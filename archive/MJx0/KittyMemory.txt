Project Path: arc_MJx0_KittyMemory_qh7qfl73

Source Tree:

```txt
arc_MJx0_KittyMemory_qh7qfl73
├── Deps
│   ├── keystone
│   ├── keystone-build-android.sh
│   └── keystone-build-ios.sh
├── KittyMemory
│   ├── Deps
│   │   └── Keystone
│   │       ├── includes
│   │       │   ├── arm.h
│   │       │   ├── arm64.h
│   │       │   ├── evm.h
│   │       │   ├── hexagon.h
│   │       │   ├── keystone.h
│   │       │   ├── mips.h
│   │       │   ├── ppc.h
│   │       │   ├── riscv.h
│   │       │   ├── sparc.h
│   │       │   ├── systemz.h
│   │       │   └── x86.h
│   │       ├── libs-android
│   │       │   ├── arm64-v8a
│   │       │   │   └── libkeystone.a
│   │       │   ├── armeabi-v7a
│   │       │   │   └── libkeystone.a
│   │       │   ├── x86
│   │       │   │   └── libkeystone.a
│   │       │   └── x86_64
│   │       │       └── libkeystone.a
│   │       └── libs-ios
│   │           ├── arm64
│   │           │   └── libkeystone.a
│   │           ├── arm64e
│   │           │   └── libkeystone.a
│   │           └── arm64e_old
│   │               └── libkeystone.a
│   ├── KittyAsm.cpp
│   ├── KittyAsm.hpp
│   ├── KittyIOFile.cpp
│   ├── KittyIOFile.hpp
│   ├── KittyInclude.hpp
│   ├── KittyMemory.cpp
│   ├── KittyMemory.hpp
│   ├── KittyPtrValidator.cpp
│   ├── KittyPtrValidator.hpp
│   ├── KittyScanner.cpp
│   ├── KittyScanner.hpp
│   ├── KittyUtils.cpp
│   ├── KittyUtils.hpp
│   ├── MemoryBackup.cpp
│   ├── MemoryBackup.hpp
│   ├── MemoryPatch.cpp
│   ├── MemoryPatch.hpp
│   └── writeData.hpp
├── LICENSE
├── README.md
├── example-android
│   ├── Android.mk
│   ├── Application.mk
│   ├── CMakeLists.txt
│   ├── README.md
│   ├── build.bat
│   ├── build.sh
│   ├── clean.bat
│   ├── clean.sh
│   └── example.cpp
└── example-ios
    ├── README.md
    ├── Tweak.mm
    ├── control
    └── example.plist

```

`Deps/keystone-build-android.sh`:

```sh
#!/bin/bash

## set ndk home
## NDK_HOME=

PWD=$(pwd)
SOURCE_PATH=${PWD}/keystone
BUILD_PATH=${PWD}/_keystone_builds_android
ARCH_TARGETS="armeabi-v7a arm64-v8a x86 x86_64"

rm -rf ${BUILD_PATH}
rm -rf ${SOURCE_PATH}

git clone https://github.com/keystone-engine/keystone.git keystone

for ARCH_TARGET in ${ARCH_TARGETS}
do
    TARGET_BUILD_PATH=${BUILD_PATH}/${ARCH_TARGET}/build
    echo "~: Building ${ARCH_TARGET} :~"
    echo "~: Path: ${TARGET_BUILD_PATH} :~"

    mkdir -p ${TARGET_BUILD_PATH}
    cd ${TARGET_BUILD_PATH}

    cmake -DBUILD_LIBS_ONLY=1 -DBUILD_SHARED_LIBS=0 ${SOURCE_PATH} -G"Unix Makefiles" \
    -DCMAKE_SYSTEM_NAME=Android \
    -DCMAKE_SYSTEM_VERSION=21 \
    -DCMAKE_ANDROID_NDK=${NDK_HOME} \
    -DCMAKE_ANDROID_ARCH_ABI=${ARCH_TARGET} \
    -DCMAKE_ANDROID_STL_TYPE=c++_static \
    -DCMAKE_BUILD_TYPE=Release
    
    make -j8

    cd -

    cp ${TARGET_BUILD_PATH}/llvm/lib/libkeystone.a ${BUILD_PATH}/${ARCH_TARGET}
    echo "Binary built ${BUILD_PATH}/${ARCH_TARGET}/libkeystone.a"
done

```

`Deps/keystone-build-ios.sh`:

```sh
#!/bin/bash

PWD=$(pwd)
SOURCE_PATH=${PWD}/keystone
BUILD_PATH=${PWD}/_keystone_builds_ios
ARCH_TARGETS="arm64 arm64e"

rm -rf ${BUILD_PATH}
rm -rf ${SOURCE_PATH}

git clone https://github.com/keystone-engine/keystone.git keystone

for ARCH_TARGET in ${ARCH_TARGETS}
do
    TARGET_BUILD_PATH=${BUILD_PATH}/${ARCH_TARGET}/build

    mkdir -p ${TARGET_BUILD_PATH}
    cd ${TARGET_BUILD_PATH}

    cmake -DBUILD_LIBS_ONLY=1 -DBUILD_SHARED_LIBS=0 ${SOURCE_PATH} -G"Unix Makefiles" \
    -DCMAKE_SYSTEM_NAME=iOS \
    -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0 \
    -DCMAKE_OSX_ARCHITECTURES=${ARCH_TARGET} \
    -DCMAKE_XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH=NO \
    -DCMAKE_BUILD_TYPE=Release
    
    make -j8

    cd -

    cp ${TARGET_BUILD_PATH}/llvm/lib/libkeystone.a ${BUILD_PATH}/${ARCH_TARGET}
    echo "Binary built ${BUILD_PATH}/${ARCH_TARGET}/libkeystone.a"
done

```

`KittyMemory/Deps/Keystone/includes/arm.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_ARM_H
#define KEYSTONE_ARM_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_arm {
    KS_ERR_ASM_ARM_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_ARM_MISSINGFEATURE,
    KS_ERR_ASM_ARM_MNEMONICFAIL,
} ks_err_asm_arm;

#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/arm64.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_ARM64_H
#define KEYSTONE_ARM64_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_arm64 {
    KS_ERR_ASM_ARM64_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_ARM64_MISSINGFEATURE,
    KS_ERR_ASM_ARM64_MNEMONICFAIL,
} ks_err_asm_arm64;

#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/evm.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016-2018 */

#ifndef KEYSTONE_EVM_H
#define KEYSTONE_EVM_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_evm {
    KS_ERR_ASM_EVM_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_EVM_MISSINGFEATURE,
    KS_ERR_ASM_EVM_MNEMONICFAIL,
} ks_err_asm_evm;

#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/hexagon.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_HEXAGON_H
#define KEYSTONE_HEXAGON_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_hexagon {
    KS_ERR_ASM_HEXAGON_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_HEXAGON_MISSINGFEATURE,
    KS_ERR_ASM_HEXAGON_MNEMONICFAIL,
} ks_err_asm_hexagon;


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/keystone.h`:

```h
/* Keystone Assembler Engine (www.keystone-engine.org) */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2016 */

#ifndef KEYSTONE_ENGINE_H
#define KEYSTONE_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>

#ifdef _MSC_VER     // MSVC compiler
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#ifndef KEYSTONE_STATIC
#define KEYSTONE_EXPORT __declspec(dllexport)
#else
#define KEYSTONE_EXPORT
#endif
#else
#ifdef __GNUC__
#include <stdbool.h>
#ifndef KEYSTONE_STATIC
#define KEYSTONE_EXPORT __attribute__((visibility("default")))
#else
#define KEYSTONE_EXPORT
#endif
#else
#define KEYSTONE_EXPORT
#endif
#endif


struct ks_struct;
typedef struct ks_struct ks_engine;

// Keystone API version
#define KS_API_MAJOR 0
#define KS_API_MINOR 9

// Package version
#define KS_VERSION_MAJOR KS_API_MAJOR
#define KS_VERSION_MINOR KS_API_MINOR
#define KS_VERSION_EXTRA 2

/*
  Macro to create combined version which can be compared to
  result of ks_version() API.
*/
#define KS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Architecture type
typedef enum ks_arch {
    KS_ARCH_ARM = 1,    // ARM architecture (including Thumb, Thumb-2)
    KS_ARCH_ARM64,      // ARM-64, also called AArch64
    KS_ARCH_MIPS,       // Mips architecture
    KS_ARCH_X86,        // X86 architecture (including x86 & x86-64)
    KS_ARCH_PPC,        // PowerPC architecture (currently unsupported)
    KS_ARCH_SPARC,      // Sparc architecture
    KS_ARCH_SYSTEMZ,    // SystemZ architecture (S390X)
    KS_ARCH_HEXAGON,    // Hexagon architecture
    KS_ARCH_EVM,        // Ethereum Virtual Machine architecture
    KS_ARCH_RISCV,      // RISC-V architecture
    KS_ARCH_MAX,
} ks_arch;

// Mode type
typedef enum ks_mode {
    KS_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    KS_MODE_BIG_ENDIAN = 1 << 30, // big-endian mode
    // arm / arm64
    KS_MODE_ARM = 1 << 0,              // ARM mode
    KS_MODE_THUMB = 1 << 4,       // THUMB mode (including Thumb-2)
    KS_MODE_V8 = 1 << 6,          // ARMv8 A32 encodings for ARM
    // mips
    KS_MODE_MICRO = 1 << 4,       // MicroMips mode
    KS_MODE_MIPS3 = 1 << 5,       // Mips III ISA
    KS_MODE_MIPS32R6 = 1 << 6,    // Mips32r6 ISA
    KS_MODE_MIPS32 = 1 << 2,      // Mips32 ISA
    KS_MODE_MIPS64 = 1 << 3,      // Mips64 ISA
    // x86 / x64
    KS_MODE_16 = 1 << 1,          // 16-bit mode
    KS_MODE_32 = 1 << 2,          // 32-bit mode
    KS_MODE_64 = 1 << 3,          // 64-bit mode
    // ppc 
    KS_MODE_PPC32 = 1 << 2,       // 32-bit mode
    KS_MODE_PPC64 = 1 << 3,       // 64-bit mode
    KS_MODE_QPX = 1 << 4,         // Quad Processing eXtensions mode
        //riscv
    KS_MODE_RISCV32 = 1 << 2,     // 32-bit mode
    KS_MODE_RISCV64 = 1 << 3,     // 64-bit mode
    // sparc
    KS_MODE_SPARC32 = 1 << 2,     // 32-bit mode
    KS_MODE_SPARC64 = 1 << 3,     // 64-bit mode
    KS_MODE_V9 = 1 << 4,          // SparcV9 mode
} ks_mode;

// All generic errors related to input assembly >= KS_ERR_ASM
#define KS_ERR_ASM 128

// All architecture-specific errors related to input assembly >= KS_ERR_ASM_ARCH
#define KS_ERR_ASM_ARCH 512

// All type of errors encountered by Keystone API.
typedef enum ks_err {
    KS_ERR_OK = 0,   // No error: everything was fine
    KS_ERR_NOMEM,      // Out-Of-Memory error: ks_open(), ks_emulate()
    KS_ERR_ARCH,     // Unsupported architecture: ks_open()
    KS_ERR_HANDLE,   // Invalid handle
    KS_ERR_MODE,     // Invalid/unsupported mode: ks_open()
    KS_ERR_VERSION,  // Unsupported version (bindings)
    KS_ERR_OPT_INVALID,  // Unsupported option

    // generic input assembly errors - parser specific
    KS_ERR_ASM_EXPR_TOKEN = KS_ERR_ASM,    // unknown token in expression
    KS_ERR_ASM_DIRECTIVE_VALUE_RANGE,   // literal value out of range for directive
    KS_ERR_ASM_DIRECTIVE_ID,    // expected identifier in directive
    KS_ERR_ASM_DIRECTIVE_TOKEN, // unexpected token in directive
    KS_ERR_ASM_DIRECTIVE_STR,   // expected string in directive
    KS_ERR_ASM_DIRECTIVE_COMMA, // expected comma in directive
    KS_ERR_ASM_DIRECTIVE_RELOC_NAME, // expected relocation name in directive
    KS_ERR_ASM_DIRECTIVE_RELOC_TOKEN, // unexpected token in .reloc directive
    KS_ERR_ASM_DIRECTIVE_FPOINT,    // invalid floating point in directive
    KS_ERR_ASM_DIRECTIVE_UNKNOWN,    // unknown directive
    KS_ERR_ASM_DIRECTIVE_EQU,   // invalid equal directive
    KS_ERR_ASM_DIRECTIVE_INVALID,   // (generic) invalid directive
    KS_ERR_ASM_VARIANT_INVALID, // invalid variant
    KS_ERR_ASM_EXPR_BRACKET,    // brackets expression not supported on this target
    KS_ERR_ASM_SYMBOL_MODIFIER, // unexpected symbol modifier following '@'
    KS_ERR_ASM_SYMBOL_REDEFINED, // invalid symbol redefinition
    KS_ERR_ASM_SYMBOL_MISSING,  // cannot find a symbol
    KS_ERR_ASM_RPAREN,          // expected ')' in parentheses expression
    KS_ERR_ASM_STAT_TOKEN,      // unexpected token at start of statement
    KS_ERR_ASM_UNSUPPORTED,     // unsupported token yet
    KS_ERR_ASM_MACRO_TOKEN,     // unexpected token in macro instantiation
    KS_ERR_ASM_MACRO_PAREN,     // unbalanced parentheses in macro argument
    KS_ERR_ASM_MACRO_EQU,       // expected '=' after formal parameter identifier
    KS_ERR_ASM_MACRO_ARGS,      // too many positional arguments
    KS_ERR_ASM_MACRO_LEVELS_EXCEED, // macros cannot be nested more than 20 levels deep
    KS_ERR_ASM_MACRO_STR,    // invalid macro string
    KS_ERR_ASM_MACRO_INVALID,    // invalid macro (generic error)
    KS_ERR_ASM_ESC_BACKSLASH,   // unexpected backslash at end of escaped string
    KS_ERR_ASM_ESC_OCTAL,       // invalid octal escape sequence  (out of range)
    KS_ERR_ASM_ESC_SEQUENCE,         // invalid escape sequence (unrecognized character)
    KS_ERR_ASM_ESC_STR,         // broken escape string
    KS_ERR_ASM_TOKEN_INVALID,   // invalid token
    KS_ERR_ASM_INSN_UNSUPPORTED,   // this instruction is unsupported in this mode
    KS_ERR_ASM_FIXUP_INVALID,   // invalid fixup
    KS_ERR_ASM_LABEL_INVALID,   // invalid label
    KS_ERR_ASM_FRAGMENT_INVALID,   // invalid fragment

    // generic input assembly errors - architecture specific
    KS_ERR_ASM_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_MISSINGFEATURE,
    KS_ERR_ASM_MNEMONICFAIL,
} ks_err;

// Resolver callback to provide value for a missing symbol in @symbol.
// To handle a symbol, the resolver must put value of the symbol in @value,
// then returns True.
// If we do not resolve a missing symbol, this function must return False.
// In that case, ks_asm() would eventually return with error KS_ERR_ASM_SYMBOL_MISSING.

// To register the resolver, pass its function address to ks_option(), using
// option KS_OPT_SYM_RESOLVER. For example, see samples/sample.c.
typedef bool (*ks_sym_resolver)(const char *symbol, uint64_t *value);

// Runtime option for the Keystone engine
typedef enum ks_opt_type {
	KS_OPT_SYNTAX = 1,    // Choose syntax for input assembly
	KS_OPT_SYM_RESOLVER,  // Set symbol resolver callback
} ks_opt_type;


// Runtime option value (associated with ks_opt_type above)
typedef enum ks_opt_value {
	KS_OPT_SYNTAX_INTEL =   1 << 0, // X86 Intel syntax - default on X86 (KS_OPT_SYNTAX).
	KS_OPT_SYNTAX_ATT   =   1 << 1, // X86 ATT asm syntax (KS_OPT_SYNTAX).
	KS_OPT_SYNTAX_NASM  =   1 << 2, // X86 Nasm syntax (KS_OPT_SYNTAX).
	KS_OPT_SYNTAX_MASM  =   1 << 3, // X86 Masm syntax (KS_OPT_SYNTAX) - unsupported yet.
	KS_OPT_SYNTAX_GAS   =   1 << 4, // X86 GNU GAS syntax (KS_OPT_SYNTAX).
	KS_OPT_SYNTAX_RADIX16 = 1 << 5, // All immediates are in hex format (i.e 12 is 0x12)
} ks_opt_value;


#include "arm64.h"
#include "arm.h"
#include "evm.h"
#include "hexagon.h"
#include "mips.h"
#include "ppc.h"
#include "riscv.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro KS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
KEYSTONE_EXPORT
unsigned int ks_version(unsigned int *major, unsigned int *minor);


/*
 Determine if the given architecture is supported by this library.

 @arch: architecture type (KS_ARCH_*)

 @return True if this library supports the given arch.
*/
KEYSTONE_EXPORT
bool ks_arch_supported(ks_arch arch);


/*
 Create new instance of Keystone engine.

 @arch: architecture type (KS_ARCH_*)
 @mode: hardware mode. This is combined of KS_MODE_*
 @ks: pointer to ks_engine, which will be updated at return time

 @return KS_ERR_OK on success, or other value on failure (refer to ks_err enum
   for detailed error).
*/
KEYSTONE_EXPORT
ks_err ks_open(ks_arch arch, int mode, ks_engine **ks);


/*
 Close KS instance: MUST do to release the handle when it is not used anymore.
 NOTE: this must be called only when there is no longer usage of Keystone.
 The reason is the this API releases some cached memory, thus access to any
 Keystone API after ks_close() might crash your application.
 After this, @ks is invalid, and nolonger usable.

 @ks: pointer to a handle returned by ks_open()

 @return KS_ERR_OK on success, or other value on failure (refer to ks_err enum
   for detailed error).
*/
KEYSTONE_EXPORT
ks_err ks_close(ks_engine *ks);


/*
 Report the last error number when some API function fail.
 Like glibc's errno, ks_errno might not retain its old error once accessed.

 @ks: handle returned by ks_open()

 @return: error code of ks_err enum type (KS_ERR_*, see above)
*/
KEYSTONE_EXPORT
ks_err ks_errno(ks_engine *ks);


/*
 Return a string describing given error code.

 @code: error code (see KS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
   passed in the argument @code
 */
KEYSTONE_EXPORT
const char *ks_strerror(ks_err code);


/*
 Set option for Keystone engine at runtime

 @ks: handle returned by ks_open()
 @type: type of option to be set. See ks_opt_type
 @value: option value corresponding with @type

 @return: KS_ERR_OK on success, or other value on failure.
 Refer to ks_err enum for detailed error.
*/
KEYSTONE_EXPORT
ks_err ks_option(ks_engine *ks, ks_opt_type type, size_t value);


/*
 Assemble a string given its the buffer, size, start address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain assembled instruction.
 Resulted array of bytes containing the machine code  is put into @*encoding

 NOTE 1: this API will automatically determine memory needed to contain
 output bytes in *encoding.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 @ks: handle returned by ks_open()
 @str: NULL-terminated assembly string. Use ; or \n to separate statements.
 @address: address of the first assembly instruction, or 0 to ignore.
 @encoding: array of bytes containing encoding of input assembly string.
	   NOTE: *encoding will be allocated by this function, and should be freed
	   with ks_free() function.
 @encoding_size: size of *encoding
 @stat_count: number of statements successfully processed

 @return: 0 on success, or -1 on failure.

 On failure, call ks_errno() for error code.
*/
KEYSTONE_EXPORT
int ks_asm(ks_engine *ks,
        const char *string,
        uint64_t address,
        unsigned char **encoding, size_t *encoding_size,
        size_t *stat_count);


/*
 Free memory allocated by ks_asm()

 @p: memory allocated in @encoding argument of ks_asm()
*/
KEYSTONE_EXPORT
void ks_free(unsigned char *p);


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/mips.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_MIPS_H
#define KEYSTONE_MIPS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_mips {
    KS_ERR_ASM_MIPS_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_MIPS_MISSINGFEATURE,
    KS_ERR_ASM_MIPS_MNEMONICFAIL,
} ks_err_asm_mips;

#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/ppc.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_PPC_H
#define KEYSTONE_PPC_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_ppc {
    KS_ERR_ASM_PPC_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_PPC_MISSINGFEATURE,
    KS_ERR_ASM_PPC_MNEMONICFAIL,
} ks_err_asm_ppc;


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/riscv.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */
/* Added by Mark Juvan, 2023*/
#ifndef KEYSTONE_RISCV_H
#define KEYSTONE_RISCV_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_riscv {
    KS_ERR_ASM_RISCV_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_RISCV_MISSINGFEATURE,
    KS_ERR_ASM_RISCV_MNEMONICFAIL,
} ks_err_asm_riscv;


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/sparc.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_SPARC_H
#define KEYSTONE_SPARC_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_sparc {
    KS_ERR_ASM_SPARC_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_SPARC_MISSINGFEATURE,
    KS_ERR_ASM_SPARC_MNEMONICFAIL,
} ks_err_asm_sparc;


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/systemz.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_SYSTEMZ_H
#define KEYSTONE_SYSTEMZ_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_systemz {
    KS_ERR_ASM_SYSTEMZ_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_SYSTEMZ_MISSINGFEATURE,
    KS_ERR_ASM_SYSTEMZ_MNEMONICFAIL,
} ks_err_asm_systemz;


#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/Deps/Keystone/includes/x86.h`:

```h
/* Keystone Assembler Engine */
/* By Nguyen Anh Quynh, 2016 */

#ifndef KEYSTONE_X86_H
#define KEYSTONE_X86_H

#ifdef __cplusplus
extern "C" {
#endif

#include "keystone.h"

typedef enum ks_err_asm_x86 {
    KS_ERR_ASM_X86_INVALIDOPERAND = KS_ERR_ASM_ARCH,
    KS_ERR_ASM_X86_MISSINGFEATURE,
    KS_ERR_ASM_X86_MNEMONICFAIL,
} ks_err_asm_x86;

#ifdef __cplusplus
}
#endif

#endif

```

`KittyMemory/KittyAsm.cpp`:

```cpp
#include "KittyAsm.hpp"

// refs to
// https://github.com/CAS-Atlantic/AArch64-Encoding
// https://github.com/bminor/binutils-gdb
// https://github.com/capstone-engine/capstone
// https://github.com/qemu/QEMU
// https://reverseengineering.stackexchange.com/questions/15418/getting-function-address-by-reading-adrp-and-add-instruction-values
// https://stackoverflow.com/questions/41906688/what-are-the-semantics-of-adrp-and-adrl-instructions-in-arm-assembly

namespace KittyAsm
{
    uint32_t bits(uint32_t v, int hi, int lo)
    {
        if (hi < lo)
            return 0u;

        int width = hi - lo + 1;
        if (width >= 32)
            return v >> lo;

        uint32_t mask = (width == 32) ? 0xFFFFFFFFu : ((1u << width) - 1u);
        return (v >> lo) & mask;
    }
} // namespace KittyAsm

using namespace KittyAsm;

namespace KittyArm32
{
    EKittyInsnTypeArm32 decodeInsnType(uint32_t instr)
    {
        if ((instr & 0x0C000000) == 0x00000000)
        {
            if ((instr & 0x01E00000) == 0x00800000)
                return bits(instr, 19, 16) == 15 ? EKittyInsnTypeArm32::ADR : EKittyInsnTypeArm32::ADD;

            if ((instr & 0x01E00000) == 0x00400000)
                return bits(instr, 19, 16) == 15 ? EKittyInsnTypeArm32::ADR : EKittyInsnTypeArm32::SUB;

            if ((instr & 0x01E00000) == 0x01A00000)
                return EKittyInsnTypeArm32::MOV;
        }

        if ((instr & 0x0FF00000) == 0x02800000)
            return EKittyInsnTypeArm32::LDR_LITERAL;

        if ((instr & 0x0C500000) == 0x04100000)
            return bits(instr, 19, 16) == 15 ? EKittyInsnTypeArm32::LDR_LITERAL : EKittyInsnTypeArm32::LDR;

        if ((instr & 0x0C500000) == 0x04000000)
            return EKittyInsnTypeArm32::STR;

        if ((instr & 0x0C500000) == 0x04500000)
            return bits(instr, 19, 16) == 15 ? EKittyInsnTypeArm32::LDR_LITERAL : EKittyInsnTypeArm32::LDRB;

        if ((instr & 0x0C500000) == 0x04400000)
            return EKittyInsnTypeArm32::STRB;

        if ((instr & 0x0F1000F0) == 0x011000B0)
            return EKittyInsnTypeArm32::LDRH;

        if ((instr & 0x0F1000F0) == 0x010000B0)
            return EKittyInsnTypeArm32::STRH;

        if ((instr & 0x0F1000F0) == 0x011000D0)
            return EKittyInsnTypeArm32::LDRSB;

        if ((instr & 0x0F1000F0) == 0x011000F0)
            return EKittyInsnTypeArm32::LDRSH;

        if ((instr & 0x0F000000) == 0x0A000000)
            return bits(instr, 31, 28) == 0xE ? EKittyInsnTypeArm32::B : EKittyInsnTypeArm32::B_COND;

        if ((instr & 0x0F000000) == 0x0B000000)
            return EKittyInsnTypeArm32::BL;

        return EKittyInsnTypeArm32::UNKNOWN;
    }

    KittyInsnArm32 decodeInsn(uint32_t instr, uint32_t address)
    {
        KittyInsnArm32 insn{};

        EKittyInsnTypeArm32 insn_type = decodeInsnType(instr);
        if (insn_type == EKittyInsnTypeArm32::UNKNOWN)
            return insn;

        insn.bytes = instr;
        insn.address = address;
        insn.type = insn_type;
        insn.typeStr = typeToString(insn_type);

        switch (insn_type)
        {
        case EKittyInsnTypeArm32::UNKNOWN:
            return insn;

        case EKittyInsnTypeArm32::ADD:
        case EKittyInsnTypeArm32::SUB:
        case EKittyInsnTypeArm32::MOV:
        case EKittyInsnTypeArm32::ADR:
        {
            bool I = bit(instr, 25);
            uint32_t rn = bits(instr, 19, 16);
            uint32_t rd = bits(instr, 15, 12);
            uint32_t imm12 = bits(instr, 11, 0);
            uint32_t imm8 = bits(imm12, 7, 0);
            uint32_t rot = bits(imm12, 11, 8) * 2u;
            uint32_t imm32 = ror32(imm8, rot);
            insn.rd = regName(rd);

            if (insn_type != EKittyInsnTypeArm32::MOV)
                insn.rn = regName(rn);

            if (!I)
                insn.rt = regName(imm12);
            else
                insn.immediate = I ? imm32 : 0;

            if (rn == 15)
                insn.target = address + 8u + insn.immediate;

            break;
        }

        case EKittyInsnTypeArm32::LDRH:
        case EKittyInsnTypeArm32::LDRSH:
        case EKittyInsnTypeArm32::LDRSB:
        case EKittyInsnTypeArm32::STRH:
        {
            bool U = bit(instr, 23);
            uint32_t rn = bits(instr, 19, 16);
            uint32_t rd = bits(instr, 15, 12);
            uint32_t immH = bits(instr, 11, 8);
            uint32_t immL = bits(instr, 3, 0);
            uint32_t offset = (immH << 4) | immL;
            insn.rd = regName(rd);
            insn.rn = regName(rn);
            insn.immediate = U ? offset : -((int32_t)offset);
            break;
        }

        case EKittyInsnTypeArm32::LDR:
        case EKittyInsnTypeArm32::LDRB:
        case EKittyInsnTypeArm32::STR:
        case EKittyInsnTypeArm32::STRB:
        case EKittyInsnTypeArm32::LDR_LITERAL:
        {
            bool U = bit(instr, 23);
            uint32_t rn = bits(instr, 19, 16);
            uint32_t rd = bits(instr, 15, 12);
            uint32_t imm12 = bits(instr, 11, 0);
            insn.rd = regName(rd);
            insn.rn = regName(rn);
            insn.immediate = U ? imm12 : -((int32_t)imm12);
            // PC
            if (rn == 15)
            {
                insn.target = address + 8u + insn.immediate;
            }
            break;
        }

        case EKittyInsnTypeArm32::B:
        case EKittyInsnTypeArm32::BL:
        case EKittyInsnTypeArm32::B_COND:
        {
            uint32_t cond = bits(instr, 31, 28);
            uint32_t imm24 = bits(instr, 23, 0);
            int32_t simm = signExtend(imm24, 24) << 2;
            insn.immediate = simm;
            insn.target = address + 8u + simm;
            if (insn_type == EKittyInsnTypeArm32::B_COND)
            {
                insn.cond = branchCondName(cond);
            }
            break;
        }
        }

        return insn;
    }

    std::string typeToString(EKittyInsnTypeArm32 t)
    {
#define CASE(x)                                                                                                        \
    case EKittyInsnTypeArm32::x:                                                                                       \
        return #x;
        switch (t)
        {
            CASE(UNKNOWN)
            CASE(ADR)
            CASE(ADD)
            CASE(SUB)
            CASE(MOV)
            CASE(LDR)
            CASE(STR)
            CASE(LDRB)
            CASE(STRB)
            CASE(LDRH)
            CASE(STRH)
            CASE(LDRSH)
            CASE(LDRSB)
            CASE(LDR_LITERAL)
            CASE(B)
            CASE(BL)
            CASE(B_COND)
        }
#undef CASE
        return "UNKNOWN";
    }
} // namespace KittyArm32

namespace KittyArm64
{
    EKittyInsnTypeArm64 decodeInsnType(uint32_t instr)
    {
        // ADR
        if ((instr & 0x9F000000u) == 0x10000000u)
        {
            return EKittyInsnTypeArm64::ADR;
        }
        // ADRP
        if ((instr & 0x9F000000u) == 0x90000000u)
        {
            return EKittyInsnTypeArm64::ADRP;
        }

        // ADD
        if ((instr & 0xFF000000u) == 0x11000000u || (instr & 0xFF000000u) == 0x91000000u)
        {
            return EKittyInsnTypeArm64::ADD;
        }
        // SUB
        if ((instr & 0xFF000000u) == 0x51000000u || (instr & 0xFF000000u) == 0xD1000000u)
        {
            return EKittyInsnTypeArm64::SUB;
        }

        // MOVZ
        if ((instr & 0x7F800000u) == 0x52800000u)
        {
            return EKittyInsnTypeArm64::MOVZ;
        }
        // MOVK
        if ((instr & 0x7F800000u) == 0x72800000u)
        {
            return EKittyInsnTypeArm64::MOVK;
        }
        // MOVN
        if ((instr & 0x7F800000u) == 0x12800000u)
        {
            return EKittyInsnTypeArm64::MOVN;
        }

        // Load/Store (immediate offset)
        {
            if ((instr & 0xFFC00000) == 0xF9400000)
                return EKittyInsnTypeArm64::LDR;
            if ((instr & 0xFFC00000) == 0xF9000000)
                return EKittyInsnTypeArm64::STR;
            if ((instr & 0xFFC00000) == 0xB9400000)
                return EKittyInsnTypeArm64::LDRW;
            if ((instr & 0xFFC00000) == 0xB9000000)
                return EKittyInsnTypeArm64::STRW;

            if ((instr & 0xFFC00000) == 0x39400000)
                return EKittyInsnTypeArm64::LDRB;
            if ((instr & 0xFFC00000) == 0x39000000)
                return EKittyInsnTypeArm64::STRB;

            if ((instr & 0xFFC00000) == 0x79400000)
                return EKittyInsnTypeArm64::LDRH;
            if ((instr & 0xFFC00000) == 0x79000000)
                return EKittyInsnTypeArm64::STRH;

            if ((instr & 0xFFC00000) == 0x39C00000 || (instr & 0xFFC00000) == 0x39800000)
                return EKittyInsnTypeArm64::LDRSB;
            if ((instr & 0xFFC00000) == 0x79C00000 || (instr & 0xFFC00000) == 0x79800000)
                return EKittyInsnTypeArm64::LDRSH;
            if ((instr & 0xFFC00000) == 0xB9800000)
                return EKittyInsnTypeArm64::LDRSW;
        }

        // Load/Store (post-indexed)
        {
            if ((instr & 0xFFC00C00) == 0xB8400400 || (instr & 0xFFC00C00) == 0xF8400400)
                return EKittyInsnTypeArm64::LDR_POST;
            if ((instr & 0xFFC00C00) == 0xB8000400 || (instr & 0xFFC00C00) == 0xF8000400)
                return EKittyInsnTypeArm64::STR_POST;

            if ((instr & 0xFFC00C00) == 0x38400400)
                return EKittyInsnTypeArm64::LDRB_POST;
            if ((instr & 0xFFC00C00) == 0x38000400)
                return EKittyInsnTypeArm64::STRB_POST;

            if ((instr & 0xFFC00C00) == 0x78400400)
                return EKittyInsnTypeArm64::LDRH_POST;
            if ((instr & 0xFFC00C00) == 0x78000400)
                return EKittyInsnTypeArm64::STRH_POST;

            if ((instr & 0xFFC00C00) == 0x38C00400 || (instr & 0xFFC00C00) == 0x38800400)
                return EKittyInsnTypeArm64::LDRSB_POST;
            if ((instr & 0xFFC00C00) == 0x78C00400 || (instr & 0xFFC00C00) == 0x78800400)
                return EKittyInsnTypeArm64::LDRSH_POST;
            if ((instr & 0xFFC00C00) == 0xB8800400)
                return EKittyInsnTypeArm64::LDRSW_POST;
        }

        // Load/Store (pre-indexed)
        {
            if ((instr & 0xFFC00C00) == 0xB8400C00 || (instr & 0xFFC00C00) == 0xF8400C00)
                return EKittyInsnTypeArm64::LDR_PRE;
            if ((instr & 0xFFC00C00) == 0xB8000C00 || (instr & 0xFFC00C00) == 0xF8000C00)
                return EKittyInsnTypeArm64::STR_PRE;

            if ((instr & 0xFFC00C00) == 0x38400C00)
                return EKittyInsnTypeArm64::LDRB_PRE;
            if ((instr & 0xFFC00C00) == 0x38000C00)
                return EKittyInsnTypeArm64::STRB_PRE;

            if ((instr & 0xFFC00C00) == 0x78400C00)
                return EKittyInsnTypeArm64::LDRH_PRE;
            if ((instr & 0xFFC00C00) == 0x78000C00)
                return EKittyInsnTypeArm64::STRH_PRE;

            if ((instr & 0xFFC00C00) == 0x38C00C00 || (instr & 0xFFC00C00) == 0x38800C00)
                return EKittyInsnTypeArm64::LDRSB_PRE;
            if ((instr & 0xFFC00C00) == 0x78C00C00 || (instr & 0xFFC00C00) == 0x78800C00)
                return EKittyInsnTypeArm64::LDRSH_PRE;
            if ((instr & 0xFFC00C00) == 0xB8800C00)
                return EKittyInsnTypeArm64::LDRSW_PRE;
        }

        // === Load/Store (unscaled)
        {
            if ((instr & 0xFFC00000) == 0xF8400000)
                return EKittyInsnTypeArm64::LDUR;
            if ((instr & 0xFFC00000) == 0xF8000000)
                return EKittyInsnTypeArm64::STUR;
            if ((instr & 0xFFC00000) == 0xB8400000)
                return EKittyInsnTypeArm64::LDURW;
            if ((instr & 0xFFC00000) == 0xB8000000)
                return EKittyInsnTypeArm64::STURW;
            if ((instr & 0xFFC00000) == 0x38400000)
                return EKittyInsnTypeArm64::LDURB;
            if ((instr & 0xFFC00000) == 0x38000000)
                return EKittyInsnTypeArm64::STURB;
            if ((instr & 0xFFC00000) == 0x78400000)
                return EKittyInsnTypeArm64::LDURH;
            if ((instr & 0xFFC00000) == 0x78000000)
                return EKittyInsnTypeArm64::STURH;
            if ((instr & 0xFFC00000) == 0xB8800000)
                return EKittyInsnTypeArm64::LDURSW;
            if ((instr & 0xFFC00000) == 0x38800000u || (instr & 0xFFC00000) == 0x38C00000u)
                return EKittyInsnTypeArm64::LDURSB;
            if ((instr & 0xFFC00000) == 0x78800000u || (instr & 0xFFC00000) == 0x78C00000u)
                return EKittyInsnTypeArm64::LDURSH;
        }

        // Load/Store (Literal)
        {
            if ((instr & 0xFFC00000) == 0x18000000)
                return EKittyInsnTypeArm64::LDRW_LITERAL;
            if ((instr & 0xFFC00000) == 0x58000000)
                return EKittyInsnTypeArm64::LDR_LITERAL;
            if ((instr & 0xFFC00000) == 0x98000000)
                return EKittyInsnTypeArm64::LDRSW_LITERAL;
        }

        // B
        if ((instr & 0xFC000000u) == 0x14000000u)
        {
            return EKittyInsnTypeArm64::B;
        }

        // BL
        if ((instr & 0xFC000000u) == 0x94000000u)
        {
            return EKittyInsnTypeArm64::BL;
        }

        // B.Cond
        if ((instr & 0xFF000010u) == 0x54000000u)
        {
            return EKittyInsnTypeArm64::B_COND;
        }

        // CBZ/CBNZ
        {
            if ((instr & 0x7F000000u) == 0x34000000u)
                return EKittyInsnTypeArm64::CBZ;
            if ((instr & 0x7F000000u) == 0x35000000u)
                return EKittyInsnTypeArm64::CBNZ;
        }

        // TBZ/TBNZ
        {
            if ((instr & 0x7F000000u) == 0x36000000u)
                return EKittyInsnTypeArm64::TBZ;
            if ((instr & 0x7F000000u) == 0x37000000u)
                return EKittyInsnTypeArm64::TBNZ;
        }

        return EKittyInsnTypeArm64::UNKNOWN;
    }

    KittyInsnArm64 decodeInsn(uint32_t instr, uint64_t address)
    {
        KittyInsnArm64 insn{};

        EKittyInsnTypeArm64 insn_type = decodeInsnType(instr);
        if (insn_type == EKittyInsnTypeArm64::UNKNOWN)
            return insn;

        insn.bytes = instr;
        insn.address = address;
        insn.type = insn_type;
        insn.typeStr = typeToString(insn_type);

        switch (insn_type)
        {
        case EKittyInsnTypeArm64::UNKNOWN:
            return insn;

        case EKittyInsnTypeArm64::ADR:
        case EKittyInsnTypeArm64::ADRP:
        {
            uint32_t rd = bits(instr, 4, 0);
            uint32_t immlo = bits(instr, 30, 29);
            uint32_t immhi = bits(instr, 23, 5);
            uint64_t imm = (uint64_t)((immhi << 2) | immlo);
            insn.rd = xRegName(rd, false);
            if (insn_type == EKittyInsnTypeArm64::ADR)
            {

                int64_t simm = signExtend(imm, 21);
                insn.immediate = simm;
                insn.target = address + simm;
            }
            else
            {
                int64_t simm = signExtend(imm, 21) << 12;
                insn.immediate = simm;
                insn.target = (address & ~0xFFFULL) + simm;
            }
            break;
        }

        case EKittyInsnTypeArm64::MOVZ:
        case EKittyInsnTypeArm64::MOVK:
        case EKittyInsnTypeArm64::MOVN:
        {
            bool is64 = bit(instr, 31);
            uint32_t rd = bits(instr, 4, 0);
            uint32_t imm16 = bits(instr, 20, 5);
            uint32_t hw = bits(instr, 22, 21);
            uint64_t imm = (uint64_t)(imm16 << (hw * 16));
            insn.rd = is64 ? xRegName(rd, false) : wRegName(rd, false);
            insn.immediate = insn_type != EKittyInsnTypeArm64::MOVN ? imm : (int64_t)~imm;
            break;
        }

        case EKittyInsnTypeArm64::ADD:
        case EKittyInsnTypeArm64::SUB:
        {
            bool is64 = bit(instr, 31);
            uint32_t rd = bits(instr, 4, 0);
            uint32_t rn = bits(instr, 9, 5);
            uint32_t imm12 = bits(instr, 21, 10);
            uint32_t sh = bits(instr, 23, 22);
            uint64_t imm = (uint64_t)(sh == 1 ? imm12 << 12 : imm12);
            insn.rd = is64 ? xRegName(rd, false) : wRegName(rd, false);
            insn.rn = is64 ? xRegName(rn, true) : wRegName(rn, true);
            insn.immediate = imm;
            break;
        }

        // ldr/str uimm12
        case EKittyInsnTypeArm64::LDR:
        case EKittyInsnTypeArm64::STR:
        case EKittyInsnTypeArm64::LDRW:
        case EKittyInsnTypeArm64::STRW:
        case EKittyInsnTypeArm64::LDRB:
        case EKittyInsnTypeArm64::STRB:
        case EKittyInsnTypeArm64::LDRH:
        case EKittyInsnTypeArm64::STRH:
        case EKittyInsnTypeArm64::LDRSB:
        case EKittyInsnTypeArm64::LDRSH:
        case EKittyInsnTypeArm64::LDRSW:
        {
            uint32_t size = bits(instr, 31, 30);
            uint32_t rn = bits(instr, 9, 5);
            uint32_t rt = bits(instr, 4, 0);
            uint32_t imm12 = bits(instr, 21, 10);
            uint64_t offset = (uint64_t)(imm12 << size);
            insn.rn = xRegName(rn, true);
            insn.rt = size == 3 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = offset;
            break;
        }

        // ldr/str post/pre indexed imm9
        case EKittyInsnTypeArm64::LDR_PRE:
        case EKittyInsnTypeArm64::STR_PRE:
        case EKittyInsnTypeArm64::LDRB_PRE:
        case EKittyInsnTypeArm64::STRB_PRE:
        case EKittyInsnTypeArm64::LDRH_PRE:
        case EKittyInsnTypeArm64::STRH_PRE:
        case EKittyInsnTypeArm64::LDRSB_PRE:
        case EKittyInsnTypeArm64::LDRSH_PRE:
        case EKittyInsnTypeArm64::LDRSW_PRE:
        case EKittyInsnTypeArm64::LDR_POST:
        case EKittyInsnTypeArm64::STR_POST:
        case EKittyInsnTypeArm64::LDRB_POST:
        case EKittyInsnTypeArm64::STRB_POST:
        case EKittyInsnTypeArm64::LDRH_POST:
        case EKittyInsnTypeArm64::STRH_POST:
        case EKittyInsnTypeArm64::LDRSB_POST:
        case EKittyInsnTypeArm64::LDRSH_POST:
        case EKittyInsnTypeArm64::LDRSW_POST:
        {
            uint32_t size = bits(instr, 31, 30);
            uint32_t rn = bits(instr, 9, 5);
            uint32_t rt = bits(instr, 4, 0);
            uint32_t imm9 = bits(instr, 20, 12);
            int64_t simm = signExtend(imm9, 9);
            insn.rn = xRegName(rn, true);
            insn.rt = size == 3 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = simm;
            break;
        }

        // imm9 unscaled ldr/str
        case EKittyInsnTypeArm64::LDUR:
        case EKittyInsnTypeArm64::STUR:
        case EKittyInsnTypeArm64::LDURW:
        case EKittyInsnTypeArm64::STURW:
        case EKittyInsnTypeArm64::LDURB:
        case EKittyInsnTypeArm64::STURB:
        case EKittyInsnTypeArm64::LDURH:
        case EKittyInsnTypeArm64::STURH:
        case EKittyInsnTypeArm64::LDURSB:
        case EKittyInsnTypeArm64::LDURSH:
        case EKittyInsnTypeArm64::LDURSW:
        {
            uint32_t size = bits(instr, 31, 30);
            uint32_t rn = bits(instr, 9, 5);
            uint32_t rt = bits(instr, 4, 0);
            uint32_t imm9 = bits(instr, 20, 12);
            int64_t simm = signExtend(imm9, 9);
            insn.rn = xRegName(rn, true);
            insn.rt = size == 3 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = simm;
            break;
        }

        case EKittyInsnTypeArm64::LDR_LITERAL:
        case EKittyInsnTypeArm64::LDRW_LITERAL:
        case EKittyInsnTypeArm64::LDRSW_LITERAL:
        {
            uint32_t size = bits(instr, 31, 30);
            uint32_t rt = bits(instr, 4, 0);
            uint32_t imm19 = bits(instr, 23, 5);
            int64_t simm = signExtend(imm19, 19) << 2;
            insn.rn = "PC";
            insn.rt = size == 3 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = simm;
            insn.target = address + simm;
            break;
        }

        case EKittyInsnTypeArm64::B:
        case EKittyInsnTypeArm64::BL:
        {
            uint32_t imm26 = bits(instr, 25, 0);
            int64_t simm = signExtend(imm26, 26) << 2;
            insn.immediate = simm;
            insn.target = address + simm;
            break;
        }

        case EKittyInsnTypeArm64::B_COND:
        {
            uint32_t cond = bits(instr, 3, 0);
            uint32_t imm19 = bits(instr, 23, 5);
            int64_t simm = signExtend(imm19, 19) << 2;
            insn.immediate = simm;
            insn.target = address + simm;
            insn.cond = branchCondName(cond);
            break;
        }

        case EKittyInsnTypeArm64::CBZ:
        case EKittyInsnTypeArm64::CBNZ:
        {
            bool is64 = bit(instr, 32);
            uint32_t imm19 = bits(instr, 23, 5);
            uint32_t rt = bits(instr, 4, 0);
            int64_t simm = signExtend(imm19, 19) << 2;
            insn.rt = is64 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = simm;
            insn.target = address + simm;
            break;
        }

        case EKittyInsnTypeArm64::TBZ:
        case EKittyInsnTypeArm64::TBNZ:
        {
            bool is64 = bit(instr, 32);
            uint32_t rt = bits(instr, 4, 0);
            uint32_t bit5 = (bits(instr, 31, 31) & 1) << 5;
            uint32_t bit_lo = bits(instr, 23, 19);
            uint32_t bitpos = bit5 | bit_lo;
            uint32_t imm14 = bits(instr, 18, 5);
            int64_t simm = signExtend(imm14, 14) << 2;
            insn.rt = is64 ? xRegName(rt, false) : wRegName(rt, false);
            insn.immediate = simm;
            insn.bitpos = bitpos;
            insn.target = address + simm;
            break;
        }
        }

        return insn;
    }

    std::string typeToString(EKittyInsnTypeArm64 t)
    {
#define CASE(x)                                                                                                        \
    case EKittyInsnTypeArm64::x:                                                                                       \
        return #x;
        switch (t)
        {
            CASE(UNKNOWN)
            CASE(ADR)
            CASE(ADRP)
            CASE(ADD)
            CASE(SUB)
            CASE(MOVZ)
            CASE(MOVN)
            CASE(MOVK)
            CASE(LDR)
            CASE(STR)
            CASE(LDRW)
            CASE(STRW)
            CASE(LDRB)
            CASE(STRB)
            CASE(LDRH)
            CASE(STRH)
            CASE(LDRSB)
            CASE(LDRSH)
            CASE(LDRSW)
            CASE(LDR_PRE)
            CASE(STR_PRE)
            CASE(LDRB_PRE)
            CASE(STRB_PRE)
            CASE(LDRH_PRE)
            CASE(STRH_PRE)
            CASE(LDRSB_PRE)
            CASE(LDRSH_PRE)
            CASE(LDRSW_PRE)
            CASE(LDR_POST)
            CASE(STR_POST)
            CASE(LDRB_POST)
            CASE(STRB_POST)
            CASE(LDRH_POST)
            CASE(STRH_POST)
            CASE(LDRSB_POST)
            CASE(LDRSH_POST)
            CASE(LDRSW_POST)
            CASE(LDUR)
            CASE(STUR)
            CASE(LDURW)
            CASE(STURW)
            CASE(LDURB)
            CASE(STURB)
            CASE(LDURH)
            CASE(STURH)
            CASE(LDURSB)
            CASE(LDURSH)
            CASE(LDURSW)
            CASE(LDR_LITERAL)
            CASE(LDRW_LITERAL)
            CASE(LDRSW_LITERAL)
            CASE(B)
            CASE(BL)
            CASE(B_COND)
            CASE(CBZ)
            CASE(CBNZ)
            CASE(TBZ)
            CASE(TBNZ)
        }
#undef CASE
        return "UNKNOWN";
    }
} // namespace KittyArm64
```

`KittyMemory/KittyAsm.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

enum class EKittyInsnTypeArm32
{
    UNKNOWN,
    ADR,
    ADD,
    SUB,
    MOV,
    LDR,
    STR,
    LDRB,
    STRB,
    LDRH,
    STRH,
    LDRSB,
    LDRSH,
    LDR_LITERAL,
    B,
    BL,
    B_COND
};

struct KittyInsnArm32
{
    EKittyInsnTypeArm32 type;
    std::string typeStr;
    std::string rd, rn, rt;
    uint32_t bytes;
    uint32_t address;
    int32_t immediate;
    uint32_t target;
    std::string cond;
    KittyInsnArm32() : type(EKittyInsnTypeArm32::UNKNOWN), bytes(0), address(0), immediate(0), target(0)
    {
    }
    inline bool isValid() const
    {
        return bytes != 0 && type != EKittyInsnTypeArm32::UNKNOWN;
    }
};

enum class EKittyInsnTypeArm64
{
    UNKNOWN,
    ADR,
    ADRP,
    ADD,
    SUB,
    MOVZ,
    MOVN,
    MOVK,
    LDR,
    STR,
    LDRW,
    STRW,
    LDRB,
    STRB,
    LDRH,
    STRH,
    LDRSB,
    LDRSH,
    LDRSW,
    LDR_PRE,
    STR_PRE,
    LDRB_PRE,
    STRB_PRE,
    LDRH_PRE,
    STRH_PRE,
    LDRSB_PRE,
    LDRSH_PRE,
    LDRSW_PRE,
    LDR_POST,
    STR_POST,
    LDRB_POST,
    STRB_POST,
    LDRH_POST,
    STRH_POST,
    LDRSB_POST,
    LDRSH_POST,
    LDRSW_POST,
    LDUR,
    STUR,
    LDURW,
    STURW,
    LDURB,
    STURB,
    LDURH,
    STURH,
    LDURSB,
    LDURSH,
    LDURSW,
    LDR_LITERAL,
    LDRW_LITERAL,
    LDRSW_LITERAL,
    B,
    BL,
    B_COND,
    CBZ,
    CBNZ,
    TBZ,
    TBNZ,
};

struct KittyInsnArm64
{
    EKittyInsnTypeArm64 type = EKittyInsnTypeArm64::UNKNOWN;
    std::string typeStr;
    std::string rd, rn, rt;
    uint32_t bytes;
    uint64_t address;
    int64_t immediate;
    int64_t bitpos;
    uint64_t target;
    std::string cond;
    KittyInsnArm64() : type(EKittyInsnTypeArm64::UNKNOWN), bytes(0), address(0), immediate(0), bitpos(0), target(0)
    {
    }
    inline bool isValid() const
    {
        return bytes != 0 && type != EKittyInsnTypeArm64::UNKNOWN;
    }
};

namespace KittyAsm
{
    uint32_t bits(uint32_t v, int hi, int lo);

    inline bool bit(uint32_t v, int pos)
    {
        return bits(v, pos, pos) != 0;
    }

    inline uint32_t ror32(uint32_t value, unsigned int shift)
    {
        shift &= 31u;
        return (value >> shift) | (value << ((32 - shift) & 31u));
    }
} // namespace KittyAsm

namespace KittyArm32
{
    inline int32_t signExtend(uint32_t val, int bits)
    {
        if (bits <= 0 || bits >= 64)
            return (int32_t)val;

        uint32_t m = 1ULL << (bits - 1);
        return (int32_t)((val ^ m) - m);
    }

    inline std::string regName(unsigned r)
    {
        if (r == 13)
            return "sp";
        if (r == 14)
            return "lr";
        if (r == 15)
            return "pc";

        std::string reg = "r";
        return reg + std::to_string(r);
    }

    inline std::string branchCondName(uint32_t cond)
    {
        static const char *names[16] = {"EQ", "NE", "CS/HS", "CC/LO", "MI", "PL", "VS", "VC",
                                        "HI", "LS", "GE",    "LT",    "GT", "LE", "AL", "NV"};
        uint32_t index = cond & 0xF;
        return index < 16 ? names[index] : "";
    }

    EKittyInsnTypeArm32 decodeInsnType(uint32_t instr);

    KittyInsnArm32 decodeInsn(uint32_t instr, uint32_t address = 0);

    std::string typeToString(EKittyInsnTypeArm32 t);
} // namespace KittyArm32

namespace KittyArm64
{
    inline int64_t signExtend(uint32_t val, int bits)
    {
        if (bits <= 0 || bits >= 64)
            return (int64_t)val;

        uint64_t m = 1ULL << (bits - 1);
        return (int64_t)((val ^ m) - m);
    }

    inline std::string xRegName(unsigned reg, bool isRn)
    {
        if (reg == 31)
        {
            return isRn ? "SP" : "XZR";
        }
        return std::string("X") + std::to_string(reg);
    }

    inline std::string wRegName(unsigned reg, bool isRn)
    {
        if (reg == 31)
        {
            return isRn ? "SP" : "WZR";
        }
        return std::string("W") + std::to_string(reg);
    }

    inline std::string branchCondName(uint32_t cond)
    {
        static const char *names[16] = {"EQ", "NE", "HS", "LO", "MI", "PL", "VS", "VC",
                                        "HI", "LS", "GE", "LT", "GT", "LE", "AL", "NV"};
        uint32_t index = cond & 0xF;
        return index < 16 ? names[index] : "";
    }

    EKittyInsnTypeArm64 decodeInsnType(uint32_t instr);

    KittyInsnArm64 decodeInsn(uint32_t instr, uint64_t address = 0);

    std::string typeToString(EKittyInsnTypeArm64 t);
} // namespace KittyArm64
```

`KittyMemory/KittyIOFile.cpp`:

```cpp
#include "KittyIOFile.hpp"

bool KittyIOFile::Open()
{
    if (_fd <= 0)
    {
        errno = 0, _error = 0;
        if (_mode)
            _fd = open(_filePath.c_str(), _flags, _mode);
        else
            _fd = open(_filePath.c_str(), _flags);

        _error = _fd > 0 ? 0 : errno;
    }
    return _fd > 0;
}

bool KittyIOFile::Close()
{
    bool rt = true;
    if (_fd > 0)
    {
        errno = 0, _error = 0;
        rt = close(_fd) != -1;
        if (!rt)
            _error = errno;

        _fd = 0;
    }
    return rt;
}

ssize_t KittyIOFile::Read(void *buffer, size_t len)
{
    char *buf = (char *)buffer;
    size_t bytesRead = 0;
    do
    {
        errno = 0, _error = 0;
        ssize_t readSize = KT_EINTR_RETRY(read(_fd, buf + bytesRead, len - bytesRead));
        if (readSize <= 0)
        {
            if (readSize < 0)
                _error = errno;
            break;
        }

        bytesRead += readSize;
    } while (bytesRead < len);
    return bytesRead;
}

ssize_t KittyIOFile::Write(const void *buffer, size_t len)
{
    const char *buf = (const char *)buffer;
    size_t bytesWritten = 0;
    do
    {
        errno = 0, _error = 0;
        ssize_t writeSize = KT_EINTR_RETRY(write(_fd, buf + bytesWritten, len - bytesWritten));
        if (writeSize <= 0)
        {
            if (writeSize < 0)
                _error = errno;
            break;
        }

        bytesWritten += writeSize;
    } while (bytesWritten < len);
    return bytesWritten;
}

ssize_t KittyIOFile::Read(uintptr_t offset, void *buffer, size_t len)
{
    char *buf = (char *)buffer;
    size_t bytesRead = 0;
    do
    {
        errno = 0, _error = 0;
#ifdef __APPLE__
        ssize_t readSize = KT_EINTR_RETRY(pread(_fd, buf + bytesRead, len - bytesRead, offset + bytesRead));
#else
        ssize_t readSize = KT_EINTR_RETRY(pread64(_fd, buf + bytesRead, len - bytesRead, offset + bytesRead));
#endif
        if (readSize <= 0)
        {
            if (readSize < 0)
                _error = errno;
            break;
        }

        bytesRead += readSize;
    } while (bytesRead < len);
    return bytesRead;
}

ssize_t KittyIOFile::Write(uintptr_t offset, const void *buffer, size_t len)
{
    const char *buf = (const char *)buffer;
    size_t bytesWritten = 0;
    do
    {
        errno = 0, _error = 0;
#ifdef __APPLE__
        ssize_t writeSize = KT_EINTR_RETRY(pwrite(_fd, buf + bytesWritten, len - bytesWritten, offset + bytesWritten));
#else
        ssize_t writeSize = KT_EINTR_RETRY(pwrite64(_fd, buf + bytesWritten, len - bytesWritten, offset + bytesWritten));
#endif
        if (writeSize <= 0)
        {
            if (writeSize < 0)
                _error = errno;
            break;
        }

        bytesWritten += writeSize;
    } while (bytesWritten < len);
    return bytesWritten;
}

#ifdef __APPLE__
struct stat KittyIOFile::Stat()
{
    errno = 0, _error = 0;
    struct stat s;
    if (stat(_filePath.c_str(), &s) == -1)
        _error = errno;
    return s;
}
#else
struct stat64 KittyIOFile::Stat()
{
    errno = 0, _error = 0;
    struct stat64 s;
    if (stat64(_filePath.c_str(), &s) == -1)
        _error = errno;
    return s;
}
#endif

bool KittyIOFile::readToString(std::string *str)
{
    if (!str)
        return false;

    str->clear();

    const ssize_t flen = Stat().st_size;
    if (flen > 0)
    {
        str->resize(flen, 0);
        return Read(0, (void*)(str->data()), flen) == flen;
    }

    // incase stat fails to get file size
    std::vector<char> tmp_buf(KT_IO_BUFFER_MAX_SIZE, 0);
    ssize_t n = 0, off = 0;
    while ((n = Read(off, tmp_buf.data(), KT_IO_BUFFER_MAX_SIZE)) > 0)
    {
        off += n;
        str->append(tmp_buf.data(), n);
    }

    return n != -1;
}

bool KittyIOFile::readToBuffer(std::vector<char> *buf)
{
    if (!buf)
        return false;

    buf->clear();

    const ssize_t flen = Stat().st_size;
    if (flen > 0)
    {
        buf->resize(flen, 0);
        return Read(0, buf->data(), flen) == flen;
    }

    // incase stat fails to get file size
    std::vector<char> tmp_buf(KT_IO_BUFFER_MAX_SIZE, 0);
    ssize_t n = 0, off = 0;
    while ((n = Read(off, tmp_buf.data(), KT_IO_BUFFER_MAX_SIZE)) > 0)
    {
        off += n;
        buf->insert(buf->end(), tmp_buf.data(), tmp_buf.data() + n);
    }

    return n != -1;
}

bool KittyIOFile::writeToFile(uintptr_t offset, size_t len, const std::string &filePath)
{
    KittyIOFile of(filePath, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0666);
    of.Delete();
    if (!of.Open()) return false;

    uintptr_t woff = 0;
    std::vector<char> buf(KT_IO_BUFFER_MAX_SIZE);

    while (len)
    {
        memset(buf.data(), 0, buf.size());

        ssize_t nread = Read(offset, buf.data(), buf.size());
        if (nread <= 0)
            break;

        if (of.Write(woff, buf.data(), nread) != nread)
            break;

        offset += nread;
        len -= nread;
        woff += nread;
    }

    return ssize_t(len) <= 0;
}

bool KittyIOFile::writeToFile(const std::string &filePath)
{
    ssize_t size = Stat().st_size;
    if (size)
    {
        return writeToFile(0, size, filePath);
    }

    KittyIOFile of(filePath, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0666);
    of.Delete();
    if (!of.Open()) return false;

    uintptr_t offset = 0;
    std::vector<char> buf(KT_IO_BUFFER_MAX_SIZE);

    while (true)
    {
        memset(buf.data(), 0, buf.size());

        ssize_t nread = Read(offset, buf.data(), buf.size());
        if (nread <= 0)
            break;

        if (of.Write(offset, buf.data(), nread) != nread)
            return false;

        offset += nread;
    }
    
    return true;
}

bool KittyIOFile::writeToFd(int fd)
{
    if (fd <= 0)
        return false;

    std::vector<char> buf;
    if (!readToBuffer(&buf) || buf.empty())
        return false;

    char *ptr = buf.data();
    ssize_t len = buf.size();

    do
    {
        ssize_t nwritten = KT_EINTR_RETRY(write(fd, ptr, len));
        if (nwritten <= 0)
        {
            _error = errno;
            return false;
        }

        ptr += nwritten;
        len -= nwritten;
    } while (len > 0);

    return true;
}

bool KittyIOFile::readFileToString(const std::string& filePath, std::string* str)
{
    KittyIOFile of(filePath, O_RDONLY | O_CLOEXEC);
    return of.Open() && of.readToString(str);
}

bool KittyIOFile::readFileToBuffer(const std::string& filePath, std::vector<char>* buf)
{
    KittyIOFile of(filePath, O_RDONLY | O_CLOEXEC);
    return of.Open() && of.readToBuffer(buf);
}

bool KittyIOFile::copy(const std::string &srcFilePath, const std::string &dstFilePath)
{
    KittyIOFile src(srcFilePath, O_RDONLY | O_CLOEXEC);
    return src.Open() && src.writeToFile(dstFilePath);
}

void KittyIOFile::listFilesCallback(const std::string& dirPath, std::function<bool(const std::string&)> cb)
{
    if (auto dir = opendir(dirPath.c_str()))
    {
        while (auto f = readdir(dir))
        {
            if (f->d_name[0] == '.')
                continue;

            if (f->d_type == DT_DIR)
                listFilesCallback(dirPath + f->d_name + "/", cb);

            if (f->d_type == DT_REG)
            {
                if (cb && cb(dirPath + f->d_name)) return;
            }
        }
        closedir(dir);
    }
}
```

`KittyMemory/KittyIOFile.hpp`:

```hpp
#pragma once

#include "KittyUtils.hpp"

#define KT_IO_BUFFER_MAX_SIZE (1024*1024)

class KittyIOFile
{
private:
    int _fd;
    std::string _filePath;
    int _flags;
    mode_t _mode;
    int _error;

public:
    KittyIOFile() : _fd(0), _flags(0), _mode(0), _error(0) {}

    KittyIOFile(const std::string &filePath, int flags, mode_t mode)
        : _fd(0), _filePath(filePath), _flags(flags), _mode(mode), _error(0) {}

    KittyIOFile(const std::string &filePath, int flags)
        : _fd(0), _filePath(filePath), _flags(flags), _mode(0), _error(0) {}

    ~KittyIOFile()
    {
        if (_fd > 0)
        {
            close(_fd);
        }
    }

    bool Open();
    bool Close();

    inline int lastError() const { return _error; }
    inline std::string lastStrError() const { return _error ? strerror(_error) : ""; }

    inline int FD() const { return _fd; }
    inline std::string Path() const { return _filePath; }
    inline int Flags() const { return _flags; }
    inline mode_t Mode() const { return _mode; }

    ssize_t Read(void *buffer, size_t len);
    ssize_t Write(const void *buffer, size_t len);

    ssize_t Read(uintptr_t offset, void *buffer, size_t len);
    ssize_t Write(uintptr_t offset, const void *buffer, size_t len);

    inline bool Exists() { return access(_filePath.c_str(), F_OK) != -1; }

    inline bool canRead() { return access(_filePath.c_str(), R_OK) != -1; }
    inline bool canWrite() { return access(_filePath.c_str(), W_OK) != -1; }
    inline bool canExecute() { return access(_filePath.c_str(), X_OK) != -1; }

    inline bool isFile()
    {
        struct stat s;
        return stat(_filePath.c_str(), &s) != -1 && S_ISREG(s.st_mode);
    }

    inline bool Delete() { return unlink(_filePath.c_str()) != -1; }

#ifdef __APPLE__
    struct stat Stat();
#else
    struct stat64 Stat();
#endif

    bool readToString(std::string *str);
    bool readToBuffer(std::vector<char> *buf);

    bool writeToFile(uintptr_t offset, size_t len, const std::string &filePath);
    bool writeToFile(const std::string &filePath);

    bool writeToFd(int fd);

    static bool readFileToString(const std::string &filePath, std::string *str);
    static bool readFileToBuffer(const std::string &filePath, std::vector<char> *buf);

    static bool copy(const std::string &srcFilePath, const std::string &dstFilePath);

    static void listFilesCallback(const std::string& dir, std::function<bool(const std::string&)> cb);
};
```

`KittyMemory/KittyInclude.hpp`:

```hpp
#pragma once

#include "KittyUtils.hpp"
#include "KittyMemory.hpp"
#include "MemoryPatch.hpp"
#include "KittyScanner.hpp"
#include "KittyAsm.hpp"
#include "KittyPtrValidator.hpp"
#include "KittyIOFile.hpp"

#ifdef __ANDROID__
using KittyMemory::ProcMap;
using KittyMemory::EProcMapFilter;
using KittyScanner::RegisterNativeFn;
using KittyScanner::ElfScanner;
using KittyScanner::LinkerScanner;
using KittyScanner::EScanElfType;
using KittyScanner::EScanElfFilter;
using KittyScanner::kitty_soinfo_t;
using KittyScanner::NativeBridgeScanner;
using KittyScanner::nbItf_data_t;
using KittyScanner::KT_JNICallType;
using KittyScanner::NativeBridgeLinker;

#elif __APPLE__
#include "writeData.hpp"
using KittyMemory::seg_data_t;
using KittyMemory::MemoryFileInfo;
#endif

```

`KittyMemory/KittyMemory.cpp`:

```cpp
//
//  KittyMemory.cpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#include "KittyMemory.hpp"

#ifdef __APPLE__
#if 0
bool findMSHookMemory(void *dst, const void *src, size_t len);
#endif
extern "C"
{
    kern_return_t mach_vm_protect(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size,
                                  boolean_t set_maximum, vm_prot_t new_protection);

    kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data,
                                mach_msg_type_number_t dataCnt);

    kern_return_t mach_vm_read_overwrite(vm_map_read_t target_task, mach_vm_address_t address, mach_vm_size_t size,
                                         mach_vm_address_t data, mach_vm_size_t *outsize);
}
#endif

namespace KittyMemory
{

#ifdef __ANDROID__

    int memProtect(const void *address, size_t length, int protection)
    {
        uintptr_t pageStart = KT_PAGE_START(address);
        size_t pageLen = KT_PAGE_LEN2(address, length);
        int ret = mprotect(reinterpret_cast<void *>(pageStart), pageLen, protection);
        KITTY_LOGD("mprotect(%p, %zu, %d) = %d", (void *)pageStart, pageLen, protection, ret);
        return ret;
    }

    bool memRead(const void *address, void *buffer, size_t len)
    {
        KITTY_LOGD("memRead(%p, %p, %zu)", address, buffer, len);

        if (!address)
        {
            KITTY_LOGE("memRead err address (%p) is null", address);
            return false;
        }

        if (!buffer)
        {
            KITTY_LOGE("memRead err buffer (%p) is null", buffer);
            return false;
        }

        if (!len)
        {
            KITTY_LOGE("memRead err invalid len");
            return false;
        }

        ProcMap addressMap = getAddressMap(address);
        if (!addressMap.isValid())
        {
            KITTY_LOGE("memRead err couldn't find address (%p) in any map", address);
            return false;
        }

        if (addressMap.protection & PROT_READ)
        {
            memcpy(buffer, address, len);
            return true;
        }

        if (memProtect(address, len, addressMap.protection | PROT_READ) != 0)
        {
            KITTY_LOGE("memRead err couldn't add write perm to address (%p, len: %zu, prot: %d)", address, len,
                       addressMap.protection);
            return false;
        }

        memcpy(buffer, address, len);

        if (memProtect(address, len, addressMap.protection) != 0)
        {
            KITTY_LOGE("memRead err couldn't revert protection of address (%p, len: %zu, prot: %d)", address, len,
                       addressMap.protection);
            return false;
        }

        return true;
    }

    bool memWrite(void *address, const void *buffer, size_t len)
    {
        KITTY_LOGD("memWrite(%p, %p, %zu)", address, buffer, len);

        if (!address)
        {
            KITTY_LOGE("memWrite err address (%p) is null", address);
            return false;
        }

        if (!buffer)
        {
            KITTY_LOGE("memWrite err buffer (%p) is null", buffer);
            return false;
        }

        if (!len)
        {
            KITTY_LOGE("memWrite err invalid len");
            return false;
        }

        ProcMap addressMap = getAddressMap(address);
        if (!addressMap.isValid())
        {
            KITTY_LOGE("memWrite err couldn't find address (%p) in any map", address);
            return false;
        }

        if (addressMap.protection & PROT_WRITE)
        {
            memcpy(address, buffer, len);
            return true;
        }

        if (memProtect(address, len, KT_PROT_RWX) != 0)
        {
            KITTY_LOGE("memWrite err couldn't add write perm to address (%p, len: %zu, prot: %d)", address, len,
                       KT_PROT_RWX);
            return false;
        }

        memcpy(address, buffer, len);

        if (memProtect(address, len, KT_PROT_RX) != 0)
        {
            KITTY_LOGE("memWrite err couldn't revert protection of address (%p, len: %zu, prot: %d)", address, len,
                       KT_PROT_RX);
            return false;
        }

        return true;
    }

    std::string getProcessName()
    {
        const char *file = "/proc/self/cmdline";
        char cmdline[128] = {0};
        FILE *fp = fopen(file, "r");
        if (!fp)
        {
            KITTY_LOGE("Couldn't open file %s.", file);
            return "";
        }
        fgets(cmdline, sizeof(cmdline), fp);
        fclose(fp);
        return cmdline;
    }

    std::vector<ProcMap> getAllMaps()
    {
        std::vector<ProcMap> retMaps;
        const char *file = "/proc/self/maps";
        char line[512] = {0};

        FILE *fp = fopen(file, "r");
        if (!fp)
        {
            KITTY_LOGE("Couldn't open file %s.", file);
            return retMaps;
        }

        while (fgets(line, sizeof(line), fp))
        {
            ProcMap map;

            char perms[5] = {0}, dev[11] = {0}, pathname[256] = {0};
            // parse a line in maps file
            // (format) startAddress-endAddress perms offset dev inode pathname
            sscanf(line, "%" SCNxPTR "-%" SCNxPTR " %4s %" SCNxPTR " %s %lu %s", &map.startAddress, &map.endAddress, perms, &map.offset, dev,
                   &map.inode, pathname);

            map.length = map.endAddress - map.startAddress;
            map.dev = dev;
            map.pathname = pathname;

            if (perms[0] == 'r')
            {
                map.protection |= PROT_READ;
                map.readable = true;
            }
            if (perms[1] == 'w')
            {
                map.protection |= PROT_WRITE;
                map.writeable = true;
            }
            if (perms[2] == 'x')
            {
                map.protection |= PROT_EXEC;
                map.executable = true;
            }

            map.is_private = (perms[3] == 'p');
            map.is_shared = (perms[3] == 's');

            map.is_rx = (strncmp(perms, "r-x", 3) == 0);
            map.is_rw = (strncmp(perms, "rw-", 3) == 0);
            map.is_ro = (strncmp(perms, "r--", 3) == 0);

            retMaps.push_back(map);
        }

        fclose(fp);

        if (retMaps.empty())
        {
            KITTY_LOGE("getAllMaps err couldn't find any map");
        }
        else
        {
            std::sort(retMaps.begin(), retMaps.end(), [](const KittyMemory::ProcMap &a, const KittyMemory::ProcMap &b) {
                return a.startAddress < b.startAddress;
            });
        }

        return retMaps;
    }

    std::vector<ProcMap> getMaps(EProcMapFilter filter, const std::string &name, const std::vector<ProcMap> &maps)
    {
        std::vector<ProcMap> retMaps;

        for (auto &it : maps)
        {
            if (it.isValid())
            {
                switch (filter)
                {
                case EProcMapFilter::Equal:
                    if (it.pathname == name)
                        retMaps.push_back(it);
                    break;
                case EProcMapFilter::StartWith:
                    if (KittyUtils::String::StartsWith(it.pathname, name))
                        retMaps.push_back(it);
                    break;
                case EProcMapFilter::EndWith:
                    if (KittyUtils::String::EndsWith(it.pathname, name))
                        retMaps.push_back(it);
                    break;
                case EProcMapFilter::Contains:
                default:
                    if (KittyUtils::String::Contains(it.pathname, name))
                        retMaps.push_back(it);
                    break;
                }
            }
        }

        return retMaps;
    }

    ProcMap getAddressMap(const void *address, const std::vector<ProcMap> &maps)
    {
        if (!address)
            return {};

        ProcMap retMap{};

        for (auto &it : maps)
        {
            if (it.isValid() && it.contains((uintptr_t)address))
            {
                retMap = it;
                break;
            }
        }

        return retMap;
    }

    bool dumpMemToDisk(uintptr_t address, size_t size, const std::string &destination)
    {
        if (!address || !size || destination.empty())
            return false;

        auto allMaps = getAllMaps();

        if (!getAddressMap(address, allMaps).isValid())
            return false;

        uintptr_t endAddress = address + size;

        KittyIOFile dest(destination, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC, 0666);
        if (!dest.Open())
            return false;

        size_t bytesWritten = 0;
        for (const auto &it : allMaps)
        {
            if (it.startAddress < address)
                continue;
            if (it.startAddress >= endAddress)
                break;

            if (!it.readable && KittyMemory::memProtect((void *) (it.startAddress), it.length,
                                                        it.protection | PROT_READ) != 0)
            {
                std::vector<char> zeroData(it.length, 0);
                bytesWritten += dest.Write(zeroData.data(), zeroData.size());
            }
            else
            {
                size_t n = dest.Write((const void *)(it.startAddress), it.length);
                bytesWritten += n;
                if (n < it.length)
                {
                    std::vector<char> zeroData(it.length - n, 0);
                    bytesWritten += dest.Write(zeroData.data(), zeroData.size());
                }

                if (!it.readable)
                {
                    KittyMemory::memProtect((const void *) (it.startAddress), it.length, it.protection);
                }
            }
        }

        dest.Close();
        return bytesWritten == size;
    }

    bool dumpMemFileToDisk(const std::string &memFile, const std::string &destination)
    {
        if (!memFile.empty() || destination.empty())
            return false;

        auto fileMaps = KittyMemory::getMaps(EProcMapFilter::EndWith, memFile);
        if (fileMaps.empty())
            return false;

        auto firstMap = fileMaps.front();
        fileMaps.erase(fileMaps.begin());

        uintptr_t lastEnd = firstMap.endAddress;
        if (fileMaps.size() > 1)
        {
            for (auto &it : fileMaps)
            {
                if (firstMap.inode != it.inode || it.startAddress != lastEnd)
                    break;

                lastEnd = it.endAddress;
            }
        }

        return dumpMemToDisk(firstMap.startAddress, lastEnd - firstMap.startAddress, destination);
    }


#if defined(__aarch64__)
#define syscall_rpmv_n 270
#define syscall_wpmv_n 271
#elif defined(__arm__)
#define syscall_rpmv_n 376
#define syscall_wpmv_n 377
#elif defined(__i386__)
#define syscall_rpmv_n 347
#define syscall_wpmv_n 348
#elif defined(__x86_64__)
#define syscall_rpmv_n 310
#define syscall_wpmv_n 311
#else
#error "Unsupported ABI"
#endif

    static ssize_t syscall_process_vm_readv(pid_t pid, const iovec *lvec, unsigned long liovcnt, const iovec *rvec,
                                            unsigned long riovcnt, unsigned long flags)
    {
        return syscall(syscall_rpmv_n, pid, lvec, liovcnt, rvec, riovcnt, flags);
    }

    static ssize_t syscall_process_vm_writev(pid_t pid, const iovec *lvec, unsigned long liovcnt, const iovec *rvec,
                                             unsigned long riovcnt, unsigned long flags)
    {
        return syscall(syscall_wpmv_n, pid, lvec, liovcnt, rvec, riovcnt, flags);
    }

    size_t syscallMemOp(EPROCESS_VM_OP op, uintptr_t address, void *buffer, size_t len)
    {
        if (!address || !buffer || !len)
            return 0;

        pid_t pid = getpid();

        struct iovec lvec{.iov_base = buffer, .iov_len = 0};
        struct iovec rvec{.iov_base = reinterpret_cast<void *>(address), .iov_len = 0};

        ssize_t n = 0;
        size_t bytes_op = 0, remaining = len;
        bool op_one_page = false;
        do
        {
            size_t remaining_or_pglen = remaining;
            if (op_one_page)
                remaining_or_pglen = std::min(KT_PAGE_LEN(rvec.iov_base), remaining);

            lvec.iov_len = remaining_or_pglen;
            rvec.iov_len = remaining_or_pglen;

            errno = 0;

            if (op == EPROCESS_VM_OP::READV)
                n = KT_EINTR_RETRY(syscall_process_vm_readv(pid, &lvec, 1, &rvec, 1, 0));
            else
                n = KT_EINTR_RETRY(syscall_process_vm_writev(pid, &lvec, 1, &rvec, 1, 0));

            if (n > 0)
            {
                remaining -= n;
                bytes_op += n;
                lvec.iov_base = reinterpret_cast<char *>(lvec.iov_base) + n;
                rvec.iov_base = reinterpret_cast<char *>(rvec.iov_base) + n;
            }
            else
            {
                if (n == -1)
                {
                    int err = errno;
                    switch (err)
                    {
                    case EPERM:
                        KITTY_LOGD("Failed syscallMemOP(%p + %p, %p) | Can't access the "
                                   "address space of process ID (%d).",
                                   (void *)address, (void *)(uintptr_t(rvec.iov_base) - address), (void *)rvec.iov_len,
                                   pid);
                        break;
                    case ESRCH:
                        KITTY_LOGD("Failed syscallMemOP(%p + %p, %p) | No process with ID "
                                   "(%d) exists.",
                                   (void *)address, (void *)(uintptr_t(rvec.iov_base) - address), (void *)rvec.iov_len,
                                   pid);
                        break;
                    case ENOMEM:
                        KITTY_LOGD("Failed syscallMemOP(%p + %p, %p) | Could not allocate "
                                   "memory for internal copies of "
                                   "the iovec structures.",
                                   (void *)address, (void *)(uintptr_t(rvec.iov_base) - address), (void *)rvec.iov_len);
                        break;
                    default:
                        KITTY_LOGD("Failed syscallMemOP(%p + %p, %p) | error(%d): %s.", (void *)address,
                                   (void *)(uintptr_t(rvec.iov_base) - address), (void *)rvec.iov_len, err,
                                   strerror(err));
                    }
                }
                if (op_one_page)
                {
                    remaining -= remaining_or_pglen;
                    lvec.iov_base = reinterpret_cast<char *>(lvec.iov_base) + remaining_or_pglen;
                    rvec.iov_base = reinterpret_cast<char *>(rvec.iov_base) + remaining_or_pglen;
                }
            }
            op_one_page = n == -1 || size_t(n) != remaining_or_pglen;
        } while (remaining > 0);
        return bytes_op;
    }

#elif __APPLE__

    kern_return_t getPageInfo(vm_address_t region, vm_region_submap_short_info_64 *info_out)
    {
        vm_size_t region_len = 0;
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
        unsigned int depth = 0x1000;
        return vm_region_recurse_64(mach_task_self(), &region, &region_len, &depth, (vm_region_recurse_info_t)info_out,
                                    &info_count);
    }

    bool memRead(const void *address, void *buffer, size_t len)
    {
        KITTY_LOGD("memRead(%p, %p, %zu)", address, buffer, len);

        if (!address)
        {
            KITTY_LOGE("memRead err address (%p) is null", address);
            return false;
        }

        if (!buffer)
        {
            KITTY_LOGE("memRead err buffer (%p) is null", buffer);
            return false;
        }

        if (!len)
        {
            KITTY_LOGE("memRead err invalid len");
            return false;
        }

        mach_vm_size_t nread = 0;
        kern_return_t kret = mach_vm_read_overwrite(mach_task_self(), mach_vm_address_t(address), mach_vm_size_t(len),
                                                    mach_vm_address_t(buffer), &nread);
        if (kret != KERN_SUCCESS || nread != len)
        {
            KITTY_LOGE("memRead err vm_read failed - [ nread(%p) - kerror(%d) ]", (void *)nread, kret);
            return false;
        }

        return true;
    }

    /*
    refs to
    - https://github.com/evelyneee/ellekit/blob/main/ellekitc/ellekitc.c
    - CydiaSubstrate
    */
    Memory_Status memWrite(void *address, const void *buffer, size_t len)
    {
        KITTY_LOGD("memWrite(%p, %p, %zu)", address, buffer, len);

        if (!address)
        {
            KITTY_LOGE("memWrite err address (%p) is null.", address);
            return KMS_INV_ADDR;
        }

        if (!buffer)
        {
            KITTY_LOGE("memWrite err buffer (%p) is null.", buffer);
            return KMS_INV_BUF;
        }

        if (!len)
        {
            KITTY_LOGE("memWrite err invalid len.");
            return KMS_INV_LEN;
        }

        task_t self_task = mach_task_self();
        mach_vm_address_t page_start = mach_vm_address_t(KT_PAGE_START(address));
        size_t page_len = KT_PAGE_LEN2(address, len);

        vm_region_submap_short_info_64 page_info = {};
        kern_return_t kret = getPageInfo(page_start, &page_info);
        if (kret != KERN_SUCCESS)
        {
            KITTY_LOGE("memWrite err failed to get page info of address (%p) - kerror(%d).", address, kret);
            return KMS_ERR_GET_PAGEINFO;
        }

        // already has write perm
        if (page_info.protection & VM_PROT_WRITE)
        {
            kret = mach_vm_write(self_task, mach_vm_address_t(address), vm_offset_t(buffer),
                                 mach_msg_type_number_t(len));
            if (kret != KERN_SUCCESS)
            {
                KITTY_LOGE("memWrite err vm_write failed to write data to address (%p) - "
                           "kerror(%d).",
                           address, kret);
                return KMS_ERR_VMWRITE;
            }
            return KMS_SUCCESS;
        }

#if 0
        // check for Substrate/ellekit MSHookMemory existance first
        if (findMSHookMemory(address, buffer, len))
            return KMS_SUCCESS;
#endif

        // copy-on-write, see vm_map_protect in vm_map.c
        kret = mach_vm_protect(self_task, page_start, page_len, false, VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY);
        if (kret != KERN_SUCCESS)
        {
            KITTY_LOGE("memWrite err vm_protect(page: %p, len: %zu, prot: %d) COW failed - "
                       "kerror(%d).",
                       (void *)page_start, page_len, page_info.protection, kret);
            return KMS_ERR_PROT;
        }

        kret = mach_vm_write(self_task, mach_vm_address_t(address), vm_offset_t(buffer), mach_msg_type_number_t(len));
        if (kret != KERN_SUCCESS)
        {
            KITTY_LOGE("memWrite err vm_write failed to write data to address (%p) - kerror(%d).", address, kret);
            return KMS_ERR_VMWRITE;
        }

        kret = mach_vm_protect(self_task, page_start, page_len, false, page_info.protection);
        if (kret != KERN_SUCCESS)
        {
            KITTY_LOGE("memWrite err vm_protect(page: %p, len: %zu, prot: %d) restore failed "
                       "- kerror(%d).",
                       (void *)page_start, page_len, page_info.protection, kret);
            return KMS_ERR_PROT;
        }

        sys_icache_invalidate(reinterpret_cast<void *>(page_start), page_len);

        return KMS_SUCCESS;
    }

    MemoryFileInfo getBaseInfo()
    {
        uint32_t exeBufSize = 1024;
        std::vector<char> exeBuf(exeBufSize, 0);
        if (_NSGetExecutablePath(exeBuf.data(), &exeBufSize) == -1)
        {
            exeBuf.clear();
            exeBuf.resize(exeBufSize + 1, 0);
            _NSGetExecutablePath(exeBuf.data(), &exeBufSize);
        }

        const uint32_t imageCount = _dyld_image_count();
        int exeIdx = -1;

        for (uint32_t i = 0; i < imageCount; i++)
        {
            const mach_header *hdr = _dyld_get_image_header(i);
            if (!hdr || hdr->filetype != MH_EXECUTE)
                continue;

            // first executable
            if (exeIdx == -1)
                exeIdx = i;

            const char *name = _dyld_get_image_name(i);
            if (!name || strlen(name) != strlen(exeBuf.data()) || strcmp(name, exeBuf.data()) != 0)
                continue;

            exeIdx = i;
            break;
        }

        MemoryFileInfo _info = {};

        if (exeIdx >= 0)
        {
            _info.index = exeIdx;
#ifdef __LP64__
            _info.header = (const mach_header_64 *)_dyld_get_image_header(exeIdx);
#else
            _info.header = _dyld_get_image_header(exeIdx);
#endif
            _info.name = _dyld_get_image_name(exeIdx);
            _info.address = _dyld_get_image_vmaddr_slide(exeIdx);
        }

        return _info;
    }

    MemoryFileInfo getMemoryFileInfo(const std::string &fileName)
    {
        MemoryFileInfo _info = {};

        if (fileName.empty())
            return _info;

        const uint32_t imageCount = _dyld_image_count();

        for (uint32_t i = 0; i < imageCount; i++)
        {
            const char *name = _dyld_get_image_name(i);
            if (!name)
                continue;

            std::string fullpath(name);
            if (!KittyUtils::String::EndsWith(fullpath, fileName))
                continue;

            _info.index = i;
#ifdef __LP64__
            _info.header = (const mach_header_64 *)_dyld_get_image_header(i);
#else
            _info.header = _dyld_get_image_header(i);
#endif
            _info.name = _dyld_get_image_name(i);
            _info.address = _dyld_get_image_vmaddr_slide(i);

            break;
        }

        return _info;
    }

    uintptr_t getAbsoluteAddress(const char *fileName, uintptr_t address)
    {
        MemoryFileInfo info = {};

        if (fileName)
            info = getMemoryFileInfo(fileName);
        else
            info = getBaseInfo();

        if (!info.address)
            return 0;

        return info.address + address;
    }

#endif // __APPLE__

} // namespace KittyMemory

#ifdef __APPLE__

#if 0
#ifndef kNO_SUBSTRATE
bool findMSHookMemory(void *dst, const void *src, size_t len)
{
    static bool checked = false;
    static void *fnPtr = nullptr;

    if (!checked)
    {
        fnPtr = (void*)KittyScanner::findSymbol("/usr/lib/libsubstrate.dylib", "_MSHookMemory");
        if (!fnPtr)
            fnPtr = (void*)KittyScanner::findSymbol("/usr/lib/libellekit.dylib", "_MSHookMemory");

        checked = true;
    }

    if (fnPtr)
    {
        reinterpret_cast<void (*)(void *, const void *, size_t)>(fnPtr)(dst, src, len);
        return true;
    }

    return false;
}
#else
bool findMSHookMemory(void *, const void *, size_t) { return false; }
#endif
#endif

namespace KittyScanner
{
    uintptr_t findSymbol(const KittyMemory::MemoryFileInfo &info, const std::string &symbol)
    {
        if (!info.header || !info.address || symbol.empty())
            return 0;

        uintptr_t slide = info.address;

#ifdef __LP64__
        struct mach_header_64 *header = (struct mach_header_64 *)info.header;
        const int lc_seg = LC_SEGMENT_64;
        struct segment_command_64 *curr_seg_cmd = nullptr;
        struct segment_command_64 *linkedit_segment_cmd = nullptr;
        struct symtab_command *symtab_cmd = nullptr;
        struct nlist_64 *symtab = nullptr;
#else
        struct mach_header *header = (struct mach_header *)info.header;
        const int lc_seg = LC_SEGMENT;
        struct segment_command *curr_seg_cmd = nullptr;
        struct segment_command *linkedit_segment_cmd = nullptr;
        struct symtab_command *symtab_cmd = nullptr;
        struct nlist *symtab = nullptr;
#endif

        uintptr_t curr = uintptr_t(header) + sizeof(*header);
        for (uint32_t i = 0; i < header->ncmds; i++, curr += curr_seg_cmd->cmdsize)
        {
            *(uintptr_t *)&curr_seg_cmd = curr;

            if (curr_seg_cmd->cmd == lc_seg && (strcmp(curr_seg_cmd->segname, SEG_LINKEDIT) == 0))
                *(uintptr_t *)&linkedit_segment_cmd = curr;
            else if (curr_seg_cmd->cmd == LC_SYMTAB)
                *(uintptr_t *)&symtab_cmd = curr;
        }

        if (!linkedit_segment_cmd || !symtab_cmd)
            return 0;

        uintptr_t linkedit_base = (slide + linkedit_segment_cmd->vmaddr) - linkedit_segment_cmd->fileoff;
        *(uintptr_t *)&symtab = (linkedit_base + symtab_cmd->symoff);
        char *strtab = (char *)(linkedit_base + symtab_cmd->stroff);

        for (uint32_t i = 0; i < symtab_cmd->nsyms; i++)
        {
            if (symtab[i].n_value == 0)
                continue;

            std::string curr_sym_str = std::string(strtab + symtab[i].n_un.n_strx);

            // KITTY_LOGI("syms[%d] = [%{public}s, %p]", i, curr_sym_str.c_str(),
            // (void*)symtab[i].n_value);

            if (curr_sym_str.empty() || curr_sym_str != symbol)
                continue;

            return slide + symtab[i].n_value;
        }

        return 0;
    }

    uintptr_t findSymbol(const std::string &lib, const std::string &symbol)
    {
        return findSymbol(KittyMemory::getMemoryFileInfo(lib), symbol);
    }
} // namespace KittyScanner

#endif // __APPLE__

```

`KittyMemory/KittyMemory.hpp`:

```hpp
//
//  KittyMemory.hpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#pragma once

#include <inttypes.h>
#include <cstdio>
#include <string>
#include <unistd.h>
#include <sys/mman.h>
#include <vector>

#ifdef __ANDROID__
#include <dlfcn.h>
#include <unordered_map>

#elif __APPLE__
#include <mach/mach.h>
#include <mach-o/dyld.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <mach-o/getsect.h>
#include <libkern/OSCacheControl.h>

#endif

#include "KittyUtils.hpp"
#include "KittyIOFile.hpp"

namespace KittyMemory
{
    /*
     * Reads an address content into a buffer
     */
    bool memRead(const void *address, void *buffer, size_t len);

#ifdef __ANDROID__

    class ProcMap
    {
    public:
        uintptr_t startAddress;
        uintptr_t endAddress;
        size_t length;
        int protection;
        bool readable, writeable, executable, is_private, is_shared, is_ro, is_rw, is_rx;
        uintptr_t offset;
        std::string dev;
        unsigned long inode;
        std::string pathname;

        ProcMap()
            : startAddress(0), endAddress(0), length(0), protection(0), readable(false), writeable(false),
              executable(false), is_private(false), is_shared(false), is_ro(false), is_rw(false), is_rx(false),
              offset(0), inode(0)
        {
        }

        inline bool isValid() const
        {
            return (startAddress && endAddress && length);
        }
        inline bool isUnknown() const
        {
            return pathname.empty();
        }
        inline bool isValidELF() const
        {
            return isValid() && length > 4 && readable && memcmp((const void *)startAddress, "\177ELF", 4) == 0;
        }
        inline bool contains(uintptr_t address) const
        {
            return address >= startAddress && address < endAddress;
        }
        inline std::string toString() const
        {
            return KittyUtils::String::Fmt("%" PRIxPTR "-%" PRIxPTR " %c%c%c%c %" PRIxPTR " %s %lu %s", startAddress, endAddress,
                                           readable ? 'r' : '-', writeable ? 'w' : '-', executable ? 'x' : '-',
                                           is_private ? 'p' : 's', offset, dev.c_str(), inode, pathname.c_str());
        }
    };

    enum class EProcMapFilter
    {
        Equal,
        Contains,
        StartWith,
        EndWith
    };

    /*
     * mprotect wrapper
     */
    int memProtect(const void *address, size_t length, int protection);

    /*
     * Writes buffer content to an address
     */
    bool memWrite(void *address, const void *buffer, size_t len);

    /*
     * /proc/self/cmdline
     */
    std::string getProcessName();

    /*
     * Gets info of all maps in current process
     */
    std::vector<ProcMap> getAllMaps();

    /*
     * Gets info of all maps with filter @name in current process
     */
    std::vector<ProcMap> getMaps(EProcMapFilter filter, const std::string &name,
                                 const std::vector<ProcMap> &maps = getAllMaps());

    /*
     * Gets map info of an address in self process
     */
    ProcMap getAddressMap(const void *address, const std::vector<ProcMap> &maps = getAllMaps());
    /*
     * Gets map info of an address in self process
     */
    inline ProcMap getAddressMap(uintptr_t address, const std::vector<ProcMap> &maps = getAllMaps())
    {
        return getAddressMap((const void *)address, maps);
    }

    /**
     * Dump memory range
     */
    bool dumpMemToDisk(uintptr_t address, size_t size, const std::string &destination);

    /**
     * Dump memory mapped file
     */
    bool dumpMemFileToDisk(const std::string &memFile, const std::string &destination);

    enum class EPROCESS_VM_OP
    {
        READV,
        WRITEV
    };

    size_t syscallMemOp(EPROCESS_VM_OP op, uintptr_t address, void *buffer, size_t len);

    inline size_t syscallMemRead(uintptr_t address, void *buffer, size_t len)
    {
        return syscallMemOp(EPROCESS_VM_OP::READV, address, buffer, len);
    }

    inline size_t syscallMemRead(void *address, void *buffer, size_t len)
    {
        return syscallMemOp(EPROCESS_VM_OP::READV, uintptr_t(address), buffer, len);
    }

    inline size_t syscallMemWrite(uintptr_t address, void *buffer, size_t len)
    {
        return syscallMemOp(EPROCESS_VM_OP::WRITEV, address, buffer, len);
    }

    inline size_t syscallMemWrite(void *address, void *buffer, size_t len)
    {
        return syscallMemOp(EPROCESS_VM_OP::WRITEV, uintptr_t(address), buffer, len);
    }

#elif __APPLE__

    enum Memory_Status
    {
        KMS_FAILED = 0,
        KMS_SUCCESS,
        KMS_INV_ADDR,
        KMS_INV_LEN,
        KMS_INV_BUF,
        KMS_ERR_PROT,
        KMS_ERR_GET_PAGEINFO,
        KMS_ERR_VMWRITE,
    };

    struct seg_data_t
    {
        uintptr_t start, end;
        unsigned long size;
        seg_data_t() : start(0), end(0), size(0)
        {
        }
    };

    class MemoryFileInfo
    {
    public:
        uint32_t index;
#ifdef __LP64__
        const mach_header_64 *header;
#else
        const mach_header *header;
#endif
        const char *name;
        intptr_t address;

        MemoryFileInfo() : index(0), header(nullptr), name(nullptr), address(0)
        {
        }

        inline seg_data_t getSegment(const char *seg_name) const
        {
            seg_data_t data{};
            if (!header || !seg_name)
                return data;
            data.start = uintptr_t(getsegmentdata(header, seg_name, &data.size));
            data.end = data.start + data.size;
            return data;
        }

        inline seg_data_t getSection(const char *seg_name, const char *sect_name) const
        {
            seg_data_t data{};
            if (!header || !seg_name || !sect_name)
                return data;
            data.start = uintptr_t(getsectiondata(header, seg_name, sect_name, &data.size));
            data.end = data.start + data.size;
            return data;
        }
    };

    /*
     * Writes buffer content to an address
     */
    Memory_Status memWrite(void *address, const void *buffer, size_t len);

    /*
     * vm_region_recurse_64 wrapper
     */
    kern_return_t getPageInfo(vm_address_t region, vm_region_submap_short_info_64 *info_out);

    /*
     * returns base executable info
     */
    MemoryFileInfo getBaseInfo();

    /*
     * find in memory file info by checking if target loaded object file ends with @fileName
     */
    MemoryFileInfo getMemoryFileInfo(const std::string &fileName);

    /*
     * returns the absolue address of a relative offset of a file in memory or NULL as
     * fileName for base executable
     */
    uintptr_t getAbsoluteAddress(const char *fileName, uintptr_t address);

#endif

} // namespace KittyMemory

#ifdef __APPLE__

namespace KittyScanner
{
    uintptr_t findSymbol(const KittyMemory::MemoryFileInfo &info, const std::string &symbol);
    uintptr_t findSymbol(const std::string &lib, const std::string &symbol);
} // namespace KittyScanner

#endif // __APPLE__

```

`KittyMemory/KittyPtrValidator.cpp`:

```cpp
#include "KittyPtrValidator.hpp"

#ifdef __APPLE__

bool KittyPtrValidator::_findRegion(uintptr_t addr, RegionInfo *region)
{
    if (!use_cache_)
    {
        vm_address_t address = addr & ~(page_size_ - 1);
        vm_size_t size = 0;
        natural_t nesting_depth = 0;
        vm_region_submap_short_info_data_64_t info{};
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
        kern_return_t kret = vm_region_recurse_64(task_, &address, &size, &nesting_depth,
                                                  (vm_region_recurse_info_t)&info,
                                                  &info_count);
        if (kret != KERN_SUCCESS)
            return false;

        bool readable = (info.protection & VM_PROT_READ) != 0;
        bool writable = (info.protection & VM_PROT_WRITE) != 0;
        bool executable = (info.protection & VM_PROT_EXECUTE) != 0;
        *region = RegionInfo(address, address + size, readable, writable, executable);
        return address <= addr && addr < address + size;
    }

    if (!cachedRegions_.empty())
    {
        if (last_region_index_ < cachedRegions_.size() &&
            cachedRegions_[last_region_index_].start <= addr &&
            addr < cachedRegions_[last_region_index_].end)
        {
            *region = cachedRegions_[last_region_index_];
            return true;
        }

        size_t left = 0;
        size_t right = cachedRegions_.size();
        size_t best_match = right;

        while (left < right)
        {
            size_t mid = left + (right - left) / 2;
            if (cachedRegions_[mid].end <= addr)
            {
                left = mid + 1;
            }
            else
            {
                best_match = mid;
                right = mid;
            }
        }

        if (best_match < cachedRegions_.size() &&
            cachedRegions_[best_match].start <= addr &&
            addr < cachedRegions_[best_match].end)
        {
            last_region_index_ = best_match;
            *region = cachedRegions_[best_match];
            return true;
        }
    }

    return false;
}

void KittyPtrValidator::refreshRegionCache()
{
    cachedRegions_.clear();
    vm_address_t address = 0;

    while (true)
    {
        vm_size_t size = 0;
        natural_t nesting_depth = 0;
        vm_region_submap_short_info_data_64_t info{};
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64;
        kern_return_t kret = vm_region_recurse_64(task_, &address, &size, &nesting_depth,
                                                  (vm_region_recurse_info_t)&info,
                                                  &info_count);
        if (kret != KERN_SUCCESS)
            break;

        bool readable = (info.protection & VM_PROT_READ) != 0;
        bool writable = (info.protection & VM_PROT_WRITE) != 0;
        bool executable = (info.protection & VM_PROT_EXECUTE) != 0;
        RegionInfo new_region(address, address + size, readable, writable, executable);

        if (!cachedRegions_.empty() && cachedRegions_.back().canMergeWith(new_region))
        {
            cachedRegions_.back().end = new_region.end;
        }
        else
        {
            cachedRegions_.emplace_back(new_region);
        }

        address += size;
    }

    if (!cachedRegions_.empty())
    {
        std::sort(
            cachedRegions_.begin(), cachedRegions_.end(),
            [](const RegionInfo &a, const RegionInfo &b) { return a.start < b.start; });
    }

    last_region_index_ = 0;
}

#else

std::string KittyPtrValidator::_readMapsFile()
{
    std::string buffer;

    char filePath[256] = {0};
    snprintf(filePath, sizeof(filePath), "/proc/%d/maps", pid_);

    int fd = open(filePath, O_RDONLY);
    if (fd < 0)
        return buffer;

    char tmp_buf[4096] = {0};
    ssize_t n = 0, off = 0;
    while ((n = pread64(fd, tmp_buf, 4096, off)) > 0)
    {
        buffer.append(tmp_buf, n);
        off += n;
    }

    close(fd);

    return buffer;
}

bool KittyPtrValidator::_parseMapsLine(const std::string &line, RegionInfo *region)
{
    if (line.empty())
        return false;

    uintptr_t start, end;
    char perms[5] = {0};
    int parsed = sscanf(line.c_str(), "%" SCNxPTR "-%" SCNxPTR " %4s", &start, &end, perms);
    if (parsed != 3)
        return false;

    *region = RegionInfo(start, end, perms[0] == 'r', perms[1] == 'w', perms[2] == 'x');
    return true;
}

void KittyPtrValidator::_parseMapsFromBuffer(const std::string &buffer,
                                             std::vector<RegionInfo> *output)
{
    if (!output)
        return;

    output->clear();
    size_t pos = 0;
    while (pos < buffer.size())
    {
        size_t end = buffer.find('\n', pos);
        if (end == std::string::npos)
        {
            end = buffer.size();
        }

        std::string line(buffer.data() + pos, end - pos);
        pos = end + 1;

        RegionInfo new_region(0, 0, false, false, false);
        if (!_parseMapsLine(line, &new_region))
            continue;

        if (!output->empty() && output->back().canMergeWith(new_region))
        {
            output->back().end = new_region.end;
        }
        else
        {
            output->emplace_back(new_region);
        }
    }

    if (!output->empty())
    {
        std::sort(
            output->begin(), output->end(),
            [](const RegionInfo &a, const RegionInfo &b) { return a.start < b.start; });
    }
}

bool KittyPtrValidator::_findRegion(uintptr_t addr, RegionInfo *region)
{
    if (!use_cache_)
    {
        std::string maps_data = _readMapsFile();
        if (maps_data.empty())
            return false;

        size_t pos = 0;
        while (pos < maps_data.size())
        {
            size_t end = maps_data.find('\n', pos);
            if (end == std::string::npos)
            {
                end = maps_data.size();
            }

            std::string line(maps_data.data() + pos, end - pos);
            pos = end + 1;

            RegionInfo new_region(0, 0, false, false, false);
            if (!_parseMapsLine(line, &new_region))
                continue;

            if (new_region.start <= addr && addr < new_region.end)
            {
                *region = new_region;
                return true;
            }
        }
        return false;
    }

    if (!cachedRegions_.empty())
    {
        if (last_region_index_ < cachedRegions_.size() &&
            cachedRegions_[last_region_index_].start <= addr &&
            addr < cachedRegions_[last_region_index_].end)
        {
            *region = cachedRegions_[last_region_index_];
            return true;
        }

        size_t left = 0;
        size_t right = cachedRegions_.size();
        size_t best_match = right;

        while (left < right)
        {
            size_t mid = left + (right - left) / 2;
            if (cachedRegions_[mid].end <= addr)
            {
                left = mid + 1;
            }
            else
            {
                best_match = mid;
                right = mid;
            }
        }

        if (best_match < cachedRegions_.size() &&
            cachedRegions_[best_match].start <= addr &&
            addr < cachedRegions_[best_match].end)
        {
            last_region_index_ = best_match;
            *region = cachedRegions_[best_match];
            return true;
        }
    }

    return false;
}

void KittyPtrValidator::refreshRegionCache()
{
    cachedRegions_.clear();
    std::string maps_data = _readMapsFile();
    if (maps_data.empty())
        return;

    _parseMapsFromBuffer(maps_data, &cachedRegions_);
    last_region_index_ = 0;
}


#endif

bool KittyPtrValidator::isPtrReadable(uintptr_t ptr, size_t len)
{
    if (ptr == 0)
        return false;

    RegionInfo region(0, 0, false, false, false);
    if (!_findRegion(ptr, &region) || !region.readable)
        return false;

    if (region.end < (ptr + len))
    {
        while (len > 0)
        {
            size_t tmp_len = std::min<size_t>(len, 0x1000);
            ptr += tmp_len;
            len -= tmp_len;
            if (!_findRegion(ptr, &region) || !region.readable)
                return false;
        }
    }

    return true;
}

bool KittyPtrValidator::isPtrWritable(uintptr_t ptr, size_t len)
{
    if (ptr == 0)
        return false;

    RegionInfo region(0, 0, false, false, false);
    if (!_findRegion(ptr, &region) || !region.writable)
        return false;

    if (region.end < (ptr + len))
    {
        while (len > 0)
        {
            size_t tmp_len = std::min<size_t>(len, 0x1000);
            ptr += tmp_len;
            len -= tmp_len;
            if (!_findRegion(ptr, &region) || !region.writable)
                return false;
        }
    }

    return true;
}

bool KittyPtrValidator::isPtrExecutable(uintptr_t ptr, size_t len)
{
    if (ptr == 0)
        return false;

    RegionInfo region(0, 0, false, false, false);
    if (!_findRegion(ptr, &region) || !region.executable)
        return false;

    if (region.end < (ptr + len))
    {
        while (len > 0)
        {
            size_t tmp_len = std::min<size_t>(len, 0x1000);
            ptr += tmp_len;
            len -= tmp_len;
            if (!_findRegion(ptr, &region) || !region.executable)
                return false;
        }
    }

    return true;
}
```

`KittyMemory/KittyPtrValidator.hpp`:

```hpp
#pragma once

#include <inttypes.h>
#include <algorithm>
#include <cstdint>
#include <fcntl.h>
#include <string>
#include <sys/stat.h>
#include <unistd.h>
#include <vector>

#ifdef __APPLE__
#include <mach/mach.h>

class KittyPtrValidator
{
private:
    struct RegionInfo
    {
        uintptr_t start;
        uintptr_t end;
        bool readable;
        bool writable;
        bool executable;

        RegionInfo(uintptr_t s, uintptr_t e, bool r, bool w, bool x)
            : start(s), end(e), readable(r), writable(w), executable(x)
        {
        }

        inline bool canMergeWith(const RegionInfo &other) const
        {
            return end == other.start && readable == other.readable && writable == other.writable &&
                   executable == other.executable;
        }
    };

    std::vector<RegionInfo> cachedRegions_;
    const mach_port_t task_ = mach_task_self();
    const size_t page_size_ = sysconf(_SC_PAGESIZE);
    bool use_cache_ = true;
    size_t last_region_index_ = 0;

    bool _findRegion(uintptr_t addr, RegionInfo *region);

public:
    KittyPtrValidator()
        : task_(mach_task_self()), page_size_(sysconf(_SC_PAGESIZE)), use_cache_(false), last_region_index_(0)
    {
    }

    KittyPtrValidator(mach_port_t task, bool use_cache)
        : task_(task), page_size_(sysconf(_SC_PAGESIZE)), use_cache_(use_cache), last_region_index_(0)
    {
        if (use_cache_)
            refreshRegionCache();
    }

    inline void setUseCache(bool use_cache)
    {
        use_cache_ = use_cache;
        if (!use_cache_)
        {
            cachedRegions_.clear();
            last_region_index_ = 0;
        }
        else
        {
            refreshRegionCache();
        }
    }

    bool isPtrReadable(uintptr_t ptr, size_t len = sizeof(void *));

    bool isPtrWritable(uintptr_t ptr, size_t len = sizeof(void *));

    bool isPtrExecutable(uintptr_t ptr, size_t len = sizeof(void *));

    inline bool isPtrInAddressSpace(uintptr_t ptr)
    {
        if (ptr == 0)
            return false;
        RegionInfo region(0, 0, false, false, false);
        return _findRegion(ptr, &region);
    }

    inline bool isPtrReadable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrReadable(uintptr_t(ptr), len);
    }
    inline bool isPtrWritable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrWritable(uintptr_t(ptr), len);
    }
    inline bool isPtrExecutable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrExecutable(uintptr_t(ptr), len);
    }
    inline bool isPtrInAddressSpace(const void *ptr)
    {
        return ptr && isPtrInAddressSpace(uintptr_t(ptr));
    }

    inline void clearCache()
    {
        cachedRegions_.clear();
        last_region_index_ = 0;
    }

    void refreshRegionCache();

    inline std::vector<RegionInfo> cachedRegions() const
    {
        return cachedRegions_;
    }
};

#else

class KittyPtrValidator
{
private:
    struct RegionInfo
    {
        uintptr_t start;
        uintptr_t end;
        bool readable;
        bool writable;
        bool executable;

        RegionInfo(uintptr_t s, uintptr_t e, bool r, bool w, bool x)
            : start(s), end(e), readable(r), writable(w), executable(x)
        {
        }

        inline bool canMergeWith(const RegionInfo &other) const
        {
            return end == other.start && readable == other.readable && writable == other.writable &&
                   executable == other.executable;
        }
    };

    std::vector<RegionInfo> cachedRegions_;
    pid_t pid_ = getpid();
    const size_t page_size_ = sysconf(_SC_PAGESIZE);
    bool use_cache_ = true;
    size_t last_region_index_ = 0;

    std::string _readMapsFile();

    bool _parseMapsLine(const std::string &line, RegionInfo *region);

    void _parseMapsFromBuffer(const std::string &buffer, std::vector<RegionInfo> *output);

    bool _findRegion(uintptr_t addr, RegionInfo *region);

public:
    KittyPtrValidator() : pid_(getpid()), page_size_(sysconf(_SC_PAGESIZE)), use_cache_(false), last_region_index_(0)
    {
    }

    KittyPtrValidator(pid_t pid, bool use_cache)
        : pid_(pid), page_size_(sysconf(_SC_PAGESIZE)), use_cache_(use_cache), last_region_index_(0)
    {
        if (use_cache_)
            refreshRegionCache();
    }

    inline void setUseCache(bool use_cache)
    {
        use_cache_ = use_cache;
        if (!use_cache_)
        {
            cachedRegions_.clear();
            last_region_index_ = 0;
        }
        else
        {
            refreshRegionCache();
        }
    }

    inline void setPID(pid_t pid)
    {
        cachedRegions_.clear();
        last_region_index_ = 0;
        pid_ = pid;

        if (use_cache_)
        {
            refreshRegionCache();
        }
    }

    bool isPtrReadable(uintptr_t ptr, size_t len = sizeof(void *));

    bool isPtrWritable(uintptr_t ptr, size_t len = sizeof(void *));

    bool isPtrExecutable(uintptr_t ptr, size_t len = sizeof(void *));

    inline bool isPtrInAddressSpace(uintptr_t ptr)
    {
        if (ptr == 0)
            return false;
        RegionInfo region(0, 0, false, false, false);
        return _findRegion(ptr, &region);
    }

    inline bool isPtrReadable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrReadable(uintptr_t(ptr), len);
    }
    inline bool isPtrWritable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrWritable(uintptr_t(ptr), len);
    }
    inline bool isPtrExecutable(const void *ptr, size_t len = sizeof(void *))
    {
        return ptr && isPtrExecutable(uintptr_t(ptr), len);
    }
    inline bool isPtrInAddressSpace(const void *ptr)
    {
        return ptr && isPtrInAddressSpace(uintptr_t(ptr));
    }

    inline void clearCache()
    {
        cachedRegions_.clear();
        last_region_index_ = 0;
    }

    void refreshRegionCache();

    inline std::vector<RegionInfo> cachedRegions() const
    {
        return cachedRegions_;
    }
};

#endif

```

`KittyMemory/KittyScanner.cpp`:

```cpp
#include "KittyScanner.hpp"
#include "KittyPtrValidator.hpp"
#include <cstdint>
#include <cstring>
#include <fcntl.h>
#include <sys/stat.h>

#include "KittyUtils.hpp"

// refs
// https://github.com/learn-more/findpattern-bench

namespace KittyScanner
{

    bool compare(const char *data, const char *pattern, const char *mask)
    {
        for (; *mask; ++mask, ++data, ++pattern)
        {
            if (*mask == 'x' && *data != *pattern)
                return false;
        }
        return !*mask;
    }

    uintptr_t findInRange(const uintptr_t start, const uintptr_t end, const char *pattern, const std::string &mask)
    {
        const size_t scan_size = mask.length();

        if (scan_size < 1 || ((start + scan_size) > end))
            return 0;

        const size_t length = end - start;

        for (size_t i = 0; i < length; ++i)
        {
            const uintptr_t current_end = start + i + scan_size;
            if (current_end > end)
                break;

            if (!compare(reinterpret_cast<const char *>(start + i), pattern, mask.c_str()))
                continue;

            return start + i;
        }
        return 0;
    }

    std::vector<uintptr_t> findBytesAll(const uintptr_t start, const uintptr_t end, const char *bytes,
                                        const std::string &mask)
    {
        std::vector<uintptr_t> list;

        if (start >= end || !bytes || mask.empty())
            return list;

        uintptr_t curr_search_address = start;
        const size_t scan_size = mask.length();
        do
        {
            if (!list.empty())
                curr_search_address = list.back() + scan_size;

            uintptr_t found = findInRange(curr_search_address, end, bytes, mask);
            if (!found)
                break;

            list.push_back(found);
        } while (true);

        return list;
    }

    uintptr_t findBytesFirst(const uintptr_t start, const uintptr_t end, const char *bytes, const std::string &mask)
    {
        if (start >= end || !bytes || mask.empty())
            return 0;

        return findInRange(start, end, bytes, mask);
    }

    std::vector<uintptr_t> findHexAll(const uintptr_t start, const uintptr_t end, std::string hex,
                                      const std::string &mask)
    {
        std::vector<uintptr_t> list;

        if (start >= end || mask.empty() || !KittyUtils::String::ValidateHex(hex))
            return list;

        const size_t scan_size = mask.length();
        if ((hex.length() / 2) != scan_size)
            return list;

        std::vector<char> pattern(scan_size);
        KittyUtils::dataFromHex(hex, &pattern[0]);

        list = findBytesAll(start, end, pattern.data(), mask);
        return list;
    }

    uintptr_t findHexFirst(const uintptr_t start, const uintptr_t end, std::string hex, const std::string &mask)
    {
        if (start >= end || mask.empty() || !KittyUtils::String::ValidateHex(hex))
            return 0;

        const size_t scan_size = mask.length();
        if ((hex.length() / 2) != scan_size)
            return 0;

        std::vector<char> pattern(scan_size);
        KittyUtils::dataFromHex(hex, &pattern[0]);

        return findBytesFirst(start, end, pattern.data(), mask);
    }

    std::vector<uintptr_t> findIdaPatternAll(const uintptr_t start, const uintptr_t end, const std::string &pattern)
    {
        std::vector<uintptr_t> list;

        if (start >= end)
            return list;

        std::string mask;
        std::vector<char> bytes;

        const size_t pattren_len = pattern.length();
        for (std::size_t i = 0; i < pattren_len; i++)
        {
            if (pattern[i] == ' ')
                continue;

            if (pattern[i] == '?')
            {
                bytes.push_back(0);
                mask += '?';
            }
            else if (pattren_len > i + 1 && std::isxdigit(pattern[i]) && std::isxdigit(pattern[i + 1]))
            {
                bytes.push_back(std::stoi(pattern.substr(i++, 2), nullptr, 16));
                mask += 'x';
            }
        }

        if (bytes.empty() || mask.empty() || bytes.size() != mask.size())
            return list;

        list = findBytesAll(start, end, bytes.data(), mask);
        return list;
    }

    uintptr_t findIdaPatternFirst(const uintptr_t start, const uintptr_t end, const std::string &pattern)
    {
        if (start >= end)
            return 0;

        std::string mask;
        std::vector<char> bytes;

        const size_t pattren_len = pattern.length();
        for (std::size_t i = 0; i < pattren_len; i++)
        {
            if (pattern[i] == ' ')
                continue;

            if (pattern[i] == '?')
            {
                bytes.push_back(0);
                mask += '?';
            }
            else if (pattren_len > i + 1 && std::isxdigit(pattern[i]) && std::isxdigit(pattern[i + 1]))
            {
                bytes.push_back(std::stoi(pattern.substr(i++, 2), nullptr, 16));
                mask += 'x';
            }
        }

        if (bytes.empty() || mask.empty() || bytes.size() != mask.size())
            return 0;

        return findBytesFirst(start, end, bytes.data(), mask);
    }

    std::vector<uintptr_t> findDataAll(const uintptr_t start, const uintptr_t end, const void *data, size_t size)
    {
        std::vector<uintptr_t> list;

        if (start >= end || !data || size < 1)
            return list;

        std::string mask(size, 'x');

        list = findBytesAll(start, end, (const char *)data, mask);
        return list;
    }

    uintptr_t findDataFirst(const uintptr_t start, const uintptr_t end, const void *data, size_t size)
    {
        if (start >= end || !data || size < 1)
            return 0;

        std::string mask(size, 'x');

        return findBytesFirst(start, end, (const char *)data, mask);
    }

#ifdef __ANDROID__

// for old ndk
#ifndef DT_GNU_HASH
#define DT_GNU_HASH 0x6ffffef5
#endif

    /* ======================= ElfScanner ======================= */

    // refs https://gist.github.com/resilar/24bb92087aaec5649c9a2afc0b4350c8

    ElfScanner::ElfScanner(uintptr_t elfBase, const std::vector<KittyMemory::ProcMap> &maps)
    {
        _elfBase = 0;
        _ehdr = {};
        _phdr = 0;
        _loads = 0;
        _loadBias = 0;
        _loadSize = 0;
        _dynamic = 0;
        _stringTable = 0;
        _symbolTable = 0;
        _elfHashTable = 0;
        _gnuHashTable = 0;
        _strsz = 0;
        _syment = sizeof(KT_ElfW(Sym));
        _fixedBySoInfo = false;
        _dsymbols_init = false;

        // verify address
        auto elfBaseMap = KittyMemory::getAddressMap(elfBase, maps);
        if (!elfBaseMap.isValid() || !elfBaseMap.readable || elfBase != elfBaseMap.startAddress)
        {
            KITTY_LOGD("ElfScanner: (%p) is not a valid ELF base address.", (void *)elfBase);
            return;
        }

        // verify ELF header
        if (!elfBaseMap.isValidELF())
        {
            KITTY_LOGD("ElfScanner: (%p) is not a valid ELF.", (void *)elfBase);
            return;
        }

        _elfBase = elfBase;

        // read ELF header
        _ehdr = *(KT_ElfW(Ehdr) *)_elfBase;

        // check ELF bit
        if (_ehdr.e_ident[EI_CLASS] != KT_ELF_EICLASS)
        {
            KITTY_LOGD("ElfScanner: ELF class mismatch (%p).", (void *)_elfBase);
            return;
        }

        if (_ehdr.e_ident[EI_DATA] != ELFDATA2LSB)
        {
            KITTY_LOGD("ElfScanner: (%p) data encoding is not little endian.", (void *)elfBase);
            return;
        }

        if (_ehdr.e_ident[EI_VERSION] != EV_CURRENT)
        {
            KITTY_LOGD("ElfScanner: (%p) ELF header version mismatch.", (void *)elfBase);
            return;
        }

        if (_ehdr.e_type != ET_EXEC && _ehdr.e_type != ET_DYN)
        {
            KITTY_LOGD("ElfScanner: (%p) is not a executable or dynamic "
                       "library.",
                       (void *)elfBase);
            return;
        }

        // check common header values
        if (!_ehdr.e_phoff || !_ehdr.e_phnum || !_ehdr.e_phentsize)
        {
            KITTY_LOGD("ElfScanner: Invalid header values (%p).", (void *)_elfBase);
            return;
        }

        if (!KittyMemory::getAddressMap(_elfBase + _ehdr.e_phoff, maps).readable)
        {
            KITTY_LOGD("ElfScanner: Invalid phdr (%p + %p) = %p.", (void *)_elfBase, (void *)_ehdr.e_phoff,
                       (void *)(_elfBase + _ehdr.e_phoff));
            return;
        }

        _phdr = _elfBase + _ehdr.e_phoff;

        // find load bias
        uintptr_t min_vaddr = UINTPTR_MAX, max_vaddr = 0;
        uintptr_t load_vaddr = 0, load_memsz = 0, load_filesz = 0;
        for (KT_ElfW(Half) i = 0; i < _ehdr.e_phnum; i++)
        {
            if (!KittyMemory::getAddressMap(_phdr + (i * _ehdr.e_phentsize), maps).readable)
                continue;

            KT_ElfW(Phdr) phdr_entry = {};
            memcpy(&phdr_entry, (const void *)(_phdr + (i * _ehdr.e_phentsize)), _ehdr.e_phentsize);
            _phdrs.push_back(phdr_entry);

            if (phdr_entry.p_type == PT_LOAD)
            {
                _loads++;

                load_vaddr = phdr_entry.p_vaddr;
                load_memsz = phdr_entry.p_memsz;
                load_filesz = phdr_entry.p_filesz;

                if (phdr_entry.p_vaddr < min_vaddr)
                    min_vaddr = phdr_entry.p_vaddr;

                if (phdr_entry.p_vaddr + phdr_entry.p_memsz > max_vaddr)
                    max_vaddr = phdr_entry.p_vaddr + phdr_entry.p_memsz;
            }
        }

        if (!_loads)
        {
            KITTY_LOGD("ElfScanner: No loads entry for ELF (%p).", (void *)_elfBase);
            return;
        }

        if (!max_vaddr)
        {
            KITTY_LOGD("ElfScanner: Failed to find max_vaddr for ELF (%p).", (void *)_elfBase);
            return;
        }

        min_vaddr = KT_PAGE_START(min_vaddr);
        max_vaddr = KT_PAGE_END(max_vaddr);

        _loadBias = _elfBase - min_vaddr;
        _loadSize = max_vaddr - min_vaddr;

        uintptr_t seg_start = load_vaddr + _loadBias;
        uintptr_t seg_mem_end = KT_PAGE_END((seg_start + load_memsz));
        uintptr_t seg_file_end = KT_PAGE_END((seg_start + load_filesz));
        uintptr_t bss_start = 0, bss_end = 0;
        if (seg_mem_end > seg_file_end)
        {
            bss_start = seg_file_end;
            bss_end = seg_mem_end;
        }

        for (const auto &it : maps)
        {
            if (it.startAddress >= _elfBase && it.endAddress <= (_elfBase + _loadSize))
            {
                if (it.startAddress == _elfBase)
                {
                    _baseSegment = it;
                }

                _segments.push_back(it);

                if (it.readable && !it.executable &&
                    (it.pathname == "[anon:.bss]" || (elfBaseMap.inode != 0 && it.inode == 0) ||
                     (it.startAddress >= bss_start && it.endAddress <= bss_end)))
                {
                    _bssSegments.push_back(it);
                }
            }

            if (it.endAddress >= (_elfBase + _loadSize))
                break;
        }

        // read all dynamics
        for (auto &phdr : _phdrs)
        {
            if (phdr.p_type == PT_DYNAMIC)
            {
                if (phdr.p_vaddr == 0 || phdr.p_memsz == 0)
                    break;
                if (!KittyMemory::getAddressMap(_loadBias + phdr.p_vaddr, maps).readable)
                    break;
                if (!KittyMemory::getAddressMap((_loadBias + phdr.p_vaddr) + phdr.p_memsz - 1, maps).readable)
                    break;

                _dynamic = _loadBias + phdr.p_vaddr;

                std::vector<KT_ElfW(Dyn)> dyn_buff(phdr.p_memsz / sizeof(KT_ElfW(Dyn)));
                memcpy(&dyn_buff[0], (const void *)_dynamic, phdr.p_memsz);

                for (auto &dyn : dyn_buff)
                {
                    if (dyn.d_tag == DT_NULL)
                        break;

                    // set required dynamics for symbol lookup
                    switch (dyn.d_tag)
                    {
                        // mandatory
                    case DT_STRTAB: // string table
                        _stringTable = dyn.d_un.d_ptr;
                        break;
                        // mandatory
                    case DT_SYMTAB: // symbol table
                        _symbolTable = dyn.d_un.d_ptr;
                        break;
                    case DT_HASH: // hash table
                        _elfHashTable = dyn.d_un.d_ptr;
                        break;
                    case DT_GNU_HASH: // gnu hash table
                        _gnuHashTable = dyn.d_un.d_ptr;
                        break;
                        // mandatory
                    case DT_STRSZ: // string table size
                        _strsz = dyn.d_un.d_val;
                        break;
                        // mandatory
                    case DT_SYMENT: // symbol entry size
                        _syment = dyn.d_un.d_val;
                        break;
                    default:
                        break;
                    }

                    _dynamics.push_back(dyn);
                }

                break;
            }
        }

        auto fix_table_address = [&](uintptr_t &table_addr) {
            if (table_addr && table_addr < _loadBias)
                table_addr += _loadBias;

            if (!KittyMemory::getAddressMap(table_addr, maps).readable)
                table_addr = 0;
        };

        fix_table_address(_stringTable);
        fix_table_address(_symbolTable);
        fix_table_address(_elfHashTable);
        fix_table_address(_gnuHashTable);

        _filepath = elfBaseMap.pathname;
        _realpath = elfBaseMap.pathname;
        if (!elfBaseMap.pathname.empty() && elfBaseMap.offset != 0)
        {
            KittyUtils::Zip::ZipEntryInfo ent{};
            if (KittyUtils::Zip::GetEntryInfoByDataOffset(elfBaseMap.pathname, elfBaseMap.offset, &ent) &&
                !ent.fileName.empty())
            {
                _realpath += '!';
                _realpath += ent.fileName;
            }
        }
    }

    ElfScanner::ElfScanner(const kitty_soinfo_t &soinfo, const std::vector<KittyMemory::ProcMap> &maps)
    {
        _elfBase = 0;
        _ehdr = {};
        _phdr = 0;
        _loads = 0;
        _loadBias = 0;
        _loadSize = 0;
        _dynamic = 0;
        _stringTable = 0;
        _symbolTable = 0;
        _elfHashTable = 0;
        _gnuHashTable = 0;
        _strsz = 0;
        _syment = 0;
        _fixedBySoInfo = false;
        _dsymbols_init = false;

        _elfBase = soinfo.base;
        _phdr = soinfo.phdr;
        _loadBias = soinfo.bias;
        _loadSize = soinfo.size;
        _dynamic = soinfo.dyn;
        _stringTable = soinfo.strtab;
        _symbolTable = soinfo.symtab;
        _strsz = soinfo.strsz;
        _syment = sizeof(KT_ElfW(Sym));
        _filepath = soinfo.path;
        _realpath = soinfo.realpath;

        bool isLinker = KittyUtils::String::EndsWith(soinfo.path, "/linker") ||
                        KittyUtils::String::EndsWith(soinfo.path, "/linker64");
        if (!isLinker && (_elfBase == 0 || _loadSize == 0 || _loadBias == 0 || _phdr == 0 || _dynamic == 0 ||
                          _stringTable == 0 || _symbolTable == 0))
        {
            KITTY_LOGD("ElfScanner: Invalid soinfo!");
            KITTY_LOGD("ElfScanner: elfBase: %p | bias: %p | phdr: %p | dyn: %p | strtab=%p | symtab=%p | strsz=%p | "
                       "syment=%p",
                       (void *)_elfBase, (void *)_loadBias, (void *)_phdr, (void *)_dynamic, (void *)_stringTable,
                       (void *)_symbolTable, (void *)_strsz, (void *)_syment);
            *this = ElfScanner();
            return;
        }

        // fix for linker
        if (_elfBase == 0)
            _elfBase = KittyMemory::getAddressMap(soinfo.bias, maps).startAddress;
        if (_elfBase == 0)
            _elfBase = KittyMemory::getAddressMap(soinfo.phdr, maps).startAddress;
        if (_elfBase == 0)
            _elfBase = KittyMemory::getAddressMap(soinfo.dyn, maps).startAddress;
        if (_elfBase == 0)
            _elfBase = KittyMemory::getAddressMap(soinfo.symtab, maps).startAddress;
        if (_elfBase == 0)
            _elfBase = KittyMemory::getAddressMap(soinfo.strtab, maps).startAddress;

        // verify address
        auto elfBaseMap = KittyMemory::getAddressMap(_elfBase, maps);
        if (!elfBaseMap.isValid() || !elfBaseMap.readable || _elfBase != elfBaseMap.startAddress)
        {
            KITTY_LOGD("ElfScanner: Invalid base(%p) for soinfo(%p)", (void *)_elfBase, (void *)soinfo.ptr);
            *this = ElfScanner();
            return;
        }

        // check if header is corrupted
        // some games like farlight have corrupted header and needs to be fixed by soinfo
        if (!isLinker && (memcmp(_ehdr.e_ident, "\177ELF", 4) != 0 || _ehdr.e_ident[EI_CLASS] != KT_ELF_EICLASS ||
                          _ehdr.e_ident[EI_DATA] != ELFDATA2LSB || _ehdr.e_ident[EI_VERSION] != EV_CURRENT ||
                          (_ehdr.e_type != ET_EXEC && _ehdr.e_type != ET_DYN) ||
                          _ehdr.e_ehsize != sizeof(KT_ElfW(Ehdr)) || _ehdr.e_phentsize != sizeof(KT_ElfW(Phdr)) ||
                          _ehdr.e_phnum != soinfo.phnum || _ehdr.e_phoff != (soinfo.phdr - soinfo.base)))
        {
            KITTY_LOGD("ElfScanner: soinfo(%p) has corrupted header, fixing by soinfo...", (void *)soinfo.ptr);

            _ehdr.e_ident[EI_MAG0] = 0x7F;
            _ehdr.e_ident[EI_MAG1] = 'E';
            _ehdr.e_ident[EI_MAG2] = 'L';
            _ehdr.e_ident[EI_MAG3] = 'F';
            _ehdr.e_ident[EI_CLASS] = KT_ELF_EICLASS;
            _ehdr.e_ident[EI_DATA] = ELFDATA2LSB;
            _ehdr.e_ident[EI_VERSION] = EV_CURRENT;
            _ehdr.e_ident[EI_OSABI] = ELFOSABI_SYSV;
            _ehdr.e_ident[EI_ABIVERSION] = 0;

            _ehdr.e_type = ET_DYN;
            _ehdr.e_machine = soinfo.e_machine;
            _ehdr.e_version = EV_CURRENT;
            _ehdr.e_entry = 0;
            _ehdr.e_phoff = soinfo.phdr ? (soinfo.phdr - soinfo.base) : 0;
            _ehdr.e_phnum = soinfo.phnum;
            _ehdr.e_ehsize = sizeof(KT_ElfW(Ehdr));
            _ehdr.e_phentsize = sizeof(KT_ElfW(Phdr));
            _ehdr.e_shoff = 0;
            _ehdr.e_shentsize = sizeof(KT_ElfW(Shdr));
            _ehdr.e_shnum = 0;
            _ehdr.e_shstrndx = 0;
            _ehdr.e_flags = 0;

            _fixedBySoInfo = true;
        }

        // fix for linker
        if (_phdr == 0)
            _phdr = _elfBase + _ehdr.e_phoff;

        auto phdrMap = KittyMemory::getAddressMap(_phdr, maps);
        if (!phdrMap.readable || phdrMap.startAddress < _elfBase ||
            (_loadSize && phdrMap.endAddress > (_elfBase + _loadSize)))
        {
            KITTY_LOGD("ElfScanner: Invalid phdr(%p) for soinfo(%p).", (void *)_phdr, (void *)soinfo.ptr);
            *this = ElfScanner();
            return;
        }

        if (!isLinker)
        {
            auto dynMap = KittyMemory::getAddressMap(_dynamic, maps);
            if (!(dynMap.readable && dynMap.startAddress >= _elfBase && dynMap.endAddress <= (_elfBase + _loadSize)))
            {
                KITTY_LOGD("ElfScanner: Invalid dyn(%p) for soinfo(%p).", (void *)_dynamic, (void *)soinfo.ptr);
                *this = ElfScanner();
                return;
            }
        }

        // fix for ldplayer
        auto biasMap = KittyMemory::getAddressMap(_loadBias, maps);
        if (!(biasMap.readable && biasMap.startAddress >= _elfBase && biasMap.endAddress <= (_elfBase + _loadSize)))
        {
            KITTY_LOGD("ElfScanner: Invalid bias(%p) for soinfo(%p).", (void *)_loadBias, (void *)soinfo.ptr);
            _loadBias = 0;
        }

        uintptr_t min_vaddr = UINTPTR_MAX, max_vaddr = 0;
        uintptr_t load_vaddr = 0, load_memsz = 0, load_filesz = 0;
        for (KT_ElfW(Half) i = 0; i < _ehdr.e_phnum; i++)
        {
            if (!KittyMemory::getAddressMap(_phdr + (i * _ehdr.e_phentsize), maps).readable)
                continue;

            KT_ElfW(Phdr) phdr_entry = {};
            memcpy(&phdr_entry, (const void *)(_phdr + (i * _ehdr.e_phentsize)), _ehdr.e_phentsize);
            _phdrs.push_back(phdr_entry);

            if (phdr_entry.p_type == PT_LOAD)
            {
                _loads++;

                load_vaddr = phdr_entry.p_vaddr;
                load_memsz = phdr_entry.p_memsz;
                load_filesz = phdr_entry.p_filesz;

                if (phdr_entry.p_vaddr < min_vaddr)
                    min_vaddr = phdr_entry.p_vaddr;

                if (phdr_entry.p_vaddr + phdr_entry.p_memsz > max_vaddr)
                    max_vaddr = phdr_entry.p_vaddr + phdr_entry.p_memsz;
            }
        }

        if (!_loads)
        {
            KITTY_LOGD("ElfScanner: No loads entry for ELF (%p).", (void *)_elfBase);
            *this = ElfScanner();
            return;
        }

        if (!max_vaddr)
        {
            KITTY_LOGD("ElfScanner: Failed to find max_vaddr for ELF (%p).", (void *)_elfBase);
            *this = ElfScanner();
            return;
        }

        min_vaddr = KT_PAGE_START(min_vaddr);
        max_vaddr = KT_PAGE_END(max_vaddr);

        // fix for linker
        {
            if (_loadBias == 0)
                _loadBias = _elfBase - min_vaddr;

            if (_loadSize == 0)
                _loadSize = max_vaddr - min_vaddr;
        }

        uintptr_t seg_start = load_vaddr + _loadBias;
        uintptr_t seg_mem_end = KT_PAGE_END((seg_start + load_memsz));
        uintptr_t seg_file_end = KT_PAGE_END((seg_start + load_filesz));
        uintptr_t bss_start = 0, bss_end = 0;
        if (seg_mem_end > seg_file_end)
        {
            bss_start = seg_file_end;
            bss_end = seg_mem_end;
        }

        for (const auto &it : maps)
        {
            if (it.startAddress >= _elfBase && it.endAddress <= (_elfBase + _loadSize))
            {
                if (it.startAddress == _elfBase)
                {
                    _baseSegment = it;
                }

                _segments.push_back(it);

                if (it.readable && !it.executable &&
                    (it.pathname == "[anon:.bss]" || (elfBaseMap.inode != 0 && it.inode == 0) ||
                     (it.startAddress >= bss_start && it.endAddress <= bss_end)))
                {
                    _bssSegments.push_back(it);
                }
            }

            if (it.endAddress >= (_elfBase + _loadSize))
                break;
        }

        // read all dynamics
        for (auto &phdr : _phdrs)
        {
            if (phdr.p_type == PT_DYNAMIC)
            {
                // fix for linker
                if (_dynamic == 0 && phdr.p_vaddr)
                    _dynamic = _loadBias + phdr.p_vaddr;

                if (_dynamic == 0 || phdr.p_memsz == 0)
                    break;
                if (!KittyMemory::getAddressMap(_dynamic, maps).readable)
                    break;
                if (!KittyMemory::getAddressMap(_dynamic + phdr.p_memsz - 1, maps).readable)
                    break;

                std::vector<KT_ElfW(Dyn)> dyn_buff(phdr.p_memsz / sizeof(KT_ElfW(Dyn)));
                memcpy(&dyn_buff[0], (const void *)_dynamic, phdr.p_memsz);

                for (auto &dyn : dyn_buff)
                {
                    if (dyn.d_tag == DT_NULL)
                        break;

                    switch (dyn.d_tag)
                    {
                    case DT_STRTAB:
                        if (_stringTable == 0)
                            _stringTable = dyn.d_un.d_ptr;
                        break;
                    case DT_SYMTAB:
                        if (_symbolTable == 0)
                            _symbolTable = dyn.d_un.d_ptr;
                        break;
                    case DT_STRSZ:
                        if (_strsz == 0)
                            _strsz = dyn.d_un.d_val;
                        break;
                    case DT_SYMENT:
                        _syment = dyn.d_un.d_val;
                        break;
                    case DT_HASH: // hash table
                        _elfHashTable = dyn.d_un.d_ptr;
                        break;
                    case DT_GNU_HASH: // gnu hash table
                        _gnuHashTable = dyn.d_un.d_ptr;
                        break;
                    default:
                        break;
                    }

                    _dynamics.push_back(dyn);
                }

                break;
            }
        }

        auto fix_table_address = [&](uintptr_t &table_addr) {
            if (table_addr && table_addr < _loadBias)
                table_addr += _loadBias;

            if (!KittyMemory::getAddressMap(table_addr, maps).readable)
                table_addr = 0;
        };

        fix_table_address(_symbolTable);
        fix_table_address(_stringTable);
        fix_table_address(_gnuHashTable);
        fix_table_address(_gnuHashTable);
    }

    uintptr_t ElfScanner::findSymbol(const std::string &symbolName) const
    {
        if (_loadBias && _stringTable && _symbolTable && _strsz && _syment)
        {
            auto get_sym_address = [&](const KT_ElfW(Sym) * sym_ent) -> uintptr_t {
                return sym_ent->st_value < _loadBias ? _loadBias + sym_ent->st_value : sym_ent->st_value;
            };

            // try gnu hash first
            if (_gnuHashTable)
            {
                const auto *sym = KittyUtils::Elf::GnuHash::LookupByName(_gnuHashTable, _symbolTable, _stringTable,
                                                                         _syment, _strsz, symbolName.c_str());
                if (sym && sym->st_value)
                {
                    return get_sym_address(sym);
                }
            }

            if (_elfHashTable)
            {
                const auto *sym = KittyUtils::Elf::ElfHash::LookupByName(_elfHashTable, _symbolTable, _stringTable,
                                                                         _syment, _strsz, symbolName.c_str());
                if (sym && sym->st_value)
                {
                    return get_sym_address(sym);
                }
            }
        }

        return 0;
    }

    std::unordered_map<std::string, uintptr_t> ElfScanner::dsymbols()
    {
        if (!_dsymbols_init && _loadBias && !_filepath.empty())
        {
            _dsymbols_init = true;

            auto get_sym_address = [&](const KT_ElfW(Sym) * sym_ent) -> uintptr_t {
                return sym_ent->st_value < _loadBias ? _loadBias + sym_ent->st_value : sym_ent->st_value;
            };

            KittyUtils::Zip::ZipEntryMMap mmap_info = {nullptr, 0};
            auto baseSeg = baseSegment();
            if (baseSeg.offset != 0)
            {
                if (!KittyUtils::Zip::MMapEntryByDataOffset(_filepath, _baseSegment.offset, &mmap_info))
                    return _dsymbolsMap;
            }
            else
            {
                errno = 0;
                int fd = KT_EINTR_RETRY(open(_filepath.c_str(), O_RDONLY));
                if (fd < 0)
                {
                    KITTY_LOGD("Failed to open file <%s> err(%d)", _filepath.c_str(), errno);
                    return _dsymbolsMap;
                }

                struct stat flstats;
                memset(&flstats, 0, sizeof(struct stat));
                int fstat_ret = fstat(fd, &flstats);
                size_t elfSize = flstats.st_size;
                if (fstat_ret == -1 || elfSize <= 0)
                {
                    close(fd);
                    KITTY_LOGD("stat failed for <%s>", _filepath.c_str());
                    return _dsymbolsMap;
                }
                mmap_info.mappingBase = mmap(nullptr, elfSize, PROT_READ, MAP_PRIVATE, fd, 0);
                mmap_info.mappingSize = elfSize;
                mmap_info.data = reinterpret_cast<uint8_t *>(mmap_info.mappingBase);
                mmap_info.size = mmap_info.mappingSize;
                close(fd);
            }

            if (mmap_info.size == 0 || !mmap_info.data || mmap_info.data == ((void *)-1))
            {
                KITTY_LOGD("Failed to mmap <%s>", realPath().c_str());
                return _dsymbolsMap;
            }

            auto cleanup = [&] { munmap(mmap_info.data, mmap_info.size); };

            KT_ElfW(Ehdr) *ehdr = reinterpret_cast<KT_ElfW(Ehdr) *>(mmap_info.data);

            if (memcmp(ehdr->e_ident, "\177ELF", 4) != 0)
            {
                KITTY_LOGD("<%s> is not a valid ELF", realPath().c_str());
                cleanup();
                return _dsymbolsMap;
            }

            if (ehdr->e_phoff == 0 || ehdr->e_phentsize == 0 || ehdr->e_phnum == 0 ||
                ehdr->e_phoff + ehdr->e_phnum * sizeof(KT_ElfW(Phdr)) > mmap_info.size)
            {
                KITTY_LOGD("Invalid program header table in <%s>", filePath().c_str());
                cleanup();
                return _dsymbolsMap;
            }

            if (ehdr->e_shoff == 0 || ehdr->e_shentsize == 0 || ehdr->e_shnum == 0 ||
                ehdr->e_shoff + ehdr->e_shnum * sizeof(KT_ElfW(Shdr)) > mmap_info.size)
            {
                KITTY_LOGD("Invalid section header table in <%s>", filePath().c_str());
                cleanup();
                return _dsymbolsMap;
            }

            const KT_ElfW(Shdr) *shdr = reinterpret_cast<KT_ElfW(Shdr) *>(reinterpret_cast<char *>(mmap_info.data) +
                                                                          ehdr->e_shoff);
            const KT_ElfW(Shdr) *shstrtab_shdr = shdr + ehdr->e_shstrndx;
            const char *sectionstr = reinterpret_cast<char *>(reinterpret_cast<char *>(mmap_info.data) +
                                                              shstrtab_shdr->sh_offset);
            for (uint16_t i = 0; i < ehdr->e_shnum; ++i)
            {
                if (shdr[i].sh_type != SHT_SYMTAB)
                    continue;

                std::string section_name = std::string(reinterpret_cast<const char *>(sectionstr + shdr[i].sh_name));
                if (section_name.compare(".symtab") != 0)
                    continue;

                if ((shdr[i].sh_offset + shdr[i].sh_size) > mmap_info.size || shdr[i].sh_link >= ehdr->e_shnum ||
                    (shdr[shdr[i].sh_link].sh_offset + shdr[shdr[i].sh_link].sh_size) > mmap_info.size)
                    continue;

                const KT_ElfW(Sym) *symtab = reinterpret_cast<KT_ElfW(Sym) *>(reinterpret_cast<char *>(mmap_info.data) +
                                                                              shdr[i].sh_offset);
                const size_t symCount = shdr[i].sh_size / shdr[i].sh_entsize;
                const KT_ElfW(Shdr) *strtabShdr = &shdr[shdr[i].sh_link];
                const char *strtab = reinterpret_cast<char *>(reinterpret_cast<char *>(mmap_info.data) +
                                                              strtabShdr->sh_offset);

                for (size_t j = 0; j < symCount; ++j)
                {
                    const KT_ElfW(Sym) *curr_sym = &symtab[j];
                    if (!curr_sym || curr_sym->st_name >= strtabShdr->sh_size)
                        continue;

                    if (intptr_t(curr_sym->st_value) <= 0 || intptr_t(curr_sym->st_size) <= 0)
                        continue;

                    if (KT_ELF_ST_TYPE(curr_sym->st_info) != STT_OBJECT &&
                        KT_ELF_ST_TYPE(curr_sym->st_info) != STT_FUNC)
                        continue;

                    std::string sym_str = std::string(reinterpret_cast<const char *>(strtab + curr_sym->st_name));
                    if (!sym_str.empty() && sym_str.data())
                        _dsymbolsMap[sym_str] = get_sym_address(curr_sym);
                }
            }
            cleanup();
        }
        return _dsymbolsMap;
    }

    uintptr_t ElfScanner::findDebugSymbol(const std::string &symbolName)
    {
        const auto &syms = dsymbols();
        auto it = syms.find(symbolName);
        return it != syms.end() ? it->second : 0;
    }

    RegisterNativeFn ElfScanner::findRegisterNativeFn(const std::string &name, const std::string &signature) const
    {
        uintptr_t fn_loc = 0;
        RegisterNativeFn fn;

        if (name.empty() || !isValid())
            return fn;

        std::vector<uintptr_t> string_locs;
        for (auto &it : segments())
        {
            if (it.readable && it.inode != 0)
            {
                uintptr_t string_loc = KittyScanner::findDataFirst(it.startAddress, it.endAddress, name.data(),
                                                                   name.length());
                if (string_loc != 0)
                    string_locs.push_back(string_loc);
            }
        }

        if (string_locs.empty())
        {
            KITTY_LOGD("findRegisterNativeFn: Couldn't find string (%s) "
                       "in selected maps",
                       name.c_str());
            return fn;
        }

        for (auto &it : segments())
        {
            if (it.readable && it.inode != 0)
            {
                for (auto &string_loc : string_locs)
                {
                    uintptr_t string_xref = KittyScanner::findDataFirst(it.startAddress, it.endAddress, &string_loc,
                                                                        sizeof(uintptr_t));
                    if (!string_xref)
                        continue;

                    uintptr_t signature_ptr = *(uintptr_t *)(string_xref + sizeof(uintptr_t));
                    if (signature_ptr == 0)
                        continue;

                    std::vector<char> buf(signature.length() + 1, 0);
                    KittyMemory::syscallMemRead(signature_ptr, buf.data(), buf.size());

                    if (std::string(buf.data()) == signature)
                    {
                        fn_loc = string_xref;
                        break;
                    }
                }
            }
        }

        if (fn_loc != 0)
        {
            memcpy(&fn, (void *)fn_loc, sizeof(RegisterNativeFn));
        }

        return fn;
    }

    bool ElfScanner::dumpToDisk(const std::string &destination) const
    {
        bool dumped = (isValid() && KittyMemory::dumpMemToDisk(_elfBase, _loadSize, destination));
        if (dumped && _fixedBySoInfo)
        {
            KittyIOFile destIO(destination, O_WRONLY);
            destIO.Open();
            KT_ElfW(Ehdr) fixedHdr = header();
            destIO.Write(0, &fixedHdr, sizeof(fixedHdr));
            destIO.Close();
        }
        return dumped;
    }

    ElfScanner &ElfScanner::getProgramElf()
    {
        static ElfScanner progElf{};
        if (!progElf.isValid() || !progElf.dynamic())
        {
            const char *path = "/proc/self/exe";
            char exePath[0xff] = {0};
            errno = 0;
            int ret = int(KT_EINTR_RETRY(readlink(path, exePath, 0xff)));
            if (ret == -1)
            {
                int err = errno;
                KITTY_LOGE("Failed to readlink \"%s\", error(%d): %s.", path, err, strerror(err));
                return progElf;
            }

            const auto allMaps = KittyMemory::getAllMaps();
            const auto maps = KittyMemory::getMaps(KittyMemory::EProcMapFilter::Equal, exePath, allMaps);
            for (const auto &it : maps)
            {
                if (!it.readable || it.writeable)
                    continue;

                progElf = ElfScanner(it.startAddress, allMaps);
                if (progElf.isValid() && progElf.dynamic())
                    break;
            }
        }
        return progElf;
    }

    std::vector<ElfScanner> ElfScanner::getAllELFs(EScanElfType type, EScanElfFilter filter)
    {
        static std::mutex mtx;
        std::lock_guard<std::mutex> lock(mtx);

        static std::unordered_map<uintptr_t, ElfScanner> cached_elfs;
        std::vector<ElfScanner> elfs;

        auto maps = KittyMemory::getAllMaps();
        if (maps.empty())
        {
            KITTY_LOGD("getAllELFs: Failed to get process maps.");
            return elfs;
        }

        std::vector<uintptr_t> invalid_keys;
        for (auto &it : cached_elfs)
        {
            if (it.first && !KittyMemory::getAddressMap(it.first, maps).readable)
            {
                invalid_keys.push_back(it.first);
            }
        }

        for (auto &it : invalid_keys)
        {
            cached_elfs.erase(it);
        }

        const auto progMachine = getProgramElf().header().e_machine;
        static auto eMachineCheck = [](EScanElfType type, int a, int b) -> bool {
            return a == 0 || b == 0 || type == EScanElfType::Any || (type == EScanElfType::Native && a == b) ||
                   (type == EScanElfType::Emulated && a != b);
        };

        const bool isAppFilter = filter == EScanElfFilter::App;
        const bool isSysFilter = filter == EScanElfFilter::System;

        unsigned long lastElfNode = 0;

        for (const auto &it : maps)
        {
#ifdef __LP64__
            if (it.startAddress >= (0x7fffffffffff-0x1000))
                continue;
#else
            if (it.startAddress >= (0xffffffff-0x1000))
                continue;
#endif

            if (!it.isValid() || !it.readable || it.writeable || it.is_shared ||
                (it.inode != 0 && it.inode == lastElfNode))
                continue;

            if (isAppFilter)
            {
                if (it.inode == 0 || (!KittyUtils::String::StartsWith(it.pathname, "/data/") &&
                                      !KittyUtils::String::StartsWith(it.pathname, "/proc/") &&
                                      !KittyUtils::String::StartsWith(it.pathname, "/memfd:")))
                    continue;
            }
            else if (isSysFilter)
            {
                if ((it.inode == 0 && it.pathname != "[vdso]") ||
                    (!KittyUtils::String::StartsWith(it.pathname, "/system/") &&
                     !KittyUtils::String::StartsWith(it.pathname, "/apex/")))
                    continue;
            }

            if (cached_elfs.size() && cached_elfs.count(it.startAddress) > 0)
            {
                auto elf = cached_elfs[it.startAddress];
                if (elf.filePath() == it.pathname)
                {
                    if (eMachineCheck(type, progMachine, elf.header().e_machine))
                    {
                        elfs.push_back(elf);
                    }
                    lastElfNode = elf.baseSegment().inode;
                    continue;
                }
                else
                {
                    cached_elfs.erase(it.startAddress);
                }
            }

            bool isFile = (!it.pathname.empty() && it.inode != 0);
            if (!isFile && it.pathname != "[vdso]" && !KittyUtils::String::StartsWith(it.pathname, "/memfd:"))
                continue;

            if (it.pathname == "cfi shadow")
                continue;

            if (KittyUtils::String::StartsWith(it.pathname, "/dev/") ||
                KittyUtils::String::StartsWith(it.pathname, "/system/fonts/") ||
                KittyUtils::String::StartsWith(it.pathname, "/data/priv-downloads/") ||
                KittyUtils::String::StartsWith(it.pathname, "/data/misc/"))
                continue;

            if (KittyUtils::String::StartsWith(it.pathname, "/system/etc/") &&
                !KittyUtils::String::EndsWith(it.pathname, ".so"))
                continue;

            if (KittyUtils::String::StartsWith(it.pathname, "/data/dalvik-cache/") ||
                KittyUtils::String::StartsWith(it.pathname, "/system/") ||
                KittyUtils::String::StartsWith(it.pathname, "/apex/com.android.") ||
                (KittyUtils::String::StartsWith(it.pathname, "/data/app/") &&
                 KittyUtils::String::Contains(it.pathname, "/oat/")))
            {
                if (KittyUtils::String::EndsWith(it.pathname, ".jar") ||
                    KittyUtils::String::EndsWith(it.pathname, ".art") ||
                    KittyUtils::String::EndsWith(it.pathname, ".oat") ||
                    KittyUtils::String::EndsWith(it.pathname, ".odex") ||
                    KittyUtils::String::EndsWith(it.pathname, ".dex"))
                    continue;
            }

            auto elf = ElfScanner(it.startAddress, maps);
            if (elf.isValid())
            {
                if (eMachineCheck(type, progMachine, elf.header().e_machine))
                {
                    elfs.push_back(elf);
                }
                lastElfNode = elf.baseSegment().inode;
                cached_elfs[it.startAddress] = elf;
            }
        }

        return elfs;
    }

    ElfScanner ElfScanner::findElf(const std::string &path, EScanElfType type, EScanElfFilter filter)
    {
        ElfScanner ret{};

        if (path.empty())
            return ret;

        std::vector<ElfScanner> elfs;
        std::vector<ElfScanner> dyn_elfs;

        const auto allElfs = ElfScanner::getAllELFs(type, filter);
        for (const auto &it : allElfs)
        {
            if (it.isValid() && KittyUtils::String::EndsWith(it.realPath(), path))
            {
                if (it.dynamic() && it.dynamics().size() > 0)
                    dyn_elfs.push_back(it);
                else
                    elfs.push_back(it);
            }
        }

        if (elfs.empty() && dyn_elfs.empty())
            return ret;

        if (dyn_elfs.size() > 0)
        {
            if (dyn_elfs.size() == 1)
                return dyn_elfs[0];

            int nMostSegments = 0;
            for (auto &it : dyn_elfs)
            {
                int numSegments = it.segments().size();
                if (numSegments > nMostSegments)
                {
                    ret = it;
                    nMostSegments = numSegments;
                }
            }
        }
        else if (elfs.size() > 0)
        {
            if (elfs.size() == 1)
                return elfs[0];

            int nMostSegments = 0;
            for (auto &it : elfs)
            {
                int numSegments = it.segments().size();
                if (numSegments > nMostSegments)
                {
                    ret = it;
                    nMostSegments = numSegments;
                }
            }
        }

        return ret;
    }

    std::vector<std::pair<uintptr_t, ElfScanner>> ElfScanner::findSymbolAll(const std::string &symbolName,
                                                                            EScanElfType type, EScanElfFilter filter)
    {
        std::vector<std::pair<uintptr_t, ElfScanner>> ret{};

        auto elfs = getAllELFs(type, filter);
        for (auto &it : elfs)
        {
            uintptr_t sym = it.findSymbol(symbolName);
            if (sym != 0)
            {
                ret.emplace_back(sym, it);
            }
        }

        return ret;
    }

    LinkerScanner::LinkerScanner(uintptr_t linkerBase) : ElfScanner(linkerBase)
    {
        memset(&_linker_syms, 0, sizeof(_linker_syms));
        memset(&_soinfo_offsets, 0, sizeof(_soinfo_offsets));
        _init = false;

        if (!isValid())
            return;

        init();
    }

    LinkerScanner::LinkerScanner(const ElfScanner &linkerElf) : ElfScanner(linkerElf)
    {
        memset(&_linker_syms, 0, sizeof(_linker_syms));
        memset(&_soinfo_offsets, 0, sizeof(_soinfo_offsets));
        _init = false;

        if (!isValid())
            return;

        init();
    }

    bool LinkerScanner::init()
    {
        if (!isValid())
            return false;

        if (_init)
            return true;

        for (const auto &sym : dsymbols())
        {
            if (KittyUtils::String::StartsWith(sym.first, "__dl__ZL11solist_head") ||
                KittyUtils::String::StartsWith(sym.first, "__dl__ZL6solist"))
            {
                _linker_syms.solist = sym.second;
                continue;
            }
            if (KittyUtils::String::StartsWith(sym.first, "__dl__ZL6somain"))
            {
                _linker_syms.somain = sym.second;
                continue;
            }
            if (KittyUtils::String::StartsWith(sym.first, "__dl__ZL11solist_tail") ||
                KittyUtils::String::StartsWith(sym.first, "__dl__ZL6sonext"))
            {
                _linker_syms.sonext = sym.second;
                continue;
            }
            if (_linker_syms.solist && _linker_syms.somain && _linker_syms.sonext)
                break;
        }

        if (!(_linker_syms.solist && _linker_syms.somain && _linker_syms.sonext))
        {
            return false;
        }

        KITTY_LOGD("solist(%zx) | somain(%zx) | sonext(%zx)", solist(), somain(), sonext());

        auto maps = KittyMemory::getAllMaps();

        uintptr_t solist_ptr = solist();
        std::vector<char> solist_buf(KT_SOINFO_BUFFER_SZ, 0);
        for (size_t i = 0; i < solist_buf.size(); i += sizeof(uintptr_t))
        {
            if (KittyMemory::getAddressMap(solist_ptr + i, maps).readable)
            {
                memcpy((void *)(solist_buf.data() + i), (const void *)(solist_ptr + i), sizeof(uintptr_t));
            }
        }

        std::vector<char> si_buf(KT_SOINFO_BUFFER_SZ, 0);
        uintptr_t somain_ptr = (somain() ? somain() : sonext());
        for (size_t i = 0; i < si_buf.size(); i += sizeof(uintptr_t))
        {
            if (KittyMemory::getAddressMap(somain_ptr + i, maps).readable)
            {
                memcpy((void *)(si_buf.data() + i), (const void *)(somain_ptr + i), sizeof(uintptr_t));
            }
        }

        ElfScanner si_elf{};
        for (size_t i = 0; i < si_buf.size(); i += sizeof(uintptr_t))
        {
            uintptr_t possible_base = *(uintptr_t *)&si_buf[i];

            auto tmp_map = KittyMemory::getAddressMap(possible_base, maps);
            if (possible_base != tmp_map.startAddress || !tmp_map.isValid() || !tmp_map.readable || tmp_map.writeable ||
                tmp_map.is_shared)
                continue;

            si_elf = ElfScanner(possible_base, maps);
            if (si_elf.isValid())
            {
                _soinfo_offsets.base = i;
                break;
            }
        }

        KITTY_LOGD("soinfo_base(%zx)", _soinfo_offsets.base);

        if (_soinfo_offsets.base == 0)
            return false;

        for (size_t i = 0; i < si_buf.size(); i += sizeof(uintptr_t))
        {
            uintptr_t value = *(uintptr_t *)&si_buf[i];

            if (!_soinfo_offsets.phdr && value == si_elf.phdr())
            {
                _soinfo_offsets.phdr = i;
                continue;
            }
            if (!_soinfo_offsets.phnum && value == si_elf.header().e_phnum)
            {
                _soinfo_offsets.phnum = i;
                continue;
            }
            if (!_soinfo_offsets.size &&
                (value == si_elf.loadSize() ||
                 value == (si_elf.loadSize() + KittyMemory::getAddressMap(si_elf.end(), maps).length)))
            {
                _soinfo_offsets.size = i;
                continue;
            }
            if (!_soinfo_offsets.dyn && value == si_elf.dynamic())
            {
                _soinfo_offsets.dyn = i;
                continue;
            }
            if (!_soinfo_offsets.strtab && value == si_elf.stringTable())
            {
                _soinfo_offsets.strtab = i;
                continue;
            }
            if (!_soinfo_offsets.symtab && value == si_elf.symbolTable())
            {
                _soinfo_offsets.symtab = i;
                continue;
            }
            if (!_soinfo_offsets.bias && value == si_elf.loadBias() && i != _soinfo_offsets.base)
            {
                _soinfo_offsets.bias = i;
                continue;
            }
            if (!_soinfo_offsets.strsz && value == si_elf.stringTableSize())
            {
                _soinfo_offsets.strsz = i;
                continue;
            }
        }

        KITTY_LOGD("soinfo_bias(%zx) | soinfo_size(%zx)", _soinfo_offsets.bias, _soinfo_offsets.size);
        KITTY_LOGD("soinfo_phdr(%zx, %zx) | soinfo_dyn(%zx)", _soinfo_offsets.phdr, _soinfo_offsets.phnum,
                   _soinfo_offsets.dyn);
        KITTY_LOGD("soinfo_strtab(%zx, %zx) | soinfo_symtab(%zx)", _soinfo_offsets.strtab, _soinfo_offsets.strsz,
                   _soinfo_offsets.symtab);

        if (!(_soinfo_offsets.size && _soinfo_offsets.bias && _soinfo_offsets.dyn && _soinfo_offsets.symtab &&
              _soinfo_offsets.strtab))
        {
            return false;
        }

        for (size_t i = 0; i < solist_buf.size(); i += sizeof(uintptr_t))
        {
            uintptr_t possible_next = *(uintptr_t *)&solist_buf[i];

            if (!KittyMemory::getAddressMap(possible_next + _soinfo_offsets.base, maps).readable)
                continue;

            uintptr_t possible_base = *(uintptr_t *)(possible_next + _soinfo_offsets.base);
            auto tmp_map = KittyMemory::getAddressMap(possible_base, maps);
            if (!tmp_map.isValid() || !tmp_map.readable || tmp_map.writeable || tmp_map.is_shared)
                continue;

            auto tmp_elf = ElfScanner(possible_base, maps);
            if (tmp_elf.isValid())
            {
                if (!KittyMemory::getAddressMap(possible_next + _soinfo_offsets.size, maps).readable)
                    continue;

                size_t possible_size = *(uintptr_t *)(possible_next + _soinfo_offsets.size);
                if (possible_size == tmp_elf.loadSize() ||
                    possible_size == (tmp_elf.loadSize() + KittyMemory::getAddressMap(tmp_elf.end(), maps).length))
                {
                    _soinfo_offsets.next = i;
                    break;
                }
            }
        }

        KITTY_LOGD("soinfo_sonext(%zx)", _soinfo_offsets.next);

        _init = _soinfo_offsets.next != 0;
        return _init;
    }

    std::vector<kitty_soinfo_t> LinkerScanner::allSoInfo() const
    {
        std::vector<kitty_soinfo_t> infos{};

        if (!isValid() || !_init)
            return infos;

        auto maps = KittyMemory::getAllMaps();
        uintptr_t si = solist(), prev = 0;
        while (si && KittyMemory::getAddressMap(si, maps).readable)
        {
            kitty_soinfo_t info = infoFromSoInfo_(si, maps);
            infos.push_back(info);

            prev = si;

            si = *(uintptr_t *)(si + _soinfo_offsets.next);

            if (si == prev)
                break;
        }
        return infos;
    }

    kitty_soinfo_t LinkerScanner::findSoInfo(const std::string &name) const
    {
        const auto list = allSoInfo();
        for (const auto &it : list)
        {
            if (KittyUtils::String::EndsWith(it.realpath, name))
            {
                return it;
            }
        }
        return {};
    }

    kitty_soinfo_t LinkerScanner::infoFromSoInfo_(uintptr_t si, const std::vector<KittyMemory::ProcMap> &maps) const
    {
        kitty_soinfo_t info{};

        if (!_init)
            return info;

        info.ptr = si;
        info.base = *(uintptr_t *)(si + _soinfo_offsets.base);
        info.size = *(uintptr_t *)(si + _soinfo_offsets.size);
        info.phdr = *(uintptr_t *)(si + _soinfo_offsets.phdr);
        info.phnum = *(uintptr_t *)(si + _soinfo_offsets.phnum);
        info.dyn = *(uintptr_t *)(si + _soinfo_offsets.dyn);
        info.strtab = *(uintptr_t *)(si + _soinfo_offsets.strtab);
        info.symtab = *(uintptr_t *)(si + _soinfo_offsets.symtab);
        info.strsz = _soinfo_offsets.strsz ? *(uintptr_t *)(si + _soinfo_offsets.strsz) : 0;
        info.bias = *(uintptr_t *)(si + _soinfo_offsets.bias);
        info.next = *(uintptr_t *)(si + _soinfo_offsets.next);
        info.e_machine = header().e_machine;

        uintptr_t start_map_addr = info.base;
        if (start_map_addr == 0)
            start_map_addr = info.base;
        if (start_map_addr == 0)
            start_map_addr = info.bias;
        if (start_map_addr == 0)
            start_map_addr = info.phdr;
        if (start_map_addr == 0)
            start_map_addr = info.dyn;
        if (start_map_addr == 0)
            start_map_addr = info.strtab;
        if (start_map_addr == 0)
            start_map_addr = info.symtab;

        auto si_map = KittyMemory::getAddressMap(start_map_addr, maps);
        if (si_map.isValid())
        {
            info.path = si_map.pathname;
            info.realpath = si_map.pathname;
            if (si_map.offset != 0)
            {
                KittyUtils::Zip::ZipEntryInfo ent{};
                if (KittyUtils::Zip::GetEntryInfoByDataOffset(si_map.pathname, si_map.offset, &ent) &&
                    !ent.fileName.empty())
                {
                    info.realpath += '!';
                    info.realpath += ent.fileName;
                }
            }
        }

        return info;
    }

    bool NativeBridgeScanner::init()
    {
        if (_init)
            return true;

        _nbElf = ElfScanner::findElf("/libnativebridge.so", EScanElfType::Native, EScanElfFilter::System);
        if (!_nbElf.isValid())
        {
            KITTY_LOGD("NativeBridgeScanner: Failed to find libnativebrdge.so");
            return false;
        }

        _nbImplElf = ElfScanner::findElf("/libhoudini.so", EScanElfType::Native, EScanElfFilter::System);
        if (_nbImplElf.isValid())
            _isHoudini = true;
        else
            _nbImplElf = ElfScanner::findElf("/libndk_translation.so", EScanElfType::Native, EScanElfFilter::System);

        if (!_nbImplElf.isValid())
        {
            KITTY_LOGD("NativeBridgeScanner: Failed to find nativebridge implementation");
            return false;
        }

        _nbItf = _nbImplElf.findSymbol("NativeBridgeItf");
        if (_nbItf == 0)
        {
            KITTY_LOGD("NativeBridgeScanner: Failed to find export NativeBridgeItf");
            return false;
        }

        memcpy(&(_nbItf_data.version), (const void *)(_nbItf), sizeof(int));

        _nbItf_data_size = nbItf_data_t::GetStructSize(_nbItf_data.version);
        if (_nbItf_data_size == 0)
        {
            KITTY_LOGD("NativeBridgeScanner: Unsupported nativebridge version (%d)", _nbItf_data.version);
            return false;
        }

        KITTY_LOGD("NativeBridgeScanner: Using nativebridge version (%d), data size (%p)", _nbItf_data.version,
                   (void *)_nbItf_data_size);

        memcpy(&_nbItf_data, (const void *)(_nbItf), _nbItf_data_size);

        *(uintptr_t *)&fnNativeBridgeInitialized = _nbElf.findSymbol("NativeBridgeInitialized");
        if (fnNativeBridgeInitialized == nullptr)
            *(uintptr_t *)&fnNativeBridgeInitialized = _nbElf.findSymbol("_ZN7android23NativeBridgeInitializedEv");

        // replace for nb v2
        if (_nbItf_data.version < 3)
        {
            uintptr_t pLoadLibrary = _nbElf.findSymbol("NativeBridgeLoadLibrary");
            if (pLoadLibrary == 0)
                pLoadLibrary = _nbElf.findSymbol("_ZN7android23NativeBridgeLoadLibraryEPKci");

            uintptr_t pGetTrampoline = _nbElf.findSymbol("NativeBridgeGetTrampoline");
            if (pGetTrampoline == 0)
                pGetTrampoline = _nbElf.findSymbol("_ZN7android25NativeBridgeGetTrampolineEPvPKcS2_j");

            if (pLoadLibrary != 0)
                *(uintptr_t *)&_nbItf_data.loadLibrary = pLoadLibrary;

            if (pGetTrampoline != 0)
                *(uintptr_t *)&_nbItf_data.getTrampoline = pGetTrampoline;
        }

        _sodlElf = ElfScanner::findElf("/libdl.so", EScanElfType::Emulated, EScanElfFilter::System);
        if (!_sodlElf.isValid())
        {
            KITTY_LOGD("NativeBridgeScanner: Failed to find emulated libdl.so");
            return false;
        }

        struct
        {
            uintptr_t phdr = 0;
            size_t phnum = 0;
        } data;

        data.phdr = _sodlElf.phdr();
        data.phnum = _sodlElf.programHeaders().size();

        KITTY_LOGD("NativeBridgeScanner: sodl phdr { %p, %zu }", (void *)(data.phdr), data.phnum);

        auto maps = KittyMemory::getAllMaps();

        // search in bss frst
        for (auto &it : _nbImplElf.bssSegments())
        {
            _sodl = findDataFirst(it.startAddress, it.endAddress, &data, sizeof(data));
            if (_sodl)
            {
                KITTY_LOGD("NativeBridgeScanner: Found sodl->phdr ref (%p) at %s", (void *)_sodl,
                           it.toString().c_str());
                break;
            }
        }

        if (_sodl == 0)
        {
            // search in read-only "[anon:Mem_" or "[anon:linker_alloc]"
            for (auto &it : maps)
            {
                if (!it.is_private || !it.is_ro || it.inode != 0)
                    continue;

                if (!KittyUtils::String::StartsWith(it.pathname, "[anon:Mem_") && it.pathname != "[anon:linker_alloc]")
                    continue;

                _sodl = findDataFirst(it.startAddress, it.endAddress, &data, sizeof(data));
                if (_sodl)
                {
                    KITTY_LOGD("NativeBridgeScanner: Found sodl->phdr ref (%p) at %s", (void *)_sodl,
                               it.toString().c_str());
                    break;
                }
            }
        }

        if (_sodl == 0)
        {
            KITTY_LOGD("NativeBridgeScanner: Failed to find refs to emulated libdl.so phdr data");
            return false;
        }

        std::vector<char> si_buf(KT_SOINFO_BUFFER_SZ, 0);
        for (size_t i = 0; i < si_buf.size(); i += sizeof(uintptr_t))
        {
            if (KittyMemory::getAddressMap(_sodl + i, maps).readable)
            {
                memcpy((void *)(si_buf.data() + i), (const void *)(_sodl + i), sizeof(uintptr_t));
            }
        }

        for (size_t i = 0; i < si_buf.size(); i += sizeof(uintptr_t))
        {
            uintptr_t possible_next = *(uintptr_t *)&si_buf[i];
            if (!KittyMemory::getAddressMap(possible_next, maps).readable)
                continue;

            std::vector<char> si_buf_inner(KT_SOINFO_BUFFER_SZ, 0);
            for (size_t j = 0; j < si_buf_inner.size(); j += sizeof(uintptr_t))
            {
                if (KittyMemory::getAddressMap(possible_next + j, maps).readable)
                {
                    memcpy((void *)(si_buf_inner.data() + j), (const void *)(possible_next + j), sizeof(uintptr_t));
                }
            }

            ElfScanner si_elf{};
            for (size_t j = 0; j < si_buf_inner.size(); j += sizeof(uintptr_t))
            {
                uintptr_t possible_base = *(uintptr_t *)&si_buf_inner[j];

                auto tmp_map = KittyMemory::getAddressMap(possible_base, maps);
                if (possible_base != tmp_map.startAddress || !tmp_map.isValid() || !tmp_map.readable ||
                    tmp_map.writeable || tmp_map.is_shared)
                    continue;

                si_elf = ElfScanner(possible_base, maps);
                if (si_elf.isValid())
                {
                    _soinfo_offsets.base = j;
                    break;
                }
            }

            if (_soinfo_offsets.base == 0)
                continue;

            for (size_t j = 0; j < si_buf_inner.size(); j += sizeof(uintptr_t))
            {
                uintptr_t value = *(uintptr_t *)&si_buf_inner[j];

                if (!_soinfo_offsets.phdr && value == si_elf.phdr())
                {
                    _soinfo_offsets.phdr = j;
                    continue;
                }
                if (!_soinfo_offsets.phnum && value == si_elf.header().e_phnum)
                {
                    _soinfo_offsets.phnum = j;
                    continue;
                }
                if (!_soinfo_offsets.size &&
                    (value == si_elf.loadSize() ||
                     value == (si_elf.loadSize() + KittyMemory::getAddressMap(si_elf.end(), maps).length)))
                {
                    _soinfo_offsets.size = j;
                    continue;
                }
                if (!_soinfo_offsets.dyn && value == si_elf.dynamic())
                {
                    _soinfo_offsets.dyn = j;
                    continue;
                }
                if (!_soinfo_offsets.strtab && value == si_elf.stringTable())
                {
                    _soinfo_offsets.strtab = j;
                    continue;
                }
                if (!_soinfo_offsets.symtab && value == si_elf.symbolTable())
                {
                    _soinfo_offsets.symtab = j;
                    continue;
                }
                if (!_soinfo_offsets.bias && value == si_elf.loadBias() && j != _soinfo_offsets.base)
                {
                    _soinfo_offsets.bias = j;
                    continue;
                }
                if (!_soinfo_offsets.strsz && value == si_elf.stringTableSize())
                {
                    _soinfo_offsets.strsz = j;
                    continue;
                }
            }

            if (_soinfo_offsets.size && _soinfo_offsets.bias && _soinfo_offsets.dyn && _soinfo_offsets.symtab &&
                _soinfo_offsets.strtab)
            {
                // phdr offset might not be 0
                _sodl -= _soinfo_offsets.phdr;
                _soinfo_offsets.next = _soinfo_offsets.phdr + i;
                break;
            }
        }

        KITTY_LOGD("nb_soinfo_base(%zx) | nb_soinfo_size(%zx) | nb_soinfo_bias(%zx)", _soinfo_offsets.base,
                   _soinfo_offsets.size, _soinfo_offsets.bias);
        KITTY_LOGD("nb_soinfo_phdr(%zx, %zx) | nb_soinfo_dyn(%zx)", _soinfo_offsets.phdr, _soinfo_offsets.phnum,
                   _soinfo_offsets.dyn);
        KITTY_LOGD("nb_soinfo_strtab(%zx, %zx) | nb_soinfo_symtab(%zx)", _soinfo_offsets.strtab, _soinfo_offsets.strsz,
                   _soinfo_offsets.symtab);

        KITTY_LOGD("nb_soinfo_next(%zx)", _soinfo_offsets.next);

        _init = _soinfo_offsets.next != 0;
        return _init;
    }

    std::vector<kitty_soinfo_t> NativeBridgeScanner::allSoInfo() const
    {
        std::vector<kitty_soinfo_t> infos{};

        if (!_init)
            return infos;

        auto maps = KittyMemory::getAllMaps();
        uintptr_t si = _sodl, prev = 0;
        while (si && KittyMemory::getAddressMap(si, maps).readable)
        {
            kitty_soinfo_t info = infoFromSoInfo_(si, maps);
            infos.push_back(info);

            prev = si;

            si = *(uintptr_t *)(si + _soinfo_offsets.next);

            if (si == prev)
                break;
        }
        return infos;
    }

    kitty_soinfo_t NativeBridgeScanner::findSoInfo(const std::string &name) const
    {
        kitty_soinfo_t ret{};
        const auto list = allSoInfo();
        for (const auto &it : list)
        {
            if (KittyUtils::String::EndsWith(it.realpath, name))
            {
                ret = it;
                break;
            }
        }
        return ret;
    }

    kitty_soinfo_t NativeBridgeScanner::infoFromSoInfo_(uintptr_t si,
                                                        const std::vector<KittyMemory::ProcMap> &maps) const
    {
        kitty_soinfo_t info{};

        if (!_init)
            return info;

        info.ptr = si;
        info.base = *(uintptr_t *)(si + _soinfo_offsets.base);
        info.size = *(uintptr_t *)(si + _soinfo_offsets.size);
        info.phdr = *(uintptr_t *)(si + _soinfo_offsets.phdr);
        info.phnum = *(uintptr_t *)(si + _soinfo_offsets.phnum);
        info.dyn = *(uintptr_t *)(si + _soinfo_offsets.dyn);
        info.strtab = *(uintptr_t *)(si + _soinfo_offsets.strtab);
        info.symtab = *(uintptr_t *)(si + _soinfo_offsets.symtab);
        info.strsz = _soinfo_offsets.strsz ? *(uintptr_t *)(si + _soinfo_offsets.strsz) : 0;
        info.bias = *(uintptr_t *)(si + _soinfo_offsets.bias);
        info.next = *(uintptr_t *)(si + _soinfo_offsets.next);
        info.e_machine = _sodlElf.header().e_machine;

        uintptr_t start_map_addr = info.base;
        if (start_map_addr == 0)
            start_map_addr = info.base;
        if (start_map_addr == 0)
            start_map_addr = info.bias;
        if (start_map_addr == 0)
            start_map_addr = info.phdr;
        if (start_map_addr == 0)
            start_map_addr = info.dyn;
        if (start_map_addr == 0)
            start_map_addr = info.strtab;
        if (start_map_addr == 0)
            start_map_addr = info.symtab;

        auto si_map = KittyMemory::getAddressMap(start_map_addr, maps);
        if (si_map.isValid())
        {
            info.path = si_map.pathname;
            info.realpath = si_map.pathname;
            if (si_map.offset != 0)
            {
                KittyUtils::Zip::ZipEntryInfo ent{};
                if (KittyUtils::Zip::GetEntryInfoByDataOffset(si_map.pathname, si_map.offset, &ent) &&
                    !ent.fileName.empty())
                {
                    info.realpath += '!';
                    info.realpath += ent.fileName;
                }
            }
        }

        return info;
    }

    void *NativeBridgeLinker::dlopen(const std::string &path, int flags)
    {
#if !defined(__x86_64__) && !defined(__i386__)
        return nullptr;
#endif
        auto &nb = NativeBridgeScanner::Get();
        auto nbData = nb.nbItfData();

        if (path.empty() || !nb.init())
            return nullptr;

        if (nbData.version < 2)
        {
            KITTY_LOGD("nb_dlopen: nativebridge version (%d) is not supported", nbData.version);
            return nullptr;
        }

        if (nb.fnNativeBridgeInitialized && !nb.fnNativeBridgeInitialized())
        {
            KITTY_LOGD("nb_dlopen: nativebridge is not initialized");
            return nullptr;
        }

        /*if ((nbData..version == 2 && !nbData.isSupported(path.c_str())) ||
            !nbData.isPathSupported(path.c_str()))
        {
            KITTY_LOGD("nb_dlopen: path not supported (%s)", path.c_str());
            return nullptr;
        }*/

        if (nbData.version == 2)
            return nbData.loadLibrary(path.c_str(), flags);

        void *default_ns = nullptr;
        if (nb.isHoudini())
        {
            default_ns = (void *)uintptr_t(nbData.version >= 5 ? 5 : 3);
            if (nbData.version >= 5)
            {
                uintptr_t tmp_ns = (uintptr_t)nbData.getExportedNamespace("classloader-namespace");
                if (tmp_ns > 0 && tmp_ns <= 25)
                    default_ns = (void *)tmp_ns;
            }
        }
        else
        {
            if (nbData.getExportedNamespace)
                default_ns = nbData.getExportedNamespace("default");
            else if (nbData.getVendorNamespace)
                default_ns = nbData.getVendorNamespace();
        }

        if (!default_ns)
        {
            KITTY_LOGD("nb_dlopen: Failed to find default namespace");
            return nullptr;
        }

        return nbData.loadLibraryExt(path.c_str(), flags, default_ns);
    }

    void *NativeBridgeLinker::dlsym(void *handle, const std::string &sym_name)
    {
#if !defined(__x86_64__) && !defined(__i386__)
        return nullptr;
#endif
        auto &nb = NativeBridgeScanner::Get();
        auto nbData = nb.nbItfData();

        if (!handle || !nb.init())
            return nullptr;

        if (nbData.version < 2)
        {
            KITTY_LOGD("nb_dlsym: nativebridge version (%d) is not supported", nbData.version);
            return nullptr;
        }

        if (nb.fnNativeBridgeInitialized && !nb.fnNativeBridgeInitialized())
        {
            KITTY_LOGD("nb_dlsym: nativebridge is not initialized");
            return nullptr;
        }

        if (nbData.version < 7)
        {
            return nbData.getTrampoline(handle, sym_name.c_str(), nullptr, 0);
        }

        return nbData.getTrampolineWithJNICallType(handle, sym_name.c_str(), nullptr, 0, KT_JNICallTypeRegular);
    }

    int NativeBridgeLinker::dlclose(void *handle)
    {
#if !defined(__x86_64__) && !defined(__i386__)
        return -1;
#endif
        auto &nb = NativeBridgeScanner::Get();
        auto nbData = nb.nbItfData();

        if (nbData.version < 3)
        {
            KITTY_LOGD("nb_dlclose: nativebridge version (%d) is not supported", nbData.version);
            return -1;
        }

        if (nb.fnNativeBridgeInitialized && !nb.fnNativeBridgeInitialized())
        {
            KITTY_LOGD("nb_dlclose: nativebridge is not initialized");
            return -1;
        }

        return nbData.unloadLibrary(handle);
    }

    const char *NativeBridgeLinker::dlerror()
    {
#if !defined(__x86_64__) && !defined(__i386__)
        return nullptr;
#endif
        auto &nb = NativeBridgeScanner::Get();
        auto nbData = nb.nbItfData();

        if (nbData.version < 3)
        {
            KITTY_LOGD("nb_dlerror: nativebridge version (%d) is not supported", nbData.version);
            return nullptr;
        }

        if (nb.fnNativeBridgeInitialized && !nb.fnNativeBridgeInitialized())
        {
            KITTY_LOGD("nb_dlerror: nativebridge is not initialized");
            return nullptr;
        }

        return nbData.getError ? nbData.getError() : nullptr;
    }

    bool NativeBridgeLinker::dladdr(const void *addr, kitty_soinfo_t *info)
    {
        for (const auto &it : NativeBridgeScanner::Get().allSoInfo())
        {
            if (uintptr_t(addr) >= it.base && uintptr_t(addr) < (it.base + it.size))
            {
                if (info)
                    *info = it;
                return true;
            }
        }

        return false;
    }

    void NativeBridgeLinker::dl_iterate_phdr(const std::function<bool(const kitty_soinfo_t *)> &callback)
    {
        if (!callback)
            return;

        for (const auto &it : NativeBridgeScanner::Get().allSoInfo())
        {
            if (callback(&it))
                break;
        }
    }

#endif // __ANDROID__

} // namespace KittyScanner

```

`KittyMemory/KittyScanner.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>
#include <vector>
#include <utility>

#ifdef __ANDROID__
#include <dlfcn.h>
#include <unordered_map>
#include <mutex>
#endif

#include "KittyMemory.hpp"

namespace KittyScanner
{
    /**
     * Search for bytes within a memory range and return all results
     *
     * @start: search start address
     * @end: search end address
     * @bytes: bytes to search
     * @mask: bytes mask x/?
     *
     * @return vector list of all found bytes addresses
     */
    std::vector<uintptr_t> findBytesAll(const uintptr_t start, const uintptr_t end, const char *bytes,
                                        const std::string &mask);

    /**
     * Search for bytes within a memory range and return first result
     *
     * @start: search start address
     * @end: search end address
     * @bytes: bytes to search
     * @mask: bytes mask x/?
     *
     * @return first found bytes address
     */
    uintptr_t findBytesFirst(const uintptr_t start, const uintptr_t end, const char *bytes, const std::string &mask);

    /**
     * Search for hex within a memory range and return all results
     *
     * @start: search start address
     * @end: search end address
     * @hex: hex to search
     * @mask: hex mask x/?
     *
     * @return vector list of all found hex addresses
     */
    std::vector<uintptr_t> findHexAll(const uintptr_t start, const uintptr_t end, std::string hex,
                                      const std::string &mask);

    /**
     * Search for hex within a memory range and return first result
     *
     * @start: search start address
     * @end: search end address
     * @hex: hex to search
     * @mask: hex mask x/?
     *
     * @return first found hex address
     */
    uintptr_t findHexFirst(const uintptr_t start, const uintptr_t end, std::string hex, const std::string &mask);

    /**
     * Search for ida pattern within a memory range and return all results
     *
     * @param start: search start address
     * @param end: search end address
     * @param pattern: hex bytes and wildcard "?" ( FF DD ? 99 CC ? 00 )
     *
     * @return vector list of all found pattern addresses
     */
    std::vector<uintptr_t> findIdaPatternAll(const uintptr_t start, const uintptr_t end, const std::string &pattern);

    /**
     * Search for ida pattern within a memory range and return first result
     *
     * @param start: search start address
     * @param end: search end address
     * @param pattern: hex bytes and wildcard "?" ( FF DD ? 99 CC ? 00 )
     *
     * @return first found pattern address
     */
    uintptr_t findIdaPatternFirst(const uintptr_t start, const uintptr_t end, const std::string &pattern);

    /**
     * Search for data within a memory range and return all results
     *
     * @start: search start address
     * @end: search end address
     * @data: data to search
     * @size: data size
     *
     * @return vector list of all found data addresses
     */
    std::vector<uintptr_t> findDataAll(const uintptr_t start, const uintptr_t end, const void *data, size_t size);

    /**
     * Search for data within a memory range and return first result
     *
     * @start: search start address
     * @end: search end address
     * @data: data to search
     * @size: data size
     *
     * @return first found data address
     */
    uintptr_t findDataFirst(const uintptr_t start, const uintptr_t end, const void *data, size_t size);

#ifdef __ANDROID__

    class RegisterNativeFn
    {
    public:
        char *name;
        char *signature;
        void *fnPtr;

        RegisterNativeFn() : name(nullptr), signature(nullptr), fnPtr(nullptr)
        {
        }
        inline bool isValid() const
        {
            return (name != nullptr && signature != nullptr && fnPtr != nullptr);
        }
    };

#define KT_SOINFO_BUFFER_SZ (0x250)
    struct kitty_soinfo_t
    {
        uintptr_t ptr = 0;
        uintptr_t base = 0;
        size_t size = 0;
        uintptr_t phdr = 0;
        size_t phnum = 0;
        uintptr_t dyn = 0;
        uintptr_t strtab = 0;
        uintptr_t symtab = 0;
        size_t strsz = 0;
        uintptr_t bias = 0;
        uintptr_t next = 0;
        uint16_t e_machine = 0;
        std::string path;
        std::string realpath;
    };

    enum class EScanElfType : uint32_t
    {
        Any,
        Native,
        Emulated,
    };
    enum class EScanElfFilter : uint32_t
    {
        Any,
        System,
        App,
    };

    class ElfScanner
    {
    private:
        uintptr_t _elfBase;
        KT_ElfW(Ehdr) _ehdr;
        uintptr_t _phdr;
        std::vector<KT_ElfW(Phdr)> _phdrs;
        int _loads;
        uintptr_t _loadBias, _loadSize;
        uintptr_t _dynamic;
        std::vector<KT_ElfW(Dyn)> _dynamics;
        uintptr_t _stringTable, _symbolTable, _elfHashTable, _gnuHashTable;
        size_t _strsz, _syment;
        std::string _filepath;
        std::string _realpath;
        bool _fixedBySoInfo;
        bool _dsymbols_init;
        std::unordered_map<std::string, uintptr_t> _dsymbolsMap;
        std::vector<KittyMemory::ProcMap> _segments;
        std::vector<KittyMemory::ProcMap> _bssSegments;
        KittyMemory::ProcMap _baseSegment;

    public:
        ElfScanner()
            : _elfBase(0), _phdr(0), _loads(0), _loadBias(0), _loadSize(0), _dynamic(0), _stringTable(0),
              _symbolTable(0), _elfHashTable(0), _gnuHashTable(0), _strsz(0), _syment(0), _fixedBySoInfo(false),
              _dsymbols_init(false)
        {
        }

        ElfScanner(uintptr_t elfBase, const std::vector<KittyMemory::ProcMap> &maps = KittyMemory::getAllMaps());
        ElfScanner(const kitty_soinfo_t &soinfo,
                   const std::vector<KittyMemory::ProcMap> &maps = KittyMemory::getAllMaps());

        inline void refresh()
        {
            *this = ElfScanner(_elfBase);
        }

        inline bool isValid() const
        {
            return _elfBase && _loadSize && _phdr && _loadBias;
        }

        inline bool isFixedBySoInfo() const
        {
            return _fixedBySoInfo;
        }

        inline uintptr_t base() const
        {
            return _elfBase;
        }

        inline uintptr_t end() const
        {
            return _elfBase + _loadSize;
        }

        inline KT_ElfW(Ehdr) header() const
        {
            return _ehdr;
        }

        inline uintptr_t phdr() const
        {
            return _phdr;
        }

        inline std::vector<KT_ElfW(Phdr)> programHeaders() const
        {
            return _phdrs;
        }

        inline int loads() const
        {
            return _loads;
        }

        inline uintptr_t loadBias() const
        {
            return _loadBias;
        }

        inline uintptr_t loadSize() const
        {
            return _loadSize;
        }

        inline uintptr_t dynamic() const
        {
            return _dynamic;
        }

        inline std::vector<KT_ElfW(Dyn)> dynamics() const
        {
            return _dynamics;
        }

        inline uintptr_t stringTable() const
        {
            return _stringTable;
        }

        inline uintptr_t symbolTable() const
        {
            return _symbolTable;
        }

        inline size_t stringTableSize() const
        {
            return _strsz;
        }

        inline size_t symbolEntrySize() const
        {
            return _syment;
        }

        inline uintptr_t elfHashTable() const
        {
            return _elfHashTable;
        }

        inline uintptr_t gnuHashTable() const
        {
            return _gnuHashTable;
        }

        uintptr_t findSymbol(const std::string &symbolName) const;

        // debug symbols from SHT_SYMTAB on disk
        std::unordered_map<std::string, uintptr_t> dsymbols();
        uintptr_t findDebugSymbol(const std::string &symbolName);

        KittyMemory::ProcMap baseSegment() const
        {
            return _baseSegment;
        }

        std::vector<KittyMemory::ProcMap> segments() const
        {
            return _segments;
        }

        std::vector<KittyMemory::ProcMap> bssSegments() const
        {
            return _bssSegments;
        }

        inline std::string filePath() const
        {
            return _filepath;
        }

        inline std::string realPath() const
        {
            return _realpath;
        }

        inline bool isZipped() const
        {
            return _baseSegment.offset != 0;
        }

        inline bool isNative() const
        {
            int a = getProgramElf().header().e_machine, b = _ehdr.e_machine;
            return a != 0 && b != 0 && a == b;
        }

        inline bool isEmulated() const
        {
            int a = getProgramElf().header().e_machine, b = _ehdr.e_machine;
            return a != 0 && b != 0 && a != b;
        }

        /**
         * search for string "name" references to find the JNINativeMethod array
         */
        RegisterNativeFn findRegisterNativeFn(const std::string &name, const std::string &signature) const;

        // dump ELF to disk
        bool dumpToDisk(const std::string &destination) const;

        static ElfScanner &getProgramElf();

        /**
         * Fetch all in-memory loaded ELFs
         */
        static std::vector<ElfScanner> getAllELFs(EScanElfType type = EScanElfType::Any,
                                                  EScanElfFilter filter = EScanElfFilter::Any);

        /**
         * Find in-memory loaded ELF with name
         */
        static ElfScanner findElf(const std::string &path, EScanElfType type = EScanElfType::Any,
                                  EScanElfFilter filter = EScanElfFilter::Any);

        /**
         * lookup symbol name in all loaded ELFs
         * @return a vector of symbol absolute address and the ELF where the symbol was found in
         */
        static std::vector<std::pair<uintptr_t, ElfScanner>> findSymbolAll(const std::string &symbolName,
                                                                           EScanElfType type = EScanElfType::Any,
                                                                           EScanElfFilter filter = EScanElfFilter::Any);

        static ElfScanner createWithBase(uintptr_t elfBase,
                                         const std::vector<KittyMemory::ProcMap> &maps = KittyMemory::getAllMaps())
        {
            return ElfScanner(elfBase, maps);
        }

        static ElfScanner createWithMap(const KittyMemory::ProcMap &elfMap,
                                         const std::vector<KittyMemory::ProcMap> &maps = KittyMemory::getAllMaps())
        {
            return ElfScanner(elfMap.startAddress, maps);
        }

        static ElfScanner createWithSoInfo(const kitty_soinfo_t &soinfo,
                                           const std::vector<KittyMemory::ProcMap> &maps = KittyMemory::getAllMaps())
        {
            return ElfScanner(soinfo, maps);
        }
    };

    struct kitty_linker_syms_t
    {
        uintptr_t solist = 0;
        uintptr_t somain = 0;
        uintptr_t sonext = 0;
    };

    struct kitty_soinfo_offsets_t
    {
        uintptr_t base = 0;
        uintptr_t size = 0;
        uintptr_t phdr = 0;
        uintptr_t phnum = 0;
        uintptr_t dyn = 0;
        uintptr_t strtab = 0;
        uintptr_t symtab = 0;
        uintptr_t strsz = 0;
        uintptr_t bias = 0;
        uintptr_t next = 0;
    };

    class LinkerScanner : public ElfScanner
    {
    protected:
        kitty_linker_syms_t _linker_syms;
        kitty_soinfo_offsets_t _soinfo_offsets;
        bool _init;

        bool init();

    public:
        LinkerScanner() : ElfScanner(), _init(false)
        {
            memset(&_linker_syms, 0, sizeof(_linker_syms));
            memset(&_soinfo_offsets, 0, sizeof(_soinfo_offsets));
        }

        LinkerScanner(uintptr_t linkerBase);
        LinkerScanner(const ElfScanner &linkerElf);

        inline static LinkerScanner &Get()
        {
            static LinkerScanner linker{};
            if (!linker.isValid() || !linker.init())
            {
                LinkerScanner tmp_linker{};
#ifdef __LP64__
                tmp_linker = LinkerScanner(
                    ElfScanner::findElf("/bin/linker64", EScanElfType::Native, EScanElfFilter::System));
#else
                tmp_linker = LinkerScanner(
                    ElfScanner::findElf("/bin/linker", EScanElfType::Native, EScanElfFilter::System));
#endif
                if (tmp_linker.isValid() && tmp_linker.init())
                    linker = tmp_linker;
            }
            return linker;
        }

        inline ElfScanner *asELF() const
        {
            return (ElfScanner *)this;
        }

        inline kitty_linker_syms_t linker_offsets() const
        {
            return _linker_syms;
        }

        inline kitty_soinfo_offsets_t soinfo_offsets() const
        {
            return _soinfo_offsets;
        }

        inline uintptr_t solist() const
        {
            if (!isValid() || !_linker_syms.solist)
                return 0;

            return *(uintptr_t *)(_linker_syms.solist);
        }

        inline uintptr_t somain() const
        {
            if (!isValid() || !_linker_syms.somain)
                return 0;

            return *(uintptr_t *)(_linker_syms.somain);
        }

        inline uintptr_t sonext() const
        {
            if (!isValid() || !_linker_syms.sonext)
                return 0;

            return *(uintptr_t *)(_linker_syms.sonext);
        }

        inline kitty_soinfo_t somainInfo() const
        {
            if (!isValid() || !_linker_syms.somain)
                return {};

            return infoFromSoInfo_(somain(), KittyMemory::getAllMaps());
        }

        inline kitty_soinfo_t sonextInfo() const
        {
            if (!isValid() || _linker_syms.sonext)
                return {};

            return infoFromSoInfo_(sonext(), KittyMemory::getAllMaps());
        }

        std::vector<kitty_soinfo_t> allSoInfo() const;

        kitty_soinfo_t findSoInfo(const std::string &name) const;

    private:
        kitty_soinfo_t infoFromSoInfo_(uintptr_t si, const std::vector<KittyMemory::ProcMap> &maps) const;
    };

    enum KT_JNICallType
    {
        KT_JNICallTypeRegular = 1,
        KT_JNICallTypeCriticalNative = 2,
    };

    enum KT_NativeBridgeImplementationVersion
    {
        // first version, not used.
        KT_NB_DEFAULT_VERSION = 1,
        // The version which signal semantic is introduced.
        KT_NB_SIGNAL_VERSION = 2,
        // The version which namespace semantic is introduced.
        KT_NB_NAMESPACE_VERSION = 3,
        // The version with vendor namespaces
        KT_NB_VENDOR_NAMESPACE_VERSION = 4,
        // The version with runtime namespaces
        KT_NB_RUNTIME_NAMESPACE_VERSION = 5,
        // The version with pre-zygote-fork hook to support app-zygotes.
        KT_NB_PRE_ZYGOTE_FORK_VERSION = 6,
        // The version with critical_native support
        KT_NB_CRITICAL_NATIVE_SUPPORT_VERSION = 7,
        // The version with native bridge detection fallback for function pointers
        KT_NB_IDENTIFY_NATIVELY_BRIDGED_FUNCTION_POINTERS_VERSION = 8,
    };

    struct nbItf_data_t
    {
        inline nbItf_data_t()
        {
            memset(this, 0, sizeof(nbItf_data_t));
        }

        int version;
#ifdef __LP64__
        uint32_t pad1;
#endif
        bool (*initialize)(const void *runtime_cbs, const char *private_dir, const char *instruction_set);
        void *(*loadLibrary)(const char *libpath, int flag);
        void *(*getTrampoline)(void *handle, const char *name, const char *shorty, uint32_t len);
        bool (*isSupported)(const char *libpath);
        const void *(*getAppEnv)(const char *instruction_set);
        bool (*isCompatibleWith)(uint32_t bridge_version);
        void *(*getSignalHandler)(int signal);
        int (*unloadLibrary)(void *handle);
        const char *(*getError)();
        bool (*isPathSupported)(const char *library_path);
        bool (*initAnonymousNamespace)(const char *public_ns_sonames, const char *anon_ns_library_path);
        void *(*createNamespace)(const char *name, const char *ld_library_path, const char *default_library_path,
                                 uint64_t type, const char *permitted_when_isolated_path, void *parent_ns);
        bool (*linkNamespaces)(void *from, void *to, const char *shared_libs_sonames);
        void *(*loadLibraryExt)(const char *libpath, int flag, void *ns);
        void *(*getVendorNamespace)();
        void *(*getExportedNamespace)(const char *name);
        void (*preZygoteFork)();
        void *(*getTrampolineWithJNICallType)(void *handle, const char *name, const char *shorty, uint32_t len,
                                              enum KT_JNICallType jni_call_type);
        void *(*getTrampolineForFunctionPointer)(const void *method, const char *shorty, uint32_t len,
                                                 enum KT_JNICallType jni_call_type);
        bool (*isNativeBridgeFunctionPointer)(const void *method);

        inline static size_t GetStructSize(int version)
        {
            switch (version)
            {
            case KT_NB_SIGNAL_VERSION:
                return sizeof(uintptr_t) * 8;
            case KT_NB_NAMESPACE_VERSION:
                return sizeof(uintptr_t) * 15;
            case KT_NB_VENDOR_NAMESPACE_VERSION:
                return sizeof(uintptr_t) * 16;
            case KT_NB_RUNTIME_NAMESPACE_VERSION:
                return sizeof(uintptr_t) * 17;
            case KT_NB_PRE_ZYGOTE_FORK_VERSION:
                return sizeof(uintptr_t) * 18;
            case KT_NB_CRITICAL_NATIVE_SUPPORT_VERSION:
                return sizeof(uintptr_t) * 19;
            case KT_NB_IDENTIFY_NATIVELY_BRIDGED_FUNCTION_POINTERS_VERSION:
                return sizeof(uintptr_t) * 21;
            }
            return 0;
        }
    };

    class NativeBridgeScanner
    {
    private:
        ElfScanner _nbElf, _nbImplElf, _sodlElf;
        uintptr_t _sodl;
        kitty_soinfo_offsets_t _soinfo_offsets;
        bool _init;
        bool _isHoudini;

        uintptr_t _nbItf;
        size_t _nbItf_data_size;
        nbItf_data_t _nbItf_data;

    public:
        bool (*fnNativeBridgeInitialized)();

        NativeBridgeScanner()
            : _sodl(0), _init(false), _isHoudini(false), _nbItf(0), _nbItf_data_size(0),
              fnNativeBridgeInitialized(nullptr)
        {
            memset(&_nbItf_data, 0, sizeof(_nbItf_data));
            memset(&_soinfo_offsets, 0, sizeof(_soinfo_offsets));
        }

        inline static NativeBridgeScanner &Get()
        {
            static NativeBridgeScanner nb{};
            ((void)nb.init());
            return nb;
        }

        bool init();

        inline bool isValid() const
        {
            return _init;
        }

        inline uintptr_t sodl() const
        {
            return _sodl;
        }

        inline kitty_soinfo_t sodlInfo() const
        {
            if (!_init || !_sodl)
                return {};

            return infoFromSoInfo_(_sodl, KittyMemory::getAllMaps());
        }

        std::vector<kitty_soinfo_t> allSoInfo() const;

        kitty_soinfo_t findSoInfo(const std::string &name) const;

        inline size_t nbItfDataSize() const
        {
            return _nbItf_data_size;
        }

        inline nbItf_data_t nbItfData() const
        {
            return _nbItf_data;
        }

        inline bool isHoudini()
        {
            return _isHoudini;
        }

    private:
        kitty_soinfo_t infoFromSoInfo_(uintptr_t si, const std::vector<KittyMemory::ProcMap> &maps) const;
    };

    class NativeBridgeLinker
    {
    public:
        // native bride load library
        static void *dlopen(const std::string &path, int flags);
        // native bridge get trampoline
        static void *dlsym(void *handle, const std::string &sym_name);
        // native bridge unload library
        static int dlclose(void *handle);
        // native bridge dlerror
        static const char *dlerror();
        // native bridge dlladdr
        static bool dladdr(const void *addr, kitty_soinfo_t *info);
        // native bridge dl_iterate_phdr
        static void dl_iterate_phdr(const std::function<bool(const kitty_soinfo_t *info)> &callback);
    };

#endif // __ANDROID__

} // namespace KittyScanner

```

`KittyMemory/KittyUtils.cpp`:

```cpp
#include "KittyUtils.hpp"

#ifdef __ANDROID__
#include <sys/system_properties.h>
#endif

namespace KittyUtils
{

#ifdef __ANDROID__
    std::string getExternalStorage()
    {
        char *storage = getenv("EXTERNAL_STORAGE");
        return storage ? storage : "/sdcard";
    }

    int getAndroidVersion()
    {
        static int ver = 0;
        if (ver > 0)
            return ver;

        char buf[0xff] = {0};
        if (__system_property_get("ro.build.version.release", buf))
            ver = std::atoi(buf);

        return ver;
    }

    int getAndroidSDK()
    {
        static int sdk = 0;
        if (sdk > 0)
            return sdk;

        char buf[0xff] = {0};
        if (__system_property_get("ro.build.version.sdk", buf))
            sdk = std::atoi(buf);

        return sdk;
    }
#endif

    std::string fileNameFromPath(const std::string &filePath)
    {
        std::string filename;
        const size_t last_slash_idx = filePath.find_last_of("/\\");
        if (std::string::npos != last_slash_idx)
            filename = filePath.substr(last_slash_idx + 1);
        return filename;
    }

    std::string fileDirectory(const std::string &filePath)
    {
        std::string directory;
        const size_t last_slash_idx = filePath.find_last_of("/\\");
        if (std::string::npos != last_slash_idx)
            directory = filePath.substr(0, last_slash_idx);
        return directory;
    }

    std::string fileExtension(const std::string &filePath)
    {
        std::string ext;
        const size_t last_slash_idx = filePath.find_last_of(".");
        if (std::string::npos != last_slash_idx)
            ext = filePath.substr(last_slash_idx + 1);
        return ext;
    }

    void String::Trim(std::string &str)
    {
        // https://www.techiedelight.com/remove-whitespaces-string-cpp/
        str.erase(std::remove_if(str.begin(), str.end(), [](char c)
        { return (c == ' ' || c == '\n' || c == '\r' ||
                  c == '\t' || c == '\v' || c == '\f'); }),
                  str.end());
    }

    bool String::ValidateHex(std::string &hex)
    {
        if (hex.empty()) return false;

        if (hex.compare(0, 2, "0x") == 0)
            hex.erase(0, 2);

        Trim(hex);  // first remove spaces

        if (hex.length() < 2 || hex.length() % 2 != 0) return false;

        for (size_t i = 0; i < hex.length(); i++)
        {
            if (!std::isxdigit((unsigned char)hex[i]))
                return false;
        }

        return true;
    }

    std::string String::Fmt(const char *fmt, ...)
    {
        if (!fmt)
            return "";

        va_list args;

        va_start(args, fmt);
        size_t size = vsnprintf(nullptr, 0, fmt, args) + 1;  // extra space for '\0'
        va_end(args);

        std::vector<char> buffer(size, '\0');

        va_start(args, fmt);
        vsnprintf(&buffer[0], size, fmt, args);
        va_end(args);

        return std::string(&buffer[0]);
    }

    std::string String::Random(size_t length)
    {
        static const std::string chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

        static std::mutex mtx;
        std::lock_guard<std::mutex> lock(mtx);

        static std::default_random_engine rnd(std::random_device{}());
        static std::uniform_int_distribution<std::string::size_type> dist(0, chars.size() - 1);

        std::string str(length, '\0');
        for (size_t i = 0; i < length; ++i)
            str[i] = chars[dist(rnd)];

        return str;
    }

    // https://tweex.net/post/c-anything-tofrom-a-hex-string/

    /*
        Convert a block of data to a hex string
    */
    std::string data2Hex(
        const void *data,        //!< Data to convert
        const size_t dataLength  //!< Length of the data to convert
    )
    {
        const auto *byteData = reinterpret_cast<const unsigned char *>(data);
        std::stringstream hexStringStream;

        hexStringStream << std::hex << std::setfill('0');
        for (size_t index = 0; index < dataLength; ++index)
            hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);
        return hexStringStream.str();
    }

    /*
        Convert a hex string to a block of data
    */
    void dataFromHex(
        const std::string &in,  //!< Input hex string
        void *data              //!< Data store
    )
    {
        size_t length = in.length();
        auto *byteData = reinterpret_cast<unsigned char *>(data);

        std::stringstream hexStringStream;
        hexStringStream >> std::hex;
        for (size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)
        {
            // Read out and convert the string two characters at a time
            const char tmpStr[3] = {in[strIndex++], in[strIndex++], 0};

            // Reset and fill the string stream
            hexStringStream.clear();
            hexStringStream.str(tmpStr);

            // Do the conversion
            int tmpValue = 0;
            hexStringStream >> tmpValue;
            byteData[dataIndex] = static_cast<unsigned char>(tmpValue);
        }
    }

#ifdef __ANDROID__

    // refs to
    // https://refspecs.linuxfoundation.org/elf/elf.pdf
    // https://flapenguin.me/elf-dt-hash
    // https://flapenguin.me/elf-dt-gnu-hash

    namespace Elf
    {
        namespace ElfHash
        {
            uint32_t HashSymName(const char *name)
            {
                uint32_t h = 0, g;
                for (; *name; name++)
                {
                    h = (h << 4) + *name;
                    g = h & 0xf0000000;
                    if (g)
                        h ^= g >> 24;
                    h &= ~g;
                }
                return h;
            }

            const KT_ElfW(Sym) * LookupByName(uintptr_t elfhash,
                                              uintptr_t symtab,
                                              uintptr_t strtab,
                                              size_t syment,
                                              size_t strsz,
                                              const char *symbol_name)
            {
                const auto *elf_hash = reinterpret_cast<const uint32_t *>(elfhash);
                const auto *symbol_table = reinterpret_cast<const uint8_t *>(symtab);
                const auto *string_table = reinterpret_cast<const char *>(strtab);

                const size_t num_bucket = elf_hash[0];
                if (!num_bucket)
                    return nullptr;

                const size_t num_chain = elf_hash[1];
                if (!num_chain)
                    return nullptr;

                const uint32_t *bucket = elf_hash + 2;
                const uint32_t *chain = bucket + num_bucket;

                const uint32_t name_hash = HashSymName(symbol_name);
                for (uint32_t i = bucket[name_hash % num_bucket]; i != 0 && i < num_chain; i = chain[i])
                {
                    const auto *symbol = reinterpret_cast<const KT_ElfW(Sym) *>(symbol_table + (syment * i));
                    if (!symbol || symbol->st_name >= strsz)
                        break;

                    std::string sym_str = std::string(string_table + symbol->st_name);
                    if (!sym_str.empty() && sym_str == symbol_name)
                        return symbol;
                }

                return nullptr;
            }
        }  // namespace ElfHash
    }  // namespace Elf

    namespace Elf
    {
        namespace GnuHash
        {
            uint32_t HashSymName(const char *name)
            {
                uint32_t h = 5381;
                for (; *name; name++)
                    h = (h << 5) + h + *name;
                return h;
            }

            const KT_ElfW(Sym) * LookupByName(uintptr_t gnuhash,
                                              uintptr_t symtab,
                                              uintptr_t strtab,
                                              size_t syment,
                                              size_t strsz,
                                              const char *symbol_name)
            {
                const auto *gnu_hash = reinterpret_cast<const uint32_t *>(gnuhash);
                const auto *symbol_table = reinterpret_cast<const uint8_t *>(symtab);
                const auto *string_table = reinterpret_cast<const char *>(strtab);

                const uint32_t name_hash = HashSymName(symbol_name);

                const uint32_t num_buckets = gnu_hash[0];
                if (!num_buckets)
                    return nullptr;

                const uint32_t sym_offset = gnu_hash[1];

                const uint32_t bloom_size = gnu_hash[2];
                // must be a power of 2
                if (!bloom_size || (bloom_size & (bloom_size - 1)) != 0)
                    return nullptr;

                const uint32_t bloom_shift = gnu_hash[3];
                const auto *bloom = reinterpret_cast<const uintptr_t *>(&gnu_hash[4]);
                const auto *buckets = reinterpret_cast<const uint32_t *>(&bloom[bloom_size]);
                const uint32_t *chain = &buckets[num_buckets];

                uintptr_t word = bloom[(name_hash / KT_ELFCLASS_BITS) % bloom_size];
                uintptr_t mask = 0 | (uintptr_t)1 << (name_hash % KT_ELFCLASS_BITS) | (uintptr_t)1 << ((name_hash >> bloom_shift) % KT_ELFCLASS_BITS);

                // If at least one bit is not set, a symbol is surely missing.
                if ((word & mask) != mask)
                    return nullptr;

                uint32_t sym_idx = buckets[name_hash % num_buckets];
                if (sym_idx < sym_offset)
                    return nullptr;

                // Loop through the chain.
                while (true)
                {
                    const auto *symbol = reinterpret_cast<const KT_ElfW(Sym) *>(symbol_table + (syment * sym_idx));
                    if (!symbol || symbol->st_name >= strsz)
                        break;

                    const uint32_t hash = chain[sym_idx - sym_offset];
                    if ((name_hash | 1) == (hash | 1))
                    {
                        std::string sym_str = std::string(string_table + symbol->st_name);
                        if (!sym_str.empty() && sym_str == symbol_name)
                            return symbol;
                    }

                    // Chain ends with an element with the lowest bit set to 1.
                    if (hash & 1)
                        break;

                    sym_idx++;
                }

                return nullptr;
            }
        }  // namespace GnuHash
    }  // namespace Elf

    namespace Zip
    {
#define KT_MIN_EOCD_SIZE 22
#define KT_EOCD_SIGNATURE 0x06054b50
#define KT_ZIP64_EOCD_SIGNATURE 0x06064b50
#define KT_ZIP64_EOCD_LOCATOR 0x07064b50
#define KT_CENTRAL_DIR_SIGNATURE 0x02014b50
#define KT_LOCAL_HEADER_SIGNATURE 0x04034b50
#define KT_ZIP64_EXTRA_ID 0x0001
#define KT_MAX_NAME_LEN 65535
#define KT_MAX_EOCD_SEARCH (1024 * 64)
#define KT_CENTRAL_DIR_SIZE 46
#define KT_LOCAL_HEADER_SIZE 30

        inline bool read16(const uint8_t *base, uint64_t size, uint64_t offset, uint16_t &out)
        {
            if (offset + 2 > size)
                return false;
            std::memcpy(&out, base + offset, 2);
            return true;
        }

        inline bool read32(const uint8_t *base, uint64_t size, uint64_t offset, uint32_t &out)
        {
            if (offset + 4 > size)
                return false;
            std::memcpy(&out, base + offset, 4);
            return true;
        }

        inline bool read64(const uint8_t *base, uint64_t size, uint64_t offset, uint64_t &out)
        {
            if (offset + 8 > size)
                return false;
            std::memcpy(&out, base + offset, 8);
            return true;
        }

        bool findCentralDirectory(const uint8_t *data, uint64_t fileSize, uint64_t *cdOffset, uint64_t *totalEntries)
        {
            if (fileSize < KT_MIN_EOCD_SIZE)
                return false;

            uint64_t searchStart = (fileSize > KT_MAX_EOCD_SEARCH) ? fileSize - KT_MAX_EOCD_SEARCH : 0;

            for (int64_t offset = fileSize - 4; offset >= (int64_t)searchStart; --offset)
            {
                uint32_t sig;
                if (!read32(data, fileSize, offset, sig))
                    continue;

                if (sig == KT_EOCD_SIGNATURE)
                {
                    uint16_t entries16;
                    uint32_t cdOff32;

                    if (!read16(data, fileSize, offset + 10, entries16))
                        return false;
                    if (!read32(data, fileSize, offset + 16, cdOff32))
                        return false;

                    if (totalEntries)
                        *totalEntries = entries16;

                    if (cdOffset)
                        *cdOffset = cdOff32;

                    return true;
                }

                if (sig == KT_ZIP64_EOCD_LOCATOR)
                {
                    uint64_t zip64EOCDOffset;
                    if (!read64(data, fileSize, offset + 8, zip64EOCDOffset))
                        return false;

                    uint32_t zip64sig;
                    if (!read32(data, fileSize, zip64EOCDOffset, zip64sig))
                        return false;

                    if (zip64sig != KT_ZIP64_EOCD_SIGNATURE)
                        return false;

                    uint64_t entries64;
                    uint64_t cdOff64;

                    if (!read64(data, fileSize, zip64EOCDOffset + 24, entries64))
                        return false;

                    if (!read64(data, fileSize, zip64EOCDOffset + 48, cdOff64))
                        return false;

                    if (totalEntries)
                        *totalEntries = entries64;

                    if (cdOffset)
                        *cdOffset = cdOff64;

                    return true;
                }
            }

            return false;
        }

        std::vector<ZipEntryInfo> listEntriesInZip(const std::string &zipPath)
        {
            std::vector<ZipEntryInfo> ents;

            int fd = KT_EINTR_RETRY(open(zipPath.c_str(), O_RDONLY));
            if (fd < 0)
                return ents;

            struct stat st{};
            if (fstat(fd, &st) < 0)
            {
                KT_EINTR_RETRY(close(fd));
                return ents;
            }

            uint64_t fileSize = st.st_size;
            if (fileSize < KT_MIN_EOCD_SIZE)
            {
                KT_EINTR_RETRY(close(fd));
                return ents;
            }

            void *map = mmap(nullptr, fileSize, PROT_READ, MAP_PRIVATE, fd, 0);
            if (!map || map == MAP_FAILED)
            {
                KT_EINTR_RETRY(close(fd));
                return ents;
            }

            const uint8_t *data = static_cast<uint8_t *>(map);

            uint64_t cdOffset = 0;
            uint64_t totalEntries = 0;

            if (!findCentralDirectory(data, fileSize, &cdOffset, &totalEntries))
            {
                munmap(map, fileSize);
                KT_EINTR_RETRY(close(fd));
                return ents;
            }

            if (cdOffset >= fileSize)
            {
                munmap(map, fileSize);
                KT_EINTR_RETRY(close(fd));
                return ents;
            }

            uint64_t offset = cdOffset;
            uint64_t parsedEntries = 0;

            while (offset + KT_CENTRAL_DIR_SIZE <= fileSize)
            {
                uint32_t sig;
                if (!read32(data, fileSize, offset, sig))
                    break;

                if (sig != KT_CENTRAL_DIR_SIGNATURE)
                    break;

                ZipEntryInfo info{};

                read16(data, fileSize, offset + 10, info.compressionMethod);
                read16(data, fileSize, offset + 12, info.modTime);
                read16(data, fileSize, offset + 14, info.modDate);
                read32(data, fileSize, offset + 16, info.crc32);

                uint32_t compSize32, uncompSize32;
                read32(data, fileSize, offset + 20, compSize32);
                read32(data, fileSize, offset + 24, uncompSize32);

                info.compressedSize = compSize32;
                info.uncompressedSize = uncompSize32;

                uint16_t nameLen, extraLen, commentLen;
                read16(data, fileSize, offset + 28, nameLen);
                read16(data, fileSize, offset + 30, extraLen);
                read16(data, fileSize, offset + 32, commentLen);

                uint32_t localHeaderOffset32;
                read32(data, fileSize, offset + 42, localHeaderOffset32);

                uint64_t entrySize = KT_CENTRAL_DIR_SIZE + nameLen + extraLen + commentLen;
                if (offset + entrySize > fileSize)
                    break;

                if (nameLen > KT_MAX_NAME_LEN)
                    break;

                info.fileName.assign(reinterpret_cast<const char *>(data + offset + KT_CENTRAL_DIR_SIZE), nameLen);

                uint64_t localHeaderOffset = localHeaderOffset32;

                // ZIP64 handling
                if (compSize32 == 0xFFFFFFFF || uncompSize32 == 0xFFFFFFFF || localHeaderOffset32 == 0xFFFFFFFF)
                {
                    uint64_t extraOffset = offset + KT_CENTRAL_DIR_SIZE + nameLen;
                    uint64_t endExtra = extraOffset + extraLen;

                    while (extraOffset + 4 <= endExtra)
                    {
                        uint16_t id, size;
                        read16(data, fileSize, extraOffset, id);
                        read16(data, fileSize, extraOffset + 2, size);

                        if (extraOffset + 4 + size > endExtra)
                            break;

                        if (id == KT_ZIP64_EXTRA_ID)
                        {
                            uint64_t fieldOffset = extraOffset + 4;

                            if (uncompSize32 == 0xFFFFFFFF)
                            {
                                read64(data, fileSize, fieldOffset, info.uncompressedSize);
                                fieldOffset += 8;
                            }

                            if (compSize32 == 0xFFFFFFFF)
                            {
                                read64(data, fileSize, fieldOffset, info.compressedSize);
                                fieldOffset += 8;
                            }

                            if (localHeaderOffset32 == 0xFFFFFFFF)
                            {
                                read64(data, fileSize, fieldOffset, localHeaderOffset);
                            }

                            break;
                        }

                        extraOffset += 4 + size;
                    }
                }

                // Validate local header
                if (localHeaderOffset + KT_LOCAL_HEADER_SIZE > fileSize)
                    break;

                uint16_t localNameLen, localExtraLen;
                read16(data, fileSize, localHeaderOffset + 26, localNameLen);
                read16(data, fileSize, localHeaderOffset + 28, localExtraLen);

                info.dataOffset = localHeaderOffset + KT_LOCAL_HEADER_SIZE + localNameLen + localExtraLen;

                if (info.dataOffset > fileSize)
                    break;

                ents.push_back(std::move(info));

                offset += entrySize;
                parsedEntries++;

                if (parsedEntries >= totalEntries)
                    break;
            }

            munmap(map, fileSize);
            KT_EINTR_RETRY(close(fd));

            return ents;
        }

        bool GetEntryInfoByDataOffset(const std::string &zipPath, uint64_t dataOffset, ZipEntryInfo *out)
        {
            if (out)
                *out = {};

            const auto ents = listEntriesInZip(zipPath);
            for (const auto &it : ents)
            {
                if (it.dataOffset == dataOffset)
                {
                    if (out)
                        *out = it;

                    return true;
                }
            }

            return false;
        }

        bool MMapEntryByDataOffset(const std::string &zipPath, uint64_t dataOffset, ZipEntryMMap *out)
        {
            if (out)
                *out = {};

            ZipEntryInfo ent{};
            if (!GetEntryInfoByDataOffset(zipPath, dataOffset, &ent))
                return false;

            uint64_t compressedSize = ent.compressedSize;

            int fd = KT_EINTR_RETRY(open(zipPath.c_str(), O_RDONLY));
            if (fd < 0)
                return false;

            struct stat st{};
            if (fstat(fd, &st) < 0)
            {
                KT_EINTR_RETRY(close(fd));
                return false;
            }

            uint64_t fileSize = st.st_size;

            if (dataOffset >= fileSize || dataOffset + compressedSize > fileSize)
            {
                KT_EINTR_RETRY(close(fd));
                return false;
            }

            const size_t pageSize = sysconf(_SC_PAGE_SIZE);
            uint64_t alignedOffset = dataOffset & ~(uint64_t(pageSize - 1));
            uint64_t offsetDiff = dataOffset - alignedOffset;
            uint64_t mapSize = offsetDiff + compressedSize;

            void *map = mmap(nullptr, mapSize, PROT_READ, MAP_PRIVATE, fd, alignedOffset);

            KT_EINTR_RETRY(close(fd));

            if (!map || map == MAP_FAILED)
                return false;

            if (out)
            {
                out->mappingBase = map;
                out->mappingSize = mapSize;
                out->data = static_cast<uint8_t *>(map) + offsetDiff;
                out->size = compressedSize;
            }

            return true;
        }
    } // namespace Zip

#endif  // __ANDROID__

}  // namespace KittyUtils

```

`KittyMemory/KittyUtils.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cstdarg>
#include <vector>
#include <utility>
#include <random>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <errno.h>
#include <inttypes.h>
#include <dirent.h>
#include <mutex>

#define KT_PAGE_SIZE (sysconf(_SC_PAGE_SIZE))

#define KT_PAGE_START(x) (uintptr_t(x) & ~(KT_PAGE_SIZE - 1))
#define KT_PAGE_END(x) (KT_PAGE_START(uintptr_t(x) + KT_PAGE_SIZE - 1))
#define KT_PAGE_OFFSET(x) (uintptr_t(x) - KT_PAGE_START(x))
#define KT_PAGE_LEN(x) (size_t(KT_PAGE_SIZE - KT_PAGE_OFFSET(x)))

#define KT_PAGE_END2(x, len) (KT_PAGE_START((uintptr_t(x) + len) + KT_PAGE_SIZE - 1))
#define KT_PAGE_LEN2(x, len) (KT_PAGE_END2(x, len) - KT_PAGE_START(x))

#define KT_PROT_RWX (PROT_READ | PROT_WRITE | PROT_EXEC)
#define KT_PROT_RX (PROT_READ | PROT_EXEC)
#define KT_PROT_RW (PROT_READ | PROT_WRITE)

#define KITTY_LOG_TAG "KittyMemory"

#ifdef __ANDROID__
#include <android/log.h>

#ifdef kITTYMEMORY_DEBUG
#define KITTY_LOGD(fmt, ...) ((void)__android_log_print(ANDROID_LOG_DEBUG, KITTY_LOG_TAG, fmt, ##__VA_ARGS__))
#else
#define KITTY_LOGD(fmt, ...)                                                                                           \
    do                                                                                                                 \
    {                                                                                                                  \
    } while (0)
#endif

#define KITTY_LOGI(fmt, ...) ((void)__android_log_print(ANDROID_LOG_INFO, KITTY_LOG_TAG, fmt, ##__VA_ARGS__))
#define KITTY_LOGE(fmt, ...) ((void)__android_log_print(ANDROID_LOG_ERROR, KITTY_LOG_TAG, fmt, ##__VA_ARGS__))

#elif __APPLE__
#include <os/log.h>

#ifdef kITTYMEMORY_DEBUG
#define KITTY_LOGD(fmt, ...) os_log(OS_LOG_DEFAULT, "D " KITTY_LOG_TAG ": " fmt, ##__VA_ARGS__)
#else
#define KITTY_LOGD(fmt, ...)                                                                                           \
    do                                                                                                                 \
    {                                                                                                                  \
    } while (0)
#endif

#define KITTY_LOGI(fmt, ...) os_log(OS_LOG_DEFAULT, "I " KITTY_LOG_TAG ": " fmt, ##__VA_ARGS__)
#define KITTY_LOGE(fmt, ...) os_log_error(OS_LOG_DEFAULT, "E " KITTY_LOG_TAG ": " fmt, ##__VA_ARGS__)

#endif

#define KT_EINTR_RETRY(exp)                                                                                            \
    ({                                                                                                                 \
        __typeof__(exp) _rc;                                                                                           \
        do                                                                                                             \
        {                                                                                                              \
            _rc = (exp);                                                                                               \
        } while (_rc == -1 && errno == EINTR);                                                                         \
        _rc;                                                                                                           \
    })

#ifdef __ANDROID__

#include <elf.h>
#ifdef __LP64__
#define KT_ELFCLASS_BITS 64
#define KT_ELF_EICLASS 2
#define KT_ElfW(x) Elf64_##x
#define KT_ELFW(x) ELF64_##x
#else
#define KT_ELFCLASS_BITS 32
#define KT_ELF_EICLASS 1
#define KT_ElfW(x) Elf32_##x
#define KT_ELFW(x) ELF32_##x
#endif
#define KT_ELF_ST_BIND(val) (((unsigned char)(val)) >> 4)
#define KT_ELF_ST_TYPE(val) ((val) & 0xf)
#define KT_ELF_ST_INFO(bind, type) (((bind) << 4) + ((type) & 0xf))
#define KT_ELF_ST_VISIBILITY(o) ((o) & 0x03)

#endif // __ANDROID__

namespace KittyUtils
{

#ifdef __ANDROID__
    std::string getExternalStorage();
    int getAndroidVersion();
    int getAndroidSDK();

    inline uintptr_t untagHeepPtr(uintptr_t p)
    {
#if defined(__aarch64__)
        /*
        static constexpr uintptr_t POINTER_TAG = 0xB4;
        static constexpr unsigned UNTAG_SHIFT = 40;
        static constexpr unsigned CHECK_SHIFT = 48;
        static constexpr unsigned TAG_SHIFT = 56;
        */
        return (p >> 56) == 0xB4 ? (p & ((static_cast<uintptr_t>(1) << 40) - 1)) : p;
#else
        return p;
#endif
    }
#endif

    std::string fileNameFromPath(const std::string &filePath);
    std::string fileDirectory(const std::string &filePath);
    std::string fileExtension(const std::string &filePath);

    namespace String
    {
        static inline bool StartsWith(const std::string &str, const std::string &str2)
        {
            return str.length() >= str2.length() && str.compare(0, str2.length(), str2) == 0;
        }

        static inline bool Contains(const std::string &str, const std::string &str2)
        {
            return str.length() >= str2.length() && str.find(str2) != std::string::npos;
        }

        static inline bool EndsWith(const std::string &str, const std::string &str2)
        {
            return str.length() >= str2.length() && str.compare(str.length() - str2.length(), str2.length(), str2) == 0;
        }

        void Trim(std::string &str);

        bool ValidateHex(std::string &hex);

        std::string Fmt(const char *fmt, ...);

        std::string Random(size_t length);
    } // namespace String

    template <typename T>
    T randInt(T min, T max)
    {
        using param_type = typename std::uniform_int_distribution<T>::param_type;

        static std::mutex mtx;
        std::lock_guard<std::mutex> lock(mtx);

        static std::mt19937 gen{std::random_device{}()};
        static std::uniform_int_distribution<T> dist;

        return dist(gen, param_type{min, max});
    }

    template <typename T>
    std::string data2Hex(const T &data)
    {
        const auto *byteData = reinterpret_cast<const unsigned char *>(&data);
        std::stringstream hexStringStream;

        hexStringStream << std::hex << std::setfill('0');
        for (size_t index = 0; index < sizeof(T); ++index)
            hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);

        return hexStringStream.str();
    }

    std::string data2Hex(const void *data, const size_t dataLength);
    void dataFromHex(const std::string &in, void *data);

    template <size_t rowSize = 8, bool showASCII = true>
    std::string HexDump(const void *address, size_t len)
    {
        if (!address || len == 0 || rowSize == 0)
            return "";

        const unsigned char *data = static_cast<const unsigned char *>(address);

        std::stringstream ss;
        ss << std::hex << std::uppercase << std::setfill('0');

        size_t i, j;

        for (i = 0; i < len; i += rowSize)
        {
            // offset
            ss << std::setw(8) << i << ": ";

            // row bytes
            for (j = 0; (j < rowSize) && ((i + j) < len); j++)
                ss << std::setw(2) << static_cast<unsigned int>(data[i + j]) << " ";

            // fill row empty space
            for (; j < rowSize; j++)
                ss << "   ";

            // ASCII
            if (showASCII)
            {
                ss << " ";

                for (j = 0; (j < rowSize) && ((i + j) < len); j++)
                {
                    if (std::isprint(data[i + j]))
                        ss << data[i + j];
                    else
                        ss << '.';
                }
            }

            ss << std::endl;
        }

        return ss.str();
    }

#ifdef __ANDROID__

    namespace Elf
    {
        namespace ElfHash
        {
            /**
             * Lookup symbol by name in hash table
             *
             * @elfhash: DT_HASH hash table address
             * @symtab: DT_SYMTAB symbol table address
             * @strtab: DT_STRTAB string table address
             * @syment: DT_SYMENT symbol table entry size address
             * @syment: DT_STRSZ string table size
             *
             * @return ElfSym pointer
             */
            const KT_ElfW(Sym) * LookupByName(uintptr_t elfhash, uintptr_t symtab, uintptr_t strtab, size_t syment,
                                              size_t strsz, const char *symbol_name);
        } // namespace ElfHash

        namespace GnuHash
        {
            /**
             * Lookup symbol by name in gnu hash table
             *
             * @elfhash: DT_GNU_HASH gnu hash table address
             * @symtab: DT_SYMTAB symbol table address
             * @strtab: DT_STRTAB string table address
             * @syment: DT_SYMENT symbol table entry size address
             * @syment: DT_STRSZ string table size
             *
             * @return ElfSym pointer
             */
            const KT_ElfW(Sym) * LookupByName(uintptr_t gnuhash, uintptr_t symtab, uintptr_t strtab, size_t syment,
                                              size_t strsz, const char *symbol_name);
        } // namespace GnuHash
    } // namespace Elf

    namespace Zip
    {
        struct ZipEntryInfo
        {
            std::string fileName;
            uint64_t compressedSize = 0;
            uint64_t uncompressedSize = 0;
            uint16_t compressionMethod = 0;
            uint32_t crc32 = 0;
            uint16_t modTime = 0;
            uint16_t modDate = 0;
            uint64_t dataOffset = 0;
        };

        struct ZipEntryMMap
        {
            void *mappingBase = nullptr;
            size_t mappingSize = 0;
            uint8_t *data = nullptr;
            uint64_t size = 0;
        };

        bool findCentralDirectory(const uint8_t *data, uint64_t fileSize, uint64_t *cdOffset, uint64_t *totalEntries);

        std::vector<ZipEntryInfo> listEntriesInZip(const std::string &zipPath);

        bool GetEntryInfoByDataOffset(const std::string &zipPath, uint64_t dataOffset, ZipEntryInfo *out);
        bool MMapEntryByDataOffset(const std::string &zipPath, uint64_t dataOffset, ZipEntryMMap *out);
    } // namespace Zip

#endif // __ANDROID__
} // namespace KittyUtils

```

`KittyMemory/MemoryBackup.cpp`:

```cpp
//
//  MemoryBackup.cpp
//
//  Created by MJ (Ruit) on 4/19/20.
//

#include "MemoryBackup.hpp"
#include "KittyUtils.hpp"


MemoryBackup::MemoryBackup()
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
}

MemoryBackup::~MemoryBackup()
{
  // clean up
  _orig_code.clear();
  _orig_code.shrink_to_fit();
}


MemoryBackup MemoryBackup::createBackup(uintptr_t absolute_address, size_t backup_size)
{
  MemoryBackup backup;

  if (!absolute_address || !backup_size) return backup;

  backup._address = absolute_address;

  backup._size = backup_size;

  backup._orig_code.resize(backup_size);

  // backup current content
  KittyMemory::memRead(reinterpret_cast<const void *>(backup._address), &backup._orig_code[0], backup_size);

  return backup;
}

#ifdef __ANDROID__
MemoryBackup MemoryBackup::createBackup(const KittyMemory::ProcMap &map, uintptr_t address, size_t backup_size)
{
  if (!map.isValid() || !address || !backup_size)
    return MemoryBackup();

  return createBackup(map.startAddress + address, backup_size);
}

#elif __APPLE__
MemoryBackup MemoryBackup::createBackup(const char *fileName, uintptr_t address, size_t backup_size)
{
  if (!address || !backup_size)
    return MemoryBackup();

  return createBackup(KittyMemory::getAbsoluteAddress(fileName, address), backup_size);
}
#endif

bool MemoryBackup::isValid() const
{
  return (_address != 0 && _size > 0 && _orig_code.size() == _size);
}

size_t MemoryBackup::get_BackupSize() const
{
  return _size;
}

uintptr_t MemoryBackup::get_TargetAddress() const
{
  return _address;
}

bool MemoryBackup::Restore()
{
  if (!isValid()) return false;

#ifdef __ANDROID__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size);
#elif __APPLE__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) == KittyMemory::KMS_SUCCESS;
#endif
}

std::string MemoryBackup::get_CurrBytes() const
{
  if (!isValid()) return "";
  
  return KittyUtils::data2Hex(reinterpret_cast<const void *>(_address), _size);
}

std::string MemoryBackup::get_OrigBytes() const
{
  if (!isValid()) return "";
  
  return KittyUtils::data2Hex(_orig_code.data(), _orig_code.size());
}
```

`KittyMemory/MemoryBackup.hpp`:

```hpp
//
//  MemoryBackup.h
//
//  Created by MJ (Ruit) on 4/19/20.
//

#pragma once

#include <string>
#include <vector>
#include <cstdint>

#include "KittyMemory.hpp"


class MemoryBackup
{
private:
    uintptr_t _address;
    size_t _size;

    std::vector<uint8_t> _orig_code;

public:
    MemoryBackup();
    ~MemoryBackup();

    static MemoryBackup createBackup(uintptr_t absolute_address, size_t backup_size);

#ifdef __ANDROID__
    static MemoryBackup createBackup(const KittyMemory::ProcMap &map, uintptr_t address, size_t backup_size);
#elif __APPLE__
    static MemoryBackup createBackup(const char *fileName, uintptr_t address, size_t backup_size);
#endif

    bool isValid() const;
    size_t get_BackupSize() const;
    uintptr_t get_TargetAddress() const;

    /*
     * Restores backup code
     */
    bool Restore();

    /*
     * Returns hex string of the current target address bytes
     */
    std::string get_CurrBytes() const;

    /*
     * Returns hex string of the original bytes
     */
    std::string get_OrigBytes() const;
};

```

`KittyMemory/MemoryPatch.cpp`:

```cpp
//
//  MemoryPatch.cpp
//
//  Created by MJ (Ruit) on 1/1/19.
//

#include "MemoryPatch.hpp"
#include "KittyUtils.hpp"

#ifndef kNO_KEYSTONE
#include "Deps/Keystone/includes/keystone.h"
#endif

MemoryPatch::MemoryPatch()
{
  _address = 0;
  _size = 0;
  _orig_code.clear();
  _patch_code.clear();
}

MemoryPatch::~MemoryPatch()
{
  // clean up
  _orig_code.clear();
  _orig_code.shrink_to_fit();

  _patch_code.clear();
  _patch_code.shrink_to_fit();
}

MemoryPatch MemoryPatch::createWithBytes(uintptr_t absolute_address, const void *patch_code, size_t patch_size)
{
  MemoryPatch patch;

  if (!absolute_address || !patch_code || patch_size < 1)
    return patch;

  patch._address = absolute_address;
  patch._size = patch_size;

  patch._orig_code.resize(patch_size);
  patch._patch_code.resize(patch_size);

  // initialize patch & backup current content
  KittyMemory::memRead(patch_code, &patch._patch_code[0], patch_size);
  KittyMemory::memRead(reinterpret_cast<const void *>(patch._address), &patch._orig_code[0], patch_size);
  return patch;
}

MemoryPatch MemoryPatch::createWithHex(uintptr_t absolute_address, std::string hex)
{
  MemoryPatch patch;

  if (!absolute_address || !KittyUtils::String::ValidateHex(hex))
    return patch;

  patch._address = absolute_address;
  patch._size = hex.length() / 2;

  patch._orig_code.resize(patch._size);
  patch._patch_code.resize(patch._size);

  // initialize patch
  KittyUtils::dataFromHex(hex, &patch._patch_code[0]);

  // backup current content
  KittyMemory::memRead(reinterpret_cast<const void *>(patch._address), &patch._orig_code[0], patch._size);
  return patch;
}

#ifndef kNO_KEYSTONE
MemoryPatch MemoryPatch::createWithAsm(uintptr_t absolute_address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address)
{
  MemoryPatch patch;

  if (!absolute_address || asm_code.empty())
      return patch;

  ks_engine *ks = nullptr;
  ks_err err = KS_ERR_ARCH;

  switch (asm_arch) {
    case MP_ASM_ARM32:
      err = ks_open(KS_ARCH_ARM, KS_MODE_LITTLE_ENDIAN, &ks);
      break;
    case MP_ASM_ARM64:
      err = ks_open(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN, &ks);
      break;
    case MP_ASM_x86:
      err = ks_open(KS_ARCH_X86, KS_MODE_32, &ks);
      break;
    case MP_ASM_x86_64:
      err = ks_open(KS_ARCH_X86, KS_MODE_64, &ks);
      break;
    default:
      KITTY_LOGE("Unknown MP_ASM_ARCH '%d'.", asm_arch);
      return patch;
  }

  if (err != KS_ERR_OK) {
    KITTY_LOGE("ks_open failed with error = '%s'.", ks_strerror(err));
    return patch;
  }

  unsigned char *insn_bytes = nullptr;
  size_t insn_count = 0, insn_size = 0;
  int rt = ks_asm(ks, asm_code.c_str(), asm_address, &insn_bytes, &insn_size, &insn_count);

  if (rt == 0 && insn_bytes != nullptr && insn_size) {
    patch = createWithBytes(absolute_address, insn_bytes, insn_size);
  }

  if (insn_bytes != nullptr) {
    ks_free(insn_bytes);
  }

  ks_close(ks);

  if (rt) {
    KITTY_LOGE("ks_asm failed (asm: %s, count = %zu, error = '%s') (code = %u).", asm_code.c_str(), insn_count, ks_strerror(ks_errno(ks)), ks_errno(ks));
  }

  return patch;
}
#endif // kNO_KEYSTONE

#ifdef __ANDROID__

MemoryPatch MemoryPatch::createWithBytes(const KittyMemory::ProcMap &map, uintptr_t address, const void *patch_code, size_t patch_size)
{
  if (!address || !map.startAddress || !map.isValid())
    return MemoryPatch();

  return createWithBytes(map.startAddress+address, patch_code, patch_size);
}

MemoryPatch MemoryPatch::createWithHex(const KittyMemory::ProcMap &map, uintptr_t address, const std::string &hex)
{
  if (!address || !map.startAddress || !map.isValid())
    return MemoryPatch();

  return createWithHex(map.startAddress+address, hex);
}

#elif __APPLE__

MemoryPatch MemoryPatch::createWithBytes(const char *fileName, uintptr_t address, const void *patch_code, size_t patch_size)
{
  if (!address || !patch_code || !patch_size)
    return MemoryPatch();

  uintptr_t absolute_address = KittyMemory::getAbsoluteAddress(fileName, address);
  return createWithBytes(absolute_address, patch_code, patch_size);
}

MemoryPatch MemoryPatch::createWithHex(const char *fileName, uintptr_t address, const std::string &hex)
{
  if (!address || hex.empty())
    return MemoryPatch();

  uintptr_t absolute_address = KittyMemory::getAbsoluteAddress(fileName, address);
  return createWithHex(absolute_address, hex);
}

#endif

#ifndef kNO_KEYSTONE

#ifdef __ANDROID__
MemoryPatch MemoryPatch::createWithAsm(const KittyMemory::ProcMap &map, uintptr_t address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address)
{
  if (!address || !map.startAddress || !map.isValid())
    return MemoryPatch();

  return createWithAsm(map.startAddress+address, asm_arch, asm_code, asm_address);
}

#elif __APPLE__
MemoryPatch MemoryPatch::createWithAsm(const char *fileName, uintptr_t address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address)
{
  if (!address || asm_code.empty())
    return MemoryPatch();

  uintptr_t absolute_address = KittyMemory::getAbsoluteAddress(fileName, address);
  return createWithAsm(absolute_address, asm_arch, asm_code, asm_address);
}
#endif

#endif // kNO_KEYSTONE

bool MemoryPatch::isValid() const
{
  return (_address != 0 && _size > 0 && _orig_code.size() == _size && _patch_code.size() == _size);
}

size_t MemoryPatch::get_PatchSize() const
{
  return _size;
}

uintptr_t MemoryPatch::get_TargetAddress() const
{
  return _address;
}

bool MemoryPatch::Restore()
{
  if (!isValid()) return false;

#ifdef __ANDROID__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size);
#elif __APPLE__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_orig_code[0], _size) == KittyMemory::KMS_SUCCESS;
#endif
}

bool MemoryPatch::Modify()
{
  if (!isValid()) return false;

#ifdef __ANDROID__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_patch_code[0], _size);
#elif __APPLE__
  return KittyMemory::memWrite(reinterpret_cast<void *>(_address), &_patch_code[0], _size) == KittyMemory::KMS_SUCCESS;
#endif
}

std::string MemoryPatch::get_CurrBytes() const
{
  if (!isValid()) return "";
  
  return KittyUtils::data2Hex(reinterpret_cast<const void *>(_address), _size);
}

std::string MemoryPatch::get_OrigBytes() const
{
  if (!isValid()) return "";
  
  return KittyUtils::data2Hex( _orig_code.data(), _orig_code.size());
}

std::string MemoryPatch::get_PatchBytes() const
{
  if (!isValid()) return "";
  
  return KittyUtils::data2Hex(_patch_code.data(), _patch_code.size());
}
```

`KittyMemory/MemoryPatch.hpp`:

```hpp
//
//  MemoryPatch.h
//
//  Created by MJ (Ruit) on 1/1/19.
//

#pragma once

#include <string>
#include <vector>
#include <cstdint>

#include "KittyMemory.hpp"

enum MP_ASM_ARCH {
    MP_ASM_ARM32 = 0,
    MP_ASM_ARM64,
    MP_ASM_x86,
    MP_ASM_x86_64,
};

class MemoryPatch
{
private:
    uintptr_t _address;
    size_t _size;

    std::vector<uint8_t> _orig_code;
    std::vector<uint8_t> _patch_code;

public:
    MemoryPatch();
    ~MemoryPatch();

    static MemoryPatch createWithBytes(uintptr_t absolute_address, const void *patch_code, size_t patch_size);
    static MemoryPatch createWithHex(uintptr_t absolute_address, std::string hex);

#ifndef kNO_KEYSTONE
    /**
     * Keystone assembler
     */
    static MemoryPatch createWithAsm(uintptr_t absolute_address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address=0);
#endif

#ifdef __ANDROID__

    static MemoryPatch createWithBytes(const KittyMemory::ProcMap &map, uintptr_t address, const void *patch_code, size_t patch_size);
    static MemoryPatch createWithHex(const KittyMemory::ProcMap &map, uintptr_t address, const std::string &hex);
    
#ifndef kNO_KEYSTONE
    /**
     * Keystone assembler
     */
     static MemoryPatch createWithAsm(const KittyMemory::ProcMap &map, uintptr_t address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address=0);
#endif

#elif __APPLE__

    static MemoryPatch createWithBytes(const char *fileName, uintptr_t address, const void *patch_code, size_t patch_size);
    static MemoryPatch createWithHex(const char *fileName, uintptr_t address, const std::string &hex);
    
#ifndef kNO_KEYSTONE
    /**
     * Keystone assembler
     */
     static MemoryPatch createWithAsm(const char *fileName, uintptr_t address, MP_ASM_ARCH asm_arch, const std::string &asm_code, uintptr_t asm_address=0);
#endif

#endif


    bool isValid() const;
    size_t get_PatchSize() const;
    uintptr_t get_TargetAddress() const;

    /*
     * Restores the patch to the original value
     */
    bool Restore();

    /*
     * Applies patch modifications to the target address
     */
    bool Modify();

    /*
     * Returns hex string of the current target address bytes
     */
    std::string get_CurrBytes() const;

    /*
     * Returns hex string of the original bytes
     */
    std::string get_OrigBytes() const;
    
    /*
     * Returns hex string of the patch bytes
     */
    std::string get_PatchBytes() const;
};

```

`KittyMemory/writeData.hpp`:

```hpp
/*
   This is an alternative for the old writeData that was made by HackJack & Razzile
*/

#pragma once

#ifdef __APPLE__

#include <cmath>
#include <cstdint>

#include "MemoryPatch.hpp"
#include <libkern/_OSByteOrder.h>

/*
 * expects file name and relative offset, you can pass NULL as filename for base executable
 */
static inline bool writeData8(const char *fileName, uintptr_t offset, uint8_t data)
{
   return MemoryPatch::createWithBytes(fileName, offset, &data, 1).Modify();
}

static inline bool writeData8(uintptr_t address, uint8_t data)
{
   return MemoryPatch::createWithBytes(address, &data, 1).Modify();
}

/*
 * expects file name and relative offset, you can pass NULL as filename for base executable
 */
static inline bool writeData16(const char *fileName, uintptr_t offset, uint16_t data)
{
   uint16_t tmp_data = _OSSwapInt16(data);
   return MemoryPatch::createWithBytes(fileName, offset, &tmp_data, 2).Modify();
}

static inline bool writeData16(uintptr_t address, uint16_t data)
{
   uint16_t tmp_data = _OSSwapInt16(data);
   return MemoryPatch::createWithBytes(address, &tmp_data, 2).Modify();
}

/*
 * expects file name and relative offset, you can pass NULL as filename for base executable
 */
static inline bool writeData32(const char *fileName, uintptr_t offset, uint32_t data)
{
   uint32_t tmp_data = _OSSwapInt32(data);
   return MemoryPatch::createWithBytes(fileName, offset, &tmp_data, 4).Modify();
}

static inline bool writeData32(uintptr_t address, uint32_t data)
{
   uint32_t tmp_data = _OSSwapInt32(data);
   return MemoryPatch::createWithBytes(address, &tmp_data, 4).Modify();
}

/*
 * expects file name and relative offset, you can pass NULL as filename for base executable
 */
static inline bool writeData64(const char *fileName, uintptr_t offset, uint64_t data)
{
   uint64_t tmp_data = _OSSwapInt64(data);
   return MemoryPatch::createWithBytes(fileName, offset, &tmp_data, 8).Modify();
}

static inline bool writeData64(uintptr_t address, uint64_t data)
{
   uint64_t tmp_data = _OSSwapInt64(data);
   return MemoryPatch::createWithBytes(address, &tmp_data, 8).Modify();
}

#endif
```

`LICENSE`:

```
MIT License

Copyright (c) 2019 MJ

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# KittyMemory

Dedicated library for runtime code patching & some memory utilities for both Android and iOS.

KittyMemory now depends on [Keystone Assembler](https://github.com/keystone-engine/keystone) for MemoryPatch::createWithAsm.

Prebuilt Keystone binaries are already included [Here](KittyMemory/Deps/Keystone/), However if you want to build them yourself you can use the scripts [build-android.sh](Deps/keystone-build-android.sh) & [build-ios.sh](Deps/keystone-build-ios.sh).

If for any reason you don't want to use Keystone and MemoryPatch::createWithAsm then add definition kNO_KEYSTONE to your project cpp flags.

Check [Android example](example-android/README.md) & [iOS example](example-ios/README.md) for how to use & build.
```

`example-android/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

KITTYMEMORY_PATH = $(LOCAL_PATH)/../KittyMemory
KITTYMEMORY_SRC = $(subst $(LOCAL_PATH),.,$(wildcard $(KITTYMEMORY_PATH)/*.cpp))

# Disable keystone support
KT_DISABLE_KEYSTONE ?= false

## Keystone static lib link
ifeq ($(KT_DISABLE_KEYSTONE),false)
include $(CLEAR_VARS)
LOCAL_MODULE    := Keystone
LOCAL_SRC_FILES := $(KITTYMEMORY_PATH)/Deps/Keystone/libs-android/$(TARGET_ARCH_ABI)/libkeystone.a
include $(PREBUILT_STATIC_LIBRARY)
endif

## Example lib
include $(CLEAR_VARS)

LOCAL_MODULE := KittyMemoryExample

# add -DkITTYMEMORY_DEBUG for debug outputs
LOCAL_CPPFLAGS += -std=c++17 -fno-rtti -DkITTYMEMORY_DEBUG

LOCAL_SRC_FILES := example.cpp $(KITTYMEMORY_SRC)

## add keystone
ifeq ($(KT_DISABLE_KEYSTONE),false)
LOCAL_STATIC_LIBRARIES := Keystone
endif

include $(BUILD_SHARED_LIBRARY)
```

`example-android/Application.mk`:

```mk
APP_ABI := armeabi-v7a arm64-v8a x86 x86_64
APP_PLATFORM := android-21
APP_STL      := c++_static
APP_OPTIM    := release
APP_PIE      := true

ifeq ($(APP_OPTIM),release)
  APP_CFLAGS     := -O2 -DNDEBUG #-Wall -Wextra
  APP_STRIP_MODE := --strip-all
else
  APP_CFLAGS     := -O0 -g
  APP_STRIP_MODE := none
endif

APP_LDFLAGS := -llog

APP_BUILD_SCRIPT := Android.mk
```

`example-android/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

project(ExampleProject
    VERSION 1.0
    LANGUAGES CXX
)

# -----------------------------
# Options
# -----------------------------
option(KT_DISABLE_KEYSTONE "Disable keystone support" OFF)

# -----------------------------
# C++ standard
# -----------------------------
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# -----------------------------
# KittyMemory library
# -----------------------------
set(KITTYMEMORY_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../KittyMemory")
file(GLOB KITTYMEMORY_SRC "${KITTYMEMORY_PATH}/*.cpp")
set(KEYSTONE_LIB ${KITTYMEMORY_PATH}/Deps/Keystone/libs-android/${CMAKE_ANDROID_ARCH_ABI}/libkeystone.a)

# -----------------------------
# Project sources
# -----------------------------
file(GLOB PROJ_SRC
    "example.cpp"
)

# -----------------------------
# Shared Library
# -----------------------------
add_library(ExampleProject SHARED ${PROJ_SRC} ${KITTYMEMORY_SRC})


# -----------------------------
# Includes
# -----------------------------
target_include_directories(ExampleProject
    PRIVATE
        ${KITTYMEMORY_PATH}
)

# -----------------------------
# Compile definitions
# -----------------------------
target_compile_definitions(ExampleProject
    PRIVATE
        $<$<CONFIG:Debug>:DEBUG>
        $<$<CONFIG:Release>:NDEBUG>
        $<$<BOOL:${KT_DISABLE_KEYSTONE}>:kNO_KEYSTONE>
)

# -----------------------------
# Compile options
# -----------------------------
target_compile_options(ExampleProject
    PRIVATE
        $<$<CONFIG:Debug>:-O0 -g>
        $<$<CONFIG:Release>:-O2>
        -Wall
        -Wextra
        -Werror
        -fexceptions
        -Wno-unused-command-line-argument
)

# -----------------------------
# Platform-specific libraries
# -----------------------------
if(ANDROID)
    target_link_libraries(ExampleProject PRIVATE log $<$<NOT:$<BOOL:${KT_DISABLE_KEYSTONE}>>:${KEYSTONE_LIB}>)
endif()
```

`example-android/README.md`:

```md
# KittyMemory Android Example

<h3>This is an example android shared lib.</h3>

Requires C++11 or above.</br>
Android API 21 or above for keystone linking.

See how to use KittyMemory in [example.cpp](example.cpp).

<h3>Clone:</h3>

```
git clone --recursive https://github.com/MJx0/KittyMemory.git
```

<h3>How to build:</h3>

<h4>NDK Build:</h4>

- In your Android.mk somewhere at top, define:

```make
## it's better to use relative path to $(LOCAL_PATH) and then use subst
KITTYMEMORY_PATH = path/to/KittyMemory
KITTYMEMORY_SRC = $(wildcard $(KITTYMEMORY_PATH)/*.cpp)
```

- Inlcude Keystone static lib:

```make
include $(CLEAR_VARS)
LOCAL_MODULE    := Keystone
LOCAL_SRC_FILES := $(KITTYMEMORY_PATH)/Deps/Keystone/libs-android/$(TARGET_ARCH_ABI)/libkeystone.a
include $(PREBUILT_STATIC_LIBRARY)
```

- Add KittyMemory source files:

```make
LOCAL_SRC_FILES := example.cpp $(KITTYMEMORY_SRC)
```

- Finally add keystone static lib:

```make
LOCAL_STATIC_LIBRARIES := Keystone
```

You can check example here [Android.mk](Android.mk).

<h4>CMake Build:</h4>

- In your CMakeLists.txt somewhere at top, define:

```cmake
set(KITTYMEMORY_PATH path/to/KittyMemory)
file(GLOB KITTYMEMORY_SRC ${KITTYMEMORY_PATH}/*.cpp)
```

- Inlcude Keystone static lib:

```cmake
set(KEYSTONE_LIB ${KITTYMEMORY_PATH}/Deps/Keystone/libs-android/${CMAKE_ANDROID_ARCH_ABI}/libkeystone.a)
```

- Add KittyMemory source files:

```cmake
add_library(YourProjectName SHARED example.cpp ${KITTYMEMORY_SRC})
```

- Finally add keystone static lib:

```cmake
target_link_libraries(YourProjectName ${KEYSTONE_LIB})
## or
link_libraries(${KEYSTONE_LIB})
```

You can check example here [CMakeLists.txt](CMakeLists.txt).

NOTE:
If you don't want to link keystone and use MemoryPatch::createWithAsm then add definition kNO_KEYSTONE to your cpp flags.

```

`example-android/build.bat`:

```bat
@ECHO OFF
SETLOCAL ENABLEDELAYEDEXPANSION

:: ===============================
:: Config
:: ===============================
SET "NDK=%NDK_HOME%"
SET "BUILD_TYPE=Release"
SET "ANDROID_API=21"
SET "ABIs=arm64-v8a armeabi-v7a x86 x86_64"

SET "CMAKE=cmake"
SET "GENERATOR=Ninja"

SET "CMAKE_BUILD_DIR=cmake_build"
SET "NDK_BUILD_DIR=ndk_build"

:: ===============================
:: Detect cores
:: ===============================
SET "JOBS=4"
IF DEFINED NUMBER_OF_PROCESSORS (
    SET /A JOBS=%NUMBER_OF_PROCESSORS% / 2
)

:: ===============================
:: Validate NDK
:: ===============================
IF "%NDK%"=="" (
    ECHO ERROR: env variable NDK_HOME not set.
    PAUSE
    EXIT /B 1
)

:: ===============================
:: Menu
:: ===============================
ECHO.
ECHO Select build system:
ECHO   [1] CMake
ECHO   [2] ndk-build
ECHO.

SET /P CHOICE=Enter choice (1 or 2):

IF "%CHOICE%"=="1" GOTO BUILD_CMAKE
IF "%CHOICE%"=="2" GOTO BUILD_NDK

ECHO Invalid choice.
PAUSE
EXIT /B 1

:: ===============================
:: CMake build
:: ===============================
:BUILD_CMAKE
FOR %%A IN (%ABIs%) DO (
    ECHO ==================================
    ECHO CMake build - ABI "%%A"
    ECHO ==================================

    %CMAKE% -S . -B "%CMAKE_BUILD_DIR%\%%A" ^
        -G "%GENERATOR%" ^
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ^
        -DCMAKE_BUILD_TYPE=%BUILD_TYPE% ^
        -DCMAKE_TOOLCHAIN_FILE=%NDK%\build\cmake\android.toolchain.cmake ^
        -DANDROID_NDK="%NDK%" ^
        -DANDROID_ABI=%%A ^
        -DANDROID_PLATFORM=android-%ANDROID_API% ^
        -DANDROID_STL=c++_static

    %CMAKE% --build "%CMAKE_BUILD_DIR%\%%A" -- -j%JOBS%
)
PAUSE
GOTO :EOF

:: ===============================
:: ndk-build
:: ===============================
:BUILD_NDK
CALL "%NDK%\ndk-build.cmd" -j%JOBS% ^
    NDK_PROJECT_PATH=. ^
    APP_BUILD_SCRIPT=Android.mk ^
    NDK_APPLICATION_MK=Application.mk ^
    NDK_OUT="%NDK_BUILD_DIR%\obj" ^
    NDK_LIBS_OUT="%NDK_BUILD_DIR%\libs"
PAUSE
GOTO :EOF
```

`example-android/build.sh`:

```sh
#!/usr/bin/env bash
set -e

# ===============================
# Config
# ===============================
NDK_PATH="${NDK_HOME}"
BUILD_TYPE=Release
ANDROID_API=21
ABIs=("arm64-v8a" "armeabi-v7a" "x86" "x86_64")

CMAKE=cmake
GENERATOR="Ninja"

CMAKE_BUILD_DIR=cmake_build
NDK_BUILD_DIR=ndk_build

# ===============================
# Detect cores
# ===============================
JOBS=$(($(nproc 2>/dev/null || sysctl -n hw.ncpu || echo 4) / 2))

# ===============================
# Validate
# ===============================
if [[ -z "NDK_PATH" ]]; then
  echo "ERROR: env variable NDK_HOME not set."
  exit 1
fi

# ===============================
# Menu
# ===============================
echo
echo "Select build system:"
echo "  [1] CMake"
echo "  [2] ndk-build"
echo

read -p "Enter choice (1 or 2): " CHOICE

case "$CHOICE" in
  1) BUILD_SYSTEM=cmake ;;
  2) BUILD_SYSTEM=ndk ;;
  *)
    echo "Invalid choice."
    exit 1
    ;;
esac

# ===============================
# CMake build
# ===============================
if [[ "$BUILD_SYSTEM" == "cmake" ]]; then
  for ABI in "${ABIs[@]}"; do
    echo "=================================="
    echo "CMake build - ABI $ABI (j$JOBS)"
    echo "=================================="

    $CMAKE -S . -B "${CMAKE_BUILD_DIR}/${ABI}" \
      -G "${GENERATOR}" \
      -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
      -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
      -DCMAKE_TOOLCHAIN_FILE="${NDK_PATH}/build/cmake/android.toolchain.cmake" \
      -DANDROID_ABI=$ABI \
      -DANDROID_PLATFORM=android-${ANDROID_API} \
      -DANDROID_STL=c++_static

    $CMAKE --build "${CMAKE_BUILD_DIR}/${ABI}" -- -j${JOBS}
  done
fi

# ===============================
# ndk-build
# ===============================
if [[ "$BUILD_SYSTEM" == "ndk" ]]; then
  "$NDK_PATH/ndk-build" -j${JOBS} \
    NDK_PROJECT_PATH=. \
    APP_BUILD_SCRIPT=Android.mk \
    NDK_APPLICATION_MK=Application.mk \
    NDK_OUT="${NDK_BUILD_DIR}/obj" \
    NDK_LIBS_OUT="${NDK_BUILD_DIR}/libs"
fi

```

`example-android/clean.bat`:

```bat
@ECHO OFF
SETLOCAL

SET CMAKE_BUILD_DIR=cmake_build
SET NDK_BUILD_DIR=ndk_build

ECHO ===============================
ECHO Cleaning build artifacts
ECHO ===============================

IF EXIST "%CMAKE_BUILD_DIR%" (
    ECHO Removing %CMAKE_BUILD_DIR% ...
    rmdir /S /Q "%CMAKE_BUILD_DIR%"
)

IF EXIST "%NDK_BUILD_DIR%" (
    ECHO Removing %NDK_BUILD_DIR% ...
    rmdir /S /Q "%NDK_BUILD_DIR%"
)

IF EXIST "compile_commands.json" (
    ECHO Removing compile_commands.json ...
    del /F /Q "compile_commands.json"
)

ECHO Done.
ENDLOCAL

PAUSE

```

`example-android/clean.sh`:

```sh
#!/usr/bin/env bash
set -e

CMAKE_BUILD_DIR="cmake_build"
NDK_BUILD_DIR="ndk_build"

echo "==============================="
echo "Cleaning build artifacts"
echo "==============================="

if [[ -d "$CMAKE_BUILD_DIR" ]]; then
  echo "Removing $CMAKE_BUILD_DIR ..."
  rm -rf "$CMAKE_BUILD_DIR"
fi

if [[ -d "$NDK_BUILD_DIR" ]]; then
  echo "Removing $NDK_BUILD_DIR ..."
  rm -rf "$NDK_BUILD_DIR"
fi

if [[ -f "compile_commands.json" ]]; then
  echo "Removing compile_commands.json ..."
  rm -f "compile_commands.json"
fi

echo "Done."

```

`example-android/example.cpp`:

```cpp
#include <cstdint>
#include <string>
#include <thread>
#include <utility>
#include <vector>

#include <link.h>

#include "../KittyMemory/KittyInclude.hpp"

// fancy struct for patches
struct MemPatches
{
    // let's assume we have patches for these functions for whatever game
    // boolean get_canShoot() function
    MemoryPatch get_canShoot;
    // int get_gold() function
    MemoryPatch get_gold;
    // etc...
} gPatches;

ElfScanner g_il2cppElf;

void test_thread()
{
    sleep(3);

    std::string processName = KittyMemory::getProcessName();
    KITTY_LOGI("Hello World: %s", processName.c_str());

    KITTY_LOGI("==================== GET ELF INFO ===================");

    // loop until our target library is found
    do
    {
        sleep(1);
        // findElf can find libs in split apk too
        g_il2cppElf = ElfScanner::findElf("libil2cpp.so");
        // use filter
        // g_il2cppElf = ElfScanner::findElf("libil2cpp.so", EScanElfType::Any, EScanElfFilter::App);

        // find via linker or native bridge solist
        auto nativeSo = LinkerScanner::Get().findSoInfo("libil2cpp.so");
        auto emulatedSo = NativeBridgeScanner::Get().findSoInfo("libil2cpp.so");

        if (nativeSo.ptr)
        {
            KITTY_LOGI("Found native libil2cpp.so soinfo at %p", (void *)nativeSo.ptr);
            g_il2cppElf = ElfScanner::createWithSoInfo(nativeSo);
        }
        if (emulatedSo.ptr)
        {
            KITTY_LOGI("Found emulated libil2cpp.so soinfo at %p", (void *)emulatedSo.ptr);
            g_il2cppElf = ElfScanner::createWithSoInfo(emulatedSo);
        }

        // incase il2cpp is renamed, you can find elf by any special symbol
        for (auto &it : ElfScanner::findSymbolAll("il2cpp_init", EScanElfType::Any, EScanElfFilter::App))
        {
            // make sure it has dynamic
            if (it.second.dynamic())
            {
                KITTY_LOGI("Found il2cpp_init at %p from %s", (void *)it.first, it.second.realPath().c_str());
                g_il2cppElf = it.second;
                break;
            }
        }
    } while (!g_il2cppElf.isValid());

    KITTY_LOGI("il2cpp filePath: %s", g_il2cppElf.filePath().c_str());
    KITTY_LOGI("il2cpp realPath: %s", g_il2cppElf.realPath().c_str());
    KITTY_LOGI("il2cpp base: %p", (void *)(g_il2cppElf.base()));
    KITTY_LOGI("il2cpp load_bias: %p", (void *)(g_il2cppElf.loadBias()));
    KITTY_LOGI("il2cpp load_size: %p", (void *)(g_il2cppElf.loadSize()));
    KITTY_LOGI("il2cpp end: %p", (void *)(g_il2cppElf.end()));
    KITTY_LOGI("il2cpp phdr: %p", (void *)(g_il2cppElf.phdr()));
    KITTY_LOGI("il2cpp phdrs count: %d", int(g_il2cppElf.programHeaders().size()));
    KITTY_LOGI("il2cpp dynamic: %p", (void *)(g_il2cppElf.dynamic()));
    KITTY_LOGI("il2cpp dynamics count: %d", int(g_il2cppElf.dynamics().size()));
    KITTY_LOGI("il2cpp strtab: %p", (void *)(g_il2cppElf.stringTable()));
    KITTY_LOGI("il2cpp symtab: %p", (void *)(g_il2cppElf.symbolTable()));
    KITTY_LOGI("il2cpp elfhash: %p", (void *)(g_il2cppElf.elfHashTable()));
    KITTY_LOGI("il2cpp gnuhash: %p", (void *)(g_il2cppElf.gnuHashTable()));
    KITTY_LOGI("il2cpp segments count: %d", int(g_il2cppElf.segments().size()));
    KITTY_LOGI("il2cpp inZip: %d", g_il2cppElf.isZipped() ? 1 : 0);
    KITTY_LOGI("il2cpp isNative: %d", g_il2cppElf.isNative() ? 1 : 0);
    KITTY_LOGI("il2cpp isEmulated: %d", g_il2cppElf.isEmulated() ? 1 : 0);

    // wait more to make sure lib is fully loaded and ready
    sleep(1);

    KITTY_LOGI("==================== SYMBOL LOOKUP ===================");

    KITTY_LOGI("il2cpp_init = %p", (void *)g_il2cppElf.findSymbol("il2cpp_init"));
    KITTY_LOGI("il2cpp_string_new = %p", (void *)g_il2cppElf.findSymbol("il2cpp_string_new"));

    // symbol lookup by name in all loaded elfs
    // auto v_eglSwapBuffers = ElfScanner::findSymbolAll("eglSwapBuffers");
    // use filters
    auto v_eglSwapBuffers = ElfScanner::findSymbolAll("eglSwapBuffers", EScanElfType::Any, EScanElfFilter::System);
    // scan natives only
    // auto v_eglSwapBuffers = ElfScanner::findSymbolAll("eglSwapBuffers", EScanElfType::Native,
    // EScanElfFilter::System); scan emulated only auto v_eglSwapBuffers = ElfScanner::findSymbolAll("eglSwapBuffers",
    // EScanElfType::Emulated, EScanElfFilter::System);

    for (auto &it : v_eglSwapBuffers)
    {
        // first  = symbol address
        // second = ELF object where symbol was found
        KITTY_LOGI("Found eglSwapBuffers at %p from %s", (void *)it.first, it.second.realPath().c_str());
    }

    KITTY_LOGI("=============== FIND NATIVE REGISTERS ===============");

    // get loaded unity ELF
    auto unityELF = ElfScanner::findElf("libunity.so");

    // finding register native functions
    RegisterNativeFn nativeInjectEvent = unityELF.findRegisterNativeFn("nativeInjectEvent",
                                                                       "(Landroid/view/InputEvent;)Z");
    // new nativeInjectEvent has second integer param
    if (!nativeInjectEvent.isValid())
        nativeInjectEvent = unityELF.findRegisterNativeFn("nativeInjectEvent", "(Landroid/view/InputEvent;I)Z");

    if (nativeInjectEvent.isValid())
        KITTY_LOGI("nativeInjectEvent = { %s, %s, %p }", nativeInjectEvent.name, nativeInjectEvent.signature,
                   nativeInjectEvent.fnPtr);
    else
        KITTY_LOGI("nativeInjectEvent = NULL");

    RegisterNativeFn nativeUnitySendMessage = unityELF.findRegisterNativeFn(
        "nativeUnitySendMessage", "(Ljava/lang/String;Ljava/lang/String;[B)V");
    if (nativeUnitySendMessage.isValid())
        KITTY_LOGI("nativeUnitySendMessage = { %s, %s, %p }", nativeUnitySendMessage.name,
                   nativeUnitySendMessage.signature, nativeUnitySendMessage.fnPtr);
    else
        KITTY_LOGI("nativeUnitySendMessage = NULL");

    KITTY_LOGI("==================== MEMORY PATCH ===================");

    uintptr_t il2cppBase = g_il2cppElf.base();

    // with bytes, must specify bytes count
    gPatches.get_canShoot = MemoryPatch::createWithBytes(il2cppBase + 0x1D8B054, "\x01\x00\xA0\xE3\x1E\xFF\x2F\xE1", 8);

    // hex with or without spaces both are fine
    gPatches.get_canShoot = MemoryPatch::createWithHex(il2cppBase + 0x1D8B054, "01 00 A0 E3 1E FF 2F E1");

#ifndef kNO_KEYSTONE
    // (uses keystone assembler) insert ';' to seperate statements
    // its recommeneded to test your instructions on https://armconverter.com or
    // https://shell-storm.org/online/Online-Assembler-and-Disassembler/ change
    // MP_ASM_ARM64 to your targeted asm arch MP_ASM_ARM32, MP_ASM_ARM64, MP_ASM_x86,
    // MP_ASM_x86_64
    gPatches.get_canShoot = MemoryPatch::createWithAsm(il2cppBase + 0x1D8B054, MP_ASM_ARM64, "mov x0, #1; ret");

    // format asm
    auto asm_fmt = KittyUtils::String::Fmt("mov x0, #%d; ret", 65536);
    gPatches.get_gold = MemoryPatch::createWithAsm(il2cppBase + 0x1D8B054, MP_ASM_ARM64, asm_fmt);
#endif

    KITTY_LOGI("Patch Address: %p", (void *)gPatches.get_canShoot.get_TargetAddress());
    KITTY_LOGI("Patch Size: %zu", gPatches.get_canShoot.get_PatchSize());
    KITTY_LOGI("Current Bytes: %s", gPatches.get_canShoot.get_CurrBytes().c_str());

    // modify & print bytes
    if (gPatches.get_canShoot.Modify())
    {
        KITTY_LOGI("get_canShoot has been modified successfully");
        KITTY_LOGI("Current Bytes: %s", gPatches.get_canShoot.get_CurrBytes().c_str());
    }

    // restore & print bytes
    if (gPatches.get_canShoot.Restore())
    {
        KITTY_LOGI("get_canShoot has been restored successfully");
        KITTY_LOGI("Current Bytes: %s", gPatches.get_canShoot.get_CurrBytes().c_str());
    }

    KITTY_LOGI("==================== PATTERN SCAN ===================");

    // scan within a memory range for bytes with mask x and ?

    uintptr_t found_at = 0;
    std::vector<uintptr_t> found_at_list;

    uintptr_t search_start = g_il2cppElf.baseSegment().startAddress;
    uintptr_t search_end = g_il2cppElf.baseSegment().endAddress;

    // scan with direct bytes & get one result
    found_at = KittyScanner::findBytesFirst(search_start, search_end, "\x33\x44\x55\x66\x00\x77\x88\x00\x99",
                                            "xxxx??x?x");
    KITTY_LOGI("found bytes at: %p", (void *)found_at);
    // scan with direct bytes & get all results
    found_at_list = KittyScanner::findBytesAll(search_start, search_end, "\x33\x44\x55\x66\x00\x77\x88\x00\x99",
                                               "xxxx??x?x");
    KITTY_LOGI("found bytes results: %zu", found_at_list.size());

    // scan with hex & get one result
    found_at = KittyScanner::findHexFirst(search_start, search_end, "33 44 55 66 00 77 88 00 99", "xxxx??x?x");
    KITTY_LOGI("found hex at: %p", (void *)found_at);
    // scan with hex & get all results
    found_at_list = KittyScanner::findHexAll(search_start, search_end, "33 44 55 66 00 77 88 00 99", "xxxx??x?x");
    KITTY_LOGI("found hex results: %zu", found_at_list.size());

    // scan with IDA pattern get one result
    found_at = KittyScanner::findIdaPatternFirst(search_start, search_end, "33 ? 55 66 ? 77 88 ? 99");
    KITTY_LOGI("found IDA pattern at: %p", (void *)found_at);
    // scan with IDA pattern get all results
    found_at_list = KittyScanner::findIdaPatternAll(search_start, search_end, "33 ? 55 66 ? 77 88 ? 99");
    KITTY_LOGI("found IDA pattern results: %zu", found_at_list.size());

    // scan with data type & get one result
    uint32_t data = 0xdeadbeef;
    found_at = KittyScanner::findDataFirst(search_start, search_end, &data, sizeof(data));
    KITTY_LOGI("found data at: %p", (void *)found_at);

    // scan with data type & get all results
    found_at_list = KittyScanner::findDataAll(search_start, search_end, &data, sizeof(data));
    KITTY_LOGI("found data results: %zu", found_at_list.size());

    KITTY_LOGI("====================== HEX DUMP =====================");

    // hex dump by default 8 rows with ASCII
    KITTY_LOGI("\n%s", KittyUtils::HexDump((void *)g_il2cppElf.baseSegment().startAddress, 100).c_str());

    KITTY_LOGI("=====================================================");

    // 16 rows, no ASCII
    KITTY_LOGI("\n%s", KittyUtils::HexDump<16, false>((void *)g_il2cppElf.baseSegment().startAddress, 100).c_str());

    KITTY_LOGI("===================== ELFS SCAN ====================");

    // gret all elfs
    const auto elfs = ElfScanner::getAllELFs();
    // get app related elfs
    // const auto elfs = ElfScanner::getAllELFs(EScanElfType::Any, EScanElfFilter::App);
    // get emulated system elfs on emulator
    // const auto elfs = ElfScanner::getAllELFs(EScanElfType::Emulated, EScanElfFilter::System);

    for (const auto &it : elfs)
    {
        KITTY_LOGI("elfs(%p) -> %s", (void *)it.base(), it.realPath().c_str());
    }

#if defined(__x86_64__) || defined(__i386__)
    KITTY_LOGI("============== NativeBridge Linker ==============");

    void *libcHandle = NativeBridgeLinker::dlopen("path/to/lib", RTLD_NOW);
    if (libcHandle)
    {
        void *fnInit = NativeBridgeLinker::dlsym(libcHandle, "my_init_func");
        KITTY_LOGI("nb] handle(%p) - fnInit(%p)", libcHandle, fnInit);
        if (fnInit)
        {
            // call
            ((void (*)(void *))fnInit)(nullptr);
        }
    }
    else
    {
        const char *err = NativeBridgeLinker::dlerror();
        if (err)
            KITTY_LOGE("dlerror %s", err);
    }

    NativeBridgeLinker::dl_iterate_phdr([](const kitty_soinfo_t *info) -> bool {
        KITTY_LOGI("nb] %p -> %s", (void *)info->base, info->realpath.c_str() ? info->realpath.c_str() : "");
        return false;
    });

    kitty_soinfo_t info{};
    if (NativeBridgeLinker::dladdr((void *)il2cppBase, &info))
    {
        KITTY_LOGI("nb dladdr] %p -> %s", (void *)info.base, info.realpath.c_str());
    }
#endif
}

__attribute__((constructor)) void init()
{
    std::thread(test_thread).detach();
}

/*#include <jni.h>

extern "C" jint JNIEXPORT JNI_OnLoad(JavaVM *vm, void *key)
{
    KITTY_LOGI("========================");
    KITTY_LOGI("JNI_OnLoad(%p, %p)", vm, key);

    // check if called by injector
    if (key != (void *)1337)
        return JNI_VERSION_1_6;

    KITTY_LOGI("JNI_OnLoad called by injector.");

    JNIEnv *env = nullptr;
    if (vm->GetEnv((void **)&env, JNI_VERSION_1_6) == JNI_OK)
    {
        KITTY_LOGI("JavaEnv: %p.", env);
        // ...
    }

    std::thread(test_thread).detach();

    return JNI_VERSION_1_6;
}*/

```

`example-ios/README.md`:

```md
# KittyMemory iOS Example

<h3>This is an example theos tweak.</h3>

Requires C++11 or above.

See how to use KittyMemory in [Tweak.mm](Tweak.mm).

<h3>Clone:</h3>

```
git clone --recursive https://github.com/MJx0/KittyMemory.git
```

<h3>How to build:</h3>

- In your tweak Makefile somewhere at top, define:

```make
KITTYMEMORY_PATH = path/to/KittyMemory
KITTYMEMORY_SRC = $(wildcard $(KITTYMEMORY_PATH)/*.cpp)
```

- Add KittyMemory source files to your tweak files:

```make
$(TWEAK_NAME)_FILES = Tweak.mm $(KITTYMEMORY_SRC)
```

- Finally add keystone static lib to your tweak obj files:

```make
$(TWEAK_NAME)_OBJ_FILES = $(KITTYMEMORY_PATH)/Deps/Keystone/libs-ios/$(THEOS_CURRENT_ARCH)/libkeystone.a
```

If you don't want to link keystone and use MemoryPatch::createWithAsm then add definition kNO_KEYSTONE to your cpp flags:
```make
$(TWEAK_NAME)_CCFLAGS += -DkNO_KEYSTONE
```

You can check example here [Makefile](Makefile).

```

`example-ios/Tweak.mm`:

```mm
#include <thread>
#include <string>
#include <cstdint>
#include <vector>

// include KittyMemory
#include "../KittyMemory/KittyInclude.hpp"

// fancy struct for patches
struct MemPatches
{
    // let's assume we have patches for these functions for whatever game
    // boolean function
    MemoryPatch get_canShoot;
    // int function
    MemoryPatch get_gold;
    // etc...
} gPatches;

MemoryFileInfo g_BaseInfo;

void test_thread()
{
    KITTY_LOGI("====================== LOADED =====================");

    KITTY_LOGI("App Executable: %{public}s", KittyMemory::getBaseInfo().name);

    // loop until our target binary is found
    do
    {
        sleep(1);
        // base executable
        // g_BaseInfo = KittyMemory::getBaseInfo();
        // or framework
        g_BaseInfo = KittyMemory::getMemoryFileInfo("UnityFramework");
    } while (!g_BaseInfo.address);

    KITTY_LOGI("UnityFramework base: %p", (void *)g_BaseInfo.address);

    KITTY_LOGI("=============== FIND SYMBOL ================");
    
    // you may have to prefix function name with underscore
    
    // with existing MemoryFileInfo object
    KITTY_LOGI("il2cpp_string_new: %p", (void *)(KittyScanner::findSymbol(g_BaseInfo, "_il2cpp_string_new")));
    // or
    KITTY_LOGI("il2cpp_string_new: %p", (void *)(KittyScanner::findSymbol("UnityFramework", "_il2cpp_string_new")));

    
    KITTY_LOGI("==================== MEMORY PATCH ===================");
    
    uintptr_t unityBase = g_BaseInfo.address;
    
#ifndef kNO_KEYSTONE
    // with asm (uses keystone assembler) insert ';' to seperate statements
    // its recommeneded to test your instructions on https://armconverter.com or https://shell-storm.org/online/Online-Assembler-and-Disassembler/
    // change MP_ASM_ARM64 to your targeted asm arch
    // MP_ASM_ARM32, MP_ASM_ARM64, MP_ASM_x86, MP_ASM_x86_64
    gPatches.get_canShoot = MemoryPatch::createWithAsm(unityBase + 0x10948D4, MP_ASM_ARM64, "mov x0, #1; ret");
    
    // format asm
    std::string asm_fmt = KittyUtils::String::Fmt("mov x0, #%d; ret", 65536);
    gPatches.get_gold = MemoryPatch::createWithAsm(unityBase + 0xE4EB8, MP_ASM_ARM64, asm_fmt);
#endif
    
    
    // hex with or without spaces both are fine
    gPatches.get_canShoot = MemoryPatch::createWithHex(unityBase + 0x10948D4, "01 00 A0 E3 1E FF 2F E1");
    
    
    // raw bytes
    gPatches.get_canShoot = MemoryPatch::createWithBytes(unityBase + 0x1019C1F20, "\x01\x00\xA0\xE3\x1E\xFF\x2F\xE1", 8);
    
    
    KITTY_LOGI("Patch Address: %p", (void *)gPatches.get_canShoot.get_TargetAddress());
    KITTY_LOGI("Patch Size: %zu", gPatches.get_canShoot.get_PatchSize());
    KITTY_LOGI("Current Bytes: %{public}s", gPatches.get_canShoot.get_CurrBytes().c_str());
    
    // modify & print bytes
    if (gPatches.get_canShoot.Modify())
    {
        KITTY_LOGI("get_canShoot has been modified successfully");
        KITTY_LOGI("Current Bytes: %{public}s", gPatches.get_canShoot.get_CurrBytes().c_str());
    }
    
    // restore & print bytes
    if (gPatches.get_canShoot.Restore())
    {
        KITTY_LOGI("get_canShoot has been restored successfully");
        KITTY_LOGI("Current Bytes: %{public}s", gPatches.get_canShoot.get_CurrBytes().c_str());
    }
    
    // writedata alternative, check KittyMemory/writeData.hpp
    
    // write 64 bit integer ( 8 bytes )
    if (writeData64(unityBase + 0x1019C1F20, 0x200080D2C0035FD6))
        KITTY_LOGI("get_canShoot has been modified successfully");
    
    // or as 32 bit integer ( 4 bytes )
    if (writeData32(unityBase + 0x1019C1F20, 0x200080D2) && writeData32(unityBase + 0x1019C1F20 + 4, 0xC0035FD6))
        KITTY_LOGI("get_canShoot has been modified successfully");

    
    KITTY_LOGI("=============== PATTERN SCAN ===============");
    
    // scan within a memory range for bytes with mask x and ?
    
    // get start & end address of __TEXT segment
    seg_data_t text_seg = g_BaseInfo.getSegment("__TEXT");
    
    // get start & end address of __DATA segment
    seg_data_t data_seg = g_BaseInfo.getSegment("__DATA");
    
    uintptr_t found_at = 0;
    std::vector<uintptr_t> found_at_list;
    
    // scan with direct bytes & get one result
    found_at = KittyScanner::findBytesFirst(text_seg.start, text_seg.end, "\x33\x44\x55\x66\x00\x77\x88\x00\x99", "xxxx??x?x");
    KITTY_LOGI("found bytes at: %p", (void *)found_at);
    // scan with direct bytes & get all results
    found_at_list = KittyScanner::findBytesAll(text_seg.start, text_seg.end, "\x33\x44\x55\x66\x00\x77\x88\x00\x99", "xxxx??x?x");
    KITTY_LOGI("found bytes results: %zu", found_at_list.size());
    
    // scan with hex & get one result
    found_at = KittyScanner::findHexFirst(text_seg.start, text_seg.end, "33 44 55 66 00 77 88 00 99", "xxxx??x?x");
    KITTY_LOGI("found hex at: %p", (void *)found_at);
    // scan with hex & get all results
    found_at_list = KittyScanner::findHexAll(text_seg.start, text_seg.end, "33 44 55 66 00 77 88 00 99", "xxxx??x?x");
    KITTY_LOGI("found hex results: %zu", found_at_list.size());
    
    // scan with IDA pattern get one result
    found_at = KittyScanner::findIdaPatternFirst(text_seg.start, text_seg.end, "33 ? 55 66 ? 77 88 ? 99");
    KITTY_LOGI("found IDA pattern at: %p", (void *)found_at);
    // scan with IDA pattern get all results
    found_at_list = KittyScanner::findIdaPatternAll(text_seg.start, text_seg.end, "33 ? 55 66 ? 77 88 ? 99");
    KITTY_LOGI("found IDA pattern results: %zu", found_at_list.size());
    
    // scan with data type & get one result
    uint32_t data = 0x99887766;
    found_at = KittyScanner::findDataFirst(data_seg.start, data_seg.end, &data, sizeof(data));
    KITTY_LOGI("found data at: %p", (void *)found_at);
    
    // scan with data type & get all results
    found_at_list = KittyScanner::findDataAll(data_seg.start, data_seg.end, &data, sizeof(data));
    KITTY_LOGI("found data results: %zu", found_at_list.size());
    
    KITTY_LOGI("================= HEX DUMP =================");
    
    // hex dump by default 8 rows with ASCII
    KITTY_LOGI("%{public}s", KittyUtils::HexDump(g_BaseInfo.header, sizeof(*g_BaseInfo.header)).c_str());
    
    KITTY_LOGI("============================================");
    
    // 16 rows, no ASCII
    KITTY_LOGI("\n%{public}s", KittyUtils::HexDump<16, false>(g_BaseInfo.header, sizeof(*g_BaseInfo.header)).c_str());
}

__attribute__((constructor)) void init()
{
    std::thread(test_thread).detach();
}

```

`example-ios/control`:

```
Package: com.example.ios
Name: example
Depends: mobilesubstrate
Version: 0.0.1
Architecture: iphoneos-arm
Description: Test tweak for fwd assault
Maintainer: CyberCat
Author: CyberCat
Section: Tweaks

```

`example-ios/example.plist`:

```plist
{ Filter = { Bundles = ( "com.blayzegames.newfps" ); }; }

```