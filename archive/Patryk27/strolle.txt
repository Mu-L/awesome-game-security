Project Path: arc_Patryk27_strolle_dtn3c3lj

Source Tree:

```txt
arc_Patryk27_strolle_dtn3c3lj
├── Cargo.lock
├── Cargo.toml
├── Justfile
├── LICENSE
├── README.md
├── _readme
│   ├── demo-v11.jpg
│   ├── demo-v16.jpg
│   ├── demo-v17.jpg
│   └── demo-v9.jpg
├── bevy-strolle
│   ├── Cargo.toml
│   ├── assets
│   │   ├── cornell.zip
│   │   └── demo.zip
│   ├── examples
│   │   ├── _common.rs
│   │   ├── cornell.rs
│   │   ├── demo.rs
│   │   ├── minecraft.rs
│   │   ├── stress-bvh.rs
│   │   └── stress-lights.rs
│   └── src
│       ├── camera.rs
│       ├── debug.rs
│       ├── event.rs
│       ├── graph.rs
│       ├── lib.rs
│       ├── rendering_node.rs
│       ├── stages
│       │   ├── extract.rs
│       │   └── prepare.rs
│       ├── stages.rs
│       ├── state.rs
│       ├── sun.rs
│       └── utils.rs
├── rust-toolchain.toml
├── rustfmt.toml
├── shell.nix
├── strolle
│   ├── Cargo.toml
│   ├── assets
│   │   ├── blue-noise.png
│   │   └── blue-noise.txt
│   ├── build.rs
│   └── src
│       ├── buffers
│       │   ├── bind_group.rs
│       │   ├── bindable.rs
│       │   ├── bufferable.rs
│       │   ├── double_buffered.rs
│       │   ├── mapped_storage_buffer.rs
│       │   ├── mapped_uniform_buffer.rs
│       │   ├── storage_buffer.rs
│       │   ├── texture.rs
│       │   └── utils.rs
│       ├── buffers.rs
│       ├── bvh
│       │   ├── builder.rs
│       │   ├── node.rs
│       │   ├── nodes.rs
│       │   ├── primitive.rs
│       │   ├── primitives.rs
│       │   └── serializer.rs
│       ├── bvh.rs
│       ├── camera.rs
│       ├── camera_controller
│       │   ├── buffers.rs
│       │   ├── pass.rs
│       │   ├── passes
│       │   │   ├── atmosphere.rs
│       │   │   ├── bvh_heatmap.rs
│       │   │   ├── di_resolving.rs
│       │   │   ├── di_sampling.rs
│       │   │   ├── di_spatial_resampling.rs
│       │   │   ├── di_temporal_resampling.rs
│       │   │   ├── frame_composition.rs
│       │   │   ├── frame_denoising.rs
│       │   │   ├── frame_reprojection.rs
│       │   │   ├── gi_preview_resampling.rs
│       │   │   ├── gi_reprojection.rs
│       │   │   ├── gi_resolving.rs
│       │   │   ├── gi_sampling.rs
│       │   │   ├── gi_spatial_resampling.rs
│       │   │   ├── gi_temporal_resampling.rs
│       │   │   ├── prim_raster.rs
│       │   │   ├── ref_shading.rs
│       │   │   └── ref_tracing.rs
│       │   └── passes.rs
│       ├── camera_controller.rs
│       ├── camera_controllers.rs
│       ├── image.rs
│       ├── images.rs
│       ├── instance.rs
│       ├── instances.rs
│       ├── lib.rs
│       ├── light.rs
│       ├── lights.rs
│       ├── material.rs
│       ├── materials.rs
│       ├── mesh.rs
│       ├── mesh_triangle.rs
│       ├── meshes.rs
│       ├── noise.rs
│       ├── shaders.rs
│       ├── sun.rs
│       ├── triangle.rs
│       ├── triangles.rs
│       ├── utils
│       │   ├── allocator.rs
│       │   ├── axis.rs
│       │   ├── bounding_box.rs
│       │   └── metrics.rs
│       └── utils.rs
├── strolle-gpu
│   ├── Cargo.toml
│   └── src
│       ├── atmosphere.rs
│       ├── brdf.rs
│       ├── bvh_view.rs
│       ├── camera.rs
│       ├── frame.rs
│       ├── gbuffer.rs
│       ├── hit.rs
│       ├── lib.rs
│       ├── light.rs
│       ├── lights.rs
│       ├── material.rs
│       ├── materials.rs
│       ├── noise
│       │   ├── blue.rs
│       │   └── white.rs
│       ├── noise.rs
│       ├── normal.rs
│       ├── passes.rs
│       ├── ray.rs
│       ├── reprojection.rs
│       ├── reservoir
│       │   ├── di.rs
│       │   ├── ephemeral.rs
│       │   ├── gi.rs
│       │   └── mis.rs
│       ├── reservoir.rs
│       ├── surface.rs
│       ├── triangle.rs
│       ├── triangles.rs
│       ├── utils
│       │   ├── bilinear_filter.rs
│       │   ├── f32_ext.rs
│       │   ├── u32_ext.rs
│       │   ├── vec2_ext.rs
│       │   └── vec3_ext.rs
│       ├── utils.rs
│       └── world.rs
├── strolle-shader-builder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── strolle-shaders
    ├── Cargo.toml
    └── src
        ├── atmosphere
        │   ├── generate_scattering_lut.rs
        │   ├── generate_sky_lut.rs
        │   ├── generate_transmittance_lut.rs
        │   └── utils.rs
        ├── atmosphere.rs
        ├── bvh_heatmap.rs
        ├── di_resolving.rs
        ├── di_sampling.rs
        ├── di_spatial_resampling.rs
        ├── di_temporal_resampling.rs
        ├── frame_composition.rs
        ├── frame_denoising.rs
        ├── frame_reprojection.rs
        ├── gi_preview_resampling.rs
        ├── gi_reprojection.rs
        ├── gi_resolving.rs
        ├── gi_sampling_a.rs
        ├── gi_sampling_b.rs
        ├── gi_spatial_resampling.rs
        ├── gi_temporal_resampling.rs
        ├── lib.rs
        ├── prim_raster.rs
        ├── ref_shading.rs
        └── ref_tracing.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "ab_glyph"
version = "0.2.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80179d7dd5d7e8c285d67c4a1e652972a92de7475beddfb92028c76463b13225"
dependencies = [
 "ab_glyph_rasterizer",
 "owned_ttf_parser",
]

[[package]]
name = "ab_glyph_rasterizer"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c71b1793ee61086797f5c80b6efa2b8ffa6d5dd703f118545808a7f2e27f7046"

[[package]]
name = "accesskit"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca8410747ed85a17c4a1e9ed3f5a74d3e7bdcc876cf9a18ff40ae21d645997b2"

[[package]]
name = "accesskit_consumer"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c17cca53c09fbd7288667b22a201274b9becaa27f0b91bf52a526db95de45e6"
dependencies = [
 "accesskit",
]

[[package]]
name = "accesskit_macos"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd3b6ae1eabbfbced10e840fd3fce8a93ae84f174b3e4ba892ab7bcb42e477a7"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "objc2",
 "once_cell",
]

[[package]]
name = "accesskit_windows"
version = "0.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afcae27ec0974fc7c3b0b318783be89fd1b2e66dd702179fe600166a38ff4a0b"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "once_cell",
 "paste",
 "static_assertions",
 "windows 0.48.0",
]

[[package]]
name = "accesskit_winit"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88e39fcec2e10971e188730b7a76bab60647dacc973d4591855ebebcadfaa738"
dependencies = [
 "accesskit",
 "accesskit_macos",
 "accesskit_windows",
 "winit",
]

[[package]]
name = "addr2line"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a30b2e23b9e17a9f90641c7ab1549cd9b44f296d3ccbf309d2863cfe398a0cb"
dependencies = [
 "gimli 0.28.1",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "getrandom",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"

[[package]]
name = "alsa"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2562ad8dcf0f789f65c6fdaad8a8a9708ed6b488e649da28c01656ad66b8b47"
dependencies = [
 "alsa-sys",
 "bitflags 1.3.2",
 "libc",
 "nix 0.24.3",
]

[[package]]
name = "alsa-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db8fee663d06c4e303404ef5f40488a53e062f89ba8bfed81f42325aafad1527"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "android-activity"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64529721f27c2314ced0890ce45e469574a73e5e6fdd6e9da1860eb29285f5e0"
dependencies = [
 "android-properties",
 "bitflags 1.3.2",
 "cc",
 "jni-sys",
 "libc",
 "log",
 "ndk",
 "ndk-context",
 "ndk-sys",
 "num_enum 0.6.1",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_log-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ecc8056bf6ab9892dcd53216c83d1597487d7dacac16c8df6b877d127df9937"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "approx"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6"
dependencies = [
 "num-traits",
]

[[package]]
name = "ar"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d67af77d68a931ecd5cbd8a3b5987d63a1d1d1278f7f6a60ae33db485cdebb69"

[[package]]
name = "arboard"
version = "3.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1faa3c733d9a3dd6fbaf85da5d162a2e03b2e0033a90dceb0e2a90fdd1e5380a"
dependencies = [
 "clipboard-win",
 "core-graphics 0.23.1",
 "image",
 "log",
 "objc",
 "objc-foundation",
 "objc_id",
 "parking_lot",
 "thiserror",
 "windows-sys 0.48.0",
 "x11rb",
]

[[package]]
name = "arrayref"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"

[[package]]
name = "arrayvec"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"

[[package]]
name = "ash"
version = "0.37.3+1.3.251"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39e9c3835d686b0a6084ab4234fcd1b07dbf6e4767dce60874b12356a25ecd4a"
dependencies = [
 "libloading 0.7.4",
]

[[package]]
name = "async-broadcast"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c48ccdbf6ca6b121e0f586cbc0e73ae440e56c67c30fa0873b4e110d9c26d2b"
dependencies = [
 "event-listener 2.5.3",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81953c529336010edd6d8e358f886d9581267795c61b19475b71314bffa46d35"
dependencies = [
 "concurrent-queue",
 "event-listener 2.5.3",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ca33f4bc4ed1babef42cad36cc1f51fa88be00420404e5b1e80ab1b18f7678c"
dependencies = [
 "concurrent-queue",
 "event-listener 4.0.1",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17ae5ebefcc48e7452b4987947920dac9450be1110cadf34d1b8c116bdbaf97c"
dependencies = [
 "async-lock 3.2.0",
 "async-task",
 "concurrent-queue",
 "fastrand 2.0.1",
 "futures-lite 2.1.0",
 "slab",
]

[[package]]
name = "async-fs"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "279cf904654eeebfa37ac9bb1598880884924aab82e290aa65c9e77a0e142e06"
dependencies = [
 "async-lock 2.8.0",
 "autocfg",
 "blocking",
 "futures-lite 1.13.0",
]

[[package]]
name = "async-lock"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "287272293e9d8c41773cec55e365490fe034813a2f172f502d6ddcf75b2f582b"
dependencies = [
 "event-listener 2.5.3",
]

[[package]]
name = "async-lock"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7125e42787d53db9dd54261812ef17e937c95a51e4d291373b670342fa44310c"
dependencies = [
 "event-listener 4.0.1",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-task"
version = "4.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1d90cd0b264dfdd8eb5bad0a2c217c1f88fa96a8573f40e7b12de23fb468f46"

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "backtrace"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2089b7e3f35b9dd2d0ed921ead4f6d318c27680d4a5bd167b3ee120edb105837"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object 0.32.2",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"

[[package]]
name = "base64"
version = "0.21.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35636a1494ede3b646cc98f74f8e62c773a38a659ebc777a2cf26b9b74171df9"

[[package]]
name = "bevy"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4bc7e09282a82a48d70ade0c4c1154b0fd7882a735a39c66766a5d0f4718ea9"
dependencies = [
 "bevy_internal",
]

[[package]]
name = "bevy-strolle"
version = "0.1.0"
dependencies = [
 "bevy",
 "bevy_egui",
 "bevy_mod_raycast",
 "bevy_rapier3d",
 "log",
 "smooth-bevy-cameras",
 "strolle",
 "wgpu",
 "zip",
]

[[package]]
name = "bevy_a11y"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68080288c932634f6563d3a8299efe0ddc9ea6787539c4c771ba250d089a94f0"
dependencies = [
 "accesskit",
 "bevy_app",
 "bevy_derive",
 "bevy_ecs",
]

[[package]]
name = "bevy_animation"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7aa37683b1281e1ba8cf285644e6e3f0704f14b3901c5ee282067ff7ff6f4a56"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_core",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
]

[[package]]
name = "bevy_app"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d41731817993f92e4363dd3335558e779e290bc71eefc0b5547052b85810907e"
dependencies = [
 "bevy_derive",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "downcast-rs",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "bevy_asset"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "935984568f75867dd7357133b06f4b1502cd2be55e4642d483ce597e46e63bff"
dependencies = [
 "async-broadcast",
 "async-fs",
 "async-lock 2.8.0",
 "bevy_app",
 "bevy_asset_macros",
 "bevy_ecs",
 "bevy_log",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bevy_winit",
 "blake3",
 "crossbeam-channel",
 "downcast-rs",
 "futures-io",
 "futures-lite 1.13.0",
 "js-sys",
 "parking_lot",
 "ron",
 "serde",
 "thiserror",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "bevy_asset_macros"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f48b9bbe4ec605e4910b5cd1e1a0acbfbe0b80af5f3bcc4489a9fdd1e80058c"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "bevy_audio"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18a69889e1bfa4dbac4e641536b94f91c441da55796ad9832e77836b8264688b"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_transform",
 "bevy_utils",
 "oboe",
 "rodio",
]

[[package]]
name = "bevy_core"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3daa24502a14839509f02407bc7e48299fe84d260877de23b60662de0f4f4b6c"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bytemuck",
]

[[package]]
name = "bevy_core_pipeline"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4b77c4fca6e90edbe2e72da7bc9aa7aed7dfdfded0920ae0a0c845f5e11084a"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_core",
 "bevy_derive",
 "bevy_ecs",
 "bevy_log",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bitflags 2.4.1",
 "radsort",
 "serde",
]

[[package]]
name = "bevy_derive"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f484318350462c58ba3942a45a656c1fd6b6e484a6b6b7abc3a787ad1a51e500"
dependencies = [
 "bevy_macro_utils",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "bevy_diagnostic"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa38ca5967d335cc1006a0e0f1a86c350e2f15fd1878449f61d04cd57a7c4060"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_log",
 "bevy_time",
 "bevy_utils",
 "sysinfo",
]

[[package]]
name = "bevy_ecs"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7709fbd22f81fb681534cd913c41e1cd18b17143368743281195d7f024b61aea"
dependencies = [
 "async-channel 1.9.0",
 "bevy_ecs_macros",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "downcast-rs",
 "event-listener 2.5.3",
 "fixedbitset",
 "rustc-hash",
 "serde",
 "thiserror",
 "thread_local",
]

[[package]]
name = "bevy_ecs_macros"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8843aa489f159f25cdcd9fee75cd7d221a7098a71eaa72cb2d6b40ac4e3f1ba"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "bevy_egui"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c90c01202dbcebc03315a01ea71553b35e1f20b0da6b1cc8c2605344032a3d96"
dependencies = [
 "arboard",
 "bevy",
 "egui",
 "thread_local",
 "webbrowser",
]

[[package]]
name = "bevy_encase_derive"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5328a3715e933ebbff07d0e99528dc423c4f7a53590ed1ac19a120348b028990"
dependencies = [
 "bevy_macro_utils",
 "encase_derive_impl",
]

[[package]]
name = "bevy_gilrs"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b81ca2ebf66cbc7f998f1f142b15038ffe3c4ae1d51f70adda26dcf51b0c4ca"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_input",
 "bevy_log",
 "bevy_time",
 "bevy_utils",
 "gilrs",
 "thiserror",
]

[[package]]
name = "bevy_gizmos"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db232274ddca2ae452eb2731b98267b795d133ddd14013121bc7daddde1c7491"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_core",
 "bevy_core_pipeline",
 "bevy_ecs",
 "bevy_math",
 "bevy_pbr",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_transform",
 "bevy_utils",
]

[[package]]
name = "bevy_gltf"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85adc6b1fc86687bf67149e0bafaa4d6da432232fa956472d1b37f19121d3ace"
dependencies = [
 "base64 0.13.1",
 "bevy_animation",
 "bevy_app",
 "bevy_asset",
 "bevy_core",
 "bevy_core_pipeline",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_log",
 "bevy_math",
 "bevy_pbr",
 "bevy_reflect",
 "bevy_render",
 "bevy_scene",
 "bevy_tasks",
 "bevy_transform",
 "bevy_utils",
 "gltf",
 "percent-encoding",
 "serde",
 "serde_json",
 "thiserror",
]

[[package]]
name = "bevy_hierarchy"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06bd477152ce2ae1430f5e0a4f19216e5785c22fee1ab23788b5982dc59d1a55"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_log",
 "bevy_reflect",
 "bevy_utils",
 "smallvec",
]

[[package]]
name = "bevy_input"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cab9a599189b2a694c182d60cd52219dd9364f9892ff542d87799b8e45d9e6dc"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "thiserror",
]

[[package]]
name = "bevy_internal"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f124bece9831afd80897815231072d51bfe3ac58c6bb58eca8880963b6d0487c"
dependencies = [
 "bevy_a11y",
 "bevy_animation",
 "bevy_app",
 "bevy_asset",
 "bevy_audio",
 "bevy_core",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_diagnostic",
 "bevy_ecs",
 "bevy_gilrs",
 "bevy_gizmos",
 "bevy_gltf",
 "bevy_hierarchy",
 "bevy_input",
 "bevy_log",
 "bevy_math",
 "bevy_pbr",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_render",
 "bevy_scene",
 "bevy_sprite",
 "bevy_tasks",
 "bevy_text",
 "bevy_time",
 "bevy_transform",
 "bevy_ui",
 "bevy_utils",
 "bevy_window",
 "bevy_winit",
]

[[package]]
name = "bevy_log"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dc10ba1d225a8477b9e80a1bf797d8a8b8274e83c9b24fb4d9351aec9229755"
dependencies = [
 "android_log-sys",
 "bevy_app",
 "bevy_ecs",
 "bevy_utils",
 "console_error_panic_hook",
 "tracing-log 0.1.4",
 "tracing-subscriber",
 "tracing-wasm",
]

[[package]]
name = "bevy_macro_utils"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e566640c6b6dced73d2006c764c2cffebe1a82be4809486c4a5d7b4b50efed4d"
dependencies = [
 "proc-macro2",
 "quote",
 "rustc-hash",
 "syn 2.0.100",
 "toml_edit 0.20.7",
]

[[package]]
name = "bevy_math"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58ddc2b76783939c530178f88e5711a1b01044d7b02db4033e2eb8b43b6cf4ec"
dependencies = [
 "glam",
 "serde",
]

[[package]]
name = "bevy_mikktspace"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ec4962977a746d870170532fc92759e04d3dbcae8b7b82e7ca3bb83b1d75277"
dependencies = [
 "glam",
]

[[package]]
name = "bevy_mod_raycast"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b127622dcbfd9e6a1661219af65965625901c2549b434f0c44c4460dd055dce"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_gizmos",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "crossbeam-channel",
]

[[package]]
name = "bevy_pbr"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520bfd2a898c74f84ea52cfb8eb061f37373ad15e623489d5f75d27ebd6138fe"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.4.1",
 "bytemuck",
 "fixedbitset",
 "naga_oil",
 "radsort",
 "smallvec",
 "thread_local",
]

[[package]]
name = "bevy_ptr"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c77ec20c8fafcdc196508ef5ccb4f0400a8d193cb61f7b14a36ed9a25ad423cf"

[[package]]
name = "bevy_rapier3d"
version = "0.23.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3f0a2641af76c9eb17da0dcb0fb20cd9d615b93b67be0b85f1867487e956b5a"
dependencies = [
 "bevy",
 "bitflags 2.4.1",
 "log",
 "nalgebra",
 "rapier3d",
]

[[package]]
name = "bevy_reflect"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7921f15fc944c9c8ad01d7dbcea6505b8909c6655cd9382bab1407181556038"
dependencies = [
 "bevy_math",
 "bevy_ptr",
 "bevy_reflect_derive",
 "bevy_utils",
 "downcast-rs",
 "erased-serde",
 "glam",
 "serde",
 "smallvec",
 "smol_str",
 "thiserror",
]

[[package]]
name = "bevy_reflect_derive"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4a8c5475f216e751ef4452a1306b00711f33d2d04d9f149e4c845dfeb6753a0"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
 "uuid",
]

[[package]]
name = "bevy_render"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdefdd3737125b0d94a6ff20bb70fa8cfe9d7d5dcd72ba4dfe6c5f1d30d9f6e4"
dependencies = [
 "async-channel 1.9.0",
 "bevy_app",
 "bevy_asset",
 "bevy_core",
 "bevy_derive",
 "bevy_ecs",
 "bevy_encase_derive",
 "bevy_hierarchy",
 "bevy_log",
 "bevy_math",
 "bevy_mikktspace",
 "bevy_reflect",
 "bevy_render_macros",
 "bevy_tasks",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.4.1",
 "bytemuck",
 "codespan-reporting",
 "downcast-rs",
 "encase",
 "futures-lite 1.13.0",
 "hexasphere",
 "image",
 "js-sys",
 "ktx2",
 "naga",
 "naga_oil",
 "ruzstd 0.4.0",
 "serde",
 "smallvec",
 "thiserror",
 "thread_local",
 "wasm-bindgen",
 "web-sys",
 "wgpu",
]

[[package]]
name = "bevy_render_macros"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64d86bfc5a1e7fbeeaec0c4ceab18155530f5506624670965db3415f75826bea"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "bevy_scene"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7df078b5e406e37c8a1c6ba0d652bf105fde713ce3c3efda7263fe27467eee5"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "ron",
 "serde",
 "thiserror",
 "uuid",
]

[[package]]
name = "bevy_sprite"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7cc0c9d946e17e3e0aaa202f182837bc796c4f862b2e5a805134f873f21cf7f"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_log",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bitflags 2.4.1",
 "bytemuck",
 "fixedbitset",
 "guillotiere",
 "radsort",
 "rectangle-pack",
 "thiserror",
]

[[package]]
name = "bevy_tasks"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4fefa7fe0da8923525f7500e274f1bd60dbd79918a25cf7d0dfa0a6ba15c1cf"
dependencies = [
 "async-channel 1.9.0",
 "async-executor",
 "async-task",
 "concurrent-queue",
 "futures-lite 1.13.0",
 "wasm-bindgen-futures",
]

[[package]]
name = "bevy_text"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a9a79d49ca06170d69149949b134c14e8b99ace1444c1ca2cd4743b19d5b055"
dependencies = [
 "ab_glyph",
 "bevy_app",
 "bevy_asset",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "glyph_brush_layout",
 "serde",
 "thiserror",
]

[[package]]
name = "bevy_time"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6250d76eed3077128b6a3d004f9f198b01107800b9824051e32bb658054e837"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_utils",
 "crossbeam-channel",
 "thiserror",
]

[[package]]
name = "bevy_transform"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d541e0c292edbd96afae816ee680e02247422423ccd5dc635c1e211a20ed64be"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_math",
 "bevy_reflect",
 "thiserror",
]

[[package]]
name = "bevy_ui"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d785e3b75dabcb2a8ad0d50933f8f3446d59e512cabc2d2a145e28c2bb8792ba"
dependencies = [
 "bevy_a11y",
 "bevy_app",
 "bevy_asset",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_input",
 "bevy_log",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_text",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bytemuck",
 "serde",
 "smallvec",
 "taffy",
 "thiserror",
]

[[package]]
name = "bevy_utils"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7915222f4a08ccc782e08d10b751b42e5f9d786e697d0cb3fd09333cb7e8b6ea"
dependencies = [
 "ahash",
 "bevy_utils_proc_macros",
 "getrandom",
 "hashbrown 0.14.3",
 "instant",
 "nonmax",
 "petgraph",
 "thiserror",
 "tracing",
 "uuid",
]

[[package]]
name = "bevy_utils_proc_macros"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7aafecc952b6b8eb1a93c12590bd867d25df2f4ae1033a01dfdfc3c35ebccfff"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "bevy_window"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41ee72bf7f974000e9b31bb971a89387f1432ba9413f35c4fef59fef49767260"
dependencies = [
 "bevy_a11y",
 "bevy_app",
 "bevy_ecs",
 "bevy_input",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "raw-window-handle",
]

[[package]]
name = "bevy_winit"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1eb71f287eca9006dda998784c7b931e400ae2cc4c505da315882a8b082f21ad"
dependencies = [
 "accesskit_winit",
 "approx",
 "bevy_a11y",
 "bevy_app",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_input",
 "bevy_math",
 "bevy_tasks",
 "bevy_utils",
 "bevy_window",
 "crossbeam-channel",
 "raw-window-handle",
 "wasm-bindgen",
 "web-sys",
 "winit",
]

[[package]]
name = "bindgen"
version = "0.69.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ffcebc3849946a7170a05992aac39da343a90676ab392c51a4280981d6379c2"
dependencies = [
 "bitflags 2.4.1",
 "cexpr",
 "clang-sys",
 "lazy_static",
 "lazycell",
 "peeking_take_while",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn 2.0.100",
]

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"
dependencies = [
 "serde",
]

[[package]]
name = "blake3"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0231f06152bf547e9c2b5194f247cd97aacf6dcd8b15d8e5ec0663f64580da87"
dependencies = [
 "arrayref",
 "arrayvec",
 "cc",
 "cfg-if",
 "constant_time_eq",
]

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block-sys"
version = "0.1.0-beta.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fa55741ee90902547802152aaf3f8e5248aab7e21468089560d4c8840561146"
dependencies = [
 "objc-sys",
]

[[package]]
name = "block2"
version = "0.2.0-alpha.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8dd9e63c1744f755c2f60332b88de39d341e5e86239014ad839bd71c106dec42"
dependencies = [
 "block-sys",
 "objc2-encode",
]

[[package]]
name = "blocking"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a37913e8dc4ddcc604f0c6d3bf2887c995153af3611de9e23c352b44c1b9118"
dependencies = [
 "async-channel 2.1.1",
 "async-lock 3.2.0",
 "async-task",
 "fastrand 2.0.1",
 "futures-io",
 "futures-lite 2.1.0",
 "piper",
 "tracing",
]

[[package]]
name = "bumpalo"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f30e7476521f6f8af1a1c4c0b8cc94f0bee37d91763d0ca2665f299b6cd8aec"

[[package]]
name = "bytemuck"
version = "1.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6b1fc10dbac614ebc03540c9dbd60e83887fda27794998c6528f1782047d540"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "965ab7eb5f8f97d2a083c799f3a1b994fc397b2fe2da5d1da1626ce15a39f2b1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2bd12c1caf447e69cd4528f47f94d203fd2582878ecb9e9465484c4148a8223"

[[package]]
name = "cc"
version = "1.0.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1174fb0b6ec23863f8b971027804a42614e347eafb0a95bf0b12cdae21fc4d0"
dependencies = [
 "jobserver",
 "libc",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "clang-sys"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c688fc74432808e3eb684cae8830a86be1d66a2bd58e1f248ed0960a590baf6f"
dependencies = [
 "glob",
 "libc",
 "libloading 0.7.4",
]

[[package]]
name = "clipboard-win"
version = "5.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ec832972fefb8cf9313b45a0d1945e29c9c251f1d4c6eafc5fe2124c02d2e81"
dependencies = [
 "error-code",
]

[[package]]
name = "codespan-reporting"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
dependencies = [
 "termcolor",
 "unicode-width",
]

[[package]]
name = "color_quant"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d7b894f5411737b7867f4827955924d7c254fc9f4d91a6aad6b097804b1018b"

[[package]]
name = "com-rs"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf43edc576402991846b093a7ca18a3477e0ef9c588cde84964b5d3e43016642"

[[package]]
name = "combine"
version = "4.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "35ed6e9d84f0b51a7f52daf1c7d71dd136fd7a3f41a8462b8cdb8c78d920fad4"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d16048cd947b08fa32c24458a22f5dc5e835264f689f4f5653210c69fd107363"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console_error_panic_hook"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06aeb73f470f66dcdbf7223caeebb85984942f22f1adb2a088cf9668146bbbc"
dependencies = [
 "cfg-if",
 "wasm-bindgen",
]

[[package]]
name = "const_panic"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6051f239ecec86fde3410901ab7860d458d160371533842974fc61f96d15879b"

[[package]]
name = "const_soft_float"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ca1caa64ef4ed453e68bb3db612e51cf1b2f5b871337f0fcab1c8f87cc3dff"

[[package]]
name = "constant_time_eq"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7144d30dcf0fafbce74250a3963025d8d52177934239851c917d29f1df280c2"

[[package]]
name = "constgebra"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edd23e864550e6dafc1e41ac78ce4f1ccddc8672b40c403524a04ff3f0518420"
dependencies = [
 "const_soft_float",
]

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06ea2b9bc92be3c2baa9334a323ebca2d6f074ff852cd1d7b11064035cd3868f"

[[package]]
name = "core-graphics"
version = "0.22.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2581bbab3b8ffc6fcbd550bf46c355135d16e9ff2a6ea032ad6b9bf1d7efe4fb"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-graphics-types",
 "foreign-types 0.3.2",
 "libc",
]

[[package]]
name = "core-graphics"
version = "0.23.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "970a29baf4110c26fedbc7f82107d42c23f7e88e404c4577ed73fe99ff85a212"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "core-graphics-types",
 "foreign-types 0.5.0",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45390e6114f68f718cc7a830514a96f903cccd70d02a8f6d9f643ac4ba45afaf"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation",
 "libc",
]

[[package]]
name = "coreaudio-rs"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "321077172d79c662f64f5071a03120748d5bb652f5231570141be24cfcd2bace"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation-sys",
 "coreaudio-sys",
]

[[package]]
name = "coreaudio-sys"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3120ebb80a9de008e638ad833d4127d50ea3d3a960ea23ea69bc66d9358a028"
dependencies = [
 "bindgen",
]

[[package]]
name = "cpal"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d959d90e938c5493000514b446987c07aed46c668faaa7d34d6c7a67b1a578c"
dependencies = [
 "alsa",
 "core-foundation-sys",
 "coreaudio-rs",
 "dasp_sample",
 "jni 0.19.0",
 "js-sys",
 "libc",
 "mach2",
 "ndk",
 "ndk-context",
 "oboe",
 "once_cell",
 "parking_lot",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows 0.46.0",
]

[[package]]
name = "crc32fast"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6eb9105919ca8e40d437fc9cbb8f1975d916f1bd28afe795a48aae32a2cc8920"
dependencies = [
 "cfg-if",
 "crossbeam-channel",
 "crossbeam-deque",
 "crossbeam-epoch",
 "crossbeam-queue",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82a9b73a36529d9c47029b9fb3a6f0ea3cc916a261195352ba19e770fc1748b2"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fca89a0e215bab21874660c67903c5f143333cab1da83d041c7ded6053774751"
dependencies = [
 "cfg-if",
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e3681d554572a651dda4186cd47240627c3d0114d45a95f6ad27f2f22e7548d"
dependencies = [
 "autocfg",
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-queue"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc6598521bb5a83d491e8c1fe51db7296019d2ca3cb93cc6c2a20369a4d78a2"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3a430a770ebd84726f584a90ee7f020d28db52c6d02138900f22341f866d39c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "d3d12"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e16e44ab292b1dddfdaf7be62cfd8877df52f2f3fde5858d95bab606be259f20"
dependencies = [
 "bitflags 2.4.1",
 "libloading 0.8.1",
 "winapi",
]

[[package]]
name = "dasp_sample"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c87e182de0887fd5361989c677c4e8f5000cd9491d6d563161a8f3a5519fc7f"

[[package]]
name = "data-encoding"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e962a19be5cfc3f3bf6dd8f61eb50107f356ad6270fbb3ed41476571db78be5"

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_more"
version = "0.99.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 1.0.109",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "downcast-rs"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ea835d29036a4087793836fa931b08837ad5e957da9e23886b29586fb9b6650"

[[package]]
name = "ecolor"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b7637fc2e74d17e52931bac90ff4fc061ac776ada9c7fa272f24cdca5991972"
dependencies = [
 "bytemuck",
]

[[package]]
name = "egui"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c55bcb864b764eb889515a38b8924757657a250738ad15126637ee2df291ee6b"
dependencies = [
 "ahash",
 "epaint",
 "nohash-hasher",
]

[[package]]
name = "either"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"

[[package]]
name = "elsa"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d98e71ae4df57d214182a2e5cb90230c0192c6ddfcaa05c36453d46a54713e10"
dependencies = [
 "indexmap 2.9.0",
 "stable_deref_trait",
]

[[package]]
name = "emath"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a045c6c0b44b35e98513fc1e9d183ab42881ac27caccb9fa345465601f56cce4"
dependencies = [
 "bytemuck",
]

[[package]]
name = "encase"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fce2eeef77fd4a293a54b62aa00ac9daebfbcda4bf8998c5a815635b004aa1c"
dependencies = [
 "const_panic",
 "encase_derive",
 "glam",
 "thiserror",
]

[[package]]
name = "encase_derive"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e520cde08cbf4f7cc097f61573ec06ce467019803de8ae82fb2823fa1554a0e"
dependencies = [
 "encase_derive_impl",
]

[[package]]
name = "encase_derive_impl"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fe2568f851fd6144a45fa91cfed8fe5ca8fc0b56ba6797bfc1ed2771b90e37c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "epaint"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d1b9e000d21bab9b535ce78f9f7745be28b3f777f6c7223936561c5c7fefab8"
dependencies = [
 "ab_glyph",
 "ahash",
 "bytemuck",
 "ecolor",
 "emath",
 "nohash-hasher",
 "parking_lot",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "erased-serde"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c138974f9d5e7fe373eb04df7cae98833802ae4b11c24ac7039a21d5af4b26c"
dependencies = [
 "serde",
]

[[package]]
name = "errno"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "976dd42dc7e85965fe702eb8164f21f450704bdde31faefd6471dba214cb594e"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "error-code"
version = "3.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "281e452d3bad4005426416cdba5ccfd4f5c1280e10099e21db27f7c1c28347fc"

[[package]]
name = "euclid"
version = "0.22.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87f253bc5c813ca05792837a0ff4b3a580336b224512d48f7eda1d7dd9210787"
dependencies = [
 "num-traits",
]

[[package]]
name = "event-listener"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"

[[package]]
name = "event-listener"
version = "4.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84f2cdcf274580f2d63697192d744727b3198894b1bf02923643bf59e2c26712"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "958e4d70b6d5e81971bebec42271ec641e7ff4e170a6fa605f2b8a8b65cb97d3"
dependencies = [
 "event-listener 4.0.1",
 "pin-project-lite",
]

[[package]]
name = "fallible-iterator"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2acce4a10f12dc2fb14a218589d4f1f62ef011b2d0cc4b3cb1bba8e94da14649"

[[package]]
name = "fastrand"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
dependencies = [
 "instant",
]

[[package]]
name = "fastrand"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25cbce373ec4653f1a01a31e8a5e5ec0c622dc27ff9c4e6606eefef5cbbed4a5"

[[package]]
name = "fdeflate"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "209098dd6dfc4445aa6111f0e98653ac323eaa4dfd212c9ca3931bf9955c31bd"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "fixedbitset"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"

[[package]]
name = "flate2"
version = "1.0.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46303f565772937ffe1d394a4fac6f411c6013172fadde9dcdb1e147a086940e"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared 0.1.1",
]

[[package]]
name = "foreign-types"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d737d9aa519fb7b749cbc3b962edcf310a8dd1f4b67c91c4f83975dbdd17d965"
dependencies = [
 "foreign-types-macros",
 "foreign-types-shared 0.3.1",
]

[[package]]
name = "foreign-types-macros"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a5c6c585bc94aaf2c7b51dd4c2ba22680844aba4c687be581871a6f518c5742"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "foreign-types-shared"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa9a19cbb55df58761df49b23516a86d432839add4af60fc256da840f66ed35b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "futures-core"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfc6580bb841c5a68e9ef15c77ccc837b40a7504914d52e47b8b0e9bbda25a1d"

[[package]]
name = "futures-io"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a44623e20b9681a318efdd71c299b6b222ed6f231972bfe2f224ebad6311f0c1"

[[package]]
name = "futures-lite"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49a9d51ce47660b1e808d3c990b4709f2f415d928835a17dfd16991515c46bce"
dependencies = [
 "fastrand 1.9.0",
 "futures-core",
 "futures-io",
 "memchr",
 "parking",
 "pin-project-lite",
 "waker-fn",
]

[[package]]
name = "futures-lite"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aeee267a1883f7ebef3700f262d2d54de95dfaf38189015a74fdc4e0c7ad8143"
dependencies = [
 "fastrand 2.0.1",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "gethostname"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0176e0459c2e4a1fe232f984bca6890e681076abb9934f6cea7c326f3fc47818"
dependencies = [
 "libc",
 "windows-targets 0.48.5",
]

[[package]]
name = "getrandom"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe9006bed769170c11f845cf00c7c1e9092aeb3f268e007c3e760ac68008070f"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi",
 "wasm-bindgen",
]

[[package]]
name = "gilrs"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8b2e57a9cb946b5d04ae8638c5f554abb5a9f82c4c950fd5b1fee6d119592fb"
dependencies = [
 "fnv",
 "gilrs-core",
 "log",
 "uuid",
 "vec_map",
]

[[package]]
name = "gilrs-core"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0af1827b7dd2f36d740ae804c1b3ea0d64c12533fb61ff91883005143a0e8c5a"
dependencies = [
 "core-foundation",
 "inotify",
 "io-kit-sys",
 "js-sys",
 "libc",
 "libudev-sys",
 "log",
 "nix 0.27.1",
 "uuid",
 "vec_map",
 "wasm-bindgen",
 "web-sys",
 "windows 0.52.0",
]

[[package]]
name = "gimli"
version = "0.28.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4271d37baee1b8c7e4b708028c57d816cf9d2434acb33a549475f78c181f6253"

[[package]]
name = "gimli"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2e1d97fbe9722ba9bbd0c97051c2956e726562b61f86a25a4360398a40edfc9"
dependencies = [
 "fallible-iterator",
 "indexmap 2.9.0",
 "stable_deref_trait",
]

[[package]]
name = "glam"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5418c17512bdf42730f9032c74e1ae39afc408745ebb2acf72fbc4691c17945"
dependencies = [
 "bytemuck",
 "libm",
 "serde",
]

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "glow"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca0fe580e4b60a8ab24a868bc08e2f03cbcb20d3d676601fa909386713333728"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "gltf"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b78f069cf941075835822953c345b9e1edd67ae347b81ace3aea9de38c2ef33"
dependencies = [
 "byteorder",
 "gltf-json",
 "lazy_static",
 "serde_json",
]

[[package]]
name = "gltf-derive"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "438ffe1a5540d75403feaf23636b164e816e93f6f03131674722b3886ce32a57"
dependencies = [
 "inflections",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "gltf-json"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "655951ba557f2bc69ea4b0799446bae281fa78efae6319968bdd2c3e9a06d8e1"
dependencies = [
 "gltf-derive",
 "serde",
 "serde_derive",
 "serde_json",
]

[[package]]
name = "glyph_brush_layout"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc32c2334f00ca5ac3695c5009ae35da21da8c62d255b5b96d56e2597a637a38"
dependencies = [
 "ab_glyph",
 "approx",
 "xi-unicode",
]

[[package]]
name = "gpu-alloc"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbcd2dba93594b227a1f57ee09b8b9da8892c34d55aa332e034a228d0fe6a171"
dependencies = [
 "bitflags 2.4.1",
 "gpu-alloc-types",
]

[[package]]
name = "gpu-alloc-types"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98ff03b468aa837d70984d55f5d3f846f6ec31fe34bbb97c4f85219caeee1ca4"
dependencies = [
 "bitflags 2.4.1",
]

[[package]]
name = "gpu-allocator"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce95f9e2e11c2c6fadfce42b5af60005db06576f231f5c92550fdded43c423e8"
dependencies = [
 "backtrace",
 "log",
 "thiserror",
 "winapi",
 "windows 0.44.0",
]

[[package]]
name = "gpu-descriptor"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc11df1ace8e7e564511f53af41f3e42ddc95b56fd07b3f4445d2a6048bc682c"
dependencies = [
 "bitflags 2.4.1",
 "gpu-descriptor-types",
 "hashbrown 0.14.3",
]

[[package]]
name = "gpu-descriptor-types"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6bf0b36e6f090b7e1d8a4b49c0cb81c1f8376f72198c65dd3ad9ff3556b8b78c"
dependencies = [
 "bitflags 2.4.1",
]

[[package]]
name = "grid"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eec1c01eb1de97451ee0d60de7d81cf1e72aabefb021616027f3d1c3ec1c723c"

[[package]]
name = "guillotiere"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b62d5865c036cb1393e23c50693df631d3f5d7bcca4c04fe4cc0fd592e74a782"
dependencies = [
 "euclid",
 "svg_fmt",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.14.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"
dependencies = [
 "ahash",
 "allocator-api2",
 "serde",
]

[[package]]
name = "hashbrown"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"
dependencies = [
 "foldhash",
]

[[package]]
name = "hassle-rs"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1397650ee315e8891a0df210707f0fc61771b0cc518c3023896064c5407cb3b0"
dependencies = [
 "bitflags 1.3.2",
 "com-rs",
 "libc",
 "libloading 0.7.4",
 "thiserror",
 "widestring",
 "winapi",
]

[[package]]
name = "hexasphere"
version = "9.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7cb3df16a7bcb1b5bc092abd55e14f77ca70aea14445026e264586fc62889a10"
dependencies = [
 "constgebra",
 "glam",
]

[[package]]
name = "hexf-parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfa686283ad6dd069f105e5ab091b04c62850d3e4cf5d67debad1933f55023df"

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "idna"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "image"
version = "0.24.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f3dfdbdd72063086ff443e297b61695500514b1e41095b6fb9a5ab48a70a711"
dependencies = [
 "bytemuck",
 "byteorder",
 "color_quant",
 "jpeg-decoder",
 "num-rational",
 "num-traits",
 "png",
 "tiff",
]

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
]

[[package]]
name = "indexmap"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
dependencies = [
 "equivalent",
 "hashbrown 0.15.2",
]

[[package]]
name = "inflections"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a257582fdcde896fd96463bf2d40eefea0580021c0712a0e2b028b60b47a837a"

[[package]]
name = "inotify"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdd168d97690d0b8c412d6b6c10360277f4d7ee495c5d0d5d5fe0854923255cc"
dependencies = [
 "bitflags 1.3.2",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "internal-iterator"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "969ee3fc68ec2e88eb21434ce4d9b7e1600d1ce92ff974560a6c4a304f5124b9"

[[package]]
name = "io-kit-sys"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4769cb30e5dcf1710fc6730d3e94f78c47723a014a567de385e113c737394640"
dependencies = [
 "core-foundation-sys",
 "mach2",
]

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "jni"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c6df18c2e3db7e453d3c6ac5b3e9d5182664d28788126d39b91f2d1e22b017ec"
dependencies = [
 "cesu8",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
]

[[package]]
name = "jni"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "039022cdf4d7b1cf548d31f60ae783138e5fd42013f6271049d7df7afadef96c"
dependencies = [
 "cesu8",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
]

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c37f63953c4c63420ed5fd3d6d398c719489b9f872b9fa683262f8edd363c7d"
dependencies = [
 "libc",
]

[[package]]
name = "jpeg-decoder"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc0000e42512c92e31c2252315bda326620a4e034105e900c98ec492fa077b3e"

[[package]]
name = "js-sys"
version = "0.3.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cee9c64da59eae3b50095c18d3e74f8b73c0b86d2792824ff01bbce68ba229ca"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "khronos-egl"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c2352bd1d0bceb871cb9d40f24360c8133c11d7486b68b5381c1dd1a32015e3"
dependencies = [
 "libc",
 "libloading 0.7.4",
 "pkg-config",
]

[[package]]
name = "ktx2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87d65e08a9ec02e409d27a0139eaa6b9756b4d81fe7cde71f6941a83730ce838"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "lewton"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "777b48df9aaab155475a83a7df3070395ea1ac6902f5cd062b8f2b028075c030"
dependencies = [
 "byteorder",
 "ogg",
 "tinyvec",
]

[[package]]
name = "libc"
version = "0.2.172"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libloading"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c571b676ddfc9a8c12f1f3d3085a7b163966a8fd8098a90640953ce5f6170161"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "libm"
version = "0.2.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ec2a862134d2a7d32d7983ddcdd1c4923530833c9f2ea1a44fc5fa473989058"

[[package]]
name = "libredox"
version = "0.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3af92c55d7d839293953fcd0fda5ecfe93297cfde6ffbdec13b41d99c0ba6607"
dependencies = [
 "bitflags 2.4.1",
 "libc",
 "redox_syscall 0.4.1",
]

[[package]]
name = "libudev-sys"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c8469b4a23b962c1396b9b451dda50ef5b283e8dd309d69033475fa9b334324"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "lock_api"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "longest-increasing-subsequence"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3bd0dd2cd90571056fdb71f6275fada10131182f84899f4b2a916e565d81d86"

[[package]]
name = "mach2"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b955cdeb2a02b9117f121ce63aa52d08ade45de53e48fe6a38b39c10f6f709"
dependencies = [
 "libc",
]

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "matrixmultiply"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7574c1cf36da4798ab73da5b215bbf444f50718207754cb522201d78d1cd0ff2"
dependencies = [
 "autocfg",
 "rawpointer",
]

[[package]]
name = "memchr"
version = "2.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f665ee40bc4a3c5590afb1e9677db74a508659dfd71e126420da8274909a0167"

[[package]]
name = "metal"
version = "0.26.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "623b5e6cefd76e58f774bd3cc0c6f5c7615c58c03a97815245a25c3c9bdee318"
dependencies = [
 "bitflags 2.4.1",
 "block",
 "core-graphics-types",
 "foreign-types 0.5.0",
 "log",
 "objc",
 "paste",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
dependencies = [
 "adler",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "0.8.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f3d0b296e374a4e6f3c7b0a1f5a51d748a0d34c85e7dc48fc3fa9a87657fe09"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "naga"
version = "0.13.0"
source = "git+https://github.com/Patryk27/naga?branch=v0.13.0-strolle#5e407241607075930534c970866b6e0a1d3fdb8e"
dependencies = [
 "bit-set",
 "bitflags 2.4.1",
 "codespan-reporting",
 "hexf-parse",
 "indexmap 1.9.3",
 "log",
 "num-traits",
 "petgraph",
 "pp-rs",
 "rustc-hash",
 "spirv 0.2.0+1.5.4",
 "termcolor",
 "thiserror",
 "unicode-xid",
]

[[package]]
name = "naga_oil"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ac54c77b3529887f9668d3dd81e955e58f252b31a333f836e3548c06460b958"
dependencies = [
 "bit-set",
 "codespan-reporting",
 "data-encoding",
 "indexmap 1.9.3",
 "naga",
 "once_cell",
 "regex",
 "regex-syntax 0.7.5",
 "rustc-hash",
 "thiserror",
 "tracing",
 "unicode-ident",
]

[[package]]
name = "nalgebra"
version = "0.32.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "307ed9b18cc2423f29e83f84fd23a8e73628727990181f18641a8b5dc2ab1caa"
dependencies = [
 "approx",
 "glam",
 "matrixmultiply",
 "nalgebra-macros",
 "num-complex",
 "num-rational",
 "num-traits",
 "simba",
 "typenum",
]

[[package]]
name = "nalgebra-macros"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91761aed67d03ad966ef783ae962ef9bbaca728d2dd7ceb7939ec110fffad998"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "ndk"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "451422b7e4718271c8b5b3aadf5adedba43dc76312454b387e98fae0fc951aa0"
dependencies = [
 "bitflags 1.3.2",
 "jni-sys",
 "ndk-sys",
 "num_enum 0.5.11",
 "raw-window-handle",
 "thiserror",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.4.1+23.1.7779620"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3cf2aae958bd232cac5069850591667ad422d263686d75b52a065f9badeee5a3"
dependencies = [
 "jni-sys",
]

[[package]]
name = "nix"
version = "0.24.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
]

[[package]]
name = "nix"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2eb04e9c688eff1c89d72b407f168cf79bb9e867a9d3323ed6c01519eb9cc053"
dependencies = [
 "bitflags 2.4.1",
 "cfg-if",
 "libc",
]

[[package]]
name = "nohash-hasher"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451"

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nonmax"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "610a5acd306ec67f907abe5567859a3c693fb9886eb1f012ab8f2a47bef3db51"

[[package]]
name = "ntapi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a3895c6391c39d7fe7ebc444a87eb2991b2a0bc718fdabd071eec617fc68e4"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4a28e057d01f97e61255210fcff094d74ed0466038633e95017f5beb68e4399"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "num-complex"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ba157ca0885411de85d6ca030ba7e2a83a28636056c7c699b07c8b6f7383214"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-derive"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "876a53fff98e03a936a674b29568b0e605f06b29372c2489ff4de23f1949743d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num-integer"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "225d3389fb3509a24c93f5c29eb6bde2586b98d9f016636dff58d7c6f7569cd9"
dependencies = [
 "autocfg",
 "num-traits",
]

[[package]]
name = "num-rational"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0638a1c9d0a3c0914158145bc76cff373a75a627e6ecbfb71cbe6f453a5a19b0"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39e3200413f237f41ab11ad6d161bc7239c84dcb631773ccd7de3dfe4b5c267c"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_enum"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
dependencies = [
 "num_enum_derive 0.5.11",
]

[[package]]
name = "num_enum"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a015b430d3c108a207fd776d2e2196aaf8b1cf8cf93253e3a097ff3085076a1"
dependencies = [
 "num_enum_derive 0.6.1",
]

[[package]]
name = "num_enum_derive"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "num_enum_derive"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96667db765a921f7b295ffee8b60472b686a51d4f21c2ee4ffdb94c7013b65a6"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
 "objc_exception",
]

[[package]]
name = "objc-foundation"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1add1b659e36c9607c7aab864a76c7a4c2760cd0cd2e120f3fb8b952c7e22bf9"
dependencies = [
 "block",
 "objc",
 "objc_id",
]

[[package]]
name = "objc-sys"
version = "0.2.0-beta.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b9834c1e95694a05a828b59f55fa2afec6288359cda67146126b3f90a55d7"

[[package]]
name = "objc2"
version = "0.3.0-beta.3.patch-leaks.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e01640f9f2cb1220bbe80325e179e532cb3379ebcd1bf2279d703c19fe3a468"
dependencies = [
 "block2",
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2-encode"
version = "2.0.0-pre.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abfcac41015b00a120608fdaa6938c44cb983fee294351cc4bac7638b4e50512"
dependencies = [
 "objc-sys",
]

[[package]]
name = "objc_exception"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad970fb455818ad6cba4c122ad012fae53ae8b4795f86378bce65e4f6bab2ca4"
dependencies = [
 "cc",
]

[[package]]
name = "objc_id"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c92d4ddb4bd7b50d730c215ff871754d0da6b2178849f8a2a2ab69712d0c073b"
dependencies = [
 "objc",
]

[[package]]
name = "object"
version = "0.32.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6a622008b6e321afc04970976f62ee297fdbaa6f95318ca343e3eebb9648441"
dependencies = [
 "memchr",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "crc32fast",
 "flate2",
 "hashbrown 0.15.2",
 "indexmap 2.9.0",
 "memchr",
 "ruzstd 0.7.3",
 "wasmparser",
]

[[package]]
name = "oboe"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8868cc237ee02e2d9618539a23a8d228b9bb3fc2e7a5b11eed3831de77c395d0"
dependencies = [
 "jni 0.20.0",
 "ndk",
 "ndk-context",
 "num-derive",
 "num-traits",
 "oboe-sys",
]

[[package]]
name = "oboe-sys"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f44155e7fb718d3cfddcf70690b2b51ac4412f347cd9e4fbe511abe9cd7b5f2"
dependencies = [
 "cc",
]

[[package]]
name = "ogg"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6951b4e8bf21c8193da321bcce9c9dd2e13c858fe078bf9054a288b419ae5d6e"
dependencies = [
 "byteorder",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "orbclient"
version = "0.3.47"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52f0d54bde9774d3a51dcf281a5def240c71996bc6ca05d2c847ec8b2b216166"
dependencies = [
 "libredox",
]

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "owned_ttf_parser"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4586edfe4c648c71797a74c84bacb32b52b212eff5dfe2bb9f2c599844023e7"
dependencies = [
 "ttf-parser",
]

[[package]]
name = "parking"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb813b8af86854136c6922af0598d719255ecb2179515e6e7730d468f05c9cae"

[[package]]
name = "parking_lot"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c42a9226546d68acdd9c0a280d17ce19bfe27a46bf68784e4066115788d008e"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.4.1",
 "smallvec",
 "windows-targets 0.48.5",
]

[[package]]
name = "parry3d"
version = "0.13.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b55dc0e6db79bddbc5fd583569f7356cdcc63e1e9b2b93a9ab70dd8e717160e0"
dependencies = [
 "approx",
 "arrayvec",
 "bitflags 1.3.2",
 "downcast-rs",
 "either",
 "nalgebra",
 "num-derive",
 "num-traits",
 "rustc-hash",
 "simba",
 "slab",
 "smallvec",
 "spade",
]

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "peeking_take_while"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "petgraph"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1d3afd2628e69da2be385eb6f2fd57c8ac7977ceeff6dc166ff1657b0e386a9"
dependencies = [
 "fixedbitset",
 "indexmap 2.9.0",
]

[[package]]
name = "pin-project-lite"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8afb450f006bf6385ca15ef45d71d2288452bc3683ce2e2cacc0d18e4be60b58"

[[package]]
name = "piper"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "668d31b1c4eba19242f2088b2bf3316b82ca31082a8335764db4e083db7485d4"
dependencies = [
 "atomic-waker",
 "fastrand 2.0.1",
 "futures-io",
]

[[package]]
name = "pkg-config"
version = "0.3.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69d3587f8a9e599cc7ec2c00e331f71c4e69a5f9a4b8a6efd5b07466b9736f9a"

[[package]]
name = "png"
version = "0.17.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd75bf2d8dd3702b9707cdbc56a5b9ef42cec752eb8b3bafc01234558442aa64"
dependencies = [
 "bitflags 1.3.2",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "pp-rs"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb458bb7f6e250e6eb79d5026badc10a3ebb8f9a15d1fff0f13d17c71f4d6dee"
dependencies = [
 "unicode-xid",
]

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit 0.19.15",
]

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "profiling"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d135ede8821cf6376eb7a64148901e1690b788c11ae94dc297ae917dbc91dc0e"

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radsort"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17fd96390ed3feda12e1dfe2645ed587e0bea749e319333f104a33ff62f77a0b"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "range-alloc"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8a99fddc9f0ba0a85884b8d14e3592853e787d581ca1816c91349b10e4eeab"

[[package]]
name = "rapier3d"
version = "0.17.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62a8a0bd9d3135f7b4eb45d0796540e7bab47b6b7c974f90567ccc5a0454f42b"
dependencies = [
 "approx",
 "arrayvec",
 "bit-vec",
 "bitflags 1.3.2",
 "crossbeam",
 "downcast-rs",
 "nalgebra",
 "num-derive",
 "num-traits",
 "parry3d",
 "rustc-hash",
 "simba",
]

[[package]]
name = "raw-string"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0501e134c6905fee1f10fed25b0a7e1261bf676cffac9543a7d0730dec01af2"

[[package]]
name = "raw-window-handle"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2ff9a1f06a88b01621b7ae906ef0211290d1c8a168a15542486a8f61c0833b9"

[[package]]
name = "rawpointer"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a357793950651c4ed0f3f52338f53b2f809f32d83a07f72909fa13e4c6c1e3"

[[package]]
name = "rectangle-pack"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0d463f2884048e7153449a55166f91028d5b0ea53c79377099ce4e8cf0cf9bb"

[[package]]
name = "redox_syscall"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "regex"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "380b951a9c5e80ddfd6136919eef32310721aa4aacd4889a8d39124b026ab343"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.3",
 "regex-syntax 0.8.2",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f804c7828047e88b2d32e2d7fe5a105da8ee3264f01902f796c8e067dc2483f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.2",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbb5fb1acd8a1a18b3dd5be62d25485eb770e05afb408a9627d14d451bae12da"

[[package]]
name = "regex-syntax"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"

[[package]]
name = "renderdoc-sys"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "216080ab382b992234dda86873c18d4c48358f5cfcb70fd693d7f6f2131b628b"

[[package]]
name = "robust"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbf4a6aa5f6d6888f39e980649f3ad6b666acdce1d78e95b8a2cb076e687ae30"

[[package]]
name = "rodio"
version = "0.17.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b1bb7b48ee48471f55da122c0044fcc7600cfcc85db88240b89cb832935e611"
dependencies = [
 "cpal",
 "lewton",
]

[[package]]
name = "ron"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
dependencies = [
 "base64 0.21.5",
 "bitflags 2.4.1",
 "serde",
 "serde_derive",
]

[[package]]
name = "rspirv"
version = "0.12.0+sdk-1.3.268.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cf3a93856b6e5946537278df0d3075596371b1950ccff012f02b0f7eafec8d"
dependencies = [
 "rustc-hash",
 "spirv 0.3.0+sdk-1.3.268.0",
]

[[package]]
name = "rustc-demangle"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc_codegen_spirv"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"
dependencies = [
 "ahash",
 "ar",
 "bytemuck",
 "either",
 "indexmap 2.9.0",
 "itertools",
 "lazy_static",
 "libc",
 "log",
 "object 0.36.7",
 "regex",
 "rspirv",
 "rustc-demangle",
 "rustc_codegen_spirv-types",
 "rustix",
 "sanitize-filename",
 "smallvec",
 "spirt",
 "spirv-tools",
 "thorin-dwp",
 "tracing",
 "tracing-subscriber",
 "tracing-tree",
]

[[package]]
name = "rustc_codegen_spirv-types"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"
dependencies = [
 "rspirv",
 "serde",
 "serde_json",
]

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.4.1",
 "errno",
 "itoa",
 "libc",
 "linux-raw-sys",
 "once_cell",
 "windows-sys 0.52.0",
]

[[package]]
name = "ruzstd"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3ffab8f9715a0d455df4bbb9d21e91135aab3cd3ca187af0cd0c3c3f868fdc"
dependencies = [
 "byteorder",
 "thiserror-core",
 "twox-hash",
]

[[package]]
name = "ruzstd"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fad02996bfc73da3e301efe90b1837be9ed8f4a462b6ed410aa35d00381de89f"
dependencies = [
 "twox-hash",
]

[[package]]
name = "ryu"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f98d2aa92eebf49b69786be48e4477826b256916e84a57ff2a4f21923b48eb4c"

[[package]]
name = "safe_arch"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f398075ce1e6a179b46f51bd88d0598b92b00d3551f1a2d4ac49e771b56ac354"
dependencies = [
 "bytemuck",
]

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "sanitize-filename"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08c502bdb638f1396509467cb0580ef3b29aa2a45c5d43e5d84928241280296c"
dependencies = [
 "lazy_static",
 "regex",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "836fa6a3e1e547f9a2c4040802ec865b5d85f4014efe00555d7090a3dcaa1090"

[[package]]
name = "serde"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25dd9975e68d0cb5aa1120c288333fc98731bd1dd12f561e468ea4728c042b89"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43576ca501357b9b071ac53cdc7da8ef0cbd9493d8df094cd821777ea6e894d3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "serde_json"
version = "1.0.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d1c7e3eac408d115102c4c24ad393e0821bb3a5df4d506a80f85f7a742a526b"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7cee0529a6d40f580e7a5e6c495c8fbfe21b7b52795ed4bb5e62cdf92bc6380"

[[package]]
name = "simba"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "061507c94fc6ab4ba1c9a0305018408e312e17c041eb63bef8aa726fa33aceae"
dependencies = [
 "approx",
 "num-complex",
 "num-traits",
 "paste",
 "wide",
]

[[package]]
name = "simd-adler32"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "slotmap"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbff4acf519f630b3a3ddcfaea6c06b42174d9a44bc70c620e9ed1649d58b82a"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4dccd0940a2dcdf68d092b8cbab7dc0ad8fa938bf95787e1b916b0e3d0e8e970"
dependencies = [
 "serde",
]

[[package]]
name = "smol_str"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74212e6bbe9a4352329b2f68ba3130c15a3f26fe88ff22dbdc6cdd58fa85e99c"
dependencies = [
 "serde",
]

[[package]]
name = "smooth-bevy-cameras"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab83c7205ed16b559adac38c50f4a1caf751889165d8955ab1be33e7a4ff747f"
dependencies = [
 "approx",
 "bevy",
]

[[package]]
name = "spade"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "874799535a5ac50b123ec82e2e8015340fbebb6f71dc009ec0d4a6601fde16a4"
dependencies = [
 "hashbrown 0.14.3",
 "num-traits",
 "robust",
 "smallvec",
]

[[package]]
name = "spirt"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2d5968bd2a36466468aac637b355776f080edfb0c6f769b2b99b9708260c42a"
dependencies = [
 "arrayvec",
 "bytemuck",
 "derive_more",
 "elsa",
 "indexmap 2.9.0",
 "internal-iterator",
 "itertools",
 "lazy_static",
 "longest-increasing-subsequence",
 "rustc-hash",
 "serde",
 "serde_json",
 "smallvec",
]

[[package]]
name = "spirv"
version = "0.2.0+1.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "246bfa38fe3db3f1dfc8ca5a2cdeb7348c78be2112740cc0ec8ef18b6d94f830"
dependencies = [
 "bitflags 1.3.2",
 "num-traits",
]

[[package]]
name = "spirv"
version = "0.3.0+sdk-1.3.268.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eda41003dc44290527a59b13432d4a0379379fa074b70174882adfbdfd917844"
dependencies = [
 "bitflags 2.4.1",
]

[[package]]
name = "spirv-builder"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"
dependencies = [
 "memchr",
 "raw-string",
 "rustc_codegen_spirv",
 "rustc_codegen_spirv-types",
 "serde",
 "serde_json",
]

[[package]]
name = "spirv-std"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"
dependencies = [
 "bitflags 1.3.2",
 "glam",
 "num-traits",
 "spirv-std-macros",
 "spirv-std-types",
]

[[package]]
name = "spirv-std-macros"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"
dependencies = [
 "proc-macro2",
 "quote",
 "spirv-std-types",
 "syn 2.0.100",
]

[[package]]
name = "spirv-std-types"
version = "0.9.0"
source = "git+https://github.com/Rust-GPU/rust-gpu#6bbbfe460e45b7ca09b1a91fa6f6be7be2669bef"

[[package]]
name = "spirv-tools"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "191e2df260dbaa79c5c334fb9e7b2d5372300d765f5b950c2b54f89d412db5e7"
dependencies = [
 "spirv-tools-sys",
]

[[package]]
name = "spirv-tools-sys"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed89e04a14352154c6aca979f603bf8b59e16dafcf5e6c5f06e786b76c7daaf3"
dependencies = [
 "cc",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strolle"
version = "0.1.0"
dependencies = [
 "bytemuck",
 "derivative",
 "fxhash",
 "glam",
 "guillotiere",
 "humantime",
 "image",
 "log",
 "rand",
 "spirv-std",
 "strolle-gpu",
 "strolle-shaders",
 "wgpu",
]

[[package]]
name = "strolle-gpu"
version = "0.1.0"
dependencies = [
 "approx",
 "bytemuck",
 "glam",
 "spirv-std",
]

[[package]]
name = "strolle-shader-builder"
version = "0.1.0"
dependencies = [
 "spirv-builder",
]

[[package]]
name = "strolle-shaders"
version = "0.1.0"
dependencies = [
 "spirv-std",
 "strolle-gpu",
]

[[package]]
name = "svg_fmt"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fb1df15f412ee2e9dfc1c504260fa695c1c3f10fe9f4a6ee2d2184d7d6450e2"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sysinfo"
version = "0.29.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd727fc423c2060f6c92d9534cef765c65a6ed3f428a03d7def74a8c4348e666"
dependencies = [
 "cfg-if",
 "core-foundation-sys",
 "libc",
 "ntapi",
 "once_cell",
 "winapi",
]

[[package]]
name = "taffy"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c2287b6d7f721ada4cddf61ade5e760b2c6207df041cac9bfaa192897362fd3"
dependencies = [
 "arrayvec",
 "grid",
 "num-traits",
 "slotmap",
]

[[package]]
name = "termcolor"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff1bc3d3f05aff0403e8ac0d92ced918ec05b666a43f83297ccef5bea8a3d449"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.52"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83a48fd946b02c0a526b2e9481c8e2a17755e47039164a86c4070446e3a4614d"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-core"
version = "1.0.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c001ee18b7e5e3f62cbf58c7fe220119e68d902bb7443179c0c8aef30090e999"
dependencies = [
 "thiserror-core-impl",
]

[[package]]
name = "thiserror-core-impl"
version = "1.0.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4c60d69f36615a077cc7663b9cb8e42275722d23e58a7fa3d2c7f2915d09d04"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "thiserror-impl"
version = "1.0.52"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7fbe9b594d6568a6a1443250a7e67d80b74e1e96f6d1715e1e21cc1888291d3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "thorin-dwp"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "813ba76597db32dc4f6992fd8bf8f394715b88d352fd97401da67dab6283b4c6"
dependencies = [
 "gimli 0.30.0",
 "hashbrown 0.14.3",
 "object 0.36.7",
 "tracing",
]

[[package]]
name = "thread_local"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
dependencies = [
 "cfg-if",
 "once_cell",
]

[[package]]
name = "tiff"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba1310fcea54c6a9a4fd1aad794ecc02c31682f6bfbecdf460bf19533eed1e3e"
dependencies = [
 "flate2",
 "jpeg-decoder",
 "weezl",
]

[[package]]
name = "tinyvec"
version = "1.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "toml_datetime"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3550f4e9685620ac18a50ed434eb3aec30db8ba93b0287467bca5826ea25baf1"

[[package]]
name = "toml_edit"
version = "0.19.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
dependencies = [
 "indexmap 2.9.0",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "toml_edit"
version = "0.20.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70f427fce4d84c72b5b732388bf4a9f4531b53f74e2887e3ecb2481f68f66d81"
dependencies = [
 "indexmap 2.9.0",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tracing"
version = "0.1.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3523ab5a71916ccf420eebdf5521fcef02141234bbc0b8a49f2fdc4544364ef"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34704c8d6ebcbc939824180af020566b01a7c01f80641264eba0999f6c2b6be7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "tracing-core"
version = "0.1.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f751112709b4e791d8ce53e32c4ed2d353565a795ce84da2285393f41557bdf2"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-serde"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc6b213177105856957181934e4920de57730fc69bf42c37ee5bb664d406d9e1"
dependencies = [
 "serde",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad0f048c97dbd9faa9b7df56362b8ebcaa52adb06b498c050d2f4e32f90a7a8b"
dependencies = [
 "matchers",
 "nu-ansi-term 0.46.0",
 "once_cell",
 "regex",
 "serde",
 "serde_json",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log 0.2.0",
 "tracing-serde",
]

[[package]]
name = "tracing-tree"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b56c62d2c80033cb36fae448730a2f2ef99410fe3ecbffc916681a32f6807dbe"
dependencies = [
 "nu-ansi-term 0.50.1",
 "tracing-core",
 "tracing-log 0.2.0",
 "tracing-subscriber",
]

[[package]]
name = "tracing-wasm"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4575c663a174420fa2d78f4108ff68f65bf2fbb7dd89f33749b6e826b3626e07"
dependencies = [
 "tracing",
 "tracing-subscriber",
 "wasm-bindgen",
]

[[package]]
name = "ttf-parser"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17f77d76d837a7830fe1d4f12b7b4ba4192c1888001c7164257e4bc6d21d96b4"

[[package]]
name = "twox-hash"
version = "1.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675"
dependencies = [
 "cfg-if",
 "static_assertions",
]

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "unicode-bidi"
version = "0.3.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-normalization"
version = "0.1.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-width"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e51733f11c9c4f72aa0c160008246859e340b00807569a0da0e7a1079b27ba85"

[[package]]
name = "unicode-xid"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"

[[package]]
name = "url"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31e6302e3bb753d46e83516cae55ae196fc0c309407cf11ab35cc51a4c2a4633"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "uuid"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e395fcf16a7a3d8127ec99782007af141946b4795001f876d54fb0d55978560"
dependencies = [
 "getrandom",
 "serde",
]

[[package]]
name = "valuable"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "waker-fn"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3c4517f54858c779bbcbf228f4fca63d121bf85fbecb2dc578cdf4a39395690"

[[package]]
name = "walkdir"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71d857dc86794ca4c280d616f7da00d2dbfd8cd788846559a6813e6aa4b54ee"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ed0d4f68a3015cc185aff4db9506a015f4b96f95303897bfa23f846db54064e"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b56f625e64f3a1084ded111c4d5f477df9f8c92df113852fa5a374dbda78826"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.100",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac36a15a220124ac510204aec1c3e5db8a22ab06fd6706d881dc6149f8ed9a12"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0162dbf37223cd2afce98f3d0785506dcb8d266223983e4b5b525859e6e182b2"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0eb82fcb7930ae6219a7ecfd55b217f5f0893484b7a13022ebb2b2bf20b5283"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ab9b36309365056cd639da3134bf87fa8f3d86008abf99e612384a6eecd459f"

[[package]]
name = "wasmparser"
version = "0.222.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa210fd1788e6b37a1d1930f3389c48e1d6ebd1a013d34fa4b7f9e3e3bf03146"
dependencies = [
 "bitflags 2.4.1",
]

[[package]]
name = "wayland-scanner"
version = "0.29.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
dependencies = [
 "proc-macro2",
 "quote",
 "xml-rs",
]

[[package]]
name = "web-sys"
version = "0.3.66"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50c24a44ec86bb68fbecd1b3efed7e85ea5621b39b35ef2766b66cd984f8010f"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webbrowser"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b2391658b02c27719fc5a0a73d6e696285138e8b12fba9d4baa70451023c71"
dependencies = [
 "core-foundation",
 "home",
 "jni 0.21.1",
 "log",
 "ndk-context",
 "objc",
 "raw-window-handle",
 "url",
 "web-sys",
]

[[package]]
name = "weezl"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53a85b86a771b1c87058196170769dd264f66c0782acf1ae6cc51bfd64b39082"

[[package]]
name = "wgpu"
version = "0.17.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "752e44d3998ef35f71830dd1ad3da513e628e2e4d4aedb0ab580f850827a0b41"
dependencies = [
 "arrayvec",
 "cfg-if",
 "js-sys",
 "log",
 "naga",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "smallvec",
 "static_assertions",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "wgpu-core",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-core"
version = "0.17.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0f8a44dd301a30ceeed3c27d8c0090433d3da04d7b2a4042738095a424d12ae7"
dependencies = [
 "arrayvec",
 "bit-vec",
 "bitflags 2.4.1",
 "codespan-reporting",
 "log",
 "naga",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "rustc-hash",
 "smallvec",
 "thiserror",
 "web-sys",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-hal"
version = "0.17.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a80bf0e3c77399bb52850cb0830af9bad073d5cfcb9dd8253bef8125c42db17"
dependencies = [
 "android_system_properties",
 "arrayvec",
 "ash",
 "bit-set",
 "bitflags 2.4.1",
 "block",
 "core-graphics-types",
 "d3d12",
 "glow",
 "gpu-alloc",
 "gpu-allocator",
 "gpu-descriptor",
 "hassle-rs",
 "js-sys",
 "khronos-egl",
 "libc",
 "libloading 0.8.1",
 "log",
 "metal",
 "naga",
 "objc",
 "parking_lot",
 "profiling",
 "range-alloc",
 "raw-window-handle",
 "renderdoc-sys",
 "rustc-hash",
 "smallvec",
 "thiserror",
 "wasm-bindgen",
 "web-sys",
 "wgpu-types",
 "winapi",
]

[[package]]
name = "wgpu-types"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee64d7398d0c2f9ca48922c902ef69c42d000c759f3db41e355f4a570b052b67"
dependencies = [
 "bitflags 2.4.1",
 "js-sys",
 "web-sys",
]

[[package]]
name = "wide"
version = "0.7.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c68938b57b33da363195412cfc5fc37c9ed49aa9cfe2156fde64b8d2c9498242"
dependencies = [
 "bytemuck",
 "safe_arch",
]

[[package]]
name = "widestring"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "653f141f39ec16bba3c5abe400a0c60da7468261cc2cbf36805022876bc721a8"

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f29e6f9198ba0d26b4c9f07dbe6f9ed633e1f3d5b8b414090084349e46a52596"
dependencies = [
 "winapi",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.44.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e745dab35a0c4c77aa3ce42d595e13d2003d6902d6b08c9ef5fc326d08da12b"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-targets 0.48.5",
]

[[package]]
name = "windows"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e48a53791691ab099e5e2ad123536d0fff50652600abaf43bbf952894110d0be"
dependencies = [
 "windows-core",
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-implement"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e2ee588991b9e7e6c8338edf3333fbe4da35dc72092643958ebb43f0ab2c49c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-interface"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6fb8df20c9bcaa8ad6ab513f7b40104840c8867d5751126e4df3b08388d0cc7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a18201040b24831fbb9e4eb208f8892e1f50a37feb53cc7ff887feb8f50e7cd"
dependencies = [
 "windows_aarch64_gnullvm 0.52.0",
 "windows_aarch64_msvc 0.52.0",
 "windows_i686_gnu 0.52.0",
 "windows_i686_msvc 0.52.0",
 "windows_x86_64_gnu 0.52.0",
 "windows_x86_64_gnullvm 0.52.0",
 "windows_x86_64_msvc 0.52.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7764e35d4db8a7921e09562a0304bf2f93e0a51bfccee0bd0bb0b666b015ea"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbaa0368d4f1d2aaefc55b6fcfee13f41544ddf36801e793edbbfd7d7df075ef"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a28637cb1fa3560a16915793afb20081aba2c92ee8af57b4d5f28e4b3e7df313"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffe5e8e31046ce6230cc7215707b816e339ff4d4d67c65dffa206fd0f7aa7b9a"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6fa32db2bc4a2f5abeacf2b69f7992cd09dca97498da74a151a3132c26befd"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a657e1e9d3f514745a572a6846d3c7aa7dbe1658c056ed9c3344c4109a6949e"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dff9641d1cd4be8d1a070daf9e3773c5f67e78b4d9d42263020c057706765c04"

[[package]]
name = "winit"
version = "0.28.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9596d90b45384f5281384ab204224876e8e8bf7d58366d9b795ad99aa9894b94"
dependencies = [
 "android-activity",
 "bitflags 1.3.2",
 "cfg_aliases",
 "core-foundation",
 "core-graphics 0.22.3",
 "dispatch",
 "instant",
 "libc",
 "log",
 "mio",
 "ndk",
 "objc2",
 "once_cell",
 "orbclient",
 "percent-encoding",
 "raw-window-handle",
 "redox_syscall 0.3.5",
 "wasm-bindgen",
 "wayland-scanner",
 "web-sys",
 "windows-sys 0.45.0",
 "x11-dl",
]

[[package]]
name = "winnow"
version = "0.5.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97a4882e6b134d6c28953a387571f1acdd3496830d5e36c5e3a1075580ea641c"
dependencies = [
 "memchr",
]

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "x11rb"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8f25ead8c7e4cba123243a6367da5d3990e0d3affa708ea19dce96356bd9f1a"
dependencies = [
 "gethostname",
 "rustix",
 "x11rb-protocol",
]

[[package]]
name = "x11rb-protocol"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e63e71c4b8bd9ffec2c963173a4dc4cbde9ee96961d4fcb4429db9929b606c34"

[[package]]
name = "xi-unicode"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a67300977d3dc3f8034dae89778f502b6ba20b269527b3223ba59c0cf393bb8a"

[[package]]
name = "xml-rs"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fcb9cbac069e033553e8bb871be2fbdffcab578eb25bd0f7c508cedc6dcd75a"

[[package]]
name = "zerocopy"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74d4d3961e53fa4c9a25a8637fc2bfaf2595b3d3ae34875568a5cf64787716be"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce1b18ccd8e73a9321186f97e46f9f04b778851177567b1975109d26a08d2a6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.100",
]

[[package]]
name = "zip"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "760394e246e4c28189f19d488c058bf16f564016aefac5d32bb1f3b51d5e9261"
dependencies = [
 "byteorder",
 "crc32fast",
 "crossbeam-utils",
 "flate2",
]

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"

members = [
    "bevy-strolle",
    "strolle",
    "strolle-gpu",
    "strolle-shader-builder",
    "strolle-shaders",
]

[workspace.lints.rust]
unexpected_cfgs = { level = "allow", check-cfg = ['cfg(target_arch, values("spirv"))'] }

[workspace.dependencies]
bevy = "0.12.1"
bevy_egui = "0.24"
bevy_mod_raycast = "0.16.0"
bevy_rapier3d = "0.23.0"
bytemuck = "1.13.1"
derivative = "2.2.0"
fxhash = "0.2.1"
glam = { version = "0.24", default-features = false }
guillotiere = "0.6.2"
humantime = "2.1.0"
image = { version = "0.24.6", default-features = false }
log = "0.4.18"
rand = "0.8.5"
smooth-bevy-cameras = "0.10.0"
spirv-builder = { git = "https://github.com/Rust-GPU/rust-gpu" }
spirv-std = { git = "https://github.com/Rust-GPU/rust-gpu" }
wgpu = "0.17.2"
zip = { version = "0.6.6", default-features = false }

[patch."crates-io"]
# TODO https://github.com/gfx-rs/naga/issues/2373
naga = { git = "https://github.com/Patryk27/naga", branch = "v0.13.0-strolle" }

```

`Justfile`:

```
run:
    cargo run --release --example demo

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Patryk Wychowaniec & Jakub Trąd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Strolle

Strolle (from _strålspårning_) is a real-time renderer with support for dynamic
global illumination:

<p align="center">
  <img height="512" src="_readme/demo-v11.jpg" />
</p>

Strolle's goal is to experiment with modern real-time lighting techniques such
as ReSTIR and see how far we can go on consumer hardware, especially the one
_without_ dedicated ray-tracing cores.

Strolle comes integrated with [Bevy](https://bevyengine.org/), but can be also
used on its own (through `wgpu`).

Status: Abandoned, I've moved on to other things; feel free to fork and/or ping
me if you're interested in details as to how this engine works.

* [Gallery](#gallery)
* [Examples](#examples)
* [Usage](#usage)
* [Roadmap](#roadmap)

## Gallery

<p align="center">
  <img height="512" src="_readme/demo-v9.jpg" />
</p>

<p align="center">
  <img height="512" src="_readme/demo-v16.jpg" />
</p>

<p align="center">
  <img height="512" src="_readme/demo-v17.jpg" />
</p>

(note that currently there's no denoiser for specular lighting)

## Examples

### Dungeon

``` shell
$ cargo run --release --example demo
```

Shows a dungeon tech demo, as in the example above.

Use WASD to move, mouse to navigate the camera, and:

- H/L: Adjust sun's azimuth,
- J/K: Adjust sun's altitude,
- F: Toggle flashlight on/off,
- M: Toggle diffuse/specular materials,
- T: Remove textures,
- 1: Show the final, composed image¹ (default),
- 2: Show direct-diffuse lighting only¹,
- 3: Show direct-specular lighting only¹,
- 4: Show indirect-diffuse lighting only¹,
- 5: Show indirect-specular lighting only¹,
- 8: Show BVH heatmap,
- 9: Switch camera to a path-traced reference mode (slow),
- 0: Switch camera to Bevy's renderer,
- ;: Toggle camera's controls on/off - useful for taking screenshots.

¹ press the same key again to toggle denoising on/off

Model thanks to:    
https://sketchfab.com/3d-models/low-poly-game-level-82b7a937ae504cfa9f277d9bf6874ad2

### Cornell Box

``` shell
$ cargo run --release --example cornell
```

## Usage

### Bevy

Currently supported Bevy version: 0.12.1.

1. Add Strolle to your dependencies:

    ``` toml
    [dependencies]
    bevy_strolle = { git = "https://github.com/patryk27/strolle" }
    ```

2. Add a patch to work-around [a bug in Naga](https://github.com/gfx-rs/naga/issues/2373):

    ``` toml
    [patch."crates-io"]
    naga = { git = "https://github.com/Patryk27/naga", branch = "v0.13.0-strolle" }
    ```

3. Setup & enjoy!

    ```rust
    App::new()
        /* ... */
        .add_plugins(StrollePlugin);

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                hdr: true,
                ..default()
            },
            ..default()
        });
    ```

Note that Strolle completely overrides Bevy's camera graph, so you can't use a
Strolle camera together with Bevy's effects such as bloom or TAA - fragment and
vertex shaders won't work as well.

Also, Strolle is not optimized well towards higher resolutions - on non-high-end
GPUs, it's recommended to stick to ~800x600 and upscale the camera instead (see
the `demo.rs` here).

## Roadmap

https://github.com/Patryk27/strolle/issues?q=is%3Aissue+is%3Aopen+label%3AC-bug%2CC-feature

## Algorithms

Notable algorithms implemented in Strolle include:

- [ReSTIR DI](https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf)
- [ReSTIR GI](https://d1qx31qr3h6wln.cloudfront.net/publications/ReSTIR%20GI.pdf)
- [SVGF](https://research.nvidia.com/publication/2017-07_spatiotemporal-variance-guided-filtering-real-time-reconstruction-path-traced)
- [A Scalable and Production Ready Sky and Atmosphere Rendering Technique](https://sebh.github.io/publications/egsr2020.pdf)

## License

MIT License

Copyright (c) 2022 Patryk Wychowaniec & Jakub Trąd

```

`bevy-strolle/Cargo.toml`:

```toml
[package]
name = "bevy-strolle"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy.workspace = true
bevy_egui.workspace = true
log.workspace = true
strolle = { path = "../strolle", features = ["metrics"] }
wgpu.workspace = true

[dev-dependencies]
bevy = { workspace = true, features = ["jpeg"] }
bevy_mod_raycast.workspace = true
bevy_rapier3d.workspace = true
smooth-bevy-cameras.workspace = true
zip = { workspace = true, default-features = false, features = ["deflate"] }

```

`bevy-strolle/examples/_common.rs`:

```rs
//! This file is not an example - it just contains common code used by some of
//! the examples.

#![allow(dead_code)]

use std::env;
use std::fs::File;
use std::io::BufReader;
use std::path::Path;

use bevy::prelude::*;
use bevy::render::camera::CameraRenderGraph;
use bevy::window::{CursorGrabMode, PrimaryWindow};
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::fps::FpsCameraController;
use zip::ZipArchive;

pub fn extract_assets() {
    extract_asset("cornell");
    extract_asset("demo");
}

fn extract_asset(name: &str) {
    let dir = env::var("CARGO_MANIFEST_DIR")
        .expect("Please use `cargo` to run the examples");

    let dir = Path::new(&dir).join("assets");

    if dir.join(name).with_extension("obj").exists() {
        return;
    }

    let archive = dir.join(name).with_extension("zip");

    let archive = File::open(archive)
        .unwrap_or_else(|err| panic!("couldn't open asset {}: {}", name, err));

    let mut archive =
        ZipArchive::new(BufReader::new(archive)).unwrap_or_else(|err| {
            panic!("couldn't open archive for asset: {}: {}", name, err)
        });

    archive.extract(&dir).unwrap_or_else(|err| {
        panic!("couldn't extract asset {}: {}", name, err)
    });
}

// -----------------------------------------------------------------------------

pub fn handle_camera(
    keys: Res<Input<KeyCode>>,
    mut window: Query<&mut Window, With<PrimaryWindow>>,
    mut camera: Query<(
        &Transform,
        &mut CameraRenderGraph,
        &mut StrolleCamera,
        &mut FpsCameraController,
    )>,
) {
    let (
        camera_xform,
        mut camera_render_graph,
        mut camera,
        mut fps_camera_controller,
    ) = camera.single_mut();

    if keys.just_pressed(KeyCode::Key1) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = match camera.mode {
            st::CameraMode::Image { denoise } => {
                st::CameraMode::Image { denoise: !denoise }
            }
            _ => st::CameraMode::Image { denoise: true },
        };
    }

    if keys.just_pressed(KeyCode::Key2) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = match camera.mode {
            st::CameraMode::DiDiffuse { denoise } => {
                st::CameraMode::DiDiffuse { denoise: !denoise }
            }
            _ => st::CameraMode::DiDiffuse { denoise: true },
        };
    }

    if keys.just_pressed(KeyCode::Key3) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = match camera.mode {
            st::CameraMode::DiSpecular { denoise } => {
                st::CameraMode::DiSpecular { denoise: !denoise }
            }
            _ => st::CameraMode::DiSpecular { denoise: true },
        };
    }

    if keys.just_pressed(KeyCode::Key4) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = match camera.mode {
            st::CameraMode::GiDiffuse { denoise } => {
                st::CameraMode::GiDiffuse { denoise: !denoise }
            }
            _ => st::CameraMode::GiDiffuse { denoise: true },
        };
    }

    if keys.just_pressed(KeyCode::Key5) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = match camera.mode {
            st::CameraMode::GiSpecular { denoise } => {
                st::CameraMode::GiSpecular { denoise: !denoise }
            }
            _ => st::CameraMode::GiSpecular { denoise: true },
        };
    }

    if keys.just_pressed(KeyCode::Key8) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = st::CameraMode::BvhHeatmap;
    }

    if keys.just_pressed(KeyCode::Key9) {
        camera_render_graph.set(bevy_strolle::graph::NAME);

        camera.mode = st::CameraMode::Reference { depth: 1 };
    }

    if keys.just_pressed(KeyCode::Key0) {
        camera_render_graph.set("core_3d");
    }

    if keys.just_pressed(KeyCode::Semicolon) {
        fps_camera_controller.enabled = !fps_camera_controller.enabled;

        let mut window = window.single_mut();

        window.cursor.visible = !fps_camera_controller.enabled;

        window.cursor.grab_mode = if fps_camera_controller.enabled {
            CursorGrabMode::Locked
        } else {
            CursorGrabMode::None
        };
    }

    if keys.just_pressed(KeyCode::X) {
        println!("{:?}", camera_xform.translation);
    }
}

// -----------------------------------------------------------------------------

#[derive(Resource)]
pub struct Sun {
    azimuth: f32,
    altitude: f32,
    initialized: bool,
}

impl Default for Sun {
    fn default() -> Self {
        Self {
            azimuth: 3.0,
            altitude: StrolleSun::default().altitude,
            initialized: false,
        }
    }
}

pub fn handle_sun(keys: Res<Input<KeyCode>>, mut sun: ResMut<Sun>) {
    if keys.just_pressed(KeyCode::H) {
        sun.azimuth -= 0.05;
    }

    if keys.just_pressed(KeyCode::J) {
        sun.altitude -= 0.05;
    }

    if keys.just_pressed(KeyCode::K) {
        sun.altitude += 0.05;
    }

    if keys.just_pressed(KeyCode::L) {
        sun.azimuth += 0.05;
    }
}

pub fn animate_sun(
    time: Res<Time>,
    mut st_sun: ResMut<StrolleSun>,
    mut sun: ResMut<Sun>,
) {
    if sun.initialized {
        st_sun.azimuth = st_sun.azimuth
            + (sun.azimuth - st_sun.azimuth) * time.delta_seconds();

        st_sun.altitude = st_sun.altitude
            + (sun.altitude - st_sun.altitude) * time.delta_seconds();
    } else {
        sun.initialized = true;
        st_sun.azimuth = sun.azimuth;
        st_sun.altitude = sun.altitude;
    }
}

```

`bevy-strolle/examples/cornell.rs`:

```rs
#[path = "_common.rs"]
mod common;

use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};
use bevy::math::vec3;
use bevy::prelude::*;
use bevy::render::camera::CameraRenderGraph;
use bevy::window::WindowResolution;
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::orbit::{
    OrbitCameraBundle, OrbitCameraController, OrbitCameraPlugin,
};
use smooth_bevy_cameras::LookTransformPlugin;

fn main() {
    common::extract_assets();

    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: WindowResolution::new(512.0, 512.0),
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin,
            LookTransformPlugin,
            OrbitCameraPlugin::default(),
            StrollePlugin,
            StrolleDebugPlugin,
        ))
        .add_systems(Startup, setup)
        .add_systems(Update, animate)
        .run();
}

fn setup(mut commands: Commands, assets: Res<AssetServer>) {
    commands.spawn(SceneBundle {
        scene: assets.load("cornell/scene.gltf#Scene0"),
        ..default()
    });

    commands.spawn(PointLightBundle {
        point_light: PointLight {
            color: Color::WHITE,
            intensity: 50.0,
            radius: 0.15,
            shadows_enabled: true,
            ..default()
        },
        ..default()
    });

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                hdr: true,
                ..default()
            },
            ..default()
        })
        .insert(OrbitCameraBundle::new(
            {
                OrbitCameraController {
                    enabled: true,
                    mouse_rotate_sensitivity: Vec2::ONE * 0.2,
                    mouse_translate_sensitivity: Vec2::ONE * 0.5,
                    ..default()
                }
            },
            vec3(0.0, 1.0, 3.2),
            vec3(0.0, 1.0, 0.0),
            vec3(0.0, 1.0, 0.0),
        ));
}

fn animate(
    time: Res<Time>,
    mut sun: ResMut<StrolleSun>,
    mut light: Query<&mut Transform, With<PointLight>>,
) {
    sun.altitude = -1.0;

    light.single_mut().translation = vec3(
        time.elapsed_seconds().sin() / 2.0,
        1.5,
        time.elapsed_seconds().cos() / 2.0,
    );
}

```

`bevy-strolle/examples/demo.rs`:

```rs
#[path = "_common.rs"]
mod common;

use std::f32::consts::PI;

use bevy::core_pipeline::clear_color::ClearColorConfig;
use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};
use bevy::math::{uvec2, vec3};
use bevy::prelude::*;
use bevy::render::camera::{CameraRenderGraph, RenderTarget};
use bevy::render::texture::ImageSampler;
use bevy::window::{CursorGrabMode, PrimaryWindow, WindowResolution};
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::fps::{
    FpsCameraBundle, FpsCameraController, FpsCameraPlugin,
};
use smooth_bevy_cameras::LookTransformPlugin;
use wgpu::{
    Extent3d, TextureDescriptor, TextureDimension, TextureFormat, TextureUsages,
};

use self::common::Sun;

const VIEWPORT_SIZE: UVec2 = uvec2(640, 480);
const WINDOW_SCALE: f32 = 1.5;

fn main() {
    common::extract_assets();

    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: WindowResolution::new(
                        WINDOW_SCALE * VIEWPORT_SIZE.x as f32,
                        WINDOW_SCALE * VIEWPORT_SIZE.y as f32,
                    ),
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin,
            LookTransformPlugin,
            FpsCameraPlugin::default(),
            StrollePlugin,
        ))
        .add_systems(Startup, setup_window)
        .add_systems(Startup, setup_camera)
        .add_systems(Startup, setup_scene)
        .add_systems(Update, adjust_materials)
        .add_systems(Update, handle_materials)
        .add_systems(Update, common::handle_camera)
        .add_systems(Update, common::handle_sun)
        .add_systems(Update, common::animate_sun)
        .add_systems(Update, handle_flashlight)
        .add_systems(Update, animate_flashlight)
        .add_systems(Update, animate_toruses)
        .insert_resource(Sun::default())
        .run();
}

fn setup_window(mut window: Query<&mut Window, With<PrimaryWindow>>) {
    let mut window = window.single_mut();

    window.cursor.visible = false;
    window.cursor.grab_mode = CursorGrabMode::Locked;
}

fn setup_camera(
    mut commands: Commands,
    mut window: Query<&Window, With<PrimaryWindow>>,
    mut images: ResMut<Assets<Image>>,
) {
    let window = window.single_mut();

    let mut viewport = Image {
        texture_descriptor: TextureDescriptor {
            label: None,
            size: Extent3d {
                width: VIEWPORT_SIZE.x,
                height: VIEWPORT_SIZE.y,
                depth_or_array_layers: 1,
            },
            dimension: TextureDimension::D2,
            format: TextureFormat::Rgba8UnormSrgb,
            mip_level_count: 1,
            sample_count: 1,
            usage: TextureUsages::TEXTURE_BINDING
                | TextureUsages::COPY_DST
                | TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        },
        sampler: ImageSampler::nearest(),
        ..default()
    };

    viewport.resize(Extent3d {
        width: VIEWPORT_SIZE.x,
        height: VIEWPORT_SIZE.y,
        depth_or_array_layers: 1,
    });

    let viewport = images.add(viewport);

    commands.spawn(SpriteBundle {
        texture: viewport.clone(),
        transform: Transform::from_scale(vec3(
            window.width() / (VIEWPORT_SIZE.x as f32),
            window.height() / (VIEWPORT_SIZE.y as f32),
            1.0,
        )),
        ..default()
    });

    commands.spawn(Camera2dBundle {
        camera: Camera {
            order: 1,
            ..default()
        },
        camera_2d: Camera2d {
            clear_color: ClearColorConfig::None,
        },
        ..default()
    });

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                order: 0,
                target: RenderTarget::Image(viewport),
                hdr: true,
                ..default()
            },
            ..default()
        })
        .insert(StrolleCamera::default())
        .insert(FpsCameraBundle::new(
            {
                FpsCameraController {
                    enabled: true,
                    mouse_rotate_sensitivity: Vec2::ONE * 0.35,
                    translate_sensitivity: 8.0,
                    ..default()
                }
            },
            vec3(-5.75, 0.5, -16.8),
            vec3(-5.75, 0.5, -17.0),
            vec3(0.0, 1.0, 0.0),
        ));
}

fn setup_scene(
    mut commands: Commands,
    assets: Res<AssetServer>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut meshes: ResMut<Assets<Mesh>>,
) {
    commands.spawn(SceneBundle {
        scene: assets.load("demo/level.glb#Scene0"),
        ..default()
    });

    // ---

    let lights = vec![
        vec3(-3.0, 0.75, -23.0),
        vec3(-23.5, 0.75, -31.0),
        vec3(1.25, 0.75, -10.5),
        vec3(-3.15, 0.75, 1.25),
        vec3(-3.25, 0.75, 20.25),
        vec3(13.25, 0.75, -28.25),
    ];

    for light in lights {
        commands.spawn(PointLightBundle {
            point_light: PointLight {
                color: Color::WHITE,
                range: 35.0,
                radius: 0.15,
                intensity: 5000.0,
                shadows_enabled: true,
                ..default()
            },
            transform: Transform::from_translation(light),
            ..default()
        });
    }

    // ---

    let toruses = [
        vec3(-0.5, 0.33, -5.5),
        vec3(-11.0, 0.33, 28.0),
        vec3(-11.5, 0.33, 13.5),
    ];

    for torus in toruses {
        let color = Color::rgba(0.9, 0.6, 0.3, 1.0);

        commands
            .spawn(MaterialMeshBundle {
                mesh: meshes.add(Mesh::from(shape::Torus::default())),
                material: materials.add(StandardMaterial {
                    base_color: color,
                    emissive: color * 10.0,
                    ..default()
                }),
                transform: Transform::from_translation(torus)
                    .with_rotation(Quat::from_rotation_z(1.0))
                    .with_scale(Vec3::splat(0.5)),
                ..default()
            })
            .insert(Torus);
    }

    // ---

    commands
        .spawn(SpotLightBundle {
            spot_light: SpotLight {
                color: Color::WHITE,
                range: 100.0,
                radius: 0.1,
                intensity: 0.0,
                shadows_enabled: true,
                inner_angle: 0.1 * PI,
                outer_angle: 0.1 * PI,
                ..default()
            },
            ..default()
        })
        .insert(Flashlight { enabled: false });
}

// -----------------------------------------------------------------------------

/// Most of materials in our demo-scene have the `unlit` flag toggled on, making
/// it look suspicious - let's fix that!
///
/// Arguably, a somewhat better approach would be to adjust the *.glb asset, but
/// doing this via code here is just simpler.
fn adjust_materials(
    mut materials_adjusted: Local<bool>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    if *materials_adjusted || materials.len() < 16 {
        return;
    }

    for (_, material) in materials.iter_mut() {
        material.unlit = false;
        material.reflectance = 0.0;
        material.perceptual_roughness = 1.0;
    }

    *materials_adjusted = true;
}

fn handle_materials(
    keys: Res<Input<KeyCode>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    if keys.just_pressed(KeyCode::T) {
        for (_, material) in materials.iter_mut() {
            material.base_color_texture = None;
        }
    }

    if keys.just_pressed(KeyCode::M) {
        for (_, material) in materials.iter_mut() {
            if material.metallic == 0.0 {
                material.metallic = 1.0;
                material.perceptual_roughness = 0.15;
            } else {
                material.metallic = 0.0;
                material.perceptual_roughness = 1.0;
            }
        }
    }
}

// -----------------------------------------------------------------------------

#[derive(Component)]
struct Flashlight {
    enabled: bool,
}

fn handle_flashlight(
    keys: Res<Input<KeyCode>>,
    mut flashlight: Query<(&mut Flashlight, &mut SpotLight)>,
    mut lights: Query<&mut PointLight>,
) {
    let (mut flashlight, mut flashlight_spot) = flashlight.single_mut();

    if keys.just_pressed(KeyCode::F) {
        flashlight.enabled = !flashlight.enabled;

        if flashlight.enabled {
            flashlight_spot.intensity = 16000.0;
        } else {
            flashlight_spot.intensity = 0.0;
        }

        for mut light in lights.iter_mut() {
            light.intensity = if flashlight.enabled { 0.0 } else { 6000.0 };
        }
    }
}

fn animate_flashlight(
    camera: Query<&Transform, With<StrolleCamera>>,
    mut flashlight: Query<
        &mut Transform,
        (With<Flashlight>, Without<StrolleCamera>),
    >,
) {
    let camera = camera.single();
    let mut flashlight = flashlight.single_mut();

    *flashlight =
        Transform::from_translation(camera.translation - vec3(0.0, 0.25, 0.0))
            .with_rotation(camera.rotation);
}

// -----------------------------------------------------------------------------

#[derive(Component)]
struct Torus;

fn animate_toruses(
    time: Res<Time>,
    mut toruses: Query<&mut Transform, (With<Torus>, Without<Flashlight>)>,
) {
    for mut xform in toruses.iter_mut() {
        xform.rotation = Quat::from_rotation_z(time.elapsed_seconds())
            * Quat::from_rotation_x(time.elapsed_seconds() + 1.0);
    }
}

```

`bevy-strolle/examples/minecraft.rs`:

```rs
#[path = "_common.rs"]
mod common;

use std::f32::consts::PI;

use bevy::core_pipeline::clear_color::ClearColorConfig;
use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};
use bevy::input::mouse::MouseWheel;
use bevy::math::{uvec2, vec2, vec3};
use bevy::prelude::*;
use bevy::render::camera::{CameraRenderGraph, RenderTarget};
use bevy::render::texture::ImageSampler;
use bevy::sprite::MaterialMesh2dBundle;
use bevy::window::{CursorGrabMode, PrimaryWindow, WindowResolution};
use bevy_mod_raycast::prelude::*;
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::fps::{
    FpsCameraBundle, FpsCameraController, FpsCameraPlugin,
};
use smooth_bevy_cameras::LookTransformPlugin;
use wgpu::{
    Extent3d, TextureDescriptor, TextureDimension, TextureFormat, TextureUsages,
};

use self::common::Sun;

const VIEWPORT_SIZE: UVec2 = uvec2(800, 600);
const WINDOW_SCALE: f32 = 1.0;

fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: WindowResolution::new(
                        WINDOW_SCALE * VIEWPORT_SIZE.x as f32,
                        WINDOW_SCALE * VIEWPORT_SIZE.y as f32,
                    ),
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin,
            LookTransformPlugin,
            FpsCameraPlugin::default(),
            StrollePlugin,
        ))
        .add_systems(Startup, setup_window)
        .add_systems(Startup, setup_camera)
        .add_systems(Startup, setup_state)
        .add_systems(Startup, setup_scene)
        // ---
        .add_systems(Update, common::handle_camera)
        .add_systems(Update, common::handle_sun)
        .add_systems(Update, common::animate_sun)
        // ---
        .add_systems(Update, process_input)
        .add_systems(Update, process_blocks.after(process_input))
        .add_systems(Update, update_crosshair.after(process_input))
        // ---
        .insert_resource(Sun::default())
        .add_event::<Event>()
        .run();
}

fn setup_window(mut window: Query<&mut Window, With<PrimaryWindow>>) {
    let mut window = window.single_mut();

    window.cursor.visible = false;
    window.cursor.grab_mode = CursorGrabMode::Confined;
}

fn setup_camera(
    mut commands: Commands,
    mut window: Query<&Window, With<PrimaryWindow>>,
    mut images: ResMut<Assets<Image>>,
) {
    let window = window.single_mut();

    let mut viewport = Image {
        texture_descriptor: TextureDescriptor {
            label: None,
            size: Extent3d {
                width: VIEWPORT_SIZE.x,
                height: VIEWPORT_SIZE.y,
                depth_or_array_layers: 1,
            },
            dimension: TextureDimension::D2,
            format: TextureFormat::Rgba8UnormSrgb,
            mip_level_count: 1,
            sample_count: 1,
            usage: TextureUsages::TEXTURE_BINDING
                | TextureUsages::COPY_DST
                | TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        },
        sampler: ImageSampler::nearest(),
        ..default()
    };

    viewport.resize(Extent3d {
        width: VIEWPORT_SIZE.x,
        height: VIEWPORT_SIZE.y,
        depth_or_array_layers: 1,
    });

    let viewport = images.add(viewport);

    commands.spawn(SpriteBundle {
        texture: viewport.clone(),
        transform: Transform::from_scale(vec3(
            window.width() / (VIEWPORT_SIZE.x as f32),
            window.height() / (VIEWPORT_SIZE.y as f32),
            1.0,
        )),
        ..default()
    });

    commands.spawn(Camera2dBundle {
        camera: Camera {
            order: 1,
            ..default()
        },
        camera_2d: Camera2d {
            clear_color: ClearColorConfig::None,
        },
        ..default()
    });

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                order: 0,
                target: RenderTarget::Image(viewport),
                hdr: true,
                ..default()
            },
            ..default()
        })
        .insert(StrolleCamera::default())
        .insert(FpsCameraBundle::new(
            {
                FpsCameraController {
                    mouse_rotate_sensitivity: Vec2::ONE * 0.35,
                    translate_sensitivity: 8.0,
                    ..default()
                }
            },
            vec3(2.0, 1.0, 2.0),
            vec3(0.0, 0.0, 0.0),
            vec3(0.0, 1.0, 0.0),
        ));
}

fn setup_state(
    mut commands: Commands,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut color_materials: ResMut<Assets<ColorMaterial>>,
    mut meshes: ResMut<Assets<Mesh>>,
) {
    let block_mesh = meshes.add(Mesh::from(shape::Cube::new(1.0)));
    let block_white_mat = materials.add(StandardMaterial::from(Color::WHITE));
    let block_red_mat = materials.add(StandardMaterial::from(Color::RED));
    let block_green_mat = materials.add(StandardMaterial::from(Color::GREEN));
    let block_blue_mat = materials.add(StandardMaterial::from(Color::BLUE));

    let torch_mesh = meshes.add(Mesh::from(shape::Cylinder {
        radius: 0.1,
        height: 0.4,
        resolution: 16,
        segments: 1,
    }));

    let torch_mat = materials.add(StandardMaterial::from(Color::YELLOW));

    let items = vec![
        Item::Block {
            mesh: block_mesh.clone(),
            material: block_white_mat.clone(),
            crosshair: Color::WHITE,
        },
        Item::Block {
            mesh: block_mesh.clone(),
            material: block_red_mat.clone(),
            crosshair: Color::RED,
        },
        Item::Block {
            mesh: block_mesh.clone(),
            material: block_green_mat.clone(),
            crosshair: Color::GREEN,
        },
        Item::Block {
            mesh: block_mesh.clone(),
            material: block_blue_mat.clone(),
            crosshair: Color::BLUE,
        },
        Item::Torch {
            mesh: torch_mesh.clone(),
            material: torch_mat.clone(),
            crosshair: Color::YELLOW,
        },
    ];

    // ---

    let crosshair_mesh = meshes.add(shape::Box::new(2.0, 16.0, 0.0).into());

    let crosshair_material =
        color_materials.add(ColorMaterial::from(Color::WHITE));

    commands.spawn(MaterialMesh2dBundle {
        mesh: crosshair_mesh.clone().into(),
        material: crosshair_material.clone(),
        transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),
        ..default()
    });

    commands.spawn(MaterialMesh2dBundle {
        mesh: crosshair_mesh.into(),
        material: crosshair_material.clone(),
        transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))
            .with_rotation(Quat::from_rotation_z(PI / 2.0)),
        ..default()
    });

    // ---

    commands.insert_resource(State {
        items,
        selected_item: 0,
        crosshair_material,
    });
}

fn setup_scene(mut events: EventWriter<Event>) {
    events.send(Event::Spawn {
        position: vec3(0.0, 0.0, 0.0),
        item: 0,
    });
}

#[allow(clippy::too_many_arguments)]
fn process_input(
    mut raycast: Raycast,
    mut state: ResMut<State>,
    mouse: Res<Input<MouseButton>>,
    mut wheel: EventReader<MouseWheel>,
    window: Query<&Window, With<PrimaryWindow>>,
    camera: Query<(&Camera, &GlobalTransform), With<StrolleCamera>>,
    objects: Query<Entity, With<Object>>,
    mut events: EventWriter<Event>,
) {
    let window = window.single();
    let (camera, camera_xform) = camera.single();

    // ---

    if mouse.just_pressed(MouseButton::Left)
        || mouse.just_pressed(MouseButton::Middle)
        || mouse.just_pressed(MouseButton::Right)
    {
        let ray = camera.viewport_to_world(
            camera_xform,
            vec2(window.width(), window.height()) / WINDOW_SCALE / 2.0,
        );

        if let Some(ray) = ray {
            let intersections = {
                let ray = Ray3d::new(ray.origin, ray.direction);
                let filter = |entity| objects.contains(entity);
                let settings = RaycastSettings::default().with_filter(&filter);

                raycast.cast_ray(ray, &settings)
            };

            if let Some((intersected, intersection)) = intersections.first() {
                let cell =
                    intersection.position() - 0.5 * intersection.normal();

                let cell = cell.round();

                if mouse.just_pressed(MouseButton::Left) {
                    events.send(Event::Destroy {
                        entity: *intersected,
                    });
                } else if mouse.just_pressed(MouseButton::Middle) {
                    events.send(Event::Destroy {
                        entity: *intersected,
                    });

                    events.send(Event::Spawn {
                        position: cell,
                        item: state.selected_item,
                    });
                } else {
                    events.send(Event::Spawn {
                        position: cell.round() + intersection.normal(),
                        item: state.selected_item,
                    });
                }
            }
        }
    }

    // ---

    for event in wheel.read() {
        if event.y < 0.0 {
            state.selected_item = state
                .selected_item
                .checked_sub(1)
                .unwrap_or_else(|| state.items.len() - 1);
        } else if event.y > 0.0 {
            state.selected_item = (state.selected_item + 1) % state.items.len();
        }
    }
}

fn process_blocks(
    state: Res<State>,
    mut commands: Commands,
    mut events: EventReader<Event>,
) {
    for block in events.read() {
        match block {
            Event::Spawn { position, item } => {
                let item = &state.items[*item];

                match item {
                    Item::Block { mesh, material, .. } => {
                        commands
                            .spawn(MaterialMeshBundle {
                                mesh: mesh.clone(),
                                material: material.clone(),
                                transform: Transform::from_translation(
                                    *position,
                                ),
                                ..default()
                            })
                            .insert(Object);
                    }

                    Item::Torch { mesh, material, .. } => {
                        commands
                            .spawn(MaterialMeshBundle {
                                mesh: mesh.clone(),
                                material: material.clone(),
                                transform: Transform::from_translation(
                                    *position - vec3(0.0, 0.3, 0.0),
                                ),
                                ..default()
                            })
                            .insert(Object)
                            .with_children(|commands| {
                                commands
                                    .spawn(PointLightBundle {
                                        point_light: PointLight {
                                            color: Color::WHITE,
                                            range: 35.0,
                                            radius: 0.1,
                                            intensity: 250.0,
                                            shadows_enabled: true,
                                            ..default()
                                        },
                                        transform: Transform::from_translation(
                                            vec3(0.0, 0.75, 0.0),
                                        ),
                                        ..default()
                                    })
                                    .insert(Object);
                            });
                    }
                }
            }

            Event::Destroy { entity } => {
                commands.entity(*entity).despawn_recursive();
            }
        }
    }
}

fn update_crosshair(
    state: Res<State>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    materials.get_mut(&state.crosshair_material).unwrap().color =
        state.items[state.selected_item].crosshair();
}

#[derive(Debug, Resource)]
struct State {
    items: Vec<Item>,
    selected_item: usize,
    crosshair_material: Handle<ColorMaterial>,
}

#[derive(Debug, Event)]
enum Event {
    Spawn { position: Vec3, item: usize },
    Destroy { entity: Entity },
}

#[derive(Debug)]
enum Item {
    Block {
        mesh: Handle<Mesh>,
        material: Handle<StandardMaterial>,
        crosshair: Color,
    },
    Torch {
        mesh: Handle<Mesh>,
        material: Handle<StandardMaterial>,
        crosshair: Color,
    },
}

impl Item {
    pub fn crosshair(&self) -> Color {
        match self {
            Item::Block { crosshair, .. } | Item::Torch { crosshair, .. } => {
                *crosshair
            }
        }
    }
}

#[derive(Component)]
struct Object;

```

`bevy-strolle/examples/stress-bvh.rs`:

```rs
use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};
use bevy::math::vec3;
use bevy::prelude::*;
use bevy::render::camera::CameraRenderGraph;
use bevy::window::{CursorGrabMode, PrimaryWindow, WindowResolution};
use bevy_rapier3d::prelude::*;
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::fps::{
    FpsCameraBundle, FpsCameraController, FpsCameraPlugin,
};
use smooth_bevy_cameras::LookTransformPlugin;

fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: WindowResolution::new(512.0, 512.0),
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin,
            LookTransformPlugin,
            FpsCameraPlugin::default(),
            RapierPhysicsPlugin::<NoUserData>::default(),
            StrollePlugin,
        ))
        .add_systems(Startup, setup)
        .add_systems(Update, handle_spawning)
        .add_systems(Update, handle_despawning)
        .run();
}

fn setup(
    mut commands: Commands,
    mut window: Query<&mut Window, With<PrimaryWindow>>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut sun: ResMut<StrolleSun>,
) {
    let mut window = window.single_mut();

    window.cursor.visible = false;
    window.cursor.grab_mode = CursorGrabMode::Locked;

    // ---

    sun.altitude = 0.33;

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                hdr: true,
                ..default()
            },
            ..default()
        })
        .insert(FpsCameraBundle::new(
            {
                FpsCameraController {
                    mouse_rotate_sensitivity: Vec2::ONE * 0.35,
                    translate_sensitivity: 8.0,
                    ..default()
                }
            },
            vec3(0.0, 8.0, 40.0),
            vec3(0.0, 1.0, 0.0),
            vec3(0.0, 1.0, 0.0),
        ));

    // ---

    let box_mesh = meshes.add(Mesh::from(shape::Box::new(1.0, 1.0, 1.0)));

    let sphere_mesh =
        meshes.add(Mesh::try_from(shape::Icosphere::default()).unwrap());

    commands
        .spawn(PbrBundle {
            mesh: box_mesh.clone(),
            material: materials.add(StandardMaterial::from(Color::WHITE)),
            transform: Transform::from_scale(vec3(100.0, 1.0, 100.0)),
            ..default()
        })
        .insert(Collider::cuboid(50.0, 0.5, 50.0));

    commands.insert_resource(State {
        box_mesh,
        sphere_mesh,
        spawner: Timer::from_seconds(0.1, TimerMode::Repeating),
    });
}

#[derive(Debug, Resource)]
struct State {
    box_mesh: Handle<Mesh>,
    sphere_mesh: Handle<Mesh>,
    spawner: Timer,
}

#[derive(Component, Debug)]
struct Object {
    despawner: Timer,
}

fn handle_spawning(
    mut commands: Commands,
    time: Res<Time>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut state: ResMut<State>,
) {
    if !state.spawner.tick(time.delta()).just_finished() {
        return;
    }

    let [rand0, rand1, rand2, rand3, rand4, ..] = time
        .elapsed_seconds_f64()
        .to_bits()
        .reflect_hash()
        .unwrap()
        .to_be_bytes();

    let mesh;
    let collider;

    if rand0 % 2 == 0 {
        mesh = state.box_mesh.clone();
        collider = Collider::cuboid(0.5, 0.5, 0.5);
    } else {
        mesh = state.sphere_mesh.clone();
        collider = Collider::ball(1.0);
    }

    let material = materials.add(StandardMaterial::from(Color::hsl(
        (rand1 as f32) / 255.0 * 360.0,
        1.0,
        0.5,
    )));

    let offset_x = (rand2 as f32) / 255.0 * 20.0 - 10.0;
    let offset_y = (rand3 as f32) / 255.0 * 20.0 - 10.0;

    commands
        .spawn(PbrBundle {
            mesh,
            material,
            transform: Transform::from_translation(vec3(
                offset_x, 20.0, offset_y,
            )),
            ..default()
        })
        .insert(RigidBody::Dynamic)
        .insert(collider)
        .insert(Object {
            despawner: Timer::from_seconds(
                (rand4 as f32) / 255.0 * 20.0,
                TimerMode::Once,
            ),
        });
}

fn handle_despawning(
    mut commands: Commands,
    time: Res<Time>,
    mut objects: Query<(Entity, &mut Object)>,
    keys: Res<Input<KeyCode>>,
) {
    for (object_entity, mut object) in objects.iter_mut() {
        if object.despawner.tick(time.delta()).just_finished()
            || keys.just_pressed(KeyCode::X)
        {
            commands.entity(object_entity).despawn();
        }
    }
}

```

`bevy-strolle/examples/stress-lights.rs`:

```rs
use std::f32::consts::PI;

use bevy::diagnostic::{FrameTimeDiagnosticsPlugin, LogDiagnosticsPlugin};
use bevy::math::vec3;
use bevy::prelude::*;
use bevy::render::camera::CameraRenderGraph;
use bevy::window::{CursorGrabMode, PrimaryWindow, WindowResolution};
use bevy_strolle::prelude::*;
use smooth_bevy_cameras::controllers::fps::{
    FpsCameraBundle, FpsCameraController, FpsCameraPlugin,
};
use smooth_bevy_cameras::LookTransformPlugin;

fn main() {
    App::new()
        .add_plugins((
            DefaultPlugins.set(WindowPlugin {
                primary_window: Some(Window {
                    resolution: WindowResolution::new(512.0, 512.0),
                    ..default()
                }),
                ..default()
            }),
            LogDiagnosticsPlugin::default(),
            FrameTimeDiagnosticsPlugin,
            LookTransformPlugin,
            FpsCameraPlugin::default(),
            StrollePlugin,
        ))
        .add_systems(Startup, setup)
        .add_systems(Update, update_lights)
        .run();
}

fn setup(
    mut commands: Commands,
    mut window: Query<&mut Window, With<PrimaryWindow>>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut sun: ResMut<StrolleSun>,
) {
    let mut window = window.single_mut();

    window.cursor.visible = false;
    window.cursor.grab_mode = CursorGrabMode::Locked;

    // ---

    sun.altitude = -1.0;

    commands
        .spawn(Camera3dBundle {
            camera_render_graph: CameraRenderGraph::new(
                bevy_strolle::graph::NAME,
            ),
            camera: Camera {
                hdr: true,
                ..default()
            },
            ..default()
        })
        .insert(FpsCameraBundle::new(
            {
                FpsCameraController {
                    mouse_rotate_sensitivity: Vec2::ONE * 0.35,
                    translate_sensitivity: 8.0,
                    ..default()
                }
            },
            vec3(0.0, 50.0, 80.0),
            vec3(0.0, 50.0, 0.0),
            vec3(0.0, 1.0, 0.0),
        ));

    // ---

    let mesh = meshes.add(Mesh::from(shape::Box::new(1.0, 1.0, 1.0)));
    let material = materials.add(StandardMaterial::from(Color::WHITE));

    commands.spawn(PbrBundle {
        mesh: mesh.clone(),
        material: material.clone(),
        transform: Transform::from_scale(vec3(1000.0, 1.0, 1000.0))
            .with_translation(vec3(0.0, -2.0, 0.0)),
        ..default()
    });

    let walls = [
        Transform::from_scale(vec3(1.0, 10.0, 10.0))
            .with_translation(vec3(-5.0, 5.0, 0.0)),
        Transform::from_scale(vec3(1.0, 10.0, 10.0))
            .with_translation(vec3(5.0, 5.0, 0.0)),
        Transform::from_scale(vec3(10.0, 10.0, 1.0))
            .with_translation(vec3(0.0, 5.0, -5.0)),
        Transform::from_scale(vec3(10.0, 1.0, 10.0))
            .with_translation(vec3(0.0, 10.0, 0.0)),
        Transform::from_scale(vec3(10.0, 1.0, 10.0))
            .with_translation(vec3(0.0, 0.0, 0.0)),
    ];

    let mut phase = 0.0;

    for x in -5..5 {
        for y in 0..10 {
            let x = x as f32 * 15.0;
            let y = y as f32 * 15.0;

            for mut wall in walls {
                wall.translation += vec3(x, y, 0.0);

                commands.spawn(PbrBundle {
                    mesh: mesh.clone(),
                    material: material.clone(),
                    transform: wall,
                    ..default()
                });
            }

            commands
                .spawn(PointLightBundle {
                    point_light: PointLight {
                        color: Color::WHITE,
                        range: 20.0,
                        radius: 0.25,
                        intensity: 3000.0,
                        shadows_enabled: true,
                        ..default()
                    },
                    ..default()
                })
                .insert(Light {
                    anchor: vec3(x, 5.0 + y, 0.0),
                    phase,
                });

            phase += 123.456;
        }
    }
}

#[derive(Component, Debug)]
struct Light {
    anchor: Vec3,
    phase: f32,
}

fn update_lights(
    time: Res<Time>,
    mut lights: Query<(&mut Transform, &mut PointLight, &Light)>,
) {
    for (mut light_xform, mut light_data, light) in lights.iter_mut() {
        let t = light.phase * 2.0 * PI + time.elapsed_seconds();

        light_xform.translation =
            light.anchor + vec3(t.sin() * 4.0, t.cos() * 4.0, 0.0);

        light_data.color = Color::hsl((t * 90.0) % 360.0, 1.0, 0.5);
    }
}

```

`bevy-strolle/src/camera.rs`:

```rs
use bevy::prelude::Component;
use strolle as st;

/// Extends Bevy's camera with extra features supported by Strolle.
///
/// This is a component that can be attached into Bevy's `Camera`; when not
/// attached, the default configuration is used.
#[derive(Clone, Debug, Default, Component)]
pub struct StrolleCamera {
    pub mode: st::CameraMode,
}

```

`bevy-strolle/src/debug.rs`:

```rs
use bevy::core_pipeline::fxaa;
use bevy::core_pipeline::tonemapping::Tonemapping;
use bevy::prelude::*;
use bevy_egui::{egui, EguiContexts, EguiPlugin};

pub struct StrolleDebugPlugin;

impl Plugin for StrolleDebugPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<DebugState>()
            .add_plugins(EguiPlugin)
            .add_systems(Update, draw)
            .add_systems(Update, apply_changes);
    }
}

#[derive(Resource, Debug, Default)]
struct DebugState {
    fxaa: bool,
    fxaa_changed: bool,
    tonemapping: Tonemapping,
    tonemapping_changed: bool,
}

fn draw(
    mut contexts: EguiContexts,
    render_config: ResMut<DebugState>,
    point_lights: Query<&mut PointLight>,
    materials: ResMut<Assets<StandardMaterial>>,
    query_material_handles: Query<&mut Handle<StandardMaterial>>,
    time: Res<Time>,
) {
    egui::Window::new("Debug")
        .resizable(true)
        .show(contexts.ctx_mut(), |ui| {
            draw_lights(ui, point_lights);
            draw_materials(ui, materials, query_material_handles);

            ui.separator();

            egui::Grid::new("grid")
                .num_columns(2)
                .spacing([20.0, 4.0])
                .striped(true)
                .show(ui, |ui| {
                    faxx_tonemapping_ui(ui, render_config);
                });

            ui.separator();

            ui.label(format!(
                "{} FPS ({:.2} ms/frame) ",
                (1.0 / time.delta_seconds()).floor(),
                1000.0 * time.delta_seconds()
            ));
        });
}

fn draw_lights(ui: &mut egui::Ui, mut point_lights: Query<&mut PointLight>) {
    ui.collapsing("Lights", |ui| {
        for (light_idx, mut light) in point_lights.iter_mut().enumerate() {
            ui.collapsing(format!("Light {}", light_idx), |ui| {
                ui.horizontal(|ui| {
                    ui.label("Intensity");

                    ui.add(egui::Slider::new(
                        &mut light.intensity,
                        0.0..=10000.0,
                    ));
                });

                ui.collapsing("Info", |ui| {
                    ui.label(format!("{:#?}", light));
                });
            });
        }
    });
}

fn draw_materials(
    ui: &mut egui::Ui,
    mut materials: ResMut<Assets<StandardMaterial>>,
    material_handles: Query<&mut Handle<StandardMaterial>>,
) {
    ui.collapsing("Materials", |ui| {
        for (mat_idx, mat_handle) in material_handles.iter().enumerate() {
            ui.collapsing(format!("Material {}", mat_idx), |ui| {
                let Some(material) = materials.get_mut(mat_handle) else {
                    return;
                };

                let rgba = material.base_color.as_rgba_f32();
                let mut rgb = [rgba[0], rgba[1], rgba[2]];

                ui.color_edit_button_rgb(&mut rgb);

                material.base_color =
                    Color::rgba(rgb[0], rgb[1], rgb[2], rgba[3]);

                ui.collapsing("Info", |ui| {
                    ui.label(format!("{:#?}", material));
                });
            });
        }
    });
}

fn faxx_tonemapping_ui(
    ui: &mut egui::Ui,
    mut render_config: ResMut<DebugState>,
) {
    ui.label("FXAA");

    render_config.fxaa_changed |=
        ui.checkbox(&mut render_config.fxaa, "").changed();

    ui.end_row();
    ui.label("Tonemapping");

    let curr_value = render_config.tonemapping;

    egui::ComboBox::from_label("")
        .selected_text(format!("{:?}", render_config.tonemapping))
        .show_ui(ui, |ui| {
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::None,
                "None",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::AcesFitted,
                "AcesFitted",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::AgX,
                "AgX",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::BlenderFilmic,
                "BlenderFilmic",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::Reinhard,
                "Reinhard",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::ReinhardLuminance,
                "ReinhardLuminance",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::SomewhatBoringDisplayTransform,
                "SomewhatBoringDisplayTransform",
            );
            ui.selectable_value(
                &mut render_config.tonemapping,
                Tonemapping::TonyMcMapface,
                "TonyMcMapface",
            );
        });

    ui.end_row();

    if render_config.tonemapping != curr_value {
        render_config.tonemapping_changed = true;
    }
}

fn apply_changes(
    mut commands: Commands,
    mut render_config: ResMut<DebugState>,
    cameras: Query<Entity, With<Camera>>,
) {
    if render_config.fxaa_changed {
        for camera in &cameras {
            if render_config.fxaa {
                commands.entity(camera).insert(fxaa::Fxaa::default());
            } else {
                commands.entity(camera).remove::<fxaa::Fxaa>();
            }
        }

        render_config.fxaa_changed = !render_config.fxaa_changed;
    }

    if render_config.tonemapping_changed {
        for camera in &cameras {
            commands.entity(camera).insert(render_config.tonemapping);
        }

        render_config.tonemapping_changed = !render_config.tonemapping_changed;
    }
}

```

`bevy-strolle/src/event.rs`:

```rs
use bevy::prelude::*;

#[derive(Debug, Event)]
pub enum StrolleEvent {
    MarkImageAsDynamic { id: AssetId<Image> },
}

```

`bevy-strolle/src/graph.rs`:

```rs
pub const NAME: &str = "strolle";

pub mod node {
    pub const RENDERING: &str = "strolle_rendering";
    pub const TONEMAPPING: &str = "strolle_tonemapping";
    pub const FXAA: &str = "strolle_fxaa";
    pub const UPSCALING: &str = "strolle_upscaling";
}

use bevy::core_pipeline::fxaa::FxaaNode;
use bevy::core_pipeline::tonemapping::TonemappingNode;
use bevy::core_pipeline::upscaling::UpscalingNode;
use bevy::prelude::*;
use bevy::render::render_graph::{RenderGraphApp, ViewNodeRunner};

use crate::RenderingNode;

pub(crate) fn setup(render_app: &mut App) {
    render_app
        .add_render_sub_graph(NAME)
        .add_render_graph_node::<ViewNodeRunner<RenderingNode>>(
            NAME,
            node::RENDERING,
        )
        .add_render_graph_node::<ViewNodeRunner<TonemappingNode>>(
            NAME,
            node::TONEMAPPING,
        )
        .add_render_graph_node::<ViewNodeRunner<UpscalingNode>>(
            NAME,
            node::UPSCALING,
        )
        .add_render_graph_node::<ViewNodeRunner<FxaaNode>>(NAME, node::FXAA)
        .add_render_graph_edges(
            NAME,
            &[
                node::RENDERING,
                node::FXAA,
                node::TONEMAPPING,
                node::UPSCALING,
            ],
        );
}

```

`bevy-strolle/src/lib.rs`:

```rs
mod camera;
mod debug;
mod event;
pub mod graph;
mod rendering_node;
mod stages;
mod state;
mod sun;
mod utils;

pub mod prelude {
    pub use crate::*;
}

use std::ops;

use bevy::prelude::*;
use bevy::render::render_resource::Texture;
use bevy::render::renderer::RenderDevice;
use bevy::render::RenderApp;
pub use strolle as st;

pub use self::camera::*;
pub use self::debug::*;
pub use self::event::*;
pub(crate) use self::rendering_node::*;
pub(crate) use self::state::*;
pub use self::sun::*;

pub struct StrollePlugin;

impl Plugin for StrollePlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<StrolleEvent>();
        app.insert_resource(StrolleSun::default());

        if let Ok(render_app) = app.get_sub_app_mut(RenderApp) {
            render_app.insert_resource(SyncedState::default());

            stages::setup(render_app);
            graph::setup(render_app);
        }
    }

    fn finish(&self, app: &mut App) {
        let Ok(render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };

        let render_device = render_app.world.resource::<RenderDevice>();
        let engine = st::Engine::new(render_device.wgpu_device());

        render_app.insert_resource(EngineResource(engine));
    }
}

#[derive(Resource)]
struct EngineResource(st::Engine<EngineParams>);

#[derive(Clone, Debug)]
struct EngineParams;

impl st::Params for EngineParams {
    type ImageHandle = AssetId<Image>;
    type ImageTexture = Texture;
    type InstanceHandle = Entity;
    type LightHandle = Entity;
    type MaterialHandle = AssetId<StandardMaterial>;
    type MeshHandle = AssetId<Mesh>;
}

impl ops::Deref for EngineResource {
    type Target = st::Engine<EngineParams>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl ops::DerefMut for EngineResource {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

```

`bevy-strolle/src/rendering_node.rs`:

```rs
use bevy::prelude::*;
use bevy::render::render_graph::{NodeRunError, RenderGraphContext, ViewNode};
use bevy::render::renderer::RenderContext;
use bevy::render::view::ViewTarget;

use crate::{EngineResource, SyncedState};

#[derive(Default)]
pub struct RenderingNode;

impl ViewNode for RenderingNode {
    type ViewQuery = &'static ViewTarget;

    fn run(
        &self,
        graph: &mut RenderGraphContext,
        render_context: &mut RenderContext,
        target: &ViewTarget,
        world: &World,
    ) -> Result<(), NodeRunError> {
        let entity = graph.view_entity();
        let engine = world.resource::<EngineResource>();
        let state = world.resource::<SyncedState>();

        let Some(camera) = state.cameras.get(&entity) else {
            return Ok(());
        };

        engine.render_camera(
            camera.handle,
            render_context.command_encoder(),
            target.main_texture_view(),
        );

        Ok(())
    }
}

```

`bevy-strolle/src/stages.rs`:

```rs
mod extract;
mod prepare;

use bevy::prelude::*;
use bevy::render::{Render, RenderSet};

pub(crate) fn setup(render_app: &mut App) {
    render_app.add_systems(
        ExtractSchedule,
        extract::meshes.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::materials.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::instances.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::images.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::lights.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::cameras.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(
        ExtractSchedule,
        extract::sun.in_set(RenderSet::ExtractCommands),
    );

    render_app.add_systems(Render, prepare::meshes.in_set(RenderSet::Prepare));

    render_app
        .add_systems(Render, prepare::materials.in_set(RenderSet::Prepare));

    render_app.add_systems(
        Render,
        prepare::instances
            .in_set(RenderSet::Prepare)
            .after(prepare::meshes)
            .after(prepare::materials),
    );

    render_app.add_systems(Render, prepare::images.in_set(RenderSet::Prepare));
    render_app.add_systems(Render, prepare::lights.in_set(RenderSet::Prepare));
    render_app.add_systems(Render, prepare::sun.in_set(RenderSet::Prepare));
    render_app.add_systems(Render, prepare::cameras.in_set(RenderSet::Prepare));

    render_app
        .add_systems(Render, prepare::flush.in_set(RenderSet::PrepareFlush));
}

```

`bevy-strolle/src/stages/extract.rs`:

```rs
use std::f32::consts::PI;

use bevy::prelude::*;
use bevy::render::camera::{CameraProjection, CameraRenderGraph};
use bevy::render::texture::{ImageSampler, ImageSamplerDescriptor};
use bevy::render::view::RenderLayers;
use bevy::render::Extract;
use bevy::utils::HashSet;
use strolle as st;

use crate::state::{
    ExtractedCamera, ExtractedImage, ExtractedImageData, ExtractedImages,
    ExtractedInstance, ExtractedInstances, ExtractedLight, ExtractedLights,
    ExtractedMaterial, ExtractedMaterials, ExtractedMesh, ExtractedMeshes,
    ExtractedSun,
};
use crate::utils::color_to_vec3;
use crate::{StrolleCamera, StrolleEvent, StrolleSun};

pub(crate) fn meshes(
    mut commands: Commands,
    mut events: Extract<EventReader<AssetEvent<Mesh>>>,
    meshes: Extract<Res<Assets<Mesh>>>,
) {
    let mut changed = HashSet::default();
    let mut removed = Vec::new();

    for event in events.read() {
        match event {
            AssetEvent::Added { id } | AssetEvent::Modified { id } => {
                changed.insert(*id);
            }
            AssetEvent::Removed { id } => {
                removed.push(*id);
            }
            AssetEvent::LoadedWithDependencies { .. } => {
                //
            }
        }
    }

    let changed = changed.into_iter().flat_map(|id| {
        if let Some(mesh) = meshes.get(id) {
            Some(ExtractedMesh {
                handle: id,
                mesh: mesh.to_owned(),
            })
        } else {
            removed.push(id);
            None
        }
    });

    commands.insert_resource(ExtractedMeshes {
        changed: changed.collect(),
        removed,
    });
}

pub(crate) fn materials(
    mut commands: Commands,
    mut events: Extract<EventReader<AssetEvent<StandardMaterial>>>,
    materials: Extract<Res<Assets<StandardMaterial>>>,
) {
    let mut changed = HashSet::default();
    let mut removed = Vec::new();

    for event in events.read() {
        match event {
            AssetEvent::Added { id } | AssetEvent::Modified { id } => {
                changed.insert(*id);
            }
            AssetEvent::Removed { id } => {
                removed.push(*id);
            }
            AssetEvent::LoadedWithDependencies { .. } => {
                //
            }
        }
    }

    let changed = changed.into_iter().flat_map(|id| {
        if let Some(material) = materials.get(id) {
            Some(ExtractedMaterial {
                handle: id,
                material: material.to_owned(),
            })
        } else {
            removed.push(id);
            None
        }
    });

    commands.insert_resource(ExtractedMaterials {
        changed: changed.collect(),
        removed,
    });
}

pub(crate) fn images(
    mut commands: Commands,
    mut events: Extract<EventReader<StrolleEvent>>,
    mut asset_events: Extract<EventReader<AssetEvent<Image>>>,
    images: Extract<Res<Assets<Image>>>,
    mut dynamic_images: Local<HashSet<AssetId<Image>>>,
) {
    for event in events.read() {
        match event {
            StrolleEvent::MarkImageAsDynamic { id } => {
                dynamic_images.insert(*id);
            }
        }
    }

    // ---

    let mut changed = HashSet::default();
    let mut removed = Vec::new();

    for event in asset_events.read() {
        match event {
            AssetEvent::Added { id } | AssetEvent::Modified { id } => {
                changed.insert(*id);
            }
            AssetEvent::Removed { id } => {
                changed.remove(id);
                removed.push(*id);
                dynamic_images.remove(id);
            }
            AssetEvent::LoadedWithDependencies { .. } => {
                //
            }
        }
    }

    let changed = changed.into_iter().flat_map(|id| {
        let Some(image) = images.get(id) else {
            removed.push(id);
            return None;
        };

        let texture_descriptor = image.texture_descriptor.clone();

        let sampler_descriptor = match &image.sampler {
            ImageSampler::Default => wgpu::SamplerDescriptor {
                label: None,
                ..ImageSamplerDescriptor::nearest().as_wgpu()
            },

            ImageSampler::Descriptor(descriptor) => wgpu::SamplerDescriptor {
                label: None,
                ..descriptor.as_wgpu()
            },
        };

        let data = if dynamic_images.contains(&id) {
            let is_legal = image
                .texture_descriptor
                .usage
                .contains(wgpu::TextureUsages::COPY_SRC);

            assert!(
                is_legal,
                "image `{:?}` was marked as dynamic but it is missing the \
                 COPY_SRC usage - please add that usage and try again",
                id
            );

            ExtractedImageData::Texture { is_dynamic: true }
        } else {
            ExtractedImageData::Raw {
                data: image.data.clone(),
            }
        };

        Some(ExtractedImage {
            handle: id,
            texture_descriptor,
            sampler_descriptor,
            data,
        })
    });

    commands.insert_resource(ExtractedImages {
        changed: changed.collect(),
        removed,
    });
}

#[allow(clippy::type_complexity)]
pub(crate) fn instances(
    mut commands: Commands,
    changed: Extract<
        Query<
            (
                Entity,
                &Handle<Mesh>,
                &Handle<StandardMaterial>,
                &GlobalTransform,
                &InheritedVisibility,
                Option<&RenderLayers>,
            ),
            Or<(
                Changed<Handle<Mesh>>,
                Changed<Handle<StandardMaterial>>,
                Changed<GlobalTransform>,
                Changed<InheritedVisibility>,
                Changed<RenderLayers>,
            )>,
        >,
    >,
    mut removed: Extract<RemovedComponents<Handle<Mesh>>>,
) {
    let mut removed: Vec<_> = removed.read().collect();

    let changed = changed
        .iter()
        .filter_map(
            |(
                handle,
                mesh_handle,
                material_handle,
                transform,
                visibility,
                layers,
            )| {
                if !visibility.get() {
                    // TODO inefficient; we should push only if the object was
                    //      visible before
                    removed.push(handle);
                    return None;
                }

                // TODO this is invalid (but good enough for now); instead, we
                //      should probably propagate the layers up to the BVH
                //      leaves and adjust the raytracer to read those
                if let Some(layers) = layers {
                    if *layers != RenderLayers::all() {
                        // TODO inefficient; we should push only if the object
                        //      was visible before
                        removed.push(handle);
                        return None;
                    }
                }

                Some(ExtractedInstance {
                    handle,
                    mesh_handle: mesh_handle.id(),
                    material_handle: material_handle.id(),
                    xform: transform.affine(),
                })
            },
        )
        .collect();

    commands.insert_resource(ExtractedInstances { changed, removed });
}

#[allow(clippy::type_complexity)]
pub(crate) fn lights(
    mut commands: Commands,
    changed_point_lights: Extract<
        Query<
            (Entity, &PointLight, &GlobalTransform),
            Or<(Changed<PointLight>, Changed<GlobalTransform>)>,
        >,
    >,
    changed_spot_lights: Extract<
        Query<
            (Entity, &SpotLight, &GlobalTransform),
            Or<(Changed<SpotLight>, Changed<GlobalTransform>)>,
        >,
    >,
    mut removed_point_lights: Extract<RemovedComponents<PointLight>>,
    mut removed_spot_lights: Extract<RemovedComponents<SpotLight>>,
) {
    let mut removed: Vec<_> = removed_point_lights
        .read()
        .chain(removed_spot_lights.read())
        .collect();

    let changed_point_lights: Vec<_> = changed_point_lights
        .iter()
        .filter_map(|(handle, light, xform)| {
            let intensity = light.intensity / (4.0 * PI);

            if intensity < 0.0001 {
                removed.push(handle);
                return None;
            }

            let light = st::Light::Point {
                position: xform.translation(),
                radius: light.radius,
                color: color_to_vec3(light.color) * intensity,
                range: light.range,
            };

            Some(ExtractedLight { handle, light })
        })
        .collect();

    let changed_spot_lights: Vec<_> = changed_spot_lights
        .iter()
        .filter_map(|(handle, light, xform)| {
            let intensity = light.intensity / (4.0 * PI);

            if intensity < 0.0001 {
                removed.push(handle);
                return None;
            }

            let (_, rotation, translation) =
                xform.to_scale_rotation_translation();

            let light = st::Light::Spot {
                position: translation,
                radius: light.radius,
                color: color_to_vec3(light.color) * intensity,
                range: light.range,
                direction: -(rotation * Vec3::Z).normalize(),
                angle: light.outer_angle,
            };

            Some(ExtractedLight { handle, light })
        })
        .collect();

    let changed = changed_point_lights
        .into_iter()
        .chain(changed_spot_lights)
        .collect();

    commands.insert_resource(ExtractedLights { changed, removed });
}

#[allow(clippy::type_complexity)]
pub(crate) fn cameras(
    mut commands: Commands,
    cameras: Extract<
        Query<(
            Entity,
            &Camera,
            &CameraRenderGraph,
            &Projection,
            &GlobalTransform,
            Option<&StrolleCamera>,
        )>,
    >,
) {
    for (
        entity,
        camera,
        camera_render_graph,
        projection,
        transform,
        strolle_camera,
    ) in cameras.iter()
    {
        if !camera.is_active || **camera_render_graph != crate::graph::NAME {
            continue;
        }

        assert!(camera.hdr, "Strolle requires an HDR camera");

        commands.get_or_spawn(entity).insert(ExtractedCamera {
            transform: transform.compute_matrix(),
            projection: projection.get_projection_matrix(),
            mode: strolle_camera.map(|camera| camera.mode),
        });
    }
}

pub(crate) fn sun(mut commands: Commands, sun: Extract<Res<StrolleSun>>) {
    commands.insert_resource(ExtractedSun { sun: Some(***sun) });
}

```

`bevy-strolle/src/stages/prepare.rs`:

```rs
use std::mem;

use bevy::prelude::*;
use bevy::render::camera::ExtractedCamera as BevyExtractedCamera;
use bevy::render::mesh::VertexAttributeValues;
use bevy::render::render_asset::RenderAssets;
use bevy::render::render_resource::PrimitiveTopology;
use bevy::render::renderer::{RenderDevice, RenderQueue};
use bevy::render::view::ViewTarget;
use bevy::utils::hashbrown::hash_map::Entry;
use bevy::utils::HashSet;
use strolle as st;

use crate::state::{
    ExtractedCamera, ExtractedImageData, ExtractedImages, ExtractedInstances,
    ExtractedLights, ExtractedMaterials, ExtractedMeshes, ExtractedSun,
    SyncedCamera, SyncedState,
};
use crate::utils::color_to_vec4;
use crate::EngineResource;

pub(crate) fn meshes(
    mut engine: ResMut<EngineResource>,
    mut meshes: ResMut<ExtractedMeshes>,
) {
    for handle in meshes
        .removed
        .iter()
        .copied()
        .chain(meshes.changed.iter().map(|mesh| mesh.handle))
    {
        engine.remove_mesh(handle);
    }

    for mesh in mem::take(&mut meshes.changed) {
        if mesh.mesh.primitive_topology() != PrimitiveTopology::TriangleList {
            continue;
        }

        let mesh_positions = mesh
            .mesh
            .attribute(Mesh::ATTRIBUTE_POSITION)
            .and_then(VertexAttributeValues::as_float3)
            .unwrap_or_else(|| {
                panic!("mesh {:?} has no positions", mesh.handle);
            });

        let mesh_normals = mesh
            .mesh
            .attribute(Mesh::ATTRIBUTE_NORMAL)
            .and_then(VertexAttributeValues::as_float3)
            .unwrap_or_else(|| {
                panic!("mesh {:?} has no normals", mesh.handle);
            });

        let mesh_uvs = mesh
            .mesh
            .attribute(Mesh::ATTRIBUTE_UV_0)
            .map(|uvs| match uvs {
                VertexAttributeValues::Float32x2(uvs) => uvs,
                _ => {
                    panic!(
                        "mesh {:?} uses unsupported format for UVs",
                        mesh.handle
                    )
                }
            })
            .map(|uvs| uvs.as_slice())
            .unwrap_or(&[]);

        let mesh_tans = mesh
            .mesh
            .attribute(Mesh::ATTRIBUTE_TANGENT)
            .map(|uvs| match uvs {
                VertexAttributeValues::Float32x4(tangents) => tangents,
                _ => panic!(
                    "mesh {:?} uses unsupported format for tangents",
                    mesh.handle
                ),
            })
            .map(|tangents| tangents.as_slice())
            .unwrap_or(&[]);

        let mesh_indices: Vec<_> = mesh
            .mesh
            .indices()
            .unwrap_or_else(|| {
                panic!("mesh {:?} has no indices", mesh.handle);
            })
            .iter()
            .collect();

        let mesh_triangles: Vec<_> = mesh_indices
            .chunks(3)
            .map(|vs| {
                let position0 = mesh_positions[vs[0]];
                let position1 = mesh_positions[vs[1]];
                let position2 = mesh_positions[vs[2]];

                let normal0 = mesh_normals[vs[0]];
                let normal1 = mesh_normals[vs[1]];
                let normal2 = mesh_normals[vs[2]];

                let uv0 = mesh_uvs.get(vs[0]).copied().unwrap_or_default();
                let uv1 = mesh_uvs.get(vs[1]).copied().unwrap_or_default();
                let uv2 = mesh_uvs.get(vs[2]).copied().unwrap_or_default();

                let tan0 = mesh_tans.get(vs[0]).copied().unwrap_or_default();
                let tan1 = mesh_tans.get(vs[1]).copied().unwrap_or_default();
                let tan2 = mesh_tans.get(vs[2]).copied().unwrap_or_default();

                st::MeshTriangle::default()
                    .with_positions([position0, position1, position2])
                    .with_normals([normal0, normal1, normal2])
                    .with_uvs([uv0, uv1, uv2])
                    .with_tangents([tan0, tan1, tan2])
            })
            .collect();

        engine.insert_mesh(mesh.handle, st::Mesh::new(mesh_triangles));
    }
}

pub(crate) fn materials(
    mut engine: ResMut<EngineResource>,
    mut materials: ResMut<ExtractedMaterials>,
) {
    for handle in &materials.removed {
        engine.remove_material(*handle);
    }

    let map = |mat: StandardMaterial| {
        let base_color = {
            let color = color_to_vec4(mat.base_color);

            match mat.alpha_mode {
                AlphaMode::Opaque => color.xyz().extend(1.0),
                AlphaMode::Mask(mask) => {
                    if color.w >= mask {
                        color.xyz().extend(1.0)
                    } else {
                        color.xyz().extend(0.0)
                    }
                }
                _ => color,
            }
        };

        let ior = if mat.thickness > 0.0 { mat.ior } else { 1.0 };

        let alpha_mode = match mat.alpha_mode {
            AlphaMode::Opaque => st::AlphaMode::Opaque,
            _ => st::AlphaMode::Blend,
        };

        st::Material {
            base_color,
            base_color_texture: mat
                .base_color_texture
                .map(|handle| handle.id()),
            emissive: color_to_vec4(mat.emissive),
            emissive_texture: mat.emissive_texture.map(|handle| handle.id()),
            perceptual_roughness: mat.perceptual_roughness,
            metallic: mat.metallic,
            metallic_roughness_texture: mat
                .metallic_roughness_texture
                .map(|handle| handle.id()),
            reflectance: mat.reflectance,
            normal_map_texture: mat
                .normal_map_texture
                .map(|handle| handle.id()),
            ior,
            alpha_mode,
        }
    };

    for entry in materials.changed.drain(..) {
        engine.insert_material(entry.handle, map(entry.material));
    }
}

pub(crate) fn images(
    mut engine: ResMut<EngineResource>,
    textures: Res<RenderAssets<Image>>,
    mut images: ResMut<ExtractedImages>,
) {
    for handle in &images.removed {
        engine.remove_image(*handle);
    }

    for entry in mem::take(&mut images.changed) {
        if entry.texture_descriptor.dimension != wgpu::TextureDimension::D2 {
            continue;
        }

        let data = match entry.data {
            ExtractedImageData::Raw { data } => st::ImageData::Raw { data },

            ExtractedImageData::Texture { is_dynamic } => {
                st::ImageData::Texture {
                    texture: textures
                        .get(entry.handle)
                        .unwrap()
                        .texture
                        .clone(),
                    is_dynamic,
                }
            }
        };

        // TODO we should add only those images which are used by at least one
        //      material, since otherwise we'll .add_image() textures that are
        //      related solely to UI, for instance
        //
        //      (conversely, we should remove those images which are not in use
        //      by any material)
        //
        //      that's not so easy though because it can happen that an image is
        //      loaded first *and then* (e.g. in next frame) it's used by some
        //      material, in which case a simple condition right here will not
        //      be sufficient
        engine.insert_image(
            entry.handle,
            st::Image::new(
                data,
                entry.texture_descriptor,
                entry.sampler_descriptor,
            ),
        );
    }
}

pub(crate) fn instances(
    mut engine: ResMut<EngineResource>,
    mut instances: ResMut<ExtractedInstances>,
) {
    for handle in &instances.removed {
        engine.remove_instance(*handle);
    }

    for entry in mem::take(&mut instances.changed) {
        engine.insert_instance(
            entry.handle,
            st::Instance::new(
                entry.mesh_handle,
                entry.material_handle,
                entry.xform,
            ),
        );
    }
}

pub(crate) fn lights(
    mut engine: ResMut<EngineResource>,
    mut lights: ResMut<ExtractedLights>,
) {
    for handle in &lights.removed {
        engine.remove_light(*handle);
    }

    for entry in mem::take(&mut lights.changed) {
        engine.insert_light(entry.handle, entry.light);
    }
}

pub(crate) fn sun(
    mut engine: ResMut<EngineResource>,
    mut sun: ResMut<ExtractedSun>,
) {
    if let Some(sun) = sun.sun.take() {
        engine.update_sun(sun);
    }
}

pub(crate) fn cameras(
    device: Res<RenderDevice>,
    mut state: ResMut<SyncedState>,
    mut engine: ResMut<EngineResource>,
    mut cameras: Query<(
        Entity,
        &ViewTarget,
        &BevyExtractedCamera,
        &ExtractedCamera,
    )>,
) {
    let device = device.wgpu_device();
    let state = &mut *state;
    let engine = &mut *engine;
    let mut alive_cameras = HashSet::new();

    for (entity, view_target, bevy_ext_camera, ext_camera) in cameras.iter_mut()
    {
        let camera = st::Camera {
            mode: ext_camera.mode.unwrap_or_default(),

            viewport: {
                let format = view_target.main_texture_format();

                let Some(size) = bevy_ext_camera.physical_viewport_size else {
                    continue;
                };

                let position = bevy_ext_camera
                    .viewport
                    .as_ref()
                    .map(|v| v.physical_position)
                    .unwrap_or_default();

                st::CameraViewport {
                    format,
                    size,
                    position,
                }
            },

            transform: ext_camera.transform,
            projection: ext_camera.projection,
        };

        match state.cameras.entry(entity) {
            Entry::Occupied(entry) => {
                engine.update_camera(device, entry.into_mut().handle, camera);
            }

            Entry::Vacant(entry) => {
                entry.insert(SyncedCamera {
                    handle: engine.create_camera(device, camera),
                });
            }
        }

        alive_cameras.insert(entity);
    }

    // -----

    if alive_cameras.len() != state.cameras.len() {
        state.cameras.retain(|entity2, camera2| {
            let is_alive = alive_cameras.contains(entity2);

            if !is_alive {
                engine.delete_camera(camera2.handle);
            }

            is_alive
        });
    }
}

pub(crate) fn flush(
    device: Res<RenderDevice>,
    queue: Res<RenderQueue>,
    mut engine: ResMut<EngineResource>,
    mut state: ResMut<SyncedState>,
) {
    state.tick(&mut engine, &device, &queue);
}

```

`bevy-strolle/src/state.rs`:

```rs
use bevy::math::Affine3A;
use bevy::prelude::*;
use bevy::render::renderer::{RenderDevice, RenderQueue};
use bevy::utils::HashMap;
use strolle as st;

use crate::EngineParams;

#[derive(Default, Resource)]
pub(crate) struct SyncedState {
    pub cameras: HashMap<Entity, SyncedCamera>,
}

impl SyncedState {
    pub fn is_active(&self) -> bool {
        !self.cameras.is_empty()
    }

    pub fn tick(
        &mut self,
        engine: &mut st::Engine<EngineParams>,
        device: &RenderDevice,
        queue: &RenderQueue,
    ) {
        if self.is_active() {
            engine.tick(device.wgpu_device(), queue);
        }
    }
}

#[derive(Debug)]
pub(crate) struct SyncedCamera {
    pub handle: st::CameraHandle,
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedMeshes {
    pub changed: Vec<ExtractedMesh>,
    pub removed: Vec<AssetId<Mesh>>,
}

#[derive(Debug)]
pub(crate) struct ExtractedMesh {
    pub handle: AssetId<Mesh>,
    pub mesh: Mesh,
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedMaterials {
    pub changed: Vec<ExtractedMaterial>,
    pub removed: Vec<AssetId<StandardMaterial>>,
}

#[derive(Debug)]
pub(crate) struct ExtractedMaterial {
    pub handle: AssetId<StandardMaterial>,
    pub material: StandardMaterial,
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedImages {
    pub changed: Vec<ExtractedImage>,
    pub removed: Vec<AssetId<Image>>,
}

#[derive(Debug)]
pub(crate) struct ExtractedImage {
    pub handle: AssetId<Image>,
    pub texture_descriptor: wgpu::TextureDescriptor<'static>,
    pub sampler_descriptor: wgpu::SamplerDescriptor<'static>,
    pub data: ExtractedImageData,
}

#[derive(Debug)]
pub(crate) enum ExtractedImageData {
    Raw { data: Vec<u8> },
    Texture { is_dynamic: bool },
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedInstances {
    pub changed: Vec<ExtractedInstance>,
    pub removed: Vec<Entity>,
}

#[derive(Debug)]
pub(crate) struct ExtractedInstance {
    pub handle: Entity,
    pub mesh_handle: AssetId<Mesh>,
    pub material_handle: AssetId<StandardMaterial>,
    pub xform: Affine3A,
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedLights {
    pub changed: Vec<ExtractedLight>,
    pub removed: Vec<Entity>,
}

#[derive(Debug)]
pub(crate) struct ExtractedLight {
    pub handle: Entity,
    pub light: st::Light,
}

#[derive(Debug, Component)]
pub(crate) struct ExtractedCamera {
    pub transform: Mat4,
    pub projection: Mat4,
    pub mode: Option<st::CameraMode>,
}

#[derive(Debug, Resource)]
pub(crate) struct ExtractedSun {
    pub sun: Option<st::Sun>,
}

```

`bevy-strolle/src/sun.rs`:

```rs
use std::ops::{Deref, DerefMut};

use bevy::prelude::Resource;
use strolle as st;

#[derive(Clone, Debug, Default, Resource)]
pub struct StrolleSun {
    sun: st::Sun,
}

impl Deref for StrolleSun {
    type Target = st::Sun;

    fn deref(&self) -> &Self::Target {
        &self.sun
    }
}

impl DerefMut for StrolleSun {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.sun
    }
}

```

`bevy-strolle/src/utils.rs`:

```rs
use bevy::math::{vec3, vec4};
use bevy::prelude::*;

pub fn color_to_vec3(color: Color) -> Vec3 {
    let [r, g, b, _] = color.as_linear_rgba_f32();

    vec3(r, g, b)
}

pub fn color_to_vec4(color: Color) -> Vec4 {
    let [r, g, b, a] = color.as_linear_rgba_f32();

    vec4(r, g, b, a)
}

```

`rust-toolchain.toml`:

```toml
[toolchain]
channel = "nightly-2024-11-22"
components = ["rust-src", "rustc-dev", "llvm-tools"]

```

`rustfmt.toml`:

```toml
max_width = 80
imports_granularity = "Module"
group_imports = "StdExternalCrate"

```

`shell.nix`:

```nix
{
  pkgs ? import <nixpkgs> { },
}:

with pkgs;

mkShell rec {
  nativeBuildInputs = [
    pkg-config
  ];

  buildInputs = [
    alsa-lib
    libxkbcommon
    udev
    vulkan-loader
    wayland
    xorg.libX11
    xorg.libXcursor
    xorg.libXi
    xorg.libXrandr
  ];

  LD_LIBRARY_PATH = lib.makeLibraryPath (buildInputs ++ [ stdenv.cc.cc.lib ]);
}

```

`strolle-gpu/Cargo.toml`:

```toml
[package]
name = "strolle-gpu"
version = "0.1.0"
edition = "2021"

[lints]
workspace = true

[dependencies]
bytemuck = { workspace = true, features = ["derive", "min_const_generics"] }
glam = { workspace = true, default-features = false, features = ["bytemuck"] }
spirv-std.workspace = true

[dev-dependencies]
approx = "0.5.1"

```

`strolle-gpu/src/atmosphere.rs`:

```rs
use core::f32::consts::PI;

use glam::{uvec2, vec2, vec3, UVec2, Vec3, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;
use spirv_std::Sampler;

use crate::{F32Ext, Ray, Tex};

#[derive(Clone, Copy)]
pub struct Atmosphere<'a> {
    transmittance_lut_tex: Tex<'a>,
    transmittance_lut_sampler: &'a Sampler,
    sky_lut_tex: Tex<'a>,
    sky_lut_sampler: &'a Sampler,
}

impl<'a> Atmosphere<'a> {
    /// Resolution of the transmittance lookup texture.
    ///
    /// This texture is generated just once, when Strolle is booting.
    pub const TRANSMITTANCE_LUT_RESOLUTION: UVec2 = uvec2(256, 64);

    /// Quality of the transmittance lookup texture.
    pub const TRANSMITTANCE_LUT_STEPS: f32 = 40.0;

    /// Resolution of the scattering lookup texture.
    ///
    /// This texture is generated just once, when Strolle is booting.
    pub const SCATTERING_LUT_RESOLUTION: UVec2 = uvec2(32, 32);

    /// Quality of the scattering lookup texture.
    pub const SCATTERING_LUT_STEPS: f32 = 20.0;

    /// Quality of the scattering lookup texture.
    pub const SCATTERING_LUT_SAMPLES_SQRT: usize = 8;

    /// Resolution of the sky lookup texture.
    ///
    /// This texture is regenerated each time sun's position changes so it's
    /// important not to go too crazy in here.
    pub const SKY_LUT_RESOLUTION: UVec2 = uvec2(256, 256);

    /// Quality of the sky lookup texture.
    pub const SKY_LUT_STEPS: f32 = 32.0;

    /// Radius of the planet, in mega-meters.
    pub const GROUND_RADIUS_MM: f32 = 6.360;

    /// Radius of the atmosphere, in mega-meters;
    pub const ATMOSPHERE_RADIUS_MM: f32 = 6.460;

    pub const RAYLEIGH_SCATTERING_BASE: Vec3 = vec3(5.802, 13.558, 33.1);
    pub const RAYLEIGH_ABSORPTION_BASE: f32 = 0.0;

    pub const MIE_SCATTERING_BASE: f32 = 3.996;
    pub const MIE_ABSORPTION_BASE: f32 = 4.4;

    pub const OZONE_ABSORPTION_BASE: Vec3 = vec3(0.650, 1.881, 0.085);

    pub const GROUND_ALBEDO: Vec3 = Vec3::splat(0.25);

    pub const EXPOSURE: f32 = 20.0;

    /// Position of the observer in world.
    ///
    /// This is a constant because the atmosphere generally doesn't change that
    /// much when camera is moving (unless one's travelling in a spaceship) and
    /// so it's just more practical to use a hard-coded value here.
    pub const VIEW_POS: Vec3 = vec3(0.0, Self::GROUND_RADIUS_MM + 0.0002, 0.0);

    pub fn new(
        transmittance_lut_tex: Tex<'a>,
        transmittance_lut_sampler: &'a Sampler,
        sky_lut_tex: Tex<'a>,
        sky_lut_sampler: &'a Sampler,
    ) -> Self {
        Self {
            transmittance_lut_tex,
            transmittance_lut_sampler,
            sky_lut_tex,
            sky_lut_sampler,
        }
    }

    pub fn sample(self, sun_dir: Vec3, ray_dir: Vec3) -> Vec3 {
        let mut lum = self.sample_sky_lut(ray_dir, sun_dir);
        let mut sun_lum = self.evaluate_bloom(ray_dir, sun_dir);

        sun_lum = self.interpolate_bloom(sun_lum);

        if sun_lum.length_squared() > 0.0 {
            let ray = Ray::new(Self::VIEW_POS, ray_dir);

            if ray.intersect_sphere(Self::GROUND_RADIUS_MM) >= 0.0 {
                sun_lum = Vec3::ZERO;
            } else {
                sun_lum *=
                    self.sample_transmittance_lut(Self::VIEW_POS, sun_dir);
            }
        }

        lum += sun_lum;
        lum *= Self::EXPOSURE;
        lum
    }

    fn sample_sky_lut(self, ray_dir: Vec3, sun_dir: Vec3) -> Vec3 {
        let height = Self::VIEW_POS.length();
        let up = Self::VIEW_POS / height;

        let horizon = {
            let t = height.sqr() - Self::GROUND_RADIUS_MM.sqr();
            let t = t.sqrt() / height;

            t.clamp(-1.0, 1.0).acos()
        };

        let altitude = horizon - ray_dir.dot(up).acos();

        let azimuth = if altitude.abs() > (0.5 * PI - 0.0001) {
            0.0
        } else {
            let right = sun_dir.cross(up);
            let forward = up.cross(right);

            let projected_dir = (ray_dir - up * ray_dir.dot(up)).normalize();
            let sin_theta = projected_dir.dot(right);
            let cos_theta = projected_dir.dot(forward);

            sin_theta.atan2(cos_theta) + PI
        };

        let uv = {
            let u = azimuth / (2.0 * PI);

            let v = 0.5
                + 0.5 * (altitude.abs() * 2.0 / PI).sqrt().copysign(altitude);

            vec2(u, v)
        };

        self.sky_lut_tex
            .sample_by_lod(*self.sky_lut_sampler, uv, 0.0)
            .xyz()
    }

    fn evaluate_bloom(self, ray_dir: Vec3, sun_dir: Vec3) -> Vec3 {
        const SUN_SOLID_ANGLE: f32 = 0.53 * PI / 180.0;

        let min_sun_cos_theta = SUN_SOLID_ANGLE.cos();
        let cos_theta = ray_dir.dot(sun_dir);

        if cos_theta >= min_sun_cos_theta {
            return Vec3::splat(1.0);
        }

        let offset = min_sun_cos_theta - cos_theta;
        let gaussian_bloom = (-offset * 50000.0).exp() * 0.5;
        let inv_bloom = 1.0 / (0.02 + offset * 300.0) * 0.01;

        Vec3::splat(gaussian_bloom + inv_bloom)
    }

    fn interpolate_bloom(self, bloom: Vec3) -> Vec3 {
        const MIN: Vec3 = Vec3::splat(0.002);
        const MAX: Vec3 = Vec3::splat(1.0);

        let t = ((bloom - MIN) / (MAX - MIN)).clamp(Vec3::ZERO, Vec3::ONE);

        t * t * (3.0 - 2.0 * t)
    }

    fn sample_transmittance_lut(self, pos: Vec3, sun_dir: Vec3) -> Vec3 {
        Self::sample_lut(
            self.transmittance_lut_tex,
            self.transmittance_lut_sampler,
            pos,
            sun_dir,
        )
    }

    pub fn sample_lut(
        lut_tex: Tex,
        lut_sampler: &Sampler,
        pos: Vec3,
        sun_dir: Vec3,
    ) -> Vec3 {
        let height = pos.length();
        let up = pos / height;
        let sun_cos_zenith_angle = sun_dir.dot(up);

        let uv = {
            let u = (0.5 + 0.5 * sun_cos_zenith_angle).saturate();

            let v = ((height - Self::GROUND_RADIUS_MM)
                / (Self::ATMOSPHERE_RADIUS_MM - Self::GROUND_RADIUS_MM))
                .saturate();

            vec2(u, v)
        };

        lut_tex.sample_by_lod(*lut_sampler, uv, 0.0).xyz()
    }
}

```

`strolle-gpu/src/brdf.rs`:

```rs
use core::f32::consts::PI;

use glam::{Vec3, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{F32Ext, GBufferEntry, WhiteNoise};

#[derive(Clone, Copy)]
pub struct DiffuseBrdf {
    gbuffer: GBufferEntry,
}

impl DiffuseBrdf {
    pub fn new(gbuffer: GBufferEntry) -> Self {
        Self { gbuffer }
    }

    // TODO separate eval_luma()
    pub fn eval(self) -> Vec3 {
        let Self { gbuffer } = self;

        gbuffer.base_color.xyz() * (1.0 - gbuffer.metallic) / PI
    }

    pub fn sample(self, wnoise: &mut WhiteNoise) -> BrdfSample {
        BrdfSample {
            dir: wnoise.sample_hemisphere(self.gbuffer.normal),
            pdf: 1.0 / PI,
            radiance: self.eval(),
        }
    }
}

#[derive(Clone, Copy)]
pub struct SpecularBrdf {
    gbuffer: GBufferEntry,
}

impl SpecularBrdf {
    pub fn new(gbuffer: GBufferEntry) -> Self {
        Self { gbuffer }
    }

    // TODO separate eval_luma()
    pub fn eval(self, l: Vec3, v: Vec3) -> Vec3 {
        let Self { gbuffer } = self;

        if gbuffer.metallic <= 0.0 {
            return Vec3::ZERO;
        }

        let a = gbuffer.clamped_roughness();
        let n = gbuffer.normal;
        let h = (l + v).normalize();
        let n_dot_l = n.dot(l).saturate();
        let n_dot_h = n.dot(h).saturate();
        let l_dot_h = l.dot(h).saturate();
        let n_dot_v = n.dot(v).saturate();

        if n_dot_l <= 0.0 || n_dot_v <= 0.0 {
            return Vec3::ZERO;
        }

        let d = ggx_distribution(n_dot_h, a);
        let g = ggx_schlick_masking_term(n_dot_l, n_dot_v, a);

        let f = {
            let f0 = 0.16
                * gbuffer.reflectance
                * gbuffer.reflectance
                * (1.0 - gbuffer.metallic)
                + gbuffer.base_color.xyz() * gbuffer.metallic;

            ggx_schlick_fresnel(f0, l_dot_h)
        };

        d * g * f / (4.0 * n_dot_l * n_dot_v)
    }

    // TODO implement VNDF
    pub fn sample(self, wnoise: &mut WhiteNoise, v: Vec3) -> BrdfSample {
        let Self { gbuffer } = self;

        let r0 = wnoise.sample();
        let r1 = wnoise.sample();

        let a = gbuffer.clamped_roughness();
        let n = gbuffer.normal;
        let a2 = a.sqr();
        let (b, t) = n.any_orthonormal_pair();

        let cos_theta = 0.0f32.max((1.0 - r0) / ((a2 - 1.0) * r0 + 1.0)).sqrt();
        let sin_theta = 0.0f32.max(1.0 - cos_theta * cos_theta).sqrt();

        let phi = r1 * PI * 2.0;

        let h = t * (sin_theta * phi.cos())
            + b * (sin_theta * phi.sin())
            + n * cos_theta;

        let n_dot_h = n.dot(h).saturate();
        let h_dot_v = h.dot(v).saturate();

        let dir = (2.0 * h_dot_v * h - v).normalize();
        let pdf = ggx_distribution(n_dot_h, a) * n_dot_h / (4.0 * h_dot_v);

        BrdfSample {
            dir,
            pdf,
            radiance: self.eval(dir, v),
        }
    }
}

pub struct LayeredBrdf {
    gbuffer: GBufferEntry,
}

impl LayeredBrdf {
    pub fn new(gbuffer: GBufferEntry) -> Self {
        Self { gbuffer }
    }

    pub fn sample(self, wnoise: &mut WhiteNoise, l: Vec3) -> BrdfSample {
        let Self { gbuffer } = self;
        let mut sample;

        if wnoise.sample() < gbuffer.metallic {
            sample = SpecularBrdf::new(gbuffer).sample(wnoise, l);
            sample.pdf /= gbuffer.metallic;
        } else {
            sample = DiffuseBrdf::new(gbuffer).sample(wnoise);
            sample.pdf /= 1.0 - gbuffer.metallic;
        }

        sample
    }
}

#[derive(Clone, Copy)]
pub struct BrdfSample {
    pub dir: Vec3,
    pub pdf: f32,
    pub radiance: Vec3,
}

impl BrdfSample {
    pub fn invalid() -> Self {
        Self {
            dir: Default::default(),
            pdf: Default::default(),
            radiance: Default::default(),
        }
    }

    pub fn is_invalid(self) -> bool {
        self.pdf == 0.0
    }
}

fn ggx_schlick_fresnel(f0: Vec3, l_dot_h: f32) -> Vec3 {
    let f90 = f0.dot(Vec3::splat(50.0 * 0.33)).saturate();

    f_schlick_vec(f0, f90, l_dot_h)
}

fn ggx_distribution(n_dot_h: f32, roughness: f32) -> f32 {
    let a2 = roughness * roughness;
    let d = (n_dot_h * a2 - n_dot_h) * n_dot_h + 1.0;

    a2 / (PI * d * d)
}

fn ggx_schlick_masking_term(n_dot_l: f32, n_dot_v: f32, roughness: f32) -> f32 {
    let k = roughness * roughness / 2.0;

    let g_v = n_dot_v / (n_dot_v * (1.0 - k) + k);
    let g_l = n_dot_l / (n_dot_l * (1.0 - k) + k);

    g_v * g_l
}

fn f_schlick_vec(f0: Vec3, f90: f32, v_dot_h: f32) -> Vec3 {
    f0 + (f90 - f0) * (1.0 - v_dot_h).max(0.001).powf(5.0)
}

```

`strolle-gpu/src/bvh_view.rs`:

```rs
use glam::Vec4;
use spirv_std::arch::IndexUnchecked;

#[derive(Clone, Copy)]
pub struct BvhView<'a> {
    buffer: &'a [Vec4],
}

impl<'a> BvhView<'a> {
    pub fn new(buffer: &'a [Vec4]) -> Self {
        Self { buffer }
    }

    pub fn get(self, ptr: u32) -> Vec4 {
        unsafe { *self.buffer.index_unchecked(ptr as usize) }
    }
}

```

`strolle-gpu/src/camera.rs`:

```rs
use bytemuck::{Pod, Zeroable};
use glam::{vec2, IVec2, Mat4, UVec2, Vec2, Vec3, Vec4, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::Ray;

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct Camera {
    pub projection_view: Mat4,
    pub ndc_to_world: Mat4,
    pub origin: Vec4,
    pub screen: Vec4,
}

impl Camera {
    /// Given a point in world-coordinates, returns it in clip-coordinates.
    pub fn world_to_clip(self, pos: Vec3) -> Vec4 {
        self.projection_view * pos.extend(1.0)
    }

    /// Given a point in world-coordinates, returns it in screen-coordinates.
    pub fn world_to_screen(self, pos: Vec3) -> Vec2 {
        self.clip_to_screen(self.world_to_clip(pos))
    }

    /// Given a point in clip-coordinates, returns it in screen-coordinates.
    pub fn clip_to_screen(self, pos: Vec4) -> Vec2 {
        let ndc = pos.xy() / pos.w;
        let ndc = vec2(ndc.x, -ndc.y);

        (0.5 * ndc + 0.5) * self.screen.xy()
    }

    /// Given a point in screen-coordinates, returns a unique index for it; used
    /// to index screen-space structures.
    pub fn screen_to_idx(self, pos: UVec2) -> usize {
        (pos.y * (self.screen.x as u32) + pos.x) as usize
    }

    /// Returns size of the camera's viewport in pixels.
    ///
    /// Note that camera's viewport's size might be different from the total
    /// window's size (e.g. user is free to create two separate cameras, each
    /// occupying half a screen - in that case this function will return that
    /// half-size).
    pub fn screen_size(self) -> UVec2 {
        self.screen.xy().as_uvec2()
    }

    /// Checks if given coordinates match camera's screen size and, if not,
    /// wraps them.
    ///
    /// See also: [`Self::contains()`].
    pub fn contain(self, mut pos: IVec2) -> UVec2 {
        let screen_size = self.screen.xy().as_ivec2();

        if pos.x < 0 {
            pos.x = -pos.x;
        }

        if pos.y < 0 {
            pos.y = -pos.y;
        }

        if pos.x >= screen_size.x {
            pos.x = screen_size.x - pos.x + screen_size.x - 1;
        }

        if pos.y >= screen_size.y {
            pos.y = screen_size.y - pos.y + screen_size.y - 1;
        }

        pos.as_uvec2()
    }

    /// Casts a ray from camera's center to given screen-coordinates.
    pub fn ray(self, screen_pos: UVec2) -> Ray {
        let screen_size = self.screen.xy();
        let screen_pos = screen_pos.as_vec2() + vec2(0.5, 0.5);

        let ndc = screen_pos * 2.0 / screen_size - Vec2::ONE;
        let ndc = vec2(ndc.x, -ndc.y);

        let far_plane =
            self.ndc_to_world.project_point3(ndc.extend(f32::EPSILON));

        let near_plane = self.ndc_to_world.project_point3(ndc.extend(1.0));

        Ray::new(near_plane, (far_plane - near_plane).normalize())
    }

    /// Returns camera's approximate origin, without taking into account the
    /// near-plane.
    ///
    /// Faster than `self.ray(...).origin()`, but somewhat less accurate.
    pub fn approx_origin(self) -> Vec3 {
        self.origin.xyz()
    }

    pub fn is_eq(self, rhs: Self) -> bool {
        self.projection_view
            .abs_diff_eq(rhs.projection_view, 0.0025)
    }
}

pub trait CameraContains<Rhs> {
    /// Returns whether given point lays inside the screen.
    ///
    /// See also: [`Camera::contain()`].
    fn contains(self, rhs: Rhs) -> bool;
}

impl CameraContains<UVec2> for Camera {
    fn contains(self, rhs: UVec2) -> bool {
        let screen_size = self.screen.xy().as_uvec2();

        rhs.x < screen_size.x && rhs.y < screen_size.y
    }
}

impl CameraContains<IVec2> for Camera {
    fn contains(self, rhs: IVec2) -> bool {
        let screen_size = self.screen.xy().as_ivec2();

        rhs.x >= 0
            && rhs.y >= 0
            && rhs.x < screen_size.x
            && rhs.y < screen_size.y
    }
}

impl CameraContains<Vec2> for Camera {
    fn contains(self, rhs: Vec2) -> bool {
        let screen_size = self.screen.xy();

        rhs.x >= 0.0
            && rhs.y >= 0.0
            && rhs.x < screen_size.x
            && rhs.y < screen_size.y
    }
}

#[cfg(test)]
mod tests {
    use glam::{ivec2, uvec2, vec4};

    use super::*;

    #[test]
    fn contain() {
        let target = Camera {
            projection_view: Default::default(),
            ndc_to_world: Default::default(),
            origin: Default::default(),
            screen: vec4(1024.0, 768.0, 0.0, 0.0),
        };

        // Case: minimum point inside the screen
        assert_eq!(target.contain(ivec2(0, 0)), uvec2(0, 0));

        // Case: point inside the screen
        assert_eq!(target.contain(ivec2(123, 456)), uvec2(123, 456));

        // Case: maximum point inside the screen
        assert_eq!(target.contain(ivec2(1023, 767)), uvec2(1023, 767));

        // Case: point outside the screen
        assert_eq!(target.contain(ivec2(1024, 768)), uvec2(1023, 767));
        assert_eq!(target.contain(ivec2(1025, 768)), uvec2(1022, 767));
        assert_eq!(target.contain(ivec2(1030, 768)), uvec2(1017, 767));
        assert_eq!(target.contain(ivec2(1030, 783)), uvec2(1017, 752));
    }
}

```

`strolle-gpu/src/frame.rs`:

```rs
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(
    Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Pod, Zeroable,
)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct Frame(u32);

impl Frame {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn get(self) -> u32 {
        self.0
    }

    pub fn is_gi_tracing(self) -> bool {
        self.0 % 6 < 4
    }

    pub fn is_gi_validation(self) -> bool {
        !self.is_gi_tracing()
    }
}

```

`strolle-gpu/src/gbuffer.rs`:

```rs
use glam::{vec4, Vec2, Vec3, Vec4, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{F32Ext, Normal, U32Ext};

#[derive(Clone, Copy, Default)]
pub struct GBufferEntry {
    pub base_color: Vec4,
    pub normal: Vec3,
    pub metallic: f32,
    pub emissive: Vec3,
    pub roughness: f32,
    pub reflectance: f32,
    pub depth: f32,
}

impl GBufferEntry {
    pub fn unpack([d0, d1]: [Vec4; 2]) -> Self {
        let depth = d0.x;
        let normal = Normal::decode(d0.yz());

        let (metallic, roughness, reflectance) = {
            let [metallic, roughness, reflectance, ..] =
                d0.w.to_bits().to_bytes();

            let metallic = metallic as f32 / 255.0;
            let roughness = (roughness as f32 / 255.0).sqr();
            let reflectance = reflectance as f32 / 255.0;

            (metallic, roughness, reflectance)
        };

        let emissive = d1.xyz();

        let base_color = {
            let [x, y, z, w] = d1.w.to_bits().to_bytes();

            vec4(
                x as f32 / 255.0,
                y as f32 / 255.0,
                z as f32 / 255.0,
                w as f32 / 63.0,
            )
            .powf(2.2)
        };

        Self {
            base_color,
            normal,
            metallic,
            emissive,
            roughness,
            reflectance,
            depth,
        }
    }

    pub fn pack(self) -> [Vec4; 2] {
        let d0 = {
            let x = self.depth;
            let Vec2 { x: y, y: z } = Normal::encode(self.normal);

            let w = {
                let metallic = self.metallic.clamp(0.0, 1.0) * 255.0;
                let roughness = self.roughness.sqrt().clamp(0.0, 1.0) * 255.0;
                let reflectance = self.reflectance.clamp(0.0, 1.0) * 255.0;

                f32::from_bits(u32::from_bytes([
                    metallic as u32,
                    roughness as u32,
                    reflectance as u32,
                    1,
                ]))
            };

            vec4(x, y, z, w)
        };

        let d1 = {
            // TODO doesn't need to use as much space
            let x = self.emissive.x;
            let y = self.emissive.y;
            let z = self.emissive.z;

            let w = {
                let base_color = self
                    .base_color
                    .powf(1.0 / 2.2)
                    .clamp(Vec4::ZERO, Vec4::ONE);

                let base_color = (vec4(
                    base_color.x * 255.0,
                    base_color.y * 255.0,
                    base_color.z * 255.0,
                    base_color.w * 63.0,
                ))
                .as_uvec4();

                f32::from_bits(u32::from_bytes([
                    base_color.x,
                    base_color.y,
                    base_color.z,
                    base_color.w,
                ]))
            };

            vec4(x, y, z, w)
        };

        [d0, d1]
    }

    pub fn is_some(self) -> bool {
        self.depth != Default::default()
    }

    pub fn clamped_roughness(self) -> f32 {
        self.roughness.clamp(0.089 * 0.089, 1.0)
    }
}

#[cfg(test)]
mod tests {
    use approx::assert_relative_eq;
    use glam::vec3;

    use super::*;

    const EPSILON: f32 = 0.005;

    #[test]
    fn serialization() {
        let target = GBufferEntry {
            base_color: vec4(0.1, 0.2, 0.3, 0.4),
            normal: vec3(0.26, 0.53, 0.80),
            metallic: 0.33,
            emissive: vec3(2.0, 3.0, 4.0),
            roughness: 0.05,
            reflectance: 0.25,
            depth: 123.456,
        };

        let target = GBufferEntry::unpack(target.pack());

        assert_relative_eq!(target.base_color.x, 0.1, epsilon = EPSILON);
        assert_relative_eq!(target.base_color.y, 0.2, epsilon = EPSILON);
        assert_relative_eq!(target.base_color.z, 0.3, epsilon = EPSILON);
        assert_relative_eq!(target.base_color.w, 0.4, epsilon = 0.1);

        assert_relative_eq!(target.normal.x, 0.26, epsilon = EPSILON);
        assert_relative_eq!(target.normal.y, 0.53, epsilon = EPSILON);
        assert_relative_eq!(target.normal.z, 0.80, epsilon = EPSILON);

        assert_relative_eq!(target.metallic, 0.33, epsilon = EPSILON);

        assert_relative_eq!(target.emissive.x, 2.0, epsilon = EPSILON);
        assert_relative_eq!(target.emissive.y, 3.0, epsilon = EPSILON);
        assert_relative_eq!(target.emissive.z, 4.0, epsilon = EPSILON);

        assert_relative_eq!(target.roughness, 0.05, epsilon = EPSILON);
        assert_relative_eq!(target.reflectance, 0.25, epsilon = EPSILON);
        assert_relative_eq!(target.depth, 123.456, epsilon = EPSILON);
    }
}

```

`strolle-gpu/src/hit.rs`:

```rs
use glam::{Vec2, Vec3, Vec4, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{GBufferEntry, MaterialId, Normal, Ray, Surface, Vec3Ext};

#[derive(Clone, Copy, Default)]
pub struct Hit {
    pub origin: Vec3,
    pub dir: Vec3,
    pub point: Vec3,
    pub gbuffer: GBufferEntry,
}

impl Hit {
    /// How far to move a hit point away from its surface to avoid
    /// self-intersection when casting shadow rays
    pub const NUDGE_OFFSET: f32 = 0.01;

    pub fn new(ray: Ray, gbuffer: GBufferEntry) -> Self {
        Self {
            origin: ray.origin(),
            dir: ray.dir(),
            point: ray.at(gbuffer.depth - Self::NUDGE_OFFSET),
            gbuffer,
        }
    }

    pub fn is_some(self) -> bool {
        self.gbuffer.is_some()
    }

    pub fn is_none(self) -> bool {
        !self.is_some()
    }

    pub fn as_surface(self) -> Surface {
        Surface {
            normal: self.gbuffer.normal,
            depth: self.gbuffer.depth,
            roughness: self.gbuffer.roughness,
        }
    }

    pub fn kernel_basis(
        normal: Vec3,
        direction: Vec3,
        roughness: f32,
        size: f32,
    ) -> (Vec3, Vec3) {
        fn dominant_direction(n: Vec3, v: Vec3, roughness: f32) -> Vec3 {
            let f = (1.0 - roughness) * ((1.0 - roughness).sqrt() + roughness);
            let r = (-v).reflect(n);

            n.lerp(r, f).normalize()
        }

        let t;
        let b;

        if roughness == 1.0 {
            (t, b) = normal.any_orthonormal_pair();
        } else {
            let d = dominant_direction(normal, -direction, roughness);
            let r = (-d).reflect(normal);

            t = normal.cross(r).normalize();
            b = r.cross(t);
        }

        (t * size, b * size)
    }
}

#[derive(Clone, Copy)]
pub struct TriangleHit {
    pub distance: f32,
    pub point: Vec3,
    pub normal: Vec3,
    pub uv: Vec2,
    pub material_id: MaterialId,
}

impl TriangleHit {
    pub fn none() -> Self {
        Self {
            distance: f32::MAX,
            point: Default::default(),
            normal: Default::default(),
            uv: Default::default(),
            material_id: MaterialId::new(0),
        }
    }

    pub fn unpack([d0, d1]: [Vec4; 2]) -> Self {
        if d0.xyz() == Default::default() {
            Self::none()
        } else {
            let normal = Normal::decode(d1.xy());
            let point = d0.xyz();

            Self {
                distance: 0.0,
                point,
                normal,
                uv: d1.zw(),
                material_id: MaterialId::new(d0.w.to_bits()),
            }
        }
    }

    pub fn pack(self) -> [Vec4; 2] {
        let d0 = self.point.extend(f32::from_bits(self.material_id.get()));

        let d1 = Normal::encode(self.normal)
            .extend(self.uv.x)
            .extend(self.uv.y);

        [d0, d1]
    }

    pub fn is_some(self) -> bool {
        self.distance < f32::MAX
    }

    pub fn is_none(self) -> bool {
        !self.is_some()
    }
}

```

`strolle-gpu/src/lib.rs`:

```rs
//! Common structs, algorithms etc. used by Strolle's shaders and renderer.

#![cfg_attr(target_arch = "spirv", no_std)]
#![allow(clippy::len_without_is_empty)]
#![allow(clippy::manual_range_contains)]
#![allow(clippy::too_many_arguments)]

mod atmosphere;
mod brdf;
mod bvh_view;
mod camera;
mod frame;
mod gbuffer;
mod hit;
mod light;
mod lights;
mod material;
mod materials;
mod noise;
mod normal;
mod passes;
mod ray;
mod reprojection;
mod reservoir;
mod surface;
mod triangle;
mod triangles;
mod utils;
mod world;

pub use self::atmosphere::*;
pub use self::brdf::*;
pub use self::bvh_view::*;
pub use self::camera::*;
pub use self::frame::*;
pub use self::gbuffer::*;
pub use self::hit::*;
pub use self::light::*;
pub use self::lights::*;
pub use self::material::*;
pub use self::materials::*;
pub use self::noise::*;
pub use self::normal::*;
pub use self::passes::*;
pub use self::ray::*;
pub use self::reprojection::*;
pub use self::reservoir::*;
pub use self::surface::*;
pub use self::triangle::*;
pub use self::triangles::*;
pub use self::utils::*;
pub use self::world::*;

pub mod prelude {
    pub use core::f32::consts::PI;

    pub use spirv_std::arch::IndexUnchecked;
    pub use spirv_std::glam::*;
    #[cfg(target_arch = "spirv")]
    pub use spirv_std::num_traits::Float;
    pub use spirv_std::{spirv, Image, Sampler};

    pub use crate::*;
}

/// Stack for nodes yet-to-be-visited when traversing the BVH.
///
/// For performance reasons, we use a per-workgroup shared-memory array where
/// each workgroup-thread simply indexes into a different slice of this memory.
pub type BvhStack<'a> = &'a mut [u32; BVH_STACK_SIZE * 8 * 8];

/// Maximum stack size per each workgroup-thread when traversing the BVH.
///
/// Affects the maximum size of BVH tree (it must not grow larger than
/// `2 ^ BVH_STACK_SIZE`).
pub const BVH_STACK_SIZE: usize = 24;

/// Golden angle, used for spatial filters.
pub const GOLDEN_ANGLE: f32 = 2.39996;

```

`strolle-gpu/src/light.rs`:

```rs
use core::f32::consts::PI;
use core::ops::Mul;

use bytemuck::{Pod, Zeroable};
use glam::{vec2, vec4, Vec2, Vec3, Vec4, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{
    DiffuseBrdf, F32Ext, Hit, Normal, Ray, SpecularBrdf, Vec3Ext, WhiteNoise,
};

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct Light {
    /// x - position x
    /// y - position y
    /// z - position z
    /// w - radius
    pub d0: Vec4,

    /// x - color r
    /// y - color g
    /// z - color b
    /// w - range
    pub d1: Vec4,

    /// x - (as u32) light type
    /// y - if it's a spot light: direction
    /// z - if it's a spot light: direction
    /// w - if it's a spot light: angle
    pub d2: Vec4,

    /// x - (as u32) see the "slot" functions below
    pub d3: Vec4,

    // Light's data from the previous frame
    pub prev_d0: Vec4,
    pub prev_d1: Vec4,
    pub prev_d2: Vec4,
}

impl Light {
    pub const TYPE_NONE: u32 = 0;
    pub const TYPE_POINT: u32 = 1;
    pub const TYPE_SPOT: u32 = 2;

    pub fn sun(position: Vec3, color: Vec3) -> Self {
        Self {
            // TODO incorrect
            d0: position.extend(25.0),
            d1: color.extend(f32::INFINITY),
            d2: vec4(
                f32::from_bits(Self::TYPE_POINT),
                Default::default(),
                Default::default(),
                Default::default(),
            ),
            d3: Default::default(),
            prev_d0: Default::default(),
            prev_d1: Default::default(),
            prev_d2: Default::default(),
        }
    }

    pub fn center(self) -> Vec3 {
        self.d0.xyz()
    }

    pub fn radius(self) -> f32 {
        self.d0.w
    }

    pub fn color(self) -> Vec3 {
        self.d1.xyz()
    }

    pub fn range(self) -> f32 {
        self.d1.w
    }

    pub fn contains(self, point: Vec3) -> bool {
        self.center().distance(point) <= self.radius()
    }

    fn ty(self) -> u32 {
        self.d2.x.to_bits()
    }

    pub fn is_none(self) -> bool {
        self.ty() == Self::TYPE_NONE
    }

    pub fn is_point(self) -> bool {
        self.ty() == Self::TYPE_POINT
    }

    pub fn spot_dir(self) -> Vec3 {
        Normal::decode(self.d2.yz())
    }

    pub fn spot_angle(self) -> f32 {
        self.d2.w
    }

    pub fn is_slot_remapped(self) -> bool {
        self.d3.x.to_bits() > 0 && self.d3.x.to_bits() != 0xcafebabe
    }

    pub fn slot_remapped_to(self) -> LightId {
        LightId::new(self.d3.x.to_bits() - 1)
    }

    pub fn remap_slot(&mut self, id: LightId) {
        self.d3.x = f32::from_bits(id.get() + 1);
    }

    pub fn is_slot_killed(self) -> bool {
        self.d3.x.to_bits() == 0xcafebabe
    }

    pub fn kill_slot(&mut self) {
        self.d3.x = f32::from_bits(0xcafebabe);
    }

    pub fn clear_slot(&mut self) {
        self.d3.x = f32::from_bits(0);
    }

    pub fn commit(&mut self) {
        self.prev_d0 = self.d0;
        self.prev_d1 = self.d1;
        self.prev_d2 = self.d2;
    }

    pub fn rollback(&mut self) {
        self.d0 = self.prev_d0;
        self.d1 = self.prev_d1;
        self.d2 = self.prev_d2;
    }

    pub fn radiance(self, hit: Hit) -> LightRadiance {
        let l = self.center() - hit.point;

        let f_angle = if self.is_point() {
            1.0
        } else {
            let angle =
                self.spot_dir().angle_between(hit.point - self.center());

            (1.0 - (angle / self.spot_angle()).powf(3.0)).saturate()
        };

        let f_dist = if self.range() == f32::INFINITY {
            1.0
        } else {
            let l2 = l.length_squared();
            let inv_r2 = 1.0 / self.range().sqr();

            let factor = l2 * inv_r2;
            let smooth_factor = (1.0 - factor * factor).saturate();
            let attenuation = smooth_factor * smooth_factor;

            attenuation / l2.max(0.0001)
        };

        let f_cosine = hit.gbuffer.normal.dot(l.normalize()).saturate();

        let diff_brdf = DiffuseBrdf::new(hit.gbuffer).eval();

        let spec_brdf = {
            let v = -hit.dir;
            let n = hit.gbuffer.normal;
            let r = (-v).reflect(n);

            let center_to_ray = l.dot(r) * r - l;

            let closest_point = {
                let t = self.radius()
                    * center_to_ray.dot(center_to_ray).inverse_sqrt();

                l + center_to_ray * t.saturate()
            };

            let l_spec_length_inverse =
                closest_point.dot(closest_point).inverse_sqrt();

            let i_roughness = {
                let t = hit.gbuffer.clamped_roughness()
                    + self.radius() * 0.5 * l_spec_length_inverse;

                hit.gbuffer.clamped_roughness() / t.saturate()
            };

            let intensity = i_roughness.sqr();
            let l = closest_point * l_spec_length_inverse;

            intensity * SpecularBrdf::new(hit.gbuffer).eval(l, v)
        };

        LightRadiance {
            radiance: self.color() * f_angle * f_dist * f_cosine,
            diff_brdf,
            spec_brdf,
        }
    }

    pub fn ray_wnoise(self, noise: &mut WhiteNoise, hit_point: Vec3) -> Ray {
        let light_pos = self.center() + self.radius() * noise.sample_sphere();
        let light_to_hit = hit_point - light_pos;

        Ray::new(light_pos, light_to_hit.normalize())
            .with_len(light_to_hit.length())
    }

    pub fn ray_bnoise(self, sample: Vec2, hit_point: Vec3) -> Ray {
        let to_light = self.center() - hit_point;
        let light_dir = to_light.normalize();
        let light_distance = to_light.length();
        let light_radius = self.radius() / light_distance;
        let (light_tangent, light_bitangent) = light_dir.any_orthonormal_pair();

        let disk_point = {
            let angle = 2.0 * PI * sample.x;
            let radius = sample.y.sqrt();

            vec2(angle.sin(), angle.cos()) * radius * light_radius
        };

        let ray_dir = light_dir
            + disk_point.x * light_tangent
            + disk_point.y * light_bitangent;

        let ray_dir = ray_dir.normalize();

        Ray::new(hit_point + ray_dir * light_distance, -ray_dir)
            .with_len(light_distance)
    }
}

#[derive(Clone, Copy, Default, PartialEq, Eq, Hash)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct LightId(u32);

impl LightId {
    pub const fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn sky() -> Self {
        Self::new(u32::MAX)
    }

    pub fn get(self) -> u32 {
        self.0
    }

    #[cfg(not(target_arch = "spirv"))]
    pub fn get_mut(&mut self) -> &mut u32 {
        &mut self.0
    }
}

#[derive(Clone, Copy, Default)]
pub struct LightRadiance {
    pub radiance: Vec3,
    pub diff_brdf: Vec3,
    pub spec_brdf: Vec3,
}

impl LightRadiance {
    pub fn sum(self) -> Vec3 {
        self.radiance * (self.diff_brdf + self.spec_brdf)
    }
}

impl Mul<f32> for LightRadiance {
    type Output = Self;

    fn mul(mut self, rhs: f32) -> Self::Output {
        self.radiance *= rhs;
        self
    }
}

```

`strolle-gpu/src/lights.rs`:

```rs
use spirv_std::arch::IndexUnchecked;

use crate::{Light, LightId};

#[derive(Clone, Copy)]
pub struct LightsView<'a> {
    items: &'a [Light],
}

impl<'a> LightsView<'a> {
    pub fn new(items: &'a [Light]) -> Self {
        Self { items }
    }

    pub fn get(self, id: LightId) -> Light {
        unsafe { *self.items.index_unchecked(id.get() as usize) }
    }

    pub fn get_prev(self, id: LightId) -> Light {
        let mut light = self.get(id);

        light.rollback();
        light
    }

    pub fn len(self) -> usize {
        self.items.len()
    }
}

```

`strolle-gpu/src/material.rs`:

```rs
use bytemuck::{Pod, Zeroable};
use glam::{Vec2, Vec3, Vec4, Vec4Swizzles};
use spirv_std::Sampler;

use crate::Tex;

#[repr(C)]
#[derive(Clone, Copy, PartialEq, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct Material {
    pub base_color: Vec4,
    pub base_color_texture: Vec4,
    pub emissive: Vec4,
    pub emissive_texture: Vec4,
    pub roughness: f32,
    pub metallic: f32,
    pub reflectance: f32,
    pub ior: f32,
    pub metallic_roughness_texture: Vec4,
    pub normal_map_texture: Vec4,
}

impl Material {
    /// Adjusts material so that it's ready for computing indirect lighting.
    pub fn regularize(&mut self) {
        self.roughness = self.roughness.max(0.75 * 0.75);
    }

    pub fn base_color(
        self,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
        hit_uv: Vec2,
    ) -> Vec4 {
        Self::sample_atlas(
            atlas_tex,
            atlas_sampler,
            hit_uv,
            self.base_color,
            self.base_color_texture,
        )
    }

    pub fn metallic_roughness(
        self,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
        hit_uv: Vec2,
    ) -> Vec2 {
        Self::sample_atlas(
            atlas_tex,
            atlas_sampler,
            hit_uv,
            Vec4::new(1.0, self.roughness, self.metallic, 1.0),
            self.metallic_roughness_texture,
        )
        .zy()
    }

    pub fn emissive(
        self,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
        hit_uv: Vec2,
    ) -> Vec3 {
        Self::sample_atlas(
            atlas_tex,
            atlas_sampler,
            hit_uv,
            self.emissive,
            self.emissive_texture,
        )
        .xyz()
    }

    fn sample_atlas(
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
        mut hit_uv: Vec2,
        multiplier: Vec4,
        texture: Vec4,
    ) -> Vec4 {
        // TODO this assumes the texture's sampler is configured to U/V-repeat
        //      which might not be the case; we should propagate sampler info up
        //      to here and decide
        let wrap = |t: f32| {
            if t > 0.0 {
                t % 1.0
            } else {
                1.0 - (-t % 1.0)
            }
        };

        if texture == Vec4::ZERO {
            multiplier
        } else {
            hit_uv.x = wrap(hit_uv.x);
            hit_uv.y = wrap(hit_uv.y);

            let uv = texture.xy() + hit_uv * texture.zw();

            multiplier * atlas_tex.sample_by_lod(*atlas_sampler, uv, 0.0)
        }
    }

    // TODO bring back
    //
    // pub fn normal(
    //     &self,
    //     hit_uv: Vec2,
    //     hit_normal: Vec3,
    //     hit_tangent: Vec4,
    // ) -> Vec3 {
    //     if self.normal_map_texture == u32::MAX {
    //         hit_normal
    //     } else {
    //         let normal_map_tex = unsafe {
    //             images.index_unchecked(self.normal_map_texture as usize)
    //         };

    //         let normal_map_sampler = unsafe {
    //             samplers.index_unchecked(self.normal_map_texture as usize)
    //         };

    //         let tangent = hit_tangent.xyz();
    //         let bitangent = hit_tangent.w * hit_normal.cross(tangent);

    //         let mapped_normal =
    //             normal_map_tex.sample(*normal_map_sampler, hit_uv);

    //         let mapped_normal = 2.0 * mapped_normal - 1.0;

    //         (mapped_normal.x * tangent
    //             + mapped_normal.y * bitangent
    //             + mapped_normal.z * hit_normal)
    //             .normalize()
    //     }
    // }
}

#[derive(Clone, Copy)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug, PartialEq))]
pub struct MaterialId(u32);

impl MaterialId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn get(self) -> u32 {
        self.0
    }
}

```

`strolle-gpu/src/materials.rs`:

```rs
use spirv_std::arch::IndexUnchecked;

use crate::{Material, MaterialId};

#[derive(Clone, Copy)]
pub struct MaterialsView<'a> {
    items: &'a [Material],
}

impl<'a> MaterialsView<'a> {
    pub fn new(items: &'a [Material]) -> Self {
        Self { items }
    }

    pub fn get(self, id: MaterialId) -> Material {
        unsafe { *self.items.index_unchecked(id.get() as usize) }
    }
}

```

`strolle-gpu/src/noise.rs`:

```rs
mod blue;
mod white;

pub use self::blue::*;
pub use self::white::*;

```

`strolle-gpu/src/noise/blue.rs`:

```rs
use glam::{uvec2, UVec2, Vec2, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{Frame, TexRgba8};

pub struct BlueNoise<'a> {
    tex: TexRgba8<'a>,
    uv: UVec2,
}

impl<'a> BlueNoise<'a> {
    pub const SIZE: UVec2 = uvec2(256, 256);

    pub fn new(tex: TexRgba8<'a>, id: UVec2, frame: Frame) -> Self {
        let uv = (id + uvec2(71, 11) * frame.get()) % Self::SIZE;

        Self { tex, uv }
    }

    pub fn first_sample(self) -> Vec2 {
        self.tex.read(self.uv).xy()
    }

    pub fn second_sample(self) -> Vec2 {
        self.tex.read(self.uv).zw()
    }
}

```

`strolle-gpu/src/noise/white.rs`:

```rs
use core::f32::consts::PI;

use glam::{vec2, vec3, UVec2, Vec2, Vec3};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::F32Ext;

#[derive(Clone, Copy)]
pub struct WhiteNoise {
    state: u32,
}

impl WhiteNoise {
    pub fn new(seed: u32, id: UVec2) -> Self {
        Self {
            state: seed ^ (48619 * id.x) ^ (95461 * id.y),
        }
    }

    pub fn from_state(state: u32) -> Self {
        Self { state }
    }

    pub fn state(self) -> u32 {
        self.state
    }

    /// Generates a uniform sample in range `<0.0, 1.0>`.
    pub fn sample(&mut self) -> f32 {
        (self.sample_int() as f32) / (u32::MAX as f32)
    }

    /// Generates a uniform sample in range `<0, u32::MAX>`.
    pub fn sample_int(&mut self) -> u32 {
        self.state = self.state * 747796405 + 2891336453;

        let word =
            ((self.state >> ((self.state >> 28) + 4)) ^ self.state) * 277803737;

        (word >> 22) ^ word
    }

    /// Generates a uniform sample on a circle.
    pub fn sample_circle(&mut self) -> Vec2 {
        let angle = self.sample() * PI * 2.0;

        vec2(angle.cos(), angle.sin())
    }

    /// Generates a uniform sample inside of a disk.
    pub fn sample_disk(&mut self) -> Vec2 {
        let radius = self.sample().sqrt();

        self.sample_circle() * radius
    }

    /// Generates a uniform sample on a sphere.
    pub fn sample_sphere(&mut self) -> Vec3 {
        let phi = self.sample() * 2.0 * PI;
        let cos_theta = self.sample() * 2.0 - 1.0;
        let u = self.sample();

        let theta = cos_theta.acos();
        let r = u.sqrt();

        vec3(
            r * theta.sin() * phi.cos(),
            r * theta.sin() * phi.sin(),
            r * theta.cos(),
        )
    }

    /// Generates a uniform sample on a hemisphere around given normal.
    pub fn sample_hemisphere(&mut self, normal: Vec3) -> Vec3 {
        let cos_theta = self.sample();
        let sin_theta = (1.0f32 - cos_theta.sqr()).sqrt();
        let phi = 2.0 * PI * self.sample();
        let (t, b) = normal.any_orthonormal_pair();

        (t * phi.cos() + b * phi.sin()) * sin_theta + normal * cos_theta
    }
}

```

`strolle-gpu/src/normal.rs`:

```rs
use glam::{vec3, Vec2, Vec3, Vec3Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

pub struct Normal;

impl Normal {
    /// Compresses normal from Vec3 into Vec2 using octahedron-normal mapping.
    pub fn encode(n: Vec3) -> Vec2 {
        let n = n / (n.x.abs() + n.y.abs() + n.z.abs());

        let n = if n.z >= 0.0 {
            n.xy()
        } else {
            let mut t = 1.0 - n.yx().abs();

            t.x = t.x.copysign(n.x);
            t.y = t.y.copysign(n.y);
            t
        };

        n * 0.5 + 0.5
    }

    /// See: [`Self::encode()`].
    pub fn decode(n: Vec2) -> Vec3 {
        let n = n * 2.0 - 1.0;
        let mut n = vec3(n.x, n.y, 1.0 - n.x.abs() - n.y.abs());
        let t = (-n.z).max(0.0);

        n.x -= t.copysign(n.x);
        n.y -= t.copysign(n.y);
        n.normalize()
    }
}

```

`strolle-gpu/src/passes.rs`:

```rs
use bytemuck::{Pod, Zeroable};
use glam::{vec3a, vec4, Affine3A, Mat3A, Vec4};

use crate::Frame;

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct PassParams {
    pub seed: u32,
    pub frame: Frame,
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct PrimRasterPassParams {
    pub payload: Vec4,
    pub curr_xform_inv_d0: Vec4,
    pub curr_xform_inv_d1: Vec4,
    pub curr_xform_inv_d2: Vec4,
    pub prev_xform_d0: Vec4,
    pub prev_xform_d1: Vec4,
    pub prev_xform_d2: Vec4,
}

impl PrimRasterPassParams {
    pub fn instance_uuid(self) -> u32 {
        self.payload.x.to_bits()
    }

    pub fn material_id(self) -> u32 {
        self.payload.y.to_bits()
    }

    pub fn curr_xform_inv(self) -> Affine3A {
        Self::decode_affine([
            self.curr_xform_inv_d0,
            self.curr_xform_inv_d1,
            self.curr_xform_inv_d2,
        ])
    }

    pub fn prev_xform(self) -> Affine3A {
        Self::decode_affine([
            self.prev_xform_d0,
            self.prev_xform_d1,
            self.prev_xform_d2,
        ])
    }

    /// Encodes a 3D affine transformation as three Vec4s; we use this to
    /// overcome padding issues when copying data from CPU into GPU.
    pub fn encode_affine(xform: Affine3A) -> [Vec4; 3] {
        let d0 = vec4(
            xform.matrix3.x_axis.x,
            xform.matrix3.x_axis.y,
            xform.matrix3.x_axis.z,
            xform.translation.x,
        );

        let d1 = vec4(
            xform.matrix3.y_axis.x,
            xform.matrix3.y_axis.y,
            xform.matrix3.y_axis.z,
            xform.translation.y,
        );

        let d2 = vec4(
            xform.matrix3.z_axis.x,
            xform.matrix3.z_axis.y,
            xform.matrix3.z_axis.z,
            xform.translation.z,
        );

        [d0, d1, d2]
    }

    /// See: [`Self::encode_affine()`].
    pub fn decode_affine([d0, d1, d2]: [Vec4; 3]) -> Affine3A {
        Affine3A {
            matrix3: Mat3A {
                x_axis: vec3a(d0.x, d0.y, d0.z),
                y_axis: vec3a(d1.x, d1.y, d1.z),
                z_axis: vec3a(d2.x, d2.y, d2.z),
            },
            translation: vec3a(d0.w, d1.w, d2.w),
        }
    }
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct FrameDenoisingWaveletPassParams {
    pub frame: Frame,
    pub stride: u32,
    pub strength: f32,
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct FrameCompositionPassParams {
    pub camera_mode: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct RefPassParams {
    pub seed: u32,
    pub frame: Frame,
    pub depth: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct GiPreviewResamplingPass {
    pub seed: u32,
    pub frame: Frame,
    pub source: u32,
    pub nth: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct GiResolvingPassParams {
    pub frame: Frame,
    pub source: u32,
}

```

`strolle-gpu/src/ray.rs`:

```rs
use core::mem;

use glam::{Vec3, Vec4, Vec4Swizzles};
use spirv_std::arch::IndexUnchecked;
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;
use spirv_std::Sampler;

use crate::{
    BvhStack, BvhView, Material, MaterialId, MaterialsView, Tex, Triangle,
    TriangleHit, TriangleId, TrianglesView, BVH_STACK_SIZE,
};

#[derive(Clone, Copy, Default, PartialEq)]
pub struct Ray {
    origin: Vec3,
    dir: Vec3,
    inv_dir: Vec3,
    len: f32,
}

impl Ray {
    pub fn new(origin: Vec3, dir: Vec3) -> Self {
        Self {
            origin,
            dir,
            inv_dir: 1.0 / dir,
            len: f32::MAX,
        }
    }

    pub fn with_len(mut self, len: f32) -> Self {
        self.len = len;
        self
    }

    pub fn origin(self) -> Vec3 {
        self.origin
    }

    pub fn dir(self) -> Vec3 {
        self.dir
    }

    pub fn len(self) -> f32 {
        self.len
    }

    pub fn at(self, depth: f32) -> Vec3 {
        self.origin + self.dir * depth
    }

    /// Returns the closest opaque intersection of this ray with the world, if
    /// any.
    pub fn trace(
        self,
        local_idx: u32,
        stack: BvhStack,
        triangles: TrianglesView,
        bvh: BvhView,
        materials: MaterialsView,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
    ) -> (TriangleHit, usize) {
        let mut hit = TriangleHit::none();

        let used_memory = self.traverse(
            local_idx,
            stack,
            triangles,
            bvh,
            materials,
            atlas_tex,
            atlas_sampler,
            Tracing::ReturnClosest,
            &mut hit,
        );

        (hit, used_memory)
    }

    /// Returns whether this ray intersects with anything in the world; used for
    /// shadow rays.
    pub fn intersect(
        self,
        local_idx: u32,
        stack: BvhStack,
        triangles: TrianglesView,
        bvh: BvhView,
        materials: MaterialsView,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
    ) -> bool {
        let mut hit = TriangleHit {
            distance: self.len,
            ..TriangleHit::none()
        };

        self.traverse(
            local_idx,
            stack,
            triangles,
            bvh,
            materials,
            atlas_tex,
            atlas_sampler,
            Tracing::ReturnFirst,
            &mut hit,
        );

        hit.distance < self.len
    }

    fn traverse(
        self,
        local_idx: u32,
        stack: BvhStack,
        triangles: TrianglesView,
        bvh: BvhView,
        materials: MaterialsView,
        atlas_tex: Tex,
        atlas_sampler: &Sampler,
        tracing: Tracing,
        hit: &mut TriangleHit,
    ) -> usize {
        // An estimation of the memory used when travelling the BVH; useful for
        // debugging
        let mut used_memory = 0;

        // Index into the `bvh` array; points at the currently processed node
        let mut bvh_ptr = 0;

        // Where this particular thread's stack starts at; see `BvhStack`
        let stack_begins_at = (local_idx as usize) * BVH_STACK_SIZE;

        // Index into the `stack` array; our stack spans from here up to +
        // BVH_STACK_SIZE items
        let mut stack_ptr = stack_begins_at;

        loop {
            used_memory += mem::size_of::<Vec4>();

            let d0 = bvh.get(bvh_ptr);
            let is_internal_node = d0.w.to_bits() == 0;

            if is_internal_node {
                used_memory += 3 * mem::size_of::<Vec4>();

                let d1 = bvh.get(bvh_ptr + 1);
                let d2 = bvh.get(bvh_ptr + 2);
                let d3 = bvh.get(bvh_ptr + 3);

                let mut near_ptr = bvh_ptr + 4;
                let mut far_ptr = d1.w.to_bits();

                let mut near_distance = self.intersect_box(d0.xyz(), d1.xyz());
                let mut far_distance = self.intersect_box(d2.xyz(), d3.xyz());

                if far_distance < near_distance {
                    mem::swap(&mut near_ptr, &mut far_ptr);
                    mem::swap(&mut near_distance, &mut far_distance);
                }

                // If the nearest child is closer than our current best shot,
                // let's check that child first; use stack to save the other
                // node for later.
                //
                // The reasoning here goes that the closer child is more likely
                // to contain a triangle we can hit; but if we don't hit that
                // triangle (kind of a "cache miss" kind of thing), we still
                // have to check the other node.
                if far_distance < hit.distance {
                    unsafe {
                        *stack.index_unchecked_mut(stack_ptr) = far_ptr;
                        stack_ptr += 1;
                    }
                }

                if near_distance < hit.distance {
                    bvh_ptr = near_ptr;
                    continue;
                }
            } else {
                used_memory += mem::size_of::<Triangle>();

                let flags = d0.x.to_bits();

                // Whether there are any more triangles directly following this
                // triangle.
                //
                // This corresponds to a single BVH leaf node containing
                // multiple triangles.
                let got_more_triangles = flags & 1 == 1;

                // Whether the triangle we're looking at supports alpha
                // blending.
                //
                // If this is turned on, we have to load the triangle's material
                // and compute albedo to make sure that the part of triangle we
                // hit is actually opaque at that particular hit-point.
                let has_alpha_blending = flags & 2 == 2;

                let triangle_id = TriangleId::new(d0.y.to_bits());
                let material_id = MaterialId::new(d0.z.to_bits());

                let prev_uv = hit.uv;
                let prev_normal = hit.normal;
                let prev_distance = hit.distance;

                let mut found_hit = triangles.get(triangle_id).hit(self, hit);

                if found_hit && has_alpha_blending {
                    used_memory += mem::size_of::<Material>();
                    used_memory += mem::size_of::<Vec4>();

                    let base_color = materials.get(material_id).base_color(
                        atlas_tex,
                        atlas_sampler,
                        hit.uv,
                    );

                    if base_color.w < 1.0 {
                        found_hit = false;

                        hit.uv = prev_uv;
                        hit.normal = prev_normal;
                        hit.distance = prev_distance;
                    }
                }

                if found_hit {
                    hit.material_id = material_id;

                    if let Tracing::ReturnFirst = tracing {
                        break;
                    }
                }

                if got_more_triangles {
                    bvh_ptr += 1;
                    continue;
                }
            }

            // If the control flow got here, then it means we either tested a
            // leaf-node or tested an internal-node and got a miss.
            //
            // In any case, now it's the time to pop the next node from the
            // stack and investigate it; if the stack is empty, then we've
            // tested all nodes and we can safely bail out.
            if stack_ptr > stack_begins_at {
                unsafe {
                    stack_ptr -= 1;
                    bvh_ptr = *stack.index_unchecked(stack_ptr);
                }
            } else {
                break;
            }
        }

        if hit.is_some() {
            hit.point = self.at(hit.distance);
        }

        used_memory
    }

    /// Checks whether this ray hits given bounding-box and returns their
    /// nearest intersection distance.
    ///
    /// Thanks to:
    /// https://tavianator.com/2022/ray_box_boundary.html
    pub fn intersect_box(self, aabb_min: Vec3, aabb_max: Vec3) -> f32 {
        fn min(x: f32, y: f32) -> f32 {
            x.min(y)
        }

        fn max(x: f32, y: f32) -> f32 {
            x.max(y)
        }

        let mut tmin = 0.0;
        let mut tmax = f32::MAX;

        let t1 = (aabb_min - self.origin) * self.inv_dir;
        let t2 = (aabb_max - self.origin) * self.inv_dir;

        tmin = max(tmin, min(t1.x, t2.x));
        tmax = min(tmax, max(t1.x, t2.x));

        tmin = max(tmin, min(t1.y, t2.y));
        tmax = min(tmax, max(t1.y, t2.y));

        tmin = max(tmin, min(t1.z, t2.z));
        tmax = min(tmax, max(t1.z, t2.z));

        if tmin <= tmax {
            tmin
        } else {
            f32::MAX
        }
    }

    pub fn intersect_sphere(self, radius: f32) -> f32 {
        let b = self.origin.dot(self.dir);
        let c = self.origin.dot(self.origin) - radius * radius;

        if c > 0.0 && b > 0.0 {
            return -1.0;
        }

        let discr = b * b - c;

        if discr < 0.0 {
            -1.0
        } else if discr > b * b {
            -b + discr.sqrt()
        } else {
            -b - discr.sqrt()
        }
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
enum Tracing {
    ReturnClosest,
    ReturnFirst,
}

```

`strolle-gpu/src/reprojection.rs`:

```rs
use glam::{vec2, vec4, UVec2, Vec2, Vec4};

use crate::TexRgba32;

#[derive(Clone, Copy, Default)]
pub struct Reprojection {
    pub prev_x: f32,
    pub prev_y: f32,
    pub confidence: f32,
    pub validity: u32,
}

impl Reprojection {
    pub fn serialize(self) -> Vec4 {
        vec4(
            self.prev_x,
            self.prev_y,
            self.confidence,
            f32::from_bits(self.validity),
        )
    }

    pub fn deserialize(d0: Vec4) -> Self {
        Self {
            prev_x: d0.x,
            prev_y: d0.y,
            confidence: d0.z,
            validity: d0.w.to_bits(),
        }
    }

    pub fn is_some(self) -> bool {
        self.confidence > 0.0
    }

    pub fn is_none(self) -> bool {
        !self.is_some()
    }

    pub fn prev_pos(self) -> Vec2 {
        vec2(self.prev_x, self.prev_y)
    }

    pub fn prev_pos_round(self) -> UVec2 {
        self.prev_pos().round().as_uvec2()
    }

    pub fn prev_pos_fract(self) -> Vec2 {
        self.prev_pos().fract()
    }

    pub fn is_exact(self) -> bool {
        self.prev_pos_fract().length_squared() == 0.0
    }
}

pub struct ReprojectionMap<'a> {
    tex: TexRgba32<'a>,
}

impl<'a> ReprojectionMap<'a> {
    pub fn new(tex: TexRgba32<'a>) -> Self {
        Self { tex }
    }

    pub fn get(self, screen_pos: UVec2) -> Reprojection {
        Reprojection::deserialize(self.tex.read(screen_pos))
    }

    pub fn set(self, screen_pos: UVec2, reprojection: &Reprojection) {
        unsafe {
            self.tex.write(screen_pos, reprojection.serialize());
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn serialization() {
        let target = Reprojection {
            prev_x: 123.45,
            prev_y: 234.56,
            confidence: 1.23,
            validity: 0xcafebabe,
        };

        let target = Reprojection::deserialize(target.serialize());

        assert_eq!(123.45, target.prev_x);
        assert_eq!(234.56, target.prev_y);
        assert_eq!(1.23, target.confidence);
        assert_eq!(0xcafebabe, target.validity);
    }
}

```

`strolle-gpu/src/reservoir.rs`:

```rs
mod di;
mod ephemeral;
mod gi;
mod mis;

pub use self::di::*;
pub use self::ephemeral::*;
pub use self::gi::*;
pub use self::mis::*;
use crate::WhiteNoise;

#[derive(Clone, Copy, Default, PartialEq)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct Reservoir<T> {
    pub sample: T,
    pub m: f32,
    pub w: f32,
}

impl<T> Reservoir<T>
where
    T: Clone + Copy,
{
    pub fn update(
        &mut self,
        wnoise: &mut WhiteNoise,
        sample: T,
        weight: f32,
    ) -> bool {
        self.m += 1.0;
        self.w += weight;

        if wnoise.sample() * self.w < weight {
            self.sample = sample;
            true
        } else {
            false
        }
    }

    pub fn merge(
        &mut self,
        wnoise: &mut WhiteNoise,
        sample: &Self,
        pdf: f32,
    ) -> bool {
        if sample.m <= 0.0 {
            return false;
        }

        self.m += sample.m - 1.0;
        self.update(wnoise, sample.sample, sample.w * sample.m * pdf)
    }

    pub fn clamp_m(&mut self, max: f32) {
        self.m = self.m.min(max);
    }

    pub fn clamp_w(&mut self, max: f32) {
        self.w = self.w.min(max);
    }

    pub fn norm(&mut self, pdf: f32, norm_num: f32, norm_denom: f32) {
        let denom = pdf * norm_denom;

        self.w = if denom == 0.0 {
            0.0
        } else {
            (self.w * norm_num) / denom
        };
    }

    pub fn norm_avg(&mut self, pdf: f32) {
        self.norm(pdf, 1.0, self.m);
    }

    pub fn norm_mis(&mut self, pdf: f32) {
        self.norm(pdf, 1.0, 1.0);
    }
}

```

`strolle-gpu/src/reservoir/di.rs`:

```rs
use core::ops::{Deref, DerefMut};

use glam::{vec4, Vec3, Vec4, Vec4Swizzles};
use spirv_std::arch::IndexUnchecked;
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{Hit, Light, LightId, LightsView, Ray, Reservoir, U32Ext, Vec3Ext};

#[derive(Clone, Copy, Default, PartialEq)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct DiReservoir {
    pub reservoir: Reservoir<DiSample>,
}

impl DiReservoir {
    pub fn read(buffer: &[Vec4], id: usize) -> Self {
        let d0 = unsafe { *buffer.index_unchecked(2 * id) };
        let d1 = unsafe { *buffer.index_unchecked(2 * id + 1) };
        let [is_occluded, confidence, ..] = d0.w.to_bits().to_bytes();

        Self {
            reservoir: Reservoir {
                sample: DiSample {
                    pdf: d0.z,
                    confidence: confidence as f32,
                    light_id: LightId::new(d1.w.to_bits()),
                    light_point: d1.xyz(),
                    is_occluded: is_occluded > 0,
                },
                m: d0.x,
                w: d0.y,
            },
        }
    }

    pub fn write(self, buffer: &mut [Vec4], id: usize) {
        let d0 = vec4(
            self.reservoir.m,
            self.reservoir.w,
            self.sample.pdf,
            f32::from_bits(u32::from_bytes([
                self.sample.is_occluded as u32,
                self.sample.confidence as u32,
                0,
                0,
            ])),
        );

        let d1 = self
            .sample
            .light_point
            .extend(f32::from_bits(self.sample.light_id.get()));

        unsafe {
            *buffer.index_unchecked_mut(2 * id) = d0;
            *buffer.index_unchecked_mut(2 * id + 1) = d1;
        }
    }

    pub fn copy(input: &[Vec4], output: &mut [Vec4], id: usize) {
        // TODO optimize
        Self::read(input, id).write(output, id);
    }

    pub fn is_empty(self) -> bool {
        self.m == 0.0
    }
}

impl Deref for DiReservoir {
    type Target = Reservoir<DiSample>;

    fn deref(&self) -> &Self::Target {
        &self.reservoir
    }
}

impl DerefMut for DiReservoir {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.reservoir
    }
}

#[derive(Clone, Copy, Default, PartialEq)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct DiSample {
    pub pdf: f32,
    pub confidence: f32, // TODO consider storing inside the reservoir instead
    pub light_id: LightId,
    pub light_point: Vec3,
    pub is_occluded: bool,
}

impl DiSample {
    pub fn pdf(self, lights: LightsView, hit: Hit) -> f32 {
        let light = lights.get(self.light_id);

        self.pdf_ex(light, hit)
    }

    pub fn pdf_prev(self, lights: LightsView, hit: Hit) -> f32 {
        let light = lights.get_prev(self.light_id);

        self.pdf_ex(light, hit)
    }

    fn pdf_ex(self, light: Light, mut hit: Hit) -> f32 {
        hit.gbuffer.base_color = Vec4::ONE;

        if !light.is_none() && light.contains(self.light_point) {
            // TODO use a cheaper proxy
            light.radiance(hit).sum().luma()
        } else {
            0.0
        }
    }

    pub fn ray(self, hit_point: Vec3) -> Ray {
        let dir = hit_point - self.light_point;

        Ray::new(self.light_point, dir.normalize()).with_len(dir.length())
    }
}

#[cfg(test)]
mod tests {
    use glam::vec3;

    use super::*;

    #[test]
    fn serialization() {
        fn target(idx: usize) -> DiReservoir {
            DiReservoir {
                reservoir: Reservoir {
                    sample: DiSample {
                        pdf: 123.0,
                        confidence: (idx % 2 == 0) as u32 as f32,
                        light_id: LightId::new(3 * idx as u32),
                        light_point: vec3(1.0, 2.0, 3.0 + (idx as f32)),
                        is_occluded: idx as u32 % 2 == 0,
                    },
                    m: 11.0,
                    w: 12.0 + (idx as f32),
                },
            }
        }

        let mut buffer = [Vec4::ZERO; 2 * 10];

        for idx in 0..10 {
            target(idx).write(&mut buffer, idx);
        }

        for idx in 0..10 {
            let actual = DiReservoir::read(&buffer, idx);
            let expected = target(idx);

            assert_eq!(expected, actual);
        }
    }
}

```

`strolle-gpu/src/reservoir/ephemeral.rs`:

```rs
use core::ops::{Deref, DerefMut};

use crate::{
    Hit, LightId, LightRadiance, LightsView, Reservoir, Vec3Ext, WhiteNoise,
    World,
};

#[derive(Clone, Copy, Default)]
pub struct EphemeralReservoir {
    pub reservoir: Reservoir<EphemeralSample>,
}

impl EphemeralReservoir {
    pub fn build(
        wnoise: &mut WhiteNoise,
        lights: LightsView,
        world: World,
        hit: Hit,
    ) -> Self {
        let mut res = EphemeralReservoir::default();
        let mut res_pdf = 0.0;

        // TODO rust-gpu seems to miscompile `.min()`
        let max_samples = if world.light_count < 16 {
            world.light_count
        } else {
            16
        };

        let sample_ipdf = world.light_count as f32;
        let mut sample_nth = 0;

        while sample_nth < max_samples {
            let light_id =
                LightId::new(wnoise.sample_int() % world.light_count);

            let light_rad = lights.get(light_id).radiance(hit);

            let sample = EphemeralSample {
                light_id,
                light_rad,
            };

            let sample_pdf = sample.pdf();

            if res.update(wnoise, sample, sample_pdf * sample_ipdf) {
                res_pdf = sample_pdf;
            }

            sample_nth += 1;
        }

        res.norm_avg(res_pdf);
        res
    }
}

impl Deref for EphemeralReservoir {
    type Target = Reservoir<EphemeralSample>;

    fn deref(&self) -> &Self::Target {
        &self.reservoir
    }
}

impl DerefMut for EphemeralReservoir {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.reservoir
    }
}

#[derive(Clone, Copy, Default)]
pub struct EphemeralSample {
    pub light_id: LightId,
    pub light_rad: LightRadiance,
}

impl EphemeralSample {
    pub fn pdf(self) -> f32 {
        self.light_rad.radiance.perc_luma()
    }
}

```

`strolle-gpu/src/reservoir/gi.rs`:

```rs
use core::ops::{Deref, DerefMut};

use glam::{Vec3, Vec4, Vec4Swizzles};
use spirv_std::arch::IndexUnchecked;
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{
    DiffuseBrdf, F32Ext, Hit, Normal, Ray, Reservoir, SpecularBrdf, Vec3Ext,
};

#[derive(Clone, Copy, Default)]
pub struct GiReservoir {
    pub reservoir: Reservoir<GiSample>,
    pub confidence: f32,
}

impl GiReservoir {
    pub fn read(buffer: &[Vec4], id: usize) -> Self {
        let d0 = unsafe { *buffer.index_unchecked(4 * id) };
        let d1 = unsafe { *buffer.index_unchecked(4 * id + 1) };
        let d2 = unsafe { *buffer.index_unchecked(4 * id + 2) };
        let d3 = unsafe { *buffer.index_unchecked(4 * id + 3) };

        Self {
            reservoir: Reservoir {
                sample: GiSample {
                    pdf: d2.w,
                    rng: d3.w.to_bits(),
                    radiance: d0.xyz(),
                    v1_point: d1.xyz(),
                    v2_point: d2.xyz(),
                    v2_normal: Normal::decode(d3.xy()),
                },
                m: d0.w,
                w: d1.w,
            },
            confidence: d3.z,
        }
    }

    pub fn write(self, buffer: &mut [Vec4], id: usize) {
        let d0 = self.sample.radiance.extend(self.m);
        let d1 = self.sample.v1_point.extend(self.w);
        let d2 = self.sample.v2_point.extend(self.sample.pdf);

        let d3 = Normal::encode(self.sample.v2_normal)
            .extend(self.confidence)
            .extend(f32::from_bits(self.sample.rng));

        unsafe {
            *buffer.index_unchecked_mut(4 * id) = d0;
            *buffer.index_unchecked_mut(4 * id + 1) = d1;
            *buffer.index_unchecked_mut(4 * id + 2) = d2;
            *buffer.index_unchecked_mut(4 * id + 3) = d3;
        }
    }

    pub fn copy(input: &[Vec4], output: &mut [Vec4], id: usize) {
        // TODO optimize
        Self::read(input, id).write(output, id);
    }

    pub fn is_empty(self) -> bool {
        self.m == 0.0
    }
}

impl Deref for GiReservoir {
    type Target = Reservoir<GiSample>;

    fn deref(&self) -> &Self::Target {
        &self.reservoir
    }
}

impl DerefMut for GiReservoir {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.reservoir
    }
}

#[derive(Clone, Copy, Default)]
pub struct GiSample {
    pub pdf: f32,
    pub rng: u32,
    pub radiance: Vec3,
    pub v1_point: Vec3, // TODO can't we simply fetch it from gbuffer instead?
    pub v2_point: Vec3,
    pub v2_normal: Vec3,
}

impl GiSample {
    pub fn exists(self) -> bool {
        self.v2_point != Default::default()
    }

    pub fn pdf(self, mut hit: Hit) -> f32 {
        if !self.exists() {
            return 0.0;
        }

        hit.gbuffer.base_color = Vec4::ONE;

        let diff_brdf = self.diff_brdf(hit).luma();

        // TODO cut off specular tail, to improve resampling near edges
        let spec_brdf = self.spec_brdf(hit).luma();

        // TODO use something simpler for the PDF
        self.radiance.luma() * self.cosine(hit) * (diff_brdf + spec_brdf)
    }

    pub fn ray(self, hit_point: Vec3) -> Ray {
        Ray::new(hit_point, self.dir(hit_point))
            .with_len(self.v2_point.distance(hit_point) - 0.01)
    }

    pub fn dir(self, point: Vec3) -> Vec3 {
        (self.v2_point - point).normalize()
    }

    pub fn cosine(self, hit: Hit) -> f32 {
        self.dir(hit.point).dot(hit.gbuffer.normal).max(0.0)
    }

    pub fn diff_brdf(self, hit: Hit) -> Vec3 {
        DiffuseBrdf::new(hit.gbuffer).eval()
    }

    pub fn spec_brdf(self, hit: Hit) -> Vec3 {
        SpecularBrdf::new(hit.gbuffer).eval(self.dir(hit.point), -hit.dir)
    }

    pub fn jacobian(self, new_hit_point: Vec3) -> f32 {
        if !self.exists() {
            return 1.0;
        }

        let (new_dist, new_cos) = self.partial_jacobian(new_hit_point);
        let (old_dist, old_cos) = self.partial_jacobian(self.v1_point);

        let x = new_cos * old_dist * old_dist;
        let y = old_cos * new_dist * new_dist;

        if y == 0.0 {
            0.0
        } else {
            x / y
        }
    }

    fn partial_jacobian(self, hit_point: Vec3) -> (f32, f32) {
        let vec = hit_point - self.v2_point;
        let dist = vec.length();
        let cos = self.v2_normal.dot(vec / dist).saturate();

        (dist, cos)
    }
}

```

`strolle-gpu/src/reservoir/mis.rs`:

```rs
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{DiReservoir, F32Ext, GiReservoir, Hit, LightsView};

/// Helper for calculating factors for multiple importance sampling.
///
/// Code assumes we'd like to merge two samples, where `lhs` is the canonical
/// one and `rhs` is the neighbour (which is an important distinction, because
/// we implement the defensive variant here).
#[derive(Clone, Copy, Default)]
pub struct Mis {
    /// Confidence weight for the canonical sample
    pub lhs_m: f32,

    /// Confidence weight for the neighbour sample
    pub rhs_m: f32,

    /// Jacobian determinant of the neighbour sample; 1.0 if not applicable
    pub rhs_jacobian: f32,

    /// `p_lhs(lhs)`, i.e. probability of lhs's sample on lhs's pixel
    pub lhs_lhs_pdf: f32,

    /// `p_lhs(rhs)`, i.e. probability of lhs's sample on rhs's pixel
    pub lhs_rhs_pdf: f32,

    /// `p_rhs(lhs)`, i.e. probability of rhs's sample on lhs's pixel
    pub rhs_lhs_pdf: f32,

    /// `p_rhs(rhs)`, i.e. probability of rhs's sample on rhs's pixel
    pub rhs_rhs_pdf: f32,
}

impl Mis {
    pub fn di_temporal(
        lights: LightsView,
        lhs: DiReservoir,
        lhs_hit: Hit,
        rhs: DiReservoir,
        rhs_hit: Hit,
        rhs_killed: bool,
    ) -> Self {
        let lhs_rhs_pdf = if (lhs.m > 0.0) & rhs_hit.is_some() {
            lhs.sample.pdf_prev(lights, rhs_hit)
        } else {
            0.0
        };

        let rhs_lhs_pdf = if (rhs.m > 0.0) & !rhs_killed {
            rhs.sample.pdf(lights, lhs_hit)
        } else {
            0.0
        };

        Self {
            lhs_m: lhs.m,
            rhs_m: rhs.m,
            rhs_jacobian: 1.0,
            lhs_lhs_pdf: lhs.sample.pdf,
            lhs_rhs_pdf,
            rhs_lhs_pdf,
            rhs_rhs_pdf: rhs.sample.pdf,
        }
    }

    pub fn gi_temporal(
        lhs: GiReservoir,
        lhs_hit: Hit,
        rhs: GiReservoir,
        rhs_hit: Hit,
    ) -> Self {
        let lhs_rhs_pdf = if (lhs.m > 0.0) & rhs_hit.is_some() {
            lhs.sample.pdf(rhs_hit)
        } else {
            0.0
        };

        let rhs_lhs_pdf = if rhs.m > 0.0 {
            rhs.sample.pdf(lhs_hit)
        } else {
            0.0
        };

        Self {
            lhs_m: lhs.m,
            rhs_m: rhs.m,
            rhs_jacobian: 1.0,
            lhs_lhs_pdf: lhs.sample.pdf,
            lhs_rhs_pdf,
            rhs_lhs_pdf,
            rhs_rhs_pdf: rhs.sample.pdf,
        }
    }

    pub fn eval(self) -> MisResult {
        fn mis(x: f32, y: f32) -> f32 {
            let sum = x + y;

            if sum == 0.0 {
                0.0
            } else {
                x / sum
            }
        }

        fn m(q0: f32, q1: f32) -> f32 {
            if q0 <= 0.0 {
                1.0
            } else {
                (q1 / q0).min(1.0).powf(8.0).saturate()
            }
        }

        let m = self.rhs_m
            * m(self.rhs_rhs_pdf, self.rhs_lhs_pdf)
                .min(m(self.lhs_rhs_pdf, self.lhs_lhs_pdf));

        // We implement the defensive variant, giving some extra score to the
        // canonical sample - this comes *very* handy in reducing variance in
        // penumbra regions for direct lighting when doing spatial resampling
        let t = mis(self.lhs_m, self.rhs_m);

        let lhs_mis = t
            + (1.0 - t)
                * mis(
                    self.lhs_m * self.lhs_lhs_pdf,
                    self.rhs_m * self.lhs_rhs_pdf,
                );

        let rhs_mis = (1.0 - t)
            * mis(
                self.rhs_m * self.rhs_rhs_pdf * self.rhs_jacobian,
                self.lhs_m * self.rhs_lhs_pdf,
            );

        MisResult {
            m,
            lhs_pdf: self.lhs_lhs_pdf,
            lhs_mis,
            rhs_pdf: self.rhs_lhs_pdf,
            rhs_mis,
        }
    }
}

#[derive(Clone, Copy, Default)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct MisResult {
    pub m: f32,
    pub lhs_pdf: f32,
    pub lhs_mis: f32,
    pub rhs_pdf: f32,
    pub rhs_mis: f32,
}

```

`strolle-gpu/src/surface.rs`:

```rs
use glam::{UVec2, Vec3, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{Normal, TexRgba32};

#[derive(Clone, Copy)]
pub struct Surface {
    pub normal: Vec3,
    pub depth: f32,
    pub roughness: f32,
}

impl Surface {
    pub fn is_sky(self) -> bool {
        self.depth == 0.0
    }

    /// Returns a score `<0.0, 1.0>` that determines the similarity of two given
    /// surfaces.
    pub fn evaluate_similarity_to(self, other: Self) -> f32 {
        if self.is_sky() || other.is_sky() {
            return 0.0;
        }

        let normal_score = {
            let dot = self.normal.dot(other.normal).max(0.0);

            if dot <= 0.5 {
                0.0
            } else {
                2.0 * dot
            }
        };

        let depth_score = {
            let t = (self.depth - other.depth).abs();

            if t >= 0.1 * other.depth {
                0.0
            } else {
                1.0
            }
        };

        normal_score * depth_score
    }
}

#[derive(Clone, Copy)]
pub struct SurfaceMap<'a> {
    tex: TexRgba32<'a>,
}

impl<'a> SurfaceMap<'a> {
    pub fn new(tex: TexRgba32<'a>) -> Self {
        Self { tex }
    }

    pub fn get(self, screen_pos: UVec2) -> Surface {
        let d0 = self.tex.read(screen_pos);

        Surface {
            normal: Normal::decode(d0.xy()),
            depth: d0.z,
            roughness: d0.w,
        }
    }
}

```

`strolle-gpu/src/triangle.rs`:

```rs
use bytemuck::{Pod, Zeroable};
use glam::{vec2, Vec2, Vec3, Vec4, Vec4Swizzles};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::{Ray, TriangleHit};

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug, PartialEq))]
pub struct Triangle {
    pub d0: Vec4,
    pub d1: Vec4,
    pub d2: Vec4,
    pub d3: Vec4,
    pub d4: Vec4,
    pub d5: Vec4,
    pub d6: Vec4,
    pub d7: Vec4,
    pub d8: Vec4,
}

impl Triangle {
    pub fn position0(self) -> Vec3 {
        self.d0.xyz()
    }

    pub fn normal0(self) -> Vec3 {
        self.d1.xyz()
    }

    pub fn uv0(self) -> Vec2 {
        vec2(self.d0.w, self.d1.w)
    }

    pub fn position1(self) -> Vec3 {
        self.d3.xyz()
    }

    pub fn normal1(self) -> Vec3 {
        self.d4.xyz()
    }

    pub fn uv1(self) -> Vec2 {
        vec2(self.d3.w, self.d4.w)
    }

    pub fn position2(self) -> Vec3 {
        self.d6.xyz()
    }

    pub fn normal2(self) -> Vec3 {
        self.d7.xyz()
    }

    pub fn uv2(self) -> Vec2 {
        vec2(self.d6.w, self.d7.w)
    }

    pub fn positions(self) -> [Vec3; 3] {
        [self.position0(), self.position1(), self.position2()]
    }

    pub fn hit(self, ray: Ray, hit: &mut TriangleHit) -> bool {
        let v0v1 = self.position1() - self.position0();
        let v0v2 = self.position2() - self.position0();

        // ---

        let pvec = ray.dir().cross(v0v2);
        let det = v0v1.dot(pvec);

        if det.abs() < f32::EPSILON {
            return false;
        }

        // ---

        let inv_det = 1.0 / det;
        let tvec = ray.origin() - self.position0();
        let u = tvec.dot(pvec) * inv_det;
        let qvec = tvec.cross(v0v1);
        let v = ray.dir().dot(qvec) * inv_det;
        let distance = v0v2.dot(qvec) * inv_det;

        if (u < 0.0)
            | (u > 1.0)
            | (v < 0.0)
            | (u + v > 1.0)
            | (distance <= 0.0)
            | (distance >= hit.distance)
        {
            return false;
        }

        let normal = {
            let normal = u * self.normal1()
                + v * self.normal2()
                + (1.0 - u - v) * self.normal0();

            normal.normalize() * 1.0f32.copysign(inv_det)
        };

        let uv = self.uv0()
            + (self.uv1() - self.uv0()) * u
            + (self.uv2() - self.uv0()) * v;

        hit.uv = uv;
        hit.normal = normal;
        hit.distance = distance;

        true
    }
}

#[derive(Clone, Copy)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug, PartialEq))]
pub struct TriangleId(u32);

impl TriangleId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn get(self) -> u32 {
        self.0
    }
}

```

`strolle-gpu/src/triangles.rs`:

```rs
use spirv_std::arch::IndexUnchecked;

use crate::{Triangle, TriangleId};

#[derive(Clone, Copy)]
pub struct TrianglesView<'a> {
    buffer: &'a [Triangle],
}

impl<'a> TrianglesView<'a> {
    pub fn new(buffer: &'a [Triangle]) -> Self {
        Self { buffer }
    }

    pub fn get(self, id: TriangleId) -> Triangle {
        unsafe { *self.buffer.index_unchecked(id.get() as usize) }
    }
}

```

`strolle-gpu/src/utils.rs`:

```rs
mod bilinear_filter;
mod f32_ext;
mod u32_ext;
mod vec2_ext;
mod vec3_ext;

use core::ops;

use glam::{uvec2, UVec2};
use spirv_std::Image;

pub use self::bilinear_filter::*;
pub use self::f32_ext::*;
pub use self::u32_ext::*;
pub use self::vec2_ext::*;
pub use self::vec3_ext::*;

pub type Tex<'a> = &'a Image!(2D, type = f32, sampled);
pub type TexRgba8<'a> = &'a Image!(2D, format = rgba8, sampled = false);
pub type TexRgba16<'a> = &'a Image!(2D, format = rgba16f, sampled = false);
pub type TexRgba32<'a> = &'a Image!(2D, format = rgba32f, sampled = false);

pub fn lerp<T>(a: T, b: T, t: f32) -> T
where
    T: ops::Add<Output = T>,
    T: ops::Sub<Output = T>,
    T: ops::Mul<f32, Output = T>,
    T: Copy,
{
    a + (b - a) * t.clamp(0.0, 1.0)
}

pub fn resolve_checkerboard(global_id: UVec2, frame: u32) -> UVec2 {
    global_id * uvec2(2, 1) + uvec2((frame + global_id.y) % 2, 0)
}

pub fn resolve_checkerboard_alt(global_id: UVec2, frame: u32) -> UVec2 {
    resolve_checkerboard(global_id, frame + 1)
}

pub fn got_checkerboard_at(screen_pos: UVec2, frame: u32) -> bool {
    screen_pos == resolve_checkerboard(screen_pos / uvec2(2, 1), frame)
}

```

`strolle-gpu/src/utils/bilinear_filter.rs`:

```rs
use glam::{ivec2, vec2, vec4, IVec2, UVec2, Vec2, Vec4};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

use crate::Reprojection;

#[derive(Clone, Copy)]
pub struct BilinearFilter {
    /// Sample at `f(x=0, y=0)`
    pub s00: Vec4,

    /// Sample at `f(x=1, y=0)`
    pub s10: Vec4,

    /// Sample at `f(x=0, y=1)`
    pub s01: Vec4,

    /// Sample at `f(x=1, y=1)`
    pub s11: Vec4,

    /// Weights for each sample
    pub weights: Vec4,
}

impl BilinearFilter {
    // TODO make it generic over `Vec4`
    pub fn reproject(
        reprojection: Reprojection,
        sample: impl Fn(UVec2) -> (Vec4, f32),
    ) -> Vec4 {
        if reprojection.is_exact() {
            sample(reprojection.prev_pos_round()).0
        } else {
            Self::from_reprojection(reprojection, sample).eval(vec2(
                reprojection.prev_x.fract(),
                reprojection.prev_y.fract(),
            ))
        }
    }

    pub fn from_reprojection(
        reprojection: Reprojection,
        sample: impl Fn(UVec2) -> (Vec4, f32),
    ) -> Self {
        let mut s00 = Vec4::ZERO;
        let mut s10 = Vec4::ZERO;
        let mut s01 = Vec4::ZERO;
        let mut s11 = Vec4::ZERO;
        let mut weights = Vec4::ZERO;

        let [p00, p10, p01, p11] =
            Self::reprojection_coords(reprojection.prev_x, reprojection.prev_y);

        if reprojection.validity & 0b0001 > 0 && p00.x >= 0 && p00.y >= 0 {
            (s00, weights.x) = sample(p00.as_uvec2());
        }

        if reprojection.validity & 0b0010 > 0 && p10.x >= 0 && p10.y >= 0 {
            (s10, weights.y) = sample(p10.as_uvec2());
        }

        if reprojection.validity & 0b0100 > 0 && p01.x >= 0 && p01.y >= 0 {
            (s01, weights.z) = sample(p01.as_uvec2());
        }

        if reprojection.validity & 0b1000 > 0 && p11.x >= 0 && p11.y >= 0 {
            (s11, weights.w) = sample(p11.as_uvec2());
        }

        Self {
            s00,
            s10,
            s01,
            s11,
            weights,
        }
    }

    pub fn reprojection_coords(prev_x: f32, prev_y: f32) -> [IVec2; 4] {
        let p00 = ivec2(prev_x.floor() as i32, prev_y.floor() as i32);
        let p10 = ivec2(prev_x.ceil() as i32, prev_y.floor() as i32);
        let p01 = ivec2(prev_x.floor() as i32, prev_y.ceil() as i32);
        let p11 = ivec2(prev_x.ceil() as i32, prev_y.ceil() as i32);

        [p00, p10, p01, p11]
    }

    pub fn eval(self, uv: Vec2) -> Vec4 {
        let weights = self.weights
            * vec4(
                (1.0 - uv.x) * (1.0 - uv.y),
                uv.x * (1.0 - uv.y),
                (1.0 - uv.x) * uv.y,
                uv.x * uv.y,
            );

        let w_sum = weights.dot(Vec4::ONE);

        if w_sum == 0.0 {
            Default::default()
        } else {
            (self.s00 * weights.x
                + self.s10 * weights.y
                + self.s01 * weights.z
                + self.s11 * weights.w)
                / w_sum
        }
    }
}

```

`strolle-gpu/src/utils/f32_ext.rs`:

```rs
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

pub trait F32Ext
where
    Self: Sized,
{
    fn sqr(self) -> Self;
    fn saturate(self) -> Self;
    fn inverse_sqrt(self) -> Self;
    fn acos_approx(self) -> Self;
}

impl F32Ext for f32 {
    fn sqr(self) -> Self {
        self * self
    }

    fn saturate(self) -> Self {
        self.clamp(0.0, 1.0)
    }

    fn inverse_sqrt(self) -> Self {
        1.0 / self.sqrt()
    }

    fn acos_approx(self) -> Self {
        2.0f32.sqrt() * (1.0 - self).saturate().sqrt()
    }
}

```

`strolle-gpu/src/utils/u32_ext.rs`:

```rs
pub trait U32Ext
where
    Self: Sized,
{
    fn from_bytes(bytes: [u32; 4]) -> Self;
    fn to_bytes(self) -> [u32; 4];
}

impl U32Ext for u32 {
    fn from_bytes([a, b, c, d]: [u32; 4]) -> Self {
        a | (b << 8) | (c << 16) | (d << 24)
    }

    fn to_bytes(mut self) -> [u32; 4] {
        let a = self & 0xff;
        self >>= 8;
        let b = self & 0xff;
        self >>= 8;
        let c = self & 0xff;
        self >>= 8;
        let d = self & 0xff;

        [a, b, c, d]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn from_to_bytes() {
        assert_eq!(0xcafebabe, u32::from_bytes(u32::to_bytes(0xcafebabe)));
    }
}

```

`strolle-gpu/src/utils/vec2_ext.rs`:

```rs
use glam::Vec2;

pub trait Vec2Ext
where
    Self: Sized,
{
    /// Clips this color-vector into given bounding box.
    ///
    /// See:
    /// - https://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463
    fn clip(self, aabb_min: Self, aabb_max: Self) -> Self;
}

impl Vec2Ext for Vec2 {
    fn clip(self, aabb_min: Self, aabb_max: Self) -> Self {
        let p_clip = 0.5 * (aabb_max + aabb_min);
        let e_clip = 0.5 * (aabb_max - aabb_min);
        let v_clip = self - p_clip;
        let v_unit = v_clip / e_clip;
        let a_unit = v_unit.abs();
        let ma_unit = a_unit.max_element();

        if ma_unit > 1.0 {
            p_clip + v_clip / ma_unit
        } else {
            self
        }
    }
}

```

`strolle-gpu/src/utils/vec3_ext.rs`:

```rs
use glam::{vec3, Vec3};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

pub trait Vec3Ext
where
    Self: Sized,
{
    /// Reflects this direction-vector around `other`.
    fn reflect(self, other: Self) -> Self;

    /// Clips this color-vector into given bounding box.
    ///
    /// See:
    /// - https://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463
    fn clip(self, aabb_min: Self, aabb_max: Self) -> Self;

    /// Returns luminance of this color-vector.
    fn luma(self) -> f32;

    /// Returns perceptual luminance of this color-vector.
    ///
    /// As compared to the standard luminance, perceptual luminance gets a boost
    /// for darker colors and attenuates the brigher colors, so that comparisons
    /// between them behave more human-vision like.
    fn perc_luma(self) -> f32;

    /// Adjusts luminance of this color-vector.
    fn with_luma(self, luma: f32) -> Self;
}

impl Vec3Ext for Vec3 {
    fn reflect(self, other: Self) -> Self {
        self - 2.0 * other.dot(self) * other
    }

    fn clip(self, aabb_min: Self, aabb_max: Self) -> Self {
        let p_clip = 0.5 * (aabb_max + aabb_min);
        let e_clip = 0.5 * (aabb_max - aabb_min);
        let v_clip = self - p_clip;
        let v_unit = v_clip / e_clip;
        let a_unit = v_unit.abs();
        let ma_unit = a_unit.max_element();

        if ma_unit > 1.0 {
            p_clip + v_clip / ma_unit
        } else {
            self
        }
    }

    fn luma(self) -> f32 {
        self.dot(vec3(0.2126, 0.7152, 0.0722))
    }

    fn perc_luma(self) -> f32 {
        self.luma().sqrt()
    }

    fn with_luma(self, luma: f32) -> Self {
        self * (luma / self.luma())
    }
}

```

`strolle-gpu/src/world.rs`:

```rs
use bytemuck::{Pod, Zeroable};
use glam::{vec3, Vec3};
#[cfg(target_arch = "spirv")]
use spirv_std::num_traits::Float;

#[repr(C)]
#[derive(Clone, Copy, Default, Pod, Zeroable)]
#[cfg_attr(not(target_arch = "spirv"), derive(Debug))]
pub struct World {
    pub light_count: u32,
    pub sun_azimuth: f32,
    pub sun_altitude: f32,
}

impl World {
    // TODO recalculate the distance factor using sun's solid angle
    pub const SUN_DISTANCE: f32 = 1000.0;

    pub fn sun_dir(self) -> Vec3 {
        vec3(
            self.sun_altitude.cos() * self.sun_azimuth.sin(),
            self.sun_altitude.sin(),
            -self.sun_altitude.cos() * self.sun_azimuth.cos(),
        )
    }

    pub fn sun_pos(self) -> Vec3 {
        self.sun_dir() * Self::SUN_DISTANCE
    }
}

```

`strolle-shader-builder/Cargo.toml`:

```toml
[package]
name = "strolle-shader-builder"
version = "0.1.0"
edition = "2021"

[dependencies]
spirv-builder.workspace = true

```

`strolle-shader-builder/src/main.rs`:

```rs
use std::env;
use std::error::Error;
use std::path::Path;

use spirv_builder::{Capability, MetadataPrintout, SpirvBuilder};

fn main() -> Result<(), Box<dyn Error>> {
    let crate_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("strolle-shaders");

    let result = SpirvBuilder::new(crate_path, "spirv-unknown-spv1.3")
        .multimodule(true)
        .print_metadata(MetadataPrintout::DependencyOnly)
        .capability(Capability::Int8)
        .extra_arg("--spirt-passes=reduce,fuse_selects")
        .build()?;

    for (shader_name, shader_path) in result.module.unwrap_multi() {
        let shader_id = shader_name.replace("::", "_");
        let shader_id = shader_id.strip_suffix("_main").unwrap_or(&shader_id);

        println!(
            "cargo:rustc-env=strolle_shaders::{}.path={}",
            shader_id,
            shader_path.display()
        );

        println!(
            "cargo:rustc-env=strolle_shaders::{}.entry_point={}",
            shader_id, shader_name,
        );
    }

    Ok(())
}

```

`strolle-shaders/Cargo.toml`:

```toml
[package]
name = "strolle-shaders"
version = "0.1.0"
edition = "2021"

[lints]
workspace = true

[lib]
crate-type = ["dylib"]

[dependencies]
spirv-std.workspace = true
strolle-gpu = { path = "../strolle-gpu" }

```

`strolle-shaders/src/atmosphere.rs`:

```rs
//! This pass generates lookup textures used to render sky.
//!
//! Thanks to:
//!
//! - https://www.shadertoy.com/view/slSXRW
//!   (Production Sky Rendering by AndrewHelmer)
//!
//! - https://github.com/sebh/UnrealEngineSkyAtmosphere
//!
//! Original license:
//!
//! ```text
//! MIT License
//!
//! Copyright (c) 2020 Epic Games, Inc.
//!
//! Permission is hereby granted, free of charge, to any person obtaining a copy
//! of this software and associated documentation files (the "Software"), to deal
//! in the Software without restriction, including without limitation the rights
//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//! copies of the Software, and to permit persons to whom the Software is
//! furnished to do so, subject to the following conditions:
//!
//! The above copyright notice and this permission notice shall be included in all
//! copies or substantial portions of the Software.
//!
//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//! SOFTWARE.
//! ```

pub mod generate_scattering_lut;
pub mod generate_sky_lut;
pub mod generate_transmittance_lut;
mod utils;

use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn generate_scattering_lut(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0)] transmittance_lut_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 1)]
    transmittance_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 2)] out: TexRgba16,
) {
    generate_scattering_lut::main(
        global_id,
        transmittance_lut_tex,
        transmittance_lut_sampler,
        out,
    );
}

#[spirv(compute(threads(8, 8)))]
pub fn generate_sky_lut(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] world: &World,
    #[spirv(descriptor_set = 0, binding = 1)] transmittance_lut_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 2)]
    transmittance_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 3)] scattering_lut_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] scattering_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 5)] out: TexRgba16,
) {
    generate_sky_lut::main(
        global_id,
        world,
        transmittance_lut_tex,
        transmittance_lut_sampler,
        scattering_lut_tex,
        scattering_lut_sampler,
        out,
    );
}

#[spirv(compute(threads(8, 8)))]
pub fn generate_transmittance_lut(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0)] out: TexRgba16,
) {
    generate_transmittance_lut::main(global_id, out);
}

```

`strolle-shaders/src/atmosphere/generate_scattering_lut.rs`:

```rs
use strolle_gpu::prelude::*;

use super::utils::*;

pub fn main(
    global_id: UVec3,
    transmittance_lut_tex: Tex,
    transmittance_lut_sampler: &Sampler,
    out: TexRgba16,
) {
    let global_id = global_id.xy();

    let uv =
        global_id.as_vec2() / Atmosphere::SCATTERING_LUT_RESOLUTION.as_vec2();

    let sun_cos_theta = 2.0 * uv.x - 1.0;
    let sun_theta = sun_cos_theta.clamp(-1.0, 1.0).acos();

    let height = lerp(
        Atmosphere::GROUND_RADIUS_MM,
        Atmosphere::ATMOSPHERE_RADIUS_MM,
        uv.y.max(0.01),
    );

    let pos = vec3(0.0, height, 0.0);
    let sun_dir = vec3(0.0, sun_cos_theta, -sun_theta.sin()).normalize();

    let (lum, f_ms) = eval(
        transmittance_lut_tex,
        transmittance_lut_sampler,
        pos,
        sun_dir,
    );

    let out_val = lum / (1.0 - f_ms);

    unsafe {
        out.write(global_id, out_val.extend(1.0));
    }
}

pub fn eval(
    transmittance_lut_tex: Tex,
    transmittance_lut_sampler: &Sampler,
    pos: Vec3,
    sun_dir: Vec3,
) -> (Vec3, Vec3) {
    let mut lum_total = Vec3::default();
    let mut fms = Vec3::default();

    let inv_samples = 1.0
        / ((Atmosphere::SCATTERING_LUT_SAMPLES_SQRT
            * Atmosphere::SCATTERING_LUT_SAMPLES_SQRT) as f32);

    let mut i = 0;

    while i < Atmosphere::SCATTERING_LUT_SAMPLES_SQRT {
        let mut j = 0;

        while j < Atmosphere::SCATTERING_LUT_SAMPLES_SQRT {
            let theta = PI * ((i as f32) + 0.5)
                / (Atmosphere::SCATTERING_LUT_SAMPLES_SQRT as f32);

            let phi = (1.0
                - 2.0 * ((j as f32) + 0.5)
                    / (Atmosphere::SCATTERING_LUT_SAMPLES_SQRT as f32))
                .clamp(-1.0, 1.0)
                .acos();

            let ray_dir = spherical_direction(theta, phi);

            let atmosphere_distance = Ray::new(pos, ray_dir)
                .intersect_sphere(Atmosphere::ATMOSPHERE_RADIUS_MM);

            let ground_distance = Ray::new(pos, ray_dir)
                .intersect_sphere(Atmosphere::GROUND_RADIUS_MM);

            let t_max = if ground_distance > 0.0 {
                ground_distance
            } else {
                atmosphere_distance
            };

            let cos_theta = ray_dir.dot(sun_dir);
            let mie_phase_value = eval_mie_phase(cos_theta);
            let rayleigh_phase_value = eval_rayleigh_phase(-cos_theta);

            let mut lum = Vec3::default();
            let mut lum_factor = Vec3::default();
            let mut transmittance = Vec3::splat(1.0);

            let mut t = 0.0;
            let mut step_i = 0.0;

            while step_i < Atmosphere::SCATTERING_LUT_STEPS {
                let new_t =
                    ((step_i + 0.3) / Atmosphere::SCATTERING_LUT_STEPS) * t_max;

                let dt = new_t - t;

                t = new_t;

                let new_pos = pos + t * ray_dir;

                let (rayleigh_scattering, mie_scattering, extinction) =
                    eval_scattering(new_pos);

                let sample_transmittance = (-dt * extinction).exp();

                let scattering_no_phase = rayleigh_scattering + mie_scattering;

                let scattering_f = (scattering_no_phase
                    - scattering_no_phase * sample_transmittance)
                    / extinction;

                lum_factor += transmittance * scattering_f;

                let sun_transmittance = Atmosphere::sample_lut(
                    transmittance_lut_tex,
                    transmittance_lut_sampler,
                    new_pos,
                    sun_dir,
                );

                let rayleigh_in_scattering =
                    rayleigh_scattering * rayleigh_phase_value;

                let mie_in_scattering = mie_scattering * mie_phase_value;

                let in_scattering = (rayleigh_in_scattering
                    + mie_in_scattering)
                    * sun_transmittance;

                let scattering_integral = (in_scattering
                    - in_scattering * sample_transmittance)
                    / extinction;

                lum += scattering_integral * transmittance;
                transmittance *= sample_transmittance;
                step_i += 1.0;
            }

            if ground_distance > 0.0 {
                let mut hit_pos = pos + ground_distance * ray_dir;

                if pos.dot(sun_dir) > 0.0 {
                    hit_pos =
                        hit_pos.normalize() * Atmosphere::GROUND_RADIUS_MM;

                    lum += transmittance
                        * Atmosphere::GROUND_ALBEDO
                        * Atmosphere::sample_lut(
                            transmittance_lut_tex,
                            transmittance_lut_sampler,
                            hit_pos,
                            sun_dir,
                        );
                }
            }

            fms += lum_factor * inv_samples;
            lum_total += lum * inv_samples;
            j += 1;
        }

        i += 1;
    }

    (lum_total, fms)
}

```

`strolle-shaders/src/atmosphere/generate_sky_lut.rs`:

```rs
use strolle_gpu::prelude::*;

use super::utils::*;

pub fn main(
    global_id: UVec3,
    world: &World,
    transmittance_lut_tex: Tex,
    transmittance_lut_sampler: &Sampler,
    scattering_lut_tex: Tex,
    scattering_lut_sampler: &Sampler,
    out: TexRgba16,
) {
    let global_id = global_id.xy();
    let uv = global_id.as_vec2() / Atmosphere::SKY_LUT_RESOLUTION.as_vec2();

    let ray_dir = {
        let azimuth = (uv.x - 0.5) * 2.0 * PI;

        let altitude = {
            let v = if uv.y < 0.5 {
                let coord = 1.0 - 2.0 * uv.y;

                -coord * coord
            } else {
                let coord = uv.y * 2.0 - 1.0;

                coord * coord
            };

            let horizon = {
                let height = Atmosphere::VIEW_POS.length();
                let t = height.sqr() - Atmosphere::GROUND_RADIUS_MM.sqr();
                let t = t.sqrt() / height;

                t.clamp(-1.0, 1.0).acos() - 0.5 * PI
            };

            v * 0.5 * PI - horizon
        };

        vec3(
            altitude.cos() * azimuth.sin(),
            altitude.sin(),
            -altitude.cos() * azimuth.cos(),
        )
    };

    let sun_dir = {
        let altitude = world.sun_altitude % (2.0 * PI);

        if altitude < 0.5 * PI {
            vec3(0.0, altitude.sin(), -altitude.cos())
        } else {
            // There's (probably) something wrong with the way we compute
            // azimuth during sky-lut sampling which shows up as sun being on
            // the opposite side of the sky when it's setting down.
            //
            // I'm not sure what's wrong with our sampling there, so let's
            // hotfix it here.
            vec3(0.0, altitude.sin(), altitude.cos())
        }
    };

    let atmosphere_distance = Ray::new(Atmosphere::VIEW_POS, ray_dir)
        .intersect_sphere(Atmosphere::ATMOSPHERE_RADIUS_MM);

    let ground_distance = Ray::new(Atmosphere::VIEW_POS, ray_dir)
        .intersect_sphere(Atmosphere::GROUND_RADIUS_MM);

    let t_max = if ground_distance < 0.0 {
        atmosphere_distance
    } else {
        ground_distance
    };

    let out_val = eval(
        transmittance_lut_tex,
        transmittance_lut_sampler,
        scattering_lut_tex,
        scattering_lut_sampler,
        Atmosphere::VIEW_POS,
        ray_dir,
        sun_dir,
        t_max,
        Atmosphere::SKY_LUT_STEPS,
    );

    unsafe {
        out.write(global_id, out_val.extend(1.0));
    }
}

pub fn eval(
    transmittance_lut_tex: Tex,
    transmittance_lut_sampler: &Sampler,
    scattering_lut_tex: Tex,
    scattering_lut_sampler: &Sampler,
    pos: Vec3,
    ray_dir: Vec3,
    sun_dir: Vec3,
    t_max: f32,
    num_steps: f32,
) -> Vec3 {
    let cos_theta = ray_dir.dot(sun_dir);
    let mie_phase_value = eval_mie_phase(cos_theta);
    let rayleigh_phase_value = eval_rayleigh_phase(-cos_theta);

    let mut lum = Vec3::default();
    let mut transmittance = Vec3::splat(1.0);
    let mut t = 0.0;
    let mut i = 0.0;

    while i < num_steps {
        let new_t = ((i + 0.3) / num_steps) * t_max;
        let dt = new_t - t;

        t = new_t;

        let new_pos = pos + t * ray_dir;

        let (rayleigh_scattering, mie_scattering, extinction) =
            eval_scattering(new_pos);

        let sample_transmittance = (-dt * extinction).exp();

        let sun_transmittance = Atmosphere::sample_lut(
            transmittance_lut_tex,
            transmittance_lut_sampler,
            new_pos,
            sun_dir,
        );

        let psi_ms = Atmosphere::sample_lut(
            scattering_lut_tex,
            scattering_lut_sampler,
            new_pos,
            sun_dir,
        );

        let rayleigh_in_scattering = rayleigh_scattering
            * (rayleigh_phase_value * sun_transmittance + psi_ms);

        let mie_in_scattering =
            mie_scattering * (mie_phase_value * sun_transmittance + psi_ms);

        let in_scattering = rayleigh_in_scattering + mie_in_scattering;

        let scattering_integral =
            (in_scattering - in_scattering * sample_transmittance) / extinction;

        lum += scattering_integral * transmittance;
        transmittance *= sample_transmittance;
        i += 1.0;
    }

    lum
}

```

`strolle-shaders/src/atmosphere/generate_transmittance_lut.rs`:

```rs
use strolle_gpu::prelude::*;

use super::utils::*;

pub fn main(global_id: UVec3, out: TexRgba16) {
    let global_id = global_id.xy();

    let uv = global_id.as_vec2()
        / Atmosphere::TRANSMITTANCE_LUT_RESOLUTION.as_vec2();

    let sun_cos_theta = 2.0 * uv.x - 1.0;
    let sun_theta = sun_cos_theta.clamp(-1.0, 1.0).acos();

    let height = lerp(
        Atmosphere::GROUND_RADIUS_MM,
        Atmosphere::ATMOSPHERE_RADIUS_MM,
        uv.y,
    );

    let pos = vec3(0.0, height, 0.0);
    let sun_dir = vec3(0.0, sun_cos_theta, -sun_theta.sin()).normalize();
    let out_val = eval(pos, sun_dir);

    unsafe {
        out.write(global_id, out_val.extend(1.0));
    }
}

pub fn eval(pos: Vec3, sun_dir: Vec3) -> Vec3 {
    if Ray::new(pos, sun_dir).intersect_sphere(Atmosphere::GROUND_RADIUS_MM)
        > 0.0
    {
        return Default::default();
    }

    let atmosphere_distance = Ray::new(pos, sun_dir)
        .intersect_sphere(Atmosphere::ATMOSPHERE_RADIUS_MM);

    let mut t = 0.0;
    let mut transmittance = Vec3::splat(1.0);
    let mut i = 0.0;

    while i < Atmosphere::TRANSMITTANCE_LUT_STEPS {
        let new_t = ((i + 0.3) / Atmosphere::TRANSMITTANCE_LUT_STEPS)
            * atmosphere_distance;

        let dt = new_t - t;

        t = new_t;

        let new_pos = pos + t * sun_dir;
        let (_, _, extinction) = eval_scattering(new_pos);

        transmittance *= (-dt * extinction).exp();
        i += 1.0;
    }

    transmittance
}

```

`strolle-shaders/src/atmosphere/utils.rs`:

```rs
use strolle_gpu::prelude::*;

pub fn eval_scattering(pos: Vec3) -> (Vec3, f32, Vec3) {
    let altitude_km = (pos.length() - Atmosphere::GROUND_RADIUS_MM) * 1000.0;
    let rayleigh_density = (-altitude_km / 8.0).exp();
    let mie_density = (-altitude_km / 1.2).exp();

    let rayleigh_scattering =
        Atmosphere::RAYLEIGH_SCATTERING_BASE * rayleigh_density;

    let rayleigh_absorption =
        Atmosphere::RAYLEIGH_ABSORPTION_BASE * rayleigh_density;

    let mie_scattering = Atmosphere::MIE_SCATTERING_BASE * mie_density;
    let mie_absorption = Atmosphere::MIE_ABSORPTION_BASE * mie_density;

    let ozone_absorption = Atmosphere::OZONE_ABSORPTION_BASE
        * (1.0 - (altitude_km - 25.0).abs() / 15.0).max(0.0);

    let extinction = rayleigh_scattering
        + rayleigh_absorption
        + mie_scattering
        + mie_absorption
        + ozone_absorption;

    (rayleigh_scattering, mie_scattering, extinction)
}

pub fn eval_mie_phase(cos_theta: f32) -> f32 {
    const G: f32 = 0.8;
    const SCALE: f32 = 3.0 / (8.0 * PI);

    let num = (1.0 - G * G) * (1.0 + cos_theta * cos_theta);
    let denom = (2.0 + G * G) * (1.0 + G * G - 2.0 * G * cos_theta).powf(1.5);

    SCALE * num / denom
}

pub fn eval_rayleigh_phase(cos_theta: f32) -> f32 {
    const K: f32 = 3.0 / (16.0 * PI);

    K * (1.0 + cos_theta * cos_theta)
}

pub fn spherical_direction(theta: f32, phi: f32) -> Vec3 {
    let cos_phi = phi.cos();
    let sin_phi = phi.sin();
    let cos_theta = theta.cos();
    let sin_theta = theta.sin();

    vec3(sin_phi * sin_theta, cos_phi, sin_phi * cos_theta)
}

```

`strolle-shaders/src/bvh_heatmap.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] output: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let (_, used_memory) = camera.ray(screen_pos).trace(
        local_idx,
        stack,
        triangles,
        bvh,
        materials,
        atlas_tex,
        atlas_sampler,
    );

    let color = gradient(
        [
            vec3(0.0, 0.0, 1.0),
            vec3(0.0, 1.0, 0.0),
            vec3(1.0, 0.0, 0.0),
            vec3(0.0, 0.0, 0.0),
        ],
        used_memory as f32 / 8192.0,
    );

    unsafe {
        output.write(screen_pos, color.extend(1.0));
    }
}

fn gradient<const N: usize>(colors: [Vec3; N], progress: f32) -> Vec3 {
    if progress <= 0.0 {
        return colors[0];
    }

    let step = 1.0 / (N as f32 - 1.0);
    let mut i = 0;

    while i < (N - 1) {
        let min = step * (i as f32);
        let max = step * (i as f32 + 1.0);

        if progress >= min && progress <= max {
            let rhs = (progress - min) / step;
            let lhs = 1.0 - rhs;

            return lhs * colors[i] + rhs * colors[i + 1];
        }

        i += 1;
    }

    colors[N - 1]
}

```

`strolle-shaders/src/di_resolving.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 0, binding = 4)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 5)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 6, uniform)] world: &World,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)]
    atmosphere_transmittance_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 2)]
    atmosphere_transmittance_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 3)] atmosphere_sky_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 4)]
    atmosphere_sky_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 5)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 6)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 7, storage_buffer)]
    next_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 8, storage_buffer)]
    prev_reservoirs: &mut [Vec4],
    #[spirv(descriptor_set = 1, binding = 9)] diff_output: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 10)] spec_output: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);
    let lights = LightsView::new(lights);
    let atmosphere = Atmosphere::new(
        atmosphere_transmittance_lut_tex,
        atmosphere_transmittance_lut_sampler,
        atmosphere_sky_lut_tex,
        atmosphere_sky_lut_sampler,
    );

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let hit = Hit::new(
        camera.ray(screen_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(screen_pos),
            prim_gbuffer_d1.read(screen_pos),
        ]),
    );

    let mut res =
        DiReservoir::read(next_reservoirs, camera.screen_to_idx(screen_pos));

    let confidence;
    let radiance;

    if hit.is_some() {
        let is_occluded = res.sample.ray(hit.point).intersect(
            local_idx,
            stack,
            triangles,
            bvh,
            materials,
            atlas_tex,
            atlas_sampler,
        );

        confidence = if res.sample.is_occluded == is_occluded {
            res.sample.confidence
        } else {
            0.0
        };

        res.sample.confidence = 1.0;
        res.sample.is_occluded = is_occluded;

        radiance = if res.sample.is_occluded {
            LightRadiance::default()
        } else {
            lights.get(res.sample.light_id).radiance(hit) * res.w
        };
    } else {
        confidence = 1.0;

        radiance = LightRadiance {
            radiance: atmosphere.sample(world.sun_dir(), hit.dir),
            diff_brdf: Vec3::ONE,
            spec_brdf: Vec3::ZERO,
        };
    };

    unsafe {
        let diff_brdf = (1.0 - hit.gbuffer.metallic) / PI;
        let spec_brdf = radiance.spec_brdf;

        diff_output.write(
            screen_pos,
            (radiance.radiance * diff_brdf).extend(confidence),
        );

        spec_output.write(
            screen_pos,
            (radiance.radiance * spec_brdf).extend(confidence),
        );
    }

    res.write(prev_reservoirs, screen_idx);
}

```

`strolle-shaders/src/di_sampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0)] blue_noise_tex: TexRgba8,
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 4, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 0, binding = 5)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 6)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 7, uniform)] world: &World,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3, storage_buffer)]
    out_reservoirs: &mut [Vec4],
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);
    let bnoise = BlueNoise::new(blue_noise_tex, screen_pos, params.frame);
    let mut wnoise = WhiteNoise::new(params.seed, screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);
    let lights = LightsView::new(lights);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let hit = Hit::new(
        camera.ray(screen_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(screen_pos),
            prim_gbuffer_d1.read(screen_pos),
        ]),
    );

    if hit.is_none() {
        return;
    }

    // ---

    let mut res = EphemeralReservoir::build(&mut wnoise, lights, *world, hit);

    let res = if res.m > 0.0 {
        let ray = lights
            .get(res.sample.light_id)
            .ray_bnoise(bnoise.first_sample(), hit.point);

        let is_occluded = ray.intersect(
            local_idx,
            stack,
            triangles,
            bvh,
            materials,
            atlas_tex,
            atlas_sampler,
        );

        if is_occluded {
            res.w = 0.0;
        }

        DiReservoir {
            reservoir: Reservoir {
                sample: DiSample {
                    pdf: 0.0,
                    confidence: 0.0,
                    light_id: res.sample.light_id,
                    light_point: ray.origin(),
                    is_occluded,
                },
                m: 1.0,
                w: res.w,
            },
        }
    } else {
        Default::default()
    };

    res.write(out_reservoirs, screen_idx);
}

```

`strolle-shaders/src/di_spatial_resampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn pick(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3, storage_buffer)]
    reservoirs: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 4)] buf_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 5)] buf_d1: TexRgba32,
) {
    let global_id = global_id.xy();
    let lhs_pos = resolve_checkerboard_alt(global_id, params.frame.get() / 2);
    let lhs_idx = camera.screen_to_idx(lhs_pos);
    let mut wnoise = WhiteNoise::new(params.seed, lhs_pos);
    let lights = LightsView::new(lights);

    let buf_pos_a = global_id * uvec2(2, 1);
    let buf_pos_b = buf_pos_a + uvec2(1, 0);

    if !camera.contains(lhs_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let lhs_hit = Hit::new(
        camera.ray(lhs_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(lhs_pos),
            prim_gbuffer_d1.read(lhs_pos),
        ]),
    );

    if lhs_hit.is_none() {
        return;
    }

    // ---

    let lhs = DiReservoir::read(reservoirs, lhs_idx);

    // ---

    let mut rhs = DiReservoir::default();
    let mut rhs_nth = 0;
    let mut rhs_idx = 0;
    let mut rhs_hit = Hit::default();

    let max_samples = 8;
    let mut max_radius = 128.0;

    while rhs_nth < max_samples {
        rhs_nth += 1;

        let rhs_pos = camera.contain(
            (lhs_pos.as_vec2() + wnoise.sample_disk() * max_radius).as_ivec2(),
        );

        if rhs_pos == lhs_pos {
            continue;
        }

        rhs_hit = Hit::new(
            camera.ray(rhs_pos),
            GBufferEntry::unpack([
                prim_gbuffer_d0.read(rhs_pos),
                prim_gbuffer_d1.read(rhs_pos),
            ]),
        );

        if rhs_hit.is_none() {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        if (rhs_hit.gbuffer.depth - lhs_hit.gbuffer.depth).abs()
            > 0.33 * lhs_hit.gbuffer.depth
        {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        if rhs_hit.gbuffer.normal.dot(lhs_hit.gbuffer.normal) < 0.33 {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        rhs_idx = camera.screen_to_idx(rhs_pos);
        rhs = DiReservoir::read(reservoirs, rhs_idx);

        if !rhs.is_empty() {
            break;
        }
    }

    // ---

    if rhs.is_empty() {
        unsafe {
            buf_d1.write(buf_pos_a, Vec4::ZERO);
            buf_d1.write(buf_pos_b, Vec4::ZERO);
        }

        return;
    }

    let lhs_rhs_pdf = lhs.sample.pdf(lights, rhs_hit);
    let rhs_lhs_pdf = rhs.sample.pdf(lights, lhs_hit);

    let ray_a = if lhs_rhs_pdf > 0.0 {
        lhs.sample.ray(rhs_hit.point)
    } else {
        Default::default()
    };

    let ray_b = if rhs_lhs_pdf > 0.0 {
        rhs.sample.ray(lhs_hit.point)
    } else {
        Default::default()
    };

    unsafe {
        buf_d0.write(buf_pos_a, ray_a.origin().extend(ray_a.len()));

        buf_d1.write(
            buf_pos_a,
            Normal::encode(ray_a.dir())
                .extend(f32::from_bits(rhs_idx as u32 + 1))
                .extend(Default::default()),
        );

        buf_d0.write(buf_pos_b, ray_b.origin().extend(ray_b.len()));

        buf_d1.write(
            buf_pos_b,
            Normal::encode(ray_b.dir())
                .extend(lhs_rhs_pdf)
                .extend(rhs_lhs_pdf),
        );
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn trace(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] buf_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] buf_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3)] buf_d2: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let ray_d0 = buf_d0.read(screen_pos);
    let ray_d1 = buf_d1.read(screen_pos);

    if ray_d1 == Default::default() {
        unsafe {
            buf_d2.write(screen_pos, Vec4::ZERO);
        }

        return;
    }

    let ray =
        Ray::new(ray_d0.xyz(), Normal::decode(ray_d1.xy())).with_len(ray_d0.w);

    let is_occluded = ray.intersect(
        local_idx,
        stack,
        triangles,
        bvh,
        materials,
        atlas_tex,
        atlas_sampler,
    );

    let visibility = if is_occluded { 0.0 } else { 1.0 };

    unsafe {
        buf_d2.write(
            screen_pos,
            vec4(visibility, ray_d1.z, ray_d1.w, Default::default()),
        );
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn sample(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)]
    in_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    out_reservoirs: &mut [Vec4],
    #[spirv(descriptor_set = 0, binding = 3)] buf_d2: TexRgba32,
) {
    let global_id = global_id.xy();
    let lhs_pos = resolve_checkerboard_alt(global_id, params.frame.get() / 2);
    let lhs_idx = camera.screen_to_idx(lhs_pos);
    let mut wnoise = WhiteNoise::new(params.seed, lhs_pos);

    let buf_pos_a = global_id * uvec2(2, 1);
    let buf_pos_b = buf_pos_a + uvec2(1, 0);

    if !camera.contains(lhs_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let d0: Vec4 = buf_d2.read(buf_pos_a);
    let d1: Vec4 = buf_d2.read(buf_pos_b);

    let lhs_rhs_vis = d0.x;
    let rhs_idx = d0.y.to_bits();

    let rhs_lhs_vis = d1.x;
    let lhs_rhs_pdf = d1.y;
    let rhs_lhs_pdf = d1.z;

    // ---

    let lhs = DiReservoir::read(in_reservoirs, lhs_idx);

    if rhs_idx > 0 {
        let rhs = DiReservoir::read(in_reservoirs, rhs_idx as usize - 1);
        let mut main = DiReservoir::default();
        let mut main_pdf = 0.0;

        let mis = Mis {
            lhs_m: lhs.m,
            rhs_m: rhs.m,
            rhs_jacobian: 1.0,
            lhs_lhs_pdf: lhs.sample.pdf,
            lhs_rhs_pdf: lhs_rhs_pdf * lhs_rhs_vis,
            rhs_lhs_pdf: rhs_lhs_pdf * rhs_lhs_vis,
            rhs_rhs_pdf: rhs.sample.pdf,
        }
        .eval();

        if main.update(
            &mut wnoise,
            lhs.sample,
            mis.lhs_mis * mis.lhs_pdf * lhs.w,
        ) {
            main_pdf = mis.lhs_pdf;
        }

        if main.update(
            &mut wnoise,
            rhs.sample,
            mis.rhs_mis * mis.rhs_pdf * rhs.w,
        ) {
            main_pdf = mis.rhs_pdf;
            main.sample.is_occluded = lhs_rhs_vis == 0.0;
        }

        main.m = lhs.m + mis.m;
        main.sample.pdf = main_pdf;
        main.norm_mis(main_pdf);
        main.write(out_reservoirs, lhs_idx);
    } else {
        lhs.write(out_reservoirs, lhs_idx);
    }

    // ---

    let other_idx = camera
        .screen_to_idx(resolve_checkerboard(global_id, params.frame.get() / 2));

    DiReservoir::copy(in_reservoirs, out_reservoirs, other_idx);
}

```

`strolle-shaders/src/di_temporal_resampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 1, binding = 0, uniform)] curr_camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1, uniform)] prev_camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 2)] reprojection_map: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3)] curr_prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 4)] curr_prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 5)] prev_prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 6)] prev_prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 7, storage_buffer)]
    prev_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 8, storage_buffer)]
    curr_reservoirs: &mut [Vec4],
) {
    let lhs_pos = global_id.xy();
    let lhs_idx = curr_camera.screen_to_idx(lhs_pos);
    let mut wnoise = WhiteNoise::new(params.seed, lhs_pos);
    let lights = LightsView::new(lights);
    let reprojection_map = ReprojectionMap::new(reprojection_map);

    if !curr_camera.contains(lhs_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let lhs_hit = Hit::new(
        curr_camera.ray(lhs_pos),
        GBufferEntry::unpack([
            curr_prim_gbuffer_d0.read(lhs_pos),
            curr_prim_gbuffer_d1.read(lhs_pos),
        ]),
    );

    if lhs_hit.is_none() {
        return;
    }

    // ---

    let mut lhs = DiReservoir::read(curr_reservoirs, lhs_idx);

    if !lhs.is_empty() {
        lhs.sample.pdf = lhs.sample.pdf(lights, lhs_hit);
    }

    // ---

    let mut rhs = DiReservoir::default();
    let mut rhs_hit = Hit::default();
    let mut rhs_killed = false;

    let reprojection = reprojection_map.get(lhs_pos);

    if reprojection.is_some() {
        let rhs_pos = reprojection.prev_pos_round();

        rhs = DiReservoir::read(
            prev_reservoirs,
            curr_camera.screen_to_idx(rhs_pos),
        );

        rhs.clamp_m(64.0);

        if !rhs.is_empty() {
            let rhs_light = lights.get(rhs.sample.light_id);

            if rhs_light.is_slot_killed() {
                rhs.w = 0.0;
                rhs_killed = true;
            } else if rhs_light.is_slot_remapped() {
                rhs.sample.light_id = rhs_light.slot_remapped_to();
            }

            rhs_hit = Hit::new(
                prev_camera.ray(rhs_pos),
                GBufferEntry::unpack([
                    prev_prim_gbuffer_d0.read(rhs_pos),
                    prev_prim_gbuffer_d1.read(rhs_pos),
                ]),
            );
        }
    }

    // ---

    let mut main = DiReservoir::default();
    let mut main_pdf = 0.0;

    let mis =
        Mis::di_temporal(lights, lhs, lhs_hit, rhs, rhs_hit, rhs_killed).eval();

    if main.update(&mut wnoise, lhs.sample, mis.lhs_mis * mis.lhs_pdf * lhs.w) {
        main_pdf = mis.lhs_pdf;
    }

    if main.update(&mut wnoise, rhs.sample, mis.rhs_mis * mis.rhs_pdf * rhs.w) {
        main_pdf = mis.rhs_pdf;
    }

    main.m = lhs.m + mis.m;
    main.sample.pdf = main_pdf;
    main.sample.confidence = if rhs_killed { 0.0 } else { 1.0 };
    main.norm_mis(main_pdf);
    main.write(curr_reservoirs, lhs_idx);
}

```

`strolle-shaders/src/frame_composition.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(vertex)]
pub fn vs(
    #[spirv(vertex_index)] vert_idx: i32,
    #[spirv(position)] output: &mut Vec4,
) {
    fn full_screen_triangle(vert_idx: i32) -> Vec4 {
        let uv = vec2(((vert_idx << 1) & 2) as f32, (vert_idx & 2) as f32);
        let pos = 2.0 * uv - Vec2::ONE;

        pos.extend(0.0).extend(1.0)
    }

    *output = full_screen_triangle(vert_idx);
}

#[spirv(fragment)]
pub fn fs(
    #[spirv(frag_coord)] pos: Vec4,
    #[spirv(push_constant)] params: &FrameCompositionPassParams,
    #[spirv(descriptor_set = 0, binding = 0)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 1)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] di_diff_colors: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3)] di_spec_colors: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 4)] gi_diff_colors: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 5)] gi_spec_colors: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 6)] ref_colors: TexRgba32,
    frag_color: &mut Vec4,
) {
    let screen_pos = pos.xy().as_uvec2();

    let gbuffer = GBufferEntry::unpack([
        prim_gbuffer_d0.read(screen_pos),
        prim_gbuffer_d1.read(screen_pos),
    ]);

    let color = match params.camera_mode {
        // CameraMode::Image
        0 => {
            let di_diff = di_diff_colors.read(screen_pos).xyz();
            let di_spec = di_spec_colors.read(screen_pos).xyz();
            let gi_diff = gi_diff_colors.read(screen_pos).xyz();
            let gi_spec = gi_spec_colors.read(screen_pos).xyz();

            if gbuffer.is_some() {
                gbuffer.emissive
                    + (di_diff + gi_diff) * gbuffer.base_color.xyz()
                    + di_spec
                    + gi_spec
            } else {
                di_diff
            }
        }

        // CameraMode::DiDiffuse
        1 => di_diff_colors.read(screen_pos).xyz(),

        // CameraMode::DiSpecular
        2 => di_spec_colors.read(screen_pos).xyz(),

        // CameraMode::GiDiffuse
        3 => gi_diff_colors.read(screen_pos).xyz(),

        // CameraMode::GiSpecular
        4 => gi_spec_colors.read(screen_pos).xyz(),

        // CameraMode::BvhHeatmap
        5 => ref_colors.read(screen_pos).xyz(),

        // CameraMode::Reference
        6 => {
            let color = ref_colors.read(screen_pos);

            color.xyz() / color.w
        }

        _ => Default::default(),
    };

    *frag_color = color.extend(1.0);
}

```

`strolle-shaders/src/frame_denoising.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn reproject(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] reprojection_map: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 0)] prev_colors: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 1)] prev_moments: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] samples: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3)] colors: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 4)] moments: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let prim_surface_map = SurfaceMap::new(prim_surface_map);
    let reprojection_map = ReprojectionMap::new(reprojection_map);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    if prim_surface_map.get(screen_pos).is_sky() {
        unsafe {
            colors.write(screen_pos, samples.read(screen_pos));
        }

        return;
    }

    let color;
    let moment;

    let sample = samples.read(screen_pos);
    let sample_luma = sample.xyz().luma();

    let reprojection = reprojection_map.get(screen_pos);

    if reprojection.is_some() && sample.w > 0.0 {
        let prev_color = BilinearFilter::reproject(reprojection, move |pos| {
            (prev_colors.read(pos), 1.0)
        });

        let prev_moment = BilinearFilter::reproject(reprojection, move |pos| {
            (prev_moments.read(pos), 1.0)
        });

        let prev_color = prev_color.xyz();
        let prev_history = prev_moment.x;
        let prev_m1 = prev_moment.y;
        let prev_m2 = prev_moment.z;

        let curr_color = sample.xyz();
        let curr_history = (prev_history + 1.0).min(16.0);
        let curr_m1 = sample_luma;
        let curr_m2 = sample_luma * sample_luma;

        let alpha = 1.0 / curr_history;

        color = lerp(prev_color, curr_color, alpha);

        moment = vec3(
            curr_history,
            lerp(prev_m1, curr_m1, alpha),
            lerp(prev_m2, curr_m2, alpha),
        );
    } else {
        color = sample.xyz();
        moment = vec3(1.0, sample_luma, sample_luma * sample_luma);
    }

    unsafe {
        colors.write(screen_pos, color.extend(0.0));
        moments.write(screen_pos, moment.extend(0.0));
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn estimate_variance(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 0)] di_colors: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 1)] di_moments: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] di_output: TexRgba32,
    #[spirv(descriptor_set = 2, binding = 0)] gi_colors: TexRgba32,
    #[spirv(descriptor_set = 2, binding = 1)] gi_moments: TexRgba32,
    #[spirv(descriptor_set = 2, binding = 2)] gi_output: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let prim_surface_map = SurfaceMap::new(prim_surface_map);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let center_surface = prim_surface_map.get(screen_pos);

    let center_di_color = di_colors.read(screen_pos);
    let center_di_luma = center_di_color.xyz().luma();
    let center_di_moment = di_moments.read(screen_pos);
    let center_di_var;

    let center_gi_color = gi_colors.read(screen_pos);
    let center_gi_luma = center_gi_color.xyz().luma();
    let center_gi_moment = gi_moments.read(screen_pos);
    let center_gi_var;

    if center_surface.is_sky() {
        unsafe {
            di_output.write(screen_pos, center_di_color);
            gi_output.write(screen_pos, center_gi_color);
        }

        return;
    }

    if center_di_moment.x >= 4.0 {
        center_di_var = center_di_moment.z - center_di_moment.y.sqr();
        center_gi_var = center_gi_moment.z - center_gi_moment.y.sqr();
    } else {
        let mut sum_di = Vec3::ZERO;
        let mut sum_gi = Vec3::ZERO;
        let mut sample_offset = ivec2(-2, -2);

        loop {
            let sample_pos = screen_pos.as_ivec2() + sample_offset;

            if camera.contains(sample_pos) {
                let sample_pos = sample_pos.as_uvec2();
                let sample_surface = prim_surface_map.get(sample_pos);

                if !sample_surface.is_sky() {
                    let sample_di_color = di_colors.read(sample_pos);
                    let sample_di_luma = sample_di_color.xyz().luma();

                    let sample_di_weight = sample_weight(
                        center_di_luma,
                        center_surface,
                        sample_di_luma,
                        sample_surface,
                        1.0,
                        0.2,
                    );

                    sum_di += vec3(
                        sample_di_luma,
                        sample_di_luma * sample_di_luma,
                        1.0,
                    ) * Vec3::splat(sample_di_weight);

                    // ---

                    let sample_gi_color = gi_colors.read(sample_pos);
                    let sample_gi_luma = sample_gi_color.xyz().luma();

                    let sample_gi_weight = sample_weight(
                        center_gi_luma,
                        center_surface,
                        sample_gi_luma,
                        sample_surface,
                        1.0,
                        0.2,
                    );

                    sum_gi += vec3(
                        sample_gi_luma,
                        sample_gi_luma * sample_gi_luma,
                        1.0,
                    ) * Vec3::splat(sample_gi_weight);
                }
            }

            // ---

            sample_offset.x += 1;

            if sample_offset.x == 3 {
                sample_offset.x = -3;
                sample_offset.y += 1;

                if sample_offset.y == 3 {
                    break;
                }
            }
        }

        center_di_var = {
            let m1 = sum_di.x / sum_di.z;
            let m2 = sum_di.y / sum_di.z;

            (m2 - m1 * m1).abs() * 4.0
        };

        center_gi_var = {
            let m1 = sum_gi.x / sum_gi.z;
            let m2 = sum_gi.y / sum_gi.z;

            (m2 - m1 * m1).abs() * 4.0
        };
    };

    let center_di_var = center_di_var.max(0.0);
    let center_gi_var = center_gi_var.max(0.0);

    unsafe {
        di_output
            .write(screen_pos, center_di_color.xyz().extend(center_di_var));

        gi_output
            .write(screen_pos, center_gi_color.xyz().extend(center_gi_var));
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn wavelet(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &FrameDenoisingWaveletPassParams,
    #[spirv(descriptor_set = 0, binding = 0)] blue_noise_tex: TexRgba8,
    #[spirv(descriptor_set = 0, binding = 1, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 2)] prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 0)] di_input: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 1)] di_output: TexRgba32,
    #[spirv(descriptor_set = 2, binding = 0)] gi_input: TexRgba32,
    #[spirv(descriptor_set = 2, binding = 1)] gi_output: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let bnoise = BlueNoise::new(blue_noise_tex, screen_pos, params.frame);
    let prim_surface_map = SurfaceMap::new(prim_surface_map);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let center_surface = prim_surface_map.get(screen_pos);

    let center_di = di_input.read(screen_pos);
    let center_di_color = center_di.xyz();
    let center_di_var = center_di.w;
    let center_di_luma = center_di_color.luma();

    if center_surface.is_sky() {
        unsafe {
            di_output.write(screen_pos, center_di_color.extend(center_di_var));
        }

        return;
    }

    let center_gi = gi_input.read(screen_pos);
    let center_gi_color = center_gi.xyz();
    let center_gi_var = center_gi.w;
    let center_gi_luma = center_gi_color.luma();

    // ---

    let luma_sigma_di = lerp(2.5, 0.5, center_di_var.sqrt());
    let depth_sigma_di = 0.33 / params.strength;

    let luma_sigma_gi = lerp(1.0, 0.0, center_gi_var.sqrt());
    let depth_sigma_gi = 0.33 / params.strength;

    let jitter =
        ((bnoise.second_sample() - 0.5) * (params.stride as f32 - 1.0) * 0.5)
            .as_ivec2();

    let mut sum_di_weights = 1.0;
    let mut sum_di_color = center_di_color;
    let mut sum_di_var = center_di_var;

    let mut sum_gi_weights = 1.0;
    let mut sum_gi_color = center_gi_color;
    let mut sum_gi_var = center_gi_var;

    let mut sample_offset = ivec2(-1, -1);

    loop {
        let sample_pos = screen_pos.as_ivec2()
            + jitter
            + sample_offset * (params.stride as i32);

        if camera.contains(sample_pos) && sample_offset != ivec2(0, 0) {
            let sample_pos = sample_pos.as_uvec2();
            let sample_surface = prim_surface_map.get(sample_pos);

            if !sample_surface.is_sky() {
                let sample_di = di_input.read(sample_pos);
                let sample_di_color = sample_di.xyz();
                let sample_di_var = sample_di.w;
                let sample_di_luma = sample_di_color.luma();

                let sample_di_weight = sample_weight(
                    center_di_luma,
                    center_surface,
                    sample_di_luma,
                    sample_surface,
                    luma_sigma_di,
                    depth_sigma_di,
                );

                if sample_di_weight > 0.0 {
                    sum_di_weights += sample_di_weight;
                    sum_di_color += sample_di_weight * sample_di_color;
                    sum_di_var += sample_di_weight.sqr() * sample_di_var;
                }

                // ---

                let sample_gi = gi_input.read(sample_pos);
                let sample_gi_color = sample_gi.xyz();
                let sample_gi_var = sample_gi.w;
                let sample_gi_luma = sample_gi_color.luma();

                let sample_gi_weight = sample_weight(
                    center_gi_luma,
                    center_surface,
                    sample_gi_luma,
                    sample_surface,
                    luma_sigma_gi,
                    depth_sigma_gi,
                );

                if sample_gi_weight > 0.0 {
                    sum_gi_weights += sample_gi_weight;
                    sum_gi_color += sample_gi_weight * sample_gi_color;
                    sum_gi_var += sample_gi_weight.sqr() * sample_gi_var;
                }
            }
        }

        // ---

        sample_offset.x += 1;

        if sample_offset.x == 2 {
            sample_offset.x = -1;
            sample_offset.y += 1;

            if sample_offset.y == 2 {
                break;
            }
        }
    }

    let out_di_color = sum_di_color / sum_di_weights;
    let out_di_var = sum_di_var / (sum_di_weights * sum_di_weights);

    let out_gi_color = sum_gi_color / sum_gi_weights;
    let out_gi_var = sum_gi_var / (sum_gi_weights * sum_gi_weights);

    unsafe {
        di_output.write(screen_pos, out_di_color.extend(out_di_var));
        gi_output.write(screen_pos, out_gi_color.extend(out_gi_var));
    }
}

fn sample_weight(
    center_luma: f32,
    center_surface: Surface,
    sample_luma: f32,
    sample_surface: Surface,
    luma_sigma: f32,
    depth_sigma: f32,
) -> f32 {
    let luma_weight =
        (center_luma.sqrt() - sample_luma.sqrt()).abs() * luma_sigma;

    let depth_weight = {
        let leeway = center_surface.depth * depth_sigma;
        let diff = (sample_surface.depth - center_surface.depth).abs();

        if diff >= leeway {
            0.0
        } else {
            1.0 - diff / leeway
        }
    };

    let normal_weight = sample_surface
        .normal
        .dot(center_surface.normal)
        .max(0.0)
        .powf(64.0);

    (-luma_weight).exp() * depth_weight * normal_weight
}

```

`strolle-shaders/src/frame_reprojection.rs`:

```rs
//! This pass performs camera reprojection, i.e. it finds out where each pixel
//! was located in the previous frame.

use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1, uniform)] prev_camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 2)] prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3)] prev_prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 4)] velocity_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 5)] reprojection_map: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let prim_surface_map = SurfaceMap::new(prim_surface_map);
    let prev_prim_surface_map = SurfaceMap::new(prev_prim_surface_map);
    let reprojection_map = ReprojectionMap::new(reprojection_map);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let mut reprojection = Reprojection::default();
    let surface = prim_surface_map.get(screen_pos);

    if surface.is_sky() {
        reprojection_map.set(screen_pos, &reprojection);
        return;
    }

    // -------------------------------------------------------------------------

    let prev_screen_pos =
        screen_pos.as_vec2() - velocity_map.read(screen_pos).xy();

    if prev_camera.contains(prev_screen_pos.round()) {
        let prev_surface =
            prev_prim_surface_map.get(prev_screen_pos.round().as_uvec2());

        let confidence = prev_surface.evaluate_similarity_to(surface);

        if confidence > 0.0 {
            reprojection = Reprojection {
                prev_x: prev_screen_pos.x,
                prev_y: prev_screen_pos.y,
                confidence,
                validity: 0,
            };
        }
    }

    // -------------------------------------------------------------------------

    if reprojection.is_some() {
        let check_validity = move |sample_pos: IVec2| {
            if !camera.contains(sample_pos) {
                return false;
            }

            prev_prim_surface_map
                .get(sample_pos.as_uvec2())
                .evaluate_similarity_to(surface)
                >= 0.25
        };

        let [p00, p10, p01, p11] = BilinearFilter::reprojection_coords(
            reprojection.prev_x,
            reprojection.prev_y,
        );

        if check_validity(p00) {
            reprojection.validity |= 0b0001;
        }

        if check_validity(p10) {
            reprojection.validity |= 0b0010;
        }

        if check_validity(p01) {
            reprojection.validity |= 0b0100;
        }

        if check_validity(p11) {
            reprojection.validity |= 0b1000;
        }
    }

    // -------------------------------------------------------------------------

    reprojection_map.set(screen_pos, &reprojection);
}

```

`strolle-shaders/src/gi_preview_resampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &GiPreviewResamplingPass,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3)] prim_surface_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 4, storage_buffer)]
    in_reservoirs_a: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 5, storage_buffer)]
    in_reservoirs_b: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 6, storage_buffer)]
    out_reservoirs: &mut [Vec4],
) {
    let center_pos = global_id.xy();
    let center_idx = camera.screen_to_idx(center_pos);
    let mut wnoise = WhiteNoise::new(params.seed, center_pos);
    let prim_surface_map = SurfaceMap::new(prim_surface_map);

    if !camera.contains(center_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let center_hit = Hit::new(
        camera.ray(center_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(center_pos),
            prim_gbuffer_d1.read(center_pos),
        ]),
    );

    if center_hit.is_none() {
        GiReservoir::default().write(out_reservoirs, center_idx);
        return;
    }

    // -------------------------------------------------------------------------

    let mut main = GiReservoir::default();
    let mut main_pdf = 0.0;

    // ---

    let center = if params.source == 0 {
        GiReservoir::read(in_reservoirs_a, center_idx)
    } else {
        GiReservoir::read(in_reservoirs_b, center_idx)
    };

    if main.merge(&mut wnoise, &center, center.sample.pdf) {
        main_pdf = center.sample.pdf;
    }

    // ---

    let max_samples;
    let max_radius;

    if params.nth == 0 {
        max_samples = lerp(8.0, 0.0, main.m / 8.0) as u32;
        max_radius = 128.0;
    } else {
        max_samples = lerp(8.0, 0.0, main.m / 8.0) as u32;
        max_radius = 64.0;
    }

    // ---

    let mut sample_nth = 0;

    while sample_nth < max_samples {
        sample_nth += 1;

        let sample_pos = camera.contain(
            (center_pos.as_vec2() + wnoise.sample_disk() * max_radius)
                .as_ivec2(),
        );

        if sample_pos == center_pos {
            return;
        }

        let sample_surface = prim_surface_map.get(sample_pos);

        if sample_surface.is_sky() {
            continue;
        }

        if (sample_surface.depth - center_hit.gbuffer.depth).abs()
            > 0.25 * center_hit.gbuffer.depth
        {
            continue;
        }

        if sample_surface.normal.dot(center_hit.gbuffer.normal) < 0.5 {
            continue;
        }

        let sample = if params.source == 0 {
            GiReservoir::read(in_reservoirs_a, camera.screen_to_idx(sample_pos))
        } else {
            GiReservoir::read(in_reservoirs_b, camera.screen_to_idx(sample_pos))
        };

        if sample.is_empty() {
            continue;
        }

        let sample_pdf = sample.sample.pdf(center_hit);
        let sample_jacobian = sample.sample.jacobian(center_hit.point);

        // TODO rust-gpu seems to miscompile `.contains()`
        #[allow(clippy::manual_range_contains)]
        if sample_jacobian < 1.0 / 10.0 || sample_jacobian > 10.0 {
            continue;
        }

        let sample_jacobian = sample_jacobian.clamp(1.0 / 3.0, 3.0);

        if main.merge(&mut wnoise, &sample, sample_pdf * sample_jacobian) {
            main_pdf = sample_pdf;
        }
    }

    // -------------------------------------------------------------------------

    main.confidence = center.confidence;
    main.sample.pdf = main_pdf;
    main.sample.v1_point = center.sample.v1_point;
    main.norm_avg(main_pdf);
    main.clamp_w(5.0);
    main.write(out_reservoirs, center_idx);
}

```

`strolle-shaders/src/gi_reprojection.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3)] reprojection_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 4, storage_buffer)]
    in_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 5, storage_buffer)]
    out_reservoirs: &mut [Vec4],
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);
    let reprojection_map = ReprojectionMap::new(reprojection_map);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let hit = Hit::new(
        camera.ray(screen_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(screen_pos),
            prim_gbuffer_d1.read(screen_pos),
        ]),
    );

    if hit.is_none() {
        return;
    }

    let reprojection = reprojection_map.get(screen_pos);

    let mut res = if reprojection.is_some() {
        GiReservoir::read(
            in_reservoirs,
            camera.screen_to_idx(reprojection.prev_pos_round()),
        )
    } else {
        GiReservoir::default()
    };

    res.confidence = 1.0;
    res.sample.v1_point = hit.point;
    res.write(out_reservoirs, screen_idx);
}

```

`strolle-shaders/src/gi_resolving.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &GiResolvingPassParams,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    in_reservoirs_a: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 4, storage_buffer)]
    in_reservoirs_b: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 5, storage_buffer)]
    out_reservoirs: &mut [Vec4],
    #[spirv(descriptor_set = 0, binding = 6)] diff_output: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 7)] spec_output: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let hit = Hit::new(
        camera.ray(screen_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(screen_pos),
            prim_gbuffer_d1.read(screen_pos),
        ]),
    );

    let res = GiReservoir::read(out_reservoirs, screen_idx);

    let confidence;
    let radiance;

    if hit.is_some() {
        confidence = res.confidence;
        radiance = res.w * res.sample.cosine(hit) * res.sample.radiance;
    } else {
        confidence = 1.0;
        radiance = Vec3::ZERO;
    };

    unsafe {
        let diff_brdf = (1.0 - hit.gbuffer.metallic) / PI;
        let spec_brdf = res.sample.spec_brdf(hit);

        diff_output
            .write(screen_pos, (radiance * diff_brdf).extend(confidence));

        spec_output
            .write(screen_pos, (radiance * spec_brdf).extend(confidence));
    }

    // ---

    if params.source == 0 {
        GiReservoir::copy(in_reservoirs_a, out_reservoirs, screen_idx);
    } else {
        GiReservoir::copy(in_reservoirs_b, out_reservoirs, screen_idx);
    }
}

```

`strolle-shaders/src/gi_sampling_a.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3)] gi_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 4)] gi_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 5)] gi_d2: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 6, storage_buffer)]
    reservoirs: &[Vec4],
) {
    let global_id = global_id.xy();

    let screen_pos = if params.frame.is_gi_tracing() {
        resolve_checkerboard(global_id, params.frame.get() / 2)
    } else {
        resolve_checkerboard(global_id, params.frame.get())
    };

    let screen_idx = camera.screen_to_idx(screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let gi_ray;
    let gi_ray_pdf;

    if params.frame.is_gi_tracing() {
        let mut wnoise = WhiteNoise::new(params.seed, screen_pos);

        let hit = Hit::new(
            camera.ray(screen_pos),
            GBufferEntry::unpack([
                prim_gbuffer_d0.read(screen_pos),
                prim_gbuffer_d1.read(screen_pos),
            ]),
        );

        if hit.is_none() {
            return;
        } else {
            let sample =
                LayeredBrdf::new(hit.gbuffer).sample(&mut wnoise, -hit.dir);

            gi_ray = Ray::new(hit.point, sample.dir);
            gi_ray_pdf = sample.pdf;
        }
    } else {
        let res = GiReservoir::read(reservoirs, screen_idx);

        if res.is_empty() {
            return;
        }

        gi_ray =
            Ray::new(res.sample.v1_point, res.sample.dir(res.sample.v1_point));

        gi_ray_pdf = 1.0;
    };

    let (gi_hit, _) = gi_ray.trace(
        local_idx,
        stack,
        triangles,
        bvh,
        materials,
        atlas_tex,
        atlas_sampler,
    );

    // ---

    let gi_gbuffer = if gi_hit.is_some() {
        let mut gi_material = materials.get(gi_hit.material_id);

        gi_material.regularize();

        GBufferEntry {
            base_color: gi_material.base_color(
                atlas_tex,
                atlas_sampler,
                gi_hit.uv,
            ),
            normal: gi_hit.normal,
            metallic: gi_material.metallic,
            emissive: gi_material.emissive(atlas_tex, atlas_sampler, gi_hit.uv),
            roughness: gi_material.roughness,
            reflectance: gi_material.reflectance,
            depth: gi_ray.origin().distance(gi_hit.point),
        }
    } else {
        Default::default()
    };

    let d0 = gi_ray.dir().extend(gi_ray_pdf);
    let [d1, d2] = gi_gbuffer.pack();

    unsafe {
        gi_d0.write(global_id, d0);
        gi_d1.write(global_id, d1);
        gi_d2.write(global_id, d2);
    }
}

```

`strolle-shaders/src/gi_sampling_b.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 4)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 5)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 6, uniform)] world: &World,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)]
    atmosphere_transmittance_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 2)]
    atmosphere_transmittance_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 3)] atmosphere_sky_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 4)]
    atmosphere_sky_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 5)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 6)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 7)] gi_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 8)] gi_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 9)] gi_d2: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 10, storage_buffer)]
    prev_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 11, storage_buffer)]
    curr_reservoirs: &mut [Vec4],
) {
    let global_id = global_id.xy();

    let screen_pos = if params.frame.is_gi_tracing() {
        resolve_checkerboard(global_id, params.frame.get() / 2)
    } else {
        resolve_checkerboard(global_id, params.frame.get())
    };

    let screen_idx = camera.screen_to_idx(screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let lights = LightsView::new(lights);
    let materials = MaterialsView::new(materials);
    let atmosphere = Atmosphere::new(
        atmosphere_transmittance_lut_tex,
        atmosphere_transmittance_lut_sampler,
        atmosphere_sky_lut_tex,
        atmosphere_sky_lut_sampler,
    );

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let prim_hit = Hit::new(
        camera.ray(screen_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(screen_pos),
            prim_gbuffer_d1.read(screen_pos),
        ]),
    );

    if prim_hit.is_none() {
        return;
    }

    let d0 = gi_d0.read(global_id);
    let d1 = gi_d1.read(global_id);
    let d2 = gi_d2.read(global_id);

    let mut wnoise;
    let gi_hit;
    let gi_ray_pdf;

    if params.frame.is_gi_tracing() {
        wnoise = WhiteNoise::new(params.seed, screen_pos);

        gi_hit = Hit::new(
            Ray::new(prim_hit.point, d0.xyz()),
            GBufferEntry::unpack([d1, d2]),
        );

        gi_ray_pdf = d0.w;
    } else {
        let res = GiReservoir::read(prev_reservoirs, screen_idx);

        if res.is_empty() {
            return;
        } else {
            wnoise = WhiteNoise::from_state(res.sample.rng);

            gi_hit = Hit::new(
                Ray::new(res.sample.v1_point, d0.xyz()),
                GBufferEntry::unpack([d1, d2]),
            );

            gi_ray_pdf = 1.0;
        }
    }

    // -------------------------------------------------------------------------

    let rng = wnoise.state();

    let light_id;
    let light_pdf;
    let light_rad;
    let mut light_dir = Vec3::ZERO;

    if gi_hit.is_none() {
        light_id = LightId::sky();
        light_pdf = 1.0;
        light_rad = atmosphere.sample(world.sun_dir(), gi_hit.dir);
    } else {
        let atmosphere_pdf = if world.sun_altitude <= -1.0 {
            0.0
        } else {
            0.25
        };

        if world.light_count == 0 || wnoise.sample() < atmosphere_pdf {
            light_id = LightId::sky();
            light_pdf = atmosphere_pdf;
            light_dir = wnoise.sample_hemisphere(gi_hit.gbuffer.normal);

            light_rad = atmosphere.sample(world.sun_dir(), light_dir)
                * gi_hit.gbuffer.normal.dot(light_dir);
        } else {
            let res =
                EphemeralReservoir::build(&mut wnoise, lights, *world, gi_hit);

            if res.w > 0.0 {
                // For simplicity, we assume an unmodulated diffuse BRDF here
                // and modulate it later, a few lines below
                let light_diff_brdf = Vec3::ONE;
                let light_spec_brdf = res.sample.light_rad.spec_brdf;

                light_id = res.sample.light_id;
                light_pdf = (1.0 / res.w) * (1.0 - atmosphere_pdf);

                light_rad = res.sample.light_rad.radiance
                    * (light_diff_brdf + light_spec_brdf);
            } else {
                light_id = LightId::new(0);
                light_pdf = 1.0;
                light_rad = Vec3::ZERO;
            }
        }
    }

    // -------------------------------------------------------------------------

    let mut radiance = if light_pdf > 0.0 {
        let light_vis = if gi_hit.is_some() {
            let ray = if light_id == LightId::sky() {
                Ray::new(gi_hit.point, light_dir)
            } else {
                lights.get(light_id).ray_wnoise(&mut wnoise, gi_hit.point)
            };

            let is_occluded = ray.intersect(
                local_idx,
                stack,
                triangles,
                bvh,
                materials,
                atlas_tex,
                atlas_sampler,
            );

            if is_occluded {
                0.0
            } else {
                1.0
            }
        } else {
            // If we hit nothing, our indirect-ray must be pointing towards
            // the sky - no point retracing it, then
            1.0
        };

        light_rad * light_vis / light_pdf
    } else {
        // If the probability of hitting our light is non-positive, there are
        // probably no lights present on the scene - in this case zeroing-out
        // the radiance is best we can do
        Vec3::ZERO
    };

    if gi_hit.is_some() {
        radiance *= gi_hit.gbuffer.base_color.xyz() / PI;
        radiance += gi_hit.gbuffer.emissive;
    }

    // -------------------------------------------------------------------------

    let mut res = GiReservoir::default();

    if gi_ray_pdf > 0.0 {
        let v1_point = prim_hit.point;
        let v2_point;
        let v2_normal;

        if gi_hit.is_some() {
            v2_point = gi_hit.point;
            v2_normal = gi_hit.gbuffer.normal;
        } else {
            v2_point = v1_point + gi_hit.dir * World::SUN_DISTANCE;
            v2_normal = -gi_hit.dir;
        }

        res.sample = GiSample {
            pdf: 0.0,
            rng,
            radiance,
            v1_point,
            v2_point,
            v2_normal,
        };

        res.m = 1.0;
        res.w = 1.0 / gi_ray_pdf;
        res.sample.pdf = res.sample.pdf(prim_hit);
    }

    res.write(curr_reservoirs, screen_idx);
}

```

`strolle-shaders/src/gi_spatial_resampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn pick(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1)] prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 2)] prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    reservoirs: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 4)] buf_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 5)] buf_d1: TexRgba32,
) {
    let global_id = global_id.xy();
    let lhs_pos = resolve_checkerboard_alt(global_id, params.frame.get() / 2);
    let lhs_idx = camera.screen_to_idx(lhs_pos);
    let mut wnoise = WhiteNoise::new(params.seed, lhs_pos);

    let buf_pos_a = global_id * uvec2(2, 1);
    let buf_pos_b = buf_pos_a + uvec2(1, 0);

    if !camera.contains(lhs_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let lhs_hit = Hit::new(
        camera.ray(lhs_pos),
        GBufferEntry::unpack([
            prim_gbuffer_d0.read(lhs_pos),
            prim_gbuffer_d1.read(lhs_pos),
        ]),
    );

    let lhs = GiReservoir::read(reservoirs, lhs_idx);

    if lhs_hit.is_none() || lhs.is_empty() {
        unsafe {
            buf_d1.write(buf_pos_a, Vec4::ZERO);
            buf_d1.write(buf_pos_b, Vec4::ZERO);
        }

        return;
    }

    // ---

    let mut rhs = GiReservoir::default();
    let mut rhs_nth = 0;
    let mut rhs_idx = 0;
    let mut rhs_hit = Hit::default();
    let mut rhs_jacobian = 0.0;

    let max_samples = 8;
    let mut max_radius = 128.0;

    while rhs_nth < max_samples {
        rhs_nth += 1;

        let rhs_pos = camera.contain(
            (lhs_pos.as_vec2() + wnoise.sample_disk() * max_radius).as_ivec2(),
        );

        if rhs_pos == lhs_pos {
            continue;
        }

        rhs_hit = Hit::new(
            camera.ray(rhs_pos),
            GBufferEntry::unpack([
                prim_gbuffer_d0.read(rhs_pos),
                prim_gbuffer_d1.read(rhs_pos),
            ]),
        );

        if rhs_hit.is_none() {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        if (rhs_hit.gbuffer.depth - lhs_hit.gbuffer.depth).abs()
            > 0.33 * lhs_hit.gbuffer.depth
        {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        if rhs_hit.gbuffer.normal.dot(lhs_hit.gbuffer.normal) < 0.33 {
            max_radius = (max_radius * 0.5).max(5.0);
            continue;
        }

        rhs_idx = camera.screen_to_idx(rhs_pos);
        rhs = GiReservoir::read(reservoirs, rhs_idx);

        if rhs.is_empty() {
            continue;
        }

        rhs_jacobian = rhs.sample.jacobian(lhs_hit.point);

        // TODO rust-gpu seems to miscompile `.contains()`
        #[allow(clippy::manual_range_contains)]
        if rhs_jacobian < 1.0 / 10.0 || rhs_jacobian > 10.0 {
            rhs.m = 0.0;
            continue;
        }

        rhs_jacobian = rhs_jacobian.clamp(1.0 / 3.0, 3.0);
        break;
    }

    // ---

    if rhs.is_empty() || rhs_hit.is_none() {
        unsafe {
            buf_d1.write(buf_pos_a, Vec4::ZERO);
            buf_d1.write(buf_pos_b, Vec4::ZERO);
        }

        return;
    }

    let lhs_rhs_pdf = lhs.sample.pdf(rhs_hit);
    let rhs_lhs_pdf = rhs.sample.pdf(lhs_hit);

    let ray_a = if lhs_rhs_pdf > 0.0 {
        lhs.sample.ray(rhs_hit.point)
    } else {
        Default::default()
    };

    let ray_b = if rhs_lhs_pdf > 0.0 {
        rhs.sample.ray(lhs_hit.point)
    } else {
        Default::default()
    };

    unsafe {
        buf_d0.write(buf_pos_a, ray_a.origin().extend(ray_a.len()));

        buf_d1.write(
            buf_pos_a,
            Normal::encode(ray_a.dir())
                .extend(f32::from_bits(rhs_idx as u32 + 1))
                .extend(rhs_jacobian),
        );

        buf_d0.write(buf_pos_b, ray_b.origin().extend(ray_b.len()));

        buf_d1.write(
            buf_pos_b,
            Normal::encode(ray_b.dir())
                .extend(lhs_rhs_pdf)
                .extend(rhs_lhs_pdf),
        );
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn trace(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1)] buf_d0: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 2)] buf_d1: TexRgba32,
    #[spirv(descriptor_set = 1, binding = 3)] buf_d2: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let ray_d0 = buf_d0.read(screen_pos);
    let ray_d1 = buf_d1.read(screen_pos);

    if ray_d1 == Default::default() {
        unsafe {
            buf_d2.write(screen_pos, Vec4::ZERO);
        }

        return;
    }

    let ray =
        Ray::new(ray_d0.xyz(), Normal::decode(ray_d1.xy())).with_len(ray_d0.w);

    let is_occluded = ray.intersect(
        local_idx,
        stack,
        triangles,
        bvh,
        materials,
        atlas_tex,
        atlas_sampler,
    );

    let visibility = if is_occluded { 0.0 } else { 1.0 };

    unsafe {
        buf_d2.write(
            screen_pos,
            vec4(visibility, ray_d1.z, ray_d1.w, Default::default()),
        );
    }
}

#[spirv(compute(threads(8, 8)))]
pub fn sample(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)]
    in_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    out_reservoirs: &mut [Vec4],
    #[spirv(descriptor_set = 0, binding = 3)] buf_d2: TexRgba32,
) {
    let global_id = global_id.xy();
    let screen_pos =
        resolve_checkerboard_alt(global_id, params.frame.get() / 2);
    let screen_idx = camera.screen_to_idx(screen_pos);
    let mut wnoise = WhiteNoise::new(params.seed, screen_pos);

    let buf_pos_a = global_id * uvec2(2, 1);
    let buf_pos_b = buf_pos_a + uvec2(1, 0);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let d0: Vec4 = buf_d2.read(buf_pos_a);
    let d1: Vec4 = buf_d2.read(buf_pos_b);

    let lhs_rhs_vis = d0.x;
    let rhs_idx = d0.y.to_bits();
    let rhs_jacobian = d0.z;

    let rhs_lhs_vis = d1.x;
    let lhs_rhs_pdf = d1.y;
    let rhs_lhs_pdf = d1.z;

    // ---

    let lhs = GiReservoir::read(in_reservoirs, screen_idx);

    if rhs_idx > 0 {
        let rhs = GiReservoir::read(in_reservoirs, rhs_idx as usize - 1);
        let mut main = GiReservoir::default();
        let mut main_pdf = 0.0;

        let mis = Mis {
            lhs_m: lhs.m,
            rhs_m: rhs.m,
            rhs_jacobian,
            lhs_lhs_pdf: lhs.sample.pdf,
            lhs_rhs_pdf: lhs_rhs_pdf * lhs_rhs_vis,
            rhs_lhs_pdf: rhs_lhs_pdf * rhs_lhs_vis,
            rhs_rhs_pdf: rhs.sample.pdf,
        }
        .eval();

        if main.update(
            &mut wnoise,
            lhs.sample,
            mis.lhs_mis * mis.lhs_pdf * lhs.w,
        ) {
            main_pdf = mis.lhs_pdf;
        }

        if main.update(
            &mut wnoise,
            rhs.sample,
            mis.rhs_mis * mis.rhs_pdf * rhs.w * rhs_jacobian,
        ) {
            main_pdf = mis.rhs_pdf;
        }

        main.m = lhs.m + mis.m;
        main.confidence = 1.0;
        main.sample.pdf = main_pdf;
        main.sample.v1_point = lhs.sample.v1_point;
        main.norm_mis(main_pdf);
        main.clamp_w(5.0);
        main.write(out_reservoirs, screen_idx);
    } else {
        lhs.write(out_reservoirs, screen_idx);
    }

    // ---

    let other_idx = camera
        .screen_to_idx(resolve_checkerboard(global_id, params.frame.get() / 2));

    GiReservoir::copy(in_reservoirs, out_reservoirs, other_idx);
}

```

`strolle-shaders/src/gi_temporal_resampling.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(push_constant)] params: &PassParams,
    #[spirv(descriptor_set = 0, binding = 0, uniform)] curr_camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 1, uniform)] prev_camera: &Camera,
    #[spirv(descriptor_set = 0, binding = 2)] curr_prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 3)] curr_prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 4)] prev_prim_gbuffer_d0: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 5)] prev_prim_gbuffer_d1: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 6)] reprojection_map: TexRgba32,
    #[spirv(descriptor_set = 0, binding = 7, storage_buffer)]
    prev_reservoirs: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 8, storage_buffer)]
    curr_reservoirs: &mut [Vec4],
) {
    let lhs_pos = global_id.xy();
    let lhs_idx = curr_camera.screen_to_idx(lhs_pos);
    let mut wnoise = WhiteNoise::new(params.seed, global_id.xy());
    let reprojection_map = ReprojectionMap::new(reprojection_map);

    if !curr_camera.contains(lhs_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let lhs_hit = Hit::new(
        curr_camera.ray(lhs_pos),
        GBufferEntry::unpack([
            curr_prim_gbuffer_d0.read(lhs_pos),
            curr_prim_gbuffer_d1.read(lhs_pos),
        ]),
    );

    if lhs_hit.is_none() {
        GiReservoir::default().write(curr_reservoirs, lhs_idx);
        return;
    }

    // ---

    let got_sample = if params.frame.is_gi_tracing() {
        params.frame.get() % 2 == 0
            && got_checkerboard_at(lhs_pos, params.frame.get() / 2)
    } else {
        got_checkerboard_at(lhs_pos, params.frame.get())
    };

    let lhs = if got_sample {
        GiReservoir::read(curr_reservoirs, lhs_idx)
    } else {
        GiReservoir::default()
    };

    // ---

    let mut rhs = GiReservoir::default();
    let mut rhs_hit = Hit::default();

    let reprojection = reprojection_map.get(lhs_pos);

    if reprojection.is_some() {
        rhs = GiReservoir::read(prev_reservoirs, lhs_idx);
        rhs.confidence = 1.0;
        rhs.clamp_m(128.0);

        if params.frame.is_gi_validation()
            && !lhs.is_empty()
            && !rhs.is_empty()
            && rhs.sample.exists()
        {
            if lhs.sample.radiance.distance(rhs.sample.radiance) > 0.33 {
                rhs.confidence = 0.0;
            }

            // Resampling stale reservoirs is tricky, because we can't really
            // calculate proper MIS weights here - that would require taking the
            // current sample and tracing it in the previous frame's BVH etc.,
            // which is infeasible even for direct lighting.
            //
            // ReSTIR GI paper suggests discarding stale reservoirs by setting
            // their M to 0, which is also biased (as it overestimates newly
            // discovered samples), but it's managable when one uses separate
            // temporal and spatial reservoirs, since it doesn't cause the bias
            // to propagate to other temporal reservoirs.
            //
            // Somewhat unfortunately, because we use one set of reservoirs,
            // without distinguishing between temporals and spatials, resetting
            // a reservoir causes an unmanagable bias that quickly spreads to
            // hundreds of nearby pixels and cannot be remedied.
            //
            // So instead of resetting the reservoir, we simply update the
            // sample that's within it - it's also biased (and not as reactive
            // as resetting would be), but in a managable way.
            rhs.sample.radiance = lhs.sample.radiance;
            rhs.sample.v2_point = lhs.sample.v2_point;
            rhs.sample.v2_normal = lhs.sample.v2_normal;
        }

        if !rhs.is_empty() {
            let rhs_pos = reprojection.prev_pos_round();

            rhs_hit = Hit::new(
                prev_camera.ray(rhs_pos),
                GBufferEntry::unpack([
                    prev_prim_gbuffer_d0.read(rhs_pos),
                    prev_prim_gbuffer_d1.read(rhs_pos),
                ]),
            );
        }
    }

    // ---

    let mut main = GiReservoir::default();
    let mut main_pdf = 0.0;

    if params.frame.is_gi_tracing() {
        let mis = Mis::gi_temporal(lhs, lhs_hit, rhs, rhs_hit).eval();

        if main.update(
            &mut wnoise,
            lhs.sample,
            mis.lhs_mis * mis.lhs_pdf * lhs.w,
        ) {
            main_pdf = mis.lhs_pdf;
        }

        if main.update(
            &mut wnoise,
            rhs.sample,
            mis.rhs_mis * mis.rhs_pdf * rhs.w,
        ) {
            main_pdf = mis.rhs_pdf;
        }

        main.m = lhs.m + mis.m;
        main.confidence = 1.0;
        main.norm_mis(main_pdf);
    } else {
        if main.merge(&mut wnoise, &rhs, rhs.sample.pdf) {
            main_pdf = rhs.sample.pdf;
        }

        main.confidence = rhs.confidence;
        main.norm_avg(main_pdf);
    }

    main.sample.pdf = main_pdf;
    main.sample.v1_point = lhs_hit.point;
    main.clamp_w(5.0);
    main.write(curr_reservoirs, lhs_idx);
}

```

`strolle-shaders/src/lib.rs`:

```rs
#![cfg_attr(target_arch = "spirv", no_std)]
#![allow(clippy::too_many_arguments)]

pub mod atmosphere;
pub mod bvh_heatmap;
pub mod di_resolving;
pub mod di_sampling;
pub mod di_spatial_resampling;
pub mod di_temporal_resampling;
pub mod frame_composition;
pub mod frame_denoising;
pub mod frame_reprojection;
pub mod gi_preview_resampling;
pub mod gi_reprojection;
pub mod gi_resolving;
pub mod gi_sampling_a;
pub mod gi_sampling_b;
pub mod gi_spatial_resampling;
pub mod gi_temporal_resampling;
pub mod prim_raster;
pub mod ref_shading;
pub mod ref_tracing;

```

`strolle-shaders/src/prim_raster.rs`:

```rs
use spirv_std::arch;
use strolle_gpu::prelude::*;

#[spirv(vertex)]
pub fn vs(
    // Params
    #[spirv(push_constant)] params: &PrimRasterPassParams,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1, uniform)] prev_camera: &Camera,

    // Inputs
    vertex_d0: Vec4,
    vertex_d1: Vec4,

    // Outputs
    #[spirv(position)] out_vertex: &mut Vec4,
    out_curr_vertex: &mut Vec4,
    out_prev_vertex: &mut Vec4,
    out_point: &mut Vec3,
    out_normal: &mut Vec3,
    out_uv: &mut Vec2,
) {
    let point = vertex_d0.xyz();

    let prev_point = params
        .prev_xform()
        .transform_point3(params.curr_xform_inv().transform_point3(point));

    let normal = vertex_d1.xyz();
    let uv = vec2(vertex_d0.w, vertex_d1.w);

    *out_vertex = camera.world_to_clip(point);
    *out_curr_vertex = camera.world_to_clip(point);
    *out_prev_vertex = prev_camera.world_to_clip(prev_point);
    *out_point = point;
    *out_normal = normal;
    *out_uv = uv;
}

#[spirv(fragment)]
pub fn fs(
    // Params
    #[spirv(push_constant)] params: &PrimRasterPassParams,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 1)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 2)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1, uniform)] prev_camera: &Camera,
    #[spirv(front_facing)] front_facing: bool,

    // Inputs
    curr_vertex: Vec4,
    prev_vertex: Vec4,
    point: Vec3,
    normal: Vec3,
    uv: Vec2,

    // Outputs
    out_prim_gbuffer_d0: &mut Vec4,
    out_prim_gbuffer_d1: &mut Vec4,
    out_surface: &mut Vec4,
    out_velocity: &mut Vec4,
) {
    let material = MaterialsView::new(materials)
        .get(MaterialId::new(params.material_id()));

    let base_color = material.base_color(atlas_tex, atlas_sampler, uv);
    let metallic_roughness =
        material.metallic_roughness(atlas_tex, atlas_sampler, uv);
    // If our material is transparent and doesn't rely on refraction, kill the
    // current fragment to re-use GPU in finding the next triangle
    if base_color.w < 0.01 && material.ior == 1.0 {
        arch::kill();
    }

    let normal = {
        // TODO bring back normal mapping
        let normal = normal.normalize();

        if front_facing {
            normal
        } else {
            -normal
        }
    };

    let ray = camera.ray(camera.clip_to_screen(curr_vertex).round().as_uvec2());
    let depth = ray.origin().distance(point);

    let gbuffer = GBufferEntry {
        base_color,
        normal,
        metallic: metallic_roughness.x,
        emissive: material.emissive(atlas_tex, atlas_sampler, uv),
        roughness: metallic_roughness.y,
        reflectance: material.reflectance,
        depth,
    };

    let [gbuffer_d0, gbuffer_d1] = gbuffer.pack();

    *out_prim_gbuffer_d0 = gbuffer_d0;
    *out_prim_gbuffer_d1 = gbuffer_d1;

    // -------------------------------------------------------------------------

    *out_surface = Normal::encode(normal)
        .extend(depth)
        .extend(material.roughness);

    // -------------------------------------------------------------------------

    *out_velocity = {
        let velocity = camera.clip_to_screen(curr_vertex)
            - prev_camera.clip_to_screen(prev_vertex);

        if velocity.length_squared() >= 0.001 {
            velocity.extend(0.0).extend(0.0)
        } else {
            // Due to floting-point inaccuracies, stationary objects can end up
            // having a very small velocity instead of zero - this causes our
            // reprojection shader to freak out, so let's truncate small
            // velocities to zero
            Default::default()
        }
    };
}

```

`strolle-shaders/src/ref_shading.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(push_constant)] params: &RefPassParams,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    lights: &[Light],
    #[spirv(descriptor_set = 0, binding = 3, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 4)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 5)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 0, binding = 6, uniform)] world: &World,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1, uniform)] prev_camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 2)]
    atmosphere_transmittance_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 3)]
    atmosphere_transmittance_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 4)] atmosphere_sky_lut_tex: Tex,
    #[spirv(descriptor_set = 1, binding = 5)]
    atmosphere_sky_lut_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 6, storage_buffer)]
    rays: &mut [Vec4],
    #[spirv(descriptor_set = 1, binding = 7, storage_buffer)] hits: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 8)] colors: TexRgba32,
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);
    let mut wnoise = WhiteNoise::new(params.seed, screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let lights = LightsView::new(lights);
    let materials = MaterialsView::new(materials);
    let atmosphere = Atmosphere::new(
        atmosphere_transmittance_lut_tex,
        atmosphere_transmittance_lut_sampler,
        atmosphere_sky_lut_tex,
        atmosphere_sky_lut_sampler,
    );

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    if params.depth == u8::MAX as u32 {
        let prev_color = if camera.is_eq(*prev_camera) {
            colors.read(screen_pos)
        } else {
            Default::default()
        };

        let curr_color = rays[3 * screen_idx + 2].xyz();

        unsafe {
            colors.write(screen_pos, prev_color + curr_color.extend(1.0));
        }

        return;
    }

    // -------------------------------------------------------------------------

    let ray;
    let mut color;
    let mut throughput;

    if params.depth == 0 {
        ray = camera.ray(screen_pos);
        color = Vec3::ZERO;
        throughput = Vec3::ONE;
    } else {
        let d0 = rays[3 * screen_idx];
        let d1 = rays[3 * screen_idx + 1];
        let d2 = rays[3 * screen_idx + 2];

        ray = Ray::new(d0.xyz(), d1.xyz());
        color = d2.xyz();
        throughput = vec3(d0.w, d1.w, d2.w);
    }

    let hit = {
        let t_hit = TriangleHit::unpack([
            hits[2 * screen_idx],
            hits[2 * screen_idx + 1],
        ]);

        if t_hit.is_none() {
            color += throughput * atmosphere.sample(world.sun_dir(), ray.dir());

            rays[3 * screen_idx] = Default::default();
            rays[3 * screen_idx + 1] = Default::default();
            rays[3 * screen_idx + 2] = color.extend(Default::default());

            return;
        }

        let mut material = materials.get(t_hit.material_id);

        if params.depth > 0 {
            material.regularize();
        }

        Hit {
            point: t_hit.point + t_hit.normal * Hit::NUDGE_OFFSET,
            origin: ray.origin(),
            dir: ray.dir(),
            gbuffer: GBufferEntry {
                base_color: material.base_color(
                    atlas_tex,
                    atlas_sampler,
                    t_hit.uv,
                ),
                normal: t_hit.normal,
                metallic: material.metallic,
                emissive: material.emissive(atlas_tex, atlas_sampler, t_hit.uv),
                roughness: material.roughness,
                reflectance: material.reflectance,
                depth: 0.0,
            },
        }
    };

    // -------------------------------------------------------------------------

    color += throughput * hit.gbuffer.emissive;

    if world.light_count > 0 {
        let light_id = wnoise.sample_int() % world.light_count;
        let light_pdf = 1.0 / (world.light_count as f32);
        let light = lights.get(LightId::new(light_id));

        let is_light_occluded =
            light.ray_wnoise(&mut wnoise, hit.point).intersect(
                local_idx,
                stack,
                triangles,
                bvh,
                materials,
                atlas_tex,
                atlas_sampler,
            );

        if !is_light_occluded {
            color += throughput * light.radiance(hit).sum() / light_pdf;
        }
    }

    // -------------------------------------------------------------------------

    let reflected_sample =
        LayeredBrdf::new(hit.gbuffer).sample(&mut wnoise, -hit.dir);

    if reflected_sample.is_invalid() {
        rays[3 * screen_idx] = Default::default();
        rays[3 * screen_idx + 1] = Default::default();
        return;
    }

    let reflected_ray = Ray::new(hit.point, reflected_sample.dir);

    throughput *= reflected_sample.dir.dot(hit.gbuffer.normal);
    throughput *= reflected_sample.radiance / reflected_sample.pdf;

    // -------------------------------------------------------------------------

    rays[3 * screen_idx] = reflected_ray.origin().extend(throughput.x);
    rays[3 * screen_idx + 1] = reflected_ray.dir().extend(throughput.y);
    rays[3 * screen_idx + 2] = color.extend(throughput.z);
}

```

`strolle-shaders/src/ref_tracing.rs`:

```rs
use strolle_gpu::prelude::*;

#[spirv(compute(threads(8, 8)))]
pub fn main(
    #[spirv(global_invocation_id)] global_id: UVec3,
    #[spirv(local_invocation_index)] local_idx: u32,
    #[spirv(push_constant)] params: &RefPassParams,
    #[spirv(workgroup)] stack: BvhStack,
    #[spirv(descriptor_set = 0, binding = 0, storage_buffer)]
    triangles: &[Triangle],
    #[spirv(descriptor_set = 0, binding = 1, storage_buffer)] bvh: &[Vec4],
    #[spirv(descriptor_set = 0, binding = 2, storage_buffer)]
    materials: &[Material],
    #[spirv(descriptor_set = 0, binding = 3)] atlas_tex: Tex,
    #[spirv(descriptor_set = 0, binding = 4)] atlas_sampler: &Sampler,
    #[spirv(descriptor_set = 1, binding = 0, uniform)] camera: &Camera,
    #[spirv(descriptor_set = 1, binding = 1, storage_buffer)] rays: &[Vec4],
    #[spirv(descriptor_set = 1, binding = 2, storage_buffer)]
    hits: &mut [Vec4],
) {
    let screen_pos = global_id.xy();
    let screen_idx = camera.screen_to_idx(screen_pos);
    let triangles = TrianglesView::new(triangles);
    let bvh = BvhView::new(bvh);
    let materials = MaterialsView::new(materials);

    if !camera.contains(screen_pos) {
        return;
    }

    // -------------------------------------------------------------------------

    let ray = if params.depth == 0 {
        camera.ray(screen_pos)
    } else {
        let d0 = rays[3 * screen_idx];
        let d1 = rays[3 * screen_idx + 1];

        if d1 == Default::default() {
            return;
        }

        Ray::new(d0.xyz(), d1.xyz())
    };

    let (hit, _) = ray.trace(
        local_idx,
        stack,
        triangles,
        bvh,
        materials,
        atlas_tex,
        atlas_sampler,
    );

    let [hit_d0, hit_d1] = hit.pack();

    hits[2 * screen_idx] = hit_d0;
    hits[2 * screen_idx + 1] = hit_d1;
}

```

`strolle/Cargo.toml`:

```toml
[package]
name = "strolle"
version = "0.1.0"
edition = "2021"

[dependencies]
bytemuck.workspace = true
derivative.workspace = true
fxhash.workspace = true
glam.workspace = true
guillotiere.workspace = true
humantime = { workspace = true, optional = true }
image = { workspace = true, default-features = false, features = ["png"] }
log.workspace = true
rand.workspace = true
spirv-std = { git = "https://github.com/Rust-GPU/rust-gpu" }
strolle-gpu = { path = "../strolle-gpu" }
strolle-shaders = { path = "../strolle-shaders" }
wgpu = { workspace = true, features = ["spirv"] }

[features]
metrics = ["humantime"]

```

`strolle/assets/blue-noise.txt`:

```txt
Thanks to http://momentsingraphics.de/BlueNoise.html (by Christoph Peters)

```

`strolle/build.rs`:

```rs
use std::error::Error;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::{env, process};

fn main() -> Result<(), Box<dyn Error>> {
    let profile = env::var("PROFILE").unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=../strolle-shader-builder/Cargo.toml");
    println!("cargo:rerun-if-changed=../strolle-shader-builder/src/main.rs");
    println!("cargo:rustc-env=PROFILE={profile}");

    let mut dir = PathBuf::from(env::var_os("OUT_DIR").unwrap());

    // Strip `$profile/build/*/out`.
    let ok = dir.ends_with("out")
        && dir.pop()
        && dir.pop()
        && dir.ends_with("build")
        && dir.pop()
        && dir.ends_with(profile)
        && dir.pop();

    assert!(ok);

    let dir = dir.join("shader-builder");

    let status = Command::new("cargo")
        .args([
            "run",
            "--release",
            "-p",
            "strolle-shader-builder",
            "--target-dir",
        ])
        .arg(dir)
        .env_remove("CARGO_ENCODED_RUSTFLAGS")
        .stderr(Stdio::inherit())
        .stdout(Stdio::inherit())
        .status()?;

    if !status.success() {
        process::exit(status.code().unwrap_or(1));
    }

    Ok(())
}

```

`strolle/src/buffers.rs`:

```rs
mod bind_group;
mod bindable;
mod bufferable;
mod double_buffered;
mod mapped_storage_buffer;
mod mapped_uniform_buffer;
mod storage_buffer;
mod texture;
mod utils;

pub use self::bind_group::*;
pub use self::bindable::*;
pub use self::bufferable::*;
pub use self::double_buffered::*;
pub use self::mapped_storage_buffer::*;
pub use self::mapped_uniform_buffer::*;
pub use self::storage_buffer::*;
pub use self::texture::*;

#[must_use = "buffer might have gotten reallocated which you should probably react upon"]
#[derive(Clone, Copy, Debug, Default)]
pub struct BufferFlushOutcome {
    pub reallocated: bool,
}

```

`strolle/src/buffers/bind_group.rs`:

```rs
use crate::DoubleBufferedBindable;

#[derive(Debug)]
pub struct BindGroup {
    bind_group_a: wgpu::BindGroup,
    bind_group_b: wgpu::BindGroup,
    bind_group_layout: wgpu::BindGroupLayout,
}

impl BindGroup {
    pub fn builder<'ctx>(label: impl ToString) -> BindGroupBuilder<'ctx> {
        BindGroupBuilder {
            label: label.to_string(),
            layouts: Default::default(),
            resources: Default::default(),
        }
    }

    pub fn get(&self, alternate: bool) -> &wgpu::BindGroup {
        if alternate {
            &self.bind_group_b
        } else {
            &self.bind_group_a
        }
    }

    pub fn layout(&self) -> &wgpu::BindGroupLayout {
        &self.bind_group_layout
    }
}

pub struct BindGroupBuilder<'a> {
    label: String,
    layouts: Vec<wgpu::BindGroupLayoutEntry>,
    resources: Vec<[wgpu::BindingResource<'a>; 2]>,
}

impl<'a> BindGroupBuilder<'a> {
    pub fn add(mut self, item: &'a dyn DoubleBufferedBindable) -> Self {
        for (layout, resources) in item.bind(self.resources.len() as u32) {
            self.layouts.push(layout);
            self.resources.push(resources);
        }

        self
    }

    pub fn build(self, device: &wgpu::Device) -> BindGroup {
        let label = format!("strolle_{}", self.label);

        let bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                label: Some(&format!("{label}_layout")),
                entries: &self.layouts,
            });

        let (resources_a, resources_b): (Vec<_>, Vec<_>) = self
            .resources
            .into_iter()
            .enumerate()
            .map(|(binding, resources)| {
                let [resource_a, resource_b] =
                    resources.map(|resource| wgpu::BindGroupEntry {
                        binding: binding as _,
                        resource,
                    });

                #[allow(
                    clippy::tuple_array_conversions,
                    reason="https://github.com/rust-lang/rust-clippy/issues/11144"
                )]
                (resource_a, resource_b)
            })
            .unzip();

        let bind_group_a =
            device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&label),
                layout: &bind_group_layout,
                entries: &resources_a,
            });

        let bind_group_b =
            device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&label),
                layout: &bind_group_layout,
                entries: &resources_b,
            });

        BindGroup {
            bind_group_a,
            bind_group_b,
            bind_group_layout,
        }
    }
}

```

`strolle/src/buffers/bindable.rs`:

```rs
/// Object that can be attached to a pipeline, e.g. a buffer or a texture
pub trait Bindable {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)>;
}

/// Object that can be attached to a pipeline, e.g. a buffer or a texture, and
/// it's double-buffered (i.e. exists in two similar versions swapped after each
/// frame)
pub trait DoubleBufferedBindable {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, [wgpu::BindingResource; 2])>;
}

impl<T> DoubleBufferedBindable for T
where
    T: Bindable,
{
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, [wgpu::BindingResource; 2])> {
        T::bind(self, binding)
            .into_iter()
            .map(|(layout, resource)| {
                let resource_a = resource.clone();
                let resource_b = resource;

                (layout, [resource_a, resource_b])
            })
            .collect()
    }
}

```

`strolle/src/buffers/bufferable.rs`:

```rs
use std::slice;

use bytemuck::Pod;

use crate::gpu;

/// Object that can be sent into the GPU
pub trait Bufferable {
    fn data(&self) -> &[u8];

    fn size(&self) -> usize {
        self.data().len()
    }
}

impl Bufferable for u32 {
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(slice::from_ref(self))
    }
}

impl Bufferable for u64 {
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(slice::from_ref(self))
    }
}

impl Bufferable for f32 {
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(slice::from_ref(self))
    }
}

impl Bufferable for gpu::Camera {
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(slice::from_ref(self))
    }
}

impl Bufferable for gpu::World {
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(slice::from_ref(self))
    }
}

impl<T> Bufferable for &[T]
where
    T: Pod,
{
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(self)
    }
}

impl<T> Bufferable for Vec<T>
where
    T: Pod,
{
    fn data(&self) -> &[u8] {
        bytemuck::cast_slice(self)
    }
}

```

`strolle/src/buffers/double_buffered.rs`:

```rs
use crate::{Bindable, DoubleBufferedBindable, Texture, TextureBuilder};

#[derive(Debug)]
pub struct DoubleBuffered<T> {
    a: T,
    b: T,
}

impl DoubleBuffered<Texture> {
    /// Creates a double-buffered texture.
    ///
    /// See: [`Texture::new()`].
    pub fn new(device: &wgpu::Device, texture: TextureBuilder) -> Self {
        let label_a = format!("{}_a", texture.label());
        let label_b = format!("{}_b", texture.label());

        Self {
            a: texture.clone().with_label(label_a).build(device),
            b: texture.with_label(label_b).build(device),
        }
    }
}

impl DoubleBuffered<&Texture> {
    /// See: [`Texture::bind_readable()`].
    pub fn bind_readable(&self) -> impl DoubleBufferedBindable + '_ {
        DoubleBufferedBinder {
            a: self.a.bind_readable(),
            b: self.b.bind_readable(),
        }
    }

    /// See: [`Texture::bind_writable()`].
    pub fn bind_writable(&self) -> impl DoubleBufferedBindable + '_ {
        DoubleBufferedBinder {
            a: self.a.bind_writable(),
            b: self.b.bind_writable(),
        }
    }
}

impl<T> DoubleBuffered<T> {
    pub fn get(&self, alternate: bool) -> &T {
        if alternate {
            &self.b
        } else {
            &self.a
        }
    }

    pub fn curr(&self) -> DoubleBuffered<&T> {
        DoubleBuffered {
            a: &self.a,
            b: &self.b,
        }
    }

    pub fn prev(&self) -> DoubleBuffered<&T> {
        DoubleBuffered {
            a: &self.b,
            b: &self.a,
        }
    }
}

pub struct DoubleBufferedBinder<T> {
    a: T,
    b: T,
}

impl<T> DoubleBufferedBindable for DoubleBufferedBinder<T>
where
    T: Bindable,
{
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, [wgpu::BindingResource; 2])> {
        let entries_a = self.a.bind(binding);
        let entries_b = self.b.bind(binding);

        assert_eq!(entries_a.len(), entries_b.len());

        entries_a
            .into_iter()
            .zip(entries_b)
            .map(|((layout_a, resource_a), (layout_b, resource_b))| {
                assert_eq!(layout_a, layout_b);

                #[allow(
                    clippy::tuple_array_conversions,
                    reason="https://github.com/rust-lang/rust-clippy/issues/11144"
                )]
                (layout_a, [resource_a, resource_b])
            })
            .collect()
    }
}

```

`strolle/src/buffers/mapped_storage_buffer.rs`:

```rs
use std::mem;
use std::ops::{Deref, DerefMut};

use log::debug;

use crate::buffers::utils;
use crate::{Bindable, BufferFlushOutcome, Bufferable};

/// Storage buffer that exists both in RAM and VRAM.
///
/// This kind of buffer should be used for data structures such as BVH that need
/// to be accessed both from the host machine and the GPU; it's allocated both
/// in RAM and VRAM, and uses [`DerefMut`] to track whether it's been modified
/// and needs to be flushed.
#[derive(Debug)]
pub struct MappedStorageBuffer<T> {
    label: String,
    buffer: wgpu::Buffer,
    data: T,
    dirty: bool,
}

impl<T> MappedStorageBuffer<T>
where
    T: Bufferable,
{
    pub fn new(device: &wgpu::Device, label: impl AsRef<str>, data: T) -> Self {
        let label = format!("strolle_{}", label.as_ref());

        let size = if data.size() == 0 {
            // If the buffer is empty - just like triangles or initial BVH - it
            // is easier to pretend the buffer is just small instead of
            // zero-sized so that we can allocate *something* here and let the
            // reallocation logic worry about growing the buffer later.
            //
            // That is, since we can't really allocate an empty buffer, the
            // other solution would be to keep `buffer: Option<wgpu::Buffer>`
            // and allocate it on-demand on the first write, and that is just
            // more trouble than it's worth.
            128 * 1024
        } else {
            utils::pad_size(data.size())
        };

        debug!("Allocating mapped storage buffer `{label}`; size={size}");

        let buffer = Self::create_buffer(device, &label, size);

        Self {
            label,
            buffer,
            data,
            dirty: true,
        }
    }

    pub fn new_default(device: &wgpu::Device, label: impl AsRef<str>) -> Self
    where
        T: Default,
    {
        Self::new(device, label, Default::default())
    }

    pub fn as_buffer(&self) -> &wgpu::Buffer {
        &self.buffer
    }

    /// Creates an immutable storage-buffer binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ..., storage_buffer)]
    /// items: &[T],
    /// ```
    pub fn bind_readable(&self) -> impl Bindable + '_ {
        MappedStorageBufferBinder {
            parent: self,
            read_only: true,
        }
    }

    pub fn reallocate(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> bool {
        let curr_size = self.buffer.size() as usize;
        let new_size = utils::pad_size(self.data.size());

        if (self.buffer.size() as usize) >= new_size {
            return false;
        }

        debug!(
            "Reallocating mapped storage buffer `{}`; \
             curr-size={curr_size}, new-size={new_size}",
            self.label,
        );

        self.buffer.destroy();
        self.buffer = Self::create_buffer(device, &self.label, new_size);
        self.dirty = false;

        queue.write_buffer(&self.buffer, 0, self.data.data());

        true
    }

    pub fn flush(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> BufferFlushOutcome {
        if !mem::take(&mut self.dirty) {
            return BufferFlushOutcome::default();
        }

        let reallocated = self.reallocate(device, queue);

        if reallocated {
            // Reallocating already flushes the entire buffer, so there's no
            // need to flush it again
        } else {
            queue.write_buffer(&self.buffer, 0, self.data.data());
        }

        BufferFlushOutcome { reallocated }
    }

    pub fn flush_part(
        &mut self,
        queue: &wgpu::Queue,
        offset: usize,
        size: usize,
    ) {
        queue.write_buffer(
            &self.buffer,
            offset as _,
            &self.data.data()[offset..][..size],
        );
    }

    fn create_buffer(
        device: &wgpu::Device,
        label: &str,
        size: usize,
    ) -> wgpu::Buffer {
        device.create_buffer(&wgpu::BufferDescriptor {
            label: Some(label),
            usage: wgpu::BufferUsages::COPY_DST
                | wgpu::BufferUsages::STORAGE
                | wgpu::BufferUsages::VERTEX,
            size: size as _,
            mapped_at_creation: false,
        })
    }
}

impl<T> Deref for MappedStorageBuffer<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

impl<T> DerefMut for MappedStorageBuffer<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.dirty = true;

        &mut self.data
    }
}

pub struct MappedStorageBufferBinder<'a, T> {
    parent: &'a MappedStorageBuffer<T>,
    read_only: bool,
}

impl<T> Bindable for MappedStorageBufferBinder<'_, T> {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)> {
        let layout = wgpu::BindGroupLayoutEntry {
            binding,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage {
                    read_only: self.read_only,
                },
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        };

        let resource = self.parent.buffer.as_entire_binding();

        vec![(layout, resource)]
    }
}

```

`strolle/src/buffers/mapped_uniform_buffer.rs`:

```rs
use std::mem;
use std::ops::{Deref, DerefMut};

use log::debug;

use crate::buffers::utils;
use crate::{Bindable, Bufferable};

#[derive(Debug)]
pub struct MappedUniformBuffer<T> {
    buffer: wgpu::Buffer,
    data: T,
    dirty: bool,
}

impl<T> MappedUniformBuffer<T>
where
    T: Bufferable,
{
    pub fn new(device: &wgpu::Device, label: impl AsRef<str>, data: T) -> Self {
        let label = format!("strolle_{}", label.as_ref());
        let size = utils::pad_size(data.size());

        debug!("Allocating uniform buffer `{label}`; size={size}");

        let buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some(&label),
            usage: wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::UNIFORM,
            size: size as _,
            mapped_at_creation: false,
        });

        Self {
            buffer,
            data,
            dirty: true,
        }
    }

    pub fn flush(&mut self, queue: &wgpu::Queue) {
        if !mem::take(&mut self.dirty) {
            return;
        }

        queue.write_buffer(&self.buffer, 0, self.data.data());
    }

    /// Creates an immutable uniform binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ..., uniform)]
    /// item: &T,
    /// ```
    pub fn bind_readable(&self) -> impl Bindable + '_ {
        MappedUniformBufferBinder { parent: self }
    }
}

impl<T> Deref for MappedUniformBuffer<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

impl<T> DerefMut for MappedUniformBuffer<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.dirty = true;

        &mut self.data
    }
}

pub struct MappedUniformBufferBinder<'a, T> {
    parent: &'a MappedUniformBuffer<T>,
}

impl<T> Bindable for MappedUniformBufferBinder<'_, T> {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)> {
        let layout = wgpu::BindGroupLayoutEntry {
            binding,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        };

        let resource = self.parent.buffer.as_entire_binding();

        vec![(layout, resource)]
    }
}

```

`strolle/src/buffers/storage_buffer.rs`:

```rs
use log::debug;

use crate::buffers::utils;
use crate::Bindable;

/// Storage buffer that exists only in VRAM.
///
/// This kind of storage buffer should be used for data structures that don't
/// have to be accessed on the host machine.
#[derive(Debug)]
pub struct StorageBuffer {
    buffer: wgpu::Buffer,
}

impl StorageBuffer {
    // TODO provide `::builder()` pattern
    pub fn new(
        device: &wgpu::Device,
        label: impl AsRef<str>,
        size: usize,
    ) -> Self {
        let label = label.as_ref();
        let size = utils::pad_size(size);

        debug!("Allocating storage buffer `{label}`; size={size}");

        let buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some(label),
            usage: wgpu::BufferUsages::STORAGE,
            size: size as _,
            mapped_at_creation: false,
        });

        Self { buffer }
    }

    /// Creates an immutable storage-buffer binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ..., storage_buffer)]
    /// items: &[T],
    /// ```
    pub fn bind_readable(&self) -> impl Bindable + '_ {
        StorageBufferBinder {
            parent: self,
            read_only: true,
        }
    }

    /// Creates a mutable storage-buffer binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ..., storage_buffer)]
    /// items: &mut [T],
    /// ```
    pub fn bind_writable(&self) -> impl Bindable + '_ {
        StorageBufferBinder {
            parent: self,
            read_only: false,
        }
    }
}

pub struct StorageBufferBinder<'a> {
    parent: &'a StorageBuffer,
    read_only: bool,
}

impl Bindable for StorageBufferBinder<'_> {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)> {
        let layout = wgpu::BindGroupLayoutEntry {
            binding,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Storage {
                    read_only: self.read_only,
                },
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        };

        let resource = self.parent.buffer.as_entire_binding();

        vec![(layout, resource)]
    }
}

```

`strolle/src/buffers/texture.rs`:

```rs
use log::debug;
use spirv_std::glam::UVec2;

use crate::Bindable;

#[derive(Debug)]
pub struct Texture {
    tex: wgpu::Texture,
    format: wgpu::TextureFormat,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
    filterable: bool,
}

impl Texture {
    pub fn builder(label: impl AsRef<str>) -> TextureBuilder {
        TextureBuilder {
            label: label.as_ref().to_owned(),
            ..Default::default()
        }
    }

    pub fn tex(&self) -> &wgpu::Texture {
        &self.tex
    }

    pub fn view(&self) -> &wgpu::TextureView {
        &self.view
    }

    /// Creates an image + sampler bindings:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ...)]
    /// tex: &Image!(2D, type=f32, sampled),
    ///
    /// #[spirv(descriptor_set = ..., binding = ...)]
    /// sampler: &Sampler,
    /// ```
    ///
    /// Sampler's binding follows the texture so e.g. if the texture has
    /// `binding = 3`, sampler will be `binding = 4`.
    pub fn bind_sampled(&self) -> impl Bindable + '_ {
        SampledTextureBinder { parent: self }
    }

    /// Creates an immutable storage texture binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ...)]
    /// tex: &Image!(2D, format = ..., sampled = false),
    /// ```
    ///
    /// TODO naga and/or rust-gpu don't support read-only storage textures yet,
    ///      so currently this is equivalent to a writable binding
    pub fn bind_readable(&self) -> impl Bindable + '_ {
        StorageTextureBinder { parent: self }
    }

    /// Creates a mutable storage texture binding:
    ///
    /// ```
    /// #[spirv(descriptor_set = ..., binding = ...)]
    /// tex: &Image!(2D, format = ..., sampled = false),
    /// ```
    pub fn bind_writable(&self) -> impl Bindable + '_ {
        StorageTextureBinder { parent: self }
    }
}

#[derive(Clone, Default)]
pub struct TextureBuilder {
    label: String,
    size: Option<UVec2>,
    format: Option<wgpu::TextureFormat>,
    usage: Option<wgpu::TextureUsages>,
    sampler: wgpu::SamplerDescriptor<'static>,
}

impl TextureBuilder {
    pub fn label(&self) -> &str {
        &self.label
    }

    pub fn with_label(mut self, label: impl AsRef<str>) -> Self {
        self.label = label.as_ref().to_owned();
        self
    }

    pub fn with_size(mut self, size: UVec2) -> Self {
        self.size = Some(size);
        self
    }

    pub fn with_format(mut self, format: wgpu::TextureFormat) -> Self {
        self.format = Some(format);
        self
    }

    pub fn with_usage(mut self, usage: wgpu::TextureUsages) -> Self {
        *self.usage.get_or_insert(usage) |= usage;
        self
    }

    pub fn with_linear_filtering_sampler(mut self) -> Self {
        self.sampler.mag_filter = wgpu::FilterMode::Linear;
        self.sampler.min_filter = wgpu::FilterMode::Linear;
        self
    }

    pub fn build(self, device: &wgpu::Device) -> Texture {
        let Self {
            label,
            size,
            format,
            usage,
            sampler,
        } = self;

        let label = format!("strolle_{}", label);
        let size = size.expect("Missing property: size");
        let format = format.expect("Missing property: format");
        let usage = usage.expect("Missing property: usage");

        debug!(
            "Allocating texture `{label}`; size={size:?}, format={format:?}"
        );

        assert!(size.x > 0);
        assert!(size.y > 0);

        let tex = device.create_texture(&wgpu::TextureDescriptor {
            label: Some(&format!("{label}_texture")),
            size: wgpu::Extent3d {
                width: size.x,
                height: size.y,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format,
            usage,
            view_formats: &[],
        });

        let filterable = sampler.mag_filter != wgpu::FilterMode::Nearest
            || sampler.min_filter != wgpu::FilterMode::Nearest;

        let view = tex.create_view(&Default::default());
        let sampler_label = format!("{label}_sampler");

        let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
            label: Some(&sampler_label),
            ..sampler
        });

        Texture {
            tex,
            format,
            view,
            sampler,
            filterable,
        }
    }
}

pub struct SampledTextureBinder<'a> {
    parent: &'a Texture,
}

impl Bindable for SampledTextureBinder<'_> {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)> {
        let image_layout = wgpu::BindGroupLayoutEntry {
            binding,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::Texture {
                multisampled: false,
                view_dimension: wgpu::TextureViewDimension::D2,
                sample_type: wgpu::TextureSampleType::Float {
                    filterable: self.parent.filterable,
                },
            },
            count: None,
        };

        let sampler_layout = wgpu::BindGroupLayoutEntry {
            binding: binding + 1,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::Sampler(if self.parent.filterable {
                wgpu::SamplerBindingType::Filtering
            } else {
                wgpu::SamplerBindingType::NonFiltering
            }),
            count: None,
        };

        let image_resource =
            wgpu::BindingResource::TextureView(&self.parent.view);

        let sampler_resource =
            wgpu::BindingResource::Sampler(&self.parent.sampler);

        vec![
            (image_layout, image_resource),
            (sampler_layout, sampler_resource),
        ]
    }
}

pub struct StorageTextureBinder<'a> {
    parent: &'a Texture,
}

impl Bindable for StorageTextureBinder<'_> {
    fn bind(
        &self,
        binding: u32,
    ) -> Vec<(wgpu::BindGroupLayoutEntry, wgpu::BindingResource)> {
        let image_layout = wgpu::BindGroupLayoutEntry {
            binding,
            visibility: wgpu::ShaderStages::all(),
            ty: wgpu::BindingType::StorageTexture {
                access: wgpu::StorageTextureAccess::ReadWrite,
                format: self.parent.format,
                view_dimension: wgpu::TextureViewDimension::D2,
            },
            count: None,
        };

        let image_resource =
            wgpu::BindingResource::TextureView(&self.parent.view);

        vec![(image_layout, image_resource)]
    }
}

```

`strolle/src/buffers/utils.rs`:

```rs
pub fn pad_size(size: usize) -> usize {
    (size + 31) & !31
}

```

`strolle/src/bvh.rs`:

```rs
mod builder;
mod node;
mod nodes;
mod primitive;
mod primitives;
mod serializer;

use std::fmt::Debug;
use std::ops::Range;

use spirv_std::glam::Vec4;

pub use self::node::*;
pub use self::nodes::*;
pub use self::primitive::*;
pub use self::primitives::*;
use crate::{
    utils, Bindable, BufferFlushOutcome, MappedStorageBuffer, Materials, Params,
};

#[derive(Debug)]
pub struct Bvh {
    buffer: MappedStorageBuffer<Vec<Vec4>>,
    nodes: BvhNodes,
    primitives: BvhPrimitives,
}

impl Bvh {
    pub fn new(device: &wgpu::Device) -> Self {
        Self {
            buffer: MappedStorageBuffer::new_default(device, "bvh"),
            nodes: Default::default(),
            primitives: Default::default(),
        }
    }

    pub fn add(&mut self, prim: BvhPrimitive) {
        self.primitives.add(prim);
    }

    pub fn update(
        &mut self,
        ids: Range<usize>,
    ) -> impl Iterator<Item = &mut BvhPrimitive> {
        self.primitives.update(ids)
    }

    pub fn refresh<P>(&mut self, materials: &Materials<P>)
    where
        P: Params,
    {
        utils::measure("tick.bvh.begin", || {
            self.primitives.begin_refresh();
        });

        utils::measure("tick.bvh.build", || {
            builder::run(&mut self.nodes, &mut self.primitives);
        });

        utils::measure("tick.bvh.serialize", || {
            serializer::run(
                materials,
                &self.nodes,
                &self.primitives,
                &mut self.buffer,
            );
        });

        self.primitives.end_refresh();
    }

    pub fn flush(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> BufferFlushOutcome {
        self.buffer.flush(device, queue)
    }

    pub fn len(&self) -> usize {
        self.nodes.nodes.len()
    }

    pub fn bind_readable(&self) -> impl Bindable + '_ {
        self.buffer.bind_readable()
    }
}

```

`strolle/src/bvh/builder.rs`:

```rs
use core::f32;
use std::collections::VecDeque;
use std::hash::{Hash, Hasher};
use std::thread;

use fxhash::FxHasher;
use glam::UVec3;

use super::{
    BvhNode, BvhNodeHash, BvhNodeId, BvhNodes, BvhPrimitiveId, BvhPrimitives,
    BvhPrimitivesRef,
};
use crate::{Axis, BoundingBox};

const BINS: usize = 12;

pub fn run(nodes: &mut BvhNodes, primitives: &mut BvhPrimitives) {
    thread::scope(|s| {
        s.spawn(|| {
            let root = nodes.set_root(BvhNode::Leaf {
                bounds: Default::default(),
                primitives_ref: primitives.current_ref(),
            });

            let root = BvhNodeRef::root(root);
            let mut stack = VecDeque::from_iter([root]);

            while let Some(node) = stack.pop_front() {
                match balance(nodes, primitives, node) {
                    (Some(left), Some(right)) => {
                        stack.push_back(left);
                        stack.push_back(right);
                    }
                    (Some(node), None) | (None, Some(node)) => {
                        stack.push_back(node);
                    }
                    (None, None) => {
                        //
                    }
                }
            }
        });
    });
}

#[inline(always)]
fn balance(
    nodes: &mut BvhNodes,
    primitives: &mut BvhPrimitives,
    node_ref: BvhNodeRef,
) -> (Option<BvhNodeRef>, Option<BvhNodeRef>) {
    if let Some(plane) = find_splitting_plane(nodes, primitives, node_ref.id) {
        if plane.split_cost < nodes[node_ref.id].sah_cost() {
            return split(nodes, primitives, node_ref, plane);
        }
    }

    if let Some(BvhNode::Internal {
        left_id, right_id, ..
    }) = node_ref.ghost
    {
        nodes.remove_tree(left_id);
        nodes.remove_tree(right_id);
    }

    (None, None)
}

#[inline(always)]
fn find_splitting_plane(
    nodes: &BvhNodes,
    primitives: &BvhPrimitives,
    node_id: BvhNodeId,
) -> Option<SplittingPlane> {
    let BvhNode::Leaf { primitives_ref, .. } = nodes[node_id] else {
        unreachable!();
    };

    if primitives_ref.len() <= 1 {
        return None;
    }

    let primitives = primitives.current(primitives_ref);

    // ---

    let centroid_bb: BoundingBox = primitives
        .iter()
        .map(|primitive| primitive.center)
        .collect();

    let mut bins = [[Bin::default(); BINS]; 3];
    let scale = (BINS as f32) / centroid_bb.extent();

    for primitive in primitives {
        let bin_id = scale * (primitive.center - centroid_bb.min());
        let bin_id = bin_id.as_uvec3().min(UVec3::splat((BINS as u32) - 1));
        let bin_idx = bin_id.x as usize;
        let bin_idy = bin_id.y as usize;
        let bin_idz = bin_id.z as usize;

        bins[0][bin_idx].count += 1;
        bins[0][bin_idx].bounds += primitive.bounds;

        bins[1][bin_idy].count += 1;
        bins[1][bin_idy].bounds += primitive.bounds;

        bins[2][bin_idz].count += 1;
        bins[2][bin_idz].bounds += primitive.bounds;
    }

    // ---

    let mut left_areas = [[0.0; BINS - 1]; 3];
    let mut right_areas = [[0.0; BINS - 1]; 3];
    let mut left_counts = [[0; BINS - 1]; 3];
    let mut right_counts = [[0; BINS - 1]; 3];
    let mut left_bb = [BoundingBox::default(); 3];
    let mut right_bb = [BoundingBox::default(); 3];
    let mut left_count = [0; 3];
    let mut right_count = [0; 3];

    for axis in 0..3 {
        for i in 0..(BINS - 1) {
            let left_bin = bins[axis][i];

            left_count[axis] += left_bin.count;
            left_counts[axis][i] = left_count[axis];

            if left_bin.bounds.is_set() {
                left_bb[axis] += left_bin.bounds;
            }

            left_areas[axis][i] = left_bb[axis].half_area();

            // ---

            let right_bin = bins[axis][BINS - 1 - i];

            right_count[axis] += right_bin.count;
            right_counts[axis][BINS - 2 - i] = right_count[axis];

            if right_bin.bounds.is_set() {
                right_bb[axis] += right_bin.bounds;
            }

            right_areas[axis][BINS - 2 - i] = right_bb[axis].half_area();
        }
    }

    // ---

    let mut best: Option<SplittingPlane> = None;
    let scale = centroid_bb.extent() / (BINS as f32);

    for axis in 0..3 {
        for i in 0..(BINS - 1) {
            let split_cost = (left_counts[axis][i] as f32)
                * left_areas[axis][i]
                + (right_counts[axis][i] as f32) * right_areas[axis][i];

            let is_current_bin_better =
                best.map_or(true, |best| split_cost <= best.split_cost);

            if is_current_bin_better {
                let split_by = Axis::from(axis);

                let split_at = centroid_bb.min()[split_by]
                    + scale[split_by] * ((i + 1) as f32);

                best = Some(SplittingPlane {
                    split_by,
                    split_at,
                    split_cost,
                });
            }
        }
    }

    best
}

fn split(
    nodes: &mut BvhNodes,
    primitives: &mut BvhPrimitives,
    node_ref: BvhNodeRef,
    plane: SplittingPlane,
) -> (Option<BvhNodeRef>, Option<BvhNodeRef>) {
    let BvhNode::Leaf {
        bounds,
        primitives_ref,
    } = nodes[node_ref.id]
    else {
        unreachable!();
    };

    // ---

    let primitives_data = &mut primitives.current_mut(primitives_ref);

    let mut left_prim_idx = 0;
    let mut right_prim_idx = (primitives_data.len() - 1) as i32;

    // TODO optimization idea: don't compute hashes when close to leaves
    let mut left_hash = FxHasher::default();
    let mut right_hash = FxHasher::default();

    let mut left_bounds = BoundingBox::default();
    let mut right_bounds = BoundingBox::default();

    while left_prim_idx <= right_prim_idx {
        let primitive = primitives_data[left_prim_idx as usize];

        if primitive.center[plane.split_by] < plane.split_at {
            left_prim_idx += 1;
            left_bounds += primitive.bounds;

            primitive.hash(&mut left_hash);
        } else {
            primitives_data
                .swap(left_prim_idx as usize, right_prim_idx as usize);

            right_prim_idx -= 1;
            right_bounds += primitive.bounds;

            primitive.hash(&mut right_hash);
        }
    }

    let pivot = BvhPrimitiveId::new(
        primitives_ref.start().get() + (left_prim_idx as u32),
    );

    let left_primitives_ref =
        BvhPrimitivesRef::new(primitives_ref.start(), pivot);

    let right_primitives_ref =
        BvhPrimitivesRef::new(pivot, primitives_ref.end());

    let left_hash = BvhNodeHash::new(left_hash.finish());
    let right_hash = BvhNodeHash::new(right_hash.finish());

    // ---

    let mut left_id = None;
    let mut right_id = None;

    let mut left_ghost = None;
    let mut right_ghost = None;

    let mut left_continue = true;
    let mut right_continue = true;

    if let Some(BvhNode::Internal {
        left_id: prev_left_id,
        left_hash: prev_left_hash,
        right_id: prev_right_id,
        right_hash: prev_right_hash,
        ..
    }) = node_ref.ghost
    {
        if prev_left_hash == left_hash {
            left_id = Some(prev_left_id);
            left_continue = false;

            copy(nodes, primitives, prev_left_id, left_primitives_ref);
        } else {
            left_ghost = Some(nodes.remove(prev_left_id));
        }

        if prev_right_hash == right_hash {
            right_id = Some(prev_right_id);
            right_continue = false;

            copy(nodes, primitives, prev_right_id, right_primitives_ref);
        } else {
            right_ghost = Some(nodes.remove(prev_right_id));
        }
    }

    // ---

    let left_id = left_id.unwrap_or_else(|| {
        nodes.add(BvhNode::Leaf {
            bounds: left_bounds,
            primitives_ref: left_primitives_ref,
        })
    });

    let right_id = right_id.unwrap_or_else(|| {
        nodes.add(BvhNode::Leaf {
            bounds: right_bounds,
            primitives_ref: right_primitives_ref,
        })
    });

    nodes[node_ref.id] = BvhNode::Internal {
        bounds,
        primitives_ref,
        left_id,
        left_hash,
        right_id,
        right_hash,
    };

    // ---

    let left = left_continue.then_some(BvhNodeRef {
        id: left_id,
        ghost: left_ghost,
    });

    let right = right_continue.then_some(BvhNodeRef {
        id: right_id,
        ghost: right_ghost,
    });

    (left, right)
}

fn copy(
    nodes: &mut BvhNodes,
    primitives: &mut BvhPrimitives,
    id: BvhNodeId,
    primitives_ref: BvhPrimitivesRef,
) {
    let prev_primitives_ref = nodes[id].primitives_ref();

    primitives.copy_previous_to_current(prev_primitives_ref, primitives_ref);

    let primitives_offset = (primitives_ref.start().get() as i32)
        - (prev_primitives_ref.start().get() as i32);

    if primitives_offset != 0 {
        offset_primitives(nodes, primitives_offset, id);
    }
}

fn offset_primitives(nodes: &mut BvhNodes, offset: i32, id: BvhNodeId) {
    match &mut nodes[id] {
        BvhNode::Internal { primitives_ref, .. }
        | BvhNode::Leaf { primitives_ref, .. } => {
            primitives_ref.offset(offset);
        }
    }

    if let BvhNode::Internal {
        left_id, right_id, ..
    } = nodes[id]
    {
        offset_primitives(nodes, offset, left_id);
        offset_primitives(nodes, offset, right_id);
    }
}

#[derive(Clone, Copy, Debug)]
struct SplittingPlane {
    split_by: Axis,
    split_at: f32,
    split_cost: f32,
}

#[derive(Clone, Copy, Default, Debug)]
struct Bin {
    bounds: BoundingBox,
    count: u32,
}

#[derive(Debug)]
struct BvhNodeRef {
    id: BvhNodeId,
    ghost: Option<BvhNode>,
}

impl BvhNodeRef {
    fn root(ghost: Option<BvhNode>) -> Self {
        Self {
            id: BvhNodeId::root(),
            ghost,
        }
    }
}

```

`strolle/src/bvh/node.rs`:

```rs
use super::BvhPrimitivesRef;
use crate::BoundingBox;

#[derive(Clone, Copy, Debug)]
pub enum BvhNode {
    Internal {
        bounds: BoundingBox,
        primitives_ref: BvhPrimitivesRef,
        left_id: BvhNodeId,
        left_hash: BvhNodeHash,
        right_id: BvhNodeId,
        right_hash: BvhNodeHash,
    },

    Leaf {
        bounds: BoundingBox,
        primitives_ref: BvhPrimitivesRef,
    },
}

impl BvhNode {
    pub fn bounds(&self) -> BoundingBox {
        match self {
            BvhNode::Internal { bounds, .. } => *bounds,
            BvhNode::Leaf { bounds, .. } => *bounds,
        }
    }

    pub fn primitives_ref(&self) -> BvhPrimitivesRef {
        match self {
            BvhNode::Internal { primitives_ref, .. } => *primitives_ref,
            BvhNode::Leaf { primitives_ref, .. } => *primitives_ref,
        }
    }

    pub fn sah_cost(&self) -> f32 {
        if let BvhNode::Leaf {
            bounds,
            primitives_ref,
        } = self
        {
            (primitives_ref.len() as f32) * bounds.half_area()
        } else {
            0.0
        }
    }
}

impl Default for BvhNode {
    fn default() -> Self {
        BvhNode::Leaf {
            bounds: Default::default(),
            primitives_ref: Default::default(),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BvhNodeId(u32);

impl BvhNodeId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn root() -> Self {
        Self::new(0)
    }

    pub fn get(&self) -> u32 {
        self.0
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BvhNodeHash(u64);

impl BvhNodeHash {
    pub fn new(hash: u64) -> Self {
        Self(hash)
    }
}

```

`strolle/src/bvh/nodes.rs`:

```rs
use std::{mem, ops};

use super::{BvhNode, BvhNodeId};

#[derive(Debug, Default)]
pub struct BvhNodes {
    pub nodes: Vec<BvhNode>,
    pub free_nodes: Vec<BvhNodeId>,
}

impl BvhNodes {
    pub fn add(&mut self, node: BvhNode) -> BvhNodeId {
        if let Some(id) = self.free_nodes.pop() {
            let prev_node = mem::replace(&mut self[id], node);

            if let BvhNode::Internal {
                left_id, right_id, ..
            } = prev_node
            {
                self.free_nodes.push(left_id);
                self.free_nodes.push(right_id);
            }

            id
        } else {
            self.nodes.push(node);

            BvhNodeId::new((self.nodes.len() - 1) as u32)
        }
    }

    pub fn remove(&mut self, id: BvhNodeId) -> BvhNode {
        self.free_nodes.push(id);

        mem::take(&mut self[id])
    }

    pub fn remove_tree(&mut self, id: BvhNodeId) {
        self.free_nodes.push(id);
    }

    pub fn set_root(&mut self, node: BvhNode) -> Option<BvhNode> {
        if self.nodes.is_empty() {
            self.nodes.push(node);
            None
        } else {
            Some(mem::replace(&mut self[BvhNodeId::root()], node))
        }
    }
}

impl ops::Index<BvhNodeId> for BvhNodes {
    type Output = BvhNode;

    fn index(&self, index: BvhNodeId) -> &Self::Output {
        &self.nodes[index.get() as usize]
    }
}

impl ops::IndexMut<BvhNodeId> for BvhNodes {
    fn index_mut(&mut self, index: BvhNodeId) -> &mut Self::Output {
        &mut self.nodes[index.get() as usize]
    }
}

```

`strolle/src/bvh/primitive.rs`:

```rs
use std::hash::{Hash, Hasher};
use std::ops::Range;

use glam::Vec3;

use crate::gpu;
use crate::utils::BoundingBox;

#[derive(Clone, Copy, Debug)]
pub struct BvhPrimitive {
    pub triangle_id: gpu::TriangleId,
    pub material_id: gpu::MaterialId,
    pub center: Vec3,
    pub bounds: BoundingBox,
}

impl BvhPrimitive {
    pub fn kill(&mut self) {
        self.center = Vec3::MAX;
    }

    pub fn is_alive(&self) -> bool {
        self.center.x != f32::MAX
    }
}

impl Hash for BvhPrimitive {
    fn hash<H>(&self, state: &mut H)
    where
        H: Hasher,
    {
        self.center.x.to_bits().hash(state);
        self.center.y.to_bits().hash(state);
        self.center.z.to_bits().hash(state);
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct BvhPrimitiveId(u32);

impl BvhPrimitiveId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn get(&self) -> u32 {
        self.0
    }
}

#[derive(Clone, Copy, Debug)]
pub struct BvhPrimitivesRef {
    start: BvhPrimitiveId,
    end: BvhPrimitiveId,
}

impl BvhPrimitivesRef {
    pub fn new(start: BvhPrimitiveId, end: BvhPrimitiveId) -> Self {
        Self { start, end }
    }

    pub fn start(&self) -> BvhPrimitiveId {
        self.start
    }

    pub fn end(&self) -> BvhPrimitiveId {
        self.end
    }

    pub fn offset(&mut self, offset: i32) {
        self.start =
            BvhPrimitiveId::new((self.start.get() as i32 + offset) as u32);

        self.end = BvhPrimitiveId::new((self.end.get() as i32 + offset) as u32);
    }

    pub fn as_range(&self) -> Range<usize> {
        let start = self.start.get() as usize;
        let end = self.end.get() as usize;

        start..end
    }

    pub fn len(&self) -> usize {
        (self.end.get() - self.start.get()) as usize
    }
}

impl Default for BvhPrimitivesRef {
    fn default() -> Self {
        Self::new(BvhPrimitiveId::new(0), BvhPrimitiveId::new(0))
    }
}

```

`strolle/src/bvh/primitives.rs`:

```rs
use std::mem;
use std::ops::Range;

use super::{BvhPrimitive, BvhPrimitiveId, BvhPrimitivesRef};

#[derive(Debug, Default)]
pub struct BvhPrimitives {
    all: Vec<BvhPrimitive>,
    current: Vec<BvhPrimitive>,
    previous: Vec<BvhPrimitive>,
}

impl BvhPrimitives {
    pub fn add(&mut self, prim: BvhPrimitive) {
        self.all.push(prim);
    }

    pub fn update(
        &mut self,
        ids: Range<usize>,
    ) -> impl Iterator<Item = &mut BvhPrimitive> {
        self.all[ids].iter_mut()
    }

    pub fn current_ref(&self) -> BvhPrimitivesRef {
        BvhPrimitivesRef::new(
            BvhPrimitiveId::new(0),
            BvhPrimitiveId::new(self.current.len() as u32),
        )
    }

    pub fn current(&self, range: BvhPrimitivesRef) -> &[BvhPrimitive] {
        let start = range.start().get() as usize;
        let end = range.end().get() as usize;

        &self.current[start..end]
    }

    pub fn current_mut(
        &mut self,
        range: BvhPrimitivesRef,
    ) -> &mut [BvhPrimitive] {
        let start = range.start().get() as usize;
        let end = range.end().get() as usize;

        &mut self.current[start..end]
    }

    pub fn copy_previous_to_current(
        &mut self,
        previous: BvhPrimitivesRef,
        current: BvhPrimitivesRef,
    ) {
        self.current[current.as_range()]
            .copy_from_slice(&self.previous[previous.as_range()]);
    }

    pub fn begin_refresh(&mut self) {
        self.current =
            self.all.iter().filter(|p| p.is_alive()).copied().collect();
    }

    pub fn end_refresh(&mut self) {
        self.previous = mem::take(&mut self.current);
    }
}

```

`strolle/src/bvh/serializer.rs`:

```rs
use glam::Vec4;
use spirv_std::glam::vec4;

use super::{BvhNodeId, BvhNodes, BvhPrimitives};
use crate::{AlphaMode, BvhNode, Materials, Params};

pub fn run<P>(
    materials: &Materials<P>,
    nodes: &BvhNodes,
    primitives: &BvhPrimitives,
    buffer: &mut Vec<Vec4>,
) where
    P: Params,
{
    buffer.clear();

    serialize(materials, nodes, primitives, buffer, BvhNodeId::root());
}

fn serialize<P>(
    materials: &Materials<P>,
    nodes: &BvhNodes,
    primitives: &BvhPrimitives,
    buffer: &mut Vec<Vec4>,
    id: BvhNodeId,
) -> u32
where
    P: Params,
{
    const OP_INTERNAL: u32 = 0;
    const OP_LEAF: u32 = 1;

    let ptr = buffer.len();

    match nodes[id] {
        BvhNode::Internal {
            left_id, right_id, ..
        } => {
            buffer.push(Default::default());
            buffer.push(Default::default());
            buffer.push(Default::default());
            buffer.push(Default::default());

            let left_bb = nodes[left_id].bounds();
            let right_bb = nodes[right_id].bounds();

            let _left_ptr =
                serialize(materials, nodes, primitives, buffer, left_id);

            let right_ptr =
                serialize(materials, nodes, primitives, buffer, right_id);

            buffer[ptr] = vec4(
                left_bb.min().x,
                left_bb.min().y,
                left_bb.min().z,
                f32::from_bits(OP_INTERNAL),
            );

            buffer[ptr + 1] = vec4(
                left_bb.max().x,
                left_bb.max().y,
                left_bb.max().z,
                f32::from_bits(right_ptr),
            );

            buffer[ptr + 2] = vec4(
                right_bb.min().x,
                right_bb.min().y,
                right_bb.min().z,
                Default::default(),
            );

            buffer[ptr + 3] = vec4(
                right_bb.max().x,
                right_bb.max().y,
                right_bb.max().z,
                Default::default(),
            );
        }

        BvhNode::Leaf { primitives_ref, .. } => {
            for (primitive_idx, primitive) in
                primitives.current(primitives_ref).iter().enumerate()
            {
                let material = &materials[primitive.material_id];

                let flags = {
                    let got_more_entries =
                        primitive_idx + 1 < primitives_ref.len();

                    let has_alpha_blending =
                        matches!(material.alpha_mode, AlphaMode::Blend);

                    (got_more_entries as u32)
                        | ((has_alpha_blending as u32) << 1)
                };

                buffer.push(vec4(
                    f32::from_bits(flags),
                    f32::from_bits(primitive.triangle_id.get()),
                    f32::from_bits(primitive.material_id.get()),
                    f32::from_bits(OP_LEAF),
                ));
            }
        }
    }

    ptr as u32
}

```

`strolle/src/camera.rs`:

```rs
use std::fmt;

use log::info;
use spirv_std::glam::{uvec2, Mat4, UVec2, Vec3};

use crate::gpu;

#[derive(Clone, Debug, Default)]
pub struct Camera {
    pub mode: CameraMode,
    pub viewport: CameraViewport,
    pub transform: Mat4,
    pub projection: Mat4,
}

impl Camera {
    pub(crate) fn is_invalidated_by(&self, older: &Self) -> bool {
        if self.mode != older.mode {
            info!(
                "Camera `{}` invalidated: mode has been changed ({:?} -> {:?})",
                older, older.mode, self.mode,
            );

            return true;
        }

        if self.viewport.format != older.viewport.format {
            info!(
                "Camera `{}` invalidated: viewport.format has been changed \
                 ({:?} -> {:?})",
                older, older.viewport.format, self.viewport.format,
            );

            return true;
        }

        if self.viewport.size != older.viewport.size {
            info!(
                "Camera `{}` invalidated: viewport.size has been changed \
                 ({} -> {})",
                older, older.viewport.size, self.viewport.size,
            );

            return true;
        }

        false
    }

    pub(crate) fn serialize(&self) -> gpu::Camera {
        gpu::Camera {
            projection_view: self.projection * self.transform.inverse(),
            ndc_to_world: self.transform * self.projection.inverse(),
            origin: self
                .transform
                .to_scale_rotation_translation()
                .2
                .extend(Default::default()),
            screen: self
                .viewport
                .size
                .as_vec2()
                .extend(Default::default())
                .extend(Default::default()),
        }
    }
}

impl fmt::Display for Camera {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "pos={}x{}, size={}x{}, format={:?}",
            self.viewport.position.x,
            self.viewport.position.y,
            self.viewport.size.x,
            self.viewport.size.y,
            self.viewport.format,
        )
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CameraMode {
    /// Shows the final composed image, default
    Image { denoise: bool },

    /// Shows direct diffuse lighting
    DiDiffuse { denoise: bool },

    /// Shows direct specular lighting
    DiSpecular { denoise: bool },

    /// Shows indirect diffuse lighting
    GiDiffuse { denoise: bool },

    /// Shows indirect specular lighting
    GiSpecular { denoise: bool },

    /// Shows BVH tree's heatmap
    BvhHeatmap,

    /// Shows a path-traced reference image; slow
    Reference { depth: u8 },
}

impl CameraMode {
    pub(crate) fn serialize(&self) -> u32 {
        match self {
            CameraMode::Image { .. } => 0,
            CameraMode::DiDiffuse { .. } => 1,
            CameraMode::DiSpecular { .. } => 2,
            CameraMode::GiDiffuse { .. } => 3,
            CameraMode::GiSpecular { .. } => 4,
            CameraMode::BvhHeatmap => 5,
            CameraMode::Reference { .. } => 6,
        }
    }

    pub(crate) fn needs_di(&self) -> bool {
        matches!(
            self,
            Self::Image { .. }
                | Self::DiDiffuse { .. }
                | Self::DiSpecular { .. }
        )
    }

    pub(crate) fn needs_gi(&self) -> bool {
        matches!(
            self,
            Self::Image { .. }
                | Self::GiDiffuse { .. }
                | Self::GiSpecular { .. }
        )
    }

    pub(crate) fn denoise(&self) -> bool {
        matches!(
            self,
            Self::Image { denoise: true }
                | Self::DiDiffuse { denoise: true }
                | Self::DiSpecular { denoise: true }
                | Self::GiDiffuse { denoise: true }
                | Self::GiSpecular { denoise: true }
        )
    }

    pub(crate) fn denoise_di_diff(&self) -> bool {
        matches!(
            self,
            Self::Image { denoise: true } | Self::DiDiffuse { denoise: true }
        )
    }

    pub(crate) fn denoise_gi_diff(&self) -> bool {
        matches!(
            self,
            Self::Image { denoise: true } | Self::GiDiffuse { denoise: true }
        )
    }
}

impl Default for CameraMode {
    fn default() -> Self {
        Self::Image { denoise: true }
    }
}

#[derive(Clone, Debug)]
pub struct CameraViewport {
    pub format: wgpu::TextureFormat,
    pub size: UVec2,
    pub position: UVec2,
}

impl Default for CameraViewport {
    fn default() -> Self {
        Self {
            format: wgpu::TextureFormat::Rgba8UnormSrgb,
            size: uvec2(512, 512),
            position: uvec2(0, 0),
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct CameraBackground {
    pub color: Vec3,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct CameraHandle(usize);

impl CameraHandle {
    pub(crate) fn new(id: usize) -> Self {
        Self(id)
    }
}

```

`strolle/src/camera_controller.rs`:

```rs
mod buffers;
mod pass;
mod passes;

use std::ops::DerefMut;

use log::{debug, info};
use rand::Rng;

pub use self::buffers::*;
pub use self::pass::*;
pub use self::passes::*;
use crate::{gpu, Camera, CameraMode, Engine, Params};

#[derive(Debug)]
pub struct CameraController {
    camera: Camera,
    buffers: CameraBuffers,
    passes: CameraPasses,
    frame: gpu::Frame,
}

impl CameraController {
    pub(crate) fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        camera: Camera,
    ) -> Self
    where
        P: Params,
    {
        info!("Creating camera `{}`", camera);

        let buffers = CameraBuffers::new(device, &camera);
        let passes = CameraPasses::new(engine, device, &camera, &buffers);

        Self {
            camera,
            buffers,
            passes,
            frame: Default::default(),
        }
    }

    pub fn update<P>(
        &mut self,
        engine: &Engine<P>,
        device: &wgpu::Device,
        camera: Camera,
    ) where
        P: Params,
    {
        let is_invalidated = self.camera.is_invalidated_by(&camera);

        self.camera = camera;
        *self.buffers.prev_camera.deref_mut() = *self.buffers.curr_camera;
        *self.buffers.curr_camera.deref_mut() = self.camera.serialize();

        if is_invalidated {
            self.rebuild_buffers(device);
            self.rebuild_passes(engine, device);
        }
    }

    fn rebuild_buffers(&mut self, device: &wgpu::Device) {
        debug!("Rebuilding buffers for camera `{}`", self.camera);

        self.buffers = CameraBuffers::new(device, &self.camera);
    }

    fn rebuild_passes<P>(&mut self, engine: &Engine<P>, device: &wgpu::Device)
    where
        P: Params,
    {
        debug!("Rebuilding passes for camera `{}`", self.camera);

        self.passes =
            CameraPasses::new(engine, device, &self.camera, &self.buffers);
    }

    pub fn flush(&mut self, frame: gpu::Frame, queue: &wgpu::Queue) {
        self.frame = frame;
        self.buffers.curr_camera.flush(queue);
        self.buffers.prev_camera.flush(queue);
    }

    pub fn render<P>(
        &self,
        engine: &Engine<P>,
        encoder: &mut wgpu::CommandEncoder,
        view: &wgpu::TextureView,
    ) where
        P: Params,
    {
        match self.camera.mode {
            CameraMode::BvhHeatmap => {
                self.passes.bvh_heatmap.run(self, encoder);
                self.passes.frame_composition.run(self, encoder, view);
            }

            CameraMode::Reference { depth } => {
                self.passes.atmosphere.run(engine, self, encoder);

                for depth in 0..=depth {
                    self.passes.ref_tracing.run(self, encoder, depth);
                    self.passes.ref_shading.run(self, encoder, depth);
                }

                self.passes.ref_shading.run(self, encoder, u8::MAX);
                self.passes.frame_composition.run(self, encoder, view);
            }

            _ => {
                let has_any_objects = !engine.instances.is_empty();

                self.passes.atmosphere.run(engine, self, encoder);
                self.passes.prim_raster.run(engine, self, encoder);

                if has_any_objects {
                    self.passes.frame_reprojection.run(self, encoder);

                    if self.camera.mode.needs_di() {
                        self.passes.di_sampling.run(self, encoder);
                        self.passes.di_temporal_resampling.run(self, encoder);
                        self.passes.di_spatial_resampling.run(self, encoder);
                        self.passes.di_resolving.run(self, encoder);
                    }

                    if self.camera.mode.needs_gi() {
                        let source;

                        self.passes.gi_reprojection.run(self, encoder);

                        if self.frame.is_gi_tracing() {
                            if self.frame.get() % 2 == 0 {
                                self.passes.gi_sampling.run(self, encoder);
                            }

                            self.passes
                                .gi_temporal_resampling
                                .run(self, encoder);

                            if self.frame.get() % 2 == 1 {
                                self.passes
                                    .gi_spatial_resampling
                                    .run(self, encoder);

                                source = 1;
                            } else {
                                source = 0;
                            }
                        } else {
                            self.passes.gi_sampling.run(self, encoder);

                            self.passes
                                .gi_temporal_resampling
                                .run(self, encoder);

                            source = 0;
                        }

                        self.passes
                            .gi_preview_resampling
                            .run(self, encoder, source);

                        self.passes.gi_resolving.run(self, encoder, source);
                    }
                }

                self.passes.frame_denoising.run(self, encoder);
                self.passes.frame_composition.run(self, encoder, view);
            }
        }
    }

    pub fn invalidate<P>(&mut self, engine: &Engine<P>, device: &wgpu::Device)
    where
        P: Params,
    {
        self.rebuild_passes(engine, device);
    }

    /// Returns whether the current frame should use the first or the second
    /// resource when given resource is double-buffered.
    fn is_alternate(&self) -> bool {
        self.frame.get() % 2 == 1
    }

    fn pass_params(&self) -> gpu::PassParams {
        gpu::PassParams {
            seed: rand::thread_rng().gen(),
            frame: self.frame,
        }
    }
}

impl Drop for CameraController {
    fn drop(&mut self) {
        info!("Deleting camera `{}`", self.camera);
    }
}

```

`strolle/src/camera_controller/buffers.rs`:

```rs
use log::debug;

use crate::{
    gpu, Camera, DoubleBuffered, MappedUniformBuffer, StorageBuffer, Texture,
};

#[derive(Debug)]
pub struct CameraBuffers {
    pub curr_camera: MappedUniformBuffer<gpu::Camera>,
    pub prev_camera: MappedUniformBuffer<gpu::Camera>,

    pub atmosphere_transmittance_lut: Texture,
    pub atmosphere_scattering_lut: Texture,
    pub atmosphere_sky_lut: Texture,

    pub prim_depth: Texture,
    pub prim_gbuffer_d0: DoubleBuffered<Texture>,
    pub prim_gbuffer_d1: DoubleBuffered<Texture>,
    pub prim_surface_map: DoubleBuffered<Texture>,

    pub reprojection_map: Texture,
    pub velocity_map: Texture,

    pub di_reservoirs: [StorageBuffer; 3],

    pub di_diff_samples: Texture,
    pub di_diff_prev_colors: Texture,
    pub di_diff_curr_colors: Texture,
    pub di_diff_moments: DoubleBuffered<Texture>,
    pub di_diff_stash: Texture,

    pub di_spec_samples: Texture,

    pub gi_d0: Texture,
    pub gi_d1: Texture,
    pub gi_d2: Texture,
    pub gi_reservoirs: [StorageBuffer; 4],

    pub gi_diff_samples: Texture,
    pub gi_diff_prev_colors: Texture,
    pub gi_diff_curr_colors: Texture,
    pub gi_diff_moments: DoubleBuffered<Texture>,
    pub gi_diff_stash: Texture,

    pub gi_spec_samples: Texture,

    pub ref_hits: StorageBuffer,
    pub ref_rays: StorageBuffer,
    pub ref_colors: Texture,
}

impl CameraBuffers {
    pub fn new(device: &wgpu::Device, camera: &Camera) -> Self {
        // Returns the size of a screen-space buffer with given parameters
        let viewport_buffer_size = |element_size| {
            (camera.viewport.size.x as usize)
                * (camera.viewport.size.y as usize)
                * element_size
        };

        // ---

        debug!("Initializing camera buffers");

        let camera_uniform =
            MappedUniformBuffer::new(device, "camera", camera.serialize());

        let prev_camera =
            MappedUniformBuffer::new(device, "prev_camera", camera.serialize());

        // ---------------------------------------------------------------------

        let atmosphere_transmittance_lut =
            Texture::builder("atmosphere_transmittance_lut")
                .with_size(gpu::Atmosphere::TRANSMITTANCE_LUT_RESOLUTION)
                .with_format(wgpu::TextureFormat::Rgba16Float)
                .with_usage(wgpu::TextureUsages::TEXTURE_BINDING)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .with_linear_filtering_sampler()
                .build(device);

        let atmosphere_scattering_lut =
            Texture::builder("atmosphere_scattering_lut")
                .with_size(gpu::Atmosphere::SCATTERING_LUT_RESOLUTION)
                .with_format(wgpu::TextureFormat::Rgba16Float)
                .with_usage(wgpu::TextureUsages::TEXTURE_BINDING)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .with_linear_filtering_sampler()
                .build(device);

        let atmosphere_sky_lut = Texture::builder("atmosphere_sky_lut")
            .with_size(gpu::Atmosphere::SKY_LUT_RESOLUTION)
            .with_format(wgpu::TextureFormat::Rgba16Float)
            .with_usage(wgpu::TextureUsages::TEXTURE_BINDING)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .with_linear_filtering_sampler()
            .build(device);

        // ---------------------------------------------------------------------

        let prim_depth = Texture::builder("prim_depth")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Depth32Float)
            .with_usage(wgpu::TextureUsages::RENDER_ATTACHMENT)
            .build(device);

        let prim_gbuffer_d0 = DoubleBuffered::<Texture>::new(
            device,
            Texture::builder("prim_gbuffer_d0")
                .with_size(camera.viewport.size)
                .with_format(wgpu::TextureFormat::Rgba32Float)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .with_usage(wgpu::TextureUsages::RENDER_ATTACHMENT),
        );

        let prim_gbuffer_d1 = DoubleBuffered::<Texture>::new(
            device,
            Texture::builder("prim_gbuffer_d1")
                .with_size(camera.viewport.size)
                .with_format(wgpu::TextureFormat::Rgba32Float)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .with_usage(wgpu::TextureUsages::RENDER_ATTACHMENT),
        );

        let prim_surface_map = DoubleBuffered::<Texture>::new(
            device,
            Texture::builder("prim_surface_map")
                .with_size(camera.viewport.size)
                .with_format(wgpu::TextureFormat::Rgba32Float)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .with_usage(wgpu::TextureUsages::RENDER_ATTACHMENT),
        );

        // ---------------------------------------------------------------------

        let reprojection_map = Texture::builder("reprojection_map")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let velocity_map = Texture::builder("velocity_map")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .with_usage(wgpu::TextureUsages::RENDER_ATTACHMENT)
            .build(device);

        // ---------------------------------------------------------------------

        let di_reservoirs = [0, 1, 2].map(|idx| {
            StorageBuffer::new(
                device,
                format!("di_reservoir_{}", idx),
                viewport_buffer_size(2 * 4 * 4),
            )
        });

        // ---

        let di_diff_samples = Texture::builder("di_diff_samples")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let di_diff_prev_colors = Texture::builder("di_diff_prev_colors")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let di_diff_curr_colors = Texture::builder("di_diff_curr_colors")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let di_diff_moments = DoubleBuffered::<Texture>::new(
            device,
            Texture::builder("di_diff_moments")
                .with_size(camera.viewport.size)
                .with_format(wgpu::TextureFormat::Rgba32Float)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING),
        );

        let di_diff_stash = Texture::builder("di_diff_stash")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        // ---

        let di_spec_samples = Texture::builder("di_spec_samples")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        // ---------------------------------------------------------------------

        let gi_d0 = Texture::builder("gi_d0")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_d1 = Texture::builder("gi_d1")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_d2 = Texture::builder("gi_d2")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_reservoirs = [0, 1, 2, 3].map(|idx| {
            StorageBuffer::new(
                device,
                format!("gi_reservoir_{}", idx),
                viewport_buffer_size(4 * 4 * 4),
            )
        });

        // ---

        let gi_diff_samples = Texture::builder("gi_diff_samples")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_diff_prev_colors = Texture::builder("gi_diff_prev_colors")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_diff_curr_colors = Texture::builder("gi_diff_curr_colors")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        let gi_diff_moments = DoubleBuffered::<Texture>::new(
            device,
            Texture::builder("gi_diff_moments")
                .with_size(camera.viewport.size)
                .with_format(wgpu::TextureFormat::Rgba32Float)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING),
        );

        let gi_diff_stash = Texture::builder("gi_diff_stash")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        // ---

        let gi_spec_samples = Texture::builder("gi_spec_samples")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        // ---------------------------------------------------------------------

        // TODO initialize lazily
        let ref_rays = StorageBuffer::new(
            device,
            "ref_rays",
            viewport_buffer_size(3 * 4 * 4),
        );

        // TODO initialize lazily
        let ref_hits = StorageBuffer::new(
            device,
            "ref_hits",
            viewport_buffer_size(2 * 4 * 4),
        );

        // TODO initialize lazily
        let ref_colors = Texture::builder("ref_colors")
            .with_size(camera.viewport.size)
            .with_format(wgpu::TextureFormat::Rgba32Float)
            .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
            .build(device);

        // ---------------------------------------------------------------------

        Self {
            curr_camera: camera_uniform,
            prev_camera,

            atmosphere_transmittance_lut,
            atmosphere_scattering_lut,
            atmosphere_sky_lut,

            prim_depth,
            prim_gbuffer_d0,
            prim_gbuffer_d1,
            prim_surface_map,

            reprojection_map,
            velocity_map,

            di_reservoirs,

            di_diff_samples,
            di_diff_prev_colors,
            di_diff_curr_colors,
            di_diff_moments,
            di_diff_stash,

            di_spec_samples,

            gi_d0,
            gi_d1,
            gi_d2,
            gi_reservoirs,

            gi_diff_samples,
            gi_diff_prev_colors,
            gi_diff_curr_colors,
            gi_diff_moments,
            gi_diff_stash,

            gi_spec_samples,

            ref_hits,
            ref_rays,
            ref_colors,
        }
    }
}

```

`strolle/src/camera_controller/pass.rs`:

```rs
use std::marker::PhantomData;
use std::mem;
use std::ops::Range;

use bytemuck::Pod;
use log::debug;
use spirv_std::glam::UVec2;

use crate::{
    gpu, BindGroup, BindGroupBuilder, CameraController, DoubleBufferedBindable,
};

#[derive(Debug)]
pub struct CameraComputePass<P = gpu::PassParams> {
    label: String,
    bind_groups: Vec<BindGroup>,
    pipeline: wgpu::ComputePipeline,
    _params: PhantomData<P>,
}

impl<P> CameraComputePass<P>
where
    P: Pod,
{
    pub fn builder<'a>(label: impl ToString) -> CameraPassBuilder<'a, P> {
        CameraPassBuilder {
            label: label.to_string(),
            bind_groups: Default::default(),
            _params: Default::default(),
        }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        size: UVec2,
        params: P,
    ) {
        let label = format!("strolle_{}_pass", self.label);

        let mut pass =
            encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
                label: Some(&label),
            });

        pass.set_pipeline(&self.pipeline);

        if mem::size_of::<P>() > 0 {
            pass.set_push_constants(0, bytemuck::bytes_of(&params));
        }

        for (bind_group_idx, bind_group) in self.bind_groups.iter().enumerate()
        {
            pass.set_bind_group(
                bind_group_idx as u32,
                bind_group.get(camera.is_alternate()),
                &[],
            );
        }

        pass.dispatch_workgroups(size.x, size.y, 1);
    }
}

pub struct CameraPassBuilder<'a, P> {
    label: String,
    bind_groups: Vec<BindGroupBuilder<'a>>,
    _params: PhantomData<P>,
}

impl<'a, P> CameraPassBuilder<'a, P>
where
    P: Pod,
{
    pub fn bind<const N: usize>(
        mut self,
        items: [&'a dyn DoubleBufferedBindable; N],
    ) -> Self {
        let mut bind_group = BindGroup::builder(format!(
            "{}_bg{}",
            self.label,
            self.bind_groups.len()
        ));

        for item in items {
            bind_group = bind_group.add(item);
        }

        self.bind_groups.push(bind_group);
        self
    }

    pub fn build(
        self,
        device: &wgpu::Device,
        (module, entry_point): &(wgpu::ShaderModule, &'static str),
    ) -> CameraComputePass<P> {
        debug!("Initializing pass: {}:{}", self.label, entry_point);

        let bind_groups: Vec<_> = self
            .bind_groups
            .into_iter()
            .map(|bg| bg.build(device))
            .collect();

        let bind_group_layouts: Vec<_> =
            bind_groups.iter().map(|bg| bg.layout()).collect();

        let push_constant_ranges = if mem::size_of::<P>() > 0 {
            vec![wgpu::PushConstantRange {
                stages: wgpu::ShaderStages::COMPUTE,
                range: Range {
                    start: 0,
                    end: mem::size_of::<P>() as u32,
                },
            }]
        } else {
            vec![]
        };

        let pipeline_layout_label =
            format!("strolle_{}_pipeline_layout", self.label);

        let pipeline_layout =
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some(&pipeline_layout_label),
                bind_group_layouts: &bind_group_layouts,
                push_constant_ranges: &push_constant_ranges,
            });

        let pipeline_label = format!("strolle_{}_pipeline", self.label);

        let pipeline =
            device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                label: Some(&pipeline_label),
                layout: Some(&pipeline_layout),
                module,
                entry_point,
            });

        CameraComputePass {
            label: self.label,
            bind_groups,
            pipeline,
            _params: PhantomData,
        }
    }
}

```

`strolle/src/camera_controller/passes.rs`:

```rs
use log::debug;

use crate::{Camera, CameraBuffers, Engine, Params};

macro_rules! passes {
    ([ $( $name:ident => $class:ident, )* ]) => {
        $( mod $name; )*
        $( pub use self::$name::*; )*

        #[derive(Debug)]
        pub struct CameraPasses {
            $( pub $name: $class, )*
        }

        impl CameraPasses {
            pub fn new<P>(
                engine: &Engine<P>,
                device: &wgpu::Device,
                config: &Camera,
                buffers: &CameraBuffers,
            ) -> Self
            where
                P: Params,
            {
                debug!("Initializing camera passes");

                Self {
                    $( $name: $class::new(engine, device, config, buffers), )*
                }
            }
        }
    };
}

passes!([
    atmosphere => AtmospherePass,
    bvh_heatmap => BvhHeatmapPass,
    di_resolving => DiResolvingPass,
    di_sampling => DiSamplingPass,
    di_spatial_resampling => DiSpatialResamplingPass,
    di_temporal_resampling => DiTemporalResamplingPass,
    frame_composition => FrameCompositionPass,
    frame_denoising => FrameDenoisingPass,
    frame_reprojection => FrameReprojectionPass,
    gi_preview_resampling => GiPreviewResamplingPass,
    gi_reprojection => GiReprojectionPass,
    gi_resolving => GiResolvingPass,
    gi_sampling => GiSamplingPass,
    gi_spatial_resampling => GiSpatialResamplingPass,
    gi_temporal_resampling => GiTemporalResamplingPass,
    prim_raster => PrimRasterPass,
    ref_shading => RefShadingPass,
    ref_tracing => RefTracingPass,
]);

```

`strolle/src/camera_controller/passes/atmosphere.rs`:

```rs
use std::sync::Mutex;

use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct AtmospherePass {
    generate_transmittance_lut_pass: CameraComputePass<()>,
    generate_scattering_lut_pass: CameraComputePass<()>,
    generate_sky_lut_pass: CameraComputePass<()>,

    is_initialized: Mutex<bool>,
    known_sun_altitude: Mutex<Option<f32>>,
}

impl AtmospherePass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let generate_transmittance_lut_pass =
            CameraComputePass::builder("atmosphere_generate_transmittance_lut")
                .bind([&buffers.atmosphere_transmittance_lut.bind_writable()])
                .build(
                    device,
                    &engine.shaders.atmosphere_generate_transmittance_lut,
                );

        let generate_scattering_lut_pass =
            CameraComputePass::builder("atmosphere_generate_scattering_lut")
                .bind([
                    &buffers.atmosphere_transmittance_lut.bind_sampled(),
                    &buffers.atmosphere_scattering_lut.bind_writable(),
                ])
                .build(
                    device,
                    &engine.shaders.atmosphere_generate_scattering_lut,
                );

        let generate_sky_lut_pass =
            CameraComputePass::builder("atmosphere_generate_sky_lut")
                .bind([
                    &engine.world.bind_readable(),
                    &buffers.atmosphere_transmittance_lut.bind_sampled(),
                    &buffers.atmosphere_scattering_lut.bind_sampled(),
                    &buffers.atmosphere_sky_lut.bind_writable(),
                ])
                .build(device, &engine.shaders.atmosphere_generate_sky_lut);

        Self {
            generate_transmittance_lut_pass,
            generate_scattering_lut_pass,
            generate_sky_lut_pass,

            is_initialized: Mutex::new(false),
            known_sun_altitude: Mutex::new(None),
        }
    }

    pub fn run<P>(
        &self,
        engine: &Engine<P>,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) where
        P: Params,
    {
        let mut is_initialized = self.is_initialized.lock().unwrap();
        let mut known_sun_altitude = self.known_sun_altitude.lock().unwrap();

        // Transmittance and scattering don't depend on anything so it's enough
        // if we just generate them once, the first time they are needed
        if !*is_initialized {
            self.generate_transmittance_lut_pass.run(
                camera,
                encoder,
                (gpu::Atmosphere::TRANSMITTANCE_LUT_RESOLUTION + 7) / 8,
                (),
            );

            self.generate_scattering_lut_pass.run(
                camera,
                encoder,
                (gpu::Atmosphere::SCATTERING_LUT_RESOLUTION + 7) / 8,
                (),
            );

            *is_initialized = true;
        }

        // On the other hand, the sky lookup texture depends on sun's altitude
        if known_sun_altitude
            .map_or(true, |altitude| altitude != engine.sun.altitude)
        {
            self.generate_sky_lut_pass.run(
                camera,
                encoder,
                (gpu::Atmosphere::SKY_LUT_RESOLUTION + 7) / 8,
                (),
            );

            *known_sun_altitude = Some(engine.sun.altitude);
        }
    }
}

```

`strolle/src/camera_controller/passes/bvh_heatmap.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct BvhHeatmapPass {
    pass: CameraComputePass<()>,
}

impl BvhHeatmapPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("bvh_heatmap")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.images.bind_atlas(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.ref_colors.bind_writable(),
            ])
            .build(device, &engine.shaders.bvh_heatmap);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, ());
    }
}

```

`strolle/src/camera_controller/passes/di_resolving.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct DiResolvingPass {
    pass: CameraComputePass,
}

impl DiResolvingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("di_resolving")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.lights.bind_readable(),
                &engine.images.bind_atlas(),
                &engine.world.bind_readable(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.atmosphere_transmittance_lut.bind_sampled(),
                &buffers.atmosphere_sky_lut.bind_sampled(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.di_reservoirs[2].bind_readable(),
                &buffers.di_reservoirs[0].bind_writable(),
                &buffers.di_diff_samples.bind_writable(),
                &buffers.di_spec_samples.bind_writable(),
            ])
            .build(device, &engine.shaders.di_resolving);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/di_sampling.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct DiSamplingPass {
    pass: CameraComputePass,
}

impl DiSamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("di_sampling")
            .bind([
                &engine.noise.bind_blue_noise(),
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.lights.bind_readable(),
                &engine.images.bind_atlas(),
                &engine.world.bind_readable(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.di_reservoirs[1].bind_writable(),
            ])
            .build(device, &engine.shaders.di_sampling);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/di_spatial_resampling.rs`:

```rs
use glam::uvec2;

use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct DiSpatialResamplingPass {
    pick_pass: CameraComputePass,
    trace_pass: CameraComputePass,
    sample_pass: CameraComputePass,
}

impl DiSpatialResamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        // We just need a couple of temporary buffers - instead of allocating
        // new ones, let's reuse the ones we've got:
        let buf_d0 = &buffers.di_diff_samples;
        let buf_d1 = &buffers.di_diff_curr_colors;
        let buf_d2 = &buffers.di_diff_stash;

        let pick_pass =
            CameraComputePass::builder("di_spatial_resampling_pick")
                .bind([&engine.lights.bind_readable()])
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.prim_gbuffer_d0.curr().bind_readable(),
                    &buffers.prim_gbuffer_d1.curr().bind_readable(),
                    &buffers.di_reservoirs[1].bind_readable(),
                    &buf_d0.bind_writable(),
                    &buf_d1.bind_writable(),
                ])
                .build(device, &engine.shaders.di_spatial_resampling_pick);

        let trace_pass =
            CameraComputePass::builder("di_spatial_resampling_trace")
                .bind([
                    &engine.triangles.bind_readable(),
                    &engine.bvh.bind_readable(),
                    &engine.materials.bind_readable(),
                    &engine.images.bind_atlas(),
                ])
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buf_d0.bind_readable(),
                    &buf_d1.bind_readable(),
                    &buf_d2.bind_writable(),
                ])
                .build(device, &engine.shaders.di_spatial_resampling_trace);

        let sample_pass =
            CameraComputePass::builder("di_spatial_resampling_sample")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.di_reservoirs[1].bind_readable(),
                    &buffers.di_reservoirs[2].bind_writable(),
                    &buf_d2.bind_readable(),
                ])
                .build(device, &engine.shaders.di_spatial_resampling_sample);

        Self {
            pick_pass,
            trace_pass,
            sample_pass,
        }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        self.pick_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8 / uvec2(2, 1),
            camera.pass_params(),
        );

        self.trace_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8,
            camera.pass_params(),
        );

        self.sample_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8 / uvec2(2, 1),
            camera.pass_params(),
        );
    }
}

```

`strolle/src/camera_controller/passes/di_temporal_resampling.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct DiTemporalResamplingPass {
    pass: CameraComputePass,
}

impl DiTemporalResamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("di_temporal_resampling")
            .bind([&engine.lights.bind_readable()])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prev_camera.bind_readable(),
                &buffers.reprojection_map.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.prim_gbuffer_d0.prev().bind_readable(),
                &buffers.prim_gbuffer_d1.prev().bind_readable(),
                &buffers.di_reservoirs[0].bind_readable(),
                &buffers.di_reservoirs[1].bind_writable(),
            ])
            .build(device, &engine.shaders.di_temporal_resampling);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/frame_composition.rs`:

```rs
use std::mem;
use std::ops::Range;

use log::debug;

use crate::{
    gpu, BindGroup, Bindable, Camera, CameraBuffers, CameraController, Engine,
    Params, Texture,
};

#[derive(Debug)]
pub struct FrameCompositionPass {
    bg0: BindGroup,
    pipeline: wgpu::RenderPipeline,
}

impl FrameCompositionPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        camera: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        debug!("Initializing pass: frame_composition");

        fn a_or_b<'a>(
            a: &'a Texture,
            b: &'a Texture,
            select_a: bool,
        ) -> impl Bindable + 'a {
            if select_a {
                a.bind_readable()
            } else {
                b.bind_readable()
            }
        }

        let bg0 = BindGroup::builder("frame_composition_bg0")
            .add(&buffers.prim_gbuffer_d0.curr().bind_readable())
            .add(&buffers.prim_gbuffer_d1.curr().bind_readable())
            .add(&a_or_b(
                &buffers.di_diff_curr_colors,
                &buffers.di_diff_samples,
                camera.mode.denoise_di_diff(),
            ))
            .add(&buffers.di_spec_samples.bind_readable())
            .add(&a_or_b(
                &buffers.gi_diff_curr_colors,
                &buffers.gi_diff_samples,
                camera.mode.denoise_gi_diff(),
            ))
            .add(&buffers.gi_spec_samples.bind_readable())
            .add(&buffers.ref_colors.bind_readable())
            .build(device);

        let pipeline_layout =
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("strolle_frame_composition_pipeline_layout"),
                bind_group_layouts: &[bg0.layout()],
                push_constant_ranges: &[wgpu::PushConstantRange {
                    stages: wgpu::ShaderStages::FRAGMENT,
                    range: Range {
                        start: 0,
                        end: mem::size_of::<gpu::FrameCompositionPassParams>()
                            as u32,
                    },
                }],
            });

        let pipeline =
            device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
                label: Some("strolle_frame_composition_pipeline"),
                layout: Some(&pipeline_layout),
                vertex: wgpu::VertexState {
                    module: &engine.shaders.frame_composition_vs.0,
                    entry_point: engine.shaders.frame_composition_vs.1,
                    buffers: &[],
                },
                primitive: wgpu::PrimitiveState::default(),
                depth_stencil: None,
                multisample: wgpu::MultisampleState::default(),
                fragment: Some(wgpu::FragmentState {
                    module: &engine.shaders.frame_composition_fs.0,
                    entry_point: engine.shaders.frame_composition_fs.1,
                    targets: &[Some(wgpu::ColorTargetState {
                        format: camera.viewport.format,
                        blend: Some(wgpu::BlendState::REPLACE),
                        write_mask: wgpu::ColorWrites::ALL,
                    })],
                }),
                multiview: None,
            });

        Self { bg0, pipeline }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        view: &wgpu::TextureView,
    ) {
        let alternate = camera.is_alternate();

        let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("strolle_frame_composition"),
            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                view,
                resolve_target: None,
                ops: wgpu::Operations {
                    load: wgpu::LoadOp::Load,
                    store: true,
                },
            })],
            depth_stencil_attachment: None,
        });

        let params = gpu::FrameCompositionPassParams {
            camera_mode: camera.camera.mode.serialize(),
        };

        pass.set_scissor_rect(
            camera.camera.viewport.position.x,
            camera.camera.viewport.position.y,
            camera.camera.viewport.size.x,
            camera.camera.viewport.size.y,
        );
        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, self.bg0.get(alternate), &[]);
        pass.set_push_constants(
            wgpu::ShaderStages::FRAGMENT,
            0,
            bytemuck::bytes_of(&params),
        );
        pass.draw(0..3, 0..1);
    }
}

```

`strolle/src/camera_controller/passes/frame_denoising.rs`:

```rs
use crate::buffers::Texture;
use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct FrameDenoisingPass {
    reproject_passes: [CameraComputePass; 2],
    estimate_variance_pass: CameraComputePass,
    wavelet_passes:
        [CameraComputePass<gpu::FrameDenoisingWaveletPassParams>; 5],
}

impl FrameDenoisingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let reproject_di_pass =
            CameraComputePass::builder("frame_denoising_reproject_di")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.prim_surface_map.curr().bind_readable(),
                    &buffers.reprojection_map.bind_readable(),
                ])
                .bind([
                    &buffers.di_diff_prev_colors.bind_readable(),
                    &buffers.di_diff_moments.prev().bind_readable(),
                    &buffers.di_diff_samples.bind_readable(),
                    &buffers.di_diff_curr_colors.bind_writable(),
                    &buffers.di_diff_moments.curr().bind_writable(),
                ])
                .build(device, &engine.shaders.frame_denoising_reproject);

        let reproject_gi_pass =
            CameraComputePass::builder("frame_denoising_reproject_gi")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.prim_surface_map.curr().bind_readable(),
                    &buffers.reprojection_map.bind_readable(),
                ])
                .bind([
                    &buffers.gi_diff_prev_colors.bind_readable(),
                    &buffers.gi_diff_moments.prev().bind_readable(),
                    &buffers.gi_diff_samples.bind_readable(),
                    &buffers.gi_diff_curr_colors.bind_writable(),
                    &buffers.gi_diff_moments.curr().bind_writable(),
                ])
                .build(device, &engine.shaders.frame_denoising_reproject);

        let estimate_variance_pass =
            CameraComputePass::builder("frame_denoising_estimate_variance")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.prim_surface_map.curr().bind_readable(),
                ])
                .bind([
                    &buffers.di_diff_curr_colors.bind_readable(),
                    &buffers.di_diff_moments.curr().bind_readable(),
                    &buffers.di_diff_stash.bind_writable(),
                ])
                .bind([
                    &buffers.gi_diff_curr_colors.bind_readable(),
                    &buffers.gi_diff_moments.curr().bind_readable(),
                    &buffers.gi_diff_stash.bind_writable(),
                ])
                .build(
                    device,
                    &engine.shaders.frame_denoising_estimate_variance,
                );

        struct WaveletPass<'a> {
            di: (&'a Texture, &'a Texture),
            gi: (&'a Texture, &'a Texture),
        }

        let wavelet_passes = {
            let b = buffers;

            [
                WaveletPass {
                    di: (&b.di_diff_stash, &b.di_diff_prev_colors),
                    gi: (&b.gi_diff_stash, &b.gi_diff_prev_colors),
                },
                WaveletPass {
                    di: (&b.di_diff_prev_colors, &b.di_diff_stash),
                    gi: (&b.gi_diff_prev_colors, &b.gi_diff_stash),
                },
                WaveletPass {
                    di: (&b.di_diff_stash, &b.di_diff_curr_colors),
                    gi: (&b.gi_diff_stash, &b.gi_diff_curr_colors),
                },
                WaveletPass {
                    di: (&b.di_diff_curr_colors, &b.di_diff_stash),
                    gi: (&b.gi_diff_curr_colors, &b.gi_diff_stash),
                },
                WaveletPass {
                    di: (&b.di_diff_stash, &b.di_diff_curr_colors),
                    gi: (&b.gi_diff_stash, &b.gi_diff_curr_colors),
                },
            ]
        };

        let wavelet_passes = {
            let mut n = 0;

            wavelet_passes.map(|wavelet| {
                let label = format!("frame_denoising_wavelet_{}", n);

                n += 1;

                CameraComputePass::builder(label)
                    .bind([
                        &engine.noise.bind_blue_noise(),
                        &buffers.curr_camera.bind_readable(),
                        &buffers.prim_surface_map.curr().bind_readable(),
                    ])
                    .bind([
                        &wavelet.di.0.bind_readable(),
                        &wavelet.di.1.bind_writable(),
                    ])
                    .bind([
                        &wavelet.gi.0.bind_readable(),
                        &wavelet.gi.1.bind_writable(),
                    ])
                    .build(device, &engine.shaders.frame_denoising_wavelet)
            })
        };

        Self {
            reproject_passes: [reproject_di_pass, reproject_gi_pass],
            estimate_variance_pass,
            wavelet_passes,
        }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        if !camera.camera.mode.denoise() {
            return;
        }

        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.reproject_passes[0].run(
            camera,
            encoder,
            size,
            camera.pass_params(),
        );

        self.reproject_passes[1].run(
            camera,
            encoder,
            size,
            camera.pass_params(),
        );

        self.estimate_variance_pass.run(
            camera,
            encoder,
            size,
            camera.pass_params(),
        );

        for (nth, pass) in self.wavelet_passes.iter().enumerate() {
            let nth = nth as u32;

            pass.run(
                camera,
                encoder,
                size,
                gpu::FrameDenoisingWaveletPassParams {
                    frame: camera.frame,
                    stride: 2u32.pow(nth),
                    strength: (1 + nth) as f32,
                },
            );
        }
    }
}

```

`strolle/src/camera_controller/passes/frame_reprojection.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct FrameReprojectionPass {
    pass: CameraComputePass<()>,
}

impl FrameReprojectionPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("frame_reprojection")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prev_camera.bind_readable(),
                &buffers.prim_surface_map.curr().bind_readable(),
                &buffers.prim_surface_map.prev().bind_readable(),
                &buffers.velocity_map.bind_readable(),
                &buffers.reprojection_map.bind_writable(),
            ])
            .build(device, &engine.shaders.frame_reprojection);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, ());
    }
}

```

`strolle/src/camera_controller/passes/gi_preview_resampling.rs`:

```rs
use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct GiPreviewResamplingPass {
    passes: [CameraComputePass<gpu::GiPreviewResamplingPass>; 2],
}

impl GiPreviewResamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass_1 = CameraComputePass::builder("gi_preview_resampling_1")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.prim_surface_map.curr().bind_readable(),
                &buffers.gi_reservoirs[1].bind_readable(),
                &buffers.gi_reservoirs[2].bind_readable(),
                &buffers.gi_reservoirs[3].bind_writable(),
            ])
            .build(device, &engine.shaders.gi_preview_resampling);

        let pass_2 = CameraComputePass::builder("gi_preview_resampling_2")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.prim_surface_map.curr().bind_readable(),
                &buffers.gi_reservoirs[1].bind_readable(),
                &buffers.gi_reservoirs[3].bind_readable(),
                &buffers.gi_reservoirs[0].bind_writable(),
            ])
            .build(device, &engine.shaders.gi_preview_resampling);

        Self {
            passes: [pass_1, pass_2],
        }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        source: u32,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;
        let params = camera.pass_params();

        for (nth, pass) in self.passes.iter().enumerate() {
            let source = if nth == 0 { source } else { 1 };

            pass.run(
                camera,
                encoder,
                size,
                gpu::GiPreviewResamplingPass {
                    seed: params.seed,
                    frame: params.frame,
                    nth: nth as u32,
                    source,
                },
            );
        }
    }
}

```

`strolle/src/camera_controller/passes/gi_reprojection.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct GiReprojectionPass {
    pass: CameraComputePass,
}

impl GiReprojectionPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("gi_reprojection")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.reprojection_map.bind_readable(),
                &buffers.gi_reservoirs[0].bind_readable(),
                &buffers.gi_reservoirs[2].bind_writable(),
            ])
            .build(device, &engine.shaders.gi_reprojection);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/gi_resolving.rs`:

```rs
use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct GiResolvingPass {
    pass: CameraComputePass<gpu::GiResolvingPassParams>,
}

impl GiResolvingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("gi_resolving")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.gi_reservoirs[1].bind_readable(),
                &buffers.gi_reservoirs[2].bind_readable(),
                &buffers.gi_reservoirs[0].bind_writable(),
                &buffers.gi_diff_samples.bind_writable(),
                &buffers.gi_spec_samples.bind_writable(),
            ])
            .build(device, &engine.shaders.gi_resolving);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        source: u32,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(
            camera,
            encoder,
            size,
            gpu::GiResolvingPassParams {
                frame: camera.frame,
                source,
            },
        );
    }
}

```

`strolle/src/camera_controller/passes/gi_sampling.rs`:

```rs
use glam::uvec2;

use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct GiSamplingPass {
    pass_a: CameraComputePass,
    pass_b: CameraComputePass,
}

impl GiSamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass_a = CameraComputePass::builder("gi_sampling_a")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.images.bind_atlas(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.gi_d0.bind_writable(),
                &buffers.gi_d1.bind_writable(),
                &buffers.gi_d2.bind_writable(),
                &buffers.gi_reservoirs[2].bind_readable(),
            ])
            .build(device, &engine.shaders.gi_sampling_a);

        let pass_b = CameraComputePass::builder("gi_sampling_b")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.lights.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.images.bind_atlas(),
                &engine.world.bind_readable(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.atmosphere_transmittance_lut.bind_sampled(),
                &buffers.atmosphere_sky_lut.bind_sampled(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.gi_d0.bind_readable(),
                &buffers.gi_d1.bind_readable(),
                &buffers.gi_d2.bind_readable(),
                &buffers.gi_reservoirs[2].bind_readable(),
                &buffers.gi_reservoirs[1].bind_writable(),
            ])
            .build(device, &engine.shaders.gi_sampling_b);

        Self { pass_a, pass_b }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // These passes use 8x8 warps and 2x1 checkerboard:
        let size = (camera.camera.viewport.size + 7) / 8 / uvec2(2, 1);

        self.pass_a.run(camera, encoder, size, camera.pass_params());
        self.pass_b.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/gi_spatial_resampling.rs`:

```rs
use glam::uvec2;

use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct GiSpatialResamplingPass {
    pick_pass: CameraComputePass,
    trace_pass: CameraComputePass,
    sample_pass: CameraComputePass,
}

impl GiSpatialResamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pick_pass =
            CameraComputePass::builder("gi_spatial_resampling_pick")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.prim_gbuffer_d0.curr().bind_readable(),
                    &buffers.prim_gbuffer_d1.curr().bind_readable(),
                    &buffers.gi_reservoirs[1].bind_readable(),
                    &buffers.gi_d0.bind_writable(),
                    &buffers.gi_d1.bind_writable(),
                ])
                .build(device, &engine.shaders.gi_spatial_resampling_pick);

        let trace_pass =
            CameraComputePass::builder("gi_spatial_resampling_trace")
                .bind([
                    &engine.triangles.bind_readable(),
                    &engine.bvh.bind_readable(),
                    &engine.materials.bind_readable(),
                    &engine.images.bind_atlas(),
                ])
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.gi_d0.bind_readable(),
                    &buffers.gi_d1.bind_readable(),
                    &buffers.gi_d2.bind_writable(),
                ])
                .build(device, &engine.shaders.gi_spatial_resampling_trace);

        let sample_pass =
            CameraComputePass::builder("gi_spatial_resampling_sample")
                .bind([
                    &buffers.curr_camera.bind_readable(),
                    &buffers.gi_reservoirs[1].bind_readable(),
                    &buffers.gi_reservoirs[2].bind_writable(),
                    &buffers.gi_d2.bind_readable(),
                ])
                .build(device, &engine.shaders.gi_spatial_resampling_sample);

        Self {
            pick_pass,
            trace_pass,
            sample_pass,
        }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        self.pick_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8 / uvec2(2, 1),
            camera.pass_params(),
        );

        self.trace_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8,
            camera.pass_params(),
        );

        self.sample_pass.run(
            camera,
            encoder,
            (camera.camera.viewport.size + 7) / 8 / uvec2(2, 1),
            camera.pass_params(),
        );
    }
}

```

`strolle/src/camera_controller/passes/gi_temporal_resampling.rs`:

```rs
use crate::{
    Camera, CameraBuffers, CameraComputePass, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct GiTemporalResamplingPass {
    pass: CameraComputePass,
}

impl GiTemporalResamplingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("gi_temporal_resampling")
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prev_camera.bind_readable(),
                &buffers.prim_gbuffer_d0.curr().bind_readable(),
                &buffers.prim_gbuffer_d1.curr().bind_readable(),
                &buffers.prim_gbuffer_d0.prev().bind_readable(),
                &buffers.prim_gbuffer_d1.prev().bind_readable(),
                &buffers.reprojection_map.bind_readable(),
                &buffers.gi_reservoirs[2].bind_readable(),
                &buffers.gi_reservoirs[1].bind_writable(),
            ])
            .build(device, &engine.shaders.gi_temporal_resampling);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        self.pass.run(camera, encoder, size, camera.pass_params());
    }
}

```

`strolle/src/camera_controller/passes/prim_raster.rs`:

```rs
use std::mem;
use std::ops::Range;

use glam::vec4;
use log::debug;

use crate::{
    gpu, BindGroup, Camera, CameraBuffers, CameraController, Engine, Params,
};

#[derive(Debug)]
pub struct PrimRasterPass {
    bg0: BindGroup,
    bg1: BindGroup,
    pipeline: wgpu::RenderPipeline,
}

impl PrimRasterPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        debug!("Initializing pass: prim_raster");

        let bg0 = BindGroup::builder("prim_raster_bg0")
            .add(&engine.materials.bind_readable())
            .add(&engine.images.bind_atlas())
            .build(device);

        let bg1 = BindGroup::builder("prim_raster_bg1")
            .add(&buffers.curr_camera.bind_readable())
            .add(&buffers.prev_camera.bind_readable())
            .build(device);

        let pipeline_layout =
            device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                label: Some("strolle_prim_raster_pipeline_layout"),
                bind_group_layouts: &[bg0.layout(), bg1.layout()],
                push_constant_ranges: &[wgpu::PushConstantRange {
                    stages: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    range: Range {
                        start: 0,
                        end: mem::size_of::<gpu::PrimRasterPassParams>() as u32,
                    },
                }],
            });

        let pipeline =
            device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
                label: Some("strolle_prim_raster_pipeline"),
                layout: Some(&pipeline_layout),
                vertex: wgpu::VertexState {
                    module: &engine.shaders.prim_raster_vs.0,
                    entry_point: engine.shaders.prim_raster_vs.1,
                    buffers: &[wgpu::VertexBufferLayout {
                        array_stride: (3 * 4 * mem::size_of::<f32>()) as _,
                        step_mode: wgpu::VertexStepMode::Vertex,
                        attributes: &[
                            // position (xyz) + uv (x)
                            wgpu::VertexAttribute {
                                offset: 0,
                                shader_location: 0,
                                format: wgpu::VertexFormat::Float32x4,
                            },
                            // normal (xyz) + uv (y)
                            wgpu::VertexAttribute {
                                offset: (4 * mem::size_of::<f32>()) as _,
                                shader_location: 1,
                                format: wgpu::VertexFormat::Float32x4,
                            },
                            // tangent (xyzw)
                            wgpu::VertexAttribute {
                                offset: (8 * mem::size_of::<f32>()) as _,
                                shader_location: 2,
                                format: wgpu::VertexFormat::Float32x4,
                            },
                        ],
                    }],
                },
                primitive: wgpu::PrimitiveState {
                    topology: wgpu::PrimitiveTopology::TriangleList,
                    strip_index_format: None,
                    front_face: wgpu::FrontFace::Ccw,
                    cull_mode: None,
                    polygon_mode: wgpu::PolygonMode::Fill,
                    unclipped_depth: false,
                    conservative: false,
                },
                depth_stencil: Some(wgpu::DepthStencilState {
                    format: wgpu::TextureFormat::Depth32Float,
                    depth_write_enabled: true,
                    depth_compare: wgpu::CompareFunction::GreaterEqual,
                    stencil: wgpu::StencilState::default(),
                    bias: wgpu::DepthBiasState::default(),
                }),
                multisample: wgpu::MultisampleState::default(),
                fragment: Some(wgpu::FragmentState {
                    module: &engine.shaders.prim_raster_fs.0,
                    entry_point: engine.shaders.prim_raster_fs.1,
                    targets: &[
                        Some(wgpu::ColorTargetState {
                            format: wgpu::TextureFormat::Rgba32Float,
                            blend: Some(wgpu::BlendState::REPLACE),
                            write_mask: wgpu::ColorWrites::ALL,
                        }),
                        Some(wgpu::ColorTargetState {
                            format: wgpu::TextureFormat::Rgba32Float,
                            blend: Some(wgpu::BlendState::REPLACE),
                            write_mask: wgpu::ColorWrites::ALL,
                        }),
                        Some(wgpu::ColorTargetState {
                            format: wgpu::TextureFormat::Rgba32Float,
                            blend: Some(wgpu::BlendState::REPLACE),
                            write_mask: wgpu::ColorWrites::ALL,
                        }),
                        Some(wgpu::ColorTargetState {
                            format: wgpu::TextureFormat::Rgba32Float,
                            blend: Some(wgpu::BlendState::REPLACE),
                            write_mask: wgpu::ColorWrites::ALL,
                        }),
                    ],
                }),
                multiview: None,
            });

        Self { bg0, bg1, pipeline }
    }

    pub fn run<P>(
        &self,
        engine: &Engine<P>,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
    ) where
        P: Params,
    {
        let alternate = camera.is_alternate();

        let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("strolle_prim_raster"),
            color_attachments: &[
                Some(wgpu::RenderPassColorAttachment {
                    view: camera.buffers.prim_gbuffer_d0.get(alternate).view(),
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                        store: true,
                    },
                }),
                Some(wgpu::RenderPassColorAttachment {
                    view: camera.buffers.prim_gbuffer_d1.get(alternate).view(),
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                        store: true,
                    },
                }),
                Some(wgpu::RenderPassColorAttachment {
                    view: camera.buffers.prim_surface_map.get(alternate).view(),
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                        store: true,
                    },
                }),
                Some(wgpu::RenderPassColorAttachment {
                    view: camera.buffers.velocity_map.view(),
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                        store: true,
                    },
                }),
            ],
            depth_stencil_attachment: Some(
                wgpu::RenderPassDepthStencilAttachment {
                    view: camera.buffers.prim_depth.view(),
                    depth_ops: Some(wgpu::Operations {
                        load: wgpu::LoadOp::Clear(0.0),
                        store: true,
                    }),
                    stencil_ops: None,
                },
            ),
        });

        pass.set_pipeline(&self.pipeline);
        pass.set_bind_group(0, self.bg0.get(alternate), &[]);
        pass.set_bind_group(1, self.bg1.get(alternate), &[]);

        for (instance_handle, instance_entry) in engine.instances.iter() {
            let instance = &instance_entry.instance;

            let Some(material_id) =
                engine.materials.lookup(instance.material_handle)
            else {
                continue;
            };

            let params = {
                let curr_xform_inv = gpu::PrimRasterPassParams::encode_affine(
                    instance.transform_inverse,
                );

                let prev_xform = gpu::PrimRasterPassParams::encode_affine(
                    instance_entry.prev_transform,
                );

                gpu::PrimRasterPassParams {
                    payload: vec4(
                        f32::from_bits(instance_entry.uuid),
                        f32::from_bits(material_id.get()),
                        Default::default(),
                        Default::default(),
                    ),
                    curr_xform_inv_d0: curr_xform_inv[0],
                    curr_xform_inv_d1: curr_xform_inv[1],
                    curr_xform_inv_d2: curr_xform_inv[2],
                    prev_xform_d0: prev_xform[0],
                    prev_xform_d1: prev_xform[1],
                    prev_xform_d2: prev_xform[2],
                }
            };

            let Some((vertices, vertex_buffer)) =
                engine.triangles.as_vertex_buffer(instance_handle)
            else {
                continue;
            };

            pass.set_vertex_buffer(0, vertex_buffer);

            pass.set_push_constants(
                wgpu::ShaderStages::VERTEX_FRAGMENT,
                0,
                bytemuck::bytes_of(&params),
            );

            pass.draw(0..(vertices as u32), 0..1);
        }
    }
}

```

`strolle/src/camera_controller/passes/ref_shading.rs`:

```rs
use rand::Rng;

use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct RefShadingPass {
    pass: CameraComputePass<gpu::RefPassParams>,
}

impl RefShadingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("ref_shading")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.lights.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.images.bind_atlas(),
                &engine.world.bind_readable(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.prev_camera.bind_readable(),
                &buffers.atmosphere_transmittance_lut.bind_sampled(),
                &buffers.atmosphere_sky_lut.bind_sampled(),
                &buffers.ref_rays.bind_writable(),
                &buffers.ref_hits.bind_readable(),
                &buffers.ref_colors.bind_writable(),
            ])
            .build(device, &engine.shaders.ref_shading);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        depth: u8,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        let params = gpu::RefPassParams {
            seed: rand::thread_rng().gen(),
            frame: camera.frame,
            depth: depth as u32,
        };

        self.pass.run(camera, encoder, size, params);
    }
}

```

`strolle/src/camera_controller/passes/ref_tracing.rs`:

```rs
use rand::Rng;

use crate::{
    gpu, Camera, CameraBuffers, CameraComputePass, CameraController, Engine,
    Params,
};

#[derive(Debug)]
pub struct RefTracingPass {
    pass: CameraComputePass<gpu::RefPassParams>,
}

impl RefTracingPass {
    pub fn new<P>(
        engine: &Engine<P>,
        device: &wgpu::Device,
        _: &Camera,
        buffers: &CameraBuffers,
    ) -> Self
    where
        P: Params,
    {
        let pass = CameraComputePass::builder("ref_tracing")
            .bind([
                &engine.triangles.bind_readable(),
                &engine.bvh.bind_readable(),
                &engine.materials.bind_readable(),
                &engine.images.bind_atlas(),
            ])
            .bind([
                &buffers.curr_camera.bind_readable(),
                &buffers.ref_rays.bind_readable(),
                &buffers.ref_hits.bind_writable(),
            ])
            .build(device, &engine.shaders.ref_tracing);

        Self { pass }
    }

    pub fn run(
        &self,
        camera: &CameraController,
        encoder: &mut wgpu::CommandEncoder,
        depth: u8,
    ) {
        // This pass uses 8x8 warps:
        let size = (camera.camera.viewport.size + 7) / 8;

        let params = gpu::RefPassParams {
            seed: rand::thread_rng().gen(),
            frame: camera.frame,
            depth: depth as u32,
        };

        self.pass.run(camera, encoder, size, params);
    }
}

```

`strolle/src/camera_controllers.rs`:

```rs
use std::collections::HashMap;

use crate::{CameraController, CameraHandle};

#[derive(Debug, Default)]
pub struct CameraControllers {
    cameras: HashMap<CameraHandle, CameraController>,
    next_id: usize,
}

impl CameraControllers {
    pub fn add(&mut self, camera: CameraController) -> CameraHandle {
        let handle = CameraHandle::new(self.next_id);

        self.cameras.insert(handle, camera);
        self.next_id += 1;

        handle
    }

    pub fn get(&self, camera_handle: CameraHandle) -> &CameraController {
        self.cameras.get(&camera_handle).unwrap_or_else(|| {
            panic!("camera does not exist: {:?}", camera_handle)
        })
    }

    pub fn get_mut(
        &mut self,
        camera_handle: CameraHandle,
    ) -> &mut CameraController {
        self.cameras.get_mut(&camera_handle).unwrap_or_else(|| {
            panic!("camera does not exist: {:?}", camera_handle)
        })
    }

    pub fn iter_mut(
        &mut self,
    ) -> impl Iterator<Item = &mut CameraController> + '_ {
        self.cameras.values_mut()
    }

    pub fn remove(&mut self, camera_handle: CameraHandle) {
        self.cameras.remove(&camera_handle);
    }
}

```

`strolle/src/image.rs`:

```rs
use crate::Params;

#[derive(Debug)]
pub struct Image<P>
where
    P: Params,
{
    pub(crate) data: ImageData<P>,
    pub(crate) texture_descriptor: wgpu::TextureDescriptor<'static>,

    // TODO propagate sampler's addressing modes to the shader so that we know
    //      whether the texture should be repeated, etc.
    pub(crate) _sampler_descriptor: wgpu::SamplerDescriptor<'static>,
}

impl<P> Image<P>
where
    P: Params,
{
    pub fn new(
        data: ImageData<P>,
        texture_descriptor: wgpu::TextureDescriptor<'static>,
        sampler_descriptor: wgpu::SamplerDescriptor<'static>,
    ) -> Self {
        assert_eq!(texture_descriptor.dimension, wgpu::TextureDimension::D2);

        Self {
            data,
            texture_descriptor,
            _sampler_descriptor: sampler_descriptor,
        }
    }
}

#[derive(Debug)]
pub enum ImageData<P>
where
    P: Params,
{
    Raw {
        data: Vec<u8>,
    },
    Texture {
        texture: P::ImageTexture,
        is_dynamic: bool,
    },
}

```

`strolle/src/images.rs`:

```rs
use std::collections::HashMap;
use std::mem;

use derivative::Derivative;
use glam::{uvec2, vec4, Vec4};
use guillotiere::{size2, Allocation, AtlasAllocator};
use log::warn;

use crate::{Bindable, Image, ImageData, Params, Texture};

#[derive(Derivative)]
#[derivative(Debug)]
pub struct Images<P>
where
    P: Params,
{
    #[derivative(Debug = "ignore")]
    atlas: AtlasAllocator,
    atlas_texture: Texture,
    atlas_changes: Vec<AtlasChange<P>>,
    images: HashMap<P::ImageHandle, Allocation>,
    dynamic_textures: Vec<(P::ImageTexture, Allocation)>,
}

impl<P> Images<P>
where
    P: Params,
{
    const ATLAS_WIDTH: u32 = 8192;
    const ATLAS_HEIGHT: u32 = 8192;

    pub fn new(device: &wgpu::Device) -> Self {
        let atlas = AtlasAllocator::new(size2(
            Self::ATLAS_WIDTH as i32,
            Self::ATLAS_HEIGHT as i32,
        ));

        let atlas_texture = Texture::builder("atlas")
            .with_size(uvec2(Self::ATLAS_WIDTH, Self::ATLAS_HEIGHT))
            .with_format(wgpu::TextureFormat::Rgba8UnormSrgb)
            .with_usage(wgpu::TextureUsages::TEXTURE_BINDING)
            .with_usage(wgpu::TextureUsages::COPY_DST)
            .build(device);

        Self {
            atlas,
            atlas_texture,
            atlas_changes: Default::default(),
            images: Default::default(),
            dynamic_textures: Default::default(),
        }
    }

    pub fn insert(&mut self, handle: P::ImageHandle, item: Image<P>) {
        let size = size2(
            item.texture_descriptor.size.width as i32,
            item.texture_descriptor.size.height as i32,
        );

        let alloc = if let Some(alloc) = self.images.get(&handle) {
            if size == alloc.rectangle.size() {
                Some(*alloc)
            } else {
                self.atlas.deallocate(alloc.id);
                self.atlas.allocate(size)
            }
        } else {
            self.atlas.allocate(size)
        };

        let Some(alloc) = alloc else {
            // TODO allocate new atlas, up to 16 (Metal's limit)
            warn!(
                "Cannot add image `{:?}` - no more space in the atlas",
                handle
            );

            return;
        };

        self.images.insert(handle, alloc);

        match item.data {
            data @ (ImageData::Raw { .. }
            | ImageData::Texture {
                is_dynamic: false, ..
            }) => {
                self.atlas_changes.push(AtlasChange::Set {
                    x: alloc.rectangle.min.x as u32,
                    y: alloc.rectangle.min.y as u32,
                    w: alloc.rectangle.width() as u32,
                    h: alloc.rectangle.height() as u32,
                    data,
                });
            }

            ImageData::Texture {
                texture,
                is_dynamic: true,
            } => {
                self.dynamic_textures.push((texture, alloc));
            }
        }
    }

    pub fn remove(&mut self, handle: P::ImageHandle) {
        let Some(alloc) = self.images.remove(&handle) else {
            return;
        };

        self.atlas.deallocate(alloc.id);
    }

    pub fn lookup(&self, handle: P::ImageHandle) -> Option<Vec4> {
        self.images.get(&handle).map(|alloc| {
            vec4(
                alloc.rectangle.min.x as f32 / (Self::ATLAS_WIDTH as f32),
                alloc.rectangle.min.y as f32 / (Self::ATLAS_HEIGHT as f32),
                alloc.rectangle.width() as f32 / (Self::ATLAS_WIDTH as f32),
                alloc.rectangle.height() as f32 / (Self::ATLAS_HEIGHT as f32),
            )
        })
    }

    pub fn lookup_opt(&self, handle: Option<P::ImageHandle>) -> Option<Vec4> {
        self.lookup(handle?)
    }

    pub fn flush(&mut self, device: &wgpu::Device, queue: &wgpu::Queue) {
        let mut encoder = None;

        for change in mem::take(&mut self.atlas_changes) {
            match change {
                AtlasChange::Set { x, y, w, h, data } => {
                    let size = wgpu::Extent3d {
                        width: w,
                        height: h,
                        depth_or_array_layers: 1,
                    };

                    match data {
                        ImageData::Raw { data } => {
                            queue.write_texture(
                                wgpu::ImageCopyTexture {
                                    texture: self.atlas_texture.tex(),
                                    mip_level: 0,
                                    origin: wgpu::Origin3d { x, y, z: 0 },
                                    aspect: wgpu::TextureAspect::All,
                                },
                                &data,
                                wgpu::ImageDataLayout {
                                    offset: 0,
                                    bytes_per_row: Some(w * 4),
                                    rows_per_image: None,
                                },
                                wgpu::Extent3d {
                                    width: w,
                                    height: h,
                                    depth_or_array_layers: 1,
                                },
                            );
                        }

                        ImageData::Texture { texture, .. } => {
                            let encoder = encoder.get_or_insert_with(|| {
                                device.create_command_encoder(
                                    &wgpu::CommandEncoderDescriptor {
                                        label: Some("strolle_atlas"),
                                    },
                                )
                            });

                            encoder.copy_texture_to_texture(
                                texture.as_image_copy(),
                                wgpu::ImageCopyTexture {
                                    texture: self.atlas_texture.tex(),
                                    mip_level: 0,
                                    origin: wgpu::Origin3d { x, y, z: 0 },
                                    aspect: wgpu::TextureAspect::All,
                                },
                                size,
                            );
                        }
                    }
                }
            }
        }

        for (tex, alloc) in &self.dynamic_textures {
            let encoder = encoder.get_or_insert_with(|| {
                device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
                    label: Some("strolle_atlas"),
                })
            });

            encoder.copy_texture_to_texture(
                tex.as_image_copy(),
                wgpu::ImageCopyTexture {
                    texture: self.atlas_texture.tex(),
                    mip_level: 0,
                    origin: wgpu::Origin3d {
                        x: alloc.rectangle.min.x as u32,
                        y: alloc.rectangle.min.y as u32,
                        z: 0,
                    },
                    aspect: wgpu::TextureAspect::All,
                },
                wgpu::Extent3d {
                    width: alloc.rectangle.size().width as u32,
                    height: alloc.rectangle.size().height as u32,
                    depth_or_array_layers: 1,
                },
            )
        }

        if let Some(encoder) = encoder {
            queue.submit([encoder.finish()]);
        }
    }

    pub fn bind_atlas(&self) -> impl Bindable + '_ {
        self.atlas_texture.bind_sampled()
    }
}

#[derive(Derivative)]
#[derivative(Debug)]
enum AtlasChange<P>
where
    P: Params,
{
    Set {
        x: u32,
        y: u32,
        w: u32,
        h: u32,

        #[derivative(Debug = "ignore")]
        data: ImageData<P>,
    },
}

```

`strolle/src/instance.rs`:

```rs
use glam::Affine3A;

use crate::Params;

#[derive(Debug)]
pub struct Instance<P>
where
    P: Params,
{
    pub(crate) mesh_handle: P::MeshHandle,
    pub(crate) material_handle: P::MaterialHandle,
    pub(crate) transform: Affine3A,
    pub(crate) transform_inverse: Affine3A,
}

impl<P> Instance<P>
where
    P: Params,
{
    pub fn new(
        mesh_handle: P::MeshHandle,
        material_handle: P::MaterialHandle,
        transform: Affine3A,
    ) -> Self {
        Self {
            mesh_handle,
            material_handle,
            transform,
            transform_inverse: transform.inverse(),
        }
    }
}

```

`strolle/src/instances.rs`:

```rs
use std::collections::hash_map::Entry;
use std::collections::HashMap;
use std::mem;

use derivative::Derivative;
use glam::Affine3A;
use rand::Rng;

use crate::bvh::Bvh;
use crate::materials::Materials;
use crate::meshes::Meshes;
use crate::triangles::Triangles;
use crate::{Instance, Params};

#[derive(Debug, Derivative)]
#[derivative(Default(bound = ""))]
pub struct Instances<P>
where
    P: Params,
{
    instances: HashMap<P::InstanceHandle, InstanceEntry<P>>,
    dirty: bool,
}

impl<P> Instances<P>
where
    P: Params,
{
    pub fn insert(&mut self, handle: P::InstanceHandle, item: Instance<P>) {
        match self.instances.entry(handle) {
            Entry::Occupied(mut entry) => {
                let entry = entry.get_mut();

                entry.prev_transform = entry.instance.transform;
                entry.instance = item;
                entry.dirty = true;
            }

            Entry::Vacant(entry) => {
                entry.insert(InstanceEntry {
                    prev_transform: item.transform,
                    uuid: rand::thread_rng().gen(),
                    dirty: true,
                    instance: item,
                });
            }
        }

        self.dirty = true;
    }

    pub fn iter(
        &self,
    ) -> impl Iterator<Item = (P::InstanceHandle, &InstanceEntry<P>)> + Clone + '_
    {
        self.instances
            .iter()
            .map(|(handle, entry)| (*handle, entry))
    }

    pub fn remove(&mut self, handle: P::InstanceHandle) {
        self.dirty |= self.instances.remove(&handle).is_some();
    }

    pub fn is_empty(&self) -> bool {
        self.instances.is_empty()
    }

    pub fn refresh(
        &mut self,
        meshes: &Meshes<P>,
        materials: &Materials<P>,
        triangles: &mut Triangles<P>,
        bvh: &mut Bvh,
    ) -> bool {
        if !mem::take(&mut self.dirty) {
            return false;
        }

        for (&instance_handle, entry) in &mut self.instances {
            if !mem::take(&mut entry.dirty) {
                continue;
            }

            let Some(mesh) = meshes.get(entry.instance.mesh_handle) else {
                // If the mesh is not yet available, it might be still being
                // loaded in the background - in that case let's try again next
                // frame
                entry.dirty = true;
                self.dirty = true;
                continue;
            };

            let Some(material_id) =
                materials.lookup(entry.instance.material_handle)
            else {
                // Same for materials
                entry.dirty = true;
                self.dirty = true;
                continue;
            };

            let mesh_triangles = mesh.triangles().iter().map(|triangle| {
                triangle.build(
                    entry.instance.transform,
                    entry.instance.transform_inverse,
                )
            });

            if let Some(count) = triangles.count(instance_handle) {
                if mesh.triangles().len() == count {
                    triangles.update(
                        bvh,
                        instance_handle,
                        mesh_triangles,
                        material_id,
                    );
                } else {
                    triangles.remove(bvh, instance_handle);

                    triangles.create(
                        bvh,
                        instance_handle.to_owned(),
                        mesh_triangles,
                        material_id,
                    );
                }
            } else {
                triangles.create(
                    bvh,
                    instance_handle.to_owned(),
                    mesh_triangles,
                    material_id,
                );
            }
        }

        true
    }
}

#[derive(Debug)]
pub struct InstanceEntry<P>
where
    P: Params,
{
    pub instance: Instance<P>,
    pub uuid: u32,
    pub prev_transform: Affine3A,
    pub dirty: bool,
}

```

`strolle/src/lib.rs`:

```rs
//! Strolle, an experimental real-time renderer that supports global
//! illumination.
//!
//! # Usage
//!
//! If you're using Bevy, please take a look at the `bevy-strolle` crate that
//! provides an integration with Bevy.
//!
//! It's also possible to uses Strolle outside of Bevy, as the low-level
//! interface requires only `wgpu` - there is no tutorial for that just yet,
//! though.
//!
//! # Definitions
//!
//! ## Mesh
//!
//! Mesh defines the structure of an object; it contains triangles, but without
//! any information about the materials.
//!
//! Meshes together with materials create instances.
//!
//! ## Material
//!
//! Material determines how an object should look like - its color, whether it
//! should be transparent or not etc.
//!
//! Materials together with meshes create instances.
//!
//! ## Image
//!
//! Image can be used to enhance material's properties, e.g. to make its diffuse
//! color more interesting.
//!
//! Note that normal maps are also classified as images.
//!
//! ## Instance
//!
//! Instance defines a single object as visible in the world-space; mesh +
//! material + transformation matrix create a single instance.
//!
//! ## Light
//!
//! Light defines how the scene should get lightened - i.e. whether it's a
//! point-light, a cone-light etc.

#![feature(hash_raw_entry)]

mod buffers;
mod bvh;
mod camera;
mod camera_controller;
mod camera_controllers;
mod image;
mod images;
mod instance;
mod instances;
mod light;
mod lights;
mod material;
mod materials;
mod mesh;
mod mesh_triangle;
mod meshes;
mod noise;
mod shaders;
mod sun;
mod triangle;
mod triangles;
mod utils;

use std::fmt::Debug;
use std::hash::Hash;
use std::ops::Deref;
use std::time::Instant;
use std::{env, mem};

pub use glam;
use log::{info, trace};
use strolle_gpu as gpu;

pub(crate) use self::buffers::*;
pub(crate) use self::bvh::*;
pub use self::camera::*;
pub(crate) use self::camera_controller::*;
pub(crate) use self::camera_controllers::*;
pub use self::image::*;
pub(crate) use self::images::*;
pub use self::instance::*;
pub(crate) use self::instances::*;
pub use self::light::*;
pub(crate) use self::lights::*;
pub use self::material::*;
pub(crate) use self::materials::*;
pub use self::mesh::*;
pub use self::mesh_triangle::*;
pub(crate) use self::meshes::*;
pub(crate) use self::noise::*;
pub(crate) use self::shaders::*;
pub use self::sun::*;
pub(crate) use self::triangle::*;
pub(crate) use self::triangles::*;
pub(crate) use self::utils::*;

#[derive(Debug)]
pub struct Engine<P>
where
    P: Params,
{
    shaders: Shaders,
    noise: Noise,
    meshes: Meshes<P>,
    instances: Instances<P>,
    triangles: Triangles<P>,
    bvh: Bvh,
    lights: Lights<P>,
    images: Images<P>,
    materials: Materials<P>,
    world: MappedUniformBuffer<gpu::World>,
    cameras: CameraControllers,
    sun: Sun,
    frame: gpu::Frame,
    has_dirty_materials: bool,
    has_dirty_images: bool,
    has_dirty_sun: bool,
    print_stats: bool,
}

impl<P> Engine<P>
where
    P: Params,
{
    pub fn new(device: &wgpu::Device) -> Self {
        info!("Initializing");

        Self {
            shaders: Shaders::new(device),
            noise: Noise::new(device),
            meshes: Meshes::default(),
            instances: Instances::default(),
            triangles: Triangles::new(device),
            bvh: Bvh::new(device),
            lights: Lights::new(device),
            images: Images::new(device),
            materials: Materials::new(device),
            world: MappedUniformBuffer::new(
                device,
                "world",
                Default::default(),
            ),
            cameras: Default::default(),
            sun: Default::default(),
            frame: gpu::Frame::new(1),
            has_dirty_materials: false,
            has_dirty_images: false,
            has_dirty_sun: true,
            print_stats: env::var("STROLLE_STATS").as_deref() == Ok("1"),
        }
    }

    /// Creates or updates a mesh.
    pub fn insert_mesh(&mut self, handle: P::MeshHandle, item: Mesh) {
        self.meshes.insert(handle, item);
    }

    /// Removes a mesh.
    ///
    /// Note that removing a mesh doesn't automatically remove instances that
    /// refer to this mesh.
    pub fn remove_mesh(&mut self, handle: P::MeshHandle) {
        self.meshes.remove(handle);
    }

    /// Creates or updates a material.
    pub fn insert_material(
        &mut self,
        handle: P::MaterialHandle,
        item: Material<P>,
    ) {
        self.materials.insert(handle, item);
        self.has_dirty_materials = true;
    }

    /// Returns whether given material exists.
    pub fn has_material(&self, handle: P::MaterialHandle) -> bool {
        self.materials.has(handle)
    }

    /// Removes a material.
    ///
    /// Note that removing a material doesn't automatically remove instances
    /// that refer to this material.
    pub fn remove_material(&mut self, handle: P::MaterialHandle) {
        self.materials.remove(handle);
        self.has_dirty_materials = true;
    }

    /// Creates or updates an image.
    pub fn insert_image(
        &mut self,
        image_handle: P::ImageHandle,
        image: Image<P>,
    ) {
        self.images.insert(image_handle, image);
        self.has_dirty_images = true;
    }

    /// Removes an image.
    ///
    /// Note that removing an image doesn't automatically remove materials that
    /// refer to this image.
    pub fn remove_image(&mut self, handle: P::ImageHandle) {
        self.images.remove(handle);
        self.has_dirty_images = true;
    }

    /// Creates or updates an instance.
    pub fn insert_instance(
        &mut self,
        instance_handle: P::InstanceHandle,
        instance: Instance<P>,
    ) {
        self.instances.insert(instance_handle, instance);
    }

    /// Removes an instance.
    pub fn remove_instance(&mut self, handle: P::InstanceHandle) {
        self.instances.remove(handle);
        self.triangles.remove(&mut self.bvh, handle);
    }

    /// Creates or updates a light.
    pub fn insert_light(&mut self, handle: P::LightHandle, item: Light) {
        self.lights.insert(handle, item);
    }

    /// Removes a light.
    pub fn remove_light(&mut self, handle: P::LightHandle) {
        self.lights.remove(handle);
    }

    /// Updates sun's parameters.
    pub fn update_sun(&mut self, sun: Sun) {
        self.sun = sun;
        self.has_dirty_sun = true;
    }

    /// Creates a new camera that can be used to render the world.
    ///
    /// Note that this is a pretty heavy operation that allocates per-camera
    /// buffers etc., and so it's expected that you only call this function when
    /// necessary (not, say, each frame).
    pub fn create_camera(
        &mut self,
        device: &wgpu::Device,
        camera: Camera,
    ) -> CameraHandle {
        self.cameras
            .add(CameraController::new(self, device, camera))
    }

    /// Updates camera, changing its mode, position, size etc.
    pub fn update_camera(
        &mut self,
        device: &wgpu::Device,
        handle: CameraHandle,
        camera: Camera,
    ) {
        let mut cameras = mem::take(&mut self.cameras);

        cameras.get_mut(handle).update(self, device, camera);

        self.cameras = cameras;
    }

    /// Renders camera to texture.
    ///
    /// Note that `view`'s texture format must be the same as the format given
    /// to [`Self::create_camera()`].
    pub fn render_camera(
        &self,
        handle: CameraHandle,
        encoder: &mut wgpu::CommandEncoder,
        view: &wgpu::TextureView,
    ) {
        self.cameras.get(handle).render(self, encoder, view);
    }

    /// Deletes a camera.
    ///
    /// After this function is called, updating or rendering this camera will
    /// panic.
    pub fn delete_camera(&mut self, handle: CameraHandle) {
        self.cameras.remove(handle);
    }

    /// Sends all changes to the GPU and prepares it for the upcoming frame.
    ///
    /// This function must be called before invoking [`Self::render_camera()`]
    /// (if you have multiple cameras, calling this function just once is
    /// enough.)
    pub fn tick(&mut self, device: &wgpu::Device, queue: &wgpu::Queue) {
        let tt = Instant::now();
        let any_material_modified = mem::take(&mut self.has_dirty_materials);
        let any_image_modified = mem::take(&mut self.has_dirty_images);

        utils::measure("tick.noise", || {
            self.noise.flush(queue);
        });

        utils::measure("tick.images", || {
            self.images.flush(device, queue);
        });

        if any_material_modified || any_image_modified {
            utils::measure("tick.materials", || {
                self.materials.refresh(&self.images);
            });
        }

        // ---

        let any_instance_changed = utils::measure("tick.instances", || {
            self.instances.refresh(
                &self.meshes,
                &self.materials,
                &mut self.triangles,
                &mut self.bvh,
            )
        });

        if any_instance_changed {
            utils::measure("tick.bvh", || {
                self.bvh.refresh(&self.materials);
            });
        }

        // ---

        *self.world = gpu::World {
            light_count: self.lights.len(),
            sun_azimuth: self.sun.azimuth,
            sun_altitude: self.sun.altitude,
        };

        utils::measure("tick.world", || {
            self.world.flush(queue);
        });

        if mem::take(&mut self.has_dirty_sun) {
            self.lights.update_sun(*self.world);
        }

        let any_buffer_reallocated = utils::measure("tick.buffers", || {
            false
                | self.bvh.flush(device, queue).reallocated
                | self.triangles.flush(device, queue).reallocated
                | self.lights.flush(device, queue).reallocated
                | self.materials.flush(device, queue).reallocated
        });

        // ---

        if any_buffer_reallocated {
            let mut cameras = mem::take(&mut self.cameras);

            for camera in cameras.iter_mut() {
                camera.invalidate(self, device);
            }

            self.cameras = cameras;
        }

        utils::measure("tick.cameras", || {
            for camera in self.cameras.iter_mut() {
                camera.flush(self.frame, queue);
            }
        });

        self.frame = gpu::Frame::new(self.frame.get() + 1);

        // ---

        utils::metric("tick", tt);

        if self.print_stats {
            trace!(
                "meshes={} | triangles={} | nodes={} | materials={} | lights = {}",
                self.meshes.len(),
                self.triangles.len(),
                self.bvh.len(),
                self.materials.len(),
                self.lights.len(),
            );
        }
    }
}

/// Parameters used by Strolle to index textures, meshes etc.
///
/// This exists to faciliate integrations with existing systems, such as Bevy,
/// that already have their own newtypes for images, instances and so on.
pub trait Params {
    type ImageHandle: Clone + Copy + Debug + Eq + Hash;
    type ImageTexture: Debug + Deref<Target = wgpu::Texture>;
    type InstanceHandle: Clone + Copy + Debug + Eq + Hash;
    type LightHandle: Clone + Copy + Debug + Eq + Hash;
    type MaterialHandle: Clone + Copy + Debug + Eq + Hash;
    type MeshHandle: Clone + Copy + Debug + Eq + Hash;
}

```

`strolle/src/light.rs`:

```rs
use glam::{vec4, Vec3};

use crate::gpu;

#[derive(Clone, Debug)]
pub enum Light {
    Point {
        position: Vec3,
        radius: f32,
        color: Vec3,
        range: f32,
    },

    Spot {
        position: Vec3,
        radius: f32,
        color: Vec3,
        range: f32,
        direction: Vec3,
        angle: f32,
    },
}

impl Light {
    pub(crate) fn serialize(&self) -> gpu::Light {
        let d0;
        let d1;
        let d2;

        match self {
            Light::Point {
                position,
                radius,
                color,
                range,
            } => {
                d0 = position.extend(*radius);
                d1 = color.extend(*range);

                d2 = vec4(
                    f32::from_bits(gpu::Light::TYPE_POINT),
                    Default::default(),
                    Default::default(),
                    Default::default(),
                );
            }

            Light::Spot {
                position,
                radius,
                color,
                range,
                direction,
                angle,
            } => {
                let direction = gpu::Normal::encode(*direction);

                d0 = position.extend(*radius);
                d1 = color.extend(*range);

                d2 = vec4(
                    f32::from_bits(gpu::Light::TYPE_SPOT),
                    direction.x,
                    direction.y,
                    *angle,
                );
            }
        }

        gpu::Light {
            d0,
            d1,
            d2,
            d3: Default::default(),
            prev_d0: Default::default(),
            prev_d1: Default::default(),
            prev_d2: Default::default(),
        }
    }
}

```

`strolle/src/lights.rs`:

```rs
use std::collections::hash_map::Entry;
use std::collections::{HashMap, HashSet};
use std::fmt::Debug;

use derivative::Derivative;

use crate::{
    gpu, Bindable, BufferFlushOutcome, Light, MappedStorageBuffer, Params,
};

#[derive(Debug)]
pub struct Lights<P>
where
    P: Params,
{
    buffer: MappedStorageBuffer<Vec<gpu::Light>>,
    index: HashMap<LightHandle<P>, gpu::LightId>,
    created: HashSet<LightHandle<P>>,
    updated: HashSet<LightHandle<P>>,
    remapped: HashMap<LightHandle<P>, gpu::LightId>,
    killed: HashSet<gpu::LightId>,
    next_light_id: gpu::LightId,
}

impl<P> Lights<P>
where
    P: Params,
{
    pub fn new(device: &wgpu::Device) -> Self {
        let mut buffer =
            MappedStorageBuffer::<Vec<_>>::new_default(device, "stolle_lights");

        buffer.push(gpu::Light::sun(Default::default(), Default::default()));

        // ---

        let mut index = HashMap::new();

        index.insert(LightHandle::Sun, gpu::LightId::new(0));

        // ---

        Self {
            buffer,
            index,
            created: Default::default(),
            updated: Default::default(),
            remapped: Default::default(),
            killed: Default::default(),
            next_light_id: gpu::LightId::new(1),
        }
    }

    pub fn insert(&mut self, handle: P::LightHandle, item: Light) {
        let item = item.serialize();
        let handle = LightHandle::Light(handle);

        match self.index.entry(handle) {
            Entry::Occupied(entry) => {
                let id = *entry.get();

                self.update(id.get() as usize, handle, item);
            }

            Entry::Vacant(entry) => {
                if let Some(slot) =
                    self.buffer.get_mut(self.next_light_id.get() as usize)
                {
                    *slot = item;
                    entry.insert(self.next_light_id);
                } else {
                    let id = gpu::LightId::new(self.buffer.len() as u32);

                    self.buffer.push(item);
                    entry.insert(id);
                }

                self.created.insert(handle);
                *self.next_light_id.get_mut() += 1;
            }
        }
    }

    pub fn update_sun(&mut self, world: gpu::World) {
        let color =
            strolle_shaders::atmosphere::generate_transmittance_lut::eval(
                gpu::Atmosphere::VIEW_POS,
                world.sun_dir(),
            );

        // TODO probably incorrect
        let color = color * gpu::Atmosphere::EXPOSURE * 5.0;

        self.update(
            0,
            LightHandle::Sun,
            gpu::Light::sun(world.sun_pos(), color),
        );
    }

    pub fn remove(&mut self, handle: P::LightHandle) {
        let handle = LightHandle::Light(handle);

        let Some(id) = self.index.remove(&handle) else {
            return;
        };

        let idx = id.get() as usize;

        self.buffer.remove(idx);
        self.buffer.push(Default::default());

        self.created.remove(&handle);
        self.updated.remove(&handle);
        self.remapped.remove(&handle);
        self.killed.insert(id);

        *self.next_light_id.get_mut() -= 1;

        for (other_handle, other_id) in self.index.iter_mut() {
            if other_id.get() > id.get() {
                self.remapped.entry(*other_handle).or_insert(*other_id);

                *other_id.get_mut() -= 1;
            }
        }
    }

    pub fn len(&self) -> u32 {
        self.next_light_id.get()
    }

    pub fn flush(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> BufferFlushOutcome {
        for id in &self.killed {
            self.buffer[id.get() as usize].kill_slot();
        }

        for (handle, id) in &self.remapped {
            self.buffer[id.get() as usize].remap_slot(self.index[&handle]);
        }

        let outcome = self.buffer.flush(device, queue);

        for handle in self.created.iter().chain(&self.updated) {
            self.buffer[self.index[handle].get() as usize].commit();
        }

        for id in self.killed.iter().chain(self.remapped.values()) {
            self.buffer[id.get() as usize].clear_slot();
        }

        self.created.clear();
        self.updated.clear();
        self.remapped.clear();
        self.killed.clear();

        outcome
    }

    pub fn bind_readable(&self) -> impl Bindable + '_ {
        self.buffer.bind_readable()
    }

    fn update(
        &mut self,
        idx: usize,
        handle: LightHandle<P>,
        mut new: gpu::Light,
    ) {
        let old = self.buffer[idx];

        new.prev_d0 = old.d0;
        new.prev_d1 = old.d1;
        new.prev_d2 = old.d2;

        self.updated.insert(handle);
        self.buffer[idx] = new;
    }
}

// TODO sun should be handled outside of Strolle, there's no reason to
//      special-case it here
#[derive(Debug, Derivative)]
#[derivative(Clone, Copy, PartialEq, Eq, Hash)]
enum LightHandle<P>
where
    P: Params,
{
    Sun,
    Light(P::LightHandle),
}

```

`strolle/src/material.rs`:

```rs
use std::fmt::Debug;

use spirv_std::glam::{vec4, Vec4};

use crate::{gpu, Images, Params};

#[derive(Clone, Debug)]
pub struct Material<P>
where
    P: Params,
{
    pub base_color: Vec4,
    pub base_color_texture: Option<P::ImageHandle>,
    pub emissive: Vec4,
    pub emissive_texture: Option<P::ImageHandle>,
    pub perceptual_roughness: f32,
    pub metallic: f32,
    pub metallic_roughness_texture: Option<P::ImageHandle>,
    pub reflectance: f32,
    pub ior: f32,
    pub normal_map_texture: Option<P::ImageHandle>,
    pub alpha_mode: AlphaMode,
}

impl<P> Material<P>
where
    P: Params,
{
    pub(crate) fn serialize(&self, images: &Images<P>) -> gpu::Material {
        gpu::Material {
            base_color: self.base_color,
            base_color_texture: images
                .lookup_opt(self.base_color_texture)
                .unwrap_or_default(),
            emissive: self.emissive,
            emissive_texture: images
                .lookup_opt(self.emissive_texture)
                .unwrap_or_default(),
            roughness: self.perceptual_roughness.powf(2.0),
            metallic: self.metallic,
            metallic_roughness_texture: images
                .lookup_opt(self.metallic_roughness_texture)
                .unwrap_or_default(),
            reflectance: self.reflectance,
            ior: self.ior,
            normal_map_texture: images
                .lookup_opt(self.normal_map_texture)
                .unwrap_or_default(),
        }
    }
}

impl<P> Default for Material<P>
where
    P: Params,
{
    fn default() -> Self {
        Self {
            base_color: vec4(1.0, 1.0, 1.0, 1.0),
            base_color_texture: None,
            emissive: Vec4::ZERO,
            emissive_texture: None,
            perceptual_roughness: 0.5,
            metallic: 0.0,
            metallic_roughness_texture: None,
            reflectance: 0.5,
            ior: 1.0,
            normal_map_texture: None,
            alpha_mode: Default::default(),
        }
    }
}

/// Specifies if a material is allowed to be transparent
#[derive(Clone, Copy, Debug, Default)]
pub enum AlphaMode {
    /// Material is always opaque (this is the default).
    ///
    /// When this is active, the base color's alpha is always set to 1.0.
    #[default]
    Opaque,

    /// Material is allowed to be transparent (i.e. base color's and base color
    /// texture's alpha channel is honored).
    ///
    /// Note that enabling this option has negative effects on ray-tracing
    /// performance (non-opaque materials need special handling during the ray
    /// traversal process), so this option should be enabled conservatively,
    /// only for materials that actually use transparency.
    Blend,
}

```

`strolle/src/materials.rs`:

```rs
use std::collections::hash_map::Entry;
use std::collections::HashMap;
use std::fmt::Debug;
use std::ops::Index;

use crate::utils::Allocator;
use crate::{
    gpu, Bindable, BufferFlushOutcome, Images, MappedStorageBuffer, Material,
    Params,
};

#[derive(Debug)]
pub struct Materials<P>
where
    P: Params,
{
    allocator: Allocator,
    buffer: MappedStorageBuffer<Vec<gpu::Material>>,
    index: HashMap<P::MaterialHandle, gpu::MaterialId>,
    materials: Vec<Material<P>>,
}

impl<P> Materials<P>
where
    P: Params,
{
    pub fn new(device: &wgpu::Device) -> Self {
        Self {
            allocator: Default::default(),
            buffer: MappedStorageBuffer::new_default(device, "materials"),
            index: Default::default(),
            materials: Default::default(),
        }
    }

    pub fn insert(&mut self, handle: P::MaterialHandle, item: Material<P>) {
        match self.index.entry(handle) {
            Entry::Occupied(entry) => {
                let id = *entry.get();

                self.materials[id.get() as usize] = item;
            }

            Entry::Vacant(entry) => {
                let id = if let Some(alloc) = self.allocator.take(1) {
                    alloc.start
                } else {
                    self.materials.push(item);
                    self.materials.len() - 1
                };

                entry.insert(gpu::MaterialId::new(id as u32));
            }
        }
    }

    pub fn has(&self, handle: P::MaterialHandle) -> bool {
        self.index.contains_key(&handle)
    }

    pub fn remove(&mut self, handle: P::MaterialHandle) {
        let Some(id) = self.index.remove(&handle) else {
            return;
        };

        let id = id.get() as usize;

        self.allocator.give(id..id);
    }

    pub fn len(&self) -> usize {
        self.buffer.len()
    }

    pub fn lookup(&self, handle: P::MaterialHandle) -> Option<gpu::MaterialId> {
        self.index.get(&handle).copied()
    }

    pub fn refresh(&mut self, images: &Images<P>) {
        *self.buffer = self
            .materials
            .iter()
            .map(|material| material.serialize(images))
            .collect();
    }

    pub fn flush(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> BufferFlushOutcome {
        self.buffer.flush(device, queue)
    }

    pub fn bind_readable(&self) -> impl Bindable + '_ {
        self.buffer.bind_readable()
    }
}

impl<P> Index<gpu::MaterialId> for Materials<P>
where
    P: Params,
{
    type Output = Material<P>;

    fn index(&self, index: gpu::MaterialId) -> &Self::Output {
        &self.materials[index.get() as usize]
    }
}

```

`strolle/src/mesh.rs`:

```rs
use crate::MeshTriangle;

#[derive(Clone, Debug)]
pub struct Mesh {
    triangles: Vec<MeshTriangle>,
}

impl Mesh {
    pub fn new(triangles: Vec<MeshTriangle>) -> Self {
        Self { triangles }
    }

    pub(crate) fn triangles(&self) -> &[MeshTriangle] {
        &self.triangles
    }
}

```

`strolle/src/mesh_triangle.rs`:

```rs
use glam::Affine3A;
use spirv_std::glam::{Mat4, Vec2, Vec3, Vec4, Vec4Swizzles};

use crate::Triangle;

#[derive(Clone, Debug, Default)]
pub struct MeshTriangle {
    positions: [Vec3; 3],
    normals: [Vec3; 3],
    uvs: [Vec2; 3],
    tangents: [Vec4; 3],
}

impl MeshTriangle {
    pub fn with_positions(mut self, positions: [impl Into<Vec3>; 3]) -> Self {
        self.positions = positions.map(Into::into);
        self
    }

    pub fn with_normals(mut self, normals: [impl Into<Vec3>; 3]) -> Self {
        self.normals = normals.map(Into::into);
        self
    }

    pub fn with_uvs(mut self, uvs: [impl Into<Vec2>; 3]) -> Self {
        self.uvs = uvs.map(Into::into);
        self
    }

    pub fn with_tangents(mut self, tangents: [impl Into<Vec4>; 3]) -> Self {
        self.tangents = tangents.map(Into::into);
        self
    }

    pub fn positions(&self) -> [Vec3; 3] {
        self.positions
    }

    pub fn normals(&self) -> [Vec3; 3] {
        self.normals
    }

    pub fn uvs(&self) -> [Vec2; 3] {
        self.uvs
    }

    pub(crate) fn build(
        &self,
        xform: Affine3A,
        xform_inv: Affine3A,
    ) -> Triangle {
        let positions =
            self.positions.map(|vertex| xform.transform_point3(vertex));

        let normals = {
            // Transforming normals requires inversing and transposing the
            // matrix in order to get correct results under scaling, see:
            //
            // https://paroj.github.io/gltut/Illumination/Tut09%20Normal%20Transformation.html
            let mat = Mat4::from(xform_inv).transpose();

            self.normals
                .map(|normal| mat.transform_vector3(normal).normalize())
        };

        let tangents = {
            let sign = if xform.matrix3.determinant().is_sign_positive() {
                1.0
            } else {
                -1.0
            };

            self.tangents.map(|tangent| {
                (xform.matrix3 * tangent.xyz())
                    .normalize()
                    .extend(tangent.w * sign)
            })
        };

        Triangle {
            positions,
            normals,
            uvs: self.uvs,
            tangents,
        }
    }
}

```

`strolle/src/meshes.rs`:

```rs
use std::collections::HashMap;

use derivative::Derivative;

use crate::{Mesh, Params};

#[derive(Debug, Derivative)]
#[derivative(Default)]
pub struct Meshes<P>
where
    P: Params,
{
    meshes: HashMap<P::MeshHandle, Mesh>,
}

impl<P> Meshes<P>
where
    P: Params,
{
    pub fn insert(&mut self, handle: P::MeshHandle, item: Mesh) {
        self.meshes.insert(handle, item);
    }

    pub fn get(&self, handle: P::MeshHandle) -> Option<&Mesh> {
        self.meshes.get(&handle)
    }

    pub fn remove(&mut self, handle: P::MeshHandle) {
        self.meshes.remove(&handle);
    }

    pub fn len(&self) -> usize {
        self.meshes.len()
    }
}

```

`strolle/src/noise.rs`:

```rs
use std::io::Cursor;

use image::io::Reader as ImageReader;

use crate::{gpu, Bindable, Texture};

#[derive(Debug)]
pub struct Noise {
    blue_noise: Texture,
    flushed: bool,
}

impl Noise {
    pub fn new(device: &wgpu::Device) -> Self {
        Self {
            blue_noise: Texture::builder("blue_noise")
                .with_size(gpu::BlueNoise::SIZE)
                .with_format(wgpu::TextureFormat::Rgba8Unorm)
                .with_usage(wgpu::TextureUsages::COPY_DST)
                .with_usage(wgpu::TextureUsages::STORAGE_BINDING)
                .build(device),
            flushed: false,
        }
    }

    pub fn bind_blue_noise(&self) -> impl Bindable + '_ {
        self.blue_noise.bind_readable()
    }

    pub fn flush(&mut self, queue: &wgpu::Queue) {
        if self.flushed {
            return;
        }

        let bytes = include_bytes!("../assets/blue-noise.png");

        let img = ImageReader::new(Cursor::new(bytes))
            .with_guessed_format()
            .unwrap()
            .decode()
            .unwrap();

        let img = img.as_rgba8().unwrap().as_raw();

        queue.write_texture(
            wgpu::ImageCopyTexture {
                texture: self.blue_noise.tex(),
                mip_level: 0,
                origin: wgpu::Origin3d { x: 0, y: 0, z: 0 },
                aspect: wgpu::TextureAspect::All,
            },
            img,
            wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: Some(256 * 4),
                rows_per_image: None,
            },
            wgpu::Extent3d {
                width: 256,
                height: 256,
                depth_or_array_layers: 1,
            },
        );

        self.flushed = true;
    }
}

```

`strolle/src/shaders.rs`:

```rs
use log::info;

macro_rules! shaders {
    ([ $( $name:ident, )* ]) => {
        #[derive(Debug)]
        pub struct Shaders {
            $( pub $name: (wgpu::ShaderModule, &'static str), )*
        }

        impl Shaders {
            pub fn new(device: &wgpu::Device) -> Self {
                $(
                    info!("Initializing shader: {}", stringify!($name));

                    let module = wgpu::include_spirv!(
                        env!(concat!("strolle_shaders::", stringify!($name), ".path"))
                    );

                    // Safety: fingers crossed™
                    //
                    // We do our best, but our shaders are so array-intensive
                    // that adding the checks decreases performance by 33%, so
                    // it's pretty much a no-go.
                    let module = unsafe {
                        device.create_shader_module_unchecked(module)
                    };

                    let entry_point = env!(concat!("strolle_shaders::", stringify!($name), ".entry_point"));

                    let $name = (module, entry_point);
                )*

                Self {
                    $($name,)*
                }
            }
        }
    };
}

shaders!([
    atmosphere_generate_scattering_lut,
    atmosphere_generate_sky_lut,
    atmosphere_generate_transmittance_lut,
    bvh_heatmap,
    di_resolving,
    di_sampling,
    di_spatial_resampling_pick,
    di_spatial_resampling_sample,
    di_spatial_resampling_trace,
    di_temporal_resampling,
    frame_composition_fs,
    frame_composition_vs,
    frame_denoising_estimate_variance,
    frame_denoising_reproject,
    frame_denoising_wavelet,
    frame_reprojection,
    gi_preview_resampling,
    gi_reprojection,
    gi_resolving,
    gi_sampling_a,
    gi_sampling_b,
    gi_spatial_resampling_pick,
    gi_spatial_resampling_sample,
    gi_spatial_resampling_trace,
    gi_temporal_resampling,
    prim_raster_fs,
    prim_raster_vs,
    ref_shading,
    ref_tracing,
]);

```

`strolle/src/sun.rs`:

```rs
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Sun {
    pub azimuth: f32,
    pub altitude: f32,
}

impl Default for Sun {
    fn default() -> Self {
        Self {
            azimuth: 0.0,
            altitude: 0.35,
        }
    }
}

```

`strolle/src/triangle.rs`:

```rs
use glam::Vec3Swizzles;
use spirv_std::glam::{Vec2, Vec3, Vec4};

use crate::gpu;
use crate::utils::BoundingBox;

#[derive(Clone, Debug)]
pub struct Triangle {
    pub positions: [Vec3; 3],
    pub normals: [Vec3; 3],
    pub uvs: [Vec2; 3],
    pub tangents: [Vec4; 3],
}

impl Triangle {
    pub fn center(&self) -> Vec3 {
        self.positions.iter().sum::<Vec3>() / 3.0
    }

    pub fn bounds(&self) -> BoundingBox {
        self.positions.iter().copied().collect()
    }

    pub fn serialize(&self) -> gpu::Triangle {
        gpu::Triangle {
            d0: self.positions[0].xyz().extend(self.uvs[0].x),
            d1: self.normals[0].xyz().extend(self.uvs[0].y),
            d2: self.tangents[0],

            d3: self.positions[1].xyz().extend(self.uvs[1].x),
            d4: self.normals[1].xyz().extend(self.uvs[1].y),
            d5: self.tangents[1],

            d6: self.positions[2].xyz().extend(self.uvs[2].x),
            d7: self.normals[2].xyz().extend(self.uvs[2].y),
            d8: self.tangents[2],
        }
    }
}

```

`strolle/src/triangles.rs`:

```rs
use std::collections::HashMap;
use std::fmt::Debug;
use std::mem;
use std::ops::Range;

use crate::bvh::Bvh;
use crate::utils::Allocator;
use crate::{
    gpu, Bindable, BufferFlushOutcome, BvhPrimitive, MappedStorageBuffer,
    Params, Triangle,
};

#[derive(Debug)]
pub struct Triangles<P>
where
    P: Params,
{
    allocator: Allocator,
    buffer: MappedStorageBuffer<Vec<gpu::Triangle>>,
    index: HashMap<P::InstanceHandle, IndexedInstance>,
    dirty: bool,
}

impl<P> Triangles<P>
where
    P: Params,
{
    pub fn new(device: &wgpu::Device) -> Self {
        Self {
            allocator: Default::default(),
            buffer: MappedStorageBuffer::new_default(device, "triangles"),
            index: Default::default(),
            dirty: Default::default(),
        }
    }

    pub fn create(
        &mut self,
        bvh: &mut Bvh,
        instance_handle: P::InstanceHandle,
        triangles: impl Iterator<Item = Triangle> + ExactSizeIterator,
        material_id: gpu::MaterialId,
    ) {
        assert!(
            !self.index.contains_key(&instance_handle),
            "instance {instance_handle:?} has been already added - now it can \
             be only updated or removed"
        );

        assert!(
            triangles.len() > 0,
            "instance {instance_handle:?} contains no triangles"
        );

        let triangle_ids = if let Some(triangle_ids) =
            self.allocator.take(triangles.len())
        {
            self.create_reusing_space(bvh, triangles, material_id, triangle_ids)
        } else {
            self.create_allocating_space(bvh, triangles, material_id)
        };

        self.index.insert(
            instance_handle,
            IndexedInstance {
                triangle_ids,
                dirty: true,
            },
        );

        self.dirty = true;
    }

    fn create_reusing_space(
        &mut self,
        bvh: &mut Bvh,
        triangles: impl Iterator<Item = Triangle>,
        material_id: gpu::MaterialId,
        triangle_ids: Range<usize>,
    ) -> Range<usize> {
        let mut triangle_id = triangle_ids.start;

        let iter = triangles
            .into_iter()
            .zip(&mut self.buffer[triangle_ids.clone()])
            .zip(bvh.update(triangle_ids.clone()));

        for ((triangle, tri), prim) in iter {
            *tri = triangle.serialize();

            *prim = BvhPrimitive {
                triangle_id: gpu::TriangleId::new(triangle_id as u32),
                material_id,
                center: triangle.center(),
                bounds: triangle.bounds(),
            };

            triangle_id += 1;
        }

        triangle_ids
    }

    fn create_allocating_space(
        &mut self,
        bvh: &mut Bvh,
        triangles: impl Iterator<Item = Triangle>,
        material_id: gpu::MaterialId,
    ) -> Range<usize> {
        let first_triangle_id = self.buffer.len();

        for (triangle_idx, triangle) in triangles.enumerate() {
            self.buffer.push(triangle.serialize());

            bvh.add(BvhPrimitive {
                triangle_id: gpu::TriangleId::new(
                    (first_triangle_id + triangle_idx) as u32,
                ),
                material_id,
                center: triangle.center(),
                bounds: triangle.bounds(),
            });
        }

        first_triangle_id..self.buffer.len()
    }

    pub fn update(
        &mut self,
        bvh: &mut Bvh,
        instance_handle: P::InstanceHandle,
        triangles: impl Iterator<Item = Triangle> + ExactSizeIterator,
        material_id: gpu::MaterialId,
    ) {
        let instance =
            self.index.get_mut(&instance_handle).unwrap_or_else(|| {
                panic!("instance not known: {instance_handle:?}")
            });

        let iter = triangles
            .into_iter()
            .zip(&mut self.buffer[instance.triangle_ids.clone()])
            .zip(bvh.update(instance.triangle_ids.clone()));

        for ((triangle, tri), prim) in iter {
            *tri = triangle.serialize();

            prim.material_id = material_id;
            prim.center = triangle.center();
            prim.bounds = triangle.bounds();
        }

        instance.dirty = true;
        self.dirty = true;
    }

    pub fn remove(
        &mut self,
        bvh: &mut Bvh,
        instance_handle: P::InstanceHandle,
    ) {
        let Some(instance) = self.index.remove(&instance_handle) else {
            return;
        };

        self.allocator.give(instance.triangle_ids.clone());

        for prim in bvh.update(instance.triangle_ids) {
            prim.kill();
        }
    }

    pub fn len(&self) -> usize {
        self.buffer.len()
    }

    pub fn count(&self, instance_handle: P::InstanceHandle) -> Option<usize> {
        self.index
            .get(&instance_handle)
            .map(|instance| instance.triangle_ids.len())
    }

    pub fn as_vertex_buffer(
        &self,
        instance_handle: P::InstanceHandle,
    ) -> Option<(usize, wgpu::BufferSlice<'_>)> {
        let IndexedInstance { triangle_ids, .. } =
            self.index.get(&instance_handle)?;

        let vertices = 3 * triangle_ids.len();

        let vertex_buffer = {
            let min = triangle_ids.start * mem::size_of::<gpu::Triangle>();
            let min = min as wgpu::BufferAddress;

            // N.B. we could slice up to some `max`, but GPUs care only about
            // the start of the buffer and the number of vertices
            self.buffer.as_buffer().slice(min..)
        };

        Some((vertices, vertex_buffer))
    }

    pub fn flush(
        &mut self,
        device: &wgpu::Device,
        queue: &wgpu::Queue,
    ) -> BufferFlushOutcome {
        if !mem::take(&mut self.dirty) {
            return BufferFlushOutcome::default();
        }

        let reallocated = self.buffer.reallocate(device, queue);

        if reallocated {
            // Reallocating already flushes the entire buffer, so there's no
            // need to flush it again
        } else {
            for instance in self.index.values_mut() {
                if !mem::take(&mut instance.dirty) {
                    continue;
                }

                let offset = instance.triangle_ids.start
                    * mem::size_of::<gpu::Triangle>();

                let size = instance.triangle_ids.len()
                    * mem::size_of::<gpu::Triangle>();

                self.buffer.flush_part(queue, offset, size);
            }
        }

        BufferFlushOutcome { reallocated }
    }

    pub fn bind_readable(&self) -> impl Bindable + '_ {
        self.buffer.bind_readable()
    }
}

#[derive(Debug)]
struct IndexedInstance {
    triangle_ids: Range<usize>,
    dirty: bool,
}

```

`strolle/src/utils.rs`:

```rs
mod allocator;
mod axis;
mod bounding_box;
mod metrics;

pub use self::allocator::*;
pub use self::axis::*;
pub use self::bounding_box::*;
pub use self::metrics::*;

```

`strolle/src/utils/allocator.rs`:

```rs
use std::mem;
use std::ops::Range;

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct Allocator {
    slots: Vec<Range<usize>>,
    dirty: bool,
}

impl Allocator {
    pub fn give(&mut self, slot: Range<usize>) {
        if let Some(last_slot) = self.slots.last() {
            self.dirty |= slot.start <= last_slot.end;
        }

        self.slots.push(slot);
    }

    pub fn take(&mut self, len: usize) -> Option<Range<usize>> {
        assert!(len > 0);

        self.compact();

        let slot_id = self.slots.iter().position(|slot| slot.len() >= len)?;
        let remaining_slot_size = self.slots[slot_id].len() - len;

        if remaining_slot_size > 0 {
            let slot = &mut self.slots[slot_id];

            slot.start += len;

            Some(Range {
                start: slot.start - len,
                end: slot.start,
            })
        } else {
            Some(self.slots.remove(slot_id))
        }
    }

    fn compact(&mut self) {
        if !mem::take(&mut self.dirty) || self.slots.is_empty() {
            return;
        }

        self.slots.sort_by_key(|slot| slot.start);

        let mut idx = 0;

        while idx < (self.slots.len() - 1) {
            if self.slots[idx].end == self.slots[idx + 1].start {
                self.slots[idx].end = self.slots.remove(idx + 1).end;
            } else {
                idx += 1;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test() {
        let mut target = Allocator::default();

        assert_eq!(None, target.take(16));

        // ---
        // Case 1: Just one range

        target.give(0..32);

        assert_eq!(Some(0..8), target.take(8));
        assert_eq!(Some(8..16), target.take(8));
        assert_eq!(Some(16..24), target.take(8));
        assert_eq!(Some(24..32), target.take(8));
        assert_eq!(None, target.take(8));

        // ---
        // Case 2: Many ranges

        target.give(0..8);
        target.give(10..15);

        assert_eq!(Some(0..4), target.take(4));
        assert_eq!(Some(4..8), target.take(4));
        assert_eq!(Some(10..14), target.take(4));
        assert_eq!(None, target.take(4));
        assert_eq!(Some(14..15), target.take(1));
        assert_eq!(None, target.take(1));

        // ---
        // Case 3a: Compaction

        target.give(0..8);
        target.give(8..16);
        target.give(16..24);
        target.give(24..32);
        target.give(32..40);
        target.give(64..256);

        assert_eq!(Some(64..128), target.take(64));
        assert_eq!(Some(0..20), target.take(20));
        assert_eq!(Some(20..40), target.take(20));
        assert_eq!(Some(128..148), target.take(20));

        // ---
        // Case 3b: Compaction + checking if the `dirty` flag gets set properly

        target = Default::default();

        target.give(64..256);
        target.give(32..40);
        target.give(24..32);
        target.give(16..24);
        target.give(8..16);
        target.give(0..8);

        assert_eq!(Some(64..128), target.take(64));
        assert_eq!(Some(0..20), target.take(20));
        assert_eq!(Some(20..40), target.take(20));
        assert_eq!(Some(128..148), target.take(20));
    }
}

```

`strolle/src/utils/axis.rs`:

```rs
use std::ops::{Index, IndexMut};

use glam::Vec3;

#[derive(Clone, Copy, Debug)]
pub enum Axis {
    X,
    Y,
    Z,
}

impl Axis {
    pub fn all() -> impl Iterator<Item = Self> {
        [Self::X, Self::Y, Self::Z].into_iter()
    }
}

impl From<usize> for Axis {
    fn from(value: usize) -> Self {
        match value {
            0 => Self::X,
            1 => Self::Y,
            2 => Self::Z,
            _ => panic!(),
        }
    }
}

impl Index<Axis> for Vec3 {
    type Output = f32;

    fn index(&self, index: Axis) -> &Self::Output {
        match index {
            Axis::X => &self.x,
            Axis::Y => &self.y,
            Axis::Z => &self.z,
        }
    }
}

impl IndexMut<Axis> for Vec3 {
    fn index_mut(&mut self, index: Axis) -> &mut Self::Output {
        match index {
            Axis::X => &mut self.x,
            Axis::Y => &mut self.y,
            Axis::Z => &mut self.z,
        }
    }
}

```

`strolle/src/utils/bounding_box.rs`:

```rs
use std::ops::{Add, AddAssign};

use spirv_std::glam::Vec3;

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BoundingBox {
    min: Vec3,
    max: Vec3,
}

impl BoundingBox {
    pub fn new(min: Vec3, max: Vec3) -> Self {
        Self { min, max }
    }

    pub fn min(&self) -> Vec3 {
        self.min
    }

    pub fn max(&self) -> Vec3 {
        self.max
    }

    pub fn extent(&self) -> Vec3 {
        self.max() - self.min()
    }

    pub fn half_area(&self) -> f32 {
        let extent = self.extent();

        extent.x * extent.y + extent.y * extent.z + extent.z * extent.x
    }

    pub fn is_set(&self) -> bool {
        self.min.x != Self::default().min.x
    }
}

impl Default for BoundingBox {
    fn default() -> Self {
        Self::new(Vec3::MAX, Vec3::MIN)
    }
}

impl Add<Vec3> for BoundingBox {
    type Output = Self;

    fn add(mut self, rhs: Vec3) -> Self::Output {
        self += rhs;
        self
    }
}

impl AddAssign<Vec3> for BoundingBox {
    fn add_assign(&mut self, rhs: Vec3) {
        self.min = self.min.min(rhs);
        self.max = self.max.max(rhs);
    }
}

impl FromIterator<Vec3> for BoundingBox {
    fn from_iter<T>(iter: T) -> Self
    where
        T: IntoIterator<Item = Vec3>,
    {
        let mut this = Self::default();

        for item in iter {
            this += item;
        }

        this
    }
}

impl Add<Self> for BoundingBox {
    type Output = Self;

    fn add(mut self, rhs: Self) -> Self::Output {
        self += rhs;
        self
    }
}

impl AddAssign<Self> for BoundingBox {
    fn add_assign(&mut self, rhs: Self) {
        *self += rhs.min;
        *self += rhs.max;
    }
}

impl FromIterator<Self> for BoundingBox {
    fn from_iter<T>(iter: T) -> Self
    where
        T: IntoIterator<Item = Self>,
    {
        let mut this = Self::default();

        for item in iter {
            this += item;
        }

        this
    }
}

```

`strolle/src/utils/metrics.rs`:

```rs
use std::time::Instant;

pub fn measure<T>(name: &str, f: impl FnOnce() -> T) -> T {
    let tt = Instant::now();
    let result = f();

    metric(name, tt);

    result
}

#[cfg(feature = "metrics")]
pub fn metric(metric: &str, tt: Instant) {
    use std::env;
    use std::sync::OnceLock;
    use std::time::Duration;

    use log::trace;

    static METRIC_THRESHOLD: OnceLock<Duration> = OnceLock::new();

    let threshold = METRIC_THRESHOLD.get_or_init(|| {
        env::var("STROLLE_METRIC_THRESHOLD")
            .ok()
            .map(|threshold| humantime::parse_duration(&threshold).unwrap())
            .unwrap_or_else(|| Duration::from_millis(0))
    });

    let tt = tt.elapsed();

    if tt > *threshold {
        trace!("metric({metric})={tt:?}");
    }
}

#[cfg(not(feature = "metrics"))]
pub fn metric(_metric: &str, _tt: Instant) {
    //
}

```