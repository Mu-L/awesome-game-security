Project Path: arc_xtremegamer1_xigmapper_nu97gsw_

Source Tree:

```txt
arc_xtremegamer1_xigmapper_nu97gsw_
├── README.md
├── efi driver.default.props
├── efi driver.props
├── efi driver.sln
├── efi driver.vcxproj
├── efi_boilerplate.c
├── hook.c
├── hook.h
├── main.c
├── mmap.c
├── mmap.h
├── ntdef.h
├── util.c
└── util.h

```

`README.md`:

```md
# xigmapper
xigmapper is a driver manual mapper that loads your driver before Vanguard, but after critical system infrastructure has been set up, allowing you to write your bypass without worrying about the intricacies of EFI or the boot process.

# Limitations
xigmapper requires sb off, or for you to manually load the driver's file digest into your tpm (which i don't know how to do). This means that you can only use it against Vanguard on Windows 10, because Windows 11 Vanguard requires sb on, unless you know how to spoof secure boot. 

# Compiling the efi driver
In order to compile the efi driver, you need to clone and build [VisualUefi](https://github.com/ionescu007/VisualUefi), and clone this repo into the same directory that VisualUefi was cloned into. Then, build using Visual Studio.

# Using the driver
In order to use the compiled driver, you must:

Edit the variable g_module_path in hook.c to include the path of the driver that you want to load. The driver you want to load cannot be on a usb device, because usb devices are discovered and loaded by Windows after Vanguard is. 

Then, you must put the compiled .efi driver into a exFAT or FAT32 partitioned drive (usb drives work for this). If you don't have an exFAT or FAT32 partition created, you can use the diskpart utility that comes with Windows to create a new partition on your drive.

Download the [efi shell](https://github.com/tianocore/edk2/blob/edk2-stable201903/ShellBinPkg/UefiShell/X64/Shell.efi), rename it to BOOTX64.efi, and put it into the directory \efi\boot on your FAT partition. 

Then boot to that partition from BIOS, and from the shell navigate to the partition you just booted from (usually fs0:), and load "efi driver.efi". Then load Windows by locating the partition with your Windows installation on it, and then executing "EFI\BOOT\bootmgfw.efi". 

If you did everything right, your driver will be loaded after IoInitSystemPreDrivers (which initializes essential windows OS functionality) and before IopInitializeSystemDrivers (the routine that loads Vanguard and other SYSTEM_START drivers).

# What is this good for?
This mapper should make it more convenient for cheat devs and pasters to bypass Vanguard, by taking away the work that comes with writing an efi driver and dealing with all the associated baggage. Now you just have to write (or paste) a simple Windows kernel driver, and loading it on Vanguard is as simple as editing a string and recompiling. I have tested this myself with a hypervisor that is made to be mapped once the system is already fully booted, and it works with no problem being bootloaded.

```

`efi driver.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>$(SolutionDir)..\VisualUefi\edk2</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(SolutionDir)..\VisualUefi\EDK-II\$(Platform)\$(Configuration)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`efi driver.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <PropertyGroup>
    <LocalDebuggerCommand>..\debugger\qemu.exe</LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>-name "VisualUEFI Debugger" -drive file=OVMF_CODE-need-smm.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=OVMF_VARS-need-smm.fd,if=pflash,format=raw,unit=1 -drive file=fat:rw:..\samples\$(Platform)\$(Configuration)\,media=disk,if=virtio,format=raw -drive file=UefiShell.iso,format=raw -m 512 -machine q35,smm=on -nodefaults -vga std -global driver=cfi.pflash01,property=secure,value=on -global ICH9-LPC.disable_s3=1</LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory>..\..\debugger</LocalDebuggerWorkingDirectory>
    <LocalDebuggerDebuggerType>Script</LocalDebuggerDebuggerType>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>$(SolutionDir)..\VisualUefi\EDK-II\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`efi driver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "efi driver", "efi driver.vcxproj", "{B8CE018B-0E28-4EFB-BF39-288C275E56D3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B8CE018B-0E28-4EFB-BF39-288C275E56D3}.Release|x64.ActiveCfg = Release|x64
		{B8CE018B-0E28-4EFB-BF39-288C275E56D3}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ECB1D2EC-1021-4B09-A8EA-85A942CB4A7A}
	EndGlobalSection
EndGlobal

```

`efi driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{B8CE018B-0E28-4EFB-BF39-288C275E56D3}</ProjectGuid>
    <ProjectName>efi driver</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(SolutionDir)\efi driver.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\efi driver.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiDriverEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>EFI Runtime</SubSystem>
    </Link>
    <ClCompile>
      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">CompileAsC</CompileAs>
      <IntrinsicFunctions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</IntrinsicFunctions>
      <InlineFunctionExpansion Condition="'$(Configuration)|$(Platform)'=='Release|x64'">OnlyExplicitInline</InlineFunctionExpansion>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <StructMemberAlignment Condition="'$(Configuration)|$(Platform)'=='Release|x64'">8Bytes</StructMemberAlignment>
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdcpp20</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="efi_boilerplate.c" />
    <ClCompile Include="hook.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="mmap.c" />
    <ClInclude Include="hook.h" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="mmap.h" />
    <ClInclude Include="ntdef.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
</Project>
```

`efi_boilerplate.c`:

```c
//
// We run on any UEFI Specification
//
extern CONST UINT32 _gUefiDriverRevision = 0;

//
// Our name
//
CHAR8* gEfiCallerBaseName = "ShellSample";

CONST UINT8  _gDriverUnloadImageCount = 1;

EFI_STATUS
EFIAPI
UefiUnload(
    IN EFI_HANDLE ImageHandle
)
{
    return EFI_SUCCESS;
}
```

`hook.c`:

```c
#include "hook.h"
#include <intrin.h>

BYTE ioinitsystem_old_bytes[23];

CHAR16 g_module_path[260] = L"\\GLOBAL??\\C:\\yourdriverhere.sys";

VOID IoInitSystemHook()
{
	ManualMapFile(g_module_path);

	Readonly_Copy_Memory((VOID*)IoInitSystem, ioinitsystem_old_bytes, 23);
	return;
}

extern EFI_RUNTIME_SERVICES* gRT;

// Retpoline kicks in after SetVirtualAddressMap, so we cannot hook anywhere that calls into a dll import. Also we need to do the thunk in order to preserve 16-byte stack alignment
VOID Hook_IoInitSystem(UINT8* _ioInitSystem, VOID* func)
{
	Copy_Memory(&ioinitsystem_old_bytes, _ioInitSystem, 23);
	
	gRT->ConvertPointer(EFI_OPTIONAL_PTR, &func);

	static UINT8 bytecode_template[] = 
		{ 0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,	// movabs rax, _ioInitSystem
		0x50,															// push rax						; Leave _ioInitSystem as the return address
		0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,		// movabs rax, func
		0xFF, 0xE0 };													// jmp rax
	Readonly_Copy_Memory(_ioInitSystem, bytecode_template, 23);

	VOID* thunk_address = _ioInitSystem;
	gRT->ConvertPointer(EFI_OPTIONAL_PTR, &thunk_address);
	Readonly_Copy_Memory(_ioInitSystem + 2, &thunk_address, 8);
	Readonly_Copy_Memory(_ioInitSystem + 13, &func, 8);
}
```

`hook.h`:

```h
#include "util.h"
#include "mmap.h"
#include "ntdef.h"


extern BYTE ioinitsystem_old_bytes[23];
extern VOID(*IofCompleteRequest)(PIRP Irp, CHAR8* PriorityBoost);
extern UINT32(*IoInitSystem)();
extern VOID* g_kernel_base;
extern CHAR16 g_module_path[260];

VOID Hook_IoInitSystem(UINT8* _ioInitSystem, VOID* func);
// This doesn't actually point to the top of IoInitSystem, it points to after IoInitSystemPreDrivers, which is number of bytes in.
VOID IoInitSystemHook();
```

`main.c`:

```c
//
// Basic UEFI Libraries
//
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/BaseMemoryLib.h>

//
// Boot and Runtime Services
//
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>

//
// Shell Library
//
#include <Library/ShellLib.h>
#include "util.h"

#include <intrin.h>
#include "ntdef.h"
#include "hook.h"

VOID* g_kernel_base;

EFI_EXIT_BOOT_SERVICES o_ExitBootServices;

// We obtain this with an exitbootservices hook and then use it in NotifySetVirtualAddressMap
VOID* AddressInWinload;

// This doesn't actually point to the top of IoInitSystem, it points to after IoInitSystemPreDrivers, which is number of bytes in.
UINT32(*IoInitSystem)();

VOID EFIAPI NotifySetVirtualAddressMap(EFI_EVENT Event, VOID* Context)
{
    // AddressInWinload is in OslFwpSetupKernelPhase1, looking for OslpLogOsLaunch
    UINT64 scan_result = PatternScan("48 B8 77 BE 9F 1A 2F DD 24 06 49 F7 E1", AddressInWinload, 0x10000, FALSE);

    PLOADER_PARAMETER_BLOCK ldr_block = *(PLOADER_PARAMETER_BLOCK*)(*(UINT32*)(scan_result + 0x10) + scan_result + 0x14);

    g_kernel_base = GetModuleFromList(&ldr_block->LoadOrderListHead, L"ntoskrnl.exe")->DllBase;
    UINT64 cr0 = AsmReadCr0();
    AsmWriteCr0(cr0 & ~0x10000ull);
    // Hooks here
    // First we inline hook IoInitSystem
    IoInitSystem = (UINT32(*)(UINT64, UINT64, UINT64, UINT64))
        ((BYTE*)PatternScan("48 83 EC 28 48 8D 05 ?? ?? ?? ?? 48 89 44 24 38 E8 ?? ?? ?? ?? 84 C0 0F 84",
        g_kernel_base, 0x1000000, FALSE) + 0x29);
    Hook_IoInitSystem((UINT8*)IoInitSystem, (VOID*)IoInitSystemHook);

    AsmWriteCr0(cr0);
    return;
}

EFI_EXIT_BOOT_SERVICES o_ExitBootServices;

EFI_STATUS
EFIAPI hk_ExitBootServices(
    IN  EFI_HANDLE                   ImageHandle,
    IN  UINTN                        MapKey
)
{
    Print(L"Hi from bootkit\n");
    gBS->ExitBootServices = o_ExitBootServices;
    AddressInWinload = _ReturnAddress();
    return gBS->ExitBootServices(ImageHandle, MapKey);
}

EFI_STATUS
EFIAPI
UefiMain (
    IN EFI_HANDLE ImageHandle,
    IN EFI_SYSTEM_TABLE* SystemTable
    )
{
    o_ExitBootServices = gBS->ExitBootServices;
    UINT64 cr0 = AsmReadCr0();
    AsmWriteCr0(cr0 & ~0x10000ull);
    gBS->ExitBootServices = hk_ExitBootServices;
    AsmWriteCr0(cr0);

    EFI_EVENT event; // We will never ever access this through the handle so its ok that it goes out of scope.
    return gBS->CreateEvent(EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE, TPL_NOTIFY, NotifySetVirtualAddressMap, NULL, &event);
}


```

`mmap.c`:

```c
#include "mmap.h"


NTSTATUS (*NtOpenFile)(
	PHANDLE            FileHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK   IoStatusBlock,
	ULONG              ShareAccess,
	ULONG              OpenOptions
);

NTSTATUS (*NtQueryInformationFile)(
	HANDLE                 FileHandle,
	PIO_STATUS_BLOCK       IoStatusBlock,
	PVOID                  FileInformation,
	ULONG                  Length,
	FILE_INFORMATION_CLASS FileInformationClass
);

NTSTATUS (*ZwReadFile)(
	HANDLE           FileHandle,
	HANDLE           Event,
	PVOID  ApcRoutine,
	PVOID            ApcContext,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID            Buffer,
	ULONG            Length,
	UINT64*   ByteOffset,
	ULONG*           Key
);

PVOID (*ExAllocatePoolWithTag) (
	POOL_TYPE										PoolType,
	UINT64                                         NumberOfBytes,
	ULONG                                          Tag
	);

NTSTATUS (*ZwClose)(
	HANDLE Handle
);

void (*ExFreePoolWithTag)(
	PVOID P,
	ULONG Tag
);

NTSTATUS ManualMapFile (CHAR16* FileName)
{
	// Open file by name
#pragma warning (push)
#pragma warning (disable : 4152)
	if (!NtOpenFile)
		NtOpenFile = FindExport(g_kernel_base, "NtOpenFile");
	if (!NtQueryInformationFile)
		NtQueryInformationFile = FindExport(g_kernel_base, "NtQueryInformationFile");
	if (!ZwReadFile)
		ZwReadFile = FindExport(g_kernel_base, "ZwReadFile");
	if (!ExAllocatePoolWithTag)
		ExAllocatePoolWithTag = FindExport(g_kernel_base, "ExAllocatePoolWithTag");
	if (!ZwClose)
		ZwClose = FindExport(g_kernel_base, "ZwClose");
	if (!ExFreePoolWithTag)
		ExFreePoolWithTag = FindExport(g_kernel_base, "ExFreePoolWithTag");
#pragma warning (pop)

	UNICODE_STRING str = {(UINT16)StrLen(FileName) * 2, (UINT16)StrLen(FileName) * 2, FileName};
	OBJECT_ATTRIBUTES attrib = {sizeof(OBJECT_ATTRIBUTES), NULL, &str, 0x00000040L, NULL, NULL};
	HANDLE FileHandle = NULL;
	IO_STATUS_BLOCK status_block;
	NTSTATUS status = NtOpenFile(&FileHandle, GENERIC_READ, &attrib, &status_block, 0, FILE_SYNCHRONOUS_IO_NONALERT);
	if (status < 0)
		return status;
	FILE_STANDARD_INFORMATION info;
	status = NtQueryInformationFile(FileHandle, &status_block, &info, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation);
	if (status < 0)
		goto endfunc;
	UINT64 size = info.EndOfFile;
	
	BYTE* buf = ExAllocatePoolWithTag(NonPagedPool, size, 'sgin');
	if (!buf)
		goto endfunc;
	UINT64 byte_offset = 0;
	status = ZwReadFile(FileHandle, NULL, NULL, NULL, &status_block, buf, (ULONG)size, &byte_offset, NULL);
	if (status < 0)
		goto freepool;
	status = ManualMapArray(buf, size);

freepool:
	ExFreePoolWithTag(buf, 'sgin');
endfunc:
	ZwClose(FileHandle);
	return status;
}

PMDL (*MmAllocatePagesForMdl)(
	PHYSICAL_ADDRESS LowAddress,
	PHYSICAL_ADDRESS HighAddress,
	PHYSICAL_ADDRESS SkipBytes,
	UINT64           TotalBytes
);

PVOID (*MmMapLockedPages)(
	PMDL			MemoryDescriptorList,
	KPROCESSOR_MODE AccessMode
);

ULONG (*DbgPrint)(
	const CHAR8* Format,
	...
);

NTSTATUS ManualMapArray(BYTE* bytes, UINT64 size)
{
#pragma warning (push)
#pragma warning (disable : 4152)
	if (!MmAllocatePagesForMdl)
		MmAllocatePagesForMdl = FindExport(g_kernel_base, "MmAllocatePagesForMdl");
	if (!MmMapLockedPages)
		MmMapLockedPages = FindExport(g_kernel_base, "MmMapLockedPages");
	if (!DbgPrint)
		DbgPrint = FindExport(g_kernel_base, "DbgPrint");
#pragma warning (pop)

	IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)bytes;
	if (dos->e_magic != 'ZM')
		return STATUS_INVALID_PARAMETER;
	IMAGE_NT_HEADERS64* nt = (IMAGE_NT_HEADERS64*)(bytes + dos->e_lfanew);
	if (nt->Signature != (UINT32)'EP')
		return STATUS_INVALID_PARAMETER;

	// Allocate mdl
	PMDL mdl = MmAllocatePagesForMdl(0, ~0ull, 0, nt->OptionalHeader.SizeOfImage);
	BYTE* AllocationBase = MmMapLockedPages(mdl, KernelMode);

	// Copy sections one at a time (no need to copy the headers)
	PIMAGE_SECTION_HEADER sec_hdr = (PIMAGE_SECTION_HEADER)((BYTE*)(&nt->FileHeader) + sizeof(IMAGE_FILE_HEADER) + nt->FileHeader.SizeOfOptionalHeader);
	for (int i = 0; i < nt->FileHeader.NumberOfSections; i++, sec_hdr++)
		Copy_Memory(AllocationBase + sec_hdr->VirtualAddress, bytes + sec_hdr->PointerToRawData, sec_hdr->SizeOfRawData);

	// Imports
	PIMAGE_DATA_DIRECTORY import_dir = &nt->OptionalHeader.DataDirectory[1];
	for (PIMAGE_IMPORT_DESCRIPTOR desc = (PIMAGE_IMPORT_DESCRIPTOR)(AllocationBase + import_dir->VirtualAddress); desc->LookupTableRVA; ++desc)
	{
		// Get unicode name from ascii name
		CHAR16 buffer[260];
		CHAR8* mod_name = (CHAR8*)(AllocationBase + desc->Name);
		for (int i = 0; i < 259 && mod_name[i]; ++i)
			buffer[i] = (CHAR16)mod_name[i], buffer[i + 1] = L'\0';
		PVOID module_base = GetLoadedModuleBase(buffer);
		for (UINT64* lookup_entry = (UINT64*)(AllocationBase + desc->LookupTableRVA), *iat_entry = (UINT64*)(AllocationBase + desc->ImportAddressTable); *lookup_entry; ++lookup_entry, ++iat_entry)
		{
			if (*lookup_entry & (1ull << 63))
				*(PVOID*)iat_entry = FindExportByOrdinal(module_base, *lookup_entry & 0xFFFF);
			else
				*(PVOID*)iat_entry = FindExport(module_base, ((RELOC_NAME_TABLE_ENTRY*)(AllocationBase + (*lookup_entry & 0x7FFFFFFF)))->Name);
		}
	}

	// Relocations
	INT64 load_delta = (INT64)(AllocationBase - nt->OptionalHeader.ImageBase);
	PIMAGE_DATA_DIRECTORY reloc = &nt->OptionalHeader.DataDirectory[5];
	for (PRELOC_BLOCK_HDR i = (PRELOC_BLOCK_HDR)(AllocationBase + reloc->VirtualAddress); i < (PRELOC_BLOCK_HDR)(AllocationBase + reloc->VirtualAddress + reloc->Size); *(BYTE**)&i += i->BlockSize)
		for (PRELOC_ENTRY entry = (PRELOC_ENTRY)i + 4; (BYTE*)entry < (BYTE*)i + i->BlockSize; ++entry)
			if (entry->Type == 0xA)
				*(UINT64*)(AllocationBase + i->PageRVA + entry->Offset) += load_delta;
	
	// Unload discardable sections
	sec_hdr = (PIMAGE_SECTION_HEADER)((BYTE*)(&nt->FileHeader) + sizeof(IMAGE_FILE_HEADER) + nt->FileHeader.SizeOfOptionalHeader);
	for (int i = 0; i < nt->FileHeader.NumberOfSections; i++, sec_hdr++)
		if (sec_hdr->Characteristics & 0x02000000)
			Set_Memory(AllocationBase + sec_hdr->VirtualAddress, sec_hdr->SizeOfRawData, 0x00);

	if (!nt->OptionalHeader.AddressOfEntryPoint)
		return STATUS_SUCCESS;

	// Call DriverEntry
	NTSTATUS(*DriverEntry)(DEVICE_OBJECT * DeviceObject, PUNICODE_STRING RegistryPath) = 
		(NTSTATUS(*)(DEVICE_OBJECT *, PUNICODE_STRING))(AllocationBase + nt->OptionalHeader.AddressOfEntryPoint);

	return DriverEntry((DEVICE_OBJECT*)0, (PUNICODE_STRING)0);
}
```

`mmap.h`:

```h
#include "ntdef.h"
#include "util.h"

extern VOID* g_kernel_base;

NTSTATUS ManualMapFile(CHAR16* FileName);
NTSTATUS ManualMapArray(BYTE* bytes, UINT64 size);
```

`ntdef.h`:

```h
#pragma once
#pragma warning( push )
#pragma warning (disable : 4201 4324)

#include <ntstatus.h>

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (char*)(address) - \
                                                  (UINT64)(&((type *)0)->field)))

typedef struct _UNICODE_STRING
{
    UINT16 Length;
    UINT16 MaximumLength;
    CHAR16* Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef short CSHORT;
typedef unsigned short USHORT;
typedef long LONG;
typedef unsigned long ULONG;
typedef VOID* PVOID;
typedef void* HANDLE;
typedef HANDLE* PHANDLE;
typedef CHAR8 CCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef ULONG DEVICE_TYPE, ACCESS_MASK;
typedef long NTSTATUS;
typedef PVOID PIO_TIMER, PVPB, PSECURITY_DESCRIPTOR, PDRIVER_EXTENSION, PFAST_IO_DISPATCH, PDRIVER_INITIALIZE, PDRIVER_STARTIO, PDRIVER_UNLOAD, PDRIVER_DISPATCH;
typedef unsigned char BYTE;
typedef struct _OBJECT_TYPE OBJECT_TYPE, * POBJECT_TYPE;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,                   // 2
    FileBothDirectoryInformation,                   // 3
    FileBasicInformation,                           // 4
    FileStandardInformation,                        // 5
    FileInternalInformation,                        // 6
    FileEaInformation,                              // 7
    FileAccessInformation,                          // 8
    FileNameInformation,                            // 9
    FileRenameInformation,                          // 10
    FileLinkInformation,                            // 11
    FileNamesInformation,                           // 12
    FileDispositionInformation,                     // 13
    FilePositionInformation,                        // 14
    FileFullEaInformation,                          // 15
    FileModeInformation,                            // 16
    FileAlignmentInformation,                       // 17
    FileAllInformation,                             // 18
    FileAllocationInformation,                      // 19
    FileEndOfFileInformation,                       // 20
    FileAlternateNameInformation,                   // 21
    FileStreamInformation,                          // 22
    FilePipeInformation,                            // 23
    FilePipeLocalInformation,                       // 24
    FilePipeRemoteInformation,                      // 25
    FileMailslotQueryInformation,                   // 26
    FileMailslotSetInformation,                     // 27
    FileCompressionInformation,                     // 28
    FileObjectIdInformation,                        // 29
    FileCompletionInformation,                      // 30
    FileMoveClusterInformation,                     // 31
    FileQuotaInformation,                           // 32
    FileReparsePointInformation,                    // 33
    FileNetworkOpenInformation,                     // 34
    FileAttributeTagInformation,                    // 35
    FileTrackingInformation,                        // 36
    FileIdBothDirectoryInformation,                 // 37
    FileIdFullDirectoryInformation,                 // 38
    FileValidDataLengthInformation,                 // 39
    FileShortNameInformation,                       // 40
    FileIoCompletionNotificationInformation,        // 41
    FileIoStatusBlockRangeInformation,              // 42
    FileIoPriorityHintInformation,                  // 43
    FileSfioReserveInformation,                     // 44
    FileSfioVolumeInformation,                      // 45
    FileHardLinkInformation,                        // 46
    FileProcessIdsUsingFileInformation,             // 47
    FileNormalizedNameInformation,                  // 48
    FileNetworkPhysicalNameInformation,             // 49
    FileIdGlobalTxDirectoryInformation,             // 50
    FileIsRemoteDeviceInformation,                  // 51
    FileUnusedInformation,                          // 52
    FileNumaNodeInformation,                        // 53
    FileStandardLinkInformation,                    // 54
    FileRemoteProtocolInformation,                  // 55

    //
    //  These are special versions of these operations (defined earlier)
    //  which can be used by kernel mode drivers only to bypass security
    //  access checks for Rename and HardLink operations.  These operations
    //  are only recognized by the IOManager, a file system should never
    //  receive these.
    //

    FileRenameInformationBypassAccessCheck,         // 56
    FileLinkInformationBypassAccessCheck,           // 57

    //
    // End of special information classes reserved for IOManager.
    //

    FileVolumeNameInformation,                      // 58
    FileIdInformation,                              // 59
    FileIdExtdDirectoryInformation,                 // 60
    FileReplaceCompletionInformation,               // 61
    FileHardLinkFullIdInformation,                  // 62
    FileIdExtdBothDirectoryInformation,             // 63
    FileDispositionInformationEx,                   // 64
    FileRenameInformationEx,                        // 65
    FileRenameInformationExBypassAccessCheck,       // 66
    FileDesiredStorageClassInformation,             // 67
    FileStatInformation,                            // 68
    FileMemoryPartitionInformation,                 // 69
    FileStatLxInformation,                          // 70
    FileCaseSensitiveInformation,                   // 71
    FileLinkInformationEx,                          // 72
    FileLinkInformationExBypassAccessCheck,         // 73
    FileStorageReserveIdInformation,                // 74
    FileCaseSensitiveInformationForceAccessCheck,   // 75
    FileKnownFolderInformation,   // 76

    FileMaximumInformation
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef struct _FILE_STANDARD_INFORMATION {
    UINT64 AllocationSize;
    UINT64 EndOfFile;
    ULONG         NumberOfLinks;
    BOOLEAN       DeletePending;
    BOOLEAN       Directory;
} FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;
typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32,

} POOL_TYPE;

typedef struct _RELOC_BLOCK_HDR
{
    UINT32 PageRVA;
    UINT32 BlockSize;
} RELOC_BLOCK_HDR, *PRELOC_BLOCK_HDR;

typedef struct _RELOC_ENTRY
{
    UINT16 Offset : 12;
    UINT16 Type : 4;
} RELOC_ENTRY, * PRELOC_ENTRY;

typedef struct _RELOC_NAME_TABLE_ENTRY
{
    UINT16 Hint;
    CHAR8 Name[];
} RELOC_NAME_TABLE_ENTRY, PRELOC_NAME_TABLE_ENTRY;

//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)

#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L


//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#define FILE_DISALLOW_EXCLUSIVE                 0x00020000

#define FILE_SESSION_AWARE                      0x00040000

//
//  CreateOptions flag to pass in call to CreateFile to allow the write through xro.sys
//

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


typedef  NTSTATUS (*p_ObReferenceObjectByName)(PUNICODE_STRING ObjectName,

    ULONG Attributes,

    PVOID AccessState,

    ACCESS_MASK DesiredAccess,

    POBJECT_TYPE ObjectType,

    KPROCESSOR_MODE AccessMode,

    PVOID ParseContext OPTIONAL,

    PVOID* Object);

#define IRP_MJ_MAXIMUM_FUNCTION 0x1b

extern p_ObReferenceObjectByName ObReferenceObjectByName;

typedef struct _MDL {
    struct _MDL* Next;
    CSHORT Size;
    CSHORT MdlFlags;

    struct _EPROCESS* Process;
    PVOID MappedSystemVa;   /* see creators for field size annotations. */
    PVOID StartVa;   /* see creators for validity; could be address 0.  */
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, * PMDL;

typedef struct __declspec(align(16)) _DEVICE_OBJECT {
    CSHORT                   Type;
    USHORT                   Size;
    LONG                     ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    PIO_TIMER                Timer;
    ULONG                    Flags;
    ULONG                    Characteristics;
    volatile PVPB            Vpb;
    PVOID                    DeviceExtension;
    DEVICE_TYPE              DeviceType;
    CCHAR                    StackSize;
    union {
        LIST_ENTRY         ListEntry;
        BYTE               Wcb[0x48];
    } Queue;
    ULONG                    AlignmentRequirement;
    ULONG                    pad0;
    BYTE                     DeviceQueue[0x28];
    BYTE                     Dpc[0x40];
    ULONG                    ActiveThreadCount;
    ULONG                    pad1;
    PSECURITY_DESCRIPTOR     SecurityDescriptor;
    BYTE                     DeviceLock[0x18];
    USHORT                   SectorSize;
    USHORT                   Spare1;
    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    PVOID                    Reserved;
} DEVICE_OBJECT, * PDEVICE_OBJECT;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    //
    // The remaining fields are reserved for system use.
    //

    ULONG           PowerFlags;
    struct          _DEVICE_OBJECT_POWER_EXTENSION* Dope;
    ULONG ExtensionFlags;
    PVOID           DeviceNode;
    PDEVICE_OBJECT  AttachedTo;
    volatile LONG StartIoCount;
    LONG           StartIoKey;
    ULONG          StartIoFlags;
    PVPB           Vpb;
    PVOID DependencyNode;
    PVOID InterruptContext;
    volatile LONG InterruptCount;

    volatile PVOID VerifierContext;

} DEVOBJ_EXTENSION, * PDEVOBJ_EXTENSION;

typedef struct _DRIVER_OBJECT {
    CSHORT             Type;
    CSHORT             Size;
    PDEVICE_OBJECT     DeviceObject;
    ULONG              Flags;
    PVOID              DriverStart;
    ULONG              DriverSize;
    PVOID              DriverSection;
    PDRIVER_EXTENSION  DriverExtension;
    UNICODE_STRING     DriverName;
    PUNICODE_STRING    HardwareDatabase;
    PFAST_IO_DISPATCH  FastIoDispatch;
    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO    DriverStartIo;
    PDRIVER_UNLOAD     DriverUnload;
    PDRIVER_DISPATCH   MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];
} DRIVER_OBJECT, * PDRIVER_OBJECT;

typedef struct _LOADER_PARAMETER_BLOCK
{
    UINT32 OsMajorVersion;
    UINT32 OsMinorVersion;
    UINT32 Size;
    UINT32 OsLoaderSecurityVersion;
    struct _LIST_ENTRY LoadOrderListHead;
    struct _LIST_ENTRY MemoryDescriptorListHead;
    struct _LIST_ENTRY BootDriverListHead;
    struct _LIST_ENTRY EarlyLaunchListHead;
    struct _LIST_ENTRY CoreDriverListHead;
    struct _LIST_ENTRY CoreExtensionsDriverListHead;
    struct _LIST_ENTRY TpmCoreDriverListHead;
} LOADER_PARAMETER_BLOCK, * PLOADER_PARAMETER_BLOCK;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;
    VOID* ExceptionTable;
    UINT32 ExceptionTableSize;
    VOID* GpValue;
    struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
    VOID* DllBase;
    VOID* EntryPoint;
    UINT32 SizeOfImage;
    struct _UNICODE_STRING FullDllName;
    struct _UNICODE_STRING BaseDllName;
    UINT32 Flags;
    UINT16 LoadCount;
    union
    {
        UINT16 SignatureLevel : 4;
        UINT16 SignatureType : 3;
        UINT16 Unused : 9;
        UINT16 EntireField;
    } u1;
    VOID* SectionPointer;
    UINT32 CheckSum;
    UINT32 CoverageSectionSize;
    VOID* CoverageSection;
    VOID* LoadedImports;
    VOID* Spare;
    UINT32 SizeOfImageNotRounded;
    UINT32 TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

typedef struct _IMAGE_FILE_HEADER
{
    UINT16 Machine;
    UINT16 NumberOfSections;
    UINT32 TimeDateStamp;
    UINT32 PointerToSymbolTable;
    UINT32 NumberOfSymbols;
    UINT16 SizeOfOptionalHeader;
    UINT16 Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
    UINT32 VirtualAddress;
    UINT32 Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct _IMAGE_OPTIONAL_HEADER64
{
    UINT16 Magic;
    UINT8 MajorLinkerVersion;
    UINT8 MinorLinkerVersion;
    UINT32 SizeOfCode;
    UINT32 SizeOfInitializedData;
    UINT32 SizeOfUninitializedData;
    UINT32 AddressOfEntryPoint;
    UINT32 BaseOfCode;
    UINT64 ImageBase;
    UINT32 SectionAlignment;
    UINT32 FileAlignment;
    UINT16 MajorOperatingSystemVersion;
    UINT16 MinorOperatingSystemVersion;
    UINT16 MajorImageVersion;
    UINT16 MinorImageVersion;
    UINT16 MajorSubsystemVersion;
    UINT16 MinorSubsystemVersion;
    UINT32 Win32VersionValue;
    UINT32 SizeOfImage;
    UINT32 SizeOfHeaders;
    UINT32 CheckSum;
    UINT16 Subsystem;
    UINT16 DllCharacteristics;
    UINT64 SizeOfStackReserve;
    UINT64 SizeOfStackCommit;
    UINT64 SizeOfHeapReserve;
    UINT64 SizeOfHeapCommit;
    UINT32 LoaderFlags;
    UINT32 NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64, IMAGE_NT_HEADERS, * PIMAGE_NT_HEADERS;

typedef struct _IMAGE_DOS_HEADER
{
    UINT16 e_magic;                     // Magic number
    UINT16 e_cblp;                      // Bytes on last page of file
    UINT16 e_cp;                        // Pages in file
    UINT16 e_crlc;                      // Relocations
    UINT16 e_cparhdr;                   // Size of header in paragraphs
    UINT16 e_minalloc;                  // Minimum extra paragraphs needed
    UINT16 e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16 e_ss;                        // Initial (relative) SS value
    UINT16 e_sp;                        // Initial SP value
    UINT16 e_csum;                      // Checksum
    UINT16 e_ip;                        // Initial IP value
    UINT16 e_cs;                        // Initial (relative) CS value
    UINT16 e_lfarlc;                    // File address of relocation table
    UINT16 e_ovno;                      // Overlay number
    UINT16 e_res[4];                    // Reserved words
    UINT16 e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16 e_oeminfo;                   // OEM information; e_oemid specific
    UINT16 e_res2[10];                  // Reserved words
    INT32 e_lfanew;                     // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct _IMAGE_SECTION_HEADER
{
    UINT8 Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        UINT32 PhysicalAddress;
        UINT32 VirtualSize;
    } Misc;
    UINT32 VirtualAddress;
    UINT32 SizeOfRawData;
    UINT32 PointerToRawData;
    UINT32 PointerToRelocations;
    UINT32 PointerToLinenumbers;
    UINT16 NumberOfRelocations;
    UINT16 NumberOfLinenumbers;
    UINT32 Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
    UINT32 Characteristics;
    UINT32 TimeDateStamp;
    UINT16 MajorVersion;
    UINT16 MinorVersion;
    UINT32 Name;
    UINT32 Base;
    UINT32 NumberOfFunctions;
    UINT32 NumberOfNames;
    UINT32 AddressOfFunctions;
    UINT32 AddressOfNames;
    UINT32 AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   LookupTableRVA;             // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    UINT32   TimeDateStamp;                  // 0 if not bound,
    // -1 if bound, and real date\time stamp
    //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
    // O.W. date/time stamp of DLL bound to (Old BIND)

    UINT32   ForwarderChain;                 // -1 if no forwarders
    UINT32   Name;
    UINT32   ImportAddressTable;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef IMAGE_IMPORT_DESCRIPTOR * PIMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    CHAR8   Name[];
} IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;

typedef struct _IO_STATUS_BLOCK {
    union {
        UINT32 Status;
        VOID* Pointer;
    };

    UINT64 Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    UINT32 SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, * PKDEVICE_QUEUE_ENTRY, * PRKDEVICE_QUEUE_ENTRY;

typedef struct _KAPC {
    UINT8 Type;
    UINT8 AllFlags;
    UINT8 Size;
    UINT8 SpareByte1;
    UINT32 SpareLong0;
    struct _KTHREAD* Thread;
    LIST_ENTRY ApcListEntry;
    VOID* Reserved[3];
    VOID* NormalContext;
    VOID* SystemArgument1;
    VOID* SystemArgument2;
    CHAR8 ApcStateIndex;
    CHAR8 ApcMode;
    BOOLEAN Inserted;
} KAPC, * PKAPC, * PRKAPC;


// TODO: Clean this up
typedef struct _IO_STACK_LOCATION {
    UINT8 MajorFunction;
    UINT8 MinorFunction;
    UINT8 Flags;
    UINT8 Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    // Stupid me deleted all the declspec aligns and they need to be added back
    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  FileAttributes;
            UINT16 ShareAccess;
            UINT32  EaLength;
        } Create;

        //
        // System service parameters for:  NtCreateNamedPipeFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  Reserved;
            UINT16 ShareAccess;
            VOID* Parameters;
        } CreatePipe;

        //
        // System service parameters for:  NtCreateMailslotFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  Reserved;
            UINT16 ShareAccess;
            VOID* Parameters;
        } CreateMailslot;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            UINT32 Length;
            UINT32  Key;
#if defined(_WIN64)
            UINT32 Flags;
#endif
            UINT64 ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            UINT32 Length;
            UINT32  Key;
#if defined(_WIN64)
            UINT32 Flags;
#endif
            UINT64 ByteOffset;
        } Write;

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            UINT32 Length;
            PUNICODE_STRING FileName;
            UINT32 FileInformationClass;
            UINT32  FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile / NtNotifyChangeDirectoryFileEx
        //

        struct {
            UINT32 Length;
            UINT32  CompletionFilter;
        } NotifyDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile / NtNotifyChangeDirectoryFileEx
        //
        // For minor code IRP_MN_NOTIFY_CHANGE_DIRECTORY_EX
        // N.B. Keep Length and CompletionFilter aligned with NotifyDirectory.
        //

        struct {
            UINT32 Length;
            UINT32  CompletionFilter;
            UINT32  DirectoryNotifyInformationClass;
        } NotifyDirectoryEx;

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FileInformationClass;
            VOID* FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                UINT32 ClusterCount;
                VOID* DeleteHandle;
            };
        } SetFile;



        //
        // System service parameters for:  NtQueryEaFile
        //

        struct {
            UINT32 Length;
            VOID* EaList;
            UINT32 EaListLength;
            UINT32  EaIndex;
        } QueryEa;

        //
        // System service parameters for:  NtSetEaFile
        //

        struct {
            UINT32 Length;
        } SetEa;



        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FsInformationClass;
        } QueryVolume;



        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FsInformationClass;
        } SetVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            UINT32 OutputBufferLength;
            UINT32  InputBufferLength;
            UINT32  FsControlCode;
            VOID* Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            UINT64* Length;
            UINT32  Key;
            UINT64 ByteOffset;
        } LockControl;

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            UINT32 OutputBufferLength;
            UINT32 __declspec(align(8)) InputBufferLength;
            UINT32 __declspec(align(8)) IoControlCode;
            VOID* Type3InputBuffer;
        } DeviceIoControl;

        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            UINT32 SecurityInformation;
            UINT32  Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            UINT32 SecurityInformation;
            VOID* SecurityDescriptor;
        } SetSecurity;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            VOID* Vpb;
            VOID* DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            VOID* Vpb;
            VOID* DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device control.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK* Srb;
        } Scsi;



        //
        // System service parameters for:  NtQueryQuotaInformationFile
        //

        struct {
            UINT32 Length;
            VOID* StartSid;
            VOID* SidList;
            UINT32 SidListLength;
        } QueryQuota;

        //
        // System service parameters for:  NtSetQuotaInformationFile
        //

        struct {
            UINT32 Length;
        } SetQuota;



        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            UINT32 Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID* InterfaceType;
            UINT16 Size;
            UINT16 Version;
            VOID* Interface;
            VOID* InterfaceSpecificData;
        } QueryInterface;

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            VOID* Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            VOID* IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            UINT32 WhichSpace;
            VOID* Buffer;
            UINT32 Offset;
            UINT32  Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            UINT32 IdType;
        } QueryId;

        //
        // Parameters for StartDevice
        //

        struct {
            VOID* AllocatedResources;
            VOID* AllocatedResourcesTranslated;
        } StartDevice;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            UINT32 ProviderId;
            VOID* DataPath;
            UINT32 BufferSize;
            VOID* Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            VOID* Argument1;
            VOID* Argument2;
            VOID* Argument3;
            VOID* Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    VOID* DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    // request.
    //

    VOID* FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    VOID* CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    VOID* Context;

} IO_STACK_LOCATION, * PIO_STACK_LOCATION;

typedef struct _IRP {
    INT16 Type;
    UINT16 Size;


    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    VOID* MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    UINT32 Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP* MasterIrp;
        INT32 IrpCount;
        VOID* SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queuing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requester mode - mode of the original requester of this operation.
    //

    CHAR8 RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR8 StackCount;
    CHAR8 CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    UINT8 CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CHAR8 ApcEnvironment;

    //
    // Allocation control flags.
    //

    UINT8 AllocationFlags;

    //
    // User parameters.
    //

    union {
        PIO_STATUS_BLOCK UserIosb;

        //
        // Context used when the Irp is managed by IoRing and is used by IoRing.
        // UserIosb is used to cancel an Irp, so sharing space with UserIosb
        // let IoRing cancel an Irp based on its context.
        //

        VOID* IoRingContext;
    };

    VOID* UserEvent;
    union {
        struct {
            union {
                VOID* UserApcRoutine;
                VOID* IssuingProcess;
            };
            union {
                VOID* UserApcContext;

                //
                // IoRing object that rolled this Irp, if any.  The completion
                // is processed through this IoRing object.  UserApcRoutine and
                // UserApcContext is not supported when issuing IOs through an
                // IoRing so we union this with UserApcContext.  We did not use
                // UserApcRoutine because IssuingProcess use the same location
                // and is used when an Irp is queued to FileObject and when the
                // Irp is managed by IoRing it is queued to the FileObject.
                //

                struct _IORING_OBJECT* IoRing;
            };
        } AsynchronousParameters;
        UINT64 AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    VOID* CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    VOID* UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    VOID* DriverContext[4];

                };

            };

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            VOID* Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            CHAR8* AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION* CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    UINT32 PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            VOID* OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file VOID*.
        //

        VOID* CompletionKey;

    } Tail;

} IRP;

typedef IRP* PIRP;

typedef struct _IF_LH_PHYSICAL_ADDRESS
{
    UINT16 Length;
    BYTE Address[32];
} IF_LH_PHYSICAL_ADDRESS;

#pragma warning( pop )


```

`util.c`:

```c
#include "util.h"
#include "ntdef.h"

UINT64 ascii_to_int(CHAR8* ascii)
{
    UINT64 return_int = 0;
    while (*ascii)
    {
        if (*ascii <= '0' || *ascii >= '9')
            return 0;
        return_int *= 10;
        return_int += *ascii - '0';
        ascii++;
    }
    return return_int;
}


UINT32* FindExportEntry(VOID* module, const CASE_SENSITIVE CHAR8* routine_name)
{
    PIMAGE_DOS_HEADER dos = module;
    if (dos->e_magic != 0x5A4D)
        return NULL;
    
    PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)((UINT8*)module + dos->e_lfanew);
    UINT32 exports_rva = nt->OptionalHeader.DataDirectory[0].VirtualAddress; // This corresponds to export directory
    if (!exports_rva)
        return NULL;

    PIMAGE_EXPORT_DIRECTORY export_dir = (PIMAGE_EXPORT_DIRECTORY)((UINT8*)module + exports_rva);
    UINT32* name_table = (UINT32*)((UINT8*)module + export_dir->AddressOfNames);

    // Binary Search
    for (int lower = 0, upper = export_dir->NumberOfNames - 1; upper >= lower;)
    {
        int i = (upper + lower) / 2;
        const CHAR8* func_name = (CHAR8*)((UINT8*)module + name_table[i]);
        INTN diff = ascii_strcmp(routine_name, func_name);
        if (diff > 0)
            lower = i + 1;
        else if (diff < 0)
            upper = i - 1;
        else
        {
            UINT32* export_func_table = (UINT32*)((UINT8*)module + export_dir->AddressOfFunctions);
            UINT16* ordinal_table = (UINT16*)((UINT8*)module + export_dir->AddressOfNameOrdinals);

            UINT16 index = ordinal_table[i];
            if (export_func_table[index] < nt->OptionalHeader.DataDirectory[0].VirtualAddress ||
                export_func_table[index] > nt->OptionalHeader.DataDirectory[0].VirtualAddress + nt->OptionalHeader.DataDirectory[0].Size)
                return export_func_table + index;
            // Handle the case of a forwarder export entry
            else
            {
                CHAR16 buffer[260];
                CHAR8* forwarder_rva_string = (CHAR8*)module + export_func_table[index];
                UINT16 dll_name_length;
                for (dll_name_length = 0; dll_name_length < 259; ++dll_name_length)
                    if (forwarder_rva_string[dll_name_length] == '.') break;
                for (int j = 0; j < dll_name_length; ++j)
                    buffer[j] = (CHAR16)forwarder_rva_string[j];
                buffer[dll_name_length] = L'\0';
                if (forwarder_rva_string[dll_name_length + 1] == '#')
                    return FindExportEntryByOrdinal(GetLoadedModuleBase(buffer), (UINT16)ascii_to_int(&forwarder_rva_string[dll_name_length + 2]));
                else
                    return FindExportEntry(GetLoadedModuleBase(buffer), forwarder_rva_string + dll_name_length + 1);
            }
        }
    }
    return NULL;
}

UINT32* FindExportEntryByOrdinal(VOID* module, UINT16 ordinal)
{
    PIMAGE_DOS_HEADER dos = module;
    if (dos->e_magic != 0x5A4D)
        return NULL;

    PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)((UINT8*)module + dos->e_lfanew);
    UINT32 exports_rva = nt->OptionalHeader.DataDirectory[0].VirtualAddress; // This corresponds to export directory
    if (!exports_rva)
        return NULL;

    PIMAGE_EXPORT_DIRECTORY export_dir = (PIMAGE_EXPORT_DIRECTORY)((UINT8*)module + exports_rva);
    UINT16 index = ordinal - (UINT16)export_dir->Base;

    UINT32* export_func_table = (UINT32*)((UINT8*)module + export_dir->AddressOfFunctions);
    if (export_func_table[index] < nt->OptionalHeader.DataDirectory[0].VirtualAddress || 
        export_func_table[index] > nt->OptionalHeader.DataDirectory[0].VirtualAddress + nt->OptionalHeader.DataDirectory[0].Size)
        return export_func_table + index;
    // Handle the case of a forwarder export entry
    else
    {
        CHAR16 buffer[260];
        CHAR8* forwarder_rva_string = (CHAR8*)module + export_func_table[index];
        UINT16 dll_name_length;
        for (dll_name_length = 0; dll_name_length < 259; ++dll_name_length)
            if (forwarder_rva_string[dll_name_length] == '.') break;
        for (int i = 0; i < dll_name_length; ++i)
            buffer[i] = (CHAR16)forwarder_rva_string[i];
        buffer[dll_name_length] = L'\0';
        if (forwarder_rva_string[dll_name_length + 1] == '#')
            return FindExportEntryByOrdinal(GetLoadedModuleBase(buffer), (UINT16)ascii_to_int(&forwarder_rva_string[dll_name_length + 2]));
        else
            return FindExportEntry(GetLoadedModuleBase(buffer), forwarder_rva_string + dll_name_length + 1);
    }
}

VOID* FindExport(VOID* module, const CASE_SENSITIVE CHAR8* routine_name)
{
    UINT32* entry = FindExportEntry(module, routine_name);
    if (!entry)
        return NULL;
    return (VOID*)((UINT8*)module + *entry);
}

VOID* FindExportByOrdinal(VOID* module, UINT16 ordinal)
{
    UINT32* entry = FindExportEntryByOrdinal(module, ordinal);
    if (!entry)
        return NULL;
    return (VOID*)((UINT8*)module + *entry);
}

// This returns a pointer within the IAT, not the entry itself
VOID** FindImportEntry(VOID* module, const CASE_INSENSITIVE CHAR8* routine_module, const CASE_SENSITIVE CHAR8* routine_name)
{
    PIMAGE_DOS_HEADER dos = module;
    if (dos->e_magic != 0x5A4D)
        return NULL;

    PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)((UINT8*)module + dos->e_lfanew);
    UINT32 imports_rva = nt->OptionalHeader.DataDirectory[1].VirtualAddress; // This corresponds to import directory
    if (!imports_rva)
        return NULL;

    PIMAGE_IMPORT_DESCRIPTOR import_dir = (PIMAGE_IMPORT_DESCRIPTOR)((UINT8*)module + imports_rva);
    // Find the appropriate import directory table entry
    for (int i = 0;; i++)
    {
        if (!import_dir[i].Name)
            return NULL;
        const CHAR8* mod_name = (const CHAR8*)module + import_dir[i].Name;
        if (!AsciiStriCmp(mod_name, routine_module))
        {
            import_dir += i;
            break;
        }
    }

    UINT64* lookup_table = (UINT64*)((UINT8*)module + import_dir->LookupTableRVA);
    for (int i = 0; lookup_table[i]; ++i)
    {
        if (lookup_table[i] & (1ull << 63))
            break; // Import by ordinal
        PIMAGE_IMPORT_BY_NAME entry = (PIMAGE_IMPORT_BY_NAME)((UINT8*)module + lookup_table[i]);
        if (!ascii_strcmp(entry->Name, routine_name))
        {
            VOID** ImportAddressTable = (VOID**)((UINT8*)module + import_dir->ImportAddressTable);
            return ImportAddressTable + i;
        }
    }
    return NULL;
}

VOID* FindImport(VOID* module, const CASE_INSENSITIVE CHAR8* routine_module, const CASE_SENSITIVE CHAR8* routine_name)
{
    VOID** entry = FindImportEntry(module, routine_module, routine_name);
    if (!entry)
        return NULL;
    return *entry;
}

CHAR16 wc_to_lower(CHAR16 c)
{
    if (c >= 'A' && c <= 'Z')
        return c += ('a' - 'A');
    else return c;
}

INTN u_wcsnicmp(const CHAR16* First, const CHAR16* Second, UINTN Length)
{
    for (int i = 0; i < Length && First[i] && Second[i]; ++i) // Channeling my inner Python developer
        if (wc_to_lower(First[i]) != wc_to_lower(Second[i]))
            return First[i] - Second[i];

    return 0;
}

KLDR_DATA_TABLE_ENTRY* GetModuleFromList(LIST_ENTRY* head, const CASE_INSENSITIVE CHAR16* mod_name)
{
    for (LIST_ENTRY* it = head->ForwardLink; it && it != head; it = it->ForwardLink)
    {
        KLDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(it, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (!u_wcsnicmp(entry->BaseDllName.Buffer, mod_name, entry->BaseDllName.Length))
        {
            return entry;
        }
    }
    return NULL;
}

extern VOID* g_kernel_base;
VOID* GetLoadedModuleBase(const CASE_INSENSITIVE CHAR16* mod_name)
{
    static LIST_ENTRY* PsLoadedModuleList;
    if (!PsLoadedModuleList)
        PsLoadedModuleList = FindExport(g_kernel_base, "PsLoadedModuleList");
    
    KLDR_DATA_TABLE_ENTRY* module = GetModuleFromList(PsLoadedModuleList, mod_name);
    if (!module)
        return NULL;
    return module->DllBase;
}

// This formats a guid in microsoft mixed endian. The out buffer must be 39 bytes
CHAR16* const FormatGuid(CHAR16* const output, GUID guid)
{
    CHAR16* formatted = CatSPrint(NULL, L"{%8X-%4X-%4X-%4X-%2X%2X%2X%2X%2X%2X}",
        guid.Data1, guid.Data2, guid.Data3, *(UINT16*)guid.Data4,
        guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
    StrCpyS(output, 39, formatted);
    FreePool(formatted);
    return output;
}

static BOOLEAN isDigit(CHAR8 character)
{
    return (character >= '0' && character <= '9') || (character >= 'A' && character <= 'F') || (character >= 'a' && character <= 'f');
}

static UINT8 ByteFromString(const CHAR8* str)
{
    UINT8 byte = 0;
    CHAR8 hi_digit = str[0];
    if (hi_digit >= '0' && hi_digit <= '9')
        byte |= ((hi_digit - '0') << 4);
    else if (hi_digit >= 'A' && hi_digit <= 'F')
        byte |= ((hi_digit - 'A' + 10) << 4);
    else if (hi_digit >= 'a' && hi_digit <= 'f')
        byte |= ((hi_digit - 'a' + 10) << 4);
    else return 0; // unreachable

    CHAR8 lo_digit = str[1];
    if (lo_digit >= '0' && lo_digit <= '9')
        byte |= (lo_digit - '0');
    else if (lo_digit >= 'A' && lo_digit <= 'F')
        byte |= (lo_digit - 'A' + 10);
    else if (lo_digit >= 'a' && lo_digit <= 'f')
        byte |= (lo_digit - 'a' + 10);
    else return 0; // unreachable

    return byte;
}

_declspec(noinline) INTN ascii_strcmp(const CHAR8* first, const CHAR8* second)
{
    return AsciiStrCmp(first, second);
}

// Pattern strings are ascii strings containing 2-character tokens separated by spaces. These tokens can either be 2 hex digits or 2 question marks. A pattern string musn't end in a space.
// Example: "ef cd ab 89 67 45 23 01 ?? ?? DE AD BE EF" is a valid pattern string
// Some invalid strings: "", "?a", "123456deadbeef", "3a ? 3b", "01, 23, 45", "0x01 0x02 0x03", "01 02 03 ?? "
static UINT64 ValidatePatternString(const CHAR8* const pattern_string)
{
    for (int i = 0; pattern_string[i]; i += 3)
    {
        // Validate that there are no null characters in the first 2
        if (!(pattern_string[i] && pattern_string[i + 1])) // Short-circuit evaluation prevents reads past the null terminator :)
            return 0;
        // Third can be either a null terminator or a space
        if (pattern_string[i + 2] != ' ' && pattern_string[i + 2] != '\0')
            return 0;
        // First 2 can either both be question marks, or both be hex digits
        if (!(isDigit(pattern_string[i]) || pattern_string[i] == '?') || !(isDigit(pattern_string[i + 1]) || pattern_string[i + 1] == '?'))
            return 0;
        if (isDigit(pattern_string[i]) != isDigit(pattern_string[i + 1]))
            return 0;

        // We have a valid 3-byte block. If it contains a null terminator, we return, otherwise continue
        if (pattern_string[i + 2] == '\0')
            return (i / 3) + 1;
    }
    // This means an otherwise valid string ended in a space. We will consider this invalid.
    return 0;
}

// A range musn't cross 0 or 7fffffffffff, and it musn't touch non-canonical territory.
static BOOLEAN ValidateRange(VOID* start, UINT64 size, BOOLEAN backwards)
{
    if (size > 0x7fffffffffff)
        return FALSE;

    UINT64 sign_extend = (UINT64)start >> 47;
    if (sign_extend != 0x1ffff && sign_extend != 0x00000)
        return FALSE;

    VOID* end = (VOID*)(backwards ? (UINT8*)start - size : (UINT8*)start + size);
    sign_extend = (UINT64)end >> 47;
    if (sign_extend != 0x1ffff && sign_extend != 0x00000)
        return FALSE;

    if (backwards)
    {
        if (end > start)
            return FALSE;
    }
    else
    {
        if (end < start)
            return FALSE;
    }

    return TRUE;
}

UINT64 PatternScan(const CHAR8* pattern, VOID* address, UINT64 size, BOOLEAN backwards)
{
    if (!ValidateRange(address, size, backwards)) return 0;
    UINT64 length = ValidatePatternString(pattern);
    if (!length)
        return 0;

    // It is forbidden for the end of the pattern to hang over the end of the range (or the beginning if the pattern is backwards)
    size -= (length - 1);
    if (backwards)
        address = (VOID*)((UINT8*)address - (length - 1));

    for (UINT8* i = (UINT8*)address; backwards ? i > (UINT8*)address - size : i < (UINT8*)address + size; backwards ? --i : ++i)
    {
        for (int j = 0; j < length; ++j)
        {
            if (pattern[3 * j] != '?')
            {
                UINT8 byte = ByteFromString(pattern + (3 * j));
                if (byte != i[j])
                    break;
            }
            if (j == length - 1)
                return (UINT64)i;
        }
    }

    return 0;
}

void Copy_Memory(const VOID* Dest, const VOID* Src, UINTN Len) // CopyMem relies on boot services
{
    for (int i = 0; i < Len; ++i)
    {
        ((UINT8*)Dest)[i] = ((UINT8*)Src)[i];
    }
}

void Readonly_Copy_Memory(const VOID* Dest, const VOID* Src, UINTN Len)
{
    // This horrendous spagetti code allows interrupt safety and to write readonly regardless of the status of control registers
    UINT64 interrupts_enabled = __readeflags() & 0x200;
    if (interrupts_enabled)
        _disable();
    UINT64 cr4 = __readcr4();
    __writecr4(cr4 & ~0x800000ull); // Disable CET
    UINT64 cr0 = __readcr0();
    __writecr0(cr0 & ~0x10000ull); // Disable WP

    Copy_Memory(Dest, Src, Len);

    __writecr0(cr0);
    __writecr4(cr4);
    if (interrupts_enabled)
        _enable();
}

void Set_Memory(VOID* Dest, UINTN Len, CHAR8 Val)
{
    for (int i = 0; i < Len; ++i)
    {
        ((volatile UINT8*)Dest)[i] = Val;
    }
}

```

`util.h`:

```h
#pragma once
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/BaseMemoryLib.h>
#include "ntdef.h"

#define CASE_INSENSITIVE
#define CASE_SENSITIVE


CHAR16* const FormatGuid(CHAR16* const output, GUID guid);

UINT64 PatternScan(const CHAR8* pattern, VOID* address, UINT64 size, BOOLEAN backwards);

KLDR_DATA_TABLE_ENTRY* GetModuleFromList(LIST_ENTRY* head, const CASE_INSENSITIVE CHAR16* mod_name);
VOID* GetLoadedModuleBase(const CASE_INSENSITIVE CHAR16* mod_name);

UINT32* FindExportEntry(VOID* module, const CASE_SENSITIVE CHAR8* routine_name);
VOID* FindExport(VOID* module, const CASE_SENSITIVE CHAR8* routine_name);

UINT32* FindExportEntryByOrdinal(VOID* module, UINT16 ordinal);
VOID* FindExportByOrdinal(VOID* module, UINT16 ordinal);

VOID** FindImportEntry(VOID* module, const CASE_INSENSITIVE CHAR8* routine_module, const CASE_SENSITIVE CHAR8* routine_name);
VOID* FindImport(VOID* module, const CASE_INSENSITIVE CHAR8* routine_module, const CASE_SENSITIVE CHAR8* routine_name);

INTN u_wcsnicmp(const CHAR16* First, const CHAR16* Second, UINTN Length);
_declspec(noinline) INTN ascii_strcmp(const CHAR8* first, const CHAR8* second); // This is to make it easier to debug, because the AsciiStrCmp creates shit assembly
void Copy_Memory(const VOID* Dest, const VOID* Src, UINTN Len);
void Readonly_Copy_Memory(const VOID* Dest, const VOID* Src, UINTN Len);
void Set_Memory(VOID* Dest, UINTN Len, CHAR8 Val);
```