Project Path: arc_shalzuth_UnrealSharp_nzhupk2o

Source Tree:

```txt
arc_shalzuth_UnrealSharp_nzhupk2o
├── FUNDING.yml
├── LICENSE
├── README.md
├── UEInspector
│   ├── Inspector.Designer.cs
│   ├── Inspector.cs
│   ├── Inspector.resx
│   ├── Program.cs
│   └── UEInspector.csproj
├── UnrealSharp
│   ├── Extensions.cs
│   ├── Hotkeys.cs
│   ├── Memory.cs
│   ├── SigScan.cs
│   ├── UnrealEngine.cs
│   └── UnrealSharp.csproj
├── UnrealSharp.sln
└── example.png

```

`FUNDING.yml`:

```yml
patreon: shalzuth
custom: shalzuth.com
```

`LICENSE`:

```
MIT License

Copyright (c) 2021 shalzuth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# UnrealSharp
 UnrealSharp is a helper framework to create extra sensory perception, radar, and other tools and game mods for UnrealEngine games.

# What is this and is it shiny?
 Unreal Sharp is written in C#, and works by using reading process memory. The framework is setup to be dynamic for multiple games, as well as being able to dynamically reference fields by name. While it is external, it is also one of, if not the only, external that can call internal functions.
 
# How does this work
 This project heavily relies on Unreal Engine's reflection system, using strings to dump out game info.
 
# Screenshot or it didn't happen
 ![Preview](example.png)

# Legal stuff
 shalzuth isn't endorsed by Epic Games and doesn’t reflect the views or opinions of Epic Games or anyone officially involved in producing or managing Epic Games content and materials are trademarks and copyrights of Epic Games
```

`UEInspector/Inspector.Designer.cs`:

```cs
namespace UEInspector
{
    partial class Inspector
    {
        /// <summary>
        ///  Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        ///  Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        ///  Required method for Designer support - do not modify
        ///  the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            actorList = new ListBox();
            dump = new Button();
            actorInfo = new ListBox();
            dumpSDK = new Button();
            SuspendLayout();
            // 
            // actorList
            // 
            actorList.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left;
            actorList.FormattingEnabled = true;
            actorList.ItemHeight = 15;
            actorList.Location = new Point(17, 55);
            actorList.Name = "actorList";
            actorList.Size = new Size(461, 604);
            actorList.TabIndex = 0;
            actorList.SelectedIndexChanged += actorList_SelectedIndexChanged;
            // 
            // dump
            // 
            dump.Location = new Point(17, 15);
            dump.Name = "dump";
            dump.Size = new Size(115, 23);
            dump.TabIndex = 1;
            dump.Text = "DumpScene";
            dump.UseVisualStyleBackColor = true;
            dump.Click += dump_Click;
            // 
            // actorInfo
            // 
            actorInfo.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
            actorInfo.FormattingEnabled = true;
            actorInfo.ItemHeight = 15;
            actorInfo.Location = new Point(484, 12);
            actorInfo.Name = "actorInfo";
            actorInfo.Size = new Size(678, 649);
            actorInfo.TabIndex = 2;
            actorInfo.SelectedIndexChanged += actorInfo_SelectedIndexChanged;
            // 
            // dumpSDK
            // 
            dumpSDK.Location = new Point(146, 19);
            dumpSDK.Name = "dumpSDK";
            dumpSDK.Size = new Size(75, 23);
            dumpSDK.TabIndex = 3;
            dumpSDK.Text = "DumpSDK";
            dumpSDK.UseVisualStyleBackColor = true;
            dumpSDK.Click += dumpSDK_Click;
            // 
            // Inspector
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            ClientSize = new Size(1162, 683);
            Controls.Add(dumpSDK);
            Controls.Add(actorInfo);
            Controls.Add(dump);
            Controls.Add(actorList);
            Name = "Inspector";
            Text = "Unreal Engine Inspector";
            ResumeLayout(false);
        }

        #endregion

        private ListBox actorList;
        private Button dump;
        private ListBox actorInfo;
        private Button dumpSDK;
    }
}
```

`UEInspector/Inspector.cs`:

```cs
using System;
using System.Diagnostics;
using UnrealSharp;

namespace UEInspector
{
    public partial class Inspector : Form
    {
        Process process;
        public Inspector()
        {
            InitializeComponent();
            Control.CheckForIllegalCrossThreadCalls = false;
            AddProcesses();
        }
        void AddProcesses()
        {
            var window = Memory.FindWindowEx(IntPtr.Zero, IntPtr.Zero, "UnrealWindow", null);
            if (window != IntPtr.Zero)
            {
                Memory.GetWindowThreadProcessId(window, out Int32 unrealProcId);
                process = Process.GetProcessById(unrealProcId);
                new UnrealEngine(new Memory(process)).UpdateAddresses();
            }
        }
        void DisplayActorInfo(nint actorAddr)
        {
            actorInfo.Items.Clear();
            actorInfo.Text = "";
            var actor = new UEObject(actorAddr);
            actorInfo.Items.Add(actor.Address + " : " + actor.GetFullPath() + " : " + actor.ClassName);
            var tempEntity = actor.ClassAddr;
            while (true)
            {
                var classNameIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(tempEntity + UEObject.nameOffset);
                var name = UEObject.GetName(classNameIndex);

                actorInfo.Items.Add(name);
                var field = tempEntity + UEObject.childPropertiesOffset - UEObject.fieldNextOffset;
                while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.fieldNextOffset)) > 0)
                {
                    var fName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(field + UEObject.fieldNameOffset));
                    var fType = actor.GetFieldType(field);
                    var fValue = "(" + field.ToString() + ")";
                    var offset = actor.GetFieldOffset(field);
                    if (fType == "BoolProperty")
                    {
                        fType = "Boolean";
                        fValue = actor[fName].Flag.ToString();
                    }
                    else if (fType == "FloatProperty")
                    {
                        fType = "Single";
                        fValue = BitConverter.ToSingle(BitConverter.GetBytes(actor[fName].Value), 0).ToString();
                    }
                    else if (fType == "IntProperty")
                    {
                        fType = "Int32";
                        fValue = actor[fName].Value.ToString();
                    }
                    else if (fType == "ObjectProperty" || fType == "StructProperty")
                    {
                        var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<int>(UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.propertySize) + UEObject.nameOffset);
                        fType = UEObject.GetName(structFieldIndex);
                    }
                    actorInfo.Items.Add("  " + fType + " " + fName + " = " + fValue);
                }

                field = tempEntity + UEObject.childrenOffset - UEObject.funcNextOffset;
                while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.funcNextOffset)) > 0)
                {
                    var fName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(field + UEObject.nameOffset));
                    actorInfo.Items.Add("  func " + fName);
                }
                tempEntity = UnrealEngine.Memory.ReadProcessMemory<nint>(tempEntity + UEObject.structSuperOffset);
                if (tempEntity == 0) break;
            }
        }

        private void dump_Click(object sender, EventArgs e)
        {
            actorList.Items.Clear();
            var World = new UEObject(UnrealEngine.Memory.ReadProcessMemory<nint>(UnrealEngine.GWorldPtr));
            var Levels = World["Levels"];
            for (var levelIndex = 0; levelIndex < Levels.Num; levelIndex++)
            {
                var Level = Levels[levelIndex];
                actorList.Items.Add(Level.Address + " : " + Level.GetFullPath());
                var Actors = new UEObject(Level.Address + 0xA8); // todo fix hardcoded 0xA8 offset...
                for (var i = 0; i < Actors.Num; i++)
                {
                    var Actor = Actors[i];
                    if (Actor.Address == 0) continue;
                    if (Actor.IsA("Class /Script/Engine.Actor"))
                        actorList.Items.Add(Actor.Address + " : " + Actor.GetFullPath());
                }
            }

        }
        private void actorList_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (process == null) return;
                var actorAddr = nint.Parse(actorList.SelectedItem.ToString().Split(':')[0].Replace(" ", ""));
                DisplayActorInfo(actorAddr);
            }
            catch { }
        }

        private void actorInfo_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                var actorAddr = nint.Parse(actorInfo.Items[0].ToString().Split(':')[0].Replace(" ", ""));
                var fName = actorInfo.SelectedItem.ToString().Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[1];
                var a = new UEObject(actorAddr)[fName];
                DisplayActorInfo(a.Address);
            }
            catch { }
        }

        private void dumpSDK_Click(object sender, EventArgs e)
        {
            UnrealEngine.Instance.DumpSdk();
        }
    }
}
```

`UEInspector/Inspector.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing"">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`UEInspector/Program.cs`:

```cs
namespace UEInspector
{
    internal static class Program
    {
        /// <summary>
        ///  The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            // To customize application configuration such as set high DPI settings or default font,
            // see https://aka.ms/applicationconfiguration.
            ApplicationConfiguration.Initialize();
            Application.Run(new Inspector());
        }
    }
}
```

`UEInspector/UEInspector.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <UseWindowsForms>true</UseWindowsForms>
    <ImplicitUsings>enable</ImplicitUsings>
    <PlatformTarget>x64</PlatformTarget>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\UnrealSharp\UnrealSharp.csproj" />
  </ItemGroup>

</Project>
```

`UnrealSharp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.33808.371
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnrealSharp", "UnrealSharp\UnrealSharp.csproj", "{AC310529-9143-4CA3-8264-AA594DEA3D3F}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UEInspector", "UEInspector\UEInspector.csproj", "{B34FF128-E068-4FE1-854A-3A99611A2C3E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC310529-9143-4CA3-8264-AA594DEA3D3F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AC310529-9143-4CA3-8264-AA594DEA3D3F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AC310529-9143-4CA3-8264-AA594DEA3D3F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AC310529-9143-4CA3-8264-AA594DEA3D3F}.Release|Any CPU.Build.0 = Release|Any CPU
		{B34FF128-E068-4FE1-854A-3A99611A2C3E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B34FF128-E068-4FE1-854A-3A99611A2C3E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B34FF128-E068-4FE1-854A-3A99611A2C3E}.Release|Any CPU.ActiveCfg = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5E6CBD91-0A6A-433A-8BF1-956961BD2015}
	EndGlobalSection
EndGlobal

```

`UnrealSharp/Extensions.cs`:

```cs
using System;
using System.Drawing;
using System.Numerics;
using System.Runtime.InteropServices;

namespace UnrealSharp
{
    public static class Extensions
    {
        public struct Vector3Double
        {
            public double X;
            public double Y;
            public double Z;
            public Vector3 ToFloats()
            {
                return new Vector3((float)X, (float)Y, (float)Z);
            }
        }
        public static Single Mult(this Vector3 v, Vector3 s) => v.X * s.X + v.Y * s.Y + v.Z * s.Z;
        public static void GetAxes(this Vector3 v, out Vector3 x, out Vector3 y, out Vector3 z)
        {
            var m = v.ToMatrix();

            x = new Vector3(m[0, 0], m[0, 1], m[0, 2]);
            y = new Vector3(m[1, 0], m[1, 1], m[1, 2]);
            z = new Vector3(m[2, 0], m[2, 1], m[2, 2]);
        }
        public static Vector3 FromRotator(this Vector3 v)
        {
            float radPitch = (float)(v.X * Math.PI / 180f);
            float radYaw = (float)(v.Y * Math.PI / 180f);
            float SP = (float)Math.Sin(radPitch);
            float CP = (float)Math.Cos(radPitch);
            float SY = (float)Math.Sin(radYaw);
            float CY = (float)Math.Cos(radYaw);
            return new Vector3(CP * CY, CP * SY, SP);
        }
        public static Single[,] ToMatrix(this Vector3 v, Vector3 origin = default(Vector3))
        {
            if (origin == default)
                origin = default;
            var radPitch = (Single)(v.X * Math.PI / 180f);
            var radYaw = (Single)(v.Y * Math.PI / 180f);
            var radRoll = (Single)(v.Z * Math.PI / 180f);

            var SP = (Single)Math.Sin(radPitch);
            var CP = (Single)Math.Cos(radPitch);
            var SY = (Single)Math.Sin(radYaw);
            var CY = (Single)Math.Cos(radYaw);
            var SR = (Single)Math.Sin(radRoll);
            var CR = (Single)Math.Cos(radRoll);

            var m = new Single[4, 4];
            m[0, 0] = CP * CY;
            m[0, 1] = CP * SY;
            m[0, 2] = SP;
            m[0, 3] = 0f;

            m[1, 0] = SR * SP * CY - CR * SY;
            m[1, 1] = SR * SP * SY + CR * CY;
            m[1, 2] = -SR * CP;
            m[1, 3] = 0f;

            m[2, 0] = -(CR * SP * CY + SR * SY);
            m[2, 1] = CY * SR - CR * SP * SY;
            m[2, 2] = CR * CP;
            m[2, 3] = 0f;

            m[3, 0] = origin.X;
            m[3, 1] = origin.Y;
            m[3, 2] = origin.Z;
            m[3, 3] = 1f;
            return m;
        }

        public static Vector3 CalcRotation(this Vector3 source, Vector3 destination, Vector3 origAngles, Single smooth)
        {
            var angles = new Vector3();
            var diff = source - destination;
            var hyp = Math.Sqrt(diff.X * diff.X + diff.Y * diff.Y);
            angles.Y = (Single)Math.Atan(diff.Y / diff.X) * 57.295779513082f;
            angles.X = -(Single)Math.Atan(diff.Z / hyp) * 57.295779513082f;
            angles.Z = 0.0f;
            if (diff.X >= 0.0)
            {
                if (angles.Y > 0)
                    angles.Y -= 180.0f;
                else
                    angles.Y += 180.0f;
            }
            if (smooth > 0 && Math.Abs(angles.Y - origAngles.Y) < 180.0f)
                angles -= ((angles - origAngles) * smooth);
            return angles;
        }
        public static class Serializer
        {
            public static unsafe byte[] Serialize<T>(T value) where T : unmanaged
            {
                byte[] buffer = new byte[sizeof(T)];

                fixed (byte* bufferPtr = buffer)
                {
                    Buffer.MemoryCopy(&value, bufferPtr, sizeof(T), sizeof(T));
                }

                return buffer;
            }

            public static unsafe T Deserialize<T>(byte[] buffer, int offset = 0) where T : unmanaged
            {
                T result = new T();

                fixed (byte* bufferPtr = buffer)
                {
                    Buffer.MemoryCopy(bufferPtr + offset, &result, sizeof(T), sizeof(T));
                }

                return result;
            }
        }
        public struct Transform
        {
            public Vector3Double Rotation;
            public Double RotationW;
            public Vector3Double Translation;
            public Double TranslationW;
            public Vector3Double Scale;
            public Double ScaleW;
            public Matrix4x4 ToMatrixWithScale()
            {
                var x2 = Rotation.X + Rotation.X;
                var y2 = Rotation.Y + Rotation.Y;
                var z2 = Rotation.Z + Rotation.Z;

                var xx2 = Rotation.X * x2;
                var yy2 = Rotation.Y * y2;
                var zz2 = Rotation.Z * z2;

                var yz2 = Rotation.Y * z2;
                var wx2 = RotationW * x2;

                var xy2 = Rotation.X * y2;
                var wz2 = RotationW * z2;

                var xz2 = Rotation.X * z2;
                var wy2 = RotationW * y2;

                var m = new Matrix4x4
                {
                    M41 = (float)Translation.X,
                    M42 = (float)Translation.Y,
                    M43 = (float)Translation.Z,
                    M11 = (float)((1.0f - (yy2 + zz2)) * Scale.X),
                    M22 = (float)((1.0f - (xx2 + zz2)) * Scale.Y),
                    M33 = (float)((1.0f - (xx2 + yy2)) * Scale.Z),
                    M32 = (float)((yz2 - wx2) * Scale.Z),
                    M23 = (float)((yz2 + wx2) * Scale.Y),
                    M21 = (float)((xy2 - wz2) * Scale.Y),
                    M12 = (float)((xy2 + wz2) * Scale.X),
                    M31 = (float)((xz2 + wy2) * Scale.Z),
                    M13 = (float)((xz2 - wy2) * Scale.X),
                    M14 = 0.0f,
                    M24 = 0.0f,
                    M34 = 0.0f,
                    M44 = 1.0f
                };
                return m;
            }
            public Single[,] ToMatrixWithScale2()
            {
                var m = new Single[4, 4];

                m[3, 0] = (float)Translation.X;
                m[3, 1] = (float)Translation.Y;
                m[3, 2] = (float)Translation.Z;

                var x2 = Rotation.X * 2;
                var y2 = Rotation.Y * 2;
                var z2 = Rotation.Z * 2;

                var xx2 = Rotation.X * x2;
                var yy2 = Rotation.Y * y2;
                var zz2 = Rotation.Z * z2;
                m[0, 0] = (float)((1.0f - (yy2 + zz2)) * Scale.X);
                m[1, 1] = (float)((1.0f - (xx2 + zz2)) * Scale.Y);
                m[2, 2] = (float)((1.0f - (xx2 + yy2)) * Scale.Z);

                var yz2 = Rotation.Y * z2;
                var wx2 = RotationW * x2;
                m[2, 1] = (float)((yz2 - wx2) * Scale.Z);
                m[1, 2] = (float)((yz2 + wx2) * Scale.Y);

                var xy2 = Rotation.X * y2;
                var wz2 = RotationW * z2;
                m[1, 0] = (float)((xy2 - wz2) * Scale.Y);
                m[0, 1] = (float)((xy2 + wz2) * Scale.X);

                var xz2 = Rotation.X * z2;
                var wy2 = RotationW * y2;
                m[2, 0] = (float)((xz2 + wy2) * Scale.Z);
                m[0, 2] = (float)((xz2 - wy2) * Scale.X);

                m[0, 3] = 0.0f;
                m[1, 3] = 0.0f;
                m[2, 3] = 0.0f;
                m[3, 3] = 1.0f;

                return m;
            }
        }
        static Vector3 LastRotation = Vector3.Zero;
        static Vector3 vAxisX = Vector3.Zero;
        static Vector3 vAxisY = Vector3.Zero;
        static Vector3 vAxisZ = Vector3.Zero;
        public static Vector2 WorldToScreen(Vector3 worldLocation, Vector3 cameraLocation, Vector3 cameraRotation, Single fieldOfView, int ScreenCenterX, int ScreenCenterY)
        {
            if (LastRotation != cameraRotation)
            {
                cameraRotation.GetAxes(out vAxisX, out vAxisY, out vAxisZ);
                LastRotation = cameraRotation;
            }
            var vDelta = worldLocation - cameraLocation;
            var vTransformed = new Vector3(vDelta.Mult(vAxisY), vDelta.Mult(vAxisZ), vDelta.Mult(vAxisX));
            if (vTransformed.Z < 1f) vTransformed.Z = 1f;
            var fullScreen = new Vector2(ScreenCenterX + vTransformed.X * (ScreenCenterX / (float)Math.Tan(fieldOfView * (float)Math.PI / 360)) / vTransformed.Z,
                ScreenCenterY - vTransformed.Y * (ScreenCenterX / (float)Math.Tan(fieldOfView * (float)Math.PI / 360)) / vTransformed.Z);
            return new Vector2(fullScreen.X, fullScreen.Y);
        }
        [DllImport("user32")] public static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);
        public static void AimAtPos(Vector2 location, Single smoothSpeed = 8)
        {
            Single ScreenCenterX = 2560 / 2;
            Single ScreenCenterY = 1440 / 2;
            if (Math.Abs(location.X - ScreenCenterX) > ScreenCenterX / 4) return;
            if (Math.Abs(location.Y - ScreenCenterY) > ScreenCenterY / 4) return;
            Single TargetX = 0;
            Single TargetY = 0;
            if (location.X > ScreenCenterX)
            {
                TargetX = -(ScreenCenterX - location.X);
            }
            else if (location.X < ScreenCenterX)
            {
                TargetX = location.X - ScreenCenterX;
            }
            if (location.Y > ScreenCenterY)
            {
                TargetY = -(ScreenCenterY - location.Y);
            }
            else if (location.Y < ScreenCenterY)
            {
                TargetY = location.Y - ScreenCenterY;
            }
            TargetX /= smoothSpeed;
            TargetY /= smoothSpeed;
            var maxSmooth = 15;
            if (TargetX > maxSmooth) TargetX = maxSmooth;
            if (TargetY > maxSmooth) TargetY = maxSmooth;
            if (TargetX < -maxSmooth) TargetX = -maxSmooth;
            if (TargetY < -maxSmooth) TargetY = -maxSmooth;
            mouse_event(0x0001, (int)Math.Round(TargetX), (int)Math.Round(TargetY), 0, 0);
        }
        [DllImport("user32.dll")] static extern uint SendInput(uint nInputs, [MarshalAs(UnmanagedType.LPArray), In] INPUT[] pInputs, int cbSize);
        struct INPUT
        {
            public UInt32 Type;
            public MOUSEKEYBDHARDWAREINPUT Data;
        }
        [StructLayout(LayoutKind.Explicit)] struct MOUSEKEYBDHARDWAREINPUT
        {
            [FieldOffset(0)] public MOUSEINPUT Mouse;
        }
        struct MOUSEINPUT
        {
            public Int32 X;
            public Int32 Y;
            public UInt32 MouseData;
            public UInt32 Flags;
            public UInt32 Time;
            public IntPtr ExtraInfo;
        }
        public static async Task MouseLeftClick()
        {
            //var inputs = new INPUT[] { new INPUT { Type = 0, Data = new MOUSEKEYBDHARDWAREINPUT { Mouse = new MOUSEINPUT { Flags = 2 } } }, new INPUT { Type = 0, Data = new MOUSEKEYBDHARDWAREINPUT { Mouse = new MOUSEINPUT { Flags = 4 } } } };
            //SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
            {
                var inputs = new INPUT[] { new INPUT { Type = 0, Data = new MOUSEKEYBDHARDWAREINPUT { Mouse = new MOUSEINPUT { Flags = 2 } } } };
                SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
            }
            {
                await Task.Delay(15);
                var inputs = new INPUT[] { new INPUT { Type = 0, Data = new MOUSEKEYBDHARDWAREINPUT { Mouse = new MOUSEINPUT { Flags = 4 } } } };
                SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
            }
        }
    }
}
```

`UnrealSharp/Hotkeys.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace UnrealSharp
{
    public class Hotkeys
    {
        [DllImport("user32")] static extern short GetKeyState(int keyCode);
        [DllImport("user32")] static extern short GetAsyncKeyState(int keyCode);
        static Dictionary<Keys, Boolean> ToggleVals = new Dictionary<Keys, Boolean>();
        static Dictionary<Keys, Boolean> SingleVals = new Dictionary<Keys, Boolean>();
        public static Boolean ToggledKey(Keys keyCode)
        {
            if (!ToggleVals.ContainsKey(keyCode)) ToggleVals.Add(keyCode, false);
            if (SinglePress(keyCode))
                ToggleVals[keyCode] = !ToggleVals[keyCode];
            return ToggleVals[keyCode];
        }
        public static Boolean SinglePress(Keys keyCode)
        {
            if (!SingleVals.ContainsKey(keyCode)) SingleVals.Add(keyCode, false);
            if (IsPressed(keyCode))
            {
                if (SingleVals[keyCode]) return false;
                SingleVals[keyCode] = true;
                return true;
            }
            else SingleVals[keyCode] = false;
            return false;
        }
        public static Boolean IsPressed(Keys keyCode)
        {
            return (GetAsyncKeyState((int)keyCode) & 0x8000) != 0;
        }
    }
    public enum Keys : ushort
    {
        LeftButton = 0x01,
        RightButton = 0x02,
        Cancel = 0x03,
        MiddleButton = 0x04,
        ExtraButton1 = 0x05,
        ExtraButton2 = 0x06,
        Back = 0x08,
        Tab = 0x09,
        Clear = 0x0C,
        Return = 0x0D,
        Shift = 0x10,
        Control = 0x11,
        /// <summary></summary>
        Menu = 0x12,
        /// <summary></summary>
        Pause = 0x13,
        /// <summary></summary>
        CapsLock = 0x14,
        /// <summary></summary>
        Kana = 0x15,
        /// <summary></summary>
        Hangeul = 0x15,
        /// <summary></summary>
        Hangul = 0x15,
        /// <summary></summary>
        Junja = 0x17,
        /// <summary></summary>
        Final = 0x18,
        /// <summary></summary>
        Hanja = 0x19,
        /// <summary></summary>
        Kanji = 0x19,
        /// <summary></summary>
        Escape = 0x1B,
        /// <summary></summary>
        Convert = 0x1C,
        /// <summary></summary>
        NonConvert = 0x1D,
        /// <summary></summary>
        Accept = 0x1E,
        /// <summary></summary>
        ModeChange = 0x1F,
        /// <summary></summary>
        Space = 0x20,
        /// <summary></summary>
        Prior = 0x21,
        /// <summary></summary>
        Next = 0x22,
        /// <summary></summary>
        End = 0x23,
        /// <summary></summary>
        Home = 0x24,
        /// <summary></summary>
        Left = 0x25,
        /// <summary></summary>
        Up = 0x26,
        /// <summary></summary>
        Right = 0x27,
        /// <summary></summary>
        Down = 0x28,
        /// <summary></summary>
        Select = 0x29,
        /// <summary></summary>
        Print = 0x2A,
        /// <summary></summary>
        Execute = 0x2B,
        /// <summary></summary>
        Snapshot = 0x2C,
        /// <summary></summary>
        Insert = 0x2D,
        /// <summary></summary>
        Delete = 0x2E,
        /// <summary></summary>
        Help = 0x2F,
        /// <summary></summary>
        N0 = 0x30,
        /// <summary></summary>
        N1 = 0x31,
        /// <summary></summary>
        N2 = 0x32,
        /// <summary></summary>
        N3 = 0x33,
        /// <summary></summary>
        N4 = 0x34,
        /// <summary></summary>
        N5 = 0x35,
        /// <summary></summary>
        N6 = 0x36,
        /// <summary></summary>
        N7 = 0x37,
        /// <summary></summary>
        N8 = 0x38,
        /// <summary></summary>
        N9 = 0x39,
        /// <summary></summary>
        A = 0x41,
        /// <summary></summary>
        B = 0x42,
        /// <summary></summary>
        C = 0x43,
        /// <summary></summary>
        D = 0x44,
        /// <summary></summary>
        E = 0x45,
        /// <summary></summary>
        F = 0x46,
        /// <summary></summary>
        G = 0x47,
        /// <summary></summary>
        H = 0x48,
        /// <summary></summary>
        I = 0x49,
        /// <summary></summary>
        J = 0x4A,
        /// <summary></summary>
        K = 0x4B,
        /// <summary></summary>
        L = 0x4C,
        /// <summary></summary>
        M = 0x4D,
        /// <summary></summary>
        N = 0x4E,
        /// <summary></summary>
        O = 0x4F,
        /// <summary></summary>
        P = 0x50,
        /// <summary></summary>
        Q = 0x51,
        /// <summary></summary>
        R = 0x52,
        /// <summary></summary>
        S = 0x53,
        /// <summary></summary>
        T = 0x54,
        /// <summary></summary>
        U = 0x55,
        /// <summary></summary>
        V = 0x56,
        /// <summary></summary>
        W = 0x57,
        /// <summary></summary>
        X = 0x58,
        /// <summary></summary>
        Y = 0x59,
        /// <summary></summary>
        Z = 0x5A,
        /// <summary></summary>
        LeftWindows = 0x5B,
        /// <summary></summary>
        RightWindows = 0x5C,
        /// <summary></summary>
        Application = 0x5D,
        /// <summary></summary>
        Sleep = 0x5F,
        /// <summary></summary>
        Numpad0 = 0x60,
        /// <summary></summary>
        Numpad1 = 0x61,
        /// <summary></summary>
        Numpad2 = 0x62,
        /// <summary></summary>
        Numpad3 = 0x63,
        /// <summary></summary>
        Numpad4 = 0x64,
        /// <summary></summary>
        Numpad5 = 0x65,
        /// <summary></summary>
        Numpad6 = 0x66,
        /// <summary></summary>
        Numpad7 = 0x67,
        /// <summary></summary>
        Numpad8 = 0x68,
        /// <summary></summary>
        Numpad9 = 0x69,
        /// <summary></summary>
        Multiply = 0x6A,
        /// <summary></summary>
        Add = 0x6B,
        /// <summary></summary>
        Separator = 0x6C,
        /// <summary></summary>
        Subtract = 0x6D,
        /// <summary></summary>
        Decimal = 0x6E,
        /// <summary></summary>
        Divide = 0x6F,
        /// <summary></summary>
        F1 = 0x70,
        /// <summary></summary>
        F2 = 0x71,
        /// <summary></summary>
        F3 = 0x72,
        /// <summary></summary>
        F4 = 0x73,
        /// <summary></summary>
        F5 = 0x74,
        /// <summary></summary>
        F6 = 0x75,
        /// <summary></summary>
        F7 = 0x76,
        /// <summary></summary>
        F8 = 0x77,
        /// <summary></summary>
        F9 = 0x78,
        /// <summary></summary>
        F10 = 0x79,
        /// <summary></summary>
        F11 = 0x7A,
        /// <summary></summary>
        F12 = 0x7B,
        /// <summary></summary>
        F13 = 0x7C,
        /// <summary></summary>
        F14 = 0x7D,
        /// <summary></summary>
        F15 = 0x7E,
        /// <summary></summary>
        F16 = 0x7F,
        /// <summary></summary>
        F17 = 0x80,
        /// <summary></summary>
        F18 = 0x81,
        /// <summary></summary>
        F19 = 0x82,
        /// <summary></summary>
        F20 = 0x83,
        /// <summary></summary>
        F21 = 0x84,
        /// <summary></summary>
        F22 = 0x85,
        /// <summary></summary>
        F23 = 0x86,
        /// <summary></summary>
        F24 = 0x87,
        /// <summary></summary>
        NumLock = 0x90,
        /// <summary></summary>
        ScrollLock = 0x91,
        /// <summary></summary>
        NEC_Equal = 0x92,
        /// <summary></summary>
        Fujitsu_Jisho = 0x92,
        /// <summary></summary>
        Fujitsu_Masshou = 0x93,
        /// <summary></summary>
        Fujitsu_Touroku = 0x94,
        /// <summary></summary>
        Fujitsu_Loya = 0x95,
        /// <summary></summary>
        Fujitsu_Roya = 0x96,
        /// <summary></summary>
        LeftShift = 0xA0,
        /// <summary></summary>
        RightShift = 0xA1,
        /// <summary></summary>
        LeftControl = 0xA2,
        /// <summary></summary>
        RightControl = 0xA3,
        /// <summary></summary>
        LeftMenu = 0xA4,
        /// <summary></summary>
        RightMenu = 0xA5,
        /// <summary></summary>
        BrowserBack = 0xA6,
        /// <summary></summary>
        BrowserForward = 0xA7,
        /// <summary></summary>
        BrowserRefresh = 0xA8,
        /// <summary></summary>
        BrowserStop = 0xA9,
        /// <summary></summary>
        BrowserSearch = 0xAA,
        /// <summary></summary>
        BrowserFavorites = 0xAB,
        /// <summary></summary>
        BrowserHome = 0xAC,
        /// <summary></summary>
        VolumeMute = 0xAD,
        /// <summary></summary>
        VolumeDown = 0xAE,
        /// <summary></summary>
        VolumeUp = 0xAF,
        /// <summary></summary>
        MediaNextTrack = 0xB0,
        /// <summary></summary>
        MediaPrevTrack = 0xB1,
        /// <summary></summary>
        MediaStop = 0xB2,
        /// <summary></summary>
        MediaPlayPause = 0xB3,
        /// <summary></summary>
        LaunchMail = 0xB4,
        /// <summary></summary>
        LaunchMediaSelect = 0xB5,
        /// <summary></summary>
        LaunchApplication1 = 0xB6,
        /// <summary></summary>
        LaunchApplication2 = 0xB7,
        /// <summary></summary>
        OEM1 = 0xBA,
        /// <summary></summary>
        OEMPlus = 0xBB,
        /// <summary></summary>
        OEMComma = 0xBC,
        /// <summary></summary>
        OEMMinus = 0xBD,
        /// <summary></summary>
        OEMPeriod = 0xBE,
        /// <summary></summary>
        OEM2 = 0xBF,
        /// <summary></summary>
        OEM3 = 0xC0,
        /// <summary></summary>
        OEM4 = 0xDB,
        /// <summary></summary>
        OEM5 = 0xDC,
        /// <summary></summary>
        OEM6 = 0xDD,
        /// <summary></summary>
        OEM7 = 0xDE,
        /// <summary></summary>
        OEM8 = 0xDF,
        /// <summary></summary>
        OEMAX = 0xE1,
        /// <summary></summary>
        OEM102 = 0xE2,
        /// <summary></summary>
        ICOHelp = 0xE3,
        /// <summary></summary>
        ICO00 = 0xE4,
        /// <summary></summary>
        ProcessKey = 0xE5,
        /// <summary></summary>
        ICOClear = 0xE6,
        /// <summary></summary>
        Packet = 0xE7,
        /// <summary></summary>
        OEMReset = 0xE9,
        /// <summary></summary>
        OEMJump = 0xEA,
        /// <summary></summary>
        OEMPA1 = 0xEB,
        /// <summary></summary>
        OEMPA2 = 0xEC,
        /// <summary></summary>
        OEMPA3 = 0xED,
        /// <summary></summary>
        OEMWSCtrl = 0xEE,
        /// <summary></summary>
        OEMCUSel = 0xEF,
        /// <summary></summary>
        OEMATTN = 0xF0,
        /// <summary></summary>
        OEMFinish = 0xF1,
        /// <summary></summary>
        OEMCopy = 0xF2,
        /// <summary></summary>
        OEMAuto = 0xF3,
        /// <summary></summary>
        OEMENLW = 0xF4,
        /// <summary></summary>
        OEMBackTab = 0xF5,
        /// <summary></summary>
        ATTN = 0xF6,
        /// <summary></summary>
        CRSel = 0xF7,
        /// <summary></summary>
        EXSel = 0xF8,
        /// <summary></summary>
        EREOF = 0xF9,
        /// <summary></summary>
        Play = 0xFA,
        /// <summary></summary>
        Zoom = 0xFB,
        /// <summary></summary>
        Noname = 0xFC,
        /// <summary></summary>
        PA1 = 0xFD,
        /// <summary></summary>
        OEMClear = 0xFE
    }
}
```

`UnrealSharp/Memory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection.Metadata;
using System.Runtime.InteropServices;
using System.Text;

namespace UnrealSharp
{
    public unsafe class Memory
    {
        public static readonly nint kernel = NativeLibrary.Load("kernel32.dll");
        public static readonly delegate* unmanaged[Stdcall]<int, int, int, nint> OpenProcess = (delegate* unmanaged[Stdcall]<int, int, int, nint>)NativeLibrary.GetExport(kernel, nameof(OpenProcess));
        public static readonly delegate* unmanaged[Stdcall]<nint, nint, byte[], int, out int, int> ReadProcessMemory2 = (delegate* unmanaged[Stdcall]<nint, nint, byte[], int, out int, int>)NativeLibrary.GetExport(kernel, nameof(ReadProcessMemory));
        //public static readonly delegate* unmanaged[Stdcall]<nint, int> CloseHandle;
        //public static readonly delegate* unmanaged[Stdcall]<nint, nint, void*, nint, out nint, uint> NtReadVirtualMemory;


        // [DllImport("kernel32")] static extern IntPtr OpenProcess(UInt32 dwDesiredAccess, Int32 bInheritHandle, Int32 dwProcessId);
        //[DllImport("kernel32")] static extern Int32 ReadProcessMemory(IntPtr hProcess, UInt64 lpBaseAddress, [In, Out] Byte[] buffer, Int32 size, out Int32 lpNumberOfBytesRead);
        [DllImport("kernel32")] static extern Boolean WriteProcessMemory(nint hProcess, nint lpBaseAddress, Byte[] buffer, Int32 nSize, out Int32 lpNumberOfBytesWritten);
        [DllImport("kernel32")] static extern Int32 CloseHandle(IntPtr hObject);
        [DllImport("kernel32")] static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, UInt32 dwCreationFlags, IntPtr lpThreadId);
        [DllImport("kernel32")] static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        [DllImport("kernel32")] static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 flAllocationType, Int32 flProtect);
        [DllImport("kernel32")] static extern Boolean VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, Int32 dwSize, Int32 dwFreeType);
        [DllImport("user32")] public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, String lpszClass, String lpszWindow);
        [DllImport("user32")] public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out Int32 lpdwProcessId);
        public IntPtr procHandle = IntPtr.Zero;
        public Process Process { get; private set; }
        public nint BaseAddress { get { return Process.MainModule.BaseAddress; } }
        public nint MainWindowHandle { get { return Process.MainWindowHandle; } }
        [StructLayout(LayoutKind.Sequential, Pack = 0)] public struct OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public uint Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }
        [StructLayout(LayoutKind.Sequential)] public struct CLIENT_ID
        {
            public IntPtr UniqueProcess;
            public IntPtr UniqueThread;
        }
        public Memory(Process proc)
        {
            //r result = NtOpenProcess(ref hProcess, 0x001F0FFF, ref oa, ref ci);
            //var handle = NativeLibrary.Load("kernel32.dll");
            //ReadProcMemInternal = (delegate* unmanaged[Stdcall]<IntPtr, UInt64, Byte[], Int32, out Int32, Int32>)NativeLibrary.GetExport(handle, "ReadProcessMemory");
            Process = proc;
            if (Process == null) return;
            OpenProcessById(Process.Id);
        }
        public Memory(String name)
        {
            var procs = Process.GetProcessesByName(name);
            Process = procs.FirstOrDefault();
            if (Process == null) return;
            OpenProcessById(Process.Id);
        }
        private Dictionary<IntPtr, int> _allocations = new Dictionary<IntPtr, int>();
        public void OpenProcessById(Int32 procId)
        {
            procHandle = OpenProcess(0x38, 1, procId);
        }
        public Int32 maxStringLength = 0x100;
        /*public static Int32 ReadProcessMemory(IntPtr hProcess, UInt64 lpBaseAddress, [In, Out] Byte[] buffer, Int32 size, out Int32 lpNumberOfBytesRead)
        {
            return ReadProcMemInternal(hProcess, lpBaseAddress, buffer, size, out lpNumberOfBytesRead);
        }*/

        private const int MaxReadSize = 0x64000;
        public Byte[] ReadProcessMemory(nint addr, Int32 length)
        {
            var buffer = new Byte[length];
            for (var i = 0; i < length / (Single)MaxReadSize; i++)
            {
                var blockSize = (i == (length / MaxReadSize)) ? length % MaxReadSize : MaxReadSize;
                var buf = new Byte[blockSize];
                ReadProcessMemory2(procHandle, addr + i * MaxReadSize, buf, blockSize, out Int32 bytesRead);
                Array.Copy(buf, 0, buffer, i * MaxReadSize, blockSize);
            }
            return buffer;
        }
        public unsafe Object ReadProcessMemory(Type type, nint addr)
        {
            if (type == typeof(String))
            {
                var stringLength = maxStringLength;
                List<Byte> bytes = new List<Byte>();
                var isUtf16 = false;
                for (var i = 0; i < 64; i++)
                {
                    var letters8 = ReadProcessMemory<nint>(addr + i * 8);
                    var tempBytes = BitConverter.GetBytes(letters8);
                    for (int j = 0; j < 8 && stringLength > 0; j++)
                    {
                        if (tempBytes[j] == 0 && j == 1 && bytes.Count == 1)
                            isUtf16 = true;
                        if (isUtf16 && j % 2 == 1)
                            continue;
                        if (tempBytes[j] == 0)
                            return (Object)Encoding.UTF8.GetString(bytes.ToArray());
                        if ((tempBytes[j] < 32 || tempBytes[j] > 126) && tempBytes[j] != '\n')
                            return (Object)"null";
                        bytes.Add(tempBytes[j]);
                        stringLength--;
                    }
                }
                return (Object)Encoding.UTF8.GetString(bytes.ToArray());
            }
            var buffer = new Byte[Marshal.SizeOf(type)];
            ReadProcessMemory2(procHandle, addr, buffer, Marshal.SizeOf(type), out Int32 bytesRead);
            var structPtr = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var obj = Marshal.PtrToStructure(structPtr.AddrOfPinnedObject(), type);
            var members = obj.GetType().GetFields();
            foreach (var member in members)
            {
                continue;
                if (member.FieldType == typeof(String))
                {
                    var offset = Marshal.OffsetOf(type, member.Name).ToInt32();
                    var ptr = BitConverter.ToUInt32(buffer.Skip(offset).Take(4).ToArray(), 0);
                    if (ptr == 0xffffffff || ptr == 0)
                    {
                        member.SetValueDirect(__makeref(obj), "null");
                        continue;
                    }
                    /* var val = member.GetValue(obj);
                     var validStr = true;
                     for (int i = 0; i < 16; i++)
                     {
                         if (buffer[offset + i] == 0 && i > 1)
                             break;
                         if (buffer[offset + i] < 32 || buffer[offset + i] > 126)
                         {
                             validStr = false;
                             break;
                         }
                     }
                     if (validStr)
                         continue;*/
                    var strPtr = Marshal.ReadIntPtr(structPtr.AddrOfPinnedObject(), offset);
                    var str = ReadProcessMemory<String>(strPtr);
                    if (str != "null" && str != "")
                        member.SetValueDirect(__makeref(obj), str);
                }
                /*if (member.FieldType.IsPointer)
                {
                    var address = System.Reflection.Pointer.Unbox(member.GetValue(obj));
                    var value = ReadProcessMemory(member.FieldType.GetElementType(), (UInt32)address);
                }*/
            }
            structPtr.Free();
            return obj;
        }
        public T ReadProcessMemory<T>(nint addr)
        {
            return (T)ReadProcessMemory(typeof(T), addr);
        }
        public void WriteProcessMemory(nint addr, Byte[] buffer)
        {
            WriteProcessMemory(procHandle, addr, buffer, buffer.Length, out Int32 bytesRead);
        }
        public void WriteProcessMemory<T>(nint addr, T value)
        {
            var objSize = Marshal.SizeOf(value);
            var objBytes = new Byte[objSize];
            var objPtr = Marshal.AllocHGlobal(objSize);
            Marshal.StructureToPtr(value, objPtr, true);
            Marshal.Copy(objPtr, objBytes, 0, objSize);
            Marshal.FreeHGlobal(objPtr);
            WriteProcessMemory(procHandle, addr, objBytes, objBytes.Length, out Int32 bytesRead);
        }
        public nint Execute(nint fPtr, nint a1, nint a2, nint a3, nint a4, params nint[] args)
        {
            var retValPtr = VirtualAllocEx(procHandle, IntPtr.Zero, 0x40, 0x1000, 0x40);
            WriteProcessMemory(retValPtr, BitConverter.GetBytes((nint)0xcafeb00));

            var asm = new List<Byte>();
            asm.AddRange(new Byte[] { 0x48, 0x83, 0xEC }); // sub rsp
            asm.Add(104);

            asm.AddRange(new Byte[] { 0x48, 0xB9 }); // mov rcx
            asm.AddRange(BitConverter.GetBytes(a1));

            asm.AddRange(new Byte[] { 0x48, 0xBA }); // mov rdx
            asm.AddRange(BitConverter.GetBytes(a2));

            asm.AddRange(new Byte[] { 0x49, 0xB8 }); // mov r8
            asm.AddRange(BitConverter.GetBytes(a3));

            asm.AddRange(new Byte[] { 0x49, 0xB9 }); // mov r9
            asm.AddRange(BitConverter.GetBytes(a4));

            var offset = 0u;
            foreach (var obj in args)
            {
                asm.AddRange(new Byte[] { 0x48, 0xB8 }); // mov rax
                asm.AddRange(BitConverter.GetBytes(obj));
                asm.AddRange(new Byte[] { 0x48, 0x89, 0x44, 0x24, (Byte)(0x28 + 8 * offset++) }); // mov rax to stack
            }
            asm.AddRange(new Byte[] { 0x48, 0xB8 }); // mov rax
            asm.AddRange(BitConverter.GetBytes(fPtr));

            asm.AddRange(new Byte[] { 0xFF, 0xD0 }); // call rax
            asm.AddRange(new Byte[] { 0x48, 0x83, 0xC4 }); // add rsp
            asm.Add(104);

            asm.AddRange(new Byte[] { 0x48, 0xA3 }); // mov rax to
            asm.AddRange(BitConverter.GetBytes((UInt64)retValPtr));
            asm.Add(0xC3); // ret
            var codePtr = VirtualAllocEx(procHandle, IntPtr.Zero, asm.Count, 0x1000, 0x40);
            WriteProcessMemory(procHandle, codePtr, asm.ToArray(), asm.Count, out Int32 bytesRead);

            var thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, codePtr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(thread, 10000);
            var returnValue = ReadProcessMemory<nint>(retValPtr);
            VirtualFreeEx(procHandle, codePtr, 0, 0x8000);
            VirtualFreeEx(procHandle, retValPtr, 0, 0x8000);
            CloseHandle(thread);
            return returnValue;
        }
        public T ExecuteUEFunc<T>(nint vtableAddr, nint objAddr, nint funcAddr, params Object[] args)
        {
            //var retValPtr = VirtualAllocEx(procHandle, IntPtr.Zero, 0x40, 0x1000, 0x40);
            //WriteProcessMemory((UInt64)retValPtr, BitConverter.GetBytes((UInt64)0xdeadbeefcafef00d));
            var dummyParms = VirtualAllocEx(procHandle, IntPtr.Zero, 0x100, 0x1000, 0x40);

            WriteProcessMemory(dummyParms, BitConverter.GetBytes((UInt64)0xffffffffffffffff));
            var offset = 0;
            foreach (var obj in args)
            {
                WriteProcessMemory(dummyParms + offset, obj);
                offset += Marshal.SizeOf(obj);
            }

            var asm = new List<Byte>();
            asm.AddRange(new byte[] { 0x48, 0x83, 0xEC }); // sub rsp
            asm.Add(40);
            asm.AddRange(new byte[] { 0x48, 0xB8 }); // mov rax
            asm.AddRange(BitConverter.GetBytes((UInt64)vtableAddr));

            asm.AddRange(new byte[] { 0x48, 0xB9 }); // mov rcx
            asm.AddRange(BitConverter.GetBytes((UInt64)objAddr));

            asm.AddRange(new byte[] { 0x48, 0xBA }); // mov rdx
            asm.AddRange(BitConverter.GetBytes((UInt64)funcAddr));

            asm.AddRange(new byte[] { 0x49, 0xB8 }); // mov r8
            asm.AddRange(BitConverter.GetBytes((UInt64)dummyParms));

            asm.AddRange(new byte[] { 0xFF, 0xD0 }); // call rax
            asm.AddRange(new byte[] { 0x48, 0x83, 0xC4 }); // add rsp
            asm.Add(40);
            //asm.AddRange(new byte[] { 0x48, 0xA3 }); // mov rax to
            //asm.AddRange(BitConverter.GetBytes((UInt64)retValPtr));
            asm.Add(0xC3); // ret
            var codePtr = VirtualAllocEx(procHandle, IntPtr.Zero, asm.Count, 0x1000, 0x40);
            WriteProcessMemory(procHandle, codePtr, asm.ToArray(), asm.Count, out Int32 bytesRead);

            IntPtr thread = CreateRemoteThread(procHandle, IntPtr.Zero, 0, codePtr, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(thread, 10000);

            var returnValue = ReadProcessMemory<T>(dummyParms);
            VirtualFreeEx(procHandle, dummyParms, 0, 0x8000);
            VirtualFreeEx(procHandle, codePtr, 0, 0x8000);
            //VirtualFreeEx(procHandle, retValPtr, 0, 0x8000);
            CloseHandle(thread);
            return returnValue;
        }

        public List<nint> SearchProcessMemory(String pattern, nint start, nint end, Boolean absolute = true)
        {
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var addresses = new List<nint>();
            var iters = 1 + ((end - start) / 0x1000);
            if (iters == 0) iters++;
            for (uint i = 0; i < iters; i++)
            {
                var buffer = new Byte[0x1000];
                ReadProcessMemory2(procHandle, (nint)(start + i * 0x1000), buffer, 0x1000, out Int32 bytesRead);
                var results = Scan(buffer, arrayOfBytes).Select(j => (nint)(j + start + i * 0x1000)).ToList();
                if (start + (i + 1) * 0x1000 > end && results.Count > 0)
                    results.RemoveAll(r => r > end);
                addresses.AddRange(results);
            }
            if (absolute)
                return addresses;
            else
                return addresses.Select(a => a - start).ToList();
        }
        public List<nint> ReSearchProcessMemory(List<nint> existing, String pattern)
        {
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var addresses = new List<nint>();
            foreach (var val in existing)
            {
                var buffer = new Byte[4];
                ReadProcessMemory2(procHandle, (nint)val, buffer, 4, out int bytesRead);
                var results = Scan(buffer, arrayOfBytes).Select(j => j + val).ToList();
                addresses.AddRange(results);
            }
            return addresses;
        }
        public String DumpSurroundString(UInt64 start)
        {
            var buffer = new Byte[0x100];
            ReadProcessMemory2(procHandle, (nint)(start - 0x80), buffer, buffer.Length, out Int32 bytesRead);
            var val = "";
            for (int i = 0x7f; i > 0; i--)
            {
                if (buffer[i] == 0)
                    break;
                val = Encoding.UTF8.GetString(buffer, i, 1) + val;
            }
            for (int i = 0x80; i < 0x100; i++)
            {
                if (buffer[i] == 0)
                    break;
                val += Encoding.UTF8.GetString(buffer, i, 1);
            }
            return val;
        }
        public String GetString(nint start)
        {
            var buffer = new Byte[0x1000];
            ReadProcessMemory2(procHandle, start, buffer, buffer.Length, out Int32 bytesRead);
            return String.Join(",", buffer.Select(b => "0x" + b.ToString("X2")));
        }
        static Byte[] FileBytes;
        public static List<nint> Scan(Byte[] buf, Int32[] pattern)
        {
            var addresses = new List<nint>();

            for (int i = 0; i <= buf.Length - pattern.Length; i++)
            {
                var found = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (pattern[j] == -1)
                        continue;
                    if (buf[i + j] != pattern[j])
                    {
                        found = false;
                        break;
                    }
                }
                if (found)
                    addresses.Add(i);
            }
            return addresses;
        }

        public static void SetImageFile(String file)
        {
            FileBytes = System.IO.File.ReadAllBytes(file);
        }
        public static int GetImageBase()
        {
            var pe = BitConverter.ToUInt16(FileBytes, 0x3c);
            return BitConverter.ToInt32(FileBytes, pe + 0x34);
        }
        public static int FindAddr(String sig, Int32 offset, Boolean isOffset = false)
        {
            var arrayOfBytes = sig.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var offs = Scan(FileBytes, arrayOfBytes);
            if (isOffset)
                return BitConverter.ToInt32(FileBytes, (int)offs.First() + offset);
            var addr = BitConverter.ToInt32(FileBytes, (int)offs.First() + offset) - GetImageBase();
            return addr;
        }
        public static nint FindAddr(String sig)
        {
            var arrayOfBytes = sig.Split(' ').Select(b => b.Contains("?") ? -1 : Convert.ToInt32(b, 16)).ToArray();
            var offs = Scan(FileBytes, arrayOfBytes);
            return offs.First() + GetImageBase();
        }
        public nint FindPattern(String pattern)
        {
            return FindPattern(pattern, Process.MainModule.BaseAddress, Process.MainModule.ModuleMemorySize);
        }
        public nint FindStringRef(String str)
        {
            var stringAddr = FindPattern(BitConverter.ToString(Encoding.Unicode.GetBytes(str)).Replace("-", " "));
            var sigScan = new SigScan(Process, Process.MainModule.BaseAddress, Process.MainModule.ModuleMemorySize);
            sigScan.DumpMemory();
            for (var i = 0; i < sigScan.Size; i++)
            {
                if ((sigScan.m_vDumpedRegion[i] == 0x48 || sigScan.m_vDumpedRegion[i] == 0x4c) && sigScan.m_vDumpedRegion[i + 1] == 0x8d)
                {
                    var jmpTo = BitConverter.ToInt32(sigScan.m_vDumpedRegion, i + 3);
                    var addr = sigScan.Address + i + jmpTo + 7;
                    if (addr == stringAddr)
                    {
                        return Process.MainModule.BaseAddress + i;
                    }
                }
            }
            return 0;
        }
        public nint FindPattern(String pattern, nint start, Int32 length)
        {
            //var skip = pattern.ToLower().Contains("cc") ? 0xcc : pattern.ToLower().Contains("aa") ? 0xaa : 0;
            var sigScan = new SigScan(Process, start, length);
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? (Byte)0 : (Byte)Convert.ToInt32(b, 16)).ToArray();
            var strMask = String.Join("", pattern.Split(' ').Select(b => b.Contains("?") ? '?' : 'x'));
            return sigScan.FindPattern(arrayOfBytes, strMask, 0);
        }
        public List<nint> FindPatterns(String pattern)
        {
            //var skip = pattern.ToLower().Contains("cc") ? 0xcc : pattern.ToLower().Contains("aa") ? 0xaa : 0;
            var sigScan = new SigScan(Process, Process.MainModule.BaseAddress, Process.MainModule.ModuleMemorySize);
            var arrayOfBytes = pattern.Split(' ').Select(b => b.Contains("?") ? (Byte)0 : (Byte)Convert.ToInt32(b, 16)).ToArray();
            var strMask = String.Join("", pattern.Split(' ').Select(b => b.Contains("?") ? '?' : 'x'));
            return sigScan.FindPatterns(arrayOfBytes, strMask, 0);
        }
    }
}
```

`UnrealSharp/SigScan.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;

//
// sigScan C# Implementation - Written by atom0s [aka Wiccaan]
// Class Version: 2.0.0
//
// [ CHANGE LOG ] -------------------------------------------------------------------------
//
//      2.0.0
//          - Updated to no longer require unsafe or fixed code.
//          - Removed unneeded methods and code.
//
//      1.0.0
//          - First version written and release.
//
// [ CREDITS ] ----------------------------------------------------------------------------
//
// sigScan is based on the FindPattern code written by
// dom1n1k and Patrick at GameDeception.net
//
// Full credit to them for the purpose of this code. I, atom0s, simply
// take credit for converting it to C#.
//
// [ USAGE ] ------------------------------------------------------------------------------
//
// Examples:
//
//      SigScan _sigScan = new SigScan();
//      _sigScan.Process = someProc;
//      _sigScan.Address = new IntPtr(0x123456);
//      _sigScan.Size = 0x1000;
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
//      SigScan _sigScan = new SigScan(someProc, new IntPtr(0x123456), 0x1000);
//      IntPtr pAddr = _sigScan.FindPattern(new byte[]{ 0xFF, 0xFF, 0xFF, 0xFF, 0x51, 0x55, 0xFC, 0x11 }, "xxxx?xx?", 12);
//
// ----------------------------------------------------------------------------------------
namespace UnrealSharp
{
    public class SignatureEntity
    {
        public int StartAddress { get; set; }
        public int SearchRange { get; set; }
        public byte[] WantedBytes { get; set; }
        public String Mask { get; set; }
        public int AddressOffset { get; set; }

        public SignatureEntity(int startSAddress, int searchRange, byte[] wantedBytes, String mask, int addressOffset)
        {
            StartAddress = startSAddress;
            SearchRange = searchRange;
            WantedBytes = wantedBytes;
            Mask = mask;
            AddressOffset = addressOffset;
        }

        public IntPtr ScanSignature(Process process)
        {
            SigScan sigScan = new SigScan(process, new IntPtr(StartAddress), SearchRange);
            return sigScan.FindPattern(WantedBytes, Mask, AddressOffset);
        }
    }


    public class SigScan
    {
        /// <summary>
        /// m_vDumpedRegion
        /// 
        ///     The memory dumped from the external process.
        /// </summary>
        public byte[] m_vDumpedRegion;

        /// <summary>
        /// m_vProcess
        /// 
        ///     The process we want to read the memory of.
        /// </summary>
        private Process m_vProcess;

        /// <summary>
        /// m_vAddress
        /// 
        ///     The starting address we want to begin reading at.
        /// </summary>
        private IntPtr m_vAddress;

        /// <summary>
        /// m_vSize
        /// 
        ///     The number of bytes we wish to read from the process.
        /// </summary>
        private Int32 m_vSize;


        #region "sigScan Class Construction"
        /// <summary>
        /// SigScan
        /// 
        ///     Main class constructor that uses no params. 
        ///     Simply initializes the class properties and 
        ///     expects the user to set them later.
        /// </summary>
        public SigScan()
        {
            this.m_vProcess = null;
            this.m_vAddress = IntPtr.Zero;
            this.m_vSize = 0;
            this.m_vDumpedRegion = null;
        }
        /// <summary>
        /// SigScan
        /// 
        ///     Overloaded class constructor that sets the class
        ///     properties during construction.
        /// </summary>
        /// <param name="proc">The process to dump the memory from.</param>
        /// <param name="addr">The started address to begin the dump.</param>
        /// <param name="size">The size of the dump.</param>
        public SigScan(Process proc, IntPtr addr, int size)
        {
            this.m_vProcess = proc;
            this.m_vAddress = addr;
            this.m_vSize = size;
        }
        #endregion

        #region "sigScan Class Private Methods"
        /// <summary>
        /// DumpMemory
        /// 
        ///     Internal memory dump function that uses the set class
        ///     properties to dump a memory region.
        /// </summary>
        /// <returns>Boolean based on RPM results and valid properties.</returns>
        public bool DumpMemory()
        {
            try
            {
                // Checks to ensure we have valid data.
                if (this.m_vProcess == null)
                    return false;
                if (this.m_vProcess.HasExited == true)
                    return false;
                if (this.m_vAddress == IntPtr.Zero)
                    return false;
                if (this.m_vSize == 0)
                    return false;

                this.m_vDumpedRegion = UnrealEngine.Memory.ReadProcessMemory(this.m_vAddress, this.m_vSize);
                
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        /// <summary>
        /// MaskCheck
        /// 
        ///     Compares the current pattern byte to the current memory dump
        ///     byte to check for a match. Uses wildcards to skip bytes that
        ///     are deemed unneeded in the compares.
        /// </summary>
        /// <param name="nOffset">Offset in the dump to start at.</param>
        /// <param name="btPattern">Pattern to scan for.</param>
        /// <param name="strMask">Mask to compare against.</param>
        /// <returns>Boolean depending on if the pattern was found.</returns>
        private bool MaskCheck(int nOffset, byte[] btPattern, string strMask)
        {
            // Loop the pattern and compare to the mask and dump.
            for (int x = 0; x < btPattern.Length; x++)
            {
                // If the mask char is a wildcard, just continue.
                if (strMask[x] == '?')
                    continue;

                // If the mask char is not a wildcard, ensure a match is made in the pattern.
                if ((strMask[x] == 'x') && (btPattern[x] != this.m_vDumpedRegion[nOffset + x]))
                    return false;
            }

            // The loop was successful so we found the pattern.
            return true;
        }
        #endregion

        #region "sigScan Class Public Methods"
        /// <summary>
        /// FindPattern
        /// 
        ///     Attempts to locate the given pattern inside the dumped memory region
        ///     compared against the given mask. If the pattern is found, the offset
        ///     is added to the located address and returned to the user.
        /// </summary>
        /// <param name="btPattern">Byte pattern to look for in the dumped region.</param>
        /// <param name="strMask">The mask string to compare against.</param>
        /// <param name="nOffset">The offset added to the result address.</param>
        /// <returns>IntPtr - zero if not found, address if found.</returns>
        public IntPtr FindPattern(byte[] btPattern, string strMask, int nOffset)
        {
            try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return IntPtr.Zero;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return IntPtr.Zero;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length - strMask.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        return IntPtr.Add(this.m_vAddress, x + nOffset);
                    }
                }

                // Pattern was not found.
                return IntPtr.Zero;
            }
            catch (Exception)
            {
                return IntPtr.Zero;
            }
        }
        public List<IntPtr> FindPatterns(byte[] btPattern, string strMask, int nOffset)
        {
            var ptrs = new List<IntPtr>();
            try
            {
                // Dump the memory region if we have not dumped it yet.
                if (this.m_vDumpedRegion == null || this.m_vDumpedRegion.Length == 0)
                {
                    if (!this.DumpMemory())
                        return null;
                }

                // Ensure the mask and pattern lengths match.
                if (strMask.Length != btPattern.Length)
                    return null;

                // Loop the region and look for the pattern.
                for (int x = 0; x < this.m_vDumpedRegion.Length; x++)
                {
                    if (this.MaskCheck(x, btPattern, strMask))
                    {
                        // The pattern was found, return it.
                        ptrs.Add(IntPtr.Add(this.m_vAddress, x + nOffset));
                    }
                }

                // Pattern was not found.
                return ptrs;
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// ResetRegion
        /// 
        ///     Resets the memory dump array to nothing to allow
        ///     the class to redump the memory.
        /// </summary>
        public void ResetRegion()
        {
            this.m_vDumpedRegion = null;
        }
        #endregion

        #region "sigScan Class Properties"
        public Process Process
        {
            get { return this.m_vProcess; }
            set { this.m_vProcess = value; }
        }
        public IntPtr Address
        {
            get { return this.m_vAddress; }
            set { this.m_vAddress = value; }
        }
        public Int32 Size
        {
            get { return this.m_vSize; }
            set { this.m_vSize = value; }
        }
        #endregion

    }
}
```

`UnrealSharp/UnrealEngine.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using static UnrealSharp.UnrealEngine;

namespace UnrealSharp
{
    public class UnrealEngine
    {
        public static UnrealEngine Instance;
        static nint GNamesPattern;
        public static nint GNames;
        static nint GObjectsPattern;
        public static nint GObjects;
        static nint GWorldPtrPattern;
        public static nint GWorldPtr;
        static nint GEnginePattern;
        public static nint GEngine;
        public static nint GStaticCtor;
        public static Memory Memory;
        public UnrealEngine(Memory mem) { Memory = mem; Instance = this; }
        public void UpdateAddresses()
        {
            {
                GNamesPattern = Memory.FindPattern("74 09 48 8D 15 ? ? ? ? EB 16");
                var offset = Memory.ReadProcessMemory<int>(GNamesPattern + 5);
                GNames = GNamesPattern + offset + 9;
                if (UEObject.GetName(3) != "ByteProperty") throw new Exception("bad GNames");
                //DumpGNames();
            }
            {
                int offset;
                var stringAddr = Memory.FindStringRef("    SeamlessTravel FlushLevelStreaming");
                GWorldPtrPattern = Memory.FindPattern("48 89 05", stringAddr - 0x500, 0x500);
                //GWorldPtrPattern = Memory.FindPattern("48 89 5C 24 08 57 48 83 EC 30 0F B6 DA 48 8B F9 80 FA 01 ?? ?? ?? ?? ?? ?? ?? ?? ?? BA");
                if(GWorldPtrPattern != 0){
                    offset = UnrealEngine.Memory.ReadProcessMemory<int>(GWorldPtrPattern + 3);
                    GWorldPtr = GWorldPtrPattern + offset + 7;
                } else {
                    GWorldPtrPattern = Memory.FindPattern("0F 2E ?? 74 ?? 48 8B 1D ?? ?? ?? ?? 48 85 DB 74");
                    offset = Memory.ReadProcessMemory<int>(GWorldPtrPattern + 8);
                    GWorldPtr = GWorldPtrPattern + offset + 12;
                }
                GObjectsPattern = Memory.FindPattern("48 8B 05 ? ? ? ? 48 8B 0C C8 ? 8D 04 D1 EB ?");

                UpdateUEObject();

                offset = Memory.ReadProcessMemory<int>(GObjectsPattern + 3);
                GObjects = GObjectsPattern + offset + 7 - Memory.BaseAddress;
            }
            {
                GEnginePattern = Memory.FindPattern("48 8B 0D ?? ?? ?? ?? 48 85 C9 74 1E 48 8B 01 FF 90");
                var offset = Memory.ReadProcessMemory<int>(GEnginePattern + 3);
                GEngine = Memory.ReadProcessMemory<nint>(GEnginePattern + offset + 7);
            }
            {
                var engine = new UEObject(GEngine);
                GStaticCtor = Memory.FindPattern("4C 89 44 24 18 55 53 56 57 41 54 41 55 41 56 41 57 48 8D AC 24 ? ? ? ? 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4");
            }
            //DumpSdk();
        }
        public void EnableConsole()
        {
            var engine = new UEObject(GEngine);
            var console = new UEObject(Memory.Execute(GStaticCtor, engine["ConsoleClass"].Value, engine["GameViewport"].Address, 0, 0, 0, 0, 0, 0, 0));
            engine["GameViewport"]["ViewportConsole"] = console;
        }
        public void UpdateUEObject()
        {
            var world = Memory.ReadProcessMemory<nint>(GWorldPtr);
            {
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                var foundClassAndName = false;
                for (var c = 0; c < 0x50 && !foundClassAndName; c += 0x8)
                {
                    classPtr = Memory.ReadProcessMemory<nint>(world + c);
                    if (classPtr == 0x0) continue;
                    for (var n = 0; n < 0x50 && !foundClassAndName; n += 0x8)
                    {
                        var classNameIndex = Memory.ReadProcessMemory<int>(classPtr + n);
                        var name = UEObject.GetName(classNameIndex);
                        if (name == "World")
                        {
                            UEObject.classOffset = c;
                            UEObject.nameOffset = n;
                            foundClassAndName = true;
                        }
                    }
                }
                if (!foundClassAndName) throw new Exception("bad World or offsets?");
            }
            {
                var foundOuter = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                for (var o = 0; o < 0x50; o += 0x8)
                {
                    var outerObj = Memory.ReadProcessMemory<nint>(classPtr + o);
                    var classNameIndex = Memory.ReadProcessMemory<int>(outerObj + UEObject.nameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "/Script/Engine")
                    {
                        UEObject.objectOuterOffset = o;
                        foundOuter = true;
                        break;
                    }
                }
                if (!foundOuter) throw new Exception("bad outer addr");
            }
            {
                var foundSuper = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                for (var o = 0; o < 0x50; o += 0x8)
                {
                    var superObj = Memory.ReadProcessMemory<nint>(classPtr + o);
                    var classNameIndex = Memory.ReadProcessMemory<int>(superObj + UEObject.nameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "Object")
                    {
                        UEObject.structSuperOffset = o;
                        foundSuper = true;
                        break;
                    }
                }
                if (!foundSuper) throw new Exception("bad super addr");
            }
            {
                var foundChildsAndFieldName = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                for (var c = 0; c < 0x80 && !foundChildsAndFieldName; c += 0x8)
                {
                    var childPtr = Memory.ReadProcessMemory<nint>(classPtr + c);
                    if (childPtr == 0x0) continue;
                    for (var n = 0; n < 0x80 && !foundChildsAndFieldName; n += 0x8)
                    {
                        var classNameIndex = Memory.ReadProcessMemory<int>(childPtr + n);
                        var name = UEObject.GetName(classNameIndex);
                        if (name == "PersistentLevel")
                        {
                            UEObject.childPropertiesOffset = c;
                            UEObject.fieldNameOffset = n;
                            foundChildsAndFieldName = true;
                        }
                    }
                }
                if (!foundChildsAndFieldName) throw new Exception("bad childs offset");
            }
            {
                var foundNextField = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                var fieldPtr = Memory.ReadProcessMemory<nint>(classPtr + UEObject.childPropertiesOffset);
                for (var c = 0; c < 0x80 && !foundNextField; c += 0x8)
                {
                    var childClassPtr = Memory.ReadProcessMemory<nint>(fieldPtr + c);
                    if (childClassPtr == 0x0) continue;
                    var classNameIndex = Memory.ReadProcessMemory<int>(childClassPtr + UEObject.fieldNameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "NetDriver")
                    {
                        UEObject.fieldNextOffset = c;
                        foundNextField = true;
                    }
                }
                if (!foundNextField) throw new Exception("bad next field offset");
            }
            {
                var foundFuncs = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                for (var c = 0; c < 0x80 && !foundFuncs; c += 0x8)
                {
                    var childPtr = Memory.ReadProcessMemory<nint>(classPtr + c);
                    if (childPtr == 0x0) continue;
                    var classNameIndex = Memory.ReadProcessMemory<int>(childPtr + UEObject.nameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "K2_GetWorldSettings")
                    {
                        UEObject.childrenOffset = c;
                        foundFuncs = true;
                    }
                }
                if (!foundFuncs)
                {
                    var testObj = new UEObject(world);
                    var isField = testObj["K2_GetWorldSettings"];
                    if (isField != null)
                    {
                        UEObject.childrenOffset = UEObject.childPropertiesOffset;
                        foundFuncs = true;
                    }
                }
                if (!foundFuncs) throw new Exception("bad childs offset");
            }
            {
                var foundNextField = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                var fieldPtr = Memory.ReadProcessMemory<nint>(classPtr + UEObject.childrenOffset);
                for (var c = 0; c < 0x80 && !foundNextField; c += 0x8)
                {
                    var childClassPtr = Memory.ReadProcessMemory<nint>(fieldPtr + c);
                    if (childClassPtr == 0x0) continue;
                    var classNameIndex = Memory.ReadProcessMemory<int>(childClassPtr + UEObject.nameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "HandleTimelineScrubbed")
                    {
                        UEObject.funcNextOffset = c;
                        foundNextField = true;
                    }
                }
                if (!foundNextField) throw new Exception("bad next offset");
            }
            {
                var foundNextField = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                var fieldPtr = Memory.ReadProcessMemory<nint>(classPtr + UEObject.childPropertiesOffset);
                for (var c = 0; c < 0x80 && !foundNextField; c += 0x8)
                {
                    var childClassPtr = Memory.ReadProcessMemory<nint>(fieldPtr + c);
                    if (childClassPtr == 0x0) continue;
                    var classNameOffset = UEObject.NewFName ? 0 : UEObject.fieldNameOffset;
                    var classNameIndex = Memory.ReadProcessMemory<int>(childClassPtr + classNameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "ObjectProperty")
                    {
                        UEObject.fieldClassOffset = c;
                        foundNextField = true;
                    }
                }
                if (!foundNextField) throw new Exception("bad field class offset");
            }
            {
                var foundFieldOffset = false;
                var classPtr = Memory.ReadProcessMemory<nint>(world + UEObject.classOffset);
                var fieldPtr = Memory.ReadProcessMemory<nint>(classPtr + UEObject.childPropertiesOffset);
                for (var c = 0x0; c < 0x80 && !foundFieldOffset; c += 0x4)
                {
                    var fieldOffset = Memory.ReadProcessMemory<nint>(fieldPtr + c);
                    var nextFieldPtr = Memory.ReadProcessMemory<nint>(fieldPtr + UEObject.fieldNextOffset);
                    var fieldOffsetPlus8 = Memory.ReadProcessMemory<nint>(nextFieldPtr + c);
                    if ((fieldOffset + 8) == fieldOffsetPlus8)
                    {
                        UEObject.fieldOffset = c;
                        foundFieldOffset = true;
                    }
                }
                if (!foundFieldOffset) throw new Exception("bad field offset");
            }
            {
                var World = new UEObject(world);
                var field = World.GetFieldAddr("StreamingLevelsToConsider");
                var foundPropertySize = false;
                for (var c = 0x60; c < 0x100 && !foundPropertySize; c += 0x8)
                {
                    var classAddr = Memory.ReadProcessMemory<nint>(field + c);
                    var classNameIndex = Memory.ReadProcessMemory<Int32>(classAddr + UEObject.nameOffset);
                    var name = UEObject.GetName(classNameIndex);
                    if (name == "StreamingLevelsToConsider")
                    {
                        UEObject.propertySize = c;
                        foundPropertySize = true;
                    }
                }
                if (!foundPropertySize) throw new Exception("bad property size offset");
            }
            {
                var vTable = UnrealEngine.Memory.ReadProcessMemory<nint>(world);
                var foundProcessEventOffset = false;
                for (var i = 50; i < 0x100 && !foundProcessEventOffset; i++)
                {
                    var s = UnrealEngine.Memory.ReadProcessMemory<IntPtr>(vTable + i * 8);
                    var sig = (UInt64)UnrealEngine.Memory.FindPattern("40 55 56 57 41 54 41 55 41 56 41 57", s, 0X20);
                    if (sig != 0)
                    {
                        UEObject.vTableFuncNum = i;
                        foundProcessEventOffset = true;
                    }
                }
                if (!foundProcessEventOffset) throw new Exception("bad process event offset");
            }
            {
                var testObj = new UEObject(world);
                var funcAddr = testObj.GetFuncAddr(testObj.ClassAddr, testObj.ClassAddr, "K2_GetWorldSettings");
                var foundFuncFlags = false;
                for (var i = 0; i < 0x200 && !foundFuncFlags; i += 8)
                {
                    var flags = UnrealEngine.Memory.ReadProcessMemory<nint>(funcAddr + i);
                    if (flags == 0x0008000104020401)
                    {
                        UEObject.funcFlagsOffset = i;
                        foundFuncFlags = true;
                    }
                }
                if (!foundFuncFlags) throw new Exception("bad func flags offset");
            }
        }
        public void DumpGNames()
        {
            var testObj = new UEObject(0);
            var sb = new StringBuilder();
            var i = 0;
            while (true)
            {
                var name = UEObject.GetName(i);

                if (name == "badIndex")
                {
                    if ((i & 0xffff) > 0xff00)
                    {
                        i += 0x10000 - (i % 0x10000);
                        continue;
                    }
                    break;
                }
                sb.AppendLine("[" + i + " | " + (i).ToString("X") + "] " + name);
                i += name.Length / 2 + name.Length % 2 + 1;
            }
            System.IO.Directory.CreateDirectory(Memory.Process.ProcessName);
            System.IO.File.WriteAllText(Memory.Process.ProcessName + @"\GNamesDump.txt", sb.ToString());
        }
        public String GetTypeFromFieldAddr(String fName, String fType, nint fAddr, out String gettersetter)
        {
            gettersetter = "";
            if (fType == "BoolProperty")
            {
                fType = "bool";
                gettersetter = "{ get { return this[nameof(" + fName + ")].Flag; } set { this[nameof(" + fName + ")].Flag = value; } }";
            }
            else if (fType == "ByteProperty" || fType == "Int8Property")
            {
                fType = "byte";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "Int16Property")
            {
                fType = "short";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "UInt16Property")
            {
                fType = "ushort";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "IntProperty")
            {
                fType = "int";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "UInt32Property")
            {
                fType = "uint";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "Int64Property")
            {
                fType = "long";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "UInt64Property")
            {
                fType = "ulong";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "FloatProperty")
            {
                fType = "float";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "DoubleProperty")
            {
                fType = "double";
                gettersetter = "{ get { return this[nameof(" + fName + ")].GetValue<" + fType + ">(); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
            }
            else if (fType == "StrProperty")
            {
                fType = "unk";
            }
            else if (fType == "TextProperty")
            {
                fType = "unk";
            }
            else if (fType == "ObjectProperty")
            {
                var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(UnrealEngine.Memory.ReadProcessMemory<nint>(fAddr + UEObject.propertySize) + UEObject.nameOffset);
                fType = UEObject.GetName(structFieldIndex);
                gettersetter = "{ get { return this[nameof(" + fName + ")].As<" + fType + ">(); } set { this[\"" + fName + "\"] = value; } }";
            }
            else if (fType == "ClassPtrProperty")
            {
                fType = "Object";
                gettersetter = "{ get { return this[nameof(" + fName + ")].As<" + fType + ">(); } set { this[\"" + fName + "\"] = value; } } // ClassPtrProperty";
            }
            else if (fType == "ScriptTypedElementHandle")
            {
                fType = "Object";
                gettersetter = "{ get { return this[nameof(" + fName + ")].As<" + fType + ">(); } set { this[\"" + fName + "\"] = value; } } // ClassPtrProperty";
            }
            else if (fType == "StructProperty")
            {
                var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(UnrealEngine.Memory.ReadProcessMemory<nint>(fAddr + UEObject.propertySize) + UEObject.nameOffset);
                fType = UEObject.GetName(structFieldIndex);
                //gettersetter = "{ get { return UnrealEngine.Memory.ReadProcessMemory<" + fType + ">(this[nameof(" + fName + ")].Address); } set { this[nameof(" + fName + ")].SetValue<" + fType + ">(value); } }";
                gettersetter = "{ get { return this[nameof(" + fName + ")].As<" + fType + ">(); } set { this[\"" + fName + "\"] = value; } }";
            }
            else if (fType == "EnumProperty")
            {
                var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(UnrealEngine.Memory.ReadProcessMemory<nint>(fAddr + UEObject.propertySize + 8) + UEObject.nameOffset);
                fType = UEObject.GetName(structFieldIndex);
                gettersetter = "{ get { return (" + fType + ")this[nameof(" + fName + ")].GetValue<int>(); } set { this[nameof(" + fName + ")].SetValue<int>((int)value); } }";
            }
            else if (fType == "NameProperty")
            {
                fType = "unk";
            }
            else if (fType == "ArrayProperty")
            {
                var inner = UnrealEngine.Memory.ReadProcessMemory<nint>(fAddr + UEObject.propertySize);
                var innerClass = UnrealEngine.Memory.ReadProcessMemory<nint>(inner + UEObject.fieldClassOffset);
                var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(innerClass);
                fType = UEObject.GetName(structFieldIndex);
                var innerType = GetTypeFromFieldAddr(fName, fType, inner, out gettersetter);
                gettersetter = "{ get { return new Array<" + innerType + ">(this[nameof(" + fName + ")].Address); } }";// set { this[\"" + fName + "\"] = value; } }";
                fType = "Array<" + innerType + ">";
            }
            else if (fType == "SoftObjectProperty")
            {
                fType = "unk";
            }
            else if (fType == "SoftClassProperty")
            {
                fType = "unk";
            }
            else if (fType == "WeakObjectProperty")
            {
                fType = "unk";
            }
            else if (fType == "LazyObjectProperty")
            {
                fType = "unk";
            }
            else if (fType == "DelegateProperty")
            {
                fType = "unk";
            }
            else if (fType == "MulticastSparseDelegateProperty")
            {
                fType = "unk";
            }
            else if (fType == "MulticastInlineDelegateProperty")
            {
                fType = "unk";
            }
            else if (fType == "ClassProperty")
            {
                fType = "unk";
            }
            else if (fType == "MapProperty")
            {
                fType = "unk";
            }
            else if (fType == "SetProperty")
            {
                fType = "unk";
            }
            else if (fType == "FieldPathProperty")
            {
                fType = "unk";
            }
            else if (fType == "InterfaceProperty")
            {
                fType = "unk";
            }
            else if (fType == "Enum")
            {
                fType = "UEEnum";
            }
            else if (fType == "DateTime")
            {
                fType = "UEDateTime";
            }
            else if (fType == "Guid")
            {
                fType = "UEGuid";
            }
            if (fType == "unk")
            {
                fType = "Object";
                gettersetter = "{ get { return this[nameof(" + fName + ")]; } set { this[nameof(" + fName + ")] = value; } }";
            }
            return fType;
        }
        public class Package
        {
            public String FullName;
            public String Name => FullName.Substring(FullName.LastIndexOf("/") + 1);
            public List<SDKClass> Classes = new List<SDKClass>();
            public List<Package> Dependencies = new List<Package>();
            public class SDKClass
            {
                public String SdkType;
                public String Namespace;
                public String Name;
                public String Parent;
                public List<SDKFields> Fields = new List<SDKFields>();
                public List<SDKFunctions> Functions = new List<SDKFunctions>();
                public class SDKFields
                {
                    public String Type;
                    public String Name;
                    public String GetterSetter;
                    public Int32 EnumVal;
                }
                public class SDKFunctions
                {
                    public String ReturnType;
                    public String Name;
                    public List<SDKFields> Params = new List<SDKFields>();
                }

            }
        }
        public void DumpSdk(String location = "")
        {
            if (location == "") location = Memory.Process.ProcessName;
            Directory.CreateDirectory(location);
            var entityList = Memory.ReadProcessMemory<nint>(Memory.BaseAddress + GObjects);
            var count = Memory.ReadProcessMemory<UInt32>(Memory.BaseAddress + GObjects + 0x14);
            entityList = Memory.ReadProcessMemory<nint>(entityList);
            var packages = new Dictionary<nint, List<nint>>();
            for (var i = 0; i < count; i++)
            {
                // var entityAddr = Memory.ReadProcessMemory<UInt64>((entityList + 8 * (i / 0x10400)) + 24 * (i % 0x10400));
                var entityAddr = Memory.ReadProcessMemory<nint>((entityList + 8 * (i >> 16)) + 24 * (i % 0x10000));
                if (entityAddr == 0) continue;
                var outer = entityAddr;
                while (true)
                {
                    var tempOuter = Memory.ReadProcessMemory<nint>(outer + UEObject.objectOuterOffset);
                    if (tempOuter == 0) break;
                    outer = tempOuter;
                }
                if (!packages.ContainsKey(outer)) packages.Add(outer, new List<nint>());
                packages[outer].Add(entityAddr);
            }
            var ii = 0;
            var dumpedPackages = new List<Package>();
            foreach (var package in packages)
            {
                var packageObj = new UEObject(package.Key);
                var fullPackageName = packageObj.GetName();
                if (fullPackageName.Contains("TypedElementFrameworkSDK"))
                    Console.WriteLine("");
                var dumpedClasses = new List<String>();
                var sdkPackage = new Package { FullName = fullPackageName };
                foreach (var objAddr in package.Value)
                {
                    var obj = new UEObject(objAddr);
                    if (dumpedClasses.Contains(obj.ClassName)) continue;
                    dumpedClasses.Add(obj.ClassName);
                    if (obj.ClassName.StartsWith("Package")) continue;
                    var typeName = obj.ClassName.StartsWith("Class") ? "class" : obj.ClassName.StartsWith("ScriptStruct") ? "class" : obj.ClassName.StartsWith("Enum") ? "enum" : "unk";
                    //if (obj.ClassName.StartsWith("BlueprintGenerated")) typeName = "class";
                    var className = obj.GetName();
                    if (typeName == "unk") continue;
                    if (className == "Object") continue;
                    var parentClass = UnrealEngine.Memory.ReadProcessMemory<nint>(obj.Address + UEObject.structSuperOffset);
                    var sdkClass = new Package.SDKClass { Name = className, Namespace = fullPackageName, SdkType = typeName };
                    if (typeName == "enum") sdkClass.Parent = "int";
                    else if (parentClass != 0)
                    {
                        var parentNameIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(parentClass + UEObject.nameOffset);
                        var parentName = UEObject.GetName(parentNameIndex);
                        sdkClass.Parent = parentName;
                    }
                    else sdkClass.Parent = "Object";
                    //else throw new Exception("unparented obj not supported");

                    if (typeName == "enum")
                    {
                        var enumArray = UnrealEngine.Memory.ReadProcessMemory<nint>(objAddr + 0x40);
                        var enumCount = UnrealEngine.Memory.ReadProcessMemory<int>(objAddr + 0x48);
                        for (var i = 0; i < enumCount; i++)
                        {
                            var enumNameIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(enumArray + i * 0x10);
                            var enumName = UEObject.GetName(enumNameIndex);
                            enumName = enumName.Substring(enumName.LastIndexOf(":") + 1);
                            var enumNameRepeatedIndex = UnrealEngine.Memory.ReadProcessMemory<Int32>(enumArray + i * 0x10 + 4);
                            if (enumNameRepeatedIndex > 0)
                                enumName += "_" + enumNameRepeatedIndex;
                            var enumVal = UnrealEngine.Memory.ReadProcessMemory<Int32>(enumArray + i * 0x10 + 0x8);
                            sdkClass.Fields.Add(new Package.SDKClass.SDKFields { Name = enumName, EnumVal = enumVal });
                        }
                    }
                    else if (typeName == "unk")
                    {
                        continue;
                    }
                    else
                    {
                        var field = obj.Address + UEObject.childPropertiesOffset - UEObject.fieldNextOffset;
                        while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.fieldNextOffset)) > 0)
                        {
                            var fName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(field + UEObject.fieldNameOffset));
                            var fType = obj.GetFieldType(field);
                            var fValue = "(" + field.ToString() + ")";
                            var offset = (UInt32)obj.GetFieldOffset(field);
                            var gettersetter = "{ get { return new {0}(this[\"{1}\"].Address); } set { this[\"{1}\"] = value; } }";
                            fType = GetTypeFromFieldAddr(fName, fType, field, out gettersetter);
                            //if (typeName == "struct") gettersetter = ";";
                            if (fName == className) fName += "_value";
                            sdkClass.Fields.Add(new Package.SDKClass.SDKFields { Type = fType, Name = fName, GetterSetter = gettersetter });
                        }
                        field = obj.Address + UEObject.childrenOffset - UEObject.funcNextOffset;
                        while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.funcNextOffset)) > 0)
                        {
                            var fName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(field + UEObject.nameOffset));
                            if (fName == className) fName += "_value";
                            var func = new Package.SDKClass.SDKFunctions { Name = fName };
                            var fField = field + UEObject.childPropertiesOffset - UEObject.fieldNextOffset;
                            while ((fField = UnrealEngine.Memory.ReadProcessMemory<nint>(fField + UEObject.fieldNextOffset)) > 0)
                            {
                                var pName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(fField + UEObject.fieldNameOffset));
                                var pType = obj.GetFieldType(fField);
                                pType = GetTypeFromFieldAddr("", pType, fField, out _);
                                func.Params.Add(new Package.SDKClass.SDKFields { Name = pName, Type = pType });
                            }
                            sdkClass.Functions.Add(func);
                        }
                    }
                    sdkPackage.Classes.Add(sdkClass);
                }
                dumpedPackages.Add(sdkPackage);
            }
            foreach (var p in dumpedPackages)
            {
                p.Dependencies = new List<Package>();
                foreach (var c in p.Classes)
                {
                    {
                        var fromPackage = dumpedPackages.Find(tp => tp.Classes.Count(tc => tc.Name == c.Parent) > 0);
                        if (fromPackage != null && fromPackage != p && !p.Dependencies.Contains(fromPackage)) p.Dependencies.Add(fromPackage);
                    }
                    foreach (var f in c.Fields)
                    {
                        var fromPackage = dumpedPackages.Find(tp => tp.Classes.Count(tc => tc.Name == f.Type?.Replace("Array<", "").Replace(">", "")) > 0);
                        if (fromPackage != null && fromPackage != p && !p.Dependencies.Contains(fromPackage)) p.Dependencies.Add(fromPackage);
                    }
                    foreach (var f in c.Functions)
                    {
                        foreach (var param in f.Params)
                        {
                            var fromPackage = dumpedPackages.Find(tp => tp.Classes.Count(tc => tc.Name == param.Type?.Replace("Array<", "").Replace(">", "")) > 0);
                            if (fromPackage != null && fromPackage != p && !p.Dependencies.Contains(fromPackage)) p.Dependencies.Add(fromPackage);
                        }
                    }
                }
            }
            foreach (var p in dumpedPackages)
            {
                var sb = new StringBuilder();
                sb.AppendLine("using UnrealSharp;");
                sb.AppendLine("using Object = UnrealSharp.UEObject;");
                sb.AppendLine("using Guid = SDK.Script.CoreUObjectSDK.Guid;");
                sb.AppendLine("using Enum = SDK.Script.CoreUObjectSDK.Enum;");
                sb.AppendLine("using DateTime = SDK.Script.CoreUObjectSDK.DateTime;");
                foreach (var d in p.Dependencies) sb.AppendLine("using SDK" + d.FullName.Replace("/", ".") + "SDK;");
                sb.AppendLine("namespace SDK" + p.FullName.Replace("/", ".") + "SDK");
                sb.AppendLine("{");
                var printedClasses = 0;
                foreach(var c in p.Classes)
                {
                    if (c.Fields.Count > 0) printedClasses++;
                   // sb.AppendLine("    [Namespace(\"" + c.Namespace + "\")]");
                    sb.AppendLine("    public " + c.SdkType + " " + c.Name + ((c.Parent == null) ? "" : ( " : " + c.Parent)));
                    sb.AppendLine("    {");
                    if (c.SdkType != "enum")
                        sb.AppendLine("        public " + c.Name + "(nint addr) : base(addr) { }");
                    foreach (var f in c.Fields)
                    {
                        if (f.Name == "RelatedPlayerState") continue; // todo fix
                        if (c.SdkType == "enum")
                            sb.AppendLine("        " + f.Name + " = " + f.EnumVal + ",");
                        else
                            sb.AppendLine("        public " + f.Type + " " + f.Name + " " + f.GetterSetter);
                    }
                    foreach (var f in c.Functions)
                    {
                        if (f.Name == "ClientReceiveLocalizedMessage") continue; // todo fix
                        var returnType = f.Params.FirstOrDefault(pa => pa.Name == "ReturnValue")?.Type ?? "void";
                        var parameters = String.Join(", ", f.Params.FindAll(pa => pa.Name != "ReturnValue").Select(pa => pa.Type + " " + pa.Name));
                        var args = f.Params.FindAll(pa => pa.Name != "ReturnValue").Select(pa => pa.Name).ToList();
                        args.Insert(0, "nameof(" + f.Name + ")");
                        var argList = String.Join(", ", args);
                        var returnTypeTemplate = returnType == "void" ? "" : ("<" + returnType + ">");
                        sb.AppendLine("        public " + returnType + " " + f.Name + "(" + parameters + ") { " + (returnType == "void" ? "" : "return ") + "Invoke" + returnTypeTemplate + "(" + argList + "); }");
                    }
                    sb.AppendLine("    }");
                }
                sb.AppendLine("}");
                if (printedClasses == 0)
                    continue;
                System.IO.File.WriteAllText(location + @"\" + p.Name + ".cs", sb.ToString());
            }
        }
    }
    public class Array<T> : UEObject
    {
        public Array(UEObject obj) : base()
        {
            Address = obj.Address;
            _classAddr = obj.ClassAddr;
            _substructAddr = obj._substructAddr;
        }
        public Array(nint addr) : base(addr) { }
        public Array(nint addr, nint classAddr) : base(addr) { _classAddr = classAddr; }
        public int Num
        {
            get
            {
                if (_num != int.MaxValue) return _num;
                _num = UnrealEngine.Memory.ReadProcessMemory<int>(Address + 8);
                if (_num > 0x20000) _num = 0x20000;
                return _num;
            }
        }
        public Byte[] ArrayCache
        {
            get
            {
                if (_arrayCache.Length != 0) return _arrayCache;
                _arrayCache = UnrealEngine.Memory.ReadProcessMemory(Value, Num * 8);
                return _arrayCache;
            }
        }
        public T this[int index]
        {
            get
            {
                if (index >= Num) return (T)Activator.CreateInstance(typeof(T), (nint)0);
                return (T)Activator.CreateInstance(typeof(T), (nint)BitConverter.ToUInt64(ArrayCache, index * 8));
            }
        }
        public T this[int index, bool t]
        {
            get {
                if (typeof(T).IsAssignableTo(typeof(UEObject)))
                {
                    var subStructSize = 0x28;// (int)typeof(T).GetField("size").GetValue(null);
                    var obj = (T)Activator.CreateInstance(typeof(T), (nint)Value + index * subStructSize);
                    var q = obj as UEObject;
                    q._classAddr = _substructAddr;
                    obj = (T)(object)q;
                    return obj;
                }
                else
                {
                    var obj = (T)Activator.CreateInstance(typeof(T), (nint)Value + index * Marshal.SizeOf(typeof(T)));
                    return obj;

                }
            }
        }
    }
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum)]
    public class NamespaceAttribute : Attribute
    {
        public string name;
        public NamespaceAttribute(string name)
        {
            this.name = name;
        }
    }
    public class UEObject
    {
        public static int objectOuterOffset = 0x20;
        public static int classOffset = 0x10;
        public static int nameOffset = 0x18;
        public static int structSuperOffset = 0x40;
        public static int childPropertiesOffset = 0x50;
        public static int childrenOffset = 0x48;
        public static int fieldNameOffset = 0x28;
        public static int fieldTypeNameOffset = 0;
        public static int fieldClassOffset = 0x8;
        public static int fieldNextOffset = 0x20;
        public static int funcNextOffset = 0x20;
        public static int fieldOffset = 0x4C;
        public static int propertySize = 0x78;
        public static int vTableFuncNum = 66;
        public static int funcFlagsOffset = 0xB0;
        public static int enumArrayOffset = 0x40;
        public static int enumCountOffset = 0x48;

        static ConcurrentDictionary<nint, string> AddrToName = new ConcurrentDictionary<nint, string>();
        static ConcurrentDictionary<nint, nint> AddrToClass = new ConcurrentDictionary<nint, nint>();
        static ConcurrentDictionary<String, Boolean> ClassIsSubClass = new ConcurrentDictionary<string, bool>();
        static ConcurrentDictionary<nint, string> ClassToName = new ConcurrentDictionary<nint, string>();
        static ConcurrentDictionary<nint, ConcurrentDictionary<string, nint>> ClassFieldToAddr = new ConcurrentDictionary<nint, ConcurrentDictionary<string, nint>>();
        static ConcurrentDictionary<nint, int> FieldAddrToOffset = new ConcurrentDictionary<nint, int>();
        static ConcurrentDictionary<nint, string> FieldAddrToType = new ConcurrentDictionary<nint, string>();
        public static void ClearCache()
        {
            AddrToName.Clear();
            AddrToClass.Clear();
            ClassIsSubClass.Clear();
            //ClassToAddr.Clear();
            ClassFieldToAddr.Clear();
            FieldAddrToOffset.Clear();
            FieldAddrToType.Clear();
        }
        public int GetFieldOffset(nint fieldAddr)
        {
            if (FieldAddrToOffset.ContainsKey(fieldAddr)) return FieldAddrToOffset[fieldAddr];
            var offset = UnrealEngine.Memory.ReadProcessMemory<int>(fieldAddr + fieldOffset);
            FieldAddrToOffset[fieldAddr] = offset;
            return offset;
        }
        String _className;
        public String ClassName
        {
            get
            {
                if (_className != null) return _className;
                _className = GetFullPath();// GetFullName(ClassAddr);
                return _className;
            }
        }
        public nint _substructAddr = nint.MaxValue;
        public nint _classAddr = nint.MaxValue;
        public nint ClassAddr
        {
            get
            {
                if (_classAddr != nint.MaxValue) return _classAddr;
                if (AddrToClass.ContainsKey(Address))
                {
                    _classAddr = AddrToClass[Address];
                    return _classAddr;
                }
                _classAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(Address + classOffset);
                AddrToClass[Address] = _classAddr;
                return _classAddr;
            }
        }
        public UEObject(nint address = 0)
        {
            Address = address;
        }
        public Boolean IsA(nint entityClassAddr, String targetClassName)
        {
            var key = entityClassAddr + ":" + targetClassName;
            if (ClassIsSubClass.ContainsKey(key)) return ClassIsSubClass[key];
            var tempEntityClassAddr = entityClassAddr;
            while (true)
            {
                var tempEntity = new UEObject(tempEntityClassAddr);
                var className = tempEntity.GetFullPath();
                if (className == targetClassName)
                {
                    ClassIsSubClass[key] = true;
                    return true;
                }
                tempEntityClassAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(tempEntityClassAddr + structSuperOffset);
                if (tempEntityClassAddr == 0) break;
            }
            ClassIsSubClass[key] = false;
            return false;
        }
        public Boolean IsA(String className)
        {
            return IsA(ClassAddr, className);
        }
        public Boolean IsA<T>(out T converted) where T : UEObject
        {
            var n = typeof(T).Namespace;
            n = n.Substring(3, n.Length - 6).Replace(".", "/");
            n = "Class " + n + "." + typeof(T).Name;
            converted = As<T>();
            return IsA(ClassAddr, n);
        }
        public Boolean IsA<T>() where T : UEObject
        {
            if (Address == 0) return false;
            return IsA<T>(out _);
        }
        public static Boolean NewFName = true;
        public static String GetName(int key)
        {
            var namePtr = UnrealEngine.Memory.ReadProcessMemory<nint>(UnrealEngine.GNames + ((key >> 16) + 2) * 8);
            if (namePtr == 0) return "badIndex";
            var nameEntry = UnrealEngine.Memory.ReadProcessMemory<UInt16>(namePtr + (key & 0xffff) * 2);
            var nameLength = (Int32)(nameEntry >> 6);
            if (nameLength <= 0) return "badIndex";

            UnrealEngine.Memory.maxStringLength = nameLength;
            string result = UnrealEngine.Memory.ReadProcessMemory<String>(namePtr + (key & 0xffff) * 2 + 2);
            UnrealEngine.Memory.maxStringLength = 0x100;
            return result;
        }
        public String GetName()
        {
            return GetName(UnrealEngine.Memory.ReadProcessMemory<int>(Address + nameOffset));
        }
        public String GetShortName()
        {
            if (ClassToName.ContainsKey(ClassAddr)) return ClassToName[ClassAddr];
            var classNameIndex = UnrealEngine.Memory.ReadProcessMemory<int>(ClassAddr + nameOffset);
            ClassToName[ClassAddr] = GetName(classNameIndex);
            return ClassToName[ClassAddr];
        }
        public String GetFullPath()
        {
            if (AddrToName.ContainsKey(Address)) return AddrToName[Address];
            var classPtr = UnrealEngine.Memory.ReadProcessMemory<nint>(Address + classOffset);
            var classNameIndex = UnrealEngine.Memory.ReadProcessMemory<int>(classPtr + nameOffset);
            var name = GetName(classNameIndex);
            var outerEntityAddr = Address;
            var parentName = "";
            while (true)
            {
                var tempOuterEntityAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(outerEntityAddr + objectOuterOffset);
                //var tempOuterEntityAddr = Memory.ReadProcessMemory<UInt64>(outerEntityAddr + structSuperOffset);
                if (tempOuterEntityAddr == outerEntityAddr || tempOuterEntityAddr == 0) break;
                outerEntityAddr = tempOuterEntityAddr;
                var outerNameIndex = UnrealEngine.Memory.ReadProcessMemory<int>(outerEntityAddr + nameOffset);
                var tempName = GetName(outerNameIndex);
                if (tempName == "") break;
                if (tempName == "None") break;
                parentName = tempName + "." + parentName;
            }
            name += " " + parentName;
            var nameIndex = UnrealEngine.Memory.ReadProcessMemory<int>(Address + nameOffset);
            name += GetName(nameIndex);
            AddrToName[Address] = name;
            return name;
        }
        public String GetHierachy()
        {
            var sb = new StringBuilder();
            var tempEntityClassAddr = ClassAddr;
            while (true)
            {
                var tempEntity = new UEObject(tempEntityClassAddr);
                var className = tempEntity.GetFullPath();
                sb.AppendLine(className);
                tempEntityClassAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(tempEntityClassAddr + structSuperOffset);
                if (tempEntityClassAddr == 0) break;
            }
            return sb.ToString();
        }
        public String GetFieldType(nint fieldAddr)
        {
            if (FieldAddrToType.ContainsKey(fieldAddr)) return FieldAddrToType[fieldAddr];
            var fieldType = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + fieldClassOffset);
            var name = GetName(UnrealEngine.Memory.ReadProcessMemory<int>(fieldType + (NewFName ? 0 : fieldNameOffset)));
            FieldAddrToType[fieldAddr] = name;
            return name;
        }
        nint GetFieldAddr(nint origClassAddr, nint classAddr, string fieldName)
        {
            if (ClassFieldToAddr.ContainsKey(origClassAddr) && ClassFieldToAddr[origClassAddr].ContainsKey(fieldName)) return ClassFieldToAddr[origClassAddr][fieldName];
            var field = classAddr + childPropertiesOffset - fieldNextOffset;
            while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + fieldNextOffset)) > 0)
            {
                var fName = GetName(UnrealEngine.Memory.ReadProcessMemory<int>(field + fieldNameOffset));
                if (fName == fieldName)
                {
                    if (!ClassFieldToAddr.ContainsKey(origClassAddr))
                        ClassFieldToAddr[origClassAddr] = new ConcurrentDictionary<string, nint>();
                    ClassFieldToAddr[origClassAddr][fieldName] = field;
                    return field;
                }
            }
            var parentClass = UnrealEngine.Memory.ReadProcessMemory<nint>(classAddr + structSuperOffset);
            //if (parentClass == classAddr) throw new Exception("parent is me");
            if (parentClass == 0)
            {
                if (!ClassFieldToAddr.ContainsKey(origClassAddr))
                    ClassFieldToAddr[origClassAddr] = new ConcurrentDictionary<string, nint>();
                ClassFieldToAddr[origClassAddr][fieldName] = 0;
                return 0;
            }
            return GetFieldAddr(origClassAddr, parentClass, fieldName);
        }
        public nint GetFieldAddr(string fieldName)
        {
            return GetFieldAddr(ClassAddr, ClassAddr, fieldName);
        }
        public nint GetFuncAddr(nint origClassAddr, nint classAddr, String fieldName)
        {
            if (!NewFName) return GetFieldAddr(origClassAddr, classAddr, fieldName);
            if (ClassFieldToAddr.ContainsKey(origClassAddr) && ClassFieldToAddr[origClassAddr].ContainsKey(fieldName)) return ClassFieldToAddr[origClassAddr][fieldName];
            var field = classAddr + childrenOffset - funcNextOffset;
            while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + funcNextOffset)) > 0)
            {
                var fName = GetName(UnrealEngine.Memory.ReadProcessMemory<int>(field + nameOffset));
                if (fName == fieldName)
                {
                    if (!ClassFieldToAddr.ContainsKey(origClassAddr))
                        ClassFieldToAddr[origClassAddr] = new ConcurrentDictionary<String, nint>();
                    ClassFieldToAddr[origClassAddr][fieldName] = field;
                    return field;
                }
            }
            var parentClass = UnrealEngine.Memory.ReadProcessMemory<nint>(classAddr + structSuperOffset);
            if (parentClass == classAddr) throw new Exception("parent is me");
            if (parentClass == 0) throw new Exception("bad field");
            return GetFuncAddr(origClassAddr, parentClass, fieldName);
        }
        public int FieldOffset;
        public Byte[] Data;
        public nint _value = 0xcafeb00;
        public nint Value
        {
            get
            {
                if (_value != 0xcafeb00) return _value;
                _value = UnrealEngine.Memory.ReadProcessMemory<nint>(Address);
                return _value;
            }
            set
            {
                _value = 0xcafeb00;
                UnrealEngine.Memory.WriteProcessMemory(Address, value);
            }
        }

        public T GetValue<T>()
        {
            return UnrealEngine.Memory.ReadProcessMemory<T>(Address);
        }
        public void SetValue<T>(T value)
        {
            UnrealEngine.Memory.WriteProcessMemory<T>(Address, value);
        }
        UInt64 boolMask = 0;
        public Boolean Flag
        {
            get
            {
                var val = UnrealEngine.Memory.ReadProcessMemory<UInt64>(Address);
                return ((val & boolMask) == boolMask);
            }
            set
            {
                var val = UnrealEngine.Memory.ReadProcessMemory<UInt64>(Address);
                if (value) val |= boolMask;
                else val &= ~boolMask;
                UnrealEngine.Memory.WriteProcessMemory(Address, val);
                //UnrealEngine.Memory.WriteProcessMemory(Address, value);
            }

        }
        public nint Address;
        public UEObject this[String key]
        {
            get
            {
                var fieldAddr = GetFieldAddr(key);
                if (fieldAddr == 0) return null;
                var fieldType = GetFieldType(fieldAddr);
                var offset = GetFieldOffset(fieldAddr);
                UEObject obj;
                if (fieldType == "ObjectProperty" || fieldType == "ScriptStruct")
                    obj = new UEObject(UnrealEngine.Memory.ReadProcessMemory<nint>(Address + offset)) { FieldOffset = offset };
                else if (fieldType == "ArrayProperty")
                {
                    obj = new UEObject(Address + offset);
                    obj._classAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + fieldClassOffset);
                    var inner = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + propertySize);
                    var innerClass = UnrealEngine.Memory.ReadProcessMemory<nint>(inner + fieldClassOffset);
                    obj._substructAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(inner + propertySize);
                    //obj._substructAddr;
                }
                else if (fieldType.Contains("Bool"))
                {
                    obj = new UEObject(Address + offset);
                    obj._classAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + classOffset);
                    obj.boolMask = UnrealEngine.Memory.ReadProcessMemory<Byte>(fieldAddr + propertySize);
                }
                else if (fieldType.Contains("Function"))
                {
                    obj = new UEObject(fieldAddr);
                    //obj.BaseObjAddr = Address;
                }
                else if (fieldType.Contains("StructProperty"))
                {
                    obj = new UEObject(Address + offset);
                    obj._classAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + propertySize);
                }
                else if (fieldType.Contains("FloatProperty"))
                {
                    obj = new UEObject(Address + offset);
                    obj._classAddr = 0;
                }
                else
                {
                    obj = new UEObject(Address + offset);
                    obj._classAddr = UnrealEngine.Memory.ReadProcessMemory<nint>(fieldAddr + propertySize);
                }
                if (obj.Address == 0)
                {
                    obj = new UEObject(0);
                    //var classInfo = Engine.Instance.DumpClass(ClassAddr);
                    //throw new Exception("bad addr");
                }
                return obj;
            }
            set
            {
                var fieldAddr = GetFieldAddr(key);
                var offset = GetFieldOffset(fieldAddr);
                UnrealEngine.Memory.WriteProcessMemory(Address + offset, value.Address);
            }
        }
        public int _num = int.MaxValue;
        public int Num
        {
            get
            {
                if (_num != int.MaxValue) return _num;
                _num = UnrealEngine.Memory.ReadProcessMemory<int>(Address + 8);
                if (_num > 0x10000) _num = 0x10000;
                return _num;
            }
        }
        public Byte[] _arrayCache = new Byte[0];
        public Byte[] ArrayCache
        {
            get
            {
                if (_arrayCache.Length != 0) return _arrayCache;
                _arrayCache = UnrealEngine.Memory.ReadProcessMemory(Value, Num * 8);
                return _arrayCache;
            }
        }
        public UEObject this[int index] { get { return new UEObject((nint)BitConverter.ToUInt64(ArrayCache, index * 8)); } }
        public nint _vTableFunc = 0xcafeb00;
        public nint VTableFunc
        {
            get
            {
                if (_vTableFunc != 0xcafeb00) return _vTableFunc;
                _vTableFunc = UnrealEngine.Memory.ReadProcessMemory<nint>(Address) + vTableFuncNum * 8;
                _vTableFunc = UnrealEngine.Memory.ReadProcessMemory<nint>(_vTableFunc);
                return _vTableFunc;
            }
        }
        public T Invoke<T>(String funcName, params Object[] args)
        {
            var funcAddr = GetFuncAddr(ClassAddr, ClassAddr, funcName);
            var initFlags = UnrealEngine.Memory.ReadProcessMemory<nint>(funcAddr + funcFlagsOffset);
            var nativeFlag = initFlags;
            nativeFlag |= 0x400;
            UnrealEngine.Memory.WriteProcessMemory(funcAddr + funcFlagsOffset, BitConverter.GetBytes(nativeFlag));
            var val = UnrealEngine.Memory.ExecuteUEFunc<T>((IntPtr)VTableFunc, Address, (IntPtr)funcAddr, args);
            UnrealEngine.Memory.WriteProcessMemory(funcAddr + funcFlagsOffset, BitConverter.GetBytes(initFlags));
            return val;
        }
        public void Invoke(String funcName, params Object[] args)
        {
            Invoke<Int32>(funcName, args);
        }
        public T As<T>() where T : UEObject
        {
            var obj = (T)Activator.CreateInstance(typeof(T), Address);
            obj._classAddr = _classAddr;
            return obj;
        }
        public string Dump()
        {
            var tempEntity = ClassAddr;
            var fields = new List<object> { };
            while (true)
            {
                var classNameIndex = UnrealEngine.Memory.ReadProcessMemory<int>(tempEntity + nameOffset);
                var name = GetName(classNameIndex);
                var field = tempEntity + childPropertiesOffset - fieldNextOffset;
                while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + fieldNextOffset)) > 0)
                {
                    var fName = GetName(UnrealEngine.Memory.ReadProcessMemory<int>(field + fieldNameOffset));
                    var fType = GetFieldType(field);
                    var fValue = "(" + field.ToString("X") + ")";
                    var offset = GetFieldOffset(field);
                    if (fType == "BoolProperty")
                    {
                        fType = "Boolean";
                        fValue = this[fName].Flag.ToString();
                    }
                    else if (fType == "FloatProperty")
                    {
                        fType = "Single";
                        fValue = BitConverter.ToSingle(BitConverter.GetBytes(this[fName].Value), 0).ToString();
                    }
                    else if (fType == "DoubleProperty")
                    {
                        fType = "Double";
                        fValue = BitConverter.ToDouble(BitConverter.GetBytes(this[fName].Value), 0).ToString();
                    }
                    else if (fType == "IntProperty")
                    {
                        fType = "Int32";
                        fValue = ((int)this[fName].Value).ToString("X");
                    }
                    else if (fType == "ObjectProperty" || fType == "StructProperty")
                    {
                        var structFieldIndex = UnrealEngine.Memory.ReadProcessMemory<int>(UnrealEngine.Memory.ReadProcessMemory<nint>(field + UEObject.propertySize) + UEObject.nameOffset);
                        fType = UEObject.GetName(structFieldIndex);
                    }
                    /*fields.Add(new
                    {
                        info = fType + " " + fName + " = " + fValue
                    });*/
                    fields.Add(fType + " " + fName + " = " + fValue + " ( @ " + offset.ToString("X") + " - " + (this.Address + offset).ToString("X") + " )");
                }

                field = tempEntity + UEObject.childrenOffset - UEObject.funcNextOffset;
                while ((field = UnrealEngine.Memory.ReadProcessMemory<nint>(field + funcNextOffset)) > 0)
                {
                    var fName = UEObject.GetName(UnrealEngine.Memory.ReadProcessMemory<Int32>(field + nameOffset));
                }
                tempEntity = UnrealEngine.Memory.ReadProcessMemory<nint>(tempEntity + structSuperOffset);
                if (tempEntity == 0) break;
            }
            var obj = new
            {
                name = ClassName + " : " + GetFullPath(),
                hierarchy = GetHierachy(),
                fields
            };
            return System.Text.Json.JsonSerializer.Serialize(obj, new System.Text.Json.JsonSerializerOptions { IncludeFields = true, WriteIndented = true });
        }
    }
}
```

`UnrealSharp/UnrealSharp.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <PlatformTarget>x64</PlatformTarget>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <Version>1.0.0.1</Version>
  </PropertyGroup>

</Project>

```