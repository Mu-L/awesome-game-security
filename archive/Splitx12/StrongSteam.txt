Project Path: arc_Splitx12_StrongSteam_l1h5ud4r

Source Tree:

```txt
arc_Splitx12_StrongSteam_l1h5ud4r
├── GDI_Discord
│   ├── CRT.h
│   ├── CryptSTR.h
│   ├── GDI_Discord.vcxproj
│   ├── GDI_Discord.vcxproj.filters
│   ├── GDI_Discord.vcxproj.user
│   ├── Global.h
│   ├── Helpers.h
│   ├── HideImport.h
│   ├── Internals.h
│   ├── KGDI.h
│   ├── MathASM.asm
│   ├── MathASM.h
│   └── Source.cpp
├── README.md
├── StrongSteam.sln
└── example.png

```

`GDI_Discord/CRT.h`:

```h
template <typename StrType, typename StrType2>
_FI bool StrICmp(StrType Str, StrType2 InStr, bool Two) 
{
	#define ToLower(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)

	if (!Str || !InStr) 
		return false;

	wchar_t c1, c2; do {
		c1 = *Str++; c2 = *InStr++;
		c1 = ToLower(c1); c2 = ToLower(c2);
		if (!c1 && (Two ? !c2 : 1))
			return true;
	} while (c1 == c2);

	return false;
}

template <typename StrType> 
_FI int StrLen(StrType Str) {
	if (!Str) return 0;
	StrType Str2 = Str;
	while (*Str2) *Str2++;
	return (int)(Str2 - Str);
}

_FI void MemCpy(PVOID Dst, PVOID Src, ULONG Size) {
	__movsb((PUCHAR)Dst, (const PUCHAR)Src, Size);
}

_FI void MemZero(PVOID Ptr, SIZE_T Size, UCHAR Filling = 0) {
	__stosb((PUCHAR)Ptr, Filling, Size);
}
```

`GDI_Discord/CryptSTR.h`:

```h
/*
 * Copyright 2017 - 2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define JM_XORSTR_DISABLE_AVX_INTRINSICS 1

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#define XOR(str) ::jm::xor_string{[]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{} }
#define E(str) XOR(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

#if defined(__clang__) || defined(__GNUC__)
#define JM_XORSTR_LOAD_FROM_REG(x) ::jm::detail::load_from_reg(x)
#else
#define JM_XORSTR_LOAD_FROM_REG(x) (x)
#endif

namespace jm {

    namespace detail {

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for (char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<std::size_t N, class CharT>
        XORSTR_FORCEINLINE constexpr std::uint64_t
            load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
        {
            using cast_type = typename std::make_unsigned<CharT>::type;
            constexpr auto value_size = sizeof(CharT);
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for (std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
                value ^=
                (std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
            << ((i % idx_offset) * 8 * value_size));

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm("" : "=r"(value) : "0"(value) : );
#endif
            return value;
        }

        template<std::uint64_t V>
        struct uint64_v {
            constexpr static std::uint64_t value = V;
        };

    } // namespace detail

    template<class CharT, std::size_t Size, class Keys, class Indices>
    class xor_string;

    template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
    class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
        constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);
#else
        constexpr static inline std::uint64_t alignment = 16;
#endif

        alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

    public:
        using value_type = CharT;
        using size_type = std::size_t;
        using pointer = CharT*;
        using const_pointer = const CharT*;

        template<class L>
        XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
            : _storage{ JM_XORSTR_LOAD_FROM_REG(detail::uint64_v<detail::load_xored_str8<Size>(Keys, Indices, l())>::value)... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return Size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t* keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr (sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                        _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
                reinterpret_cast<__m128i*>(_storage) + Indices,
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast<pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            // crypt() function inlined by hand, because MSVC linker chokes when you have a lot of strings
            // on 32 bit builds, so don't blame me for shit code :pepekms:
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
            std::uint64_t* keys =
                (std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr (sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                        _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
                reinterpret_cast<__m128i*>(_storage) + Indices,
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
            return (pointer)(_storage);
        }
    };

    template<class L, std::size_t Size, std::size_t... Indices>
    xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>)->xor_string<
        std::remove_reference_t<decltype(l()[0])>,
        Size,
        std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
        std::index_sequence<Indices...>>;

} // namespace jm

#endif // include guard
```

`GDI_Discord/GDI_Discord.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>
    </TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>GDI_Discord</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>StrongSteam</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.sys</TargetExt>
    <IncludePath>$(windowssdkdir_10)include\$(targetplatformversion)\km;$(IncludePath)</IncludePath>
    <LibraryPath>$(windowssdkdir_10)lib\$(targetplatformversion)\km\x64;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)$(Platform)\</IntDir>
    <TargetName>LIL_HDD</TargetName>
    <OutDir>$(SolutionDir)$(Platform)\</OutDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <GuardEHContMetadata>false</GuardEHContMetadata>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WarningLevel>Level1</WarningLevel>
    </ClCompile>
    <Link>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Link>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <CETCompat>false</CETCompat>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SubSystem>Native</SubSystem>
      <LargeAddressAware>true</LargeAddressAware>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AssemblyDebug>false</AssemblyDebug>
      <AdditionalDependencies>ntoskrnl.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CRT.h" />
    <ClInclude Include="CryptSTR.h" />
    <ClInclude Include="Global.h" />
    <ClInclude Include="Helpers.h" />
    <ClInclude Include="HideImport.h" />
    <ClInclude Include="Internals.h" />
    <ClInclude Include="KGDI.h" />
    <ClInclude Include="MathASM.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="MathASM.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`GDI_Discord/GDI_Discord.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source Files\SDK">
      <UniqueIdentifier>{6fc0867a-8ba4-4a85-92f6-dae7350a3dc8}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Global.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Helpers.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Internals.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="CryptSTR.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="KGDI.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="HideImport.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="CRT.h">
      <Filter>Source Files\SDK</Filter>
    </ClInclude>
    <ClInclude Include="MathASM.h">
      <Filter>Source Files\SDK</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="MathASM.asm">
      <Filter>Source Files\SDK</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`GDI_Discord/GDI_Discord.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommand>C:\Users\busy10\Desktop\MEXFLEXER_DRV.exe</LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>$(TargetPath)</LocalDebuggerCommandArguments>
  </PropertyGroup>
</Project>
```

`GDI_Discord/Global.h`:

```h
//#pragma comment(linker, "/MERGE:.rdata=INIT") //hz
#pragma comment(linker, "/MERGE:.pdata=INIT")

#define _AMD64_ 1
#define _KERNEL_MODE 1
#define _FI __forceinline
extern "C" int _fltused = 0;

#include <ntifs.h>
#include <intrin.h>
#include <windef.h>

#include "Internals.h"
#include "CryptSTR.h"
#include "CRT.h"
#include "HideImport.h"
#include "Helpers.h"
#include "KGDI.h"

```

`GDI_Discord/Helpers.h`:

```h
//DBG Help
#define DBG 0
#ifdef DBG
#define wsp(a) DbgPrintEx(0, 0, "\nFACE WSTR: %ws\n", (a))
#define hp(a) DbgPrintEx(0, 0, "\nFACE HEX: 0x%p\n", (a))
#define sp(a) DbgPrintEx(0, 0, "\nFACE STR: %s\n", (a))
#define dp(a) DbgPrintEx(0, 0, "\nFACE DEC: %d\n", (a))
#endif

//ptr utils
template <typename Type>
_FI Type EPtr(Type Ptr) {
	auto Key = (ULONG64)SharedUserData->Cookie *
		SharedUserData->Cookie *
		SharedUserData->Cookie *
		SharedUserData->Cookie;
	return (Type)((ULONG64)Ptr ^ Key);
}

template<typename Ret = void, typename... ArgT>
_FI Ret CallPtr(PVOID Fn, ArgT... Args) {
	typedef Ret(*ShellFn)(ArgT...);
	return ((ShellFn)Fn)(Args...);
}

//kernel memory utils
_FI PVOID KAlloc(ULONG Size) {
	PVOID Buff = ImpCall(ExAllocatePoolWithTag, NonPagedPoolNx, Size, 'KgxD');
	MemZero(Buff, Size);
	return Buff;
}

_FI void KFree(PVOID Ptr) {
	ImpCall(ExFreePoolWithTag, Ptr, 'KgxD');
}

//basic utils
PVOID FindSection(PVOID ModBase, const char* Name, PULONG SectSize)
{
	//get & enum sections
	PIMAGE_NT_HEADERS NT_Header = NT_HEADER(ModBase);
	PIMAGE_SECTION_HEADER Sect = IMAGE_FIRST_SECTION(NT_Header);
	for (PIMAGE_SECTION_HEADER pSect = Sect; pSect < Sect + NT_Header->FileHeader.NumberOfSections; pSect++)
	{
		//copy section name
		char SectName[9]; SectName[8] = 0;
		*(ULONG64*)&SectName[0] = *(ULONG64*)&pSect->Name[0];

		//check name
		if (StrICmp(Name, SectName, true))
		{
			//save size
			if (SectSize) {
				ULONG SSize = SizeAlign(max(pSect->Misc.VirtualSize, pSect->SizeOfRawData));
				*SectSize = SSize;
			}

			//ret full sect ptr
			return (PVOID)((ULONG64)ModBase + pSect->VirtualAddress);
		}
	}

	//no section
	return nullptr;
}

PUCHAR FindPatternSect(PVOID ModBase, const char* SectName, const char* Pattern)
{
	//find pattern utils
	#define InRange(x, a, b) (x >= a && x <= b) 
	#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : ((x - 'A') + 0xA))
	#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

	//get sect range
	ULONG SectSize;
	PUCHAR ModuleStart = (PUCHAR)FindSection(ModBase, SectName, &SectSize);
	PUCHAR ModuleEnd = ModuleStart + SectSize;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');
		if (SkipByte || *ModuleStart == GetByte(CurPatt)) {
			if (!FirstMatch) FirstMatch = ModuleStart;
			SkipByte ? CurPatt += 2 : CurPatt += 3;
			if (CurPatt[-1] == 0) return FirstMatch;
		}

		else if (FirstMatch) {
			ModuleStart = FirstMatch;
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	//failed
	return nullptr;
}

PVOID NQSI(SYSTEM_INFORMATION_CLASS Class)
{
	ULONG ret_size;
	for (size_t i = 0x1000;; i += 0x1000) {
		PVOID pInfo = KAlloc(i);
		if (NT_SUCCESS(ImpCall(ZwQuerySystemInformation, Class, pInfo, i, &ret_size))) {
			return pInfo;
		}
		KFree(pInfo);
	}
}

PVOID GetProcAdress(PVOID ModBase, const char* Name)
{
	//parse headers
	PIMAGE_NT_HEADERS NT_Head = NT_HEADER(ModBase);
	PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY)((ULONG64)ModBase + NT_Head->OptionalHeader.DataDirectory[0].VirtualAddress);

	//process records
	for (ULONG i = 0; i < ExportDir->NumberOfNames; i++)
	{
		//get ordinal & name
		USHORT Ordinal = ((USHORT*)((ULONG64)ModBase + ExportDir->AddressOfNameOrdinals))[i];
		const char* ExpName = (const char*)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfNames))[i];

		//check export name
		if (StrICmp(Name, ExpName, true))
			return (PVOID)((ULONG64)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfFunctions))[Ordinal]);
	}

	//no export
	return nullptr;
}

_FI void Sleep(LONG64 MSec) {
	LARGE_INTEGER Delay; Delay.QuadPart = -MSec * 10000;
	ImpCall(KeDelayExecutionThread, KernelMode, false, &Delay);
}

//process utils
_FI PEPROCESS AttachToProcess(HANDLE PID)
{
	//get eprocess
	PEPROCESS Process = nullptr;
	if (ImpCall(PsLookupProcessByProcessId, PID, &Process) || !Process)
		return nullptr;

	//take process lock
	if (ImpCall(PsAcquireProcessExitSynchronization, Process))
	{
		//process lock failed
		ImpCall(ObfDereferenceObject, Process);
		return nullptr;
	}

	//attach to process
	ImpCall(KeAttachProcess, Process);
	return Process;
}

_FI void DetachFromProcess(PEPROCESS Process)
{
	//check valid process
	if (Process != nullptr)
	{
		//de-attach to process
		ImpCall(KeDetachProcess);

		//cleanup & process unlock
		ImpCall(ObfDereferenceObject, Process);
		ImpCall(PsReleaseProcessExitSynchronization, Process);
	}
}

PVOID GetUserModuleBase(PEPROCESS Process, const char* ModName)
{
	if (ImpCall(IoIs32bitProcess, nullptr)) {
		PPEB32 pPeb32 = (PPEB32)ImpCall(PsGetProcessWow64Process, Process);
		if (!pPeb32 || !pPeb32->Ldr) return nullptr;

		for (PLIST_ENTRY32 pListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList.Flink;
			pListEntry != &((PPEB_LDR_DATA32)pPeb32->Ldr)->InLoadOrderModuleList;
			pListEntry = (PLIST_ENTRY32)pListEntry->Flink) {
			PLDR_DATA_TABLE_ENTRY32 pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
			if (StrICmp(ModName, (PWCH)pEntry->BaseDllName.Buffer, false))
				return (PVOID)pEntry->DllBase;
		}
	}
	else {
		PPEB PEB = ImpCall(PsGetProcessPeb, Process);
		if (!PEB || !PEB->Ldr) return nullptr;

		for (PLIST_ENTRY pListEntry = PEB->Ldr->InLoadOrderModuleList.Flink;
			pListEntry != &PEB->Ldr->InLoadOrderModuleList;
			pListEntry = pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

			if (StrICmp(ModName, pEntry->BaseDllName.Buffer, false))
				return pEntry->DllBase;
		}
	}

	return nullptr;
}

PVOID GetUserModuleBase1(PEPROCESS Process, const char* ModName)
{
	//get peb & ldr
	PPEB PEB = ImpCall(PsGetProcessPeb, Process);
	if (!PEB || !PEB->Ldr) return nullptr;

	//process modules list (with peb->ldr)
	for (PLIST_ENTRY pListEntry = PEB->Ldr->InLoadOrderModuleList.Flink;
		pListEntry != &PEB->Ldr->InLoadOrderModuleList;
		pListEntry = pListEntry->Flink)
	{
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (StrICmp(ModName, pEntry->BaseDllName.Buffer, false))
			return pEntry->DllBase;
	}

	//no module
	return nullptr;
}

_FI PVOID UAlloc(ULONG Size, ULONG Protect = PAGE_READWRITE) {
	PVOID AllocBase = nullptr; SIZE_T SizeUL = SizeAlign(Size);
	if (!ImpCall(ZwAllocateVirtualMemory, ZwCurrentProcess(), &AllocBase, 0, &SizeUL, MEM_COMMIT, Protect)) {
		MemZero(AllocBase, SizeUL);
	}
	return AllocBase;
}

_FI void UFree(PVOID Ptr) {
	SIZE_T SizeUL = 0;
	ImpCall(ZwFreeVirtualMemory, ZwCurrentProcess(), &Ptr, &SizeUL, MEM_RELEASE);
}

void CallUserMode(PVOID Func)
{
	//get user32 (KernelCallbackTable table ptr)
	PEPROCESS Process = ImpCall(IoGetCurrentProcess);
	PVOID ModBase = GetUserModuleBase(Process, E("user32"));
	PVOID DataSect = FindSection(ModBase, E(".data"), nullptr);
	ULONG64 AllocPtr = ((ULONG64)DataSect + 0x2000 - 0x8);
	ULONG64 CallBackPtr = (ULONG64)ImpCall(PsGetProcessPeb, Process)->KernelCallbackTable;
	ULONG Index = (ULONG)((AllocPtr - CallBackPtr) / 8);

	//store func ptr in place
	auto OldData = _InterlockedExchangePointer((PVOID*)AllocPtr, Func);

	//enable apc (FIX BSOD)
	//ImpCall(KeLeaveGuardedRegion);

	//call usermode
	union Garbage { ULONG ulong; PVOID pvoid; } Garbage;
	ImpCall(KeUserModeCallback, Index, nullptr, 0, &Garbage.pvoid, &Garbage.ulong);

	//store old ptr in place
	_InterlockedExchangePointer((PVOID*)AllocPtr, OldData);

	//disable apc
	//ImpCall(KeEnterGuardedRegion);
}

//kernel utils
PEPROCESS GetProcessWModule(const char* ProcName, const char* ModName, PVOID* WaitModBase)
{
	//get process list
	PEPROCESS EProc = nullptr;
	PSYSTEM_PROCESS_INFO pInfo = (PSYSTEM_PROCESS_INFO)NQSI(SystemProcessInformation), pInfoCur = pInfo;

	while (true)
	{
		//get process name
		const wchar_t* ProcessName = pInfoCur->ImageName.Buffer;
		if (ImpCall(MmIsAddressValid, (PVOID)ProcessName))
		{
			//check process name
			if (StrICmp(ProcName, ProcessName, true))
			{
				//attach to process
				PEPROCESS Process = AttachToProcess(pInfoCur->UniqueProcessId);
				if (Process != nullptr)
				{
					//check wait module
					PVOID ModBase = GetUserModuleBase(Process, ModName);
					if (ModBase)
					{
						//save modbase
						if (WaitModBase)
							*WaitModBase = ModBase;

						//save eprocess
						//dp(pInfoCur->UniqueProcessId);

						EProc = Process;
						break;
					}

					//failed, no wait module
					DetachFromProcess(Process);
				}
			}
		}

		//goto next process entry
		if (!pInfoCur->NextEntryOffset) break;
		pInfoCur = (PSYSTEM_PROCESS_INFO)((ULONG64)pInfoCur + pInfoCur->NextEntryOffset);
	}

	//cleanup
	KFree(pInfo);
	return EProc;
}

PVOID GetKernelModuleBase(const char* ModName)
{
	//get module list
	PSYSTEM_MODULE_INFORMATION ModuleList = (PSYSTEM_MODULE_INFORMATION)NQSI(SystemModuleInformation);

	//process module list
	PVOID ModuleBase = 0;
	for (ULONG64 i = 0; i < ModuleList->ulModuleCount; i++)
	{
		SYSTEM_MODULE Module = ModuleList->Modules[i];
		if (StrICmp(&Module.ImageName[Module.ModuleNameOffset], ModName, true)) {
			ModuleBase = Module.Base;
			break;
		}
	}

	//cleanup
	KFree(ModuleList);
	return ModuleBase;
}

PUCHAR FindPatternInProcess(ULONG ModBase, const char* Pattern)
{
	//find pattern utils
	#define InRange(x, a, b) (x >= a && x <= b) 
	#define GetBits(x) (InRange(x, '0', '9') ? (x - '0') : ((x - 'A') + 0xA))
	#define GetByte(x) ((UCHAR)(GetBits(x[0]) << 4 | GetBits(x[1])))

	//get module range
	PUCHAR ModuleStart = (PUCHAR)ModBase; if (!ModuleStart) return nullptr;
	PIMAGE_NT_HEADERS NtHeader = ((PIMAGE_NT_HEADERS)(ModuleStart + ((PIMAGE_DOS_HEADER)ModuleStart)->e_lfanew));
	PUCHAR ModuleEnd = (PUCHAR)(ModuleStart + NtHeader->OptionalHeader.SizeOfImage - 0x1000); ModuleStart += 0x1000;

	//scan pattern main
	PUCHAR FirstMatch = nullptr;
	const char* CurPatt = Pattern;
	for (; ModuleStart < ModuleEnd; ++ModuleStart)
	{
		bool SkipByte = (*CurPatt == '\?');
		if (SkipByte || *ModuleStart == GetByte(CurPatt))
		{
			if (!FirstMatch)
				FirstMatch = ModuleStart;

			SkipByte ? CurPatt += 2 : CurPatt += 3;

			if (CurPatt[-1] == 0)
				return FirstMatch;
		}
		else if (FirstMatch)
		{
			ModuleStart = FirstMatch;
			FirstMatch = nullptr;
			CurPatt = Pattern;
		}
	}

	return nullptr;
}

//memory
template<typename ReadType>
__forceinline ReadType Read(DWORD Addr)
{
	ReadType ReadData{};
	if (Addr && ImpCall(MmIsAddressValid, (PVOID)Addr)) {
		ReadData = *(ReadType*)Addr;
	}

	return ReadData;
}

__forceinline bool ReadArr(DWORD Addr, PVOID Buff, ULONG Size)
{
	if (ImpCall(MmIsAddressValid, (PVOID)Addr)) {
		MemCpy(Buff, (PVOID)Addr, Size);
		return true;
	}

	return false;
}

template<typename WriteType>
__forceinline void Write(DWORD Addr, WriteType Data)
{
	if (ImpCall(MmIsAddressValid, (PVOID)Addr)) {
		*(WriteType*)Addr = Data;
	}
}

__forceinline void WriteArr(DWORD Addr, PVOID Buff, ULONG Size){
	if (ImpCall(MmIsAddressValid, (PVOID)Addr)) {
		MemCpy((PVOID)Addr, Buff, Size);
	}
}

template<typename WriteType>
__forceinline bool WriteProt(DWORD Addr, /*const*/ WriteType/*&*/ Data) 
{
	PVOID Addr1 = (PVOID)Addr;
	SIZE_T Size1 = sizeof(WriteType);
	
	//hp(Addr1);

	ULONG oldProt;
	if (!ImpCall(ZwProtectVirtualMemory, ZwCurrentProcess(), &Addr1, &Size1, PAGE_EXECUTE_READWRITE, &oldProt))
	{
		auto data1 = Data;
		MemCpy((PVOID)Addr, &data1, sizeof(WriteType));

		//hp(Addr1);
		ImpCall(ZwProtectVirtualMemory, ZwCurrentProcess(), &Addr1, &Size1, oldProt, &oldProt);

		return true;
	}

	return false;
}
```

`GDI_Discord/HideImport.h`:

```h
//Setup Import Defines
#define ImpSet(a) a##Fn = (a##Def)EPtr(GetProcAdress(KBase, E(#a)));
#define ImpDef(a) using a##Def = decltype(&a); a##Def a##Fn = nullptr;
#define ImpCall(a, ...) ((a##Def)EPtr(a##Fn))(__VA_ARGS__)

ImpDef(IoIs32bitProcess);
ImpDef(ZwProtectVirtualMemory);
ImpDef(PsGetProcessWow64Process);

ImpDef(ZwQueryObject);
ImpDef(ExAllocatePoolWithTag);
ImpDef(ExFreePoolWithTag);
ImpDef(IoGetCurrentProcess);
ImpDef(KeAttachProcess);
ImpDef(KeDelayExecutionThread);
ImpDef(KeDetachProcess);
ImpDef(KeEnterGuardedRegion);
ImpDef(KeLeaveGuardedRegion);
ImpDef(KeQueryAuxiliaryCounterFrequency);
ImpDef(KeUserModeCallback);
ImpDef(MmIsAddressValid);
ImpDef(ObfDereferenceObject);
ImpDef(PsAcquireProcessExitSynchronization);
ImpDef(PsGetProcessPeb);
ImpDef(PsLookupProcessByProcessId);
ImpDef(PsLookupThreadByThreadId);
ImpDef(PsReleaseProcessExitSynchronization);
ImpDef(RtlCreateUserThread);
ImpDef(ZwAllocateVirtualMemory);
ImpDef(ZwClose);
ImpDef(ZwFreeVirtualMemory);
ImpDef(ZwQuerySystemInformation);
ImpDef(ZwQueryVirtualMemory); 
ImpDef(MmSecureVirtualMemory);
```

`GDI_Discord/Internals.h`:

```h
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, *PPEB;

typedef struct _IMAGE_DOS_HEADER
{
	USHORT e_magic;
	USHORT e_cblp;
	USHORT e_cp;
	USHORT e_crlc;
	USHORT e_cparhdr;
	USHORT e_minalloc;
	USHORT e_maxalloc;
	USHORT e_ss;
	USHORT e_sp;
	USHORT e_csum;
	USHORT e_ip;
	USHORT e_cs;
	USHORT e_lfarlc;
	USHORT e_ovno;
	USHORT e_res[4];
	USHORT e_oemid;
	USHORT e_oeminfo;
	USHORT e_res2[10];
	LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER
{
	USHORT Machine;
	USHORT NumberOfSections;
	ULONG TimeDateStamp;
	ULONG PointerToSymbolTable;
	ULONG NumberOfSymbols;
	USHORT SizeOfOptionalHeader;
	USHORT Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
	ULONG VirtualAddress;
	ULONG Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
	USHORT Magic;
	UCHAR MajorLinkerVersion;
	UCHAR MinorLinkerVersion;
	ULONG SizeOfCode;
	ULONG SizeOfInitializedData;
	ULONG SizeOfUninitializedData;
	ULONG AddressOfEntryPoint;
	ULONG BaseOfCode;
	ULONGLONG ImageBase;
	ULONG SectionAlignment;
	ULONG FileAlignment;
	USHORT MajorOperatingSystemVersion;
	USHORT MinorOperatingSystemVersion;
	USHORT MajorImageVersion;
	USHORT MinorImageVersion;
	USHORT MajorSubsystemVersion;
	USHORT MinorSubsystemVersion;
	ULONG Win32VersionValue;
	ULONG SizeOfImage;
	ULONG SizeOfHeaders;
	ULONG CheckSum;
	USHORT Subsystem;
	USHORT DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	ULONG LoaderFlags;
	ULONG NumberOfRvaAndSizes;
	struct _IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
	ULONG Signature;
	struct _IMAGE_FILE_HEADER FileHeader;
	struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER
{
	UCHAR  Name[8];
	union
	{
		ULONG PhysicalAddress;
		ULONG VirtualSize;
	} Misc;
	ULONG VirtualAddress;
	ULONG SizeOfRawData;
	ULONG PointerToRawData;
	ULONG PointerToRelocations;
	ULONG PointerToLinenumbers;
	USHORT  NumberOfRelocations;
	USHORT  NumberOfLinenumbers;
	ULONG Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
	ULONG   Characteristics;
	ULONG   TimeDateStamp;
	USHORT  MajorVersion;
	USHORT  MinorVersion;
	ULONG   Name;
	ULONG   Base;
	ULONG   NumberOfFunctions;
	ULONG   NumberOfNames;
	ULONG   AddressOfFunctions;
	ULONG   AddressOfNames;
	ULONG   AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _SYSTEM_MODULE
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;

typedef struct _SYSTEM_HANDLE
{
	ULONG ProcessId;
	UCHAR ObjectTypeNumber;
	UCHAR Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

#define RVA(Instr, InstrSize) ((DWORD64)Instr + InstrSize + *(LONG*)((DWORD64)Instr + (InstrSize - sizeof(LONG))))

#define NT_HEADER(ModBase) (PIMAGE_NT_HEADERS)((ULONG64)(ModBase) + ((PIMAGE_DOS_HEADER)(ModBase))->e_lfanew)

#define IMAGE_FIRST_SECTION(NtHeader) (PIMAGE_SECTION_HEADER)(NtHeader + 1)

#define SizeAlign(Size) ((Size + 0xFFF) & 0xFFFFFFFFFFFFF000)

extern "C"
{
	NTKERNELAPI PPEB PsGetProcessPeb(PEPROCESS);
	NTKERNELAPI PVOID PsGetProcessWow64Process(PEPROCESS Process);
	NTKERNELAPI void PsReleaseProcessExitSynchronization(PEPROCESS);
	NTKERNELAPI NTSTATUS PsAcquireProcessExitSynchronization(PEPROCESS);
	NTKERNELAPI NTSTATUS KeUserModeCallback(ULONG, PVOID, ULONG, PVOID*, PULONG);
	NTKERNELAPI NTSTATUS ZwWaitForMultipleObjects(
		ULONG Count,
		HANDLE Object[],
		WAIT_TYPE WaitType,
		BOOLEAN Alertable,
		PLARGE_INTEGER Time);
	NTSYSAPI NTSTATUS ZwProtectVirtualMemory(HANDLE, PVOID*, SIZE_T*, ULONG, PULONG);
	NTKERNELAPI NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
	NTSYSAPI NTSTATUS RtlCreateUserThread(HANDLE, PVOID, BOOLEAN, ULONG, SIZE_T, SIZE_T, PVOID, PVOID, PHANDLE, PCLIENT_ID);
}
```

`GDI_Discord/KGDI.h`:

```h
#include <wingdi.h>

//render
class Render
{
private:
    //obj
    HDC ScreenDC;
    HFONT CurFont;
    HBITMAP ScreenBitmap;
    HBITMAP ScaleScreenBitmap;

    //desc
    int ScrScale;
    int CurrentWidth;
    int CurrentHeight;

    //um buffer
    PVOID UserBuffer;
    PVOID DcAttrObject;
    PBYTE MappedTexture;
    PBYTE ScaleMappedTexture;
    
    //shared internals
    PVOID GetWin32k(const char* Name)
    {
        //win32kfull
        auto win32kFull = GetKernelModuleBase(E("win32kfull.sys"));
        auto func = GetProcAdress(win32kFull, Name);

        //win32kbase
        if (!func) {
            auto win32kBase = GetKernelModuleBase(E("win32kbase.sys"));
            func = GetProcAdress(win32kBase, Name);
        }

        //win32k
        if (!func) {
            auto win32k = GetKernelModuleBase(E("win32k.sys"));
            func = GetProcAdress(win32k, Name);
        }

        return func;
    }

    HPEN SelectPenInternal(HPEN hPen)
    {
        static PVOID NtGdiSelectPen_Fn = nullptr;
        if (!NtGdiSelectPen_Fn) {
            NtGdiSelectPen_Fn = EPtr(GetWin32k(E("NtGdiSelectPen")));
        }

        //call NtGdiSelectPen
        return CallPtr<HPEN>(EPtr(NtGdiSelectPen_Fn), EPtr(ScreenDC), hPen);
    }

    void RemoveObjInternal(HGDIOBJ Obj)
    {
        if (Obj)
        {
            static PVOID DeleteObject_Fn = nullptr;
            if (!DeleteObject_Fn) {
                DeleteObject_Fn = EPtr(GetWin32k(E("NtGdiDeleteObjectApp")));
            }

            //call NtGdiDeleteObjectApp
            CallPtr(EPtr(DeleteObject_Fn), Obj);
        }
    }

    HFONT SelectFontInternal(HFONT hFont)
    {
        static PVOID NtGdiSelectFont_Fn = nullptr;
        if (!NtGdiSelectFont_Fn) {
            NtGdiSelectFont_Fn = EPtr(GetWin32k(E("NtGdiSelectFont")));
        }

        //call NtGdiSelectFont
        return CallPtr<HFONT>(EPtr(NtGdiSelectFont_Fn), EPtr(ScreenDC), hFont);
    }

    HBITMAP SelectBitMapInternal(HBITMAP BitMap)
    {
        static PVOID NtGdiSelectBitmap_Fn = nullptr;
        if (!NtGdiSelectBitmap_Fn) {
            NtGdiSelectBitmap_Fn = EPtr(GetWin32k(E("NtGdiSelectBitmap")));
        }

        //call NtGdiSelectBitmap
        return CallPtr<HBITMAP>(EPtr(NtGdiSelectBitmap_Fn), EPtr(ScreenDC), BitMap);
    }

    _FI HGDIOBJ GetStockObjectInternal(ULONG Index)
    {
        //get GdiSharedHandleTable
        auto PEB = ImpCall(PsGetProcessPeb, ImpCall(IoGetCurrentProcess));
        auto GdiSharedHandleTable = *(ULONG64*)((ULONG64)PEB + 0xF8/*GdiSharedHandleTable*/);

        //get object
        const auto ObjArray = (ULONG64*)(GdiSharedHandleTable + 0x1800B0/*in GetStockObject*/);
        return (HGDIOBJ)ObjArray[Index];
    }

    _FI PVOID GetDCObjectInternal()
    {
        //get GdiSharedHandleTable
        auto PEB = ImpCall(PsGetProcessPeb, ImpCall(IoGetCurrentProcess));
        auto pGdiSharedHandleTable = *(ULONG64*)((ULONG64)PEB + 0xF8/*GdiSharedHandleTable*/);

        //get index
        #pragma warning(disable: 4311) 
        auto a1 = EPtr(ScreenDC);
        auto v2 = (unsigned __int16)a1 | ((unsigned int)a1 >> 8) & 0xFF0000; //shit rcast not works
        #pragma warning(default:4311)
        if ((unsigned int)v2 < 0x10000 || *(unsigned __int8*)(pGdiSharedHandleTable + 24i64 * (unsigned __int16)v2 + 13) == (unsigned int)v2 >> 16) {
            v2 = (unsigned __int16)v2;
        }

        //get object
        struct GDICELL { PVOID s1; PVOID s2; PVOID UserAddress; };
        return ((GDICELL*)pGdiSharedHandleTable)[v2].UserAddress;
    }

    //draw polygon & polyline
    void PolyLineInternal(POINT* Dots, ULONG64 NumDots, int Thick, COLORREF Color)
    {
        //decrt DC
        auto hDC = EPtr(ScreenDC);

        //NtGdiCreatePen
        static PVOID NtGdiCreatePen_Fn = nullptr;
        if (!NtGdiCreatePen_Fn) {
            NtGdiCreatePen_Fn = EPtr(GetWin32k(E("NtGdiCreatePen")));
        }

        //create & select pen
        auto Pen = CallPtr<HPEN>(EPtr(NtGdiCreatePen_Fn), PS_SOLID, Thick, Color, 0ull);
        auto oldPen = SelectPenInternal(Pen);

        //fill line
        static PVOID GrePolyPolyline = nullptr;
        if (!GrePolyPolyline)
            GrePolyPolyline = EPtr(GetWin32k(E("GrePolyPolyline")));
        CallPtr(EPtr(GrePolyPolyline), hDC, Dots, &NumDots, 1ull, NumDots);

        //cleanup
        SelectPenInternal(oldPen);
        RemoveObjInternal(Pen);
    }

    void PolygonInternal(POINT* Dots, ULONG64 NumDots, COLORREF Color)
    {
        //decrt
        auto hDC = EPtr(ScreenDC);
        auto Obj = EPtr(DcAttrObject);

        //select colors
        SelectPenInternal((HPEN)GetStockObjectInternal(NULL_PEN));
        *(DWORD*)((ULONG64)Obj + 0xC0) = Color; //in SetDCBrushColor
        *(DWORD*)((ULONG64)Obj + 0x98) |= 1u;   //in SetDCBrushColor

        //fill polygon
        static PVOID GrePolyPolygon = nullptr;
        if (!GrePolyPolygon)
            GrePolyPolygon = EPtr(GetWin32k(E("GrePolyPolygon")));
        CallPtr(EPtr(GrePolyPolygon), hDC, Dots, &NumDots, 1ull, NumDots);
    }

    //fast math
    _FI float CosAdd(float x) {
        float x2 = x * x;
        const float c1 = 0.99940307f;
        const float c2 = -0.49558072f;
        const float c3 = 0.03679168f;
        return (c1 + x2 * (c2 + c3 * x2));
    }

    _FI float FastSqrt(float x) {
        union { int i; float x; } u; u.x = x;
        u.i = (1 << 29) + (u.i >> 1) - (1 << 22);
        return u.x;
    }

    _FI float FastCos(float angle) {
        angle = angle - floorf(angle * 0.15f) * 6.28f;
        angle = angle > 0.f ? angle : -angle;
        if (angle < 1.57f) return CosAdd(angle);
        if (angle < 3.14f) return -CosAdd(3.14f - angle);
        if (angle < 4.71f) return -CosAdd(angle - 3.14f);
        return CosAdd(6.28f - angle);
    }

    _FI float FastSin(float angle) {
        return FastCos(1.57f - angle);
    }

    //setup
    void Init(int Width, int Height, const wchar_t* FontName, int FontSize, int Scale)
    {
        //create dc
        ScreenDC = EPtr(CallPtr<HDC>(GetWin32k(E("NtGdiCreateCompatibleDC")), nullptr));

        //alloc usermode buff
        UserBuffer = EPtr(UAlloc(4096));

        //create bitmap (normal size)
        PBITMAPINFO InfoUser = (PBITMAPINFO)EPtr(UserBuffer);
        InfoUser->bmiHeader.biSize = 40;
        InfoUser->bmiHeader.biWidth = Width;
        InfoUser->bmiHeader.biHeight = -Height;
        InfoUser->bmiHeader.biPlanes = 1;
        InfoUser->bmiHeader.biBitCount = 32;
        InfoUser->bmiHeader.biCompression = 0;
        InfoUser->bmiHeader.biSizeImage = Width * Height * 4;
        PVOID* MappedTextureUser = (PVOID*)((ULONG64)InfoUser + 0x800);
        PVOID NtGdiCreateDIBSection_Fn = GetWin32k(E("NtGdiCreateDIBSection"));
        ScreenBitmap = EPtr(CallPtr<HBITMAP>(NtGdiCreateDIBSection_Fn, EPtr(ScreenDC), nullptr, 0, InfoUser, 0, 40, 0, 0, MappedTextureUser));
        MappedTexture = EPtr((PBYTE)*MappedTextureUser);

        //get w32k base (for resolve many functions)
        auto win32kFull = GetKernelModuleBase(E("win32kfull.sys"));

        //need scale
        if (Scale > 1)
        {
            //create bitmap (normal size * scale)
            InfoUser->bmiHeader.biWidth = (Width * Scale);
            InfoUser->bmiHeader.biHeight = -(Height * Scale);
            InfoUser->bmiHeader.biSizeImage = (Width * Scale) * (Height * Scale) * 4;
            ScaleScreenBitmap = EPtr(CallPtr<HBITMAP>(NtGdiCreateDIBSection_Fn, EPtr(ScreenDC), nullptr, 0, InfoUser, 0, 40, 0, 0, MappedTextureUser));
            ScaleMappedTexture = EPtr((PBYTE)*MappedTextureUser);

            //GreSetStretchBltMode (FIX MIXING COLORS, SLOW)
            auto GreSetStretchBltMode = (PVOID)RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? 48 8B D7 89 84")), 5);
            CallPtr(GreSetStretchBltMode, EPtr(ScreenDC), HALFTONE);
        }

        //cleanup
        MemZero(InfoUser, 0x808/*https://en.wikipedia.org/wiki/808_Mafia*/);

        //select backbuffer
        SelectBitMapInternal(EPtr(((Scale > 1) ? ScaleScreenBitmap : ScreenBitmap)));

        //create font desc
        ENUMLOGFONTEXDVW EnumFont; 
        MemZero(&EnumFont, sizeof(ENUMLOGFONTEXDVW));
        EnumFont.elfEnumLogfontEx.elfLogFont.lfWeight = FW_MEDIUM;
        EnumFont.elfEnumLogfontEx.elfLogFont.lfHeight = FontSize * Scale;
        MemCpy(&EnumFont.elfEnumLogfontEx.elfLogFont.lfFaceName, (PVOID)FontName, (StrLen(FontName) + 1) * 2);

        //create & select font
        CurFont = EPtr(CallPtr<HFONT>(GetWin32k(E("hfontCreate")), &EnumFont, 0ull, 0ull, 0ull, 0ull));
        SelectFontInternal(EPtr(CurFont));

        //fix text alpha
        PVOID GreSetBkMode = (PVOID)RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? 89 45 7F 85")), 5);
        CallPtr(GreSetBkMode, EPtr(ScreenDC), TRANSPARENT);

        //fixup solid brush
        DcAttrObject = EPtr(GetDCObjectInternal());
        CallPtr<HBRUSH>(GetWin32k(E("NtGdiSelectBrush")), EPtr(ScreenDC), GetStockObjectInternal(DC_BRUSH));
        
        //save vars
        ScrScale = Scale;
        CurrentWidth = Width;
        CurrentHeight = Height;
    }

public:
    //mgr
    _FI void NewFrame(int Width, int Height, const wchar_t* FontName, int FontSize, int ExtraSample = 1)
    {
        //need init/reinit
        if ((Width != CurrentWidth) || (Height != CurrentHeight)) 
        {
            //cleanup
            Release();

            //setup render
            Init(Width, Height, FontName, FontSize, ExtraSample);
        }
    }

    void EndFrame(PBYTE Buffer)
    {
        //apply extrasampling
        if (ScrScale > 1)
        {
            //select original size bitmap
            auto SBitMap = SelectBitMapInternal(EPtr(ScreenBitmap));

            //NtGdiStretchDIBitsInternal
            static PVOID NtGdiStretchDIBitsInternal_Fn = nullptr;
            if (!NtGdiStretchDIBitsInternal_Fn) {
                NtGdiStretchDIBitsInternal_Fn = EPtr(GetWin32k(E("NtGdiStretchDIBitsInternal")));
            }

            //create desc bitmap
            PBITMAPINFO InfoUser = (PBITMAPINFO)EPtr(UserBuffer);
            InfoUser->bmiHeader.biSize = 40;
            InfoUser->bmiHeader.biPlanes = 1;
            InfoUser->bmiHeader.biBitCount = 32;
            InfoUser->bmiHeader.biWidth = (CurrentWidth * ScrScale);
            InfoUser->bmiHeader.biHeight = -(CurrentHeight * ScrScale);
            InfoUser->bmiHeader.biSizeImage = (CurrentWidth * ScrScale) * (CurrentHeight * ScrScale) * 4;
            CallPtr(EPtr(NtGdiStretchDIBitsInternal_Fn), EPtr(ScreenDC), 0, 0, CurrentWidth, CurrentHeight, 0, 0,
                CurrentWidth * ScrScale, CurrentHeight * ScrScale, EPtr(ScaleMappedTexture), InfoUser, 0, SRCCOPY, 40, InfoUser->bmiHeader.biSizeImage, 0ull);
            
            //cleanup & restore bitmap
            MemZero(InfoUser, sizeof(BITMAPINFO));
            SelectBitMapInternal(SBitMap);
        }
        
        //fix alpha & copy & clear buffer (BUG: no black color)
        auto MappedTextureDecrt = EPtr(MappedTexture);
        for (ULONG i = 0; i < CurrentWidth * CurrentHeight * 4; i += 8/*2 pixels*/)
        {
            //copy pixels
            ULONG Pixel1 = *(ULONG*)&Buffer[i] = *(ULONG*)&MappedTextureDecrt[i];
            ULONG Pixel2 = *(ULONG*)&Buffer[i + 4] = *(ULONG*)&MappedTextureDecrt[i + 4];

            //fix alpha
            if (Pixel1) Buffer[i + 3] = 0xFF;
            if (Pixel2) Buffer[i + 7] = 0xFF;

            //reset pixels
            *(ULONG*)&MappedTextureDecrt[i] = 0;
            *(ULONG*)&MappedTextureDecrt[i + 4] = 0;
        }
    }

    void Release() 
    {
        //if need
        if (ScreenDC)
        {
            //remove bitmaps
            SelectBitMapInternal((HBITMAP)GetStockObjectInternal(21/*DEFAULT_BITMAP*/));
            RemoveObjInternal(EPtr(ScreenBitmap));
            RemoveObjInternal(EPtr(ScaleScreenBitmap));
            
            //remove font
            SelectFontInternal((HFONT)GetStockObjectInternal(SYSTEM_FONT));
            RemoveObjInternal(EPtr(CurFont));

            //release userbuff
            UFree(EPtr(UserBuffer));

            //remove screen dc
            RemoveObjInternal(EPtr(ScreenDC));
            ScreenDC = nullptr;
        }
    }

    //render line
    void Line(int x0, int y0, int x1, int y1, COLORREF Color, int Thick = 1)
    {
        //apply scale
        x0 *= ScrScale;
        y0 *= ScrScale;
        x1 *= ScrScale;
        y1 *= ScrScale;
        Thick *= ScrScale;

        //gen dots
        POINT Dots[2];
        Dots[0] = { x0, y0 };
        Dots[1] = { x1, y1 };

        //draw polyline
        PolyLineInternal(Dots, 2, Thick, Color);
    }

    //render circle
    void Circle(int x, int y, COLORREF Color, float Radius, int Thick = 1)
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        Thick *= ScrScale;
        Radius *= ScrScale;

        //gen dots
        POINT Dots[120]; int NumDots = 0;
        for (float i = 0.f; i < 6.28f; i += .054f) {
            Dots[NumDots++] = {
                LONG(x + Radius * FastCos(i)),
                LONG(y + Radius * FastSin(i))
            };
        }

        //fix end
        Dots[NumDots] = Dots[0];

        //draw polyline
        PolyLineInternal(Dots, NumDots, Thick, Color);
    }

    void FillCircle(int x, int y, COLORREF Color, float Radius)
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        Radius *= ScrScale;

        //gen dots
        POINT Dots[120]; int NumDots = 0;
        for (float i = 0.f; i < 6.28f; i += .054f) {
            Dots[NumDots++] = {
                LONG(x + Radius * FastCos(i)),
                LONG(y + Radius * FastSin(i))
            };
        }

        //draw polygon
        PolygonInternal(Dots, NumDots, Color);
    }

    //render rectangle
    void Rectangle(int x, int y, int w, int h, COLORREF Color, int Thick = 1)
    { 
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        w *= ScrScale;
        h *= ScrScale;
        Thick *= ScrScale;

        //gen dots
        POINT Dots[5];
        Dots[0] = { x, y };
        Dots[1] = { x + w, y };
        Dots[2] = { x + w, y + h };
        Dots[3] = { x, y + h };
        Dots[4] = Dots[0];

        //draw polyline
        PolyLineInternal(Dots, 5, Thick, Color);
    }
    
    void RoundedRectangle(int x, int y, int w, int h, COLORREF Color, float Radius, int Thick = 1) //shit
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        w *= ScrScale;
        h *= ScrScale;
        Thick *= ScrScale;
        Radius *= ScrScale;

        //gen dots
        POINT Add{};
        POINT Dots[25];
        for (int i = 0; i < 24; ++i)
        {
            //gen dot
            float angle = (float(i) / -24.f) * 6.28f - (6.28f / 16.f);
            Dots[i].x = Radius + x + Add.x + (Radius * FastSin(angle));
            Dots[i].y = h - Radius + y + Add.y + (Radius * FastCos(angle));

            //calc offset
            if (i == 4) { Add.y = -h + (Radius * 2.f); }
            else if (i == 10) { Add.x = w - (Radius * 2.f); }
            else if (i == 16) Add.y = 0.f; else if (i == 22) Add.x = 0.f;
        }

        //fix end
        Dots[24] = Dots[0];

        //Line(Dots[16].x, Dots[16].y, Dots[22].x, Dots[22].y, RGB(255, 0, 0));

        //draw polyline
        PolyLineInternal(Dots, 25, Thick, Color);
    }

    void FillRectangle(int x, int y, int w, int h, COLORREF Color)
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        w *= ScrScale;
        h *= ScrScale;

        //gen dots
        POINT Dots[4];
        Dots[0] = { x, y };
        Dots[1] = { x + w, y };
        Dots[2] = { x + w, y + h };
        Dots[3] = { x, y + h };

        //draw polygon
        PolygonInternal(Dots, 4, Color);
    }

    void FillRoundedRectangle(int x, int y, int w, int h, COLORREF Color, float Radius)
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;
        w *= ScrScale;
        h *= ScrScale; 
        Radius *= ScrScale;

        //gen dots
        POINT Add{};
        POINT Dots[24];
        for (int i = 0; i < 24; ++i)
        {
            //gen dot
            float angle = (float(i) / -24.f) * 6.28f - (6.28f / 16.f);
            Dots[i].x = Radius + x + Add.x + (Radius * FastSin(angle));
            Dots[i].y = h - Radius + y + Add.y + (Radius * FastCos(angle));

            //calc offset
            if (i == 4) { Add.y = -h + (Radius * 2.f); }
            else if (i == 10) { Add.x = w - (Radius * 2.f); }
            else if (i == 16) Add.y = 0.f;
            else if (i == 22) Add.x = 0.f;
        }
        
        //draw polygon
        PolygonInternal(Dots, 24, Color);
    }

    //render string
    void String(int x, int y, const wchar_t* String, UINT Align = TA_LEFT, COLORREF Color = RGB(255, 255, 255)) 
    {
        //apply scale
        x *= ScrScale;
        y *= ScrScale;

        //resolve functions
        static PVOID GreSetTextAlign = nullptr;
        static PVOID GreSetTextColor = nullptr;
        static PVOID GreExtTextOutWInternal = nullptr;
        if (!GreSetTextColor || !GreSetTextAlign || !GreExtTextOutWInternal) {
            auto win32kFull = GetKernelModuleBase(E("win32kfull.sys"));
            GreSetTextAlign = (PVOID)EPtr(RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? 89 5C 24 48 45")), 5));
            GreExtTextOutWInternal = (PVOID)EPtr(RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? 49 83 C6 02 BB")), 5));
            GreSetTextColor = (PVOID)EPtr(RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? BA ? ? ? ? 89 44 24 70")), 5));
        }

        //draw text
        auto hDC = EPtr(ScreenDC);
        CallPtr(EPtr(GreSetTextAlign), hDC, Align);
        CallPtr(EPtr(GreSetTextColor), hDC, Color);
        CallPtr(EPtr(GreExtTextOutWInternal), hDC, x, y, 0ull, 0ull, String, StrLen(String), 0ull, 0ull);
    }

    SIZE TextRect(const wchar_t* String)
    {
        //resolve function
        static PVOID GreGetTextExtentW = nullptr;
        if (!GreGetTextExtentW) {
            auto win32kFull = GetKernelModuleBase(E("win32kfull.sys"));
            GreGetTextExtentW = (PVOID)EPtr(RVA(FindPatternSect(win32kFull, E(".text"), E("E8 ? ? ? ? 8B D8 41 83 FD 10")), 5));
        }
       
        //get text size
        SIZE TextRect{};
        CallPtr(EPtr(GreGetTextExtentW), EPtr(ScreenDC), String, StrLen(String), &TextRect, 1);
        return SIZE{ TextRect.cx / ScrScale, TextRect.cy / ScrScale }; //fix scale
    }
} rctx;

```

`GDI_Discord/MathASM.asm`:

```asm
.code

fwrap macro a, b
	sub rsp, 10h
	cvtss2sd xmm0, xmm0
	movsd qword ptr [rsp], xmm0
	fld qword ptr [rsp]
	a
	b
	fstp qword ptr [rsp]
	movsd xmm0, qword ptr [rsp]
	cvtsd2ss xmm0, xmm0
	add rsp, 10h
	ret
endm

__sqrtf proc
	fwrap fsqrt
__sqrtf endp

__sinf proc
	fwrap fsin
__sinf endp

__cosf proc
	fwrap fcos
__cosf endp

__tanf proc
	fwrap fptan, fmulp
__tanf endp

arg1 macro
	cvtss2sd xmm1, xmm1
	movsd qword ptr [rsp], xmm1
	fld qword ptr [rsp]
endm

__atan2f proc
	fwrap arg1, fpatan
__atan2f endp

end
```

`GDI_Discord/MathASM.h`:

```h
extern "C" {
	float __sinf(const float);
	float __cosf(const float);
	float __sqrtf(const float);
	float __tanf(const float a);
	float __atan2f(const float, const float);
	__forceinline float __atanf(const float a) {
		return __atan2f(a, 1.f);
	}
	__forceinline float __asinf(const float a) {
		return __atan2f(a, __sqrtf(1.f - a * a));
	}
	__forceinline float __acosf(const float a) {
		return __atan2f(__sqrtf(1.f - a * a), a);
	}
}

```

`GDI_Discord/Source.cpp`:

```cpp
#include "Global.h"

//tmp hook data
PVOID* xKdEnumerateDebuggingDevicesPtr;
PVOID xKdEnumerateDebuggingDevicesVal;

#define GameProc "TestEnvironment.exe"

namespace Win32K {
	ULONG64 gafAsyncKeyState;
	ULONG64 gafAsyncKeyStateRecentDown;
}

unsigned __int16 GetAsyncKeyState(unsigned int a1)
{
	__int16 result;

	if (a1 >= 0x100) { result = 0; }
	else
	{
		unsigned __int64 v1 = (unsigned __int8)a1;
		unsigned __int64 v2 = (unsigned __int64)(unsigned __int8)a1 >> 3;

		__int16 v4 = 0;
		unsigned int v3 = v1 & 7;

		int v5 = *(unsigned __int8*)(v2 + EPtr(Win32K::gafAsyncKeyStateRecentDown));

		if (_bittest((LONG*)&v5, v3)) {
			v4 = 1;
			*(UCHAR*)(v2 + EPtr(Win32K::gafAsyncKeyStateRecentDown)) = v5 & ~(1 << v3);
		}

		result = v4 | 0x8000;
		if (!(*((UCHAR*)EPtr(Win32K::gafAsyncKeyState) + (v1 >> 2)) & (unsigned __int8)(1 << (2 * (v1 & 3)))))
			result = v4;
	}

	return result;
}

PVOID Kbase2;
typedef NTSTATUS(__fastcall* ZwReleaseMutantFn)(HANDLE, PLONG);

class OSRender
{
private:
	PVOID OverlayBase;
	PVOID PaintBuffer;
	HANDLE InputMutex;
	HANDLE PaintCmdMutex;
	HANDLE InputAvailable;
	ZwReleaseMutantFn ZwReleaseMutant;

public:
	OSRender(PVOID OverlayBase1) {
		OverlayBase = OverlayBase1;
		ZwReleaseMutant = (ZwReleaseMutantFn)RVA(FindPatternSect(Kbase2, "PAGE", "48 83 F9 FF 74 07") + 8, 5);
		auto paintCmd = *(ULONG64*)(RVA(FindPatternSect(OverlayBase, ".text", "48 89 05 ? ? ? ? BA ? ? ? ? 48"), 7));
		auto inputCmd = *(ULONG64*)(RVA(FindPatternSect(OverlayBase, ".text", "48 8B 0D ? ? ? ? 41 B8 ? ? ? ? 48 8D"), 7));
		PaintCmdMutex = *(HANDLE*)(*(ULONG64*)(paintCmd + 0x108) + 0x10);
		PaintBuffer = *(PVOID*)(*(ULONG64*)(paintCmd + 0x110) + 0x10);
		InputMutex = *(HANDLE*)(*(ULONG64*)(inputCmd + 0x108) + 0x10);
		InputAvailable = *(HANDLE*)(*(ULONG64*)(inputCmd + 0x120) + 0x10);
	}

	void WaitLockFrame() {
		HANDLE handles[] = { PaintCmdMutex, InputMutex, InputAvailable };
		LARGE_INTEGER time; time.QuadPart = 0;
		ZwWaitForMultipleObjects(3, handles, WaitAll, 0, nullptr);
	}

	void PutCmd(const void* source, DWORD size)
	{
		struct StreamHeader
		{
			DWORD BufferStartIndex;
			DWORD BufferEndIndex;
			DWORD BufferCapacity;
			DWORD BufferSize;
		};
		auto Header = (StreamHeader*)PaintBuffer;
		auto Buffer = (char*)Header + sizeof(StreamHeader);

		//if (source == nullptr)
		//{
		//}	//throw std::invalid_argument("Source is null.");
		//
		//if (size > GetUnusedCapacity())
		//{
		//}	//throw std::out_of_range("Size exceeds the unused capacity of the buffer.");

		char* destination;

		//dp(Header->BufferSize);

		Header->BufferSize += size;

		// write is wrapped
		if (size > Header->BufferStartIndex)
		{
			DWORD postwrapSize = size - Header->BufferStartIndex;
			// update size
			size = Header->BufferStartIndex;
			// wrap buffer start index
			Header->BufferStartIndex = Header->BufferCapacity - postwrapSize;

			memcpy(Buffer + Header->BufferStartIndex, source, postwrapSize);
			// update source
			source = (char*)source + postwrapSize;
			// finish write at start
			destination = Buffer;
		}

		else
		{
			Header->BufferStartIndex -= size;
			destination = Buffer + Header->BufferStartIndex;
		}

		memcpy(destination, source, size);
	}

	void ReleaseFrame() {
		ZwReleaseMutant(InputMutex, 0);
		ZwReleaseMutant(PaintCmdMutex, 0);
	}
};

//meme thread
NTSTATUS MainThread()
{
	//unhook kernel hook
	_InterlockedExchangePointer(xKdEnumerateDebuggingDevicesPtr, xKdEnumerateDebuggingDevicesVal);
	xKdEnumerateDebuggingDevicesPtr = nullptr; xKdEnumerateDebuggingDevicesVal = nullptr;

	//create gui thread context
	auto hNtdll = GetUserModuleBase(ImpCall(IoGetCurrentProcess), E("user32"));
	auto CallBack = GetProcAdress(hNtdll, E("GetForegroundWindow"));
	CallUserMode(CallBack);

	//get target process
	PVOID OverlayBase;
	auto TargetProc = GetProcessWModule(E(GameProc), E("gameoverlayrenderer64"), &OverlayBase);
	
	//find steam overlay
	OSRender renderSteam(OverlayBase);

	int w = 400;
	int h = 400;

	DWORD size = w * h * 4;
	DWORD textureVersion = 0;
	auto pBuff111 = UAlloc(size);

	while (true)
	{
		renderSteam.WaitLockFrame();

		struct
		{
			DWORD renderCommand;
			int x0;
			int y0;
			int x1;
			int y1;
			float u0;
			float v0;
			float u1;
			float v1;
			float uk4;
			DWORD colorStart;
			DWORD colorEnd; // unused if gradient direction is set to none
			DWORD gradientDirection;
			DWORD textureId;
		} drawTexturedRect =
		{
		3, // render command
		0,
		0,
		w,
		h,
		0.0f,
		0.0f,
		1.0f,
		1.0f,
		1.0f,
		0xFFFFFFFF,
		0xFFFFFFFF,
		3, // none
		1337
		};
		renderSteam.PutCmd(&drawTexturedRect, sizeof(drawTexturedRect));
		
		rctx.NewFrame(w, h, E(L"Calibri"), 48, 1);
		rctx.String(100, 100, L"FACE", TA_CENTER, RGB(255, 255, 255));
		rctx.EndFrame((PBYTE)pBuff111);

		renderSteam.PutCmd((PBYTE)pBuff111, size);
		struct
		{
			DWORD renderCommand;
			DWORD textureId;
			DWORD version;
			BOOL fullUpdate;
			DWORD size;
			DWORD width;
			DWORD height;
			DWORD x;
			DWORD y;
		} loadTexture =
		{
			1, // render command
			1337, // id
			++textureVersion,
			1, // full update
			size, // size
			w, // width
			h, // height
			0,
			0
		};

		// command
		renderSteam.PutCmd(&loadTexture, sizeof(loadTexture));
		renderSteam.ReleaseFrame();
	}

	//sp("end cheat!!!");
	DetachFromProcess(TargetProc);

	//lol return 1!!
	return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg(push)
#pragma code_seg("INIT")

//create thread meme
bool SetupKernelThread(PVOID KBase, PVOID ThreadStartAddr)
{
	//get thread fake start address
	PVOID hMsVCRT = nullptr;
	auto Process = GetProcessWModule(E("explorer.exe"), E("msvcrt"), &hMsVCRT);
	auto FakeStartAddr = (PUCHAR)GetProcAdress(hMsVCRT, E("_endthreadex")) + 0x30;

	auto win32k = GetKernelModuleBase(E("win32kbase.sys"));
	Win32K::gafAsyncKeyState = (ULONG64)EPtr(GetProcAdress(win32k, E("gafAsyncKeyState")));
	Win32K::gafAsyncKeyStateRecentDown = (ULONG64)EPtr(GetProcAdress(win32k, E("gafAsyncKeyStateRecentDown")));

	//get usermode func
	auto Var = UAlloc(0x1000); HANDLE Thread = nullptr;
	auto hNtdll = GetUserModuleBase(Process, E("ntdll"));
	auto CallBack = GetProcAdress(hNtdll, E("NtQueryAuxiliaryCounterFrequency"));

	//set kernel hook
	xKdEnumerateDebuggingDevicesPtr = (PVOID*)RVA((ULONG64)EPtr(KeQueryAuxiliaryCounterFrequencyFn) + 4, 7);
	xKdEnumerateDebuggingDevicesVal = _InterlockedExchangePointer(xKdEnumerateDebuggingDevicesPtr, ThreadStartAddr);

	//create new thread
	CLIENT_ID Cid;
	ImpCall(RtlCreateUserThread, ZwCurrentProcess(), nullptr, false, 0, 0, 0, CallBack, Var, &Thread, &Cid);

	if (Thread)
	{
		//close useless handle
		ImpCall(ZwClose, Thread);

		//spoof thread start address
		PETHREAD EThread;
		ImpCall(PsLookupThreadByThreadId, Cid.UniqueThread, &EThread);
		auto StartAddrOff = *(USHORT*)(FindPatternSect(KBase, E("PAGE"), E("48 89 86 ? ? ? ? 48 8B 8C")) + 3);
		*(PVOID*)((ULONG64)EThread + StartAddrOff/*Win32StartAddress*/) = FakeStartAddr;
		ImpCall(ObfDereferenceObject, EThread);

		//wait exec kernel callback
		while (xKdEnumerateDebuggingDevicesPtr && xKdEnumerateDebuggingDevicesVal) {
			Sleep(10);
		}
	}

	//cleanup
	UFree(Var);
	DetachFromProcess(Process);

	//ret create status
	return (bool)Thread;
}

//driver entry point
NTSTATUS DriverEntry(PVOID a1, PVOID KBase)
{
	//import set
	ImpSet(IoIs32bitProcess);
	ImpSet(PsGetProcessWow64Process);
	ImpSet(ExAllocatePoolWithTag);
	ImpSet(ExFreePoolWithTag);
	ImpSet(IoGetCurrentProcess);
	ImpSet(KeAttachProcess);
	ImpSet(KeDelayExecutionThread);
	ImpSet(KeDetachProcess);
	ImpSet(KeEnterGuardedRegion);
	ImpSet(KeLeaveGuardedRegion);
	ImpSet(KeQueryAuxiliaryCounterFrequency);
	ImpSet(KeUserModeCallback);
	ImpSet(MmIsAddressValid);
	ImpSet(ObfDereferenceObject);
	ImpSet(PsAcquireProcessExitSynchronization);
	ImpSet(PsGetProcessPeb);
	ImpSet(PsLookupProcessByProcessId);
	ImpSet(PsLookupThreadByThreadId);
	ImpSet(PsReleaseProcessExitSynchronization);
	ImpSet(RtlCreateUserThread);
	ImpSet(ZwAllocateVirtualMemory);
	ImpSet(ZwClose);
	ImpSet(ZwFreeVirtualMemory);
	ImpSet(ZwQuerySystemInformation);
	ImpSet(ZwQueryVirtualMemory); 
	ImpSet(MmSecureVirtualMemory);
	ImpSet(ZwProtectVirtualMemory);
	ImpSet(ZwQueryObject);

	Kbase2 = KBase;

	//create kernel usermode thread
	SetupKernelThread(KBase, MainThread);

	return STATUS_SUCCESS;
}

#pragma code_seg(pop)
```

`README.md`:

```md
Kernel SteamOverlay GDI reneder

![example](example.png?raw=true "example")

```

`StrongSteam.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30611.23
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GDI_Discord", "GDI_Discord\GDI_Discord.vcxproj", "{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}.Release|x64.ActiveCfg = Release|x64
		{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}.Release|x64.Build.0 = Release|x64
		{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B6DED265-611F-448C-A24B-BE2D105AD5A5}
	EndGlobalSection
EndGlobal

```