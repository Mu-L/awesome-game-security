Project Path: arc_chronoxor_CppServer_otjmcuor

Source Tree:

```txt
arc_chronoxor_CppServer_otjmcuor
├── CMakeLists.txt
├── LICENSE
├── README.md
├── TODO.md
├── bin
│   └── .gitignore
├── documents
│   └── Doxyfile
├── examples
│   ├── asio_service.cpp
│   ├── asio_service.h
│   ├── asio_timer.cpp
│   ├── http_client.cpp
│   ├── http_server.cpp
│   ├── https_client.cpp
│   ├── https_server.cpp
│   ├── proto_client.cpp
│   ├── proto_server.cpp
│   ├── ssl_chat_client.cpp
│   ├── ssl_chat_server.cpp
│   ├── tcp_chat_client.cpp
│   ├── tcp_chat_server.cpp
│   ├── udp_echo_client.cpp
│   ├── udp_echo_server.cpp
│   ├── udp_multicast_client.cpp
│   ├── udp_multicast_server.cpp
│   ├── ws_chat_client.cpp
│   ├── ws_chat_server.cpp
│   ├── wss_chat_client.cpp
│   └── wss_chat_server.cpp
├── images
│   ├── multicast.ai
│   ├── multicast.png
│   ├── openapi-http.png
│   ├── openapi-https.png
│   ├── round-trip.ai
│   ├── round-trip.png
│   ├── ws-chat.png
│   └── wss-chat.png
├── include
│   └── server
│       ├── asio
│       │   ├── asio.h
│       │   ├── asio.inl
│       │   ├── memory.h
│       │   ├── memory.inl
│       │   ├── service.h
│       │   ├── ssl_client.h
│       │   ├── ssl_context.h
│       │   ├── ssl_server.h
│       │   ├── ssl_session.h
│       │   ├── tcp_client.h
│       │   ├── tcp_resolver.h
│       │   ├── tcp_server.h
│       │   ├── tcp_session.h
│       │   ├── timer.h
│       │   ├── udp_client.h
│       │   ├── udp_resolver.h
│       │   └── udp_server.h
│       ├── http
│       │   ├── http.h
│       │   ├── http_client.h
│       │   ├── http_request.h
│       │   ├── http_request.inl
│       │   ├── http_response.h
│       │   ├── http_response.inl
│       │   ├── http_server.h
│       │   ├── http_session.h
│       │   ├── https_client.h
│       │   ├── https_server.h
│       │   └── https_session.h
│       ├── version.h
│       └── ws
│           ├── ws.h
│           ├── ws_client.h
│           ├── ws_server.h
│           ├── ws_session.h
│           ├── wss_client.h
│           ├── wss_server.h
│           └── wss_session.h
├── modules
│   ├── CMakeLists.txt
│   ├── Catch2.cmake
│   ├── CppBenchmark.cmake
│   ├── CppCommon.cmake
│   ├── asio.cmake
│   └── cpp-optparse.cmake
├── performance
│   ├── http_trace_client.cpp
│   ├── http_trace_server.cpp
│   ├── https_trace_client.cpp
│   ├── https_trace_server.cpp
│   ├── proto_client.cpp
│   ├── proto_server.cpp
│   ├── ssl_echo_client.cpp
│   ├── ssl_echo_server.cpp
│   ├── ssl_multicast_client.cpp
│   ├── ssl_multicast_server.cpp
│   ├── tcp_echo_client.cpp
│   ├── tcp_echo_server.cpp
│   ├── tcp_multicast_client.cpp
│   ├── tcp_multicast_server.cpp
│   ├── udp_echo_client.cpp
│   ├── udp_echo_server.cpp
│   ├── udp_multicast_client.cpp
│   ├── udp_multicast_server.cpp
│   ├── ws_echo_client.cpp
│   ├── ws_echo_server.cpp
│   ├── ws_multicast_client.cpp
│   ├── ws_multicast_server.cpp
│   ├── wss_echo_client.cpp
│   ├── wss_echo_server.cpp
│   ├── wss_multicast_client.cpp
│   └── wss_multicast_server.cpp
├── proto
│   ├── fbe.cpp
│   ├── fbe.h
│   ├── fbe_models.cpp
│   ├── fbe_models.h
│   ├── fbe_models.inl
│   ├── fbe_protocol.cpp
│   ├── fbe_protocol.h
│   ├── simple.cpp
│   ├── simple.fbe
│   ├── simple.h
│   ├── simple_models.cpp
│   ├── simple_models.h
│   ├── simple_protocol.cpp
│   └── simple_protocol.h
├── source
│   └── server
│       ├── asio
│       │   ├── service.cpp
│       │   ├── ssl_client.cpp
│       │   ├── ssl_context.cpp
│       │   ├── ssl_server.cpp
│       │   ├── ssl_session.cpp
│       │   ├── tcp_client.cpp
│       │   ├── tcp_resolver.cpp
│       │   ├── tcp_server.cpp
│       │   ├── tcp_session.cpp
│       │   ├── timer.cpp
│       │   ├── udp_client.cpp
│       │   ├── udp_resolver.cpp
│       │   └── udp_server.cpp
│       ├── http
│       │   ├── http_client.cpp
│       │   ├── http_request.cpp
│       │   ├── http_response.cpp
│       │   ├── http_server.cpp
│       │   ├── http_session.cpp
│       │   ├── https_client.cpp
│       │   ├── https_server.cpp
│       │   └── https_session.cpp
│       └── ws
│           ├── ws.cpp
│           ├── ws_client.cpp
│           ├── ws_server.cpp
│           ├── ws_session.cpp
│           ├── wss_client.cpp
│           ├── wss_server.cpp
│           └── wss_session.cpp
├── tests
│   ├── test.cpp
│   ├── test.h
│   ├── test_http.cpp
│   ├── test_https.cpp
│   ├── test_proto.cpp
│   ├── test_ssl.cpp
│   ├── test_tcp.cpp
│   ├── test_timer.cpp
│   ├── test_udp.cpp
│   ├── test_udp_multicast.cpp
│   ├── test_ws.cpp
│   └── test_wss.cpp
├── tools
│   └── certificates
│       ├── ca-secret.key
│       ├── ca.crt
│       ├── ca.key
│       ├── ca.pem
│       ├── ca.pfx
│       ├── client-secret.key
│       ├── client.crt
│       ├── client.csr
│       ├── client.key
│       ├── client.pem
│       ├── client.pfx
│       ├── dh4096.pem
│       ├── generate.bat
│       ├── generate.sh
│       ├── server-secret.key
│       ├── server.crt
│       ├── server.csr
│       ├── server.key
│       ├── server.pem
│       └── server.pfx
└── www
    ├── api
    │   ├── index.html
    │   ├── openapi.yaml
    │   └── swagger.js
    ├── ws
    │   ├── favicon.png
    │   └── index.html
    └── wss
        ├── favicon.png
        └── index.html

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)

# Global properties
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# Project name
project(cppserver)

# Doxygen
find_package(Doxygen)
if(DOXYGEN_FOUND)
  set(DOXYGEN "doxygen")
  if(NOT TARGET ${DOXYGEN})
    add_custom_command(OUTPUT "Doxyfile" COMMAND ${DOXYGEN_EXECUTABLE} "Doxyfile" WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/documents")
    add_custom_target(${DOXYGEN} DEPENDS "Doxyfile")
    set_target_properties(${DOXYGEN} PROPERTIES FOLDER "doxygen")
  endif()
endif()

# CMake module path
set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# Compiler features
include(SetCompilerFeatures)
include(SetCompilerWarnings)
include(SetPlatformFeatures)
include(SystemInformation)

# External packages
if(APPLE)
  set(OPENSSL_ROOT_DIR "/usr/local/opt/openssl@3")
elseif(CYGWIN)
  set(OPENSSL_ROOT_DIR "/usr/lib")
  set(OPENSSL_INCLUDE_DIR "/usr/include")
  set(OPENSSL_CRYPTO_LIBRARY "/usr/lib/libcrypto.dll.a")
  set(OPENSSL_SSL_LIBRARY "/usr/lib/libssl.dll.a")
elseif(MINGW AND NOT MSYS)
  set(OPENSSL_ROOT_DIR "${CMAKE_CURRENT_SOURCE_DIR}/modules/OpenSSL/MinGW")
  set(OPENSSL_USE_STATIC_LIBS TRUE)
elseif(MSVC)
  set(OPENSSL_ROOT_DIR "${CMAKE_CURRENT_SOURCE_DIR}/modules/OpenSSL/VS")
  set(OPENSSL_USE_STATIC_LIBS TRUE)
  set(OPENSSL_MSVC_STATIC_RT TRUE)
endif()
find_package(OpenSSL REQUIRED)
if(WIN32)
  find_package(Crypt)
  find_package(WinSock)
endif()

# Modules
add_subdirectory("modules")

# Link libraries
list(APPEND LINKLIBS ${OPENSSL_LIBRARIES})
if(WIN32)
  list(APPEND LINKLIBS ${CRYPT_LIBRARIES})
  list(APPEND LINKLIBS ${WINSOCK_LIBRARIES})
endif()
list(APPEND LINKLIBS cppcommon)

# OpenSSL libraries
message(STATUS "OpenSSL version: ${OPENSSL_VERSION} ${OPENSSL_INCLUDE_DIR} ${OPENSSL_LIBRARIES}")

# System directories
include_directories(SYSTEM "${CMAKE_CURRENT_SOURCE_DIR}/modules")

# Library
file(GLOB_RECURSE LIB_HEADER_FILES "include/*.h" "source/*.h")
file(GLOB_RECURSE LIB_INLINE_FILES "include/*.inl" "source/*.inl")
file(GLOB_RECURSE LIB_SOURCE_FILES "include/*.cpp" "source/*.cpp")
add_library(cppserver ${LIB_HEADER_FILES} ${LIB_INLINE_FILES} ${LIB_SOURCE_FILES})
set_target_properties(cppserver PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}" FOLDER "libraries")
target_include_directories(cppserver PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
target_link_libraries(cppserver ${LINKLIBS} asio)
list(APPEND INSTALL_TARGETS cppserver)
list(APPEND LINKLIBS cppserver)

# Additional module components: benchmarks, examples, plugins, tests, tools and install
if(NOT CPPSERVER_MODULE)

  # Proto library
  file(GLOB_RECURSE PROTO_HEADER_FILES "proto/*.h")
  file(GLOB_RECURSE PROTO_INLINE_FILES "proto/*.inl")
  file(GLOB_RECURSE PROTO_SOURCE_FILES "proto/*.cpp")
  add_library(proto ${PROTO_HEADER_FILES} ${PROTO_INLINE_FILES} ${PROTO_SOURCE_FILES})
  set_target_properties(proto PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}" FOLDER "proto")
  target_include_directories(proto PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/proto")
  target_link_libraries(proto ${LINKLIBS})
  list(APPEND INSTALL_TARGETS proto)
  list(APPEND LINKLIBS proto)

  # Examples
  file(GLOB EXAMPLE_HEADER_FILES "examples/*.h")
  file(GLOB EXAMPLE_INLINE_FILES "examples/*.inl")
  file(GLOB EXAMPLE_SOURCE_FILES RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}/examples" "examples/*.cpp")
  foreach(EXAMPLE_SOURCE_FILE ${EXAMPLE_SOURCE_FILES})
    string(REGEX REPLACE "(.*)\\.cpp" "\\1" EXAMPLE_NAME ${EXAMPLE_SOURCE_FILE})
    set(EXAMPLE_TARGET "cppserver-example-${EXAMPLE_NAME}")
    add_executable(${EXAMPLE_TARGET} ${EXAMPLE_HEADER_FILES} ${EXAMPLE_INLINE_FILES} "examples/${EXAMPLE_SOURCE_FILE}")
    set_target_properties(${EXAMPLE_TARGET} PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}" FOLDER "examples")
    target_link_libraries(${EXAMPLE_TARGET} ${LINKLIBS})
    list(APPEND INSTALL_TARGETS ${EXAMPLE_TARGET})
    list(APPEND INSTALL_TARGETS_PDB ${EXAMPLE_TARGET})
  endforeach()

  # Benchmarks
  file(GLOB BENCHMARK_HEADER_FILES "performance/*.h")
  file(GLOB BENCHMARK_INLINE_FILES "performance/*.inl")
  file(GLOB BENCHMARK_SOURCE_FILES RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}/performance" "performance/*.cpp")
  foreach(BENCHMARK_SOURCE_FILE ${BENCHMARK_SOURCE_FILES})
    string(REGEX REPLACE "(.*)\\.cpp" "\\1" BENCHMARK_NAME ${BENCHMARK_SOURCE_FILE})
    set(BENCHMARK_TARGET "cppserver-performance-${BENCHMARK_NAME}")
    add_executable(${BENCHMARK_TARGET} ${BENCHMARK_HEADER_FILES} ${BENCHMARK_INLINE_FILES} "performance/${BENCHMARK_SOURCE_FILE}")
    set_target_properties(${BENCHMARK_TARGET} PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}" FOLDER "performance")
    target_link_libraries(${BENCHMARK_TARGET} ${LINKLIBS} cppbenchmark)
    list(APPEND INSTALL_TARGETS ${BENCHMARK_TARGET})
    list(APPEND INSTALL_TARGETS_PDB ${BENCHMARK_TARGET})
  endforeach()

  # Tests
  file(GLOB TESTS_HEADER_FILES "tests/*.h")
  file(GLOB TESTS_INLINE_FILES "tests/*.inl")
  file(GLOB TESTS_SOURCE_FILES "tests/*.cpp")
  add_executable(cppserver-tests ${TESTS_HEADER_FILES} ${TESTS_INLINE_FILES} ${TESTS_SOURCE_FILES})
  set_target_properties(cppserver-tests PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}" FOLDER "tests")
  target_include_directories(cppserver-tests PRIVATE Catch2)
  target_link_libraries(cppserver-tests ${LINKLIBS} Catch2)
  list(APPEND INSTALL_TARGETS cppserver-tests)
  list(APPEND INSTALL_TARGETS_PDB cppserver-tests)

  # CTest
  enable_testing()
  add_test(cppserver-tests cppserver-tests --durations yes --order lex)

  # Install
  install(TARGETS ${INSTALL_TARGETS}
    RUNTIME DESTINATION "${PROJECT_SOURCE_DIR}/bin"
    LIBRARY DESTINATION "${PROJECT_SOURCE_DIR}/bin"
    ARCHIVE DESTINATION "${PROJECT_SOURCE_DIR}/bin")

  # Install *.pdb files
  if(MSVC)
    foreach(INSTALL_TARGET_PDB ${INSTALL_TARGETS_PDB})
      install(FILES $<TARGET_PDB_FILE:${INSTALL_TARGET_PDB}> DESTINATION "${PROJECT_SOURCE_DIR}/bin")
    endforeach()
  endif()

endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2016-2026 Ivan Shynkarenka

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# CppServer

[![Awesome C++](https://awesome.re/badge.svg)](https://github.com/fffaraz/awesome-cpp)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)
[![Release](https://img.shields.io/github/release/chronoxor/CppServer.svg?sort=semver)](https://github.com/chronoxor/CppServer/releases)
<br/>
[![Linux (clang)](https://github.com/chronoxor/CppServer/actions/workflows/build-linux-clang.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-linux-clang.yml)
[![Linux (gcc)](https://github.com/chronoxor/CppServer/actions/workflows/build-linux-gcc.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-linux-gcc.yml)
[![MacOS](https://github.com/chronoxor/CppServer/actions/workflows/build-macos.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-macos.yml)
<br/>
[![Windows (MSYS2)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-msys2.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-msys2.yml)
[![Windows (MinGW)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-mingw.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-mingw.yml)
[![Windows (Visual Studio)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-vs.yml/badge.svg)](https://github.com/chronoxor/CppServer/actions/workflows/build-windows-vs.yml)

Ultra fast and low latency asynchronous socket server & client C++ library with
support TCP, SSL, UDP, HTTP, HTTPS, WebSocket protocols and [10K connections problem](https://en.wikipedia.org/wiki/C10k_problem)
solution.

Has integration with high-level message protocol based on [Fast Binary Encoding](https://github.com/chronoxor/FastBinaryEncoding)

[CppServer API reference](https://chronoxor.github.io/CppServer/index.html)

# Contents
  * [Features](#features)
  * [Requirements](#requirements)
  * [How to build?](#how-to-build)
  * [Examples](#examples)
    * [Example: Asio service](#example-asio-service)
    * [Example: Asio timer](#example-asio-timer)
    * [Example: TCP chat server](#example-tcp-chat-server)
    * [Example: TCP chat client](#example-tcp-chat-client)
    * [Example: SSL chat server](#example-ssl-chat-server)
    * [Example: SSL chat client](#example-ssl-chat-client)
    * [Example: UDP echo server](#example-udp-echo-server)
    * [Example: UDP echo client](#example-udp-echo-client)
    * [Example: UDP multicast server](#example-udp-multicast-server)
    * [Example: UDP multicast client](#example-udp-multicast-client)
    * [Example: Simple protocol](#example-simple-protocol)
    * [Example: Simple protocol server](#example-simple-protocol-server)
    * [Example: Simple protocol client](#example-simple-protocol-client)
    * [Example: HTTP server](#example-http-server)
    * [Example: HTTP client](#example-http-client)
    * [Example: HTTPS server](#example-https-server)
    * [Example: HTTPS client](#example-https-client)
    * [Example: WebSocket chat server](#example-websocket-chat-server)
    * [Example: WebSocket chat client](#example-websocket-chat-client)
    * [Example: WebSocket secure chat server](#example-websocket-secure-chat-server)
    * [Example: WebSocket secure chat client](#example-websocket-secure-chat-client)
  * [Performance](#performance)
    * [Benchmark: Round-Trip](#benchmark-round-trip)
      * [TCP echo server](#tcp-echo-server)
      * [SSL echo server](#ssl-echo-server)
      * [UDP echo server](#udp-echo-server)
      * [Simple protocol server](#simple-protocol-server)
      * [WebSocket echo server](#websocket-echo-server)
      * [WebSocket secure echo server](#websocket-secure-echo-server)
    * [Benchmark: Multicast](#benchmark-multicast)
      * [TCP multicast server](#tcp-multicast-server)
      * [SSL multicast server](#ssl-multicast-server)
      * [UDP multicast server](#udp-multicast-server)
      * [WebSocket multicast server](#websocket-multicast-server)
      * [WebSocket secure multicast server](#websocket-secure-multicast-server)
    * [Benchmark: Web Server](#benchmark-web-server)
      * [HTTP Trace server](#http-trace-server)
      * [HTTPS Trace server](#https-trace-server)
  * [OpenSSL certificates](#openssl-certificates)
    * [Production](#production)
    * [Development](#development)
    * [Certificate Authority](#certificate-authority)
    * [SSL Server certificate](#ssl-server-certificate)
    * [SSL Client certificate](#ssl-client-certificate)
    * [Diffie-Hellman key exchange](#diffie-hellman-key-exchange)

# Features
* Cross platform (Linux, MacOS, Windows)
* [Asynchronous communication](https://think-async.com)
* Supported CPU scalability designs: IO service per thread, thread pool
* Supported transport protocols: [TCP](#example-tcp-chat-server), [SSL](#example-ssl-chat-server),
  [UDP](#example-udp-echo-server), [UDP multicast](#example-udp-multicast-server)
* Supported Web protocols: [HTTP](#example-http-server), [HTTPS](#example-https-server),
  [WebSocket](#example-websocket-chat-server), [WebSocket secure](#example-websocket-secure-chat-server)
* Supported [Swagger OpenAPI](https://swagger.io/specification/) iterative documentation
* Supported message protocol based on [Fast Binary Encoding](https://github.com/chronoxor/FastBinaryEncoding)

# Requirements
* Linux
* MacOS
* Windows
* [cmake](https://www.cmake.org)
* [gcc](https://gcc.gnu.org)
* [git](https://git-scm.com)
* [gil](https://github.com/chronoxor/gil.git)
* [python3](https://www.python.org)

Optional:
* [clang](https://clang.llvm.org)
* [CLion](https://www.jetbrains.com/clion)
* [MSYS2](https://www.msys2.org)
* [MinGW](https://mingw-w64.org/doku.php)
* [Visual Studio](https://www.visualstudio.com)

# How to build?

### Linux: install required packages
```shell
sudo apt-get install -y binutils-dev uuid-dev libssl-dev
```

### Install [gil (git links) tool](https://github.com/chronoxor/gil)
```shell
pip3 install gil
```

### Setup repository
```shell
git clone https://github.com/chronoxor/CppServer.git
cd CppServer
gil update
```

### Linux
```shell
cd build
./unix.sh
```

### MacOS
```shell
cd build
./unix.sh
```

### Windows (MSYS2)
```shell
cd build
unix.bat
```

### Windows (MinGW)
```shell
cd build
mingw.bat
```

### Windows (Visual Studio)
```shell
cd build
vs.bat
```

# Examples

## Example: Asio service
Asio service is used to host all clients/servers based on [Asio C++ library](https://think-async.com).
It is implemented based on Asio C++ Library and use a separate thread to
perform all asynchronous IO operations and communications.

The common usecase is to instantiate one Asio service, start the service and
attach TCP/UDP/WebSocket servers or/and clients to it. One Asio service can
handle several servers and clients asynchronously at the same time in one I/O
thread. If you want to scale your servers or clients it is possible to create
and use more than one Asio services to handle your servers/clients in balance.

Also it is possible to dispatch or post your custom handler into I/O thread.
Dispatch will execute the handler immediately if the current thread is I/O one.
Otherwise the handler will be enqueued to the I/O queue. In opposite the post
method will always enqueue the handler into the I/O queue.

Here comes an example of using custom Asio service with dispatch/post methods:
```c++
#include "server/asio/service.h"
#include "threads/thread.h"

#include <iostream>

int main(int argc, char** argv)
{
    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Dispatch
    std::cout << "1 - Dispatch from the main thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
    service->Dispatch([service]()
    {
        std::cout << "1.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;

        std::cout << "1.2 - Dispatch from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Dispatch([service]()
        {
            std::cout << "1.2.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });

        std::cout << "1.3 - Post from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Post([service]()
        {
            std::cout << "1.3.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });
    });

    // Post
    std::cout << "2 - Post from the main thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
    service->Post([service]()
    {
        std::cout << "2.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;

        std::cout << "2.2 - Dispatch from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Dispatch([service]()
        {
            std::cout << "2.2.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });

        std::cout << "2.3 - Post from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Post([service]()
        {
            std::cout << "2.3.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });
    });

    // Wait for a while...
    CppCommon::Thread::Sleep(1000);

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

Output of the above example is the following:
```
Asio service started!
1 - Dispatch from the main thread with Id 16744
2 - Post from the main thread with Id 16744
1.1 - Dispatched in thread with Id 19920
1.2 - Dispatch from thread with Id 19920
1.2.1 - Dispatched in thread with Id 19920
1.3 - Post from thread with Id 19920
2.1 - Posted in thread with Id 19920
2.2 - Dispatch from thread with Id 19920
2.2.1 - Dispatched in thread with Id 19920
2.3 - Post from thread with Id 19920
1.3.1 - Posted in thread with Id 19920
2.3.1 - Posted in thread with Id 19920
Asio service stopped!
```

## Example: Asio timer
Here comes the example of Asio timer. It can be used to wait for some action
in future with providing absolute time or relative time span. Asio timer can
be used in synchronous or asynchronous modes.
```c++
#include "server/asio/timer.h"
#include "threads/thread.h"

#include <iostream>

class AsioTimer : public CppServer::Asio::Timer
{
public:
    using CppServer::Asio::Timer::Timer;

protected:
    void onTimer(bool canceled) override
    {
        std::cout << "Asio timer " << (canceled ? "canceled" : "expired") << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Asio timer caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new Asio timer
    auto timer = std::make_shared<AsioTimer>(service);

    // Setup and synchronously wait for the timer
    timer->Setup(CppCommon::UtcTime() + CppCommon::Timespan::seconds(1));
    timer->WaitSync();

    // Setup and asynchronously wait for the timer
    timer->Setup(CppCommon::Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    CppCommon::Thread::Sleep(2000);

    // Setup and asynchronously wait for the timer
    timer->Setup(CppCommon::Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    CppCommon::Thread::Sleep(500);

    // Cancel the timer
    timer->Cancel();

    // Wait for a while...
    CppCommon::Thread::Sleep(500);

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

Output of the above example is the following:
```
Asio service starting...Done!
Timer was expired
Timer was canceled
Asio service stopping...Done!
```

## Example: TCP chat server
Here comes the example of the TCP chat server. It handles multiple TCP client
sessions and multicast received message from any session to all ones. Also it
is possible to send admin message directly from the server.

```c++
#include "server/asio/tcp_server.h"
#include "threads/thread.h"

#include <iostream>

class ChatSession : public CppServer::Asio::TCPSession
{
public:
    using CppServer::Asio::TCPSession::TCPSession;

protected:
    void onConnected() override
    {
        std::cout << "Chat TCP session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from TCP chat! Please send a message or '!' to disconnect the client!");
        SendAsync(message);
    }

    void onDisconnected() override
    {
        std::cout << "Chat TCP session with Id " << id() << " disconnected!" << std::endl;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        server()->Multicast(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            DisconnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::Asio::TCPServer
{
public:
    using CppServer::Asio::TCPServer::TCPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(std::shared_ptr<CppServer::Asio::TCPServer> server) override
    {
        return std::make_shared<ChatSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // TCP server port
    int port = 1111;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "TCP server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new TCP chat server
    auto server = std::make_shared<ChatServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->Multicast(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: TCP chat client
Here comes the example of the TCP chat client. It connects to the TCP chat
server and allows to send message to it and receive new messages.

```c++
#include "server/asio/tcp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::Asio::TCPClient
{
public:
    ChatClient(std::shared_ptr<CppServer::Asio::Service> service, const std::string& address, int port)
        : CppServer::Asio::TCPClient(service, address, port)
    {
        _stop = false;
    }

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Chat TCP client connected a new session with Id " << id() << std::endl;
    }

    void onDisconnected() override
    {
        std::cout << "Chat TCP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop;
};

int main(int argc, char** argv)
{
    // TCP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // TCP server port
    int port = 1111;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "TCP server address: " << address << std::endl;
    std::cout << "TCP server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new TCP chat client
    auto client = std::make_shared<ChatClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Disconnect the client
        if (line == "!")
        {
            std::cout << "Client disconnecting...";
            client->DisconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: SSL chat server
Here comes the example of the SSL chat server. It handles multiple SSL client
sessions and multicast received message from any session to all ones. Also it
is possible to send admin message directly from the server.

This example is very similar to the TCP one except the code that prepares SSL
context and handshake handler.

```c++
#include "server/asio/ssl_server.h"
#include "threads/thread.h"

#include <iostream>

class ChatSession : public CppServer::Asio::SSLSession
{
public:
    using CppServer::Asio::SSLSession::SSLSession;

protected:
    void onConnected() override
    {
        std::cout << "Chat SSL session with Id " << id() << " connected!" << std::endl;
    }

    void onHandshaked() override
    {
        std::cout << "Chat SSL session with Id " << id() << " handshaked!" << std::endl;

        // Send invite message
        std::string message("Hello from SSL chat! Please send a message or '!' to disconnect the client!");
        SendAsync(message.data(), message.size());
    }

    void onDisconnected() override
    {
        std::cout << "Chat SSL session with Id " << id() << " disconnected!" << std::endl;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        server()->Multicast(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            DisconnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat SSL session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::Asio::SSLServer
{
public:
    using CppServer::Asio::SSLServer::SSLServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(std::shared_ptr<CppServer::Asio::SSLServer> server) override
    {
        return std::make_shared<ChatSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // SSL server port
    int port = 2222;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "SSL server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new SSL chat server
    auto server = std::make_shared<ChatServer>(service, context, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->Multicast(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: SSL chat client
Here comes the example of the SSL chat client. It connects to the SSL chat
server and allows to send message to it and receive new messages.

This example is very similar to the TCP one except the code that prepares SSL
context and handshake handler.

```c++
#include "server/asio/ssl_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::Asio::SSLClient
{
public:
    ChatClient(std::shared_ptr<CppServer::Asio::Service> service, std::shared_ptr<CppServer::Asio::SSLContext> context, const std::string& address, int port)
        : CppServer::Asio::SSLClient(service, context, address, port)
    {
        _stop = false;
    }

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Chat SSL client connected a new session with Id " << id() << std::endl;
    }

    void onHandshaked() override
    {
        std::cout << "Chat SSL client handshaked a new session with Id " << id() << std::endl;
    }

    void onDisconnected() override
    {
        std::cout << "Chat SSL client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat SSL client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop;
};

int main(int argc, char** argv)
{
    // SSL server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // SSL server port
    int port = 2222;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "SSL server address: " << address << std::endl;
    std::cout << "SSL server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new SSL chat client
    auto client = std::make_shared<ChatClient>(service, context, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Disconnect the client
        if (line == "!")
        {
            std::cout << "Client disconnecting...";
            client->DisconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: UDP echo server
Here comes the example of the UDP echo server. It receives a datagram mesage
from any UDP client and resend it back without any changes.

```c++
#include "server/asio/udp_server.h"
#include "threads/thread.h"

#include <iostream>

class EchoServer : public CppServer::Asio::UDPServer
{
public:
    using CppServer::Asio::UDPServer::UDPServer;

protected:
    void onStarted() override
    {
        // Start receive datagrams
        ReceiveAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Echo the message back to the sender
        SendAsync(endpoint, message);
    }

    void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) override
    {
        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Echo UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // UDP server port
    int port = 3333;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "UDP server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP echo server
    auto server = std::make_shared<EchoServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: UDP echo client
Here comes the example of the UDP echo client. It sends user datagram message
to UDP server and listen for response.

```c++
#include "server/asio/udp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class EchoClient : public CppServer::Asio::UDPClient
{
public:
    EchoClient(std::shared_ptr<CppServer::Asio::Service> service, const std::string& address, int port)
        : CppServer::Asio::UDPClient(service, address, port)
    {
        _stop = false;
    }

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Echo UDP client connected a new session with Id " << id() << std::endl;

        // Start receive datagrams
        ReceiveAsync();
    }

    void onDisconnected() override
    {
        std::cout << "Echo UDP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;

        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Echo UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop;
};

int main(int argc, char** argv)
{
    // UDP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // UDP server port
    int port = 3333;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "UDP server address: " << address << std::endl;
    std::cout << "UDP server port: " << port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP echo client
    auto client = std::make_shared<EchoClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Disconnect the client
        if (line == "!")
        {
            std::cout << "Client disconnecting...";
            client->DisconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the echo server
        client->SendSync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: UDP multicast server
Here comes the example of the UDP multicast server. It use multicast IP address
to multicast datagram messages to all client that joined corresponding UDP
multicast group.

```c++
#include "server/asio/udp_server.h"
#include "threads/thread.h"

#include <iostream>

class MulticastServer : public CppServer::Asio::UDPServer
{
public:
    using CppServer::Asio::UDPServer::UDPServer;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Multicast UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // UDP multicast address
    std::string multicast_address = "239.255.0.1";
    if (argc > 1)
        multicast_address = argv[1];

    // UDP multicast port
    int multicast_port = 3334;
    if (argc > 2)
        multicast_port = std::atoi(argv[2]);

    std::cout << "UDP multicast address: " << multicast_address << std::endl;
    std::cout << "UDP multicast port: " << multicast_port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP multicast server
    auto server = std::make_shared<MulticastServer>(service, 0);

    // Start the multicast server
    std::cout << "Server starting...";
    server->Start(multicast_address, multicast_port);
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->MulticastSync(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: UDP multicast client
Here comes the example of the UDP multicast client. It use multicast IP address
and joins UDP multicast group in order to receive multicasted datagram messages
from UDP server.

```c++
#include "server/asio/udp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class MulticastClient : public CppServer::Asio::UDPClient
{
public:
    MulticastClient(std::shared_ptr<CppServer::Asio::Service> service, const std::string& address, const std::string& multicast, int port)
        : CppServer::Asio::UDPClient(service, address, port),
          _multicast(multicast)
    {
        _stop = false;
    }

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Multicast UDP client connected a new session with Id " << id() << std::endl;

        // Join UDP multicast group
        JoinMulticastGroupAsync(_multicast);

        // Start receive datagrams
        ReceiveAsync();
    }

    void onDisconnected() override
    {
        std::cout << "Multicast UDP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;

        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Multicast UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop;
    std::string _multicast;
};

int main(int argc, char** argv)
{
    // UDP listen address
    std::string listen_address = "0.0.0.0";
    if (argc > 1)
        listen_address = argv[1];

    // UDP multicast address
    std::string multicast_address = "239.255.0.1";
    if (argc > 2)
        multicast_address = argv[2];

    // UDP multicast port
    int multicast_port = 3334;
    if (argc > 3)
        multicast_port = std::atoi(argv[3]);

    std::cout << "UDP listen address: " << listen_address << std::endl;
    std::cout << "UDP multicast address: " << multicast_address << std::endl;
    std::cout << "UDP multicast port: " << multicast_port << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP multicast client
    auto client = std::make_shared<MulticastClient>(service, listen_address, multicast_address, multicast_port);
    client->SetupMulticast(true);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Disconnect the client
        if (line == "!")
        {
            std::cout << "Client disconnecting...";
            client->DisconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: Simple protocol
Simple protocol is defined in [simple.fbe](https://github.com/chronoxor/CppServer/blob/master/proto/simple.fbe) file:

```proto
/*
   Simple Fast Binary Encoding protocol for CppServer
   https://github.com/chronoxor/FastBinaryEncoding

   Generate protocol command: fbec --cpp --proto --input=simple.fbe --output=.
*/

// Domain declaration
domain com.chronoxor

// Package declaration
package simple

// Protocol version
version 1.0

// Simple request message
[request]
[response(SimpleResponse)]
[reject(SimpleReject)]
message SimpleRequest
{
    // Request Id
    uuid [id] = uuid1;
    // Request message
    string Message;
}

// Simple response
message SimpleResponse
{
    // Response Id
    uuid [id] = uuid1;
    // Calculated message hash
    uint32 Hash;
}

// Simple reject
message SimpleReject
{
    // Reject Id
    uuid [id] = uuid1;
    // Error message
    string Error;
}

// Simple notification
message SimpleNotify
{
    // Server notification
    string Notification;
}

// Disconnect request message
[request]
message DisconnectRequest
{
    // Request Id
    uuid [id] = uuid1;
}
```

## Example: Simple protocol server
Here comes the example of  the  simple  protocol  server.  It  process  client
requests, answer with corresponding responses and  send  server  notifications
back to clients.

```c++
#include "asio_service.h"

#include "server/asio/tcp_server.h"

#include "../proto/simple_protocol.h"

#include <iostream>

class SimpleProtoSession : public CppServer::Asio::TCPSession, public FBE::simple::Sender, public FBE::simple::Receiver
{
public:
    using CppServer::Asio::TCPSession::TCPSession;

protected:
    void onConnected() override
    {
        std::cout << "Simple protocol session with Id " << id() << " connected!" << std::endl;

        // Send invite notification
        simple::SimpleNotify notify;
        notify.Notification = "Hello from Simple protocol server! Please send a message or '!' to disconnect the client!";
        send(notify);
    }

    void onDisconnected() override
    {
        std::cout << "Simple protocol session with Id " << id() << " disconnected!" << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol handlers
    void onReceive(const ::simple::DisconnectRequest& request) override { Disconnect(); }
    void onReceive(const ::simple::SimpleRequest& request) override
    {
        std::cout << "Received: " << request << std::endl;

        // Validate request
        if (request.Message.empty())
        {
            // Send reject
            simple::SimpleReject reject;
            reject.id = request.id;
            reject.Error = "Request message is empty!";
            send(reject);
            return;
        }

        static std::hash<std::string> hasher;

        // Send response
        simple::SimpleResponse response;
        response.id = request.id;
        response.Hash = (uint32_t)hasher(request.Message);
        send(response);
    }

    // Protocol implementation
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }
};

class SimpleProtoServer : public CppServer::Asio::TCPServer, public FBE::simple::Sender
{
public:
    using CppServer::Asio::TCPServer::TCPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<SimpleProtoSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol implementation
    size_t onSend(const void* data, size_t size) override { Multicast(data, size); return size; }
};

int main(int argc, char** argv)
{
    // Simple protocol server port
    int port = 4444;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "Simple protocol server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new simple protocol server
    auto server = std::make_shared<SimpleProtoServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin notification to all sessions
        simple::SimpleNotify notify;
        notify.Notification = "(admin) " + line;
        server->send(notify);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: Simple protocol client
Here comes the example of the simple  protocol  client.  It  connects  to  the
simple protocol  server  and  allows  to  send  requests  to  it  and  receive
corresponding responses.

```c++
#include "asio_service.h"

#include "server/asio/tcp_client.h"
#include "threads/thread.h"

#include "../proto/simple_protocol.h"

#include <atomic>
#include <iostream>

class SimpleProtoClient : public CppServer::Asio::TCPClient, public FBE::simple::Client
{
public:
    using CppServer::Asio::TCPClient::TCPClient;

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Simple protocol client connected a new session with Id " << id() << std::endl;

        // Reset FBE protocol buffers
        reset();
    }

    void onDisconnected() override
    {
        std::cout << "Simple protocol client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol handlers
    void onReceive(const ::simple::DisconnectRequest& request) override { Client::onReceive(request); std::cout << "Received: " << request << std::endl; DisconnectAsync(); }
    void onReceive(const ::simple::SimpleResponse& response) override { Client::onReceive(response); std::cout << "Received: " << response << std::endl; }
    void onReceive(const ::simple::SimpleReject& reject) override { Client::onReceive(reject); std::cout << "Received: " << reject << std::endl; }
    void onReceive(const ::simple::SimpleNotify& notify) override { Client::onReceive(notify); std::cout << "Received: " << notify << std::endl; }

    // Protocol implementation
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // TCP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // Simple protocol server port
    int port = 4444;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "Simple protocol server address: " << address << std::endl;
    std::cout << "Simple protocol server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new simple protocol client
    auto client = std::make_shared<SimpleProtoClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send request to the simple protocol server
        simple::SimpleRequest request;
        request.Message = line;
        auto response = client->request(request).get();

        // Show string hash calculation result
        std::cout << "Hash of '" << line << "' = " << std::format("0x{:8X}", response.Hash) << std::endl;
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: HTTP server
Here comes the example of the HTTP cache server. It allows to manipulate
cache data with HTTP methods (GET, POST, PUT and DELETE).

Use the following link to open [Swagger OpenAPI](https://swagger.io/specification/) iterative documentation: http://localhost:8080/api/index.html

![OpenAPI-HTTP](https://github.com/chronoxor/CppServer/raw/master/images/openapi-http.png)

```c++
#include "server/http/http_server.h"
#include "string/string_utils.h"
#include "utility/singleton.h"

#include <iostream>
#include <map>
#include <mutex>

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPCacheSession : public CppServer::HTTP::HTTPSession
{
public:
    using CppServer::HTTP::HTTPSession::HTTPSession;

protected:
    void onReceivedRequest(const CppServer::HTTP::HTTPRequest& request) override
    {
        // Show HTTP request content
        std::cout << std::endl << request;

        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const CppServer::HTTP::HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPCacheServer : public CppServer::HTTP::HTTPServer
{
public:
    using CppServer::HTTP::HTTPServer::HTTPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<HTTPCacheSession>(std::dynamic_pointer_cast<CppServer::HTTP::HTTPServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // HTTP server port
    int port = 8080;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // HTTP server content path
    std::string www = "../www/api";
    if (argc > 2)
        www = argv[2];

    std::cout << "HTTP server port: " << port << std::endl;
    std::cout << "HTTP server static content path: " << www << std::endl;
    std::cout << "HTTP server website: " << "http://localhost:" << port << "/api/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new HTTP server
    auto server = std::make_shared<HTTPCacheServer>(service, port);
    server->AddStaticContent(www, "/api");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: HTTP client
Here comes the example of the HTTP client. It allows to send HTTP requests
(GET, POST, PUT and DELETE) and receive HTTP responses.

```c++
#include "server/http/http_client.h"
#include "string/string_utils.h"

#include <iostream>

int main(int argc, char** argv)
{
    // HTTP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    std::cout << "HTTP server address: " << address << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new HTTP client
    auto client = std::make_shared<CppServer::HTTP::HTTPClientEx>(service, address, "http");

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    try
    {
        // Perform text input
        std::string line;
        while (getline(std::cin, line))
        {
            if (line.empty())
                break;

            // Reconnect the client
            if (line == "!")
            {
                std::cout << "Client reconnecting...";
                client->ReconnectAsync();
                std::cout << "Done!" << std::endl;
                continue;
            }

            auto commands = CppCommon::StringUtils::Split(line, ' ', true);
            if (commands.size() < 2)
            {
                std::cout << "HTTP method and URL must be entered!" << std::endl;
                continue;
            }

            if (CppCommon::StringUtils::ToUpper(commands[0]) == "HEAD")
            {
                auto response = client->SendHeadRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "GET")
            {
                auto response = client->SendGetRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "POST")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPostRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "PUT")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPutRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "DELETE")
            {
                auto response = client->SendDeleteRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "OPTIONS")
            {
                auto response = client->SendOptionsRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "TRACE")
            {
                auto response = client->SendTraceRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else
                std::cout << "Unknown HTTP method: " << commands[0] << std::endl;
        }
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << std::endl;
    }

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: HTTPS server
Here comes the example of the HTTPS cache server. It allows to manipulate
cache data with HTTP methods (GET, POST, PUT and DELETE) with secured
transport protocol.

Use the following link to open [Swagger OpenAPI](https://swagger.io/specification/) iterative documentation: https://localhost:8443/api/index.html

![OpenAPI-HTTPS](https://github.com/chronoxor/CppServer/raw/master/images/openapi-https.png)

```c++
#include "server/http/https_server.h"
#include "string/string_utils.h"
#include "utility/singleton.h"

#include <iostream>
#include <map>
#include <mutex>

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPSCacheSession : public CppServer::HTTP::HTTPSSession
{
public:
    using CppServer::HTTP::HTTPSSession::HTTPSSession;

protected:
    void onReceivedRequest(const CppServer::HTTP::HTTPRequest& request) override
    {
        // Show HTTP request content
        std::cout << std::endl << request;

        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const CppServer::HTTP::HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPSCacheServer : public CppServer::HTTP::HTTPSServer
{
public:
    using CppServer::HTTP::HTTPSServer::HTTPSServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(const std::shared_ptr<CppServer::Asio::SSLServer>& server) override
    {
        return std::make_shared<HTTPSCacheSession>(std::dynamic_pointer_cast<CppServer::HTTP::HTTPSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // HTTPS server port
    int port = 8443;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // HTTPS server content path
    std::string www = "../www/api";
    if (argc > 2)
        www = argv[2];

    std::cout << "HTTPS server port: " << port << std::endl;
    std::cout << "HTTPS server static content path: " << www << std::endl;
    std::cout << "HTTPS server website: " << "https://localhost:" << port << "/api/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new HTTPS server
    auto server = std::make_shared<HTTPSCacheServer>(service, context, port);
    server->AddStaticContent(www, "/api");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: HTTPS client
Here comes the example of the HTTPS client. It allows to send HTTP requests
(GET, POST, PUT and DELETE) and receive HTTP responses with secured
transport protocol.

```c++
#include "server/http/https_client.h"
#include "string/string_utils.h"

#include <iostream>

int main(int argc, char** argv)
{
    // HTTP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    std::cout << "HTTPS server address: " << address << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new HTTP client
    auto client = std::make_shared<CppServer::HTTP::HTTPSClientEx>(service, context, address, "https");

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    try
    {
        // Perform text input
        std::string line;
        while (getline(std::cin, line))
        {
            if (line.empty())
                break;

            // Reconnect the client
            if (line == "!")
            {
                std::cout << "Client reconnecting...";
                client->ReconnectAsync();
                std::cout << "Done!" << std::endl;
                continue;
            }

            auto commands = CppCommon::StringUtils::Split(line, ' ', true);
            if (commands.size() < 2)
            {
                std::cout << "HTTP method and URL must be entered!" << std::endl;
                continue;
            }

            if (CppCommon::StringUtils::ToUpper(commands[0]) == "HEAD")
            {
                auto response = client->SendHeadRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "GET")
            {
                auto response = client->SendGetRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "POST")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPostRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "PUT")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPutRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "DELETE")
            {
                auto response = client->SendDeleteRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "OPTIONS")
            {
                auto response = client->SendOptionsRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "TRACE")
            {
                auto response = client->SendTraceRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else
                std::cout << "Unknown HTTP method: " << commands[0] << std::endl;
        }
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << std::endl;
    }

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: WebSocket chat server
Here comes the example of the WebSocket chat server. It handles multiple
WebSocket client sessions and multicast received message from any session
to all ones. Also it is possible to send admin message directly from the
server.

Use the following link to open WebSocket chat server example: http://localhost:8080/chat/index.html

![ws-chat](https://github.com/chronoxor/CppServer/raw/master/images/ws-chat.png)

```c++
#include "server/ws/ws_server.h"

#include <iostream>

class ChatSession : public CppServer::WS::WSSession
{
public:
    using CppServer::WS::WSSession::WSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override
    {
        std::cout << "Chat WebSocket session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from WebSocket chat! Please send a message or '!' to disconnect the client!");
        SendTextAsync(message);
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket session with Id " << id() << " disconnected!" << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        std::dynamic_pointer_cast<CppServer::WS::WSServer>(server())->MulticastText(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Close(1000);
    }

    void onWSPing(const void* buffer, size_t size) override
    {
        SendPongAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::WS::WSServer
{
public:
    using CppServer::WS::WSServer::WSServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(std::shared_ptr<CppServer::Asio::TCPServer> server) override
    {
        return std::make_shared<ChatSession>(std::dynamic_pointer_cast<CppServer::WS::WSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // WebSocket server port
    int port = 8080;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // WebSocket server content path
    std::string www = "../www/ws";
    if (argc > 2)
        www = argv[2];

    std::cout << "WebSocket server port: " << port << std::endl;
    std::cout << "WebSocket server static content path: " << www << std::endl;
    std::cout << "WebSocket server website: " << "http://localhost:" << port << "/chat/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new WebSocket chat server
    auto server = std::make_shared<ChatServer>(service, port);
    server->AddStaticContent(www, "/chat");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->MulticastText(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: WebSocket chat client
Here comes the example of the WebSocket chat client. It connects to the
WebSocket chat server and allows to send message to it and receive new
messages.

```c++
#include "server/ws/ws_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::WS::WSClient
{
public:
    using CppServer::WS::WSClient::WSClient;

    void DisconnectAndStop()
    {
        _stop = true;
        CloseAsync(1000);
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "http://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        std::cout << "Chat WebSocket client connected a new session with Id " << id() << std::endl;
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket client disconnected a session with Id " << id() << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onWSPing(const void* buffer, size_t size) override
    {
        SendPongAsync(buffer, size);
    }

    void onDisconnected() override
    {
        WSClient::onDisconnected();

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // WebSocket server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // WebSocket server port
    int port = 8080;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "WebSocket server address: " << address << std::endl;
    std::cout << "WebSocket server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new WebSocket chat client
    auto client = std::make_shared<ChatClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->ReconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendTextAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: WebSocket secure chat server
Here comes the example of the WebSocket secure chat server. It handles
multiple WebSocket secure client sessions and multicast received message
from any session to all ones. Also it is possible to send admin message
directly from the server.

This example is very similar to the WebSocket one except the code that
prepares WebSocket secure context and handshake handler.

Use the following link to open WebSocket secure chat server example: https://localhost:8443/chat/index.html

![wss-chat](https://github.com/chronoxor/CppServer/raw/master/images/wss-chat.png)

```c++
#include "server/ws/wss_server.h"

#include <iostream>

class ChatSession : public CppServer::WS::WSSSession
{
public:
    using CppServer::WS::WSSSession::WSSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override
    {
        std::cout << "Chat WebSocket secure session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from WebSocket secure chat! Please send a message or '!' to disconnect the client!");
        SendTextAsync(message);
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket secure session with Id " << id() << " disconnected!" << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        std::dynamic_pointer_cast<CppServer::WS::WSSServer>(server())->MulticastText(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Close(1000);
    }

    void onWSPing(const void* buffer, size_t size) override
    {
        SendPongAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::WS::WSSServer
{
public:
    using CppServer::WS::WSSServer::WSSServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(std::shared_ptr<CppServer::Asio::SSLServer> server) override
    {
        return std::make_shared<ChatSession>(std::dynamic_pointer_cast<CppServer::WS::WSSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // WebSocket secure server port
    int port = 8443;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // WebSocket secure server content path
    std::string www = "../www/wss";
    if (argc > 2)
        www = argv[2];

    std::cout << "WebSocket secure server port: " << port << std::endl;
    std::cout << "WebSocket secure server static content path: " << www << std::endl;
    std::cout << "WebSocket server website: " << "https://localhost:" << port << "/chat/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new WebSocket secure chat server
    auto server = std::make_shared<ChatServer>(service, context, port);
    server->AddStaticContent(www, "/chat");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->MulticastText(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

## Example: WebSocket secure chat client
Here comes the example of the WebSocket secure chat client. It connects to
the WebSocket secure chat server and allows to send message to it and receive
new messages.

This example is very similar to the WebSocket one except the code that
prepares WebSocket secure context and handshake handler.

```c++
#include "server/ws/wss_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::WS::WSSClient
{
public:
    using CppServer::WS::WSSClient::WSSClient;

    void DisconnectAndStop()
    {
        _stop = true;
        CloseAsync(1000);
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "https://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        std::cout << "Chat WebSocket secure client connected a new session with Id " << id() << std::endl;
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket secure client disconnected a session with Id " << id() << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onWSPing(const void* buffer, size_t size) override
    {
        SendPongAsync(buffer, size);
    }

    void onDisconnected() override
    {
        WSSClient::onDisconnected();

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // WebSocket server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // WebSocket server port
    int port = 8443;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "WebSocket secure server address: " << address << std::endl;
    std::cout << "WebSocket secure server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<CppServer::Asio::Service>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv12);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new WebSocket chat client
    auto client = std::make_shared<ChatClient>(service, context, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->ReconnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendTextAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}
```

# Performance

Here comes several communication scenarios with timing measurements.

Benchmark environment is the following:
```
CPU architecutre: Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz
CPU logical cores: 8
CPU physical cores: 4
CPU clock speed: 3.998 GHz
CPU Hyper-Threading: enabled
RAM total: 31.962 GiB
RAM free: 21.623 GiB

OS version: Microsoft Windows 8 Enterprise Edition (build 9200), 64-bit
OS bits: 64-bit
Process bits: 64-bit
Process configuaraion: release
```

## Benchmark: Round-Trip

![Round-trip](https://github.com/chronoxor/CppServer/raw/master/images/round-trip.png)

This scenario sends lots of messages from several clients to a server.
The server responses to each message and resend the similar response to
the client. The benchmark measures total round-trip time to send all
messages and receive all responses, messages & data throughput, count
of errors.

### TCP echo server

* [cppserver-performance-tcp_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_echo_server.cpp)
* [cppserver-performance-tcp_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_echo_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 1111
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.001 s
Total data: 1.692 GiB
Total messages: 56261685
Data throughput: 171.693 MiB/s
Message latency: 177 ns
Message throughput: 5625528 msg/s
```

* [cppserver-performance-tcp_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_echo_server.cpp)
* [cppserver-performance-tcp_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_echo_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 1111
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.007 s
Total data: 1.151 GiB
Total messages: 38503396
Data throughput: 117.423 MiB/s
Message latency: 259 ns
Message throughput: 3847402 msg/s
```

### SSL echo server

* [cppserver-performance-ssl_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_echo_server.cpp)
* [cppserver-performance-ssl_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_echo_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 2222
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.012 s
Total data: 296.350 MiB
Total messages: 9710535
Data throughput: 29.612 MiB/s
Message latency: 1.031 mcs
Message throughput: 969878 msg/s
```

* [cppserver-performance-ssl_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_echo_server.cpp)
* [cppserver-performance-ssl_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_echo_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 2222
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.341 s
Total data: 390.660 MiB
Total messages: 12800660
Data throughput: 37.792 MiB/s
Message latency: 807 ns
Message throughput: 1237782 msg/s
```

### UDP echo server

* [cppserver-performance-udp_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/udp_echo_server.cpp)
* [cppserver-performance-udp_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/udp_echo_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 3333
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.002 s
Total data: 46.032 MiB
Total messages: 1508355
Data throughput: 4.616 MiB/s
Message latency: 6.631 mcs
Message throughput: 150801 msg/s
```

* [cppserver-performance-udp_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/udp_echo_server.cpp)
* [cppserver-performance-udp_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/udp_echo_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 3333
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.152 s
Total data: 32.185 MiB
Total messages: 1054512
Data throughput: 3.173 MiB/s
Message latency: 9.627 mcs
Message throughput: 103867 msg/s
```

### Simple protocol server

* [cppserver-performance-proto_server](https://github.com/chronoxor/CppServer/blob/master/performance/proto_server.cpp)
* [cppserver-performance-proto_client](https://github.com/chronoxor/CppServer/blob/master/performance/proto_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 4444
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.002 s
Total data: 497.096 MiB
Total messages: 16288783
Data throughput: 49.715 MiB/s
Message latency: 614 ns
Message throughput: 1628542 msg/s
```

* [cppserver-performance-proto_server](https://github.com/chronoxor/CppServer/blob/master/performance/proto_server.cpp)
* [cppserver-performance-proto_client](https://github.com/chronoxor/CppServer/blob/master/performance/proto_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 4444
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.066 s
Total data: 997.384 MiB
Total messages: 32681995
Data throughput: 99.078 MiB/s
Message latency: 308 ns
Message throughput: 3246558 msg/s
```

### WebSocket echo server

* [cppserver-performance-ws_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/ws_echo_server.cpp)
* [cppserver-performance-ws_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/ws_echo_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 8080
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 9.994 s
Total data: 48.958 MiB
Total messages: 1603548
Data throughput: 4.918 MiB/s
Message latency: 6.232 mcs
Message throughput: 160448 msg/s
```

* [cppserver-performance-ws_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/ws_echo_server.cpp)
* [cppserver-performance-ws_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/ws_echo_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 8080
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 11.402 s
Total data: 206.827 MiB
Total messages: 6776702
Data throughput: 18.140 MiB/s
Message latency: 1.682 mcs
Message throughput: 594328 msg/s
```

### WebSocket secure echo server

* [cppserver-performance-wss_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/wss_echo_server.cpp)
* [cppserver-performance-wss_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/wss_echo_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 8443
Working threads: 1
Working clients: 1
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.001 s
Total data: 62.068 MiB
Total messages: 2033811
Data throughput: 6.210 MiB/s
Message latency: 4.917 mcs
Message throughput: 203343 msg/s
```

* [cppserver-performance-wss_echo_server](https://github.com/chronoxor/CppServer/blob/master/performance/wss_echo_server.cpp)
* [cppserver-performance-wss_echo_client](https://github.com/chronoxor/CppServer/blob/master/performance/wss_echo_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 8443
Working threads: 4
Working clients: 100
Working messages: 1000
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.011 s
Total data: 249.1023 MiB
Total messages: 8191971
Data throughput: 24.993 MiB/s
Message latency: 1.222 mcs
Message throughput: 818230 msg/s
```

## Benchmark: Multicast

![Multicast](https://github.com/chronoxor/CppServer/raw/master/images/multicast.png)

In this scenario server multicasts messages to all connected clients.
The benchmark counts total messages received by all clients for all
the working time and measures messages & data throughput, count
of errors.

### TCP multicast server

* [cppserver-performance-tcp_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_multicast_server.cpp)
* [cppserver-performance-tcp_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_multicast_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 1111
Working threads: 1
Working clients: 1
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.001 s
Total data: 1.907 GiB
Total messages: 63283367
Data throughput: 193.103 MiB/s
Message latency: 158 ns
Message throughput: 6327549 msg/s
```

* [cppserver-performance-tcp_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_multicast_server.cpp)
* [cppserver-performance-tcp_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/tcp_multicast_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 1111
Working threads: 4
Working clients: 100
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.006 s
Total data: 1.1006 GiB
Total messages: 66535013
Data throughput: 202.930 MiB/s
Message latency: 150 ns
Message throughput: 6648899 msg/s
```

### SSL multicast server

* [cppserver-performance-ssl_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_multicast_server.cpp)
* [cppserver-performance-ssl_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_multicast_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 2222
Working threads: 1
Working clients: 1
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.014 s
Total data: 1.535 GiB
Total messages: 51100073
Data throughput: 155.738 MiB/s
Message latency: 195 ns
Message throughput: 5102683 msg/s
```

* [cppserver-performance-ssl_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_multicast_server.cpp)
* [cppserver-performance-ssl_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/ssl_multicast_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 2222
Working threads: 4
Working clients: 100
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.691 s
Total data: 1.878 GiB
Total messages: 62334478
Data throughput: 177.954 MiB/s
Message latency: 171 ns
Message throughput: 5830473 msg/s
```

### UDP multicast server

* [cppserver-performance-udp_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/udp_multicast_server.cpp)
* [cppserver-performance-udp_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/udp_multicast_client.cpp) --clients 1 --threads 1

```
Server address: 239.255.0.1
Server port: 3333
Working threads: 1
Working clients: 1
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.002 s
Total data: 23.777 MiB
Total messages: 778555
Data throughput: 2.384 MiB/s
Message latency: 12.847 mcs
Message throughput: 77833 msg/s
```

* [cppserver-performance-udp_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/udp_multicast_server.cpp)
* [cppserver-performance-udp_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/udp_multicast_client.cpp) --clients 100 --threads 4

```
Server address: 239.255.0.1
Server port: 3333
Working threads: 4
Working clients: 100
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.004 s
Total data: 52.457 MiB
Total messages: 1718575
Data throughput: 5.248 MiB/s
Message latency: 5.821 mcs
Message throughput: 171784 msg/s
```

### WebSocket multicast server

* [cppserver-performance-ws_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/ws_multicast_server.cpp)
* [cppserver-performance-ws_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/ws_multicast_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 8080
Working threads: 1
Working clients: 1
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.001 s
Total data: 960.902 MiB
Total messages: 31486166
Data throughput: 96.075 MiB/s
Message latency: 317 ns
Message throughput: 3148135 msg/s
```

* [cppserver-performance-ws_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/ws_multicast_server.cpp)
* [cppserver-performance-ws_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/ws_multicast_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 8080
Working threads: 4
Working clients: 100
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.020 s
Total data: 986.489 MiB
Total messages: 32324898
Data throughput: 98.459 MiB/s
Message latency: 309 ns
Message throughput: 3225965 msg/s
```

### WebSocket secure multicast server

* [cppserver-performance-wss_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/wss_multicast_server.cpp)
* [cppserver-performance-wss_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/wss_multicast_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 8443
Working threads: 1
Working clients: 1
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.002 s
Total data: 1.041 GiB
Total messages: 34903186
Data throughput: 106.505 MiB/s
Message latency: 286 ns
Message throughput: 3489578 msg/s
```

* [cppserver-performance-wss_multicast_server](https://github.com/chronoxor/CppServer/blob/master/performance/wss_multicast_server.cpp)
* [cppserver-performance-wss_multicast_client](https://github.com/chronoxor/CppServer/blob/master/performance/wss_multicast_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 8443
Working threads: 4
Working clients: 100
Message size: 32
Seconds to benchmarking: 10

Errors: 0

Total time: 10.013 s
Total data: 1.569 GiB
Total messages: 52225588
Data throughput: 159.172 MiB/s
Message latency: 191 ns
Message throughput: 5215639 msg/s
```

## Benchmark: Web Server

### HTTP Trace server

* [cppserver-performance-http_trace_server](https://github.com/chronoxor/CppServer/blob/master/performance/http_trace_server.cpp)
* [cppserver-performance-http_trace_client](https://github.com/chronoxor/CppServer/blob/master/performance/http_trace_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 80
Working threads: 1
Working clients: 1
Working messages: 1
Seconds to benchmarking: 10

Errors: 0

Total time: 10.001 s
Total data: 58.476 MiB
Total messages: 578353
Data throughput: 5.865 MiB/s
Message latency: 17.293 mcs
Message throughput: 57825 msg/s
```

* [cppserver-performance-http_trace_server](https://github.com/chronoxor/CppServer/blob/master/performance/http_trace_server.cpp)
* [cppserver-performance-http_trace_client](https://github.com/chronoxor/CppServer/blob/master/performance/http_trace_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 80
Working threads: 4
Working clients: 100
Working messages: 1
Seconds to benchmarking: 10

Errors: 0

Total time: 10.006 s
Total data: 310.730 MiB
Total messages: 3073650
Data throughput: 31.051 MiB/s
Message latency: 3.255 mcs
Message throughput: 307154 msg/s
```

### HTTPS Trace server

* [cppserver-performance-https_trace_server](https://github.com/chronoxor/CppServer/blob/master/performance/https_trace_server.cpp)
* [cppserver-performance-https_trace_client](https://github.com/chronoxor/CppServer/blob/master/performance/https_trace_client.cpp) --clients 1 --threads 1

```
Server address: 127.0.0.1
Server port: 443
Working threads: 1
Working clients: 1
Working messages: 1
Seconds to benchmarking: 10

Errors: 0

Total time: 10.003 s
Total data: 37.475 MiB
Total messages: 370602
Data throughput: 3.763 MiB/s
Message latency: 26.992 mcs
Message throughput: 37047 msg/s
```

* [cppserver-performance-https_trace_server](https://github.com/chronoxor/CppServer/blob/master/performance/https_trace_server.cpp)
* [cppserver-performance-https_trace_client](https://github.com/chronoxor/CppServer/blob/master/performance/https_trace_client.cpp) --clients 100 --threads 4

```
Server address: 127.0.0.1
Server port: 443
Working threads: 4
Working clients: 100
Working messages: 1
Seconds to benchmarking: 10

Errors: 0

Total time: 10.035 s
Total data: 204.531 MiB
Total messages: 2023152
Data throughput: 20.389 MiB/s
Message latency: 4.960 mcs
Message throughput: 201602 msg/s
```

# OpenSSL certificates
In order to create OpenSSL based server and client you should prepare a set of
SSL certificates.

## Production
Depending on your project, you may need to purchase a traditional SSL
certificate signed by a Certificate Authority. If you, for instance,
want some else's web browser to talk to your WebSocket project, you'll
need a traditional SSL certificate.

## Development
The commands below entered in the order they are listed will generate a
self-signed certificate for development or testing purposes.

## Certificate Authority

* Create CA private key
```shell
openssl genrsa -passout pass:qwerty -out ca-secret.key 4096
```

* Remove passphrase
```shell
openssl rsa -passin pass:qwerty -in ca-secret.key -out ca.key
```

* Create CA self-signed certificate
```shell
openssl req -new -x509 -days 3650 -subj '/C=BY/ST=Belarus/L=Minsk/O=Example root CA/OU=Example CA unit/CN=example.com' -key ca.key -out ca.crt
```

* Convert CA self-signed certificate to PFX
```shell
openssl pkcs12 -export -passout pass:qwerty -inkey ca.key -in ca.crt -out ca.pfx
```

* Convert CA self-signed certificate to PEM
```shell
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in ca.pfx -out ca.pem
```

## SSL Server certificate

* Create private key for the server
```shell
openssl genrsa -passout pass:qwerty -out server-secret.key 4096
```

* Remove passphrase
```shell
openssl rsa -passin pass:qwerty -in server-secret.key -out server.key
```

* Create CSR for the server
```shell
openssl req -new -subj '/C=BY/ST=Belarus/L=Minsk/O=Example server/OU=Example server unit/CN=server.example.com' -key server.key -out server.csr
```

* Create certificate for the server
```shell
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt
```

* Convert the server certificate to PFX
```shell
openssl pkcs12 -export -passout pass:qwerty -inkey server.key -in server.crt -out server.pfx
```

* Convert the server certificate to PEM
```shell
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in server.pfx -out server.pem
```

## SSL Client certificate

* Create private key for the client
```shell
openssl genrsa -passout pass:qwerty -out client-secret.key 4096
```

* Remove passphrase
```shell
openssl rsa -passin pass:qwerty -in client-secret.key -out client.key
```

* Create CSR for the client
```shell
openssl req -new -subj '/C=BY/ST=Belarus/L=Minsk/O=Example client/OU=Example client unit/CN=client.example.com' -key client.key -out client.csr
```

* Create the client certificate
```shell
openssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt
```

* Convert the client certificate to PFX
```shell
openssl pkcs12 -export -passout pass:qwerty -inkey client.key -in client.crt -out client.pfx
```

* Convert the client certificate to PEM
```shell
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in client.pfx -out client.pem
```

## Diffie-Hellman key exchange

* Create DH parameters
```shell
openssl dhparam -out dh4096.pem 4096
```

```

`TODO.md`:

```md
# CppServer todo

```

`bin/.gitignore`:

```
# Ignore everything in this directory
*
# Except this file
!.gitignore

```

`documents/Doxyfile`:

```
# Doxyfile 1.9.8

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").
#
# Note:
#
# Use doxygen to compare the used configuration file with the template
# configuration file:
# doxygen -x [configFile]
# Use doxygen to compare the used configuration file with the template
# configuration file without replacing the environment variables or CMake type
# replacement variables:
# doxygen -x_noenv [configFile]

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the configuration
# file that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = CppServer

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         = 1.0.5.0

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "C++ Server Library"

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           =

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       =

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create up to 4096
# sub-directories (in 2 levels) under the output directory of each output format
# and will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system. Adapt CREATE_SUBDIRS_LEVEL to
# control the number of sub-directories.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# Controls the number of sub-directories that will be created when
# CREATE_SUBDIRS tag is set to YES. Level 0 represents 16 directories, and every
# level increment doubles the number of directories, resulting in 4096
# directories at level 8 which is the default and also the maximum value. The
# sub-directories are organized in 2 levels, the first level always has a fixed
# number of 16 directories.
# Minimum value: 0, maximum value: 8, default value: 8.
# This tag requires that the tag CREATE_SUBDIRS is set to YES.

CREATE_SUBDIRS_LEVEL   = 8

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Bulgarian,
# Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, English
# (United States), Esperanto, Farsi (Persian), Finnish, French, German, Greek,
# Hindi, Hungarian, Indonesian, Italian, Japanese, Japanese-en (Japanese with
# English messages), Korean, Korean-en (Korean with English messages), Latvian,
# Lithuanian, Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese,
# Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish,
# Swedish, Turkish, Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       =

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        = ../

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
# such as
# /***************
# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
# Javadoc-style will behave just like regular comments and it will not be
# interpreted by doxygen.
# The default value is: NO.

JAVADOC_BANNER         = NO

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# By default Python docstrings are displayed as preformatted text and doxygen's
# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the
# doxygen's special commands can be used and the contents of the docstring
# documentation blocks is shown as doxygen documentation.
# The default value is: YES.

PYTHON_DOCSTRING       = YES

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:^^"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". Note that you cannot put \n's in the value part of an alias
# to insert newlines (in the resulting output). You can put ^^ in the value part
# of an alias to insert a newline as if a physical newline was in the original
# file. When you need a literal { or } or , in the value part of an alias you
# have to escape them by means of a backslash (\), this can lead to conflicts
# with the commands \{ and \} for these it is advised to use the version @{ and
# @} or use a double escape (\\{ and \\})

ALIASES                =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
# sources only. Doxygen will then generate output that is more tailored for that
# language. For instance, namespaces will be presented as modules, types will be
# separated into more groups, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_SLICE  = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,
# Csharp (C#), C, C++, Lex, D, PHP, md (Markdown), Objective-C, Python, Slice,
# VHDL, Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
# tries to guess whether the code is fixed or free formatted code, this is the
# default for Fortran type files). For instance to make doxygen treat .inc files
# as Fortran files (default is PHP), and .f files as C (default is Fortran),
# use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen. When specifying no_extension you should add
# * to the FILE_PATTERNS.
#
# Note see also the list of default file extension mappings.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See https://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 5.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 5

# The MARKDOWN_ID_STYLE tag can be used to specify the algorithm used to
# generate identifiers for the Markdown headings. Note: Every identifier is
# unique.
# Possible values are: DOXYGEN use a fixed 'autotoc_md' string followed by a
# sequence number starting at 0 and GITHUB use the lower case version of title
# with any whitespace replaced by '-' and punctuation characters removed.
# The default value is: DOXYGEN.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

MARKDOWN_ID_STYLE      = DOXYGEN

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

# The NUM_PROC_THREADS specifies the number of threads doxygen is allowed to use
# during processing. When set to 0 doxygen will based this on the number of
# cores available in the system. You can set it explicitly to a value larger
# than 0 to get more control over the balance between CPU load and processing
# speed. At this moment only the input processing can be done using multiple
# threads. Since this is still an experimental feature the default is set to 1,
# which effectively disables parallel processing. Please report any issues you
# encounter. Generating dot graphs in parallel is controlled by the
# DOT_NUM_THREADS setting.
# Minimum value: 0, maximum value: 32, default value: 1.

NUM_PROC_THREADS       = 1

# If the TIMESTAMP tag is set different from NO then each generated page will
# contain the date or date and time when the page was generated. Setting this to
# NO can help when comparing the output of multiple runs.
# Possible values are: YES, NO, DATETIME and DATE.
# The default value is: NO.

TIMESTAMP              = NO

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
# methods of a class will be included in the documentation.
# The default value is: NO.

EXTRACT_PRIV_VIRTUAL   = NO

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If this flag is set to YES, the name of an unnamed parameter in a declaration
# will be determined by the corresponding definition. By default unnamed
# parameters remain unnamed in the output.
# The default value is: YES.

RESOLVE_UNNAMED_PARAMS = YES

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# will also hide undocumented C++ concepts if enabled. This option has no effect
# if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# declarations. If set to NO, these declarations will be included in the
# documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# With the correct setting of option CASE_SENSE_NAMES doxygen will better be
# able to match the capabilities of the underlying filesystem. In case the
# filesystem is case sensitive (i.e. it supports files in the same directory
# whose names only differ in casing), the option must be set to YES to properly
# deal with such files in case they appear in the input. For filesystems that
# are not case sensitive the option should be set to NO to properly deal with
# output files written for symbols that only differ in casing, such as for two
# classes, one named CLASS and the other named Class, and to also support
# references to files without having to specify the exact matching casing. On
# Windows (including Cygwin) and MacOS, users should typically set this option
# to NO, whereas on Linux or other Unix flavors it should typically be set to
# YES.
# Possible values are: SYSTEM, NO and YES.
# The default value is: SYSTEM.

CASE_SENSE_NAMES       = NO

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_HEADERFILE tag is set to YES then the documentation for a class
# will show which file needs to be included to use the class.
# The default value is: YES.

SHOW_HEADERFILE        = YES

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file. See also section "Changing the
# layout of pages" for information.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as documenting some parameters in
# a documented function twice, or documenting parameters that don't exist or
# using markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# If WARN_IF_INCOMPLETE_DOC is set to YES, doxygen will warn about incomplete
# function parameter documentation. If set to NO, doxygen will accept that some
# parameters have no documentation without warning.
# The default value is: YES.

WARN_IF_INCOMPLETE_DOC = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong parameter
# documentation, but not about the absence of documentation. If EXTRACT_ALL is
# set to YES then this flag will automatically be disabled. See also
# WARN_IF_INCOMPLETE_DOC
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If WARN_IF_UNDOC_ENUM_VAL option is set to YES, doxygen will warn about
# undocumented enumeration values. If set to NO, doxygen will accept
# undocumented enumeration values. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: NO.

WARN_IF_UNDOC_ENUM_VAL = NO

# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS
# then doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but
# at the end of the doxygen process doxygen will return with a non-zero status.
# If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS_PRINT then doxygen behaves
# like FAIL_ON_WARNINGS but in case no WARN_LOGFILE is defined doxygen will not
# write the warning messages in between other messages but write them at the end
# of a run, in case a WARN_LOGFILE is defined the warning messages will be
# besides being in the defined file also be shown at the end of a run, unless
# the WARN_LOGFILE is defined as - i.e. standard output (stdout) in that case
# the behavior will remain as with the setting FAIL_ON_WARNINGS.
# Possible values are: NO, YES, FAIL_ON_WARNINGS and FAIL_ON_WARNINGS_PRINT.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# See also: WARN_LINE_FORMAT
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# In the $text part of the WARN_FORMAT command it is possible that a reference
# to a more specific place is given. To make it easier to jump to this place
# (outside of doxygen) the user can define a custom "cut" / "paste" string.
# Example:
# WARN_LINE_FORMAT = "'vi $file +$line'"
# See also: WARN_FORMAT
# The default value is: at line $line of file $file.

WARN_LINE_FORMAT       = "at line $line of file $file"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr). In case the file specified cannot be opened for writing the
# warning and error messages are written to standard error. When as file - is
# specified the warning and error messages are written to standard output
# (stdout).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = ../include \
                         ../source

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see:
# https://www.gnu.org/software/libiconv/) for the list of possible encodings.
# See also: INPUT_FILE_ENCODING
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# This tag can be used to specify the character encoding of the source files
# that doxygen parses The INPUT_FILE_ENCODING tag can be used to specify
# character encoding on a per file pattern basis. Doxygen will compare the file
# name with each pattern and apply the encoding instead of the default
# INPUT_ENCODING) if there is a match. The character encodings are a list of the
# form: pattern=encoding (like *.php=ISO-8859-1). See cfg_input_encoding
# "INPUT_ENCODING" for further information on supported encodings.

INPUT_FILE_ENCODING    =

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by doxygen.
#
# Note the list of default checked file patterns might differ from the list of
# default file extension mappings.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cxxm,
# *.cpp, *.cppm, *.c++, *.c++m, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl,
# *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp, *.h++, *.ixx, *.l, *.cs, *.d, *.php,
# *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown, *.md, *.mm, *.dox (to be
# provided as doxygen C comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
# *.f18, *.f, *.for, *.vhd, *.vhdl, *.ucf, *.qsf and *.ice.

FILE_PATTERNS          =

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# ANamespace::AClass, ANamespace::*Test

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           = ../examples \
                         ../tests

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       =

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = YES

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             = ../images

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that doxygen will use the data processed and written to standard output
# for further processing, therefore nothing else, like debug statements or used
# commands (so in case of a Windows batch file always use @echo OFF), should be
# written to standard output.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE =

# The Fortran standard specifies that for fixed formatted Fortran code all
# characters from position 72 are to be considered as comment. A common
# extension is to allow longer lines before the automatic comment starts. The
# setting FORTRAN_COMMENT_AFTER will also make it possible that longer lines can
# be processed before the automatic comment starts.
# Minimum value: 7, maximum value: 10000, default value: 72.

FORTRAN_COMMENT_AFTER  = 72

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = YES

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# entity all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see https://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
# clang parser (see:
# http://clang.llvm.org/) for more accurate parsing at the cost of reduced
# performance. This can be particularly helpful with template rich C++ code for
# which doxygen's built-in parser lacks the necessary type information.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.
# The default value is: NO.

CLANG_ASSISTED_PARSING = NO

# If the CLANG_ASSISTED_PARSING tag is set to YES and the CLANG_ADD_INC_PATHS
# tag is set to YES then doxygen will add the directory of each input to the
# include path.
# The default value is: YES.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_ADD_INC_PATHS    = YES

# If clang assisted parsing is enabled you can provide the compiler with command
# line options that you would normally use when invoking the compiler. Note that
# the include paths will already be set by doxygen for the files and directories
# specified with INPUT and INCLUDE_PATH.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_OPTIONS          =

# If clang assisted parsing is enabled you can provide the clang parser with the
# path to the directory containing a file called compile_commands.json. This
# file is the compilation database (see:
# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) containing the
# options used when the source files were built. This is equivalent to
# specifying the -p option to a clang tool, such as clang-check. These options
# will then be passed to the parser. Any options specified with CLANG_OPTIONS
# will be added as well.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.

CLANG_DATABASE_PATH    =

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The IGNORE_PREFIX tag can be used to specify a prefix (or a list of prefixes)
# that should be ignored while generating the index headers. The IGNORE_PREFIX
# tag works for classes, function and member names. The entity will be placed in
# the alphabetical list under the first letter of the entity name that remains
# after removing the prefix.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# Note: Since the styling of scrollbars can currently not be overruled in
# Webkit/Chromium, the styling will be left out of the default doxygen.css if
# one or more extra stylesheets have been specified. So if scrollbar
# customization is desired it has to be added explicitly. For an example see the
# documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE tag can be used to specify if the generated HTML output
# should be rendered with a dark or light theme.
# Possible values are: LIGHT always generate light mode output, DARK always
# generate dark mode output, AUTO_LIGHT automatically set the mode according to
# the user preference, use light mode if no preference is set (the default),
# AUTO_DARK automatically set the mode according to the user preference, use
# dark mode if no preference is set and TOGGLE allow to user to switch between
# light and dark mode via a button.
# The default value is: AUTO_LIGHT.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE        = AUTO_LIGHT

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a color-wheel, see
# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use gray-scales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
# documentation will contain a main index with vertical navigation menus that
# are dynamically created via JavaScript. If disabled, the navigation index will
# consists of multiple levels of tabs that are statically embedded in every HTML
# page. Disable this option to support browsers that do not have JavaScript,
# like the Qt help browser.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_MENUS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# If the HTML_CODE_FOLDING tag is set to YES then classes and functions can be
# dynamically folded and expanded in the generated HTML source code.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_CODE_FOLDING      = YES

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see:
# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To
# create a documentation set, doxygen will generate a Makefile in the HTML
# output directory. Running make will produce the docset in that directory and
# running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
# genXcode/_index.html for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag determines the URL of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDURL         =

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# on Windows. In the beginning of 2021 Microsoft took the original page, with
# a.o. the download links, offline the HTML help workshop was already many years
# in maintenance mode). You can download the HTML help workshop from the web
# archives at Installation executable (see:
# http://web.archive.org/web/20160201063255/http://download.microsoft.com/downlo
# ad/0/A/9/0A939EF6-E31C-430F-A3DF-DFAE7960D564/htmlhelp.exe).
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the main .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# The SITEMAP_URL tag is used to specify the full URL of the place where the
# generated documentation will be placed on the server by the user during the
# deployment of the documentation. The generated sitemap is called sitemap.xml
# and placed on the directory specified by HTML_OUTPUT. In case no SITEMAP_URL
# is specified no sitemap is generated. For information about the sitemap
# protocol see https://www.sitemaps.org
# This tag requires that the tag GENERATE_HTML is set to YES.

SITEMAP_URL            =

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location (absolute path
# including file name) of Qt's qhelpgenerator. If non-empty doxygen will try to
# run qhelpgenerator on the generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine tune the look of the index (see "Fine-tuning the output"). As an
# example, the default style sheet generated by doxygen has an example that
# shows how to put an image at the root of the tree instead of the PROJECT_NAME.
# Since the tree basically has the same information as the tab index, you could
# consider setting DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = NO

# When both GENERATE_TREEVIEW and DISABLE_INDEX are set to YES, then the
# FULL_SIDEBAR option determines if the side bar is limited to only the treeview
# area (value NO) or if it should extend to the full height of the window (value
# YES). Setting this to YES gives a layout similar to
# https://docs.readthedocs.io with more room for contents, but less room for the
# project logo, title, and description. If either GENERATE_TREEVIEW or
# DISABLE_INDEX is set to NO, this option has no effect.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

FULL_SIDEBAR           = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# If the OBFUSCATE_EMAILS tag is set to YES, doxygen will obfuscate email
# addresses.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

OBFUSCATE_EMAILS       = YES

# If the HTML_FORMULA_FORMAT option is set to svg, doxygen will use the pdf2svg
# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see
# https://inkscape.org) to generate formulas as SVG images instead of PNGs for
# the HTML output. These images will generally look nicer at scaled resolutions.
# Possible values are: png (the default) and svg (looks nicer but requires the
# pdf2svg or inkscape tool).
# The default value is: png.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FORMULA_FORMAT    = png

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
# to create new LaTeX commands to be used in formulas as building blocks. See
# the section "Including formulas" for details.

FORMULA_MACROFILE      =

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# https://www.mathjax.org) which uses client side JavaScript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# With MATHJAX_VERSION it is possible to specify the MathJax version to be used.
# Note that the different versions of MathJax have different requirements with
# regards to the different settings, so it is possible that also other MathJax
# settings have to be changed when switching between the different MathJax
# versions.
# Possible values are: MathJax_2 and MathJax_3.
# The default value is: MathJax_2.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_VERSION        = MathJax_2

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. For more details about the output format see MathJax
# version 2 (see:
# http://docs.mathjax.org/en/v2.7-latest/output.html) and MathJax version 3
# (see:
# http://docs.mathjax.org/en/latest/web/components/output.html).
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility. This is the name for Mathjax version 2, for MathJax version 3
# this will be translated into chtml), NativeMML (i.e. MathML. Only supported
# for NathJax 2. For MathJax version 3 chtml will be used instead.), chtml (This
# is the name for Mathjax version 3, for MathJax version 2 this will be
# translated into HTML-CSS) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from https://www.mathjax.org before deployment. The default value is:
# - in case of MathJax version 2: https://cdn.jsdelivr.net/npm/mathjax@2
# - in case of MathJax version 3: https://cdn.jsdelivr.net/npm/mathjax@3
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# for MathJax version 2 (see
# https://docs.mathjax.org/en/v2.7-latest/tex.html#tex-and-latex-extensions):
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# For example for MathJax version 3 (see
# http://docs.mathjax.org/en/latest/input/tex/extensions/index.html):
# MATHJAX_EXTENSIONS = ams
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see:
# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using JavaScript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/). See the section "External Indexing and Searching" for
# details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when not enabling USE_PDFLATEX the default is latex when enabling
# USE_PDFLATEX the default is pdflatex and when in the later case latex is
# chosen this is overwritten by pdflatex. For specific output languages the
# default can have been set differently, this depends on the implementation of
# the output language.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# Note: This tag is used in the Makefile / make.bat.
# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
# (.tex).
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
# generate index for LaTeX. In case there is no backslash (\) as first character
# it will be automatically added in the LaTeX code.
# Note: This tag is used in the generated output file (.tex).
# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
# The default value is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_MAKEINDEX_CMD    = makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a user-defined LaTeX header for
# the generated LaTeX document. The header should contain everything until the
# first chapter. If it is left blank doxygen will generate a standard header. It
# is highly recommended to start with a default header using
# doxygen -w latex new_header.tex new_footer.tex new_stylesheet.sty
# and then modify the file new_header.tex. See also section "Doxygen usage" for
# information on how to generate the default header that doxygen normally uses.
#
# Note: Only use a user-defined header if you know what you are doing!
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. The following
# commands have a special meaning inside the header (and footer): For a
# description of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a user-defined LaTeX footer for
# the generated LaTeX document. The footer should contain everything after the
# last chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer. See also section "Doxygen
# usage" for information on how to generate the default footer that doxygen
# normally uses. Note: Only use a user-defined footer if you know what you are
# doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use the engine as
# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX
# files. Set this option to YES, to get a higher quality PDF documentation.
#
# See also section LATEX_CMD_NAME for selecting the engine.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# The LATEX_BATCHMODE tag signals the behavior of LaTeX in case of an error.
# Possible values are: NO same as ERROR_STOP, YES same as BATCH, BATCH In batch
# mode nothing is printed on the terminal, errors are scrolled as if <return> is
# hit at every error; missing files that TeX tries to input or request from
# keyboard input (\read on a not open input stream) cause the job to abort,
# NON_STOP In nonstop mode the diagnostic message will appear on the terminal,
# but there is no possibility of user interaction just like in batch mode,
# SCROLL In scroll mode, TeX will stop only for missing files to input or if
# keyboard input is necessary and ERROR_STOP In errorstop mode, TeX will stop at
# each error, asking for user intervention.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
# path from which the emoji images will be read. If a relative path is entered,
# it will be relative to the LATEX_OUTPUT directory. If left blank the
# LATEX_OUTPUT directory will be used.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EMOJI_DIRECTORY  =

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's
# configuration file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's configuration file. A template extensions file can be
# generated using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
# namespace members in file scope as well, matching the HTML output.
# The default value is: NO.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_NS_MEMB_FILE_SCOPE = NO

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see https://autogen.sourceforge.net/) file that captures
# the structure of the code including all documentation. Note that this feature
# is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to Sqlite3 output
#---------------------------------------------------------------------------

# If the GENERATE_SQLITE3 tag is set to YES doxygen will generate a Sqlite3
# database with symbols found by doxygen stored in tables.
# The default value is: NO.

GENERATE_SQLITE3       = NO

# The SQLITE3_OUTPUT tag is used to specify where the Sqlite3 database will be
# put. If a relative path is entered the value of OUTPUT_DIRECTORY will be put
# in front of it.
# The default directory is: sqlite3.
# This tag requires that the tag GENERATE_SQLITE3 is set to YES.

SQLITE3_OUTPUT         = sqlite3

# The SQLITE3_OVERWRITE_DB tag is set to YES, the existing doxygen_sqlite3.db
# database file will be recreated with each doxygen run. If set to NO, doxygen
# will warn if an a database file is already found and not modify it.
# The default value is: YES.
# This tag requires that the tag GENERATE_SQLITE3 is set to YES.

SQLITE3_RECREATE_DB    = YES

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor. Note that the INCLUDE_PATH is not recursive, so the setting of
# RECURSIVE has no effect here.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             = __DOXYGEN__

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external classes and namespaces
# will be listed in the class and namespace index. If set to NO, only the
# inherited external classes will be listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the topic index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

#---------------------------------------------------------------------------
# Configuration options related to diagram generator tools
#---------------------------------------------------------------------------

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# https://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# DOT_COMMON_ATTR is common attributes for nodes, edges and labels of
# subgraphs. When you want a differently looking font in the dot files that
# doxygen generates you can specify fontname, fontcolor and fontsize attributes.
# For details please see <a href=https://graphviz.org/doc/info/attrs.html>Node,
# Edge and Graph Attributes specification</a> You need to make sure dot is able
# to find the font, which can be done by putting it in a standard location or by
# setting the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
# directory containing the font. Default graphviz fontsize is 14.
# The default value is: fontname=Helvetica,fontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_COMMON_ATTR        = "fontname=Helvetica,fontsize=10"

# DOT_EDGE_ATTR is concatenated with DOT_COMMON_ATTR. For elegant style you can
# add 'arrowhead=open, arrowtail=open, arrowsize=0.5'. <a
# href=https://graphviz.org/doc/info/arrows.html>Complete documentation about
# arrows shapes.</a>
# The default value is: labelfontname=Helvetica,labelfontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_EDGE_ATTR          = "labelfontname=Helvetica,labelfontsize=10"

# DOT_NODE_ATTR is concatenated with DOT_COMMON_ATTR. For view without boxes
# around nodes set 'shape=plain' or 'shape=plaintext' <a
# href=https://www.graphviz.org/doc/info/shapes.html>Shapes specification</a>
# The default value is: shape=box,height=0.2,width=0.4.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NODE_ATTR          = "shape=box,height=0.2,width=0.4"

# You can set the path where dot can find font specified with fontname in
# DOT_COMMON_ATTR and others dot attributes.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES or GRAPH or BUILTIN then doxygen will
# generate a graph for each documented class showing the direct and indirect
# inheritance relations. In case the CLASS_GRAPH tag is set to YES or GRAPH and
# HAVE_DOT is enabled as well, then dot will be used to draw the graph. In case
# the CLASS_GRAPH tag is set to YES and HAVE_DOT is disabled or if the
# CLASS_GRAPH tag is set to BUILTIN, then the built-in generator will be used.
# If the CLASS_GRAPH tag is set to TEXT the direct and indirect inheritance
# relations will be shown as texts / links.
# Possible values are: NO, YES, TEXT, GRAPH and BUILTIN.
# The default value is: YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes. Explicit enabling a collaboration graph,
# when COLLABORATION_GRAPH is set to NO, can be accomplished by means of the
# command \collaborationgraph. Disabling a collaboration graph can be
# accomplished by means of the command \hidecollaborationgraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies. Explicit enabling a group
# dependency graph, when GROUP_GRAPHS is set to NO, can be accomplished by means
# of the command \groupgraph. Disabling a directory graph can be accomplished by
# means of the command \hidegroupgraph. See also the chapter Grouping in the
# manual.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag UML_LOOK is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the DOT_UML_DETAILS tag is set to NO, doxygen will show attributes and
# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS
# tag is set to YES, doxygen will add type and arguments for attributes and
# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, doxygen
# will not generate fields with class member information in the UML graphs. The
# class diagrams will look similar to the default class diagrams but using UML
# notation for the relationships.
# Possible values are: NO, YES and NONE.
# The default value is: NO.
# This tag requires that the tag UML_LOOK is set to YES.

DOT_UML_DETAILS        = NO

# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters
# to display on a single line. If the actual line length exceeds this threshold
# significantly it will wrapped across multiple lines. Some heuristics are apply
# to avoid ugly line breaks.
# Minimum value: 0, maximum value: 1000, default value: 17.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_WRAP_THRESHOLD     = 17

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files. Explicit enabling an include graph, when INCLUDE_GRAPH is is set to NO,
# can be accomplished by means of the command \includegraph. Disabling an
# include graph can be accomplished by means of the command \hideincludegraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files. Explicit enabling an included by graph, when INCLUDED_BY_GRAPH is set
# to NO, can be accomplished by means of the command \includedbygraph. Disabling
# an included by graph can be accomplished by means of the command
# \hideincludedbygraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories. Explicit enabling a directory graph, when
# DIRECTORY_GRAPH is set to NO, can be accomplished by means of the command
# \directorygraph. Disabling a directory graph can be accomplished by means of
# the command \hidedirectorygraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DIR_GRAPH_MAX_DEPTH tag can be used to limit the maximum number of levels
# of child directories generated in directory dependency graphs by dot.
# Minimum value: 1, maximum value: 25, default value: 1.
# This tag requires that the tag DIRECTORY_GRAPH is set to YES.

DIR_GRAPH_MAX_DEPTH    = 1

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# https://www.graphviz.org/)).
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
# png:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file or to the filename of jar file
# to be used. If left blank, it is assumed PlantUML is not used or called during
# a preprocessing step. Doxygen will generate a warning when it encounters a
# \startuml command in this case and will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for plantuml.

PLANTUML_CFG_FILE      =

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# Note: This tag requires that UML_LOOK isn't set, i.e. the doxygen internal
# graphical representation for inheritance and collaboration diagrams is used.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate
# files that are used to generate the various graphs.
#
# Note: This setting is not only used for dot files but also for msc temporary
# files.
# The default value is: YES.

DOT_CLEANUP            = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. If the MSCGEN_TOOL tag is left empty (the default), then doxygen will
# use a built-in version of mscgen tool to produce the charts. Alternatively,
# the MSCGEN_TOOL tag can also specify the name an external tool. For instance,
# specifying prog as the value, doxygen will call the tool as prog -T
# <outfile_format> -o <outputfile> <inputfile>. The external tool should support
# output file formats "png", "eps", "svg", and "ismap".

MSCGEN_TOOL            =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

```

`examples/asio_service.cpp`:

```cpp
/*!
    \file asio_service.cpp
    \brief Asio service example
    \author Ivan Shynkarenka
    \date 15.01.2017
    \copyright MIT License
*/

#include "asio_service.h"

#include "threads/thread.h"

#include <iostream>

int main(int argc, char** argv)
{
    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Dispatch
    std::cout << "1 - Dispatch from the main thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
    service->Dispatch([service]()
    {
        std::cout << "1.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;

        std::cout << "1.2 - Dispatch from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Dispatch([service]()
        {
            std::cout << "1.2.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });

        std::cout << "1.3 - Post from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Post([service]()
        {
            std::cout << "1.3.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });
    });

    // Post
    std::cout << "2 - Post from the main thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
    service->Post([service]()
    {
        std::cout << "2.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;

        std::cout << "2.2 - Dispatch from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Dispatch([service]()
        {
            std::cout << "2.2.1 - Dispatched in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });

        std::cout << "2.3 - Post from thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        service->Post([service]()
        {
            std::cout << "2.3.1 - Posted in thread with Id " << CppCommon::Thread::CurrentThreadId() << std::endl;
        });
    });

    // Wait for a while...
    CppCommon::Thread::Sleep(1000);

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/asio_service.h`:

```h
/*!
    \file asio_service.h
    \brief Asio service example
    \author Ivan Shynkarenka
    \date 15.01.2017
    \copyright MIT License
*/

#include "server/asio/service.h"

class AsioService : public CppServer::Asio::Service
{
public:
    using CppServer::Asio::Service::Service;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Asio service caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

```

`examples/asio_timer.cpp`:

```cpp
/*!
    \file asio_timer.cpp
    \brief Asio timer example
    \author Ivan Shynkarenka
    \date 16.08.2018
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/timer.h"
#include "threads/thread.h"

#include <iostream>

class AsioTimer : public CppServer::Asio::Timer
{
public:
    using CppServer::Asio::Timer::Timer;

protected:
    void onTimer(bool canceled) override
    {
        std::cout << "Asio timer " << (canceled ? "canceled" : "expired") << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Asio timer caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new Asio timer
    auto timer = std::make_shared<AsioTimer>(service);

    // Setup and synchronously wait for the timer
    timer->Setup(CppCommon::UtcTime() + CppCommon::Timespan::seconds(1));
    timer->WaitSync();

    // Setup and asynchronously wait for the timer
    timer->Setup(CppCommon::Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    CppCommon::Thread::Sleep(2000);

    // Setup and asynchronously wait for the timer
    timer->Setup(CppCommon::Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    CppCommon::Thread::Sleep(500);

    // Cancel the timer
    timer->Cancel();

    // Wait for a while...
    CppCommon::Thread::Sleep(500);

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/http_client.cpp`:

```cpp
/*!
    \file http_client.cpp
    \brief HTTP client example
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/http/http_client.h"
#include "string/string_utils.h"

#include <iostream>

int main(int argc, char** argv)
{
    // HTTP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];
    // HTTP server port
    int port = 8080;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "HTTP server address: " << address << std::endl;
    std::cout << "HTTP server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new HTTP client
    auto client = std::make_shared<CppServer::HTTP::HTTPClientEx>(service, address, port);

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    try
    {
        // Perform text input
        std::string line;
        while (getline(std::cin, line))
        {
            if (line.empty())
                break;

            // Reconnect the client
            if (line == "!")
            {
                std::cout << "Client reconnecting...";
                client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
                std::cout << "Done!" << std::endl;
                continue;
            }

            auto commands = CppCommon::StringUtils::Split(line, ' ', true);
            if (commands.size() < 2)
            {
                std::cout << "HTTP method and URL must be entered!" << std::endl;
                continue;
            }

            if (CppCommon::StringUtils::ToUpper(commands[0]) == "HEAD")
            {
                auto response = client->SendHeadRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "GET")
            {
                auto response = client->SendGetRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "POST")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPostRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "PUT")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPutRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "DELETE")
            {
                auto response = client->SendDeleteRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "OPTIONS")
            {
                auto response = client->SendOptionsRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "TRACE")
            {
                auto response = client->SendTraceRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else
                std::cout << "Unknown HTTP method: " << commands[0] << std::endl;
        }
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << std::endl;
    }

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/http_server.cpp`:

```cpp
/*!
    \file http_server.cpp
    \brief HTTP server example
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/http/http_server.h"
#include "string/string_utils.h"
#include "utility/singleton.h"

#include <iostream>
#include <map>
#include <mutex>

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPCacheSession : public CppServer::HTTP::HTTPSession
{
public:
    using CppServer::HTTP::HTTPSession::HTTPSession;

protected:
    void onReceivedRequest(const CppServer::HTTP::HTTPRequest& request) override
    {
        // Show HTTP request content
        std::cout << std::endl << request;

        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const CppServer::HTTP::HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPCacheServer : public CppServer::HTTP::HTTPServer
{
public:
    using CppServer::HTTP::HTTPServer::HTTPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<HTTPCacheSession>(std::dynamic_pointer_cast<CppServer::HTTP::HTTPServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // HTTP server port
    int port = 8080;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // HTTP server content path
    std::string www = "../www/api";
    if (argc > 2)
        www = argv[2];

    std::cout << "HTTP server port: " << port << std::endl;
    std::cout << "HTTP server static content path: " << www << std::endl;
    std::cout << "HTTP server website: " << "http://localhost:" << port << "/api/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new HTTP server
    auto server = std::make_shared<HTTPCacheServer>(service, port);
    server->AddStaticContent(www, "/api");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/https_client.cpp`:

```cpp
/*!
    \file https_client.cpp
    \brief HTTPS client example
    \author Ivan Shynkarenka
    \date 12.02.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/http/https_client.h"
#include "string/string_utils.h"

#include <iostream>

int main(int argc, char** argv)
{
    // HTTP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];
    // HTTP server port
    int port = 8443;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "HTTPS server address: " << address << std::endl;
    std::cout << "HTTPS server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new HTTP client
    auto client = std::make_shared<CppServer::HTTP::HTTPSClientEx>(service, context, address, port);

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    try
    {
        // Perform text input
        std::string line;
        while (getline(std::cin, line))
        {
            if (line.empty())
                break;

            // Reconnect the client
            if (line == "!")
            {
                std::cout << "Client reconnecting...";
                client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
                std::cout << "Done!" << std::endl;
                continue;
            }

            auto commands = CppCommon::StringUtils::Split(line, ' ', true);
            if (commands.size() < 2)
            {
                std::cout << "HTTP method and URL must be entered!" << std::endl;
                continue;
            }

            if (CppCommon::StringUtils::ToUpper(commands[0]) == "HEAD")
            {
                auto response = client->SendHeadRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "GET")
            {
                auto response = client->SendGetRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "POST")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPostRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "PUT")
            {
                if (commands.size() < 3)
                {
                    std::cout << "HTTP method, URL and body must be entered!" << std::endl;
                    continue;
                }
                auto response = client->SendPutRequest(commands[1], commands[2]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "DELETE")
            {
                auto response = client->SendDeleteRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "OPTIONS")
            {
                auto response = client->SendOptionsRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else if (CppCommon::StringUtils::ToUpper(commands[0]) == "TRACE")
            {
                auto response = client->SendTraceRequest(commands[1]).get();
                std::cout << response << std::endl;
            }
            else
                std::cout << "Unknown HTTP method: " << commands[0] << std::endl;
        }
    }
    catch (const std::exception& ex)
    {
        std::cerr << ex.what() << std::endl;
    }

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/https_server.cpp`:

```cpp
/*!
    \file https_server.cpp
    \brief HTTPS server example
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/http/https_server.h"
#include "string/string_utils.h"
#include "utility/singleton.h"

#include <iostream>
#include <map>
#include <mutex>

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPSCacheSession : public CppServer::HTTP::HTTPSSession
{
public:
    using CppServer::HTTP::HTTPSSession::HTTPSSession;

protected:
    void onReceivedRequest(const CppServer::HTTP::HTTPRequest& request) override
    {
        // Show HTTP request content
        std::cout << std::endl << request;

        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const CppServer::HTTP::HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPSCacheServer : public CppServer::HTTP::HTTPSServer
{
public:
    using CppServer::HTTP::HTTPSServer::HTTPSServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(const std::shared_ptr<CppServer::Asio::SSLServer>& server) override
    {
        return std::make_shared<HTTPSCacheSession>(std::dynamic_pointer_cast<CppServer::HTTP::HTTPSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // HTTPS server port
    int port = 8443;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // HTTPS server content path
    std::string www = "../www/api";
    if (argc > 2)
        www = argv[2];

    std::cout << "HTTPS server port: " << port << std::endl;
    std::cout << "HTTPS server static content path: " << www << std::endl;
    std::cout << "HTTPS server website: " << "https://localhost:" << port << "/api/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new HTTPS server
    auto server = std::make_shared<HTTPSCacheServer>(service, context, port);
    server->AddStaticContent(www, "/api");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/proto_client.cpp`:

```cpp
/*!
    \file proto_client.cpp
    \brief Simple protocol client example
    \author Ivan Shynkarenka
    \date 05.01.2022
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/tcp_client.h"
#include "string/format.h"
#include "threads/thread.h"

#include "../proto/simple_protocol.h"

#include <atomic>
#include <iostream>

class SimpleProtoClient : public CppServer::Asio::TCPClient, public FBE::simple::Client
{
public:
    using CppServer::Asio::TCPClient::TCPClient;

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Simple protocol client connected a new session with Id " << id() << std::endl;

        // Reset FBE protocol buffers
        reset();
    }

    void onDisconnected() override
    {
        std::cout << "Simple protocol client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol handlers
    void onReceive(const ::simple::DisconnectRequest& request) override { Client::onReceive(request); std::cout << "Received: " << request << std::endl; DisconnectAsync(); }
    void onReceive(const ::simple::SimpleResponse& response) override { Client::onReceive(response); std::cout << "Received: " << response << std::endl; }
    void onReceive(const ::simple::SimpleReject& reject) override { Client::onReceive(reject); std::cout << "Received: " << reject << std::endl; }
    void onReceive(const ::simple::SimpleNotify& notify) override { Client::onReceive(notify); std::cout << "Received: " << notify << std::endl; }

    // Protocol implementation
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // Simple protocol server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // Simple protocol server port
    int port = 4444;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "Simple protocol server address: " << address << std::endl;
    std::cout << "Simple protocol server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new simple protocol client
    auto client = std::make_shared<SimpleProtoClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send request to the simple protocol server
        simple::SimpleRequest request;
        request.Message = line;
        auto response = client->request(request).get();

        // Show string hash calculation result
        std::cout << "Hash of '" << line << "' = " << CppCommon::format("0x{:08X}", response.Hash) << std::endl;
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/proto_server.cpp`:

```cpp
/*!
    \file proto_server.cpp
    \brief Simple protocol server example
    \author Ivan Shynkarenka
    \date 05.01.2022
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/tcp_server.h"

#include "../proto/simple_protocol.h"

#include <iostream>

class SimpleProtoSession : public CppServer::Asio::TCPSession, public FBE::simple::Sender, public FBE::simple::Receiver
{
public:
    using CppServer::Asio::TCPSession::TCPSession;

protected:
    void onConnected() override
    {
        std::cout << "Simple protocol session with Id " << id() << " connected!" << std::endl;

        // Send invite notification
        simple::SimpleNotify notify;
        notify.Notification = "Hello from Simple protocol server! Please send a message or '!' to disconnect the client!";
        send(notify);
    }

    void onDisconnected() override
    {
        std::cout << "Simple protocol session with Id " << id() << " disconnected!" << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol handlers
    void onReceive(const ::simple::DisconnectRequest& request) override { Disconnect(); }
    void onReceive(const ::simple::SimpleRequest& request) override
    {
        std::cout << "Received: " << request << std::endl;

        // Validate request
        if (request.Message.empty())
        {
            // Send reject
            simple::SimpleReject reject;
            reject.id = request.id;
            reject.Error = "Request message is empty!";
            send(reject);
            return;
        }

        static std::hash<std::string> hasher;

        // Send response
        simple::SimpleResponse response;
        response.id = request.id;
        response.Hash = (uint32_t)hasher(request.Message);
        response.Length = (uint32_t)request.Message.size();
        send(response);
    }

    // Protocol implementation
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }
};

class SimpleProtoServer : public CppServer::Asio::TCPServer, public FBE::simple::Sender
{
public:
    using CppServer::Asio::TCPServer::TCPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<SimpleProtoSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Simple protocol server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

    // Protocol implementation
    size_t onSend(const void* data, size_t size) override { Multicast(data, size); return size; }
};

int main(int argc, char** argv)
{
    // Simple protocol server port
    int port = 4444;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "Simple protocol server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new simple protocol server
    auto server = std::make_shared<SimpleProtoServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin notification to all sessions
        simple::SimpleNotify notify;
        notify.Notification = "(admin) " + line;
        server->send(notify);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/ssl_chat_client.cpp`:

```cpp
/*!
    \file ssl_chat_client.cpp
    \brief SSL chat client example
    \author Ivan Shynkarenka
    \date 01.01.2017
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/ssl_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::Asio::SSLClient
{
public:
    using CppServer::Asio::SSLClient::SSLClient;

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Chat SSL client connected a new session with Id " << id() << std::endl;
    }

    void onHandshaked() override
    {
        std::cout << "Chat SSL client handshaked a new session with Id " << id() << std::endl;
    }

    void onDisconnected() override
    {
        std::cout << "Chat SSL client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat SSL client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // SSL server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // SSL server port
    int port = 2222;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "SSL server address: " << address << std::endl;
    std::cout << "SSL server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new SSL chat client
    auto client = std::make_shared<ChatClient>(service, context, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/ssl_chat_server.cpp`:

```cpp
/*!
    \file ssl_chat_server.cpp
    \brief SSL chat server example
    \author Ivan Shynkarenka
    \date 30.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/ssl_server.h"

#include <iostream>

class ChatSession : public CppServer::Asio::SSLSession
{
public:
    using CppServer::Asio::SSLSession::SSLSession;

protected:
    void onConnected() override
    {
        std::cout << "Chat SSL session with Id " << id() << " connected!" << std::endl;
    }

    void onHandshaked() override
    {
        std::cout << "Chat SSL session with Id " << id() << " handshaked!" << std::endl;

        // Send invite message
        std::string message("Hello from SSL chat! Please send a message or '!' to disconnect the client!");
        SendAsync(message.data(), message.size());
    }

    void onDisconnected() override
    {
        std::cout << "Chat SSL session with Id " << id() << " disconnected!" << std::endl;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        server()->Multicast(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Disconnect();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat SSL session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::Asio::SSLServer
{
public:
    using CppServer::Asio::SSLServer::SSLServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(const std::shared_ptr<CppServer::Asio::SSLServer>& server) override
    {
        return std::make_shared<ChatSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // SSL server port
    int port = 2222;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "SSL server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new SSL chat server
    auto server = std::make_shared<ChatServer>(service, context, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->Multicast(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/tcp_chat_client.cpp`:

```cpp
/*!
    \file tcp_chat_client.cpp
    \brief TCP chat client example
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/tcp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::Asio::TCPClient
{
public:
    using CppServer::Asio::TCPClient::TCPClient;

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Chat TCP client connected a new session with Id " << id() << std::endl;
    }

    void onDisconnected() override
    {
        std::cout << "Chat TCP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // TCP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // TCP server port
    int port = 1111;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "TCP server address: " << address << std::endl;
    std::cout << "TCP server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new TCP chat client
    auto client = std::make_shared<ChatClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/tcp_chat_server.cpp`:

```cpp
/*!
    \file tcp_chat_server.cpp
    \brief TCP chat server example
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/tcp_server.h"

#include <iostream>

class ChatSession : public CppServer::Asio::TCPSession
{
public:
    using CppServer::Asio::TCPSession::TCPSession;

protected:
    void onConnected() override
    {
        std::cout << "Chat TCP session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from TCP chat! Please send a message or '!' to disconnect the client!");
        SendAsync(message);
    }

    void onDisconnected() override
    {
        std::cout << "Chat TCP session with Id " << id() << " disconnected!" << std::endl;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        server()->Multicast(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Disconnect();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::Asio::TCPServer
{
public:
    using CppServer::Asio::TCPServer::TCPServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<ChatSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // TCP server port
    int port = 1111;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "TCP server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new TCP chat server
    auto server = std::make_shared<ChatServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->Multicast(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/udp_echo_client.cpp`:

```cpp
/*!
    \file udp_echo_client.cpp
    \brief UDP echo client example
    \author Ivan Shynkarenka
    \date 23.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/udp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class EchoClient : public CppServer::Asio::UDPClient
{
public:
    using CppServer::Asio::UDPClient::UDPClient;

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Echo UDP client connected a new session with Id " << id() << std::endl;

        // Start receive datagrams
        ReceiveAsync();
    }

    void onDisconnected() override
    {
        std::cout << "Echo UDP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;

        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Echo UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // UDP server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // UDP server port
    int port = 3333;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "UDP server address: " << address << std::endl;
    std::cout << "UDP server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP echo client
    auto client = std::make_shared<EchoClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the echo server
        client->Send(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/udp_echo_server.cpp`:

```cpp
/*!
    \file udp_echo_server.cpp
    \brief UDP echo server example
    \author Ivan Shynkarenka
    \date 22.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/udp_server.h"

#include <iostream>

class EchoServer : public CppServer::Asio::UDPServer
{
public:
    using CppServer::Asio::UDPServer::UDPServer;

protected:
    void onStarted() override
    {
        // Start receive datagrams
        ReceiveAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Echo the message back to the sender
        SendAsync(endpoint, message);
    }

    void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) override
    {
        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Echo UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // UDP server port
    int port = 3333;
    if (argc > 1)
        port = std::atoi(argv[1]);

    std::cout << "UDP server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP echo server
    auto server = std::make_shared<EchoServer>(service, port);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/udp_multicast_client.cpp`:

```cpp
/*!
    \file udp_multicast_client.cpp
    \brief UDP multicast client example
    \author Ivan Shynkarenka
    \date 27.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/udp_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class MulticastClient : public CppServer::Asio::UDPClient
{
public:
    MulticastClient(const std::shared_ptr<CppServer::Asio::Service>& service, const std::string& address, const std::string& multicast, int port)
        : CppServer::Asio::UDPClient(service, address, port),
          _multicast(multicast)
    {
    }

    void DisconnectAndStop()
    {
        _stop = true;
        DisconnectAsync();
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onConnected() override
    {
        std::cout << "Multicast UDP client connected a new session with Id " << id() << std::endl;

        // Join UDP multicast group
        JoinMulticastGroup(_multicast);

        // Start receive datagrams
        ReceiveAsync();
    }

    void onDisconnected() override
    {
        std::cout << "Multicast UDP client disconnected a session with Id " << id() << std::endl;

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;

        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Multicast UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
    std::string _multicast;
};

int main(int argc, char** argv)
{
    // UDP listen address
    std::string listen_address = "0.0.0.0";
    if (argc > 1)
        listen_address = argv[1];

    // UDP multicast address
    std::string multicast_address = "239.255.0.1";
    if (argc > 2)
        multicast_address = argv[2];

    // UDP multicast port
    int multicast_port = 3334;
    if (argc > 3)
        multicast_port = std::atoi(argv[3]);

    std::cout << "UDP listen address: " << listen_address << std::endl;
    std::cout << "UDP multicast address: " << multicast_address << std::endl;
    std::cout << "UDP multicast port: " << multicast_port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP multicast client
    auto client = std::make_shared<MulticastClient>(service, listen_address, multicast_address, multicast_port);
    client->SetupMulticast(true);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/udp_multicast_server.cpp`:

```cpp
/*!
    \file udp_multicast_server.cpp
    \brief UDP multicast server example
    \author Ivan Shynkarenka
    \date 27.12.2016
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/asio/udp_server.h"

#include <iostream>

class MulticastServer : public CppServer::Asio::UDPServer
{
public:
    using CppServer::Asio::UDPServer::UDPServer;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Multicast UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // UDP multicast address
    std::string multicast_address = "239.255.0.1";
    if (argc > 1)
        multicast_address = argv[1];

    // UDP multicast port
    int multicast_port = 3334;
    if (argc > 2)
        multicast_port = std::atoi(argv[2]);

    std::cout << "UDP multicast address: " << multicast_address << std::endl;
    std::cout << "UDP multicast port: " << multicast_port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new UDP multicast server
    auto server = std::make_shared<MulticastServer>(service, 0);

    // Start the multicast server
    std::cout << "Server starting...";
    server->Start(multicast_address, multicast_port);
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->Multicast(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/ws_chat_client.cpp`:

```cpp
/*!
    \file ws_chat_client.cpp
    \brief WebSocket chat client example
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/ws/ws_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::WS::WSClient
{
public:
    using CppServer::WS::WSClient::WSClient;

    void DisconnectAndStop()
    {
        _stop = true;
        CloseAsync(1000);
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "http://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        std::cout << "Chat WebSocket client connected a new session with Id " << id() << std::endl;
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket client disconnected a session with Id " << id() << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onDisconnected() override
    {
        WSClient::onDisconnected();

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // WebSocket server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // WebSocket server port
    int port = 8080;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "WebSocket server address: " << address << std::endl;
    std::cout << "WebSocket server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new WebSocket chat client
    auto client = std::make_shared<ChatClient>(service, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendTextAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/ws_chat_server.cpp`:

```cpp
/*!
    \file ws_chat_server.cpp
    \brief WebSocket chat server example
    \author Ivan Shynkarenka
    \date 28.05.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/ws/ws_server.h"

#include <iostream>

class ChatSession : public CppServer::WS::WSSession
{
public:
    using CppServer::WS::WSSession::WSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override
    {
        std::cout << "Chat WebSocket session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from WebSocket chat! Please send a message or '!' to disconnect the client!");
        SendTextAsync(message);
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket session with Id " << id() << " disconnected!" << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        std::dynamic_pointer_cast<CppServer::WS::WSServer>(server())->MulticastText(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Close();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::WS::WSServer
{
public:
    using CppServer::WS::WSServer::WSServer;

protected:
    std::shared_ptr<CppServer::Asio::TCPSession> CreateSession(const std::shared_ptr<CppServer::Asio::TCPServer>& server) override
    {
        return std::make_shared<ChatSession>(std::dynamic_pointer_cast<CppServer::WS::WSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // WebSocket server port
    int port = 8080;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // WebSocket server content path
    std::string www = "../www/ws";
    if (argc > 2)
        www = argv[2];

    std::cout << "WebSocket server port: " << port << std::endl;
    std::cout << "WebSocket server static content path: " << www << std::endl;
    std::cout << "WebSocket server website: " << "http://localhost:" << port << "/chat/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new WebSocket chat server
    auto server = std::make_shared<ChatServer>(service, port);
    server->AddStaticContent(www, "/chat");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->MulticastText(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/wss_chat_client.cpp`:

```cpp
/*!
    \file wss_chat_client.cpp
    \brief WebSocket secure chat client example
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/ws/wss_client.h"
#include "threads/thread.h"

#include <atomic>
#include <iostream>

class ChatClient : public CppServer::WS::WSSClient
{
public:
    using CppServer::WS::WSSClient::WSSClient;

    void DisconnectAndStop()
    {
        _stop = true;
        CloseAsync(1000);
        while (IsConnected())
            CppCommon::Thread::Yield();
    }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "https://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        std::cout << "Chat WebSocket secure client connected a new session with Id " << id() << std::endl;
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket secure client disconnected a session with Id " << id() << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::cout << "Incoming: " << std::string((const char*)buffer, size) << std::endl;
    }

    void onDisconnected() override
    {
        WSSClient::onDisconnected();

        // Wait for a while...
        CppCommon::Thread::Sleep(1000);

        // Try to connect again
        if (!_stop)
            ConnectAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

private:
    std::atomic<bool> _stop{false};
};

int main(int argc, char** argv)
{
    // WebSocket server address
    std::string address = "127.0.0.1";
    if (argc > 1)
        address = argv[1];

    // WebSocket server port
    int port = 8443;
    if (argc > 2)
        port = std::atoi(argv[2]);

    std::cout << "WebSocket secure server address: " << address << std::endl;
    std::cout << "WebSocket secure server port: " << port << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create a new WebSocket chat client
    auto client = std::make_shared<ChatClient>(service, context, address, port);

    // Connect the client
    std::cout << "Client connecting...";
    client->ConnectAsync();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the client or '!' to reconnect the client..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Reconnect the client
        if (line == "!")
        {
            std::cout << "Client reconnecting...";
            client->IsConnected() ? client->ReconnectAsync() : client->ConnectAsync();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Send the entered text to the chat server
        client->SendTextAsync(line);
    }

    // Disconnect the client
    std::cout << "Client disconnecting...";
    client->DisconnectAndStop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`examples/wss_chat_server.cpp`:

```cpp
/*!
    \file wss_chat_server.cpp
    \brief WebSocket secure chat server example
    \author Ivan Shynkarenka
    \date 28.05.2019
    \copyright MIT License
*/

#include "asio_service.h"

#include "server/ws/wss_server.h"

#include <iostream>

class ChatSession : public CppServer::WS::WSSSession
{
public:
    using CppServer::WS::WSSSession::WSSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override
    {
        std::cout << "Chat WebSocket secure session with Id " << id() << " connected!" << std::endl;

        // Send invite message
        std::string message("Hello from WebSocket secure chat! Please send a message or '!' to disconnect the client!");
        SendTextAsync(message);
    }

    void onWSDisconnected() override
    {
        std::cout << "Chat WebSocket secure session with Id " << id() << " disconnected!" << std::endl;
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        std::string message((const char*)buffer, size);
        std::cout << "Incoming: " << message << std::endl;

        // Multicast message to all connected sessions
        std::dynamic_pointer_cast<CppServer::WS::WSSServer>(server())->MulticastText(message);

        // If the buffer starts with '!' the disconnect the current session
        if (message == "!")
            Close();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class ChatServer : public CppServer::WS::WSSServer
{
public:
    using CppServer::WS::WSSServer::WSSServer;

protected:
    std::shared_ptr<CppServer::Asio::SSLSession> CreateSession(const std::shared_ptr<CppServer::Asio::SSLServer>& server) override
    {
        return std::make_shared<ChatSession>(std::dynamic_pointer_cast<CppServer::WS::WSSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Chat WebSocket secure server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    // WebSocket secure server port
    int port = 8443;
    if (argc > 1)
        port = std::atoi(argv[1]);
    // WebSocket secure server content path
    std::string www = "../www/wss";
    if (argc > 2)
        www = argv[2];

    std::cout << "WebSocket secure server port: " << port << std::endl;
    std::cout << "WebSocket secure server static content path: " << www << std::endl;
    std::cout << "WebSocket server website: " << "https://localhost:" << port << "/chat/index.html" << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<AsioService>();

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new WebSocket secure chat server
    auto server = std::make_shared<ChatServer>(service, context, port);
    server->AddStaticContent(www, "/chat");

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }

        // Multicast admin message to all sessions
        line = "(admin) " + line;
        server->MulticastText(line);
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`include/server/asio/asio.h`:

```h
/*!
    \file asio.h
    \brief Asio C++ Library definition
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_H
#define CPPSERVER_ASIO_H

#include <iostream>

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#if defined(__CYGWIN__)

#include <boost/asio.hpp>
#include <boost/asio/ssl.hpp>

#else

#define ASIO_STANDALONE
#define ASIO_SEPARATE_COMPILATION
#define ASIO_NO_WIN32_LEAN_AND_MEAN

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable: 4459) // C4459: declaration of 'identifier' hides global declaration
#endif

#include <asio.hpp>
#include <asio/ssl.hpp>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#if defined(_WIN32) || defined(_WIN64)
#undef DELETE
#undef ERROR
#undef Yield
#undef min
#undef max
#undef uuid_t
#endif

#endif

namespace CppServer {

/*!
    \namespace CppServer::Asio
    \brief Asio definitions
*/
namespace Asio {

//! Internet protocol
enum class InternetProtocol
{
    IPv4,               //!< Internet Protocol version 4
    IPv6                //!< Internet Protocol version 6
};

//! Stream output: Internet protocol
/*!
    \param stream - Output stream
    \param protocol - Internet protocol
    \return Output stream
*/
template <class TOutputStream>
TOutputStream& operator<<(TOutputStream& stream, InternetProtocol protocol);

} // namespace Asio
} // namespace CppServer

#include "asio.inl"

#endif // CPPSERVER_ASIO_H

```

`include/server/asio/asio.inl`:

```inl
/*!
    \file asio.inl
    \brief Asio C++ Library inline implementation
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

namespace CppServer {
namespace Asio {

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, InternetProtocol protocol)
{
    switch (protocol)
    {
        case InternetProtocol::IPv4:
            stream << "IPv4";
            break;
        case InternetProtocol::IPv6:
            stream << "IPv6";
            break;
        default:
            stream << "<unknown>";
            break;
    }
    return stream;
}

} // namespace Asio
} // namespace CppServer

```

`include/server/asio/memory.h`:

```h
/*!
    \file memory.h
    \brief Asio memory manager definition
    \author Ivan Shynkarenka
    \date 16.02.2018
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_MEMORY_H
#define CPPSERVER_ASIO_MEMORY_H

#include <memory>

namespace CppServer {
namespace Asio {

//! Asio handler storage
/*!
    Class to manage the memory to be used for handler-based custom allocation.
    It contains a single block of memory which may be returned for allocation
    requests. If the memory is in use when an allocation request is made, the
    allocator delegates allocation to the global heap.

    Not thread-safe.
*/
class HandlerStorage
{
public:
    HandlerStorage() noexcept : _in_use(false) {}
    HandlerStorage(const HandlerStorage&) = delete;
    HandlerStorage(HandlerStorage&&) = delete;
    ~HandlerStorage() noexcept = default;

    HandlerStorage& operator=(const HandlerStorage&) = delete;
    HandlerStorage& operator=(HandlerStorage&&) = delete;

    //! Allocate memory buffer
    /*!
        \param size - Size of allocated block in bytes
        \return Pointer to the allocated buffer
    */
    void* allocate(size_t size);
    //! Deallocate memory buffer
    /*!
        \param ptr - Pointer to the allocated buffer
    */
    void deallocate(void* ptr);

private:
    // Whether the handler-based custom allocation storage has been used
    bool _in_use;
    // Storage space used for handler-based custom memory allocation
    std::byte _storage[1024];
};

//! Asio handler allocator
/*!
    The allocator to be associated with the handler objects. This allocator only
    needs to satisfy the C++11 minimal allocator requirements.

    Not thread-safe.
*/
template <typename T>
class HandlerAllocator
{
    template <typename>
    friend class HandlerAllocator;

public:
    //! Element type
    typedef T value_type;
    //! Pointer to element
    typedef T* pointer;
    //! Reference to element
    typedef T& reference;
    //! Pointer to constant element
    typedef const T* const_pointer;
    //! Reference to constant element
    typedef const T& const_reference;
    //! Quantities of elements
    typedef size_t size_type;
    //! Difference between two pointers
    typedef ptrdiff_t difference_type;

    //! Initialize allocator with a given memory storage
    /*!
        \param storage - Memory storage
    */
    explicit HandlerAllocator(HandlerStorage& storage) noexcept : _storage(storage) {}
    template <typename U>
    HandlerAllocator(const HandlerAllocator<U>& alloc) noexcept : _storage(alloc._storage) {}
    HandlerAllocator(const HandlerAllocator& alloc) noexcept : _storage(alloc._storage) {}
    HandlerAllocator(HandlerAllocator&&) noexcept = default;
    ~HandlerAllocator() noexcept = default;

    template <typename U>
    HandlerAllocator& operator=(const HandlerAllocator<U>& alloc) noexcept
    { _storage = alloc._storage; return *this; }
    HandlerAllocator& operator=(const HandlerAllocator& alloc) noexcept
    { _storage = alloc._storage; return *this; }
    HandlerAllocator& operator=(HandlerAllocator&&) noexcept = default;

    //! Allocate a block of storage suitable to contain the given count of elements
    /*!
        \param num - Number of elements to be allocated
        \param hint - Allocation hint (default is 0)
        \return A pointer to the initial element in the block of storage
    */
    pointer allocate(size_type num, const void* hint = 0) { return (pointer)_storage.allocate(num * sizeof(T)); }
    //! Release a block of storage previously allocated
    /*!
        \param ptr - Pointer to a block of storage
        \param num - Number of releasing elements
    */
    void deallocate(pointer ptr, size_type num) { return _storage.deallocate(ptr); }

private:
    // The underlying handler storage
    HandlerStorage& _storage;
};

//! Asio allocate handler wrapper
/*!
    Wrapper class template for handler objects to allow handler memory
    allocation to be customised. The allocator_type type and get_allocator()
    member function are used by the asynchronous operations to obtain the
    allocator. Calls to operator() are forwarded to the encapsulated handler.

    Not thread-safe.
*/
template <typename THandler>
class AllocateHandler
{
public:
    //! Allocator type
    typedef HandlerAllocator<THandler> allocator_type;

    //! Initialize allocate handler wrapper with a given memory storage and handler
    /*!
        \param storage - Memory storage
        \param handler - Handler to allocate
    */
    AllocateHandler(HandlerStorage& storage, THandler handler) noexcept : _storage(storage), _handler(handler) {}
    AllocateHandler(const AllocateHandler&) noexcept = default;
    AllocateHandler(AllocateHandler&&) noexcept = default;
    ~AllocateHandler() noexcept = default;

    AllocateHandler& operator=(const AllocateHandler&) noexcept = default;
    AllocateHandler& operator=(AllocateHandler&&) noexcept = default;

    //! Get the handler allocator
    allocator_type get_allocator() const noexcept { return allocator_type(_storage); }

    //! Wrap the handler
    template <typename ...Args>
    void operator()(Args&&... args) { _handler(std::forward<Args>(args)...); }

private:
    HandlerStorage& _storage;
    THandler _handler;
};

//! Helper function to wrap a handler object to add custom allocation
/*!
    \param storage - Memory storage
    \param handler - Handler to allocate
*/
template <typename THandler>
AllocateHandler<THandler> make_alloc_handler(HandlerStorage& storage, THandler handler);

} // namespace Asio
} // namespace CppServer

#include "memory.inl"

#endif // CPPSERVER_ASIO_MEMORY_H

```

`include/server/asio/memory.inl`:

```inl
/*!
    \file memory.inl
    \brief Asio memory manager inline implementation
    \author Ivan Shynkarenka
    \date 16.02.2018
    \copyright MIT License
*/

namespace CppServer {
namespace Asio {

inline void* HandlerStorage::allocate(size_t size)
{
    // Check if the storage is not already used and has enough capacity
    if (!_in_use && (size < sizeof(_storage)))
    {
        _in_use = true;
        return &_storage;
    }

    // Otherwise allocate memory in the heap
    return ::operator new(size);
}

inline void HandlerStorage::deallocate(void* ptr)
{
    // Free storage if memory block was allocated from it
    if (ptr == &_storage)
    {
        _in_use = false;
        return;
    }

    // Otherwise free memory in the heap
    ::operator delete(ptr);
}

template <typename THandler>
inline AllocateHandler<THandler> make_alloc_handler(HandlerStorage& storage, THandler handler)
{
    return AllocateHandler<THandler>(storage, handler);
}

} // namespace Asio
} // namespace CppServer

```

`include/server/asio/service.h`:

```h
/*!
    \file service.h
    \brief Asio service definition
    \author Ivan Shynkarenka
    \date 16.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_SERVICE_H
#define CPPSERVER_ASIO_SERVICE_H

#include "asio.h"
#include "memory.h"

#include "threads/thread.h"

#include <atomic>
#include <cassert>
#include <memory>
#include <string>
#include <string_view>
#include <vector>

namespace CppServer {
namespace Asio {

//! Asio service
/*!
    Asio service is used to host all clients/servers based on Asio C++ library.
    It is implemented based on Asio C++ Library and use one or more threads to
    perform all asynchronous IO operations and communications.

    There are three ways to initialize Asio service:

    1) Service(threads, false) - initialize a new Asio service with io-service-
    per-thread design. In this case each Asio IO will be bounded to its own
    working thread and all handlers will be dispatched sequentially without
    strands making the code clean and easy to maintain.

    2) Service(threads, true) - initialize a new Asio service with thread-pool
    design. In this case single Asio IO will be bounded to all threads in pool,
    but strands will be required to serialize handler execution.

    3) Service(service, true | false) - initialize a new Asio service using the
    existing Asio IO service instance with required strands flag. Strands are
    required for serialized handler execution when single Asio IO service used
    in thread pool.

    Thread-safe.

    https://think-async.com
*/
class Service : public std::enable_shared_from_this<Service>
{
public:
    //! Initialize Asio service with single or multiple working threads
    /*!
        \param threads - Working threads count (default is 1)
        \param pool - Asio service thread pool flag (default is false)
    */
    explicit Service(int threads = 1, bool pool = false);
    //! Initialize Asio service manually with a given Asio IO service
    /*!
        \param service - Asio IO service
        \param strands - Asio IO service strands required flag (default is false)
    */
    explicit Service(const std::shared_ptr<asio::io_service>& service, bool strands = false);
    Service(const Service&) = delete;
    Service(Service&&) = delete;
    virtual ~Service() = default;

    Service& operator=(const Service&) = delete;
    Service& operator=(Service&&) = delete;

    //! Get the number of working threads
    size_t threads() const noexcept { return _threads.size(); }

    //! Is the service required strand to serialized handler execution?
    bool IsStrandRequired() const noexcept { return _strand_required; }
    //! Is the service started with polling loop mode?
    bool IsPolling() const noexcept { return _polling; }
    //! Is the service started?
    bool IsStarted() const noexcept { return _started; }

    //! Start the service
    /*!
        \param polling - Polling loop mode with idle handler call (default is false)
        \return 'true' if the service was successfully started, 'false' if the service failed to start
    */
    virtual bool Start(bool polling = false);
    //! Stop the service
    /*!
        \return 'true' if the service was successfully stopped, 'false' if the service is already stopped
    */
    virtual bool Stop();
    //! Restart the service
    /*!
        \return 'true' if the service was successfully restarted, 'false' if the service failed to restart
    */
    virtual bool Restart();

    //! Get the next available Asio IO service
    /*!
        Method will return single Asio IO service for manual or thread pool design or
        will return the next available Asio IO service using round-robin algorithm for
        io-service-per-thread design.

        \return Asio IO service
    */
    virtual std::shared_ptr<asio::io_service>& GetAsioService() noexcept
    { return _services[++_round_robin_index % _services.size()]; }

    //! Dispatch the given handler
    /*!
        The given handler may be executed immediately if this function is called from IO service thread.
        Otherwise it will be enqueued to the IO service pending operations queue.

        Method takes a handler to dispatch as a parameter and returns async result of the handler.
    */
    template <typename CompletionHandler>
    ASIO_INITFN_RESULT_TYPE(CompletionHandler, void()) Dispatch(ASIO_MOVE_ARG(CompletionHandler) handler)
    { if (_strand_required) return _strand->dispatch(handler); else return _services[0]->dispatch(handler); }

    //! Post the given handler
    /*!
        The given handler will be enqueued to the IO service pending operations queue.

        Method takes a handler to dispatch as a parameter and returns async result of the handler.
    */
    template <typename CompletionHandler>
    ASIO_INITFN_RESULT_TYPE(CompletionHandler, void()) Post(ASIO_MOVE_ARG(CompletionHandler) handler)
    { if (_strand_required) return _strand->post(handler); else return _services[0]->post(handler); }

protected:
    //! Initialize thread handler
    /*!
         This handler can be used to initialize priority or affinity of the service thread.
    */
    virtual void onThreadInitialize() {}
    //! Cleanup thread handler
    /*!
         This handler can be used to cleanup priority or affinity of the service thread.
    */
    virtual void onThreadCleanup() {}

    //! Handle service started notification
    virtual void onStarted() {}
    //! Handle service stopped notification
    virtual void onStopped() {}

    //! Handle service idle notification
    virtual void onIdle() { CppCommon::Thread::Yield(); }

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Asio IO services
    std::vector<std::shared_ptr<asio::io_service>> _services;
    // Asio service working threads
    std::vector<std::thread> _threads;
    // Asio service strand for serialized handler execution
    std::shared_ptr<asio::io_service::strand> _strand;
    // Asio service strands required flag
    std::atomic<bool> _strand_required;
    // Asio service polling loop mode flag
    std::atomic<bool> _polling;
    // Asio service state
    std::atomic<bool> _started;
    std::atomic<size_t> _round_robin_index;

    //! Service thread
    static void ServiceThread(const std::shared_ptr<Service>& service, const std::shared_ptr<asio::io_service>& io_service);

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example asio_service.cpp Asio service example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_SERVICE_H

```

`include/server/asio/ssl_client.h`:

```h
/*!
    \file ssl_client.h
    \brief SSL client definition
    \author Ivan Shynkarenka
    \date 01.01.2017
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_SSL_CLIENT_H
#define CPPSERVER_ASIO_SSL_CLIENT_H

#include "ssl_context.h"
#include "tcp_resolver.h"

#include "system/uuid.h"
#include "time/timespan.h"

#include <mutex>
#include <vector>

namespace CppServer {
namespace Asio {

//! SSL client
/*!
    SSL client is used to read/write data from/into the connected SSL server.

    Thread-safe.
*/
class SSLClient : public std::enable_shared_from_this<SSLClient>
{
public:
    //! Initialize SSL client with a given Asio service, SSL context, server address and port number
    /*!
        \param service - Asio service
        \param context - SSL context
        \param address - Server address
        \param port - Server port number
    */
    SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, int port);
    //! Initialize SSL client with a given Asio service, SSL context, server address and scheme name
    /*!
        \param service - Asio service
        \param context - SSL context
        \param address - Server address
        \param scheme - Scheme name
    */
    SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, const std::string& scheme);
    //! Initialize SSL client with a given Asio service, SSL context and endpoint
    /*!
        \param service - Asio service
        \param context - SSL context
        \param endpoint - Server SSL endpoint
    */
    SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const asio::ip::tcp::endpoint& endpoint);
    SSLClient(const SSLClient&) = delete;
    SSLClient(SSLClient&& client) = delete;
    virtual ~SSLClient();

    SSLClient& operator=(const SSLClient&) = delete;
    SSLClient& operator=(SSLClient&& client) = delete;

    //! Get the client Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the client SSL context
    std::shared_ptr<SSLContext>& context() noexcept { return _context; }
    //! Get the client endpoint
    asio::ip::tcp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the client SSL stream
    asio::ssl::stream<asio::ip::tcp::socket>& stream() noexcept { return _stream; }
    //! Get the client socket
    asio::ssl::stream<asio::ip::tcp::socket>::next_layer_type& socket() noexcept { return _stream.next_layer(); }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the scheme name
    const std::string& scheme() const noexcept { return _scheme; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of bytes pending sent by the client
    uint64_t bytes_pending() const noexcept { return _bytes_pending + _bytes_sending; }
    //! Get the number of bytes sent by the client
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the client
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: keep alive
    bool option_keep_alive() const noexcept { return _option_keep_alive; }
    //! Get the option: no delay
    bool option_no_delay() const noexcept { return _option_no_delay; }
    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the client connected?
    bool IsConnected() const noexcept { return _connected; }
    //! Is the session handshaked?
    bool IsHandshaked() const noexcept { return _handshaked; }

    //! Connect the client (synchronous)
    /*!
        Please note that synchronous connect will not receive data automatically!
        You should use Receive() or ReceiveAsync() method manually after successful connection.

        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect();
    //! Connect the client using the given DNS resolver (synchronous)
    /*!
        Please note that synchronous connect will not receive data automatically!
        You should use Receive() or ReceiveAsync() method manually after successful connection.

        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect(const std::shared_ptr<TCPResolver>& resolver);
    //! Disconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool Disconnect() { return DisconnectInternal(); }
    //! Reconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool Reconnect();

    //! Connect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync();
    //! Connect the client using the given DNS resolver (asynchronous)
    /*!
        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync(const std::shared_ptr<TCPResolver>& resolver);
    //! Disconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool DisconnectAsync() { return DisconnectInternalAsync(false); }
    //! Reconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool ReconnectAsync();

    //! Send data to the server (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size);
    //! Send text to the server (synchronous)
    /*!
        \param text - Text to send
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text) { return Send(text.data(), text.size()); }

    //! Send data to the server with timeout (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \param timeout - Timeout
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the server with timeout (synchronous)
    /*!
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text, const CppCommon::Timespan& timeout) { return Send(text.data(), text.size(), timeout); }

    //! Send data to the server (asynchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return 'true' if the data was successfully sent, 'false' if the client is not connected
    */
    virtual bool SendAsync(const void* buffer, size_t size);
    //! Send text to the server (asynchronous)
    /*!
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the client is not connected
    */
    virtual bool SendAsync(std::string_view text) { return SendAsync(text.data(), text.size()); }

    //! Receive data from the server (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size);
    //! Receive text from the server (synchronous)
    /*!
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(size_t size);

    //! Receive data from the server with timeout (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \param timeout - Timeout
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the server with timeout (synchronous)
    /*!
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(size_t size, const CppCommon::Timespan& timeout);

    //! Receive data from the server (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: keep alive
    /*!
        This option will setup SO_KEEPALIVE if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupKeepAlive(bool enable) noexcept { _option_keep_alive = enable; }
    //! Setup option: no delay
    /*!
        This option will enable/disable Nagle's algorithm for TCP protocol.

        https://en.wikipedia.org/wiki/Nagle%27s_algorithm

        \param enable - Enable/disable option
    */
    void SetupNoDelay(bool enable) noexcept { _option_no_delay = enable; }
    //! Setup option: receive buffer limit
    /*!
        The client will be disconnected if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The client will be disconnected if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle client connected notification
    virtual void onConnected() {}
    //! Handle session handshaked notification
    virtual void onHandshaked() {}
    //! Handle client disconnected notification
    virtual void onDisconnected() {}

    //! Handle buffer received notification
    /*!
        Notification is called when another part of buffer was received
        from the server.

        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onReceived(const void* buffer, size_t size) {}
    //! Handle buffer sent notification
    /*!
        Notification is called when another part of buffer was sent
        to the server.

        This handler could be used to send another buffer to the server
        for instance when the pending size is zero.

        \param sent - Size of sent buffer
        \param pending - Size of pending buffer
    */
    virtual void onSent(size_t sent, size_t pending) {}

    //! Handle empty send buffer notification
    /*!
        Notification is called when the send buffer is empty and ready
        for a new data to send.

        This handler could be used to send another buffer to the server.
    */
    virtual void onEmpty() {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Client Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialised handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    std::string _scheme;
    int _port;
    // Server SSL context, endpoint & client stream
    std::shared_ptr<SSLContext> _context;
    asio::ip::tcp::endpoint _endpoint;
    asio::ssl::stream<asio::ip::tcp::socket> _stream;
    std::atomic<bool> _resolving;
    std::atomic<bool> _connecting;
    std::atomic<bool> _connected;
    std::atomic<bool> _handshaking;
    std::atomic<bool> _handshaked;
    HandlerStorage _connect_storage;
    // Client statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    std::mutex _send_lock;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer_main;
    std::vector<uint8_t> _send_buffer_flush;
    size_t _send_buffer_flush_offset;
    HandlerStorage _send_storage;
    // Options
    bool _option_keep_alive;
    bool _option_no_delay;

    //! Disconnect the client (internal synchronous)
    bool DisconnectInternal();
    //! Disconnect the client (internal asynchronous)
    bool DisconnectInternalAsync(bool dispatch);

    //! Try to receive new data
    void TryReceive();
    //! Try to send pending data
    void TrySend();

    //! Clear send/receive buffers
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example ssl_chat_client.cpp SSL chat client example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_SSL_CLIENT_H

```

`include/server/asio/ssl_context.h`:

```h
/*!
    \file ssl_context.h
    \brief SSL context definition
    \author Ivan Shynkarenka
    \date 12.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_SSL_CONTEXT_H
#define CPPSERVER_ASIO_SSL_CONTEXT_H

#include "service.h"

namespace CppServer {
namespace Asio {

//! SSL context
/*!
    SSL context is used to handle and validate certificates in SSL clients and servers.

    Thread-safe.
*/
class SSLContext : public asio::ssl::context
{
public:
    using asio::ssl::context::context;

    SSLContext(const SSLContext&) = delete;
    SSLContext(SSLContext&&) = delete;
    ~SSLContext() = default;

    SSLContext& operator=(const SSLContext&) = delete;
    SSLContext& operator=(SSLContext&&) = delete;

    //! Configures the context to use system root certificates
    void set_root_certs();
};

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_SSL_CONTEXT_H

```

`include/server/asio/ssl_server.h`:

```h
/*!
    \file ssl_server.h
    \brief SSL server definition
    \author Ivan Shynkarenka
    \date 30.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_SSL_SERVER_H
#define CPPSERVER_ASIO_SSL_SERVER_H

#include "ssl_context.h"
#include "ssl_session.h"

#include "system/uuid.h"

#include <map>
#include <mutex>
#include <shared_mutex>
#include <vector>

namespace CppServer {
namespace Asio {

//! SSL server
/*!
    SSL server is used to connect, disconnect and manage SSL sessions.

    Thread-safe.
*/
class SSLServer : public std::enable_shared_from_this<SSLServer>
{
    friend class SSLSession;

public:
    //! Initialize SSL server with a given Asio service, SSL context and port number
    /*!
        \param service - Asio service
        \param context - SSL context
        \param port - Port number
        \param protocol - Internet protocol type (default is IPv4)
    */
    SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, int port, InternetProtocol protocol = InternetProtocol::IPv4);
    //! Initialize SSL server with a given Asio service, SSL context, server address and port number
    /*!
        \param service - Asio service
        \param context - SSL context
        \param address - Server address
        \param port - Port number
    */
    SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, int port);
    //! Initialize SSL server with a given a given Asio service, SSL context and endpoint
    /*!
        \param service - Asio service
        \param context - SSL context
        \param endpoint - Server SSL endpoint
    */
    SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const asio::ip::tcp::endpoint& endpoint);
    SSLServer(const SSLServer&) = delete;
    SSLServer(SSLServer&&) = delete;
    virtual ~SSLServer() = default;

    SSLServer& operator=(const SSLServer&) = delete;
    SSLServer& operator=(SSLServer&&) = delete;

    //! Get the server Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the server SSL context
    std::shared_ptr<SSLContext>& context() noexcept { return _context; }
    //! Get the server endpoint
    asio::ip::tcp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the server acceptor
    asio::ip::tcp::acceptor& acceptor() noexcept { return _acceptor; }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of sessions connected to the server
    uint64_t connected_sessions() const noexcept { return _sessions.size(); }
    //! Get the number of bytes pending sent by the server
    uint64_t bytes_pending() const noexcept { return _bytes_pending; }
    //! Get the number of bytes sent by the server
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the server
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: keep alive
    bool option_keep_alive() const noexcept { return _option_keep_alive; }
    //! Get the option: no delay
    bool option_no_delay() const noexcept { return _option_no_delay; }
    //! Get the option: reuse address
    bool option_reuse_address() const noexcept { return _option_reuse_address; }
    //! Get the option: reuse port
    bool option_reuse_port() const noexcept { return _option_reuse_port; }

    //! Is the server started?
    bool IsStarted() const noexcept { return _started; }

    //! Start the server
    /*!
        \return 'true' if the server was successfully started, 'false' if the server failed to start
    */
    virtual bool Start();
    //! Stop the server
    /*!
        \return 'true' if the server was successfully stopped, 'false' if the server is already stopped
    */
    virtual bool Stop();
    //! Restart the server
    /*!
        \return 'true' if the server was successfully restarted, 'false' if the server failed to restart
    */
    virtual bool Restart();

    //! Multicast data to all connected sessions
    /*!
        \param buffer - Buffer to multicast
        \param size - Buffer size
        \return 'true' if the data was successfully multicast, 'false' if the server is not started
    */
    virtual bool Multicast(const void* buffer, size_t size);
    //! Multicast text to all connected sessions
    /*!
        \param text - Text to multicast
        \return 'true' if the text was successfully multicast, 'false' if the server is not started
    */
    virtual bool Multicast(std::string_view text) { return Multicast(text.data(), text.size()); }

    //! Disconnect all connected sessions
    /*!
        \return 'true' if all sessions were successfully disconnected, 'false' if the server is not started
    */
    virtual bool DisconnectAll();

    //! Find a session with a given Id
    /*!
        \param id - Session Id
        \return Session with a given Id or null if the session it not connected
    */
    std::shared_ptr<SSLSession> FindSession(const CppCommon::UUID& id);

    //! Setup option: keep alive
    /*!
        This option will setup SO_KEEPALIVE if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupKeepAlive(bool enable) noexcept { _option_keep_alive = enable; }
    //! Setup option: no delay
    /*!
        This option will enable/disable Nagle's algorithm for TCP protocol.

        https://en.wikipedia.org/wiki/Nagle%27s_algorithm

        \param enable - Enable/disable option
    */
    void SetupNoDelay(bool enable) noexcept { _option_no_delay = enable; }
    //! Setup option: reuse address
    /*!
        This option will enable/disable SO_REUSEADDR if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReuseAddress(bool enable) noexcept { _option_reuse_address = enable; }
    //! Setup option: reuse port
    /*!
        This option will enable/disable SO_REUSEPORT if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReusePort(bool enable) noexcept { _option_reuse_port = enable; }

protected:
    //! Create SSL session factory method
    /*!
        \param server - SSL server
        \return SSL session
    */
    virtual std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) { return std::make_shared<SSLSession>(server); }

protected:
    //! Handle server started notification
    virtual void onStarted() {}
    //! Handle server stopped notification
    virtual void onStopped() {}

    //! Handle session connected notification
    /*!
        \param session - Connected session
    */
    virtual void onConnected(std::shared_ptr<SSLSession>& session) {}
    //! Handle session handshaked notification
    /*!
        \param session - Handshaked session
    */
    virtual void onHandshaked(std::shared_ptr<SSLSession>& session) {}
    //! Handle session disconnected notification
    /*!
        \param session - Disconnected session
    */
    virtual void onDisconnected(std::shared_ptr<SSLSession>& session) {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

protected:
    // Server sessions
    std::shared_mutex _sessions_lock;
    std::map<CppCommon::UUID, std::shared_ptr<SSLSession>> _sessions;

private:
    // Server Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    int _port;
    // Server SSL context, endpoint, acceptor and socket
    std::shared_ptr<SSLContext> _context;
    std::shared_ptr<SSLSession> _session;
    asio::ip::tcp::endpoint _endpoint;
    asio::ip::tcp::acceptor _acceptor;
    std::atomic<bool> _started;
    HandlerStorage _acceptor_storage;
    // Server statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Options
    bool _option_keep_alive;
    bool _option_no_delay;
    bool _option_reuse_address;
    bool _option_reuse_port;

    //! Accept new connections
    void Accept();

    //! Register a new session
    void RegisterSession();
    //! Unregister the given session
    /*!
        \param id - Session Id
    */
    void UnregisterSession(const CppCommon::UUID& id);

    //! Clear multicast buffer
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example ssl_chat_server.cpp SSL chat server example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_SSL_SERVER_H

```

`include/server/asio/ssl_session.h`:

```h
/*!
    \file ssl_session.h
    \brief SSL session definition
    \author Ivan Shynkarenka
    \date 30.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_SSL_SESSION_H
#define CPPSERVER_ASIO_SSL_SESSION_H

#include "service.h"

#include "system/uuid.h"

namespace CppServer {
namespace Asio {

class SSLServer;

//! SSL session
/*!
    SSL session is used to read and write data from the connected SSL client.

    Thread-safe.
*/
class SSLSession : public std::enable_shared_from_this<SSLSession>
{
    friend class SSLServer;

public:
    //! Initialize the session with a given server
    /*!
        \param server - Connected server
    */
    explicit SSLSession(const std::shared_ptr<SSLServer>& server);
    SSLSession(const SSLSession&) = delete;
    SSLSession(SSLSession&&) = delete;
    virtual ~SSLSession() = default;

    SSLSession& operator=(const SSLSession&) = delete;
    SSLSession& operator=(SSLSession&&) = delete;

    //! Get the session Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the server
    std::shared_ptr<SSLServer>& server() noexcept { return _server; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the session SSL stream
    asio::ssl::stream<asio::ip::tcp::socket>& stream() noexcept { return _stream; }
    //! Get the session socket
    asio::ssl::stream<asio::ip::tcp::socket>::next_layer_type& socket() noexcept { return _stream.next_layer(); }

    //! Get the number of bytes pending sent by the session
    uint64_t bytes_pending() const noexcept { return _bytes_pending + _bytes_sending; }
    //! Get the number of bytes sent by the session
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the session
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const noexcept { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const noexcept { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the session connected?
    bool IsConnected() const noexcept { return _connected; }
    //! Is the session handshaked?
    bool IsHandshaked() const noexcept { return _handshaked; }

    //! Disconnect the session
    /*!
        \return 'true' if the section was successfully disconnected, 'false' if the section is already disconnected
    */
    virtual bool Disconnect() { return DisconnectAsync(false); }

    //! Send data to the client (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size);
    //! Send text to the client (synchronous)
    /*!
        \param text - Text to send
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text) { return Send(text.data(), text.size()); }

    //! Send data to the client with timeout (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \param timeout - Timeout
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the client with timeout (synchronous)
    /*!
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text, const CppCommon::Timespan& timeout) { return Send(text.data(), text.size(), timeout); }

    //! Send data to the client (asynchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return 'true' if the data was successfully sent, 'false' if the session is not connected
    */
    virtual bool SendAsync(const void* buffer, size_t size);
    //! Send text to the client (asynchronous)
    /*!
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the session is not connected
    */
    virtual bool SendAsync(std::string_view text) { return SendAsync(text.data(), text.size()); }

    //! Receive data from the client (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size);
    //! Receive text from the client (synchronous)
    /*!
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(size_t size);

    //! Receive data from the client with timeout (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \param timeout - Timeout
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the client with timeout (synchronous)
    /*!
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(size_t size, const CppCommon::Timespan& timeout);

    //! Receive data from the client (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: receive buffer limit
    /*!
        The session will be disconnected if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) noexcept { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The session will be disconnected if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) noexcept { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle session connected notification
    virtual void onConnected() {}
    //! Handle session handshaked notification
    virtual void onHandshaked() {}
    //! Handle session disconnected notification
    virtual void onDisconnected() {}

    //! Handle buffer received notification
    /*!
        Notification is called when another part of buffer was received
        from the client.

        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onReceived(const void* buffer, size_t size) {}
    //! Handle buffer sent notification
    /*!
        Notification is called when another part of buffer was sent
        to the client.

        This handler could be used to send another buffer to the client
        for instance when the pending size is zero.

        \param sent - Size of sent buffer
        \param pending - Size of pending buffer
    */
    virtual void onSent(size_t sent, size_t pending) {}

    //! Handle empty send buffer notification
    /*!
        Notification is called when the send buffer is empty and ready
        for a new data to send.

        This handler could be used to send another buffer to the client.
    */
    virtual void onEmpty() {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Session Id
    CppCommon::UUID _id;
    // Server & session
    std::shared_ptr<SSLServer> _server;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Session stream
    asio::ssl::stream<asio::ip::tcp::socket> _stream;
    std::atomic<bool> _connected;
    std::atomic<bool> _handshaked;
    // Session statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    std::mutex _send_lock;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer_main;
    std::vector<uint8_t> _send_buffer_flush;
    size_t _send_buffer_flush_offset;
    HandlerStorage _send_storage;

    //! Connect the session
    void Connect();
    //! Disconnect the session with error
    void Disconnect(std::error_code ec);
    //! Disconnect the session (asynchronous)
    /*!
        \param dispatch - Dispatch flag
        \return 'true' if the session was successfully disconnected, 'false' if the session is already disconnected
    */
    bool DisconnectAsync(bool dispatch);

    //! Try to receive new data
    void TryReceive();
    //! Try to send pending data
    void TrySend();

    //! Clear send/receive buffers
    void ClearBuffers();
    //! Reset server
    void ResetServer();

    //! Send error notification
    void SendError(std::error_code ec);
};

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_SSL_SESSION_H

```

`include/server/asio/tcp_client.h`:

```h
/*!
    \file tcp_client.h
    \brief TCP client definition
    \author Ivan Shynkarenka
    \date 15.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_TCP_CLIENT_H
#define CPPSERVER_ASIO_TCP_CLIENT_H

#include "tcp_resolver.h"

#include "system/uuid.h"
#include "time/timespan.h"

#include <mutex>
#include <vector>

namespace CppServer {
namespace Asio {

//! TCP client
/*!
    TCP client is used to read/write data from/into the connected TCP server.

    Thread-safe.
*/
class TCPClient : public std::enable_shared_from_this<TCPClient>
{
public:
    //! Initialize TCP client with a given Asio service, server address and port number
    /*!
        \param service - Asio service
        \param address - Server address
        \param port - Server port number
    */
    TCPClient(const std::shared_ptr<Service>& service, const std::string& address, int port);
    //! Initialize TCP client with a given Asio service, server address and scheme name
    /*!
        \param service - Asio service
        \param address - Server address
        \param scheme - Scheme name
    */
    TCPClient(const std::shared_ptr<Service>& service, const std::string& address, const std::string& scheme);
    //! Initialize TCP client with a given Asio service and endpoint
    /*!
        \param service - Asio service
        \param endpoint - Server TCP endpoint
    */
    TCPClient(const std::shared_ptr<Service>& service, const asio::ip::tcp::endpoint& endpoint);
    TCPClient(const TCPClient&) = delete;
    TCPClient(TCPClient&&) = delete;
    virtual ~TCPClient() = default;

    TCPClient& operator=(const TCPClient&) = delete;
    TCPClient& operator=(TCPClient&&) = delete;

    //! Get the client Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the client endpoint
    asio::ip::tcp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the client socket
    asio::ip::tcp::socket& socket() noexcept { return _socket; }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the scheme name
    const std::string& scheme() const noexcept { return _scheme; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of bytes pending sent by the client
    uint64_t bytes_pending() const noexcept { return _bytes_pending + _bytes_sending; }
    //! Get the number of bytes sent by the client
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the client
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: keep alive
    bool option_keep_alive() const noexcept { return _option_keep_alive; }
    //! Get the option: no delay
    bool option_no_delay() const noexcept { return _option_no_delay; }
    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const noexcept { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const noexcept { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the client connected?
    bool IsConnected() const noexcept { return _connected; }

    //! Connect the client (synchronous)
    /*!
        Please note that synchronous connect will not receive data automatically!
        You should use Receive() or ReceiveAsync() method manually after successful connection.

        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect();
    //! Connect the client using the given DNS resolver (synchronous)
    /*!
        Please note that synchronous connect will not receive data automatically!
        You should use Receive() or ReceiveAsync() method manually after successful connection.

        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect(const std::shared_ptr<TCPResolver>& resolver);
    //! Disconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool Disconnect() { return DisconnectInternal(); }
    //! Reconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool Reconnect();

    //! Connect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync();
    //! Connect the client using the given DNS resolver (asynchronous)
    /*!
        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync(const std::shared_ptr<TCPResolver>& resolver);
    //! Disconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool DisconnectAsync() { return DisconnectInternalAsync(false); }
    //! Reconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool ReconnectAsync();

    //! Send data to the server (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size);
    //! Send text to the server (synchronous)
    /*!
        \param text - Text to send
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text) { return Send(text.data(), text.size()); }

    //! Send data to the server with timeout (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \param timeout - Timeout
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the server with timeout (synchronous)
    /*!
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text, const CppCommon::Timespan& timeout) { return Send(text.data(), text.size(), timeout); }

    //! Send data to the server (asynchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return 'true' if the data was successfully sent, 'false' if the client is not connected
    */
    virtual bool SendAsync(const void* buffer, size_t size);
    //! Send text to the server (asynchronous)
    /*!
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the client is not connected
    */
    virtual bool SendAsync(std::string_view text) { return SendAsync(text.data(), text.size()); }

    //! Receive data from the server (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size);
    //! Receive text from the server (synchronous)
    /*!
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(size_t size);

    //! Receive data from the server with timeout (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \param timeout - Timeout
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the server with timeout (synchronous)
    /*!
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(size_t size, const CppCommon::Timespan& timeout);

    //! Receive data from the server (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: keep alive
    /*!
        This option will setup SO_KEEPALIVE if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupKeepAlive(bool enable) noexcept { _option_keep_alive = enable; }
    //! Setup option: no delay
    /*!
        This option will enable/disable Nagle's algorithm for TCP protocol.

        https://en.wikipedia.org/wiki/Nagle%27s_algorithm

        \param enable - Enable/disable option
    */
    void SetupNoDelay(bool enable) noexcept { _option_no_delay = enable; }
    //! Setup option: receive buffer limit
    /*!
        The client will be disconnected if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) noexcept { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The client will be disconnected if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) noexcept { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle client connected notification
    virtual void onConnected() {}
    //! Handle client disconnected notification
    virtual void onDisconnected() {}

    //! Handle buffer received notification
    /*!
        Notification is called when another part of buffer was received
        from the server.

        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onReceived(const void* buffer, size_t size) {}
    //! Handle buffer sent notification
    /*!
        Notification is called when another part of buffer was sent
        to the server.

        This handler could be used to send another buffer to the server
        for instance when the pending size is zero.

        \param sent - Size of sent buffer
        \param pending - Size of pending buffer
    */
    virtual void onSent(size_t sent, size_t pending) {}

    //! Handle empty send buffer notification
    /*!
        Notification is called when the send buffer is empty and ready
        for a new data to send.

        This handler could be used to send another buffer to the server.
    */
    virtual void onEmpty() {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Client Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    std::string _scheme;
    int _port;
    // Server endpoint & client socket
    asio::ip::tcp::endpoint _endpoint;
    asio::ip::tcp::socket _socket;
    std::atomic<bool> _resolving;
    std::atomic<bool> _connecting;
    std::atomic<bool> _connected;
    // Client statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    std::mutex _send_lock;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer_main;
    std::vector<uint8_t> _send_buffer_flush;
    size_t _send_buffer_flush_offset;
    HandlerStorage _send_storage;
    // Options
    bool _option_keep_alive;
    bool _option_no_delay;

    //! Disconnect the client (internal synchronous)
    bool DisconnectInternal();
    //! Disconnect the client (internal asynchronous)
    bool DisconnectInternalAsync(bool dispatch);

    //! Try to receive new data
    void TryReceive();
    //! Try to send pending data
    void TrySend();

    //! Clear send/receive buffers
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example tcp_chat_client.cpp TCP chat client example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_TCP_CLIENT_H

```

`include/server/asio/tcp_resolver.h`:

```h
/*!
    \file tcp_resolver.h
    \brief TCP resolver definition
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_TCP_RESOLVER_H
#define CPPSERVER_ASIO_TCP_RESOLVER_H

#include "service.h"

namespace CppServer {
namespace Asio {

//! TCP resolver
/*!
    TCP resolver is used to resolve DNS while connecting TCP/SSL clients.

    Thread-safe.
*/
class TCPResolver
{
public:
    //! Initialize resolver with a given Asio service
    /*!
        \param service - Asio service
    */
    TCPResolver(const std::shared_ptr<Service>& service);
    TCPResolver(const TCPResolver&) = delete;
    TCPResolver(TCPResolver&&) = delete;
    virtual ~TCPResolver() { Cancel(); }

    TCPResolver& operator=(const TCPResolver&) = delete;
    TCPResolver& operator=(TCPResolver&&) = delete;

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the TCP resolver
    asio::ip::tcp::resolver& resolver() noexcept { return _resolver; }

    //! Cancel any asynchronous operations that are waiting on the resolver
    virtual void Cancel() { _resolver.cancel(); }

private:
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // TCP resolver
    asio::ip::tcp::resolver _resolver;
};

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_TCP_RESOLVER_H

```

`include/server/asio/tcp_server.h`:

```h
/*!
    \file tcp_server.h
    \brief TCP server definition
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_TCP_SERVER_H
#define CPPSERVER_ASIO_TCP_SERVER_H

#include "tcp_session.h"

#include "system/uuid.h"

#include <map>
#include <mutex>
#include <shared_mutex>
#include <vector>

namespace CppServer {
namespace Asio {

//! TCP server
/*!
    TCP server is used to connect, disconnect and manage TCP sessions.

    Thread-safe.
*/
class TCPServer : public std::enable_shared_from_this<TCPServer>
{
    friend class TCPSession;

public:
    //! Initialize TCP server with a given Asio service and port number
    /*!
        \param service - Asio service
        \param port - Port number
        \param protocol - Internet protocol type (default is IPv4)
    */
    TCPServer(const std::shared_ptr<Service>& service, int port, InternetProtocol protocol = InternetProtocol::IPv4);
    //! Initialize TCP server with a given Asio service, server address and port number
    /*!
        \param service - Asio service
        \param address - Server address
        \param port - Port number
    */
    TCPServer(const std::shared_ptr<Service>& service, const std::string& address, int port);
    //! Initialize TCP server with a given Asio service and endpoint
    /*!
        \param service - Asio service
        \param endpoint - Server TCP endpoint
    */
    TCPServer(const std::shared_ptr<Service>& service, const asio::ip::tcp::endpoint& endpoint);
    TCPServer(const TCPServer&) = delete;
    TCPServer(TCPServer&&) = delete;
    virtual ~TCPServer() = default;

    TCPServer& operator=(const TCPServer&) = delete;
    TCPServer& operator=(TCPServer&&) = delete;

    //! Get the server Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the server endpoint
    asio::ip::tcp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the server acceptor
    asio::ip::tcp::acceptor& acceptor() noexcept { return _acceptor; }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of sessions connected to the server
    uint64_t connected_sessions() const noexcept { return _sessions.size(); }
    //! Get the number of bytes pending sent by the server
    uint64_t bytes_pending() const noexcept { return _bytes_pending; }
    //! Get the number of bytes sent by the server
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the server
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: keep alive
    bool option_keep_alive() const noexcept { return _option_keep_alive; }
    //! Get the option: no delay
    bool option_no_delay() const noexcept { return _option_no_delay; }
    //! Get the option: reuse address
    bool option_reuse_address() const noexcept { return _option_reuse_address; }
    //! Get the option: reuse port
    bool option_reuse_port() const noexcept { return _option_reuse_port; }

    //! Is the server started?
    bool IsStarted() const noexcept { return _started; }

    //! Start the server
    /*!
        \return 'true' if the server was successfully started, 'false' if the server failed to start
    */
    virtual bool Start();
    //! Stop the server
    /*!
        \return 'true' if the server was successfully stopped, 'false' if the server is already stopped
    */
    virtual bool Stop();
    //! Restart the server
    /*!
        \return 'true' if the server was successfully restarted, 'false' if the server failed to restart
    */
    virtual bool Restart();

    //! Multicast data to all connected sessions
    /*!
        \param buffer - Buffer to multicast
        \param size - Buffer size
        \return 'true' if the data was successfully multicast, 'false' if the server is not started
    */
    virtual bool Multicast(const void* buffer, size_t size);
    //! Multicast text to all connected sessions
    /*!
        \param text - Text to multicast
        \return 'true' if the text was successfully multicast, 'false' if the server is not started
    */
    virtual bool Multicast(std::string_view text) { return Multicast(text.data(), text.size()); }

    //! Disconnect all connected sessions
    /*!
        \return 'true' if all sessions were successfully disconnected, 'false' if the server is not started
    */
    virtual bool DisconnectAll();

    //! Find a session with a given Id
    /*!
        \param id - Session Id
        \return Session with a given Id or null if the session it not connected
    */
    std::shared_ptr<TCPSession> FindSession(const CppCommon::UUID& id);

    //! Setup option: keep alive
    /*!
        This option will setup SO_KEEPALIVE if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupKeepAlive(bool enable) noexcept { _option_keep_alive = enable; }
    //! Setup option: no delay
    /*!
        This option will enable/disable Nagle's algorithm for TCP protocol.

        https://en.wikipedia.org/wiki/Nagle%27s_algorithm

        \param enable - Enable/disable option
    */
    void SetupNoDelay(bool enable) noexcept { _option_no_delay = enable; }
    //! Setup option: reuse address
    /*!
        This option will enable/disable SO_REUSEADDR if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReuseAddress(bool enable) noexcept { _option_reuse_address = enable; }
    //! Setup option: reuse port
    /*!
        This option will enable/disable SO_REUSEPORT if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReusePort(bool enable) noexcept { _option_reuse_port = enable; }

protected:
    //! Create TCP session factory method
    /*!
        \param server - TCP server
        \return TCP session
    */
    virtual std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) { return std::make_shared<TCPSession>(server); }

protected:
    //! Handle server started notification
    virtual void onStarted() {}
    //! Handle server stopped notification
    virtual void onStopped() {}

    //! Handle session connected notification
    /*!
        \param session - Connected session
    */
    virtual void onConnected(std::shared_ptr<TCPSession>& session) {}
    //! Handle session disconnected notification
    /*!
        \param session - Disconnected session
    */
    virtual void onDisconnected(std::shared_ptr<TCPSession>& session) {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

protected:
    // Server sessions
    std::shared_mutex _sessions_lock;
    std::map<CppCommon::UUID, std::shared_ptr<TCPSession>> _sessions;

private:
    // Server Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    int _port;
    // Server endpoint, acceptor & socket
    std::shared_ptr<TCPSession> _session;
    asio::ip::tcp::endpoint _endpoint;
    asio::ip::tcp::acceptor _acceptor;
    std::atomic<bool> _started;
    HandlerStorage _acceptor_storage;
    // Server statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Options
    bool _option_keep_alive;
    bool _option_no_delay;
    bool _option_reuse_address;
    bool _option_reuse_port;

    //! Accept new connections
    void Accept();

    //! Register a new session
    void RegisterSession();
    //! Unregister the given session
    /*!
        \param id - Session Id
    */
    void UnregisterSession(const CppCommon::UUID& id);

    //! Clear multicast buffer
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example tcp_chat_server.cpp TCP chat server example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_TCP_SERVER_H

```

`include/server/asio/tcp_session.h`:

```h
/*!
    \file tcp_session.h
    \brief TCP session definition
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_TCP_SESSION_H
#define CPPSERVER_ASIO_TCP_SESSION_H

#include "service.h"

#include "system/uuid.h"

namespace CppServer {
namespace Asio {

class TCPServer;

//! TCP session
/*!
    TCP session is used to read and write data from the connected TCP client.

    Thread-safe.
*/
class TCPSession : public std::enable_shared_from_this<TCPSession>
{
    friend class TCPServer;

public:
    //! Initialize the session with a given server
    /*!
        \param server - Connected server
    */
    explicit TCPSession(const std::shared_ptr<TCPServer>& server);
    TCPSession(const TCPSession&) = delete;
    TCPSession(TCPSession&&) = delete;
    virtual ~TCPSession() = default;

    TCPSession& operator=(const TCPSession&) = delete;
    TCPSession& operator=(TCPSession&&) = delete;

    //! Get the session Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the server
    std::shared_ptr<TCPServer>& server() noexcept { return _server; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the session socket
    asio::ip::tcp::socket& socket() noexcept { return _socket; }

    //! Get the number of bytes pending sent by the session
    uint64_t bytes_pending() const noexcept { return _bytes_pending + _bytes_sending; }
    //! Get the number of bytes sent by the session
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the session
    uint64_t bytes_received() const noexcept { return _bytes_received; }

    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const noexcept { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const noexcept { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the session connected?
    bool IsConnected() const noexcept { return _connected; }

    //! Disconnect the session
    /*!
        \return 'true' if the section was successfully disconnected, 'false' if the section is already disconnected
    */
    virtual bool Disconnect() { return Disconnect(false); }

    //! Send data to the client (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size);
    //! Send text to the client (synchronous)
    /*!
        \param text - Text to send
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text) { return Send(text.data(), text.size()); }

    //! Send data to the client with timeout (synchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \param timeout - Timeout
        \return Size of sent data
    */
    virtual size_t Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the client with timeout (synchronous)
    /*!
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent text
    */
    virtual size_t Send(std::string_view text, const CppCommon::Timespan& timeout) { return Send(text.data(), text.size(), timeout); }

    //! Send data to the client (asynchronous)
    /*!
        \param buffer - Buffer to send
        \param size - Buffer size
        \return 'true' if the data was successfully sent, 'false' if the session is not connected
    */
    virtual bool SendAsync(const void* buffer, size_t size);
    //! Send text to the client (asynchronous)
    /*!
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the session is not connected
    */
    virtual bool SendAsync(std::string_view text) { return SendAsync(text.data(), text.size()); }

    //! Receive data from the client (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size);
    //! Receive text from the client (synchronous)
    /*!
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(size_t size);

    //! Receive data from the client with timeout (synchronous)
    /*!
        \param buffer - Buffer to receive
        \param size - Buffer size to receive
        \param timeout - Timeout
        \return Size of received data
    */
    virtual size_t Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the client with timeout (synchronous)
    /*!
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(size_t size, const CppCommon::Timespan& timeout);

    //! Receive data from the client (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: receive buffer limit
    /*!
        The session will be disconnected if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) noexcept { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The session will be disconnected if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) noexcept { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle session connected notification
    virtual void onConnected() {}
    //! Handle session disconnected notification
    virtual void onDisconnected() {}

    //! Handle buffer received notification
    /*!
        Notification is called when another part of buffer was received
        from the client.

        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onReceived(const void* buffer, size_t size) {}
    //! Handle buffer sent notification
    /*!
        Notification is called when another part of buffer was sent
        to the client.

        This handler could be used to send another buffer to the client
        for instance when the pending size is zero.

        \param sent - Size of sent buffer
        \param pending - Size of pending buffer
    */
    virtual void onSent(size_t sent, size_t pending) {}

    //! Handle empty send buffer notification
    /*!
        Notification is called when the send buffer is empty and ready
        for a new data to send.

        This handler could be used to send another buffer to the client.
    */
    virtual void onEmpty() {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Session Id
    CppCommon::UUID _id;
    // Server & session
    std::shared_ptr<TCPServer> _server;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Session socket
    asio::ip::tcp::socket _socket;
    std::atomic<bool> _connected;
    // Session statistic
    uint64_t _bytes_pending;
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    std::mutex _send_lock;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer_main;
    std::vector<uint8_t> _send_buffer_flush;
    size_t _send_buffer_flush_offset;
    HandlerStorage _send_storage;

    //! Connect the session
    void Connect();
    //! Disconnect the session
    /*!
        \param dispatch - Dispatch flag
        \return 'true' if the session was successfully disconnected, 'false' if the session is already disconnected
    */
    bool Disconnect(bool dispatch);

    //! Try to receive new data
    void TryReceive();
    //! Try to send pending data
    void TrySend();

    //! Clear send/receive buffers
    void ClearBuffers();
    //! Reset server
    void ResetServer();

    //! Send error notification
    void SendError(std::error_code ec);
};

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_TCP_SESSION_H

```

`include/server/asio/timer.h`:

```h
/*!
    \file timer.h
    \brief Timer definition
    \author Ivan Shynkarenka
    \date 16.08.2018
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_TIMER_H
#define CPPSERVER_ASIO_TIMER_H

#include "service.h"

#include "time/time.h"
#include "time/timespan.h"

#include <cassert>
#include <functional>

namespace CppServer {
namespace Asio {

//! Timer
/*!
    Timer is used to plan and perform delayed operation.

    Thread-safe.
*/
class Timer : public std::enable_shared_from_this<Timer>
{
public:
    //! Initialize timer with a given Asio service
    /*!
        \param service - Asio service
    */
    Timer(const std::shared_ptr<Service>& service);
    //! Initialize timer with a given Asio service and absolute expiry time
    /*!
        \param service - Asio service
        \param time - Absolute time
    */
    Timer(const std::shared_ptr<Service>& service, const CppCommon::UtcTime& time);
    //! Initialize timer with a given Asio service and expiry time relative to now
    /*!
        \param service - Asio service
        \param timespan - Relative timespan
    */
    Timer(const std::shared_ptr<Service>& service, const CppCommon::Timespan& timespan);
    //! Initialize timer with a given Asio service and action function
    /*!
        \param service - Asio service
        \param action - Action function
    */
    Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action);
    //! Initialize timer with a given Asio service, action function and absolute expiry time
    /*!
        \param service - Asio service
        \param action - Action function
        \param time - Absolute time
    */
    Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action, const CppCommon::UtcTime& time);
    //! Initialize timer with a given Asio service, action function and expiry time relative to now
    /*!
        \param service - Asio service
        \param action - Action function
        \param timespan - Relative timespan
    */
    Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action, const CppCommon::Timespan& timespan);
    Timer(const Timer&) = delete;
    Timer(Timer&&) = delete;
    virtual ~Timer() = default;

    Timer& operator=(const Timer&) = delete;
    Timer& operator=(Timer&&) = delete;

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }

    //! Get the timer's expiry time as an absolute time
    CppCommon::UtcTime expire_time() const;
    //! Get the timer's expiry time relative to now
    CppCommon::Timespan expire_timespan() const;

    //! Setup the timer with absolute expiry time
    /*!
        \param time - Absolute time
        \return 'true' if the timer was successfully setup, 'false' if the timer failed to setup
    */
    virtual bool Setup(const CppCommon::UtcTime& time);
    //! Setup the timer with expiry time relative to now
    /*!
        \param timespan - Relative timespan
        \return 'true' if the timer was successfully setup, 'false' if the timer failed to setup
    */
    virtual bool Setup(const CppCommon::Timespan& timespan);
    //! Setup the timer with an action function
    /*!
        \param action - Action function
        \return 'true' if the timer was successfully setup, 'false' if the timer failed to setup
    */
    virtual bool Setup(const std::function<void(bool)>& action);
    //! Setup the timer with an action function and absolute expiry time
    /*!
        \param action - Action function
        \param time - Absolute time
        \return 'true' if the timer was successfully setup, 'false' if the timer failed to setup
    */
    virtual bool Setup(const std::function<void(bool)>& action, const CppCommon::UtcTime& time);
    //! Setup the timer with an action function and expiry time relative to now
    /*!
        \param action - Action function
        \param timespan - Relative timespan
        \return 'true' if the timer was successfully setup, 'false' if the timer failed to setup
    */
    virtual bool Setup(const std::function<void(bool)>& action, const CppCommon::Timespan& timespan);

    //! Wait for the timer (asynchronous)
    /*!
        \return 'true' if the timer was successfully expired, 'false' if any error occurred
    */
    virtual bool WaitAsync();
    //! Wait for the timer (synchronous)
    /*!
        \return 'true' if the timer was successfully expired, 'false' if any error occurred
    */
    virtual bool WaitSync();

    //! Cancel any wait operation on the timer
    /*!
        \return 'true' if the timer was successfully canceled, 'false' if any error occurred
    */
    virtual bool Cancel();

protected:
    //! Handle timer notification
    virtual void onTimer(bool canceled) {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Deadline timer
    asio::system_timer _timer;
    // Action function
    std::function<void(bool)> _action;

    //! Send error notification
    void SendError(std::error_code ec);
    //! Send timer notification
    void SendTimer(bool canceled);
};

/*! \example asio_timer.cpp Asio timer example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_TIMER_H

```

`include/server/asio/udp_client.h`:

```h
/*!
    \file udp_client.h
    \brief UDP client definition
    \author Ivan Shynkarenka
    \date 23.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_UDP_CLIENT_H
#define CPPSERVER_ASIO_UDP_CLIENT_H

#include "udp_resolver.h"

#include "system/uuid.h"
#include "time/timespan.h"

#include <mutex>
#include <vector>

namespace CppServer {
namespace Asio {

//! UDP client
/*!
    UDP client is used to read/write datagrams from/into the connected UDP server.

    Thread-safe.
*/
class UDPClient : public std::enable_shared_from_this<UDPClient>
{
public:
    //! Initialize UDP client with a given Asio service, server address and port number
    /*!
        \param service - Asio service
        \param address - Server address
        \param port - Server port number
    */
    UDPClient(const std::shared_ptr<Service>& service, const std::string& address, int port);
    //! Initialize UDP client with a given Asio service, server address and scheme name
    /*!
        \param service - Asio service
        \param address - Server address
        \param scheme - Scheme name
    */
    UDPClient(const std::shared_ptr<Service>& service, const std::string& address, const std::string& scheme);
    //! Initialize UDP client with a given Asio service and endpoint
    /*!
        \param service - Asio service
        \param endpoint - Server UDP endpoint
    */
    UDPClient(const std::shared_ptr<Service>& service, const asio::ip::udp::endpoint& endpoint);
    UDPClient(const UDPClient&) = delete;
    UDPClient(UDPClient&&) = delete;
    virtual ~UDPClient() = default;

    UDPClient& operator=(const UDPClient&) = delete;
    UDPClient& operator=(UDPClient&&) = delete;

    //! Get the client Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the client endpoint
    asio::ip::udp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the client socket
    asio::ip::udp::socket& socket() noexcept { return _socket; }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the scheme name
    const std::string& scheme() const noexcept { return _scheme; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of bytes pending sent by the client
    uint64_t bytes_pending() const noexcept { return _bytes_sending; }
    //! Get the number of bytes sent by the client
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the client
    uint64_t bytes_received() const noexcept { return _bytes_received; }
    //! Get the number datagrams sent by the client
    uint64_t datagrams_sent() const noexcept { return _datagrams_sent; }
    //! Get the number datagrams received by the client
    uint64_t datagrams_received() const noexcept { return _datagrams_received; }

    //! Get the option: reuse address
    bool option_reuse_address() const noexcept { return _option_reuse_address; }
    //! Get the option: reuse port
    bool option_reuse_port() const noexcept { return _option_reuse_port; }
    //! Get the option: bind the socket to the multicast UDP server
    bool option_multicast() const noexcept { return _option_multicast; }
    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const noexcept { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const noexcept { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the client connected?
    bool IsConnected() const noexcept { return _connected; }

    //! Connect the client (synchronous)
    /*!
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect();
    //! Connect the client using the given DNS resolver (synchronous)
    /*!
        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool Connect(const std::shared_ptr<UDPResolver>& resolver);
    //! Disconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool Disconnect() { return DisconnectInternal(); }
    //! Reconnect the client (synchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool Reconnect();

    //! Connect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync();
    //! Connect the client using the given DNS resolver (asynchronous)
    /*!
        \param resolver - DNS resolver
        \return 'true' if the client was successfully connected, 'false' if the client failed to connect
    */
    virtual bool ConnectAsync(const std::shared_ptr<UDPResolver>& resolver);
    //! Disconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully disconnected, 'false' if the client is already disconnected
    */
    virtual bool DisconnectAsync() { return DisconnectInternalAsync(false); }
    //! Reconnect the client (asynchronous)
    /*!
        \return 'true' if the client was successfully reconnected, 'false' if the client is already reconnected
    */
    virtual bool ReconnectAsync();

    //! Join multicast group with a given address (synchronous)
    /*!
        \param address - Multicast group address
    */
    virtual void JoinMulticastGroup(const std::string& address);
    //! Leave multicast group with a given address (synchronous)
    /*!
        \param address - Multicast group address
    */
    virtual void LeaveMulticastGroup(const std::string& address);

    //! Join multicast group with a given address (asynchronous)
    /*!
        \param address - Multicast group address
    */
    virtual void JoinMulticastGroupAsync(const std::string& address);
    //! Leave multicast group with a given address (asynchronous)
    /*!
        \param address - Multicast group address
    */
    virtual void LeaveMulticastGroupAsync(const std::string& address);

    //! Send datagram to the connected server (synchronous)
    /*!
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return Size of sent datagram
    */
    virtual size_t Send(const void* buffer, size_t size);
    //! Send text to the connected server (synchronous)
    /*!
        \param text - Text to send
        \return Size of sent datagram
    */
    virtual size_t Send(std::string_view text) { return Send(text.data(), text.size()); }
    //! Send datagram to the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size);
    //! Send text to the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, std::string_view text) { return Send(endpoint, text.data(), text.size()); }

    //! Send datagram to the connected server with timeout (synchronous)
    /*!
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the connected server with timeout (synchronous)
    /*!
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(std::string_view text, const CppCommon::Timespan& timeout) { return Send(text.data(), text.size(), timeout); }
    //! Send datagram to the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text to the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, std::string_view text, const CppCommon::Timespan& timeout) { return Send(endpoint, text.data(), text.size(), timeout); }

    //! Send datagram to the connected server (asynchronous)
    /*!
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return 'true' if the datagram was successfully sent, 'false' if the datagram was not sent
    */
    virtual bool SendAsync(const void* buffer, size_t size);
    //! Send text to the connected server (asynchronous)
    /*!
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the text was not sent
    */
    virtual bool SendAsync(std::string_view text) { return SendAsync(text.data(), text.size()); }
    //! Send datagram to the given endpoint (asynchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return 'true' if the datagram was successfully sent, 'false' if the datagram was not sent
    */
    virtual bool SendAsync(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size);
    //! Send text to the given endpoint (asynchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the text was not sent
    */
    virtual bool SendAsync(const asio::ip::udp::endpoint& endpoint, std::string_view text) { return SendAsync(endpoint, text.data(), text.size()); }

    //! Receive datagram from the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param buffer - Datagram buffer to receive
        \param size - Datagram buffer size to receive
        \return Size of received datagram
    */
    virtual size_t Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size);
    //! Receive text from the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(asio::ip::udp::endpoint& endpoint, size_t size);

    //! Receive datagram from the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param buffer - Datagram buffer to receive
        \param size - Datagram buffer size to receive
        \param timeout - Timeout
        \return Size of received datagram
    */
    virtual size_t Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(asio::ip::udp::endpoint& endpoint, size_t size, const CppCommon::Timespan& timeout);

    //! Receive datagram from the server (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: reuse address
    /*!
        This option will enable/disable SO_REUSEADDR if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReuseAddress(bool enable) noexcept { _option_reuse_address = enable; }
    //! Setup option: reuse port
    /*!
        This option will enable/disable SO_REUSEPORT if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReusePort(bool enable) noexcept { _option_reuse_port = enable; }
    //! Setup option: bind the socket to the multicast UDP server
    /*!
        \param enable - Enable/disable option
    */
    void SetupMulticast(bool enable) noexcept { _option_reuse_address = enable; _option_multicast = enable; }
    //! Setup option: receive buffer limit
    /*!
        The client will be disconnected if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) noexcept { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The client will be disconnected if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) noexcept { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle client connected notification
    virtual void onConnected() {}
    //! Handle client disconnected notification
    virtual void onDisconnected() {}

    //! Handle client joined multicast group notification
    /*!
        \param address - Multicast group address
    */
    virtual void onJoinedMulticastGroup(const std::string& address) {}
    //! Handle client left multicast group notification
    /*!
        \param address - Multicast group address
    */
    virtual void onLeftMulticastGroup(const std::string& address) {}

    //! Handle datagram received notification
    /*!
        Notification is called when another datagram was received
        from some endpoint.

        \param endpoint - Received endpoint
        \param buffer - Received datagram buffer
        \param size - Received datagram buffer size
    */
    virtual void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) {}
    //! Handle datagram sent notification
    /*!
        Notification is called when a datagram was sent to the server.

        This handler could be used to send another datagram to the server
        for instance when the pending size is zero.

        \param endpoint - Endpoint of sent datagram
        \param sent - Size of sent datagram buffer
    */
    virtual void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Client Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    std::string _scheme;
    int _port;
    // Server endpoint & client socket
    asio::ip::udp::endpoint _endpoint;
    asio::ip::udp::socket _socket;
    std::atomic<bool> _resolving;
    std::atomic<bool> _connected;
    // Client statistic
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    uint64_t _datagrams_sent;
    uint64_t _datagrams_received;
    // Receive and send endpoints
    asio::ip::udp::endpoint _receive_endpoint;
    asio::ip::udp::endpoint _send_endpoint;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer;
    HandlerStorage _send_storage;
    // Options
    bool _option_reuse_address;
    bool _option_reuse_port;
    bool _option_multicast;

    //! Disconnect the client (internal synchronous)
    bool DisconnectInternal();
    //! Disconnect the client (internal asynchronous)
    bool DisconnectInternalAsync(bool dispatch);

    //! Try to receive new datagram
    void TryReceive();

    //! Clear send/receive buffers
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example udp_echo_client.cpp UDP echo client example */
/*! \example udp_multicast_client.cpp UDP multicast client example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_UDP_CLIENT_H

```

`include/server/asio/udp_resolver.h`:

```h
/*!
    \file udp_resolver.h
    \brief UDP resolver definition
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_UDP_RESOLVER_H
#define CPPSERVER_ASIO_UDP_RESOLVER_H

#include "service.h"

namespace CppServer {
namespace Asio {

//! UDP resolver
/*!
    UDP resolver is used to resolve DNS while connecting UDP clients.

    Thread-safe.
*/
class UDPResolver
{
public:
    //! Initialize resolver with a given Asio service
    /*!
        \param service - Asio service
    */
    UDPResolver(const std::shared_ptr<Service>& service);
    UDPResolver(const UDPResolver&) = delete;
    UDPResolver(UDPResolver&&) = delete;
    virtual ~UDPResolver() { Cancel(); }

    UDPResolver& operator=(const UDPResolver&) = delete;
    UDPResolver& operator=(UDPResolver&&) = delete;

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the UDP resolver
    asio::ip::udp::resolver& resolver() noexcept { return _resolver; }

    //! Cancel any asynchronous operations that are waiting on the resolver
    virtual void Cancel() { _resolver.cancel(); }

private:
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // UDP resolver
    asio::ip::udp::resolver _resolver;
};

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_UDP_RESOLVER_H

```

`include/server/asio/udp_server.h`:

```h
/*!
    \file udp_server.h
    \brief UDP server definition
    \author Ivan Shynkarenka
    \date 22.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_ASIO_UDP_SERVER_H
#define CPPSERVER_ASIO_UDP_SERVER_H

#include "service.h"

#include "system/uuid.h"

namespace CppServer {
namespace Asio {

//! UDP server
/*!
    UDP server is used to send or multicast datagrams to UDP endpoints.

    Thread-safe.
*/
class UDPServer : public std::enable_shared_from_this<UDPServer>
{
public:
    //! Initialize UDP server with a given Asio service and port number
    /*!
        \param service - Asio service
        \param port - Port number
        \param protocol - Internet protocol type (default is IPv4)
    */
    UDPServer(const std::shared_ptr<Service>& service, int port, InternetProtocol protocol = InternetProtocol::IPv4);
    //! Initialize UDP server with a given Asio service, server address and port number
    /*!
        \param service - Asio service
        \param address - Server address
        \param port - Port number
    */
    UDPServer(const std::shared_ptr<Service>& service, const std::string& address, int port);
    //! Initialize UDP server with a given Asio service and endpoint
    /*!
        \param service - Asio service
        \param endpoint - Server UDP endpoint
    */
    UDPServer(const std::shared_ptr<Service>& service, const asio::ip::udp::endpoint& endpoint);
    UDPServer(const UDPServer&) = delete;
    UDPServer(UDPServer&&) = delete;
    virtual ~UDPServer() = default;

    UDPServer& operator=(const UDPServer&) = delete;
    UDPServer& operator=(UDPServer&&) = delete;

    //! Get the server Id
    const CppCommon::UUID& id() const noexcept { return _id; }

    //! Get the Asio service
    std::shared_ptr<Service>& service() noexcept { return _service; }
    //! Get the Asio IO service
    std::shared_ptr<asio::io_service>& io_service() noexcept { return _io_service; }
    //! Get the Asio service strand for serialized handler execution
    asio::io_service::strand& strand() noexcept { return _strand; }
    //! Get the server endpoint
    asio::ip::udp::endpoint& endpoint() noexcept { return _endpoint; }
    //! Get the server multicast endpoint
    asio::ip::udp::endpoint& multicast_endpoint() noexcept { return _multicast_endpoint; }

    //! Get the server address
    const std::string& address() const noexcept { return _address; }
    //! Get the server port number
    int port() const noexcept { return _port; }

    //! Get the number of bytes pending sent by the server
    uint64_t bytes_pending() const noexcept { return _bytes_sending; }
    //! Get the number of bytes sent by the server
    uint64_t bytes_sent() const noexcept { return _bytes_sent; }
    //! Get the number of bytes received by the server
    uint64_t bytes_received() const noexcept { return _bytes_received; }
    //! Get the number datagrams sent by the server
    uint64_t datagrams_sent() const noexcept { return _datagrams_sent; }
    //! Get the number datagrams received by the server
    uint64_t datagrams_received() const noexcept { return _datagrams_received; }

    //! Get the option: reuse address
    bool option_reuse_address() const noexcept { return _option_reuse_address; }
    //! Get the option: reuse port
    bool option_reuse_port() const noexcept { return _option_reuse_port; }
    //! Get the option: receive buffer limit
    size_t option_receive_buffer_limit() const noexcept { return _receive_buffer_limit; }
    //! Get the option: receive buffer size
    size_t option_receive_buffer_size() const;
    //! Get the option: send buffer limit
    size_t option_send_buffer_limit() const noexcept { return _send_buffer_limit; }
    //! Get the option: send buffer size
    size_t option_send_buffer_size() const;

    //! Is the server started?
    bool IsStarted() const noexcept { return _started; }

    //! Start the server
    /*!
        \return 'true' if the server was successfully started, 'false' if the server failed to start
    */
    virtual bool Start();
    //! Start the server with a given multicast address and port number
    /*!
        \param multicast_address - Multicast address
        \param multicast_port - Multicast port number

        \return 'true' if the server was successfully started, 'false' if the server failed to start
    */
    virtual bool Start(const std::string& multicast_address, int multicast_port);
    //! Start the server with a given multicast endpoint
    /*!
        \param multicast_endpoint - Multicast UDP endpoint

        \return 'true' if the server was successfully started, 'false' if the server failed to start
    */
    virtual bool Start(const asio::ip::udp::endpoint& multicast_endpoint);
    //! Stop the server
    /*!
        \return 'true' if the server was successfully stopped, 'false' if the server is already stopped
    */
    virtual bool Stop();
    //! Restart the server
    /*!
        \return 'true' if the server was successfully restarted, 'false' if the server failed to restart
    */
    virtual bool Restart();

    //! Multicast datagram to the prepared mulicast endpoint (synchronous)
    /*!
        \param buffer - Datagram buffer to multicast
        \param size - Datagram buffer size
        \return Size of multicasted datagram
    */
    virtual size_t Multicast(const void* buffer, size_t size);
    //! Multicast text to the prepared mulicast endpoint (synchronous)
    /*!
        \param text - Text to multicast
        \return Size of multicasted datagram
    */
    virtual size_t Multicast(std::string_view text) { return Multicast(text.data(), text.size()); }

    //! Multicast datagram to the prepared mulicast endpoint with timeout (synchronous)
    /*!
        \param buffer - Datagram buffer to multicast
        \param size - Datagram buffer size
        \param timeout - Timeout
        \return Size of multicasted datagram
    */
    virtual size_t Multicast(const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Multicast text to the prepared mulicast endpoint with timeout (synchronous)
    /*!
        \param text - Text to multicast
        \param timeout - Timeout
        \return Size of multicasted datagram
    */
    virtual size_t Multicast(std::string_view text, const CppCommon::Timespan& timeout) { return Multicast(text.data(), text.size(), timeout); }

    //! Multicast datagram to the prepared mulicast endpoint (asynchronous)
    /*!
        \param buffer - Datagram buffer to multicast
        \param size - Datagram buffer size
        \return 'true' if the datagram was successfully multicasted, 'false' if the datagram was not multicasted
    */
    virtual bool MulticastAsync(const void* buffer, size_t size);
    //! Multicast text to the prepared mulicast endpoint (asynchronous)
    /*!
        \param text - Text to multicast
        \return 'true' if the text was successfully multicasted, 'false' if the text was not multicasted
    */
    virtual bool MulticastAsync(std::string_view text) { return MulticastAsync(text.data(), text.size()); }

    //! Send datagram into the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size);
    //! Send text into the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, std::string_view text) { return Send(endpoint, text.data(), text.size()); }

    //! Send datagram into the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Send text into the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \param timeout - Timeout
        \return Size of sent datagram
    */
    virtual size_t Send(const asio::ip::udp::endpoint& endpoint, std::string_view text, const CppCommon::Timespan& timeout) { return Send(endpoint, text.data(), text.size(), timeout); }

    //! Send datagram into the given endpoint (asynchronous)
    /*!
        \param endpoint - Endpoint to send
        \param buffer - Datagram buffer to send
        \param size - Datagram buffer size
        \return 'true' if the datagram was successfully sent, 'false' if the datagram was not sent
    */
    virtual bool SendAsync(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size);
    //! Send text into the given endpoint (asynchronous)
    /*!
        \param endpoint - Endpoint to send
        \param text - Text to send
        \return 'true' if the text was successfully sent, 'false' if the text was not sent
    */
    virtual bool SendAsync(const asio::ip::udp::endpoint& endpoint, std::string_view text) { return SendAsync(endpoint, text.data(), text.size()); }

    //! Receive datagram from the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param buffer - Datagram buffer to receive
        \param size - Datagram buffer size to receive
        \return Size of received datagram
    */
    virtual size_t Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size);
    //! Receive text from the given endpoint (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param size - Text size to receive
        \return Received text
    */
    virtual std::string Receive(asio::ip::udp::endpoint& endpoint, size_t size);

    //! Receive datagram from the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param buffer - Datagram buffer to receive
        \param size - Datagram buffer size to receive
        \param timeout - Timeout
        \return Size of received datagram
    */
    virtual size_t Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size, const CppCommon::Timespan& timeout);
    //! Receive text from the given endpoint with timeout (synchronous)
    /*!
        \param endpoint - Endpoint to receive from
        \param size - Text size to receive
        \param timeout - Timeout
        \return Received text
    */
    virtual std::string Receive(asio::ip::udp::endpoint& endpoint, size_t size, const CppCommon::Timespan& timeout);

    //! Receive datagram from the client (asynchronous)
    virtual void ReceiveAsync();

    //! Setup option: reuse address
    /*!
        This option will enable/disable SO_REUSEADDR if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReuseAddress(bool enable) noexcept { _option_reuse_address = enable; }
    //! Setup option: reuse port
    /*!
        This option will enable/disable SO_REUSEPORT if the OS support this feature.

        \param enable - Enable/disable option
    */
    void SetupReusePort(bool enable) noexcept { _option_reuse_port = enable; }
    //! Setup option: receive buffer limit
    /*!
        The receive operation will fail if the receive buffer limit is met.
        Default is unlimited.

        \param limit - Receive buffer limit
    */
    void SetupReceiveBufferLimit(size_t limit) noexcept { _receive_buffer_limit = limit; }
    //! Setup option: receive buffer size
    /*!
        This option will setup SO_RCVBUF if the OS support this feature.

        \param size - Receive buffer size
    */
    void SetupReceiveBufferSize(size_t size);
    //! Setup option: send buffer limit
    /*!
        The send operation will fail if the send buffer limit is met.
        Default is unlimited.

        \param limit - Send buffer limit
    */
    void SetupSendBufferLimit(size_t limit) noexcept { _send_buffer_limit = limit; }
    //! Setup option: send buffer size
    /*!
        This option will setup SO_SNDBUF if the OS support this feature.

        \param size - Send buffer size
    */
    void SetupSendBufferSize(size_t size);

protected:
    //! Handle server started notification
    virtual void onStarted() {}
    //! Handle server stopped notification
    virtual void onStopped() {}

    //! Handle datagram received notification
    /*!
        Notification is called when another datagram was received from
        some endpoint.

        \param endpoint - Received endpoint
        \param buffer - Received datagram buffer
        \param size - Received datagram buffer size
    */
    virtual void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) {}
    //! Handle datagram sent notification
    /*!
        Notification is called when a datagram was sent to the client.

        This handler could be used to send another datagram to the client
        for instance when the pending size is zero.

        \param endpoint - Endpoint of sent datagram
        \param sent - Size of sent datagram buffer
    */
    virtual void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) {}

    //! Handle error notification
    /*!
        \param error - Error code
        \param category - Error category
        \param message - Error message
    */
    virtual void onError(int error, const std::string& category, const std::string& message) {}

private:
    // Server Id
    CppCommon::UUID _id;
    // Asio service
    std::shared_ptr<Service> _service;
    // Asio IO service
    std::shared_ptr<asio::io_service> _io_service;
    // Asio service strand for serialized handler execution
    asio::io_service::strand _strand;
    bool _strand_required;
    // Server address, scheme & port
    std::string _address;
    int _port;
    // Server endpoint & socket
    asio::ip::udp::endpoint _endpoint;
    asio::ip::udp::socket _socket;
    std::atomic<bool> _started;
    // Server statistic
    uint64_t _bytes_sending;
    uint64_t _bytes_sent;
    uint64_t _bytes_received;
    uint64_t _datagrams_sent;
    uint64_t _datagrams_received;
    // Multicast, receive and send endpoints
    asio::ip::udp::endpoint _multicast_endpoint;
    asio::ip::udp::endpoint _receive_endpoint;
    asio::ip::udp::endpoint _send_endpoint;
    // Receive buffer
    bool _receiving;
    size_t _receive_buffer_limit{0};
    std::vector<uint8_t> _receive_buffer;
    HandlerStorage _receive_storage;
    // Send buffer
    bool _sending;
    size_t _send_buffer_limit{0};
    std::vector<uint8_t> _send_buffer;
    HandlerStorage _send_storage;
    // Options
    bool _option_reuse_address;
    bool _option_reuse_port;

    //! Try to receive new datagram
    void TryReceive();

    //! Clear send/receive buffers
    void ClearBuffers();

    //! Send error notification
    void SendError(std::error_code ec);
};

/*! \example udp_echo_server.cpp UDP echo server example */
/*! \example udp_multicast_server.cpp UDP multicast server example */

} // namespace Asio
} // namespace CppServer

#endif // CPPSERVER_ASIO_UDP_SERVER_H

```

`include/server/http/http.h`:

```h
/*!
    \file http.h
    \brief HTTP C++ Library definition
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_H
#define CPPSERVER_HTTP_H

namespace CppServer {

/*!
    \namespace CppServer::HTTP
    \brief HTTP definitions
*/
namespace HTTP {

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_H

```

`include/server/http/http_client.h`:

```h
/*!
    \file http_client.h
    \brief HTTP client definition
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTP_CLIENT_H
#define CPPSERVER_HTTP_HTTP_CLIENT_H

#include "http_request.h"
#include "http_response.h"

#include "server/asio/tcp_client.h"
#include "server/asio/timer.h"

#include <future>

namespace CppServer {
namespace HTTP {

//! HTTP client
/*!
    HTTP client is used to communicate with HTTP Web server.
    It allows to send GET, POST, PUT, DELETE requests and
    receive HTTP result.

    Thread-safe.
*/
class HTTPClient : public Asio::TCPClient
{
public:
    using TCPClient::TCPClient;

    HTTPClient(const HTTPClient&) = delete;
    HTTPClient(HTTPClient&&) = delete;
    virtual ~HTTPClient() = default;

    HTTPClient& operator=(const HTTPClient&) = delete;
    HTTPClient& operator=(HTTPClient&&) = delete;

    //! Get the HTTP request
    HTTPRequest& request() noexcept { return _request; }
    const HTTPRequest& request() const noexcept { return _request; }

    //! Send the current HTTP request (synchronous)
    /*!
        \return Size of sent data
    */
    size_t SendRequest() { return SendRequest(_request); }
    //! Send the HTTP request (synchronous)
    /*!
        \param request - HTTP request
        \return Size of sent data
    */
    size_t SendRequest(const HTTPRequest& request) { return Send(request.cache()); }

    //! Send the HTTP request body (synchronous)
    /*!
        \param body - HTTP request body
        \return Size of sent data
    */
    size_t SendRequestBody(std::string_view body) { return Send(body); }
    //! Send the HTTP request body (synchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \return Size of sent data
    */
    size_t SendRequestBody(const void* buffer, size_t size) { return Send(buffer, size); }

    //! Send the current HTTP request with timeout (synchronous)
    /*!
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequest(const CppCommon::Timespan& timeout) { return SendRequest(_request, timeout); }
    //! Send the HTTP request with timeout (synchronous)
    /*!
        \param request - HTTP request
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout) { return Send(request.cache(), timeout); }

    //! Send the HTTP request body with timeout (synchronous)
    /*!
        \param body - HTTP request body
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequestBody(std::string_view body, const CppCommon::Timespan& timeout) { return Send(body, timeout); }
    //! Send the HTTP request body with timeout (synchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequestBody(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { return Send(buffer, size, timeout); }

    //! Send the current HTTP request (asynchronous)
    /*!
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestAsync() { return SendRequestAsync(_request); }
    //! Send the HTTP request (asynchronous)
    /*!
        \param request - HTTP request
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestAsync(const HTTPRequest& request) { return SendAsync(request.cache()); }

    //! Send the HTTP request body (asynchronous)
    /*!
        \param body - HTTP request body
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestBodyAsync(std::string_view body) { return SendAsync(body); }
    //! Send the HTTP request body (asynchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestBodyAsync(const void* buffer, size_t size) { return SendAsync(buffer, size); }

protected:
    void onReceived(const void* buffer, size_t size) override;
    void onDisconnected() override;

    //! Handle HTTP response header received notification
    /*!
        Notification is called when HTTP response header was received
        from the server.

        \param response - HTTP response
    */
    virtual void onReceivedResponseHeader(const HTTPResponse& response) {}

    //! Handle HTTP response received notification
    /*!
        Notification is called when HTTP response was received
        from the server.

        \param response - HTTP response
    */
    virtual void onReceivedResponse(const HTTPResponse& response) {}

    //! Handle HTTP response error notification
    /*!
        Notification is called when HTTP response error was received
        from the server.

        \param response - HTTP response
        \param error - HTTP response error
    */
    virtual void onReceivedResponseError(const HTTPResponse& response, const std::string& error) {}

protected:
    //! HTTP request
    HTTPRequest _request;
    //! HTTP response
    HTTPResponse _response;
};

//! HTTP extended client
/*!
    HTTP extended client make requests to HTTP Web server with returning std::future
    as a synchronization primitive.

    Thread-safe.
*/
class HTTPClientEx : public HTTPClient
{
public:
    using HTTPClient::HTTPClient;

    //! Get the TCP resolver
    std::shared_ptr<Asio::TCPResolver>& resolver() noexcept { return _resolver; }
    const std::shared_ptr<Asio::TCPResolver>& resolver() const noexcept { return _resolver; }
    //! Get the timeout check timer
    std::shared_ptr<Asio::Timer>& timeout() noexcept { return _timeout; }
    const std::shared_ptr<Asio::Timer>& timeout() const noexcept { return _timeout; }

    //! Send HTTP request
    /*!
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendRequest(const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1)) { return SendRequest(_request, timeout); }
    //! HTTP request
    /*!
        \param request - HTTP request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1));

    //! Send HEAD request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendHeadRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeHeadRequest(url), timeout); }
    //! Send GET request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendGetRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeGetRequest(url), timeout); }
    //! Send POST request
    /*!
        \param url - URL to request
        \param content - Content
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendPostRequest(std::string_view url, std::string_view content, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakePostRequest(url, content), timeout); }
    //! Send PUT request
    /*!
        \param url - URL to request
        \param content - Content
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendPutRequest(std::string_view url, std::string_view content, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakePutRequest(url, content), timeout); }
    //! Send DELETE request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendDeleteRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeDeleteRequest(url), timeout); }
    //! Send OPTIONS request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendOptionsRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeOptionsRequest(url), timeout); }
    //! Send TRACE request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendTraceRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeTraceRequest(url), timeout); }

protected:
    void onConnected() override;
    void onDisconnected() override;
    void onReceivedResponse(const HTTPResponse& response) override;
    void onReceivedResponseError(const HTTPResponse& response, const std::string& error) override;

private:
    std::shared_ptr<Asio::TCPResolver> _resolver;
    std::shared_ptr<Asio::Timer> _timeout;
    std::promise<HTTPResponse> _promise;

    void SetPromiseValue(const HTTPResponse& response);
    void SetPromiseError(const std::string& error);
};

/*! \example http_client.cpp HTTP client example */

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTP_CLIENT_H

```

`include/server/http/http_request.h`:

```h
/*!
    \file http_request.h
    \brief HTTP request definition
    \author Ivan Shynkarenka
    \date 07.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTP_REQUEST_H
#define CPPSERVER_HTTP_HTTP_REQUEST_H

#include "http.h"

#include <sstream>
#include <string>
#include <string_view>
#include <tuple>
#include <vector>

namespace CppServer {
namespace HTTP {

//! HTTP request
/*!
    HTTP request is used to create or process parameters
    of HTTP protocol request (method, URL, headers, etc).

    Not thread-safe.
*/
class HTTPRequest
{
    friend class HTTPSession;
    friend class HTTPSSession;

public:
    //! Initialize an empty HTTP request
    HTTPRequest() { Clear(); }
    //! Initialize a new HTTP request with a given method, URL and protocol
    /*!
        \param method - HTTP method
        \param url - Requested URL
        \param protocol - Protocol version (default is "HTTP/1.1")
    */
    HTTPRequest(std::string_view method, std::string_view url, std::string_view protocol = "HTTP/1.1") { SetBegin(method, url, protocol); }
    HTTPRequest(const HTTPRequest&) = default;
    HTTPRequest(HTTPRequest&&) = default;
    ~HTTPRequest() = default;

    HTTPRequest& operator=(const HTTPRequest&) = default;
    HTTPRequest& operator=(HTTPRequest&&) = default;

    //! Is the HTTP request empty?
    bool empty() const noexcept { return _cache.empty(); }
    //! Is the HTTP request error flag set?
    bool error() const noexcept { return _error; }

    //! Get the HTTP request method
    std::string_view method() const noexcept { return std::string_view(_cache.data() + _method_index, _method_size); }
    //! Get the HTTP request URL
    std::string_view url() const noexcept { return std::string_view(_cache.data() + _url_index, _url_size); }
    //! Get the HTTP request protocol version
    std::string_view protocol() const noexcept { return std::string_view(_cache.data() + _protocol_index, _protocol_size); }
    //! Get the HTTP request headers count
    size_t headers() const noexcept { return _headers.size(); }
    //! Get the HTTP request header by index
    std::tuple<std::string_view, std::string_view> header(size_t i) const noexcept;
    //! Get the HTTP request cookies count
    size_t cookies() const noexcept { return _cookies.size(); }
    //! Get the HTTP request cookie by index
    std::tuple<std::string_view, std::string_view> cookie(size_t i) const noexcept;
    //! Get the HTTP request body
    std::string_view body() const noexcept { return std::string_view(_cache.data() + _body_index, _body_size); }
    //! Get the HTTP request body length
    size_t body_length() const noexcept { return _body_length; }

    //! Get the HTTP request cache content
    const std::string& cache() const noexcept { return _cache; }

    //! Get string from the current HTTP request
    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    //! Clear the HTTP request cache
    HTTPRequest& Clear();

    //! Set the HTTP request begin with a given method, URL and protocol
    /*!
        \param method - HTTP method
        \param url - Requested URL
        \param protocol - Protocol version (default is "HTTP/1.1")
    */
    HTTPRequest& SetBegin(std::string_view method, std::string_view url, std::string_view protocol = "HTTP/1.1");
    //! Set the HTTP request header
    /*!
        \param key - Header key
        \param value - Header value
    */
    HTTPRequest& SetHeader(std::string_view key, std::string_view value);
    //! Set the HTTP request cookie
    /*!
        \param name - Cookie name
        \param value - Cookie value
    */
    HTTPRequest& SetCookie(std::string_view name, std::string_view value);
    //! Add the HTTP request cookie
    /*!
        \param name - Cookie name
        \param value - Cookie value
    */
    HTTPRequest& AddCookie(std::string_view name, std::string_view value);
    //! Set the HTTP request body
    /*!
        \param body - Body content (default is "")
    */
    HTTPRequest& SetBody(std::string_view body = "");
    //! Set the HTTP request body length
    /*!
        \param length - Body length
    */
    HTTPRequest& SetBodyLength(size_t length);

    //! Make HEAD request
    /*!
        \param url - URL to request
        \return HTTP request
    */
    HTTPRequest& MakeHeadRequest(std::string_view url);
    //! Make GET request
    /*!
        \param url - URL to request
        \return HTTP request
    */
    HTTPRequest& MakeGetRequest(std::string_view url);
    //! Make POST request
    /*!
        \param url - URL to request
        \param content - Content
        \param content_type - Content type (default is "text/plain; charset=UTF-8")
        \return HTTP request
    */
    HTTPRequest& MakePostRequest(std::string_view url, std::string_view content, std::string_view content_type = "text/plain; charset=UTF-8");
    //! Make PUT request
    /*!
        \param url - URL to request
        \param content - Content
        \param content_type - Content type (default is "text/plain; charset=UTF-8")
        \return HTTP request
    */
    HTTPRequest& MakePutRequest(std::string_view url, std::string_view content, std::string_view content_type = "text/plain; charset=UTF-8");
    //! Make DELETE request
    /*!
        \param url - URL to request
        \return HTTP request
    */
    HTTPRequest& MakeDeleteRequest(std::string_view url);
    //! Make OPTIONS request
    /*!
        \param url - URL to request
        \return HTTP request
    */
    HTTPRequest& MakeOptionsRequest(std::string_view url);
    //! Make TRACE request
    /*!
        \param url - URL to request
        \return HTTP request
    */
    HTTPRequest& MakeTraceRequest(std::string_view url);

    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const HTTPRequest& request);

    //! Swap two instances
    void swap(HTTPRequest& request) noexcept;
    friend void swap(HTTPRequest& request1, HTTPRequest& request2) noexcept { request1.swap(request2); }

private:
    // HTTP request error flag
    bool _error;
    // HTTP request method
    size_t _method_index;
    size_t _method_size;
    // HTTP request URL
    size_t _url_index;
    size_t _url_size;
    // HTTP request protocol
    size_t _protocol_index;
    size_t _protocol_size;
    // HTTP request headers
    std::vector<std::tuple<size_t, size_t, size_t, size_t>> _headers;
    // HTTP request cookies
    std::vector<std::tuple<size_t, size_t, size_t, size_t>> _cookies;
    // HTTP request body
    size_t _body_index;
    size_t _body_size;
    size_t _body_length;
    bool _body_length_provided;

    // HTTP request cache
    std::string _cache;
    size_t _cache_size;

    // Is pending parts of HTTP response
    bool IsPendingHeader() const;
    bool IsPendingBody() const;

    // Receive parts of HTTP response
    bool ReceiveHeader(const void* buffer, size_t size);
    bool ReceiveBody(const void* buffer, size_t size);

    // Fast convert integer value to the corresponding string representation
    std::string_view FastConvert(size_t value, char* buffer, size_t size);
};

} // namespace HTTP
} // namespace CppServer

#include "http_request.inl"

#endif // CPPSERVER_HTTP_HTTP_REQUEST_H

```

`include/server/http/http_request.inl`:

```inl
/*!
    \file http_request.inl
    \brief HTTP request inline implementation
    \author Ivan Shynkarenka
    \date 07.02.2019
    \copyright MIT License
*/

#if defined(FMT_VERSION)
template <> struct fmt::formatter<CppServer::HTTP::HTTPRequest> : ostream_formatter {};
#endif

//! \cond DOXYGEN_SKIP
template <>
struct std::hash<CppServer::HTTP::HTTPRequest>
{
    typedef CppServer::HTTP::HTTPRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<std::string>()(value.cache());
        return result;
    }
};
//! \endcond

```

`include/server/http/http_response.h`:

```h
/*!
    \file http_response.h
    \brief HTTP response definition
    \author Ivan Shynkarenka
    \date 15.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTP_RESPONSE_H
#define CPPSERVER_HTTP_HTTP_RESPONSE_H

#include "http.h"

#include "time/time.h"

#include <sstream>
#include <string>
#include <string_view>
#include <tuple>
#include <unordered_map>
#include <vector>

namespace CppServer {
namespace HTTP {

//! HTTP response
/*!
    HTTP response is used to create or process parameters
    of HTTP protocol response (status, headers, etc).

    Not thread-safe.
*/
class HTTPResponse
{
    friend class HTTPClient;
    friend class HTTPSClient;

public:
    //! Initialize an empty HTTP response
    HTTPResponse() { Clear(); }
    //! Initialize a new HTTP response with a given status and protocol
    /*!
        \param status - HTTP status
        \param protocol - Protocol version (default is "HTTP/1.1")
    */
    HTTPResponse(int status, std::string_view protocol = "HTTP/1.1") { SetBegin(status, protocol); }
    //! Initialize a new HTTP response with a given status, status phrase and protocol
    /*!
        \param status - HTTP status
        \param status_phrase - HTTP status phrase
        \param protocol - Protocol version
    */
    HTTPResponse(int status, std::string_view status_phrase, std::string_view protocol) { SetBegin(status, status_phrase, protocol); }
    HTTPResponse(const HTTPResponse&) = default;
    HTTPResponse(HTTPResponse&&) = default;
    ~HTTPResponse() = default;

    HTTPResponse& operator=(const HTTPResponse&) = default;
    HTTPResponse& operator=(HTTPResponse&&) = default;

    //! Is the HTTP response empty?
    bool empty() const noexcept { return _cache.empty(); }
    //! Is the HTTP response error flag set?
    bool error() const noexcept { return _error; }

    //! Get the HTTP response status
    int status() const noexcept { return _status; }
    //! Get the HTTP response status phrase
    std::string_view status_phrase() const noexcept { return std::string_view(_cache.data() + _status_phrase_index, _status_phrase_size); }
    //! Get the HTTP response protocol version
    std::string_view protocol() const noexcept { return std::string_view(_cache.data() + _protocol_index, _protocol_size); }
    //! Get the HTTP response headers count
    size_t headers() const noexcept { return _headers.size(); }
    //! Get the HTTP response header by index
    std::tuple<std::string_view, std::string_view> header(size_t i) const noexcept;
    //! Get the HTTP response body
    std::string_view body() const noexcept { return std::string_view(_cache.data() + _body_index, _body_size); }
    //! Get the HTTP response body length
    size_t body_length() const noexcept { return _body_length; }

    //! Get the HTTP response cache content
    const std::string& cache() const noexcept { return _cache; }

    //! Get string from the current HTTP response
    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    //! Clear the HTTP response cache
    HTTPResponse& Clear();

    //! Set the HTTP response begin with a given status and protocol
    /*!
        \param status - HTTP status
        \param protocol - Protocol version (default is "HTTP/1.1")
    */
    HTTPResponse& SetBegin(int status, std::string_view protocol = "HTTP/1.1");
    //! Set the HTTP response begin with a given status, status phrase and protocol
    /*!
        \param status - HTTP status
        \param status_phrase - HTTP status phrase
        \param protocol - Protocol version
    */
    HTTPResponse& SetBegin(int status, std::string_view status_phrase, std::string_view protocol);
    //! Set the HTTP response content type
    /*!
        \param extension - Content extension
    */
    HTTPResponse& SetContentType(std::string_view extension);
    //! Set the HTTP response header
    /*!
        \param key - Header key
        \param value - Header value
    */
    HTTPResponse& SetHeader(std::string_view key, std::string_view value);
    //! Set the HTTP response cookie
    /*!
        \param name - Cookie name
        \param value - Cookie value
        \param max_age - Cookie age in seconds until it expires (default is 86400)
        \param path - Cookie path (default is "")
        \param domain - Cookie domain (default is "")
        \param secure - Cookie secure flag (default is true)
        \param strict - Cookie strict flag (default is true)
        \param http_only - Cookie HTTP-only flag (default is true)
    */
    HTTPResponse& SetCookie(std::string_view name, std::string_view value, size_t max_age = 86400, std::string_view path = "", std::string_view domain = "", bool secure = true, bool strict = true, bool http_only = true);
    //! Set the HTTP response body
    /*!
        \param body - Body content (default is "")
    */
    HTTPResponse& SetBody(std::string_view body = "");
    //! Set the HTTP response body length
    /*!
        \param length - Body length
    */
    HTTPResponse& SetBodyLength(size_t length);

    //! Make OK response
    /*!
        \param status - OK status (default is 200 (OK))
        \return HTTP response
    */
    HTTPResponse& MakeOKResponse(int status = 200);
    //! Make ERROR response
    /*!
        \param content - Error content (default is "")
        \param content_type - Error content type (default is "text/plain; charset=UTF-8")
        \return HTTP response
    */
    HTTPResponse& MakeErrorResponse(std::string_view content = "", std::string_view content_type = "text/plain; charset=UTF-8") { return MakeErrorResponse(500, content, content_type); }
    //! Make ERROR response
    /*!
        \param status - Error status
        \param content - Error content (default is "")
        \param content_type - Error content type (default is "text/plain; charset=UTF-8")
        \return HTTP response
    */
    HTTPResponse& MakeErrorResponse(int status, std::string_view content = "", std::string_view content_type = "text/plain; charset=UTF-8");
    //! Make HEAD response
    /*!
        \return HTTP response
    */
    HTTPResponse& MakeHeadResponse();
    //! Make GET response
    /*!
        \param content - Content (default is "")
        \param content_type - Content type (default is "text/plain; charset=UTF-8")
        \return HTTP response
    */
    HTTPResponse& MakeGetResponse(std::string_view content = "", std::string_view content_type = "text/plain; charset=UTF-8");
    //! Make OPTIONS response
    /*!
        \param allow - Allow methods (default is "HEAD,GET,POST,PUT,DELETE,OPTIONS,TRACE")
        \return HTTP response
    */
    HTTPResponse& MakeOptionsResponse(std::string_view allow = "HEAD,GET,POST,PUT,DELETE,OPTIONS,TRACE");
    //! Make TRACE response
    /*!
        \param request - Request content
        \return HTTP response
    */
    HTTPResponse& MakeTraceResponse(std::string_view request);

    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const HTTPResponse& response);

    //! Swap two instances
    void swap(HTTPResponse& response) noexcept;
    friend void swap(HTTPResponse& response1, HTTPResponse& response2) noexcept { response1.swap(response2); }

private:
    // HTTP response error flag
    bool _error;
    // HTTP response status
    int _status;
    // HTTP response status phrase
    size_t _status_phrase_index;
    size_t _status_phrase_size;
    // HTTP response protocol
    size_t _protocol_index;
    size_t _protocol_size;
    // HTTP response headers
    std::vector<std::tuple<size_t, size_t, size_t, size_t>> _headers;
    // HTTP response body
    size_t _body_index;
    size_t _body_size;
    size_t _body_length;
    bool _body_length_provided;

    // HTTP response cache
    std::string _cache;
    size_t _cache_size;

    // HTTP response mime table
    static const std::unordered_map<std::string, std::string> _mime_table;

    // Is pending parts of HTTP response
    bool IsPendingHeader() const;
    bool IsPendingBody() const;

    // Receive parts of HTTP response
    bool ReceiveHeader(const void* buffer, size_t size);
    bool ReceiveBody(const void* buffer, size_t size);

    // Fast convert integer value to the corresponding string representation
    std::string_view FastConvert(size_t value, char* buffer, size_t size);
};

} // namespace HTTP
} // namespace CppServer

#include "http_response.inl"

#endif // CPPSERVER_HTTP_HTTP_RESPONSE_H

```

`include/server/http/http_response.inl`:

```inl
/*!
    \file http_response.inl
    \brief HTTP response inline implementation
    \author Ivan Shynkarenka
    \date 15.02.2019
    \copyright MIT License
*/

#if defined(FMT_VERSION)
template <> struct fmt::formatter<CppServer::HTTP::HTTPResponse> : ostream_formatter {};
#endif

//! \cond DOXYGEN_SKIP
template <>
struct std::hash<CppServer::HTTP::HTTPResponse>
{
    typedef CppServer::HTTP::HTTPResponse argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<std::string>()(value.cache());
        return result;
    }
};
//! \endcond

```

`include/server/http/http_server.h`:

```h
/*!
    \file http_server.h
    \brief HTTP server definition
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTP_SERVER_H
#define CPPSERVER_HTTP_HTTP_SERVER_H

#include "http_session.h"

#include "cache/filecache.h"
#include "server/asio/tcp_server.h"

namespace CppServer {
namespace HTTP {

//! HTTP server
/*!
    HTTP server is used to create HTTP Web server and
    communicate with clients using HTTP protocol.
    It allows to receive GET, POST, PUT, DELETE requests and
    send HTTP responses.

    Thread-safe.
*/
class HTTPServer : public Asio::TCPServer
{
public:
    using TCPServer::TCPServer;

    HTTPServer(const HTTPServer&) = delete;
    HTTPServer(HTTPServer&&) = delete;
    virtual ~HTTPServer() = default;

    HTTPServer& operator=(const HTTPServer&) = delete;
    HTTPServer& operator=(HTTPServer&&) = delete;

    //! Get the static content cache
    CppCommon::FileCache& cache() noexcept { return _cache; }
    const CppCommon::FileCache& cache() const noexcept { return _cache; }

    //! Add static content cache
    /*!
        \param path - Static content path
        \param prefix - Cache prefix (default is "/")
        \param timeout - Refresh cache timeout (default is 1 hour)
    */
    void AddStaticContent(const CppCommon::Path& path, const std::string& prefix = "/", const CppCommon::Timespan& timeout = CppCommon::Timespan::hours(1));
    //! Remove static content cache
    /*!
        \param path - Static content path
    */
    void RemoveStaticContent(const CppCommon::Path& path) { _cache.remove_path(path); }
    //! Clear static content cache
    void ClearStaticContent() { _cache.clear(); }

    //! Watchdog the static content cache
    void Watchdog(const CppCommon::UtcTimestamp& utc = CppCommon::UtcTimestamp()) { _cache.watchdog(utc); }

protected:
    std::shared_ptr<Asio::TCPSession> CreateSession(const std::shared_ptr<Asio::TCPServer>& server) override { return std::make_shared<HTTPSession>(std::dynamic_pointer_cast<HTTPServer>(server)); }

private:
    // Static content cache
    CppCommon::FileCache _cache;
};

/*! \example http_server.cpp HTTP server example */

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTP_SERVER_H

```

`include/server/http/http_session.h`:

```h
/*!
    \file http_session.h
    \brief HTTP session definition
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTP_SESSION_H
#define CPPSERVER_HTTP_HTTP_SESSION_H

#include "http_request.h"
#include "http_response.h"

#include "cache/filecache.h"
#include "server/asio/tcp_session.h"

namespace CppServer {
namespace HTTP {

class HTTPServer;

//! HTTP session
/*!
    HTTP session is used to receive/send HTTP requests/responses from the connected HTTP client.

    Thread-safe.
*/
class HTTPSession : public Asio::TCPSession
{
public:
    explicit HTTPSession(const std::shared_ptr<HTTPServer>& server);
    HTTPSession(const HTTPSession&) = delete;
    HTTPSession(HTTPSession&&) = delete;
    virtual ~HTTPSession() = default;

    HTTPSession& operator=(const HTTPSession&) = delete;
    HTTPSession& operator=(HTTPSession&&) = delete;

    //! Get the static content cache
    CppCommon::FileCache& cache() noexcept { return _cache; }
    const CppCommon::FileCache& cache() const noexcept { return _cache; }

    //! Get the HTTP response
    HTTPResponse& response() noexcept { return _response; }
    const HTTPResponse& response() const noexcept { return _response; }

    //! Send the current HTTP response (synchronous)
    /*!
        \return Size of sent data
    */
    size_t SendResponse() { return SendResponse(_response); }
    //! Send the HTTP response (synchronous)
    /*!
        \param response - HTTP response
        \return Size of sent data
    */
    size_t SendResponse(const HTTPResponse& response) { return Send(response.cache()); }

    //! Send the HTTP response body (synchronous)
    /*!
        \param body - HTTP response body
        \return Size of sent data
    */
    size_t SendResponseBody(std::string_view body) { return Send(body); }
    //! Send the HTTP response body (synchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \return Size of sent data
    */
    size_t SendResponseBody(const void* buffer, size_t size) { return Send(buffer, size); }

    //! Send the current HTTP response with timeout (synchronous)
    /*!
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponse(const CppCommon::Timespan& timeout) { return SendResponse(_response, timeout); }
    //! Send the HTTP response with timeout (synchronous)
    /*!
        \param response - HTTP response
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponse(const HTTPResponse& response, const CppCommon::Timespan& timeout) { return Send(response.cache(), timeout); }

    //! Send the HTTP response body with timeout (synchronous)
    /*!
        \param body - HTTP response body
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponseBody(std::string_view body, const CppCommon::Timespan& timeout) { return Send(body, timeout); }
    //! Send the HTTP response body with timeout (synchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponseBody(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { return Send(buffer, size, timeout); }

    //! Send the current HTTP response (asynchronous)
    /*!
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseAsync() { return SendResponseAsync(_response); }
    //! Send the HTTP response (asynchronous)
    /*!
        \param response - HTTP response
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseAsync(const HTTPResponse& response) { return SendAsync(response.cache()); }

    //! Send the HTTP response body (asynchronous)
    /*!
        \param body - HTTP response body
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseBodyAsync(std::string_view body) { return SendAsync(body); }
    //! Send the HTTP response body (asynchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseBodyAsync(const void* buffer, size_t size) { return SendAsync(buffer, size); }

protected:
    void onReceived(const void* buffer, size_t size) override;
    void onDisconnected() override;

    //! Handle HTTP request header received notification
    /*!
        Notification is called when HTTP request header was received
        from the client.

        \param request - HTTP request
    */
    virtual void onReceivedRequestHeader(const HTTPRequest& request) {}

    //! Handle HTTP request received notification
    /*!
        Notification is called when HTTP request was received
        from the client.

        \param request - HTTP request
    */
    virtual void onReceivedRequest(const HTTPRequest& request) {}
    //! Handle HTTP cached request received notification
    /*!
        Notification is called when HTTP request was received
        from the client and the corresponding cached content
        was found.

        Default behavior is just send cached response content
        to the client.

        \param request - HTTP request
        \param content - Cached response content
    */
    virtual void onReceivedCachedRequest(const HTTPRequest& request, std::string_view content) { SendAsync(content); }

    //! Handle HTTP request error notification
    /*!
        Notification is called when HTTP request error was received
        from the client.

        \param request - HTTP request
        \param error - HTTP request error
    */
    virtual void onReceivedRequestError(const HTTPRequest& request, const std::string& error) {}

protected:
    //! HTTP request
    HTTPRequest _request;
    //! HTTP response
    HTTPResponse _response;

private:
    // Static content cache
    CppCommon::FileCache& _cache;

    void onReceivedRequestInternal(const HTTPRequest& request);
};

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTP_SESSION_H

```

`include/server/http/https_client.h`:

```h
/*!
    \file https_client.h
    \brief HTTPS client definition
    \author Ivan Shynkarenka
    \date 12.02.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTPS_CLIENT_H
#define CPPSERVER_HTTP_HTTPS_CLIENT_H

#include "http_request.h"
#include "http_response.h"

#include "server/asio/ssl_client.h"
#include "server/asio/timer.h"

#include <future>

namespace CppServer {
namespace HTTP {

//! HTTPS client
/*!
    HTTPS client is used to communicate with secured HTTPS Web server.
    It allows to send GET, POST, PUT, DELETE requests and receive HTTP
    result using secure transport.

    Thread-safe.
*/
class HTTPSClient : public Asio::SSLClient
{
public:
    using SSLClient::SSLClient;

    HTTPSClient(const HTTPSClient&) = delete;
    HTTPSClient(HTTPSClient&&) = delete;
    virtual ~HTTPSClient() = default;

    HTTPSClient& operator=(const HTTPSClient&) = delete;
    HTTPSClient& operator=(HTTPSClient&&) = delete;

    //! Get the HTTP request
    HTTPRequest& request() noexcept { return _request; }
    const HTTPRequest& request() const noexcept { return _request; }

    //! Send the current HTTP request (synchronous)
    /*!
        \return Size of sent data
    */
    size_t SendRequest() { return SendRequest(_request); }
    //! Send the HTTP request (synchronous)
    /*!
        \param request - HTTP request
        \return Size of sent data
    */
    size_t SendRequest(const HTTPRequest& request) { return Send(request.cache()); }

    //! Send the HTTP request body (synchronous)
    /*!
        \param body - HTTP request body
        \return Size of sent data
    */
    size_t SendRequestBody(std::string_view body) { return Send(body); }
    //! Send the HTTP request body (synchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \return Size of sent data
    */
    size_t SendRequestBody(const void* buffer, size_t size) { return Send(buffer, size); }

    //! Send the current HTTP request with timeout (synchronous)
    /*!
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequest(const CppCommon::Timespan& timeout) { return SendRequest(_request, timeout); }
    //! Send the HTTP request with timeout (synchronous)
    /*!
        \param request - HTTP request
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout) { return Send(request.cache(), timeout); }

    //! Send the HTTP request body with timeout (synchronous)
    /*!
        \param body - HTTP request body
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequestBody(std::string_view body, const CppCommon::Timespan& timeout) { return Send(body, timeout); }
    //! Send the HTTP request body with timeout (synchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendRequestBody(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { return Send(buffer, size, timeout); }

    //! Send the current HTTP request (asynchronous)
    /*!
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestAsync() { return SendRequestAsync(_request); }
    //! Send the HTTP request (asynchronous)
    /*!
        \param request - HTTP request
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestAsync(const HTTPRequest& request) { return SendAsync(request.cache()); }

    //! Send the HTTP request body (asynchronous)
    /*!
        \param body - HTTP request body
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestBodyAsync(std::string_view body) { return SendAsync(body); }
    //! Send the HTTP request body (asynchronous)
    /*!
        \param buffer - HTTP request body buffer
        \param size - HTTP request body size
        \return 'true' if the current HTTP request was successfully sent, 'false' if the client is not connected
    */
    bool SendRequestBodyAsync(const void* buffer, size_t size) { return SendAsync(buffer, size); }

protected:
    void onReceived(const void* buffer, size_t size) override;
    void onDisconnected() override;

    //! Handle HTTP response header received notification
    /*!
        Notification is called when HTTP response header was received
        from the server.

        \param response - HTTP response
    */
    virtual void onReceivedResponseHeader(const HTTPResponse& response) {}

    //! Handle HTTP response received notification
    /*!
        Notification is called when HTTP response was received
        from the server.

        \param response - HTTP response
    */
    virtual void onReceivedResponse(const HTTPResponse& response) {}

    //! Handle HTTP response error notification
    /*!
        Notification is called when HTTP response error was received
        from the server.

        \param response - HTTP response
        \param error - HTTP response error
    */
    virtual void onReceivedResponseError(const HTTPResponse& response, const std::string& error) {}

protected:
    //! HTTP request
    HTTPRequest _request;
    //! HTTP response
    HTTPResponse _response;
};

//! HTTPS extended client
/*!
    HTTPS extended client make requests to HTTPS Web server with returning std::future
    as a synchronization primitive.

    Thread-safe.
*/
class HTTPSClientEx : public HTTPSClient
{
public:
    using HTTPSClient::HTTPSClient;

    //! Get the TCP resolver
    std::shared_ptr<Asio::TCPResolver>& resolver() noexcept { return _resolver; }
    const std::shared_ptr<Asio::TCPResolver>& resolver() const noexcept { return _resolver; }
    //! Get the timeout check timer
    std::shared_ptr<Asio::Timer>& timeout() noexcept { return _timeout; }
    const std::shared_ptr<Asio::Timer>& timeout() const noexcept { return _timeout; }

    //! Send HTTP request
    /*!
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendRequest(const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1)) { return SendRequest(_request, timeout); }
    //! HTTP request
    /*!
        \param request - HTTP request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1));

    //! Send HEAD request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendHeadRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeHeadRequest(url), timeout); }
    //! Send GET request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendGetRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeGetRequest(url), timeout); }
    //! Send POST request
    /*!
        \param url - URL to request
        \param content - Content
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendPostRequest(std::string_view url, std::string_view content, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakePostRequest(url, content), timeout); }
    //! Send PUT request
    /*!
        \param url - URL to request
        \param content - Content
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendPutRequest(std::string_view url, std::string_view content, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakePutRequest(url, content), timeout); }
    //! Send DELETE request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendDeleteRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeDeleteRequest(url), timeout); }
    //! Send OPTIONS request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendOptionsRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeOptionsRequest(url), timeout); }
    //! Send TRACE request
    /*!
        \param url - URL to request
        \param timeout - HTTP request timeout
        \return HTTP request future
    */
    std::future<HTTPResponse> SendTraceRequest(std::string_view url, const CppCommon::Timespan& timeout = CppCommon::Timespan::minutes(1))
    { return SendRequest(_request.MakeTraceRequest(url), timeout); }

protected:
    void onHandshaked() override;
    void onDisconnected() override;
    void onReceivedResponse(const HTTPResponse& response) override;
    void onReceivedResponseError(const HTTPResponse& response, const std::string& error) override;

private:
    std::shared_ptr<Asio::TCPResolver> _resolver;
    std::shared_ptr<Asio::Timer> _timeout;
    std::promise<HTTPResponse> _promise;

    void SetPromiseValue(const HTTPResponse& response);
    void SetPromiseError(const std::string& error);
};

/*! \example https_client.cpp HTTPS client example */

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTPS_CLIENT_H

```

`include/server/http/https_server.h`:

```h
/*!
    \file https_server.h
    \brief HTTPS server definition
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTPS_SERVER_H
#define CPPSERVER_HTTP_HTTPS_SERVER_H

#include "https_session.h"

#include "cache/filecache.h"
#include "server/asio/ssl_server.h"

namespace CppServer {
namespace HTTP {

//! HTTPS server
/*!
    HTTPS server is used to create secured HTTPS Web server and
    communicate with clients using secure HTTPS protocol.
    It allows to receive GET, POST, PUT, DELETE requests and
    send HTTP responses.

    Thread-safe.
*/
class HTTPSServer : public Asio::SSLServer
{
public:
    using SSLServer::SSLServer;

    HTTPSServer(const HTTPSServer&) = delete;
    HTTPSServer(HTTPSServer&&) = delete;
    virtual ~HTTPSServer() = default;

    HTTPSServer& operator=(const HTTPSServer&) = delete;
    HTTPSServer& operator=(HTTPSServer&&) = delete;

    //! Get the static content cache
    CppCommon::FileCache& cache() noexcept { return _cache; }
    const CppCommon::FileCache& cache() const noexcept { return _cache; }

    //! Add static content cache
    /*!
        \param path - Static content path
        \param prefix - Cache prefix (default is "/")
        \param timeout - Refresh cache timeout (default is 1 hour)
    */
    void AddStaticContent(const CppCommon::Path& path, const std::string& prefix = "/", const CppCommon::Timespan& timeout = CppCommon::Timespan::hours(1));
    //! Remove static content cache
    /*!
        \param path - Static content path
    */
    void RemoveStaticContent(const CppCommon::Path& path) { _cache.remove_path(path); }
    //! Clear static content cache
    void ClearStaticContent() { _cache.clear(); }

    //! Watchdog the static content cache
    void Watchdog(const CppCommon::UtcTimestamp& utc = CppCommon::UtcTimestamp()) { _cache.watchdog(utc); }

protected:
    std::shared_ptr<Asio::SSLSession> CreateSession(const std::shared_ptr<Asio::SSLServer>& server) override { return std::make_shared<HTTPSSession>(std::dynamic_pointer_cast<HTTPSServer>(server)); }

private:
    // Static content cache
    CppCommon::FileCache _cache;
};

/*! \example https_server.cpp HTTPS server example */

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTPS_SERVER_H

```

`include/server/http/https_session.h`:

```h
/*!
    \file https_session.h
    \brief HTTPS session definition
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_HTTPS_SESSION_H
#define CPPSERVER_HTTP_HTTPS_SESSION_H

#include "http_request.h"
#include "http_response.h"

#include "cache/filecache.h"
#include "server/asio/ssl_session.h"

namespace CppServer {
namespace HTTP {

class HTTPSServer;

//! HTTPS session
/*!
    HTTPS session is used to receive/send HTTP requests/responses from the connected HTTPS client.

    Thread-safe.
*/
class HTTPSSession : public Asio::SSLSession
{
public:
    explicit HTTPSSession(const std::shared_ptr<HTTPSServer>& server);
    HTTPSSession(const HTTPSSession&) = delete;
    HTTPSSession(HTTPSSession&&) = delete;
    virtual ~HTTPSSession() = default;

    HTTPSSession& operator=(const HTTPSSession&) = delete;
    HTTPSSession& operator=(HTTPSSession&&) = delete;

    //! Get the static content cache
    CppCommon::FileCache& cache() noexcept { return _cache; }
    const CppCommon::FileCache& cache() const noexcept { return _cache; }

    //! Get the HTTP response
    HTTPResponse& response() noexcept { return _response; }
    const HTTPResponse& response() const noexcept { return _response; }

    //! Send the current HTTP response (synchronous)
    /*!
        \return Size of sent data
    */
    size_t SendResponse() { return SendResponse(_response); }
    //! Send the HTTP response (synchronous)
    /*!
        \param response - HTTP response
        \return Size of sent data
    */
    size_t SendResponse(const HTTPResponse& response) { return Send(response.cache()); }

    //! Send the HTTP response body (synchronous)
    /*!
        \param body - HTTP response body
        \return Size of sent data
    */
    size_t SendResponseBody(std::string_view body) { return Send(body); }
    //! Send the HTTP response body (synchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \return Size of sent data
    */
    size_t SendResponseBody(const void* buffer, size_t size) { return Send(buffer, size); }

    //! Send the current HTTP response with timeout (synchronous)
    /*!
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponse(const CppCommon::Timespan& timeout) { return SendResponse(_response, timeout); }
    //! Send the HTTP response with timeout (synchronous)
    /*!
        \param response - HTTP response
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponse(const HTTPResponse& response, const CppCommon::Timespan& timeout) { return Send(response.cache(), timeout); }

    //! Send the HTTP response body with timeout (synchronous)
    /*!
        \param body - HTTP response body
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponseBody(std::string_view body, const CppCommon::Timespan& timeout) { return Send(body, timeout); }
    //! Send the HTTP response body with timeout (synchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \param timeout - Timeout
        \return Size of sent data
    */
    size_t SendResponseBody(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { return Send(buffer, size, timeout); }

    //! Send the current HTTP response (asynchronous)
    /*!
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseAsync() { return SendResponseAsync(_response); }
    //! Send the HTTP response (asynchronous)
    /*!
        \param response - HTTP response
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseAsync(const HTTPResponse& response) { return SendAsync(response.cache()); }

    //! Send the HTTP response body (asynchronous)
    /*!
        \param body - HTTP response body
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseBodyAsync(std::string_view body) { return SendAsync(body); }
    //! Send the HTTP response body (asynchronous)
    /*!
        \param buffer - HTTP response body buffer
        \param size - HTTP response body size
        \return 'true' if the current HTTP response was successfully sent, 'false' if the session is not connected
    */
    bool SendResponseBodyAsync(const void* buffer, size_t size) { return SendAsync(buffer, size); }

protected:
    void onReceived(const void* buffer, size_t size) override;
    void onDisconnected() override;

    //! Handle HTTP request header received notification
    /*!
        Notification is called when HTTP request header was received
        from the client.

        \param request - HTTP request
    */
    virtual void onReceivedRequestHeader(const HTTPRequest& request) {}

    //! Handle HTTP request received notification
    /*!
        Notification is called when HTTP request was received
        from the client.

        \param request - HTTP request
    */
    virtual void onReceivedRequest(const HTTPRequest& request) {}
    //! Handle HTTP cached request received notification
    /*!
        Notification is called when HTTP request was received
        from the client and the corresponding cached content
        was found.

        Default behavior is just send cached response content
        to the client.

        \param request - HTTP request
        \param content - Cached response content
    */
    virtual void onReceivedCachedRequest(const HTTPRequest& request, std::string_view content) { SendAsync(content); }

    //! Handle HTTP request error notification
    /*!
        Notification is called when HTTP request error was received
        from the client.

        \param request - HTTP request
        \param error - HTTP request error
    */
    virtual void onReceivedRequestError(const HTTPRequest& request, const std::string& error) {}

protected:
    //! HTTP request
    HTTPRequest _request;
    //! HTTP response
    HTTPResponse _response;

private:
    // Static content cache
    CppCommon::FileCache& _cache;

    void onReceivedRequestInternal(const HTTPRequest& request);
};

} // namespace HTTP
} // namespace CppServer

#endif // CPPSERVER_HTTP_HTTPS_SESSION_H

```

`include/server/version.h`:

```h
/*!
    \file version.h
    \brief Version definition
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#ifndef CPPSERVER_VERSION_H
#define CPPSERVER_VERSION_H

/*! \mainpage C++ Server Library

C++ Server Library provides functionality to create different kind of
client/server solutions.

This document contains CppServer API references.

Library description, features, requirements and usage examples can be  find  on
GitHub: https://github.com/chronoxor/CppServer

*/

/*!
    \namespace CppServer
    \brief C++ Server project definitions
*/
namespace CppServer {

//! Project version
const char version[] = "1.0.5.0";

} // namespace CppServer

#endif // CPPSERVER_VERSION_H

```

`include/server/ws/ws.h`:

```h
/*!
    \file ws.h
    \brief WebSocket C++ Library definition
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_WS_H
#define CPPSERVER_WS_H

#include "server/http/http_request.h"
#include "server/http/http_response.h"

#include "system/uuid.h"

#include <array>
#include <mutex>

namespace CppServer {

/*!
    \namespace CppServer::WS
    \brief WebSocket definitions
*/
namespace WS {

//! WebSocket utility class
class WebSocket
{
public:
    //! Final frame
    static const uint8_t WS_FIN = 0x80;
    //! Text frame
    static const uint8_t WS_TEXT = 0x01;
    //! Binary frame
    static const uint8_t WS_BINARY = 0x02;
    //! Close frame
    static const uint8_t WS_CLOSE = 0x08;
    //! Ping frame
    static const uint8_t WS_PING = 0x09;
    //! Pong frame
    static const uint8_t WS_PONG = 0x0A;

    WebSocket() { ClearWSBuffers(); InitWSNonce(); }
    WebSocket(const WebSocket&) = delete;
    WebSocket(WebSocket&&) = delete;
    ~WebSocket() = default;

    WebSocket& operator=(const WebSocket&) = delete;
    WebSocket& operator=(WebSocket&&) = delete;

    //! Get the WebSocket random nonce
    std::string_view ws_nonce() const noexcept { return std::string_view((char*)_ws_nonce.data(), _ws_nonce.size()); }

    //! Perform WebSocket client upgrade
    /*!
        \param response - WebSocket upgrade HTTP response
        \param id - WebSocket client Id
        \return 'true' if the WebSocket was successfully upgrade, 'false' if the WebSocket was not upgrade
    */
    bool PerformClientUpgrade(const HTTP::HTTPResponse& response, const CppCommon::UUID& id);

    //! Perform WebSocket server upgrade
    /*!
        \param request - WebSocket upgrade HTTP request
        \param response - WebSocket upgrade HTTP response
        \return 'true' if the WebSocket was successfully upgrade, 'false' if the WebSocket was not upgrade
    */
    bool PerformServerUpgrade(const HTTP::HTTPRequest& request, HTTP::HTTPResponse& response);

    //! Prepare WebSocket send frame
    /*!
        \param opcode - WebSocket opcode
        \param mask - WebSocket mask
        \param buffer - Buffer to send
        \param size - Buffer size
        \param status - WebSocket status (defualt is 0)
    */
    void PrepareSendFrame(uint8_t opcode, bool mask, const void* buffer, size_t size, int status = 0);

    //! Prepare WebSocket receive frame
    /*!
        \param buffer - Received buffer
        \param size - Received buffer size
    */
    void PrepareReceiveFrame(const void* buffer, size_t size);

    //! Required WebSocket receive frame size
    size_t RequiredReceiveFrameSize();

    //! Clear WebSocket send/receive buffers
    void ClearWSBuffers();

    //! Initialize WebSocket random nonce
    void InitWSNonce();

protected:
    //! Handle WebSocket client connecting notification
    /*!
        Notification is called when WebSocket client is connecting
        to the server. You can handle the connection and change
        WebSocket upgrade HTTP request by providing your own headers.

        \param request - WebSocket upgrade HTTP request
    */
    virtual void onWSConnecting(HTTP::HTTPRequest& request) {}
    //! Handle WebSocket client connected notification
    /*!
        \param response - WebSocket upgrade HTTP response
    */
    virtual void onWSConnected(const HTTP::HTTPResponse& response) {}

    //! Handle WebSocket server session validating notification
    /*!
        Notification is called when WebSocket client is connecting
        to the server. You can handle the connection and validate
        WebSocket upgrade HTTP request.

        \param request - WebSocket upgrade HTTP request
        \param response - WebSocket upgrade HTTP response
        \return 'true' if the WebSocket update request is valid, 'false' if the WebSocket update request is not valid
    */
    virtual bool onWSConnecting(const HTTP::HTTPRequest& request, HTTP::HTTPResponse& response) { return true; }
    //! Handle WebSocket server session connected notification
    /*!
        \param request - WebSocket upgrade HTTP request
    */
    virtual void onWSConnected(const HTTP::HTTPRequest& request) {}

    //! Handle WebSocket client disconnected notification
    virtual void onWSDisconnected() {}

    //! Handle WebSocket received notification
    /*!
        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onWSReceived(const void* buffer, size_t size) {}

    //! Handle WebSocket client close notification
    /*!
        \param buffer - Received buffer
        \param size - Received buffer size
        \param status - WebSocket status (defualt is 1000)
    */
    virtual void onWSClose(const void* buffer, size_t size, int status = 1000) {}
    //! Handle WebSocket ping notification
    /*!
        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onWSPing(const void* buffer, size_t size) {}
    //! Handle WebSocket pong notification
    /*!
        \param buffer - Received buffer
        \param size - Received buffer size
    */
    virtual void onWSPong(const void* buffer, size_t size) {}

    //! Handle WebSocket error notification
    /*!
        \param message - Error message
    */
    virtual void onWSError(const std::string& message) {}

protected:
    //! Handshaked flag
    bool _ws_handshaked{false};

    //! Received frame opcode
    uint8_t _ws_opcode;
    //! Received frame flag
    bool _ws_frame_received{false};
    //! Received final flag
    bool _ws_final_received{false};
    //! Received frame header size
    size_t _ws_header_size{0};
    //! Received frame payload size
    size_t _ws_payload_size{0};
    //! Receive frame buffer
    std::vector<uint8_t> _ws_receive_frame_buffer;
    //! Receive final buffer
    std::vector<uint8_t> _ws_receive_final_buffer;
    //! Receive mask
    uint8_t _ws_receive_mask[4];

    //! Send buffer lock
    std::mutex _ws_send_lock;
    //! Send buffer
    std::vector<uint8_t> _ws_send_buffer;
    //! Send mask
    uint8_t _ws_send_mask[4];

    //! WebSocket random nonce of 16 bytes
    std::array<uint8_t, 16> _ws_nonce;

    //! Send WebSocket server upgrade response
    /*!
        \param response - WebSocket upgrade HTTP response
    */
    virtual void SendResponse(const HTTP::HTTPResponse& response) {}
};

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_WS_H

```

`include/server/ws/ws_client.h`:

```h
/*!
    \file ws_client.h
    \brief WebSocket client definition
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WS_CLIENT_H
#define CPPSERVER_HTTP_WS_CLIENT_H

#include "server/http/http_client.h"
#include "server/ws/ws.h"

namespace CppServer {
namespace WS {

//! WebSocket client
/*!
    WebSocket client is used to communicate with WebSocket server.

    https://en.wikipedia.org/wiki/WebSocket

    Thread-safe.
*/
class WSClient : public HTTP::HTTPClient, protected WebSocket
{
public:
    using HTTPClient::HTTPClient;

    WSClient(const WSClient&) = delete;
    WSClient(WSClient&&) = delete;
    virtual ~WSClient() = default;

    WSClient& operator=(const WSClient&) = delete;
    WSClient& operator=(WSClient&&) = delete;

    // WebSocket connection methods
    bool Connect() override;
    bool Connect(const std::shared_ptr<Asio::TCPResolver>& resolver) override;
    bool ConnectAsync() override;
    bool ConnectAsync(const std::shared_ptr<Asio::TCPResolver>& resolver) override;
    virtual bool Close() { return Close(0, nullptr, 0); }
    virtual bool Close(int status) { return Close(status, nullptr, 0); }
    virtual bool Close(int status, const void* buffer, size_t size) { SendClose(status, buffer, size); HTTPClient::Disconnect(); return true; }
    virtual bool Close(int status, std::string_view text) { SendClose(status, text); HTTPClient::Disconnect(); return true; }
    virtual bool CloseAsync() { return CloseAsync(0, nullptr, 0); }
    virtual bool CloseAsync(int status) { return CloseAsync(status, nullptr, 0); }
    virtual bool CloseAsync(int status, const void* buffer, size_t size) { SendCloseAsync(status, buffer, size); HTTPClient::DisconnectAsync(); return true; }
    virtual bool CloseAsync(int status, std::string_view text) { SendCloseAsync(status, text); HTTPClient::DisconnectAsync(); return true; }

    // WebSocket send text methods
    size_t SendText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendText(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendTextAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendTextAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket send binary methods
    size_t SendBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendBinary(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendBinaryAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendBinaryAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket close methods
    size_t SendClose(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendClose(int status, std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendCloseAsync(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendCloseAsync(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket ping methods
    size_t SendPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPing(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPingAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPingAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket pong methods
    size_t SendPong(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPong(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPongAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPongAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket receive methods
    std::string ReceiveText();
    std::string ReceiveText(const CppCommon::Timespan& timeout);
    std::vector<uint8_t> ReceiveBinary();
    std::vector<uint8_t> ReceiveBinary(const CppCommon::Timespan& timeout);

protected:
    void onConnected() override;
    void onDisconnected() override;
    void onReceived(const void* buffer, size_t size) override;
    void onReceivedResponseHeader(const HTTP::HTTPResponse& response) override;
    void onReceivedResponse(const HTTP::HTTPResponse& response) override;
    void onReceivedResponseError(const HTTP::HTTPResponse& response, const std::string& error) override;

    //! Handle WebSocket close notification
    void onWSClose(const void* buffer, size_t size, int status = 1000) override { CloseAsync(); }
    //! Handle WebSocket ping notification
    void onWSPing(const void* buffer, size_t size) override { SendPongAsync(buffer, size); }
    //! Handle WebSocket error notification
    void onWSError(const std::string& message) override { onError(asio::error::fault, "WebSocket error", message); }

private:
    // Sync connect flag
    bool _sync_connect;

    // WebSocket clients cannot send response
    void SendResponse(const HTTP::HTTPResponse& response) override {}
};

/*! \example ws_chat_client.cpp WebSocket chat client example */

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WS_CLIENT_H

```

`include/server/ws/ws_server.h`:

```h
/*!
    \file ws_server.h
    \brief WebSocket server definition
    \author Ivan Shynkarenka
    \date 27.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WS_SERVER_H
#define CPPSERVER_HTTP_WS_SERVER_H

#include "ws_session.h"

#include "server/http/http_server.h"

namespace CppServer {
namespace WS {

//! WebSocket server
/*!
    WebSocket server is used to communicate with clients using
    WebSocket protocol.

    https://en.wikipedia.org/wiki/WebSocket

    Thread-safe.
*/
class WSServer : public HTTP::HTTPServer, protected WebSocket
{
public:
    using HTTPServer::HTTPServer;

    WSServer(const WSServer&) = delete;
    WSServer(WSServer&&) = delete;
    virtual ~WSServer() = default;

    WSServer& operator=(const WSServer&) = delete;
    WSServer& operator=(WSServer&&) = delete;

    // WebSocket connection methods
    virtual bool CloseAll() { return CloseAll(0, nullptr, 0); }
    virtual bool CloseAll(int status) { return CloseAll(status, nullptr, 0); }
    virtual bool CloseAll(int status, const void* buffer, size_t size);
    virtual bool CloseAll(int status, std::string_view text);

    //! Multicast data to all connected WebSocket sessions
    bool Multicast(const void* buffer, size_t size) override;

    // WebSocket multicast text methods
    size_t MulticastText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket multicast binary methods
    size_t MulticastBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket multicast ping methods
    size_t MulticastPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

protected:
    std::shared_ptr<Asio::TCPSession> CreateSession(const std::shared_ptr<Asio::TCPServer>& server) override { return std::make_shared<WSSession>(std::dynamic_pointer_cast<WSServer>(server)); }
};

/*! \example ws_chat_server.cpp WebSocket chat server example */

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WS_SERVER_H

```

`include/server/ws/ws_session.h`:

```h
/*!
    \file ws_session.h
    \brief WebSocket session definition
    \author Ivan Shynkarenka
    \date 27.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WS_SESSION_H
#define CPPSERVER_HTTP_WS_SESSION_H

#include "server/http/http_session.h"
#include "server/ws/ws.h"

namespace CppServer {
namespace WS {

class WSServer;

//! WebSocket session
/*!
    WebSocket session is used to read and write data from the connected WebSocket client.

    Thread-safe.
*/
class WSSession : public HTTP::HTTPSession, protected WebSocket
{
    friend class WSServer;

public:
    explicit WSSession(const std::shared_ptr<WSServer>& server);
    WSSession(const WSSession&) = delete;
    WSSession(WSSession&&) = delete;
    virtual ~WSSession() = default;

    WSSession& operator=(const WSSession&) = delete;
    WSSession& operator=(WSSession&&) = delete;

    // WebSocket connection methods
    virtual bool Close() { return Close(0, nullptr, 0); }
    virtual bool Close(int status) { return Close(status, nullptr, 0); }
    virtual bool Close(int status, const void* buffer, size_t size) { SendCloseAsync(status, buffer, size); HTTPSession::Disconnect(); return true; }
    virtual bool Close(int status, std::string_view text) { SendCloseAsync(status, text); HTTPSession::Disconnect(); return true; }

    // WebSocket send text methods
    size_t SendText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendText(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendTextAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendTextAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket send binary methods
    size_t SendBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendBinary(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendBinaryAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendBinaryAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket close methods
    size_t SendClose(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendClose(int status, std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendCloseAsync(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendCloseAsync(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket ping methods
    size_t SendPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPing(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPingAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPingAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket pong methods
    size_t SendPong(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPong(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPongAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPongAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket receive methods
    std::string ReceiveText();
    std::string ReceiveText(const CppCommon::Timespan& timeout);
    std::vector<uint8_t> ReceiveBinary();
    std::vector<uint8_t> ReceiveBinary(const CppCommon::Timespan& timeout);

protected:
    void onDisconnected() override;
    void onReceived(const void* buffer, size_t size) override;
    void onReceivedRequestHeader(const HTTP::HTTPRequest& request) override;
    void onReceivedRequest(const HTTP::HTTPRequest& request) override;
    void onReceivedRequestError(const HTTP::HTTPRequest& request, const std::string& error) override;

    //! Handle WebSocket close notification
    void onWSClose(const void* buffer, size_t size, int status = 1000) override { Close(); }
    //! Handle WebSocket ping notification
    void onWSPing(const void* buffer, size_t size) override { SendPongAsync(buffer, size); }
    //! Handle WebSocket error notification
    void onWSError(const std::string& message) override { onError(asio::error::fault, "WebSocket error", message); }

private:
    // WebSocket send response
    void SendResponse(const HTTP::HTTPResponse& response) override { SendResponseAsync(response); }
};

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WS_SESSION_H

```

`include/server/ws/wss_client.h`:

```h
/*!
    \file wss_client.h
    \brief WebSocket secure client definition
    \author Ivan Shynkarenka
    \date 23.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WSS_CLIENT_H
#define CPPSERVER_HTTP_WSS_CLIENT_H

#include "server/http/https_client.h"
#include "server/ws/ws.h"

namespace CppServer {
namespace WS {

//! WebSocket secure client
/*!
    WebSocket secure client is used to communicate with secure WebSocket server.

    https://en.wikipedia.org/wiki/WebSocket

    Thread-safe.
*/
class WSSClient : public HTTP::HTTPSClient, protected WebSocket
{
public:
    using HTTPSClient::HTTPSClient;

    WSSClient(const WSSClient&) = delete;
    WSSClient(WSSClient&&) = delete;
    virtual ~WSSClient() = default;

    WSSClient& operator=(const WSSClient&) = delete;
    WSSClient& operator=(WSSClient&&) = delete;

    // WebSocket connection methods
    bool Connect() override;
    bool Connect(const std::shared_ptr<Asio::TCPResolver>& resolver) override;
    bool ConnectAsync() override;
    bool ConnectAsync(const std::shared_ptr<Asio::TCPResolver>& resolver) override;
    virtual bool Close() { return Close(0, nullptr, 0); }
    virtual bool Close(int status) { return Close(status, nullptr, 0); }
    virtual bool Close(int status, const void* buffer, size_t size) { SendClose(status, buffer, size); HTTPSClient::Disconnect(); return true; }
    virtual bool Close(int status, std::string_view text) { SendClose(status, text); HTTPSClient::Disconnect(); return true; }
    virtual bool CloseAsync() { return CloseAsync(0, nullptr, 0); }
    virtual bool CloseAsync(int status) { return CloseAsync(status, nullptr, 0); }
    virtual bool CloseAsync(int status, const void* buffer, size_t size) { SendCloseAsync(status, buffer, size); HTTPSClient::DisconnectAsync(); return true; }
    virtual bool CloseAsync(int status, std::string_view text) { SendCloseAsync(status, text); HTTPSClient::DisconnectAsync(); return true; }

    // WebSocket send text methods
    size_t SendText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendText(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendTextAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, buffer, size); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendTextAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, true, text.data(), text.size()); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket send binary methods
    size_t SendBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendBinary(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendBinaryAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, buffer, size); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendBinaryAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, true, text.data(), text.size()); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket close methods
    size_t SendClose(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendClose(int status, std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendCloseAsync(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, buffer, size, status); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendCloseAsync(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, true, text.data(), text.size(), status); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket ping methods
    size_t SendPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPing(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPingAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, buffer, size); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPingAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, true, text.data(), text.size()); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket pong methods
    size_t SendPong(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPong(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPSClient::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPongAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, buffer, size); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPongAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, true, text.data(), text.size()); return HTTPSClient::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket receive methods
    std::string ReceiveText();
    std::string ReceiveText(const CppCommon::Timespan& timeout);
    std::vector<uint8_t> ReceiveBinary();
    std::vector<uint8_t> ReceiveBinary(const CppCommon::Timespan& timeout);

protected:
    void onHandshaked() override;
    void onDisconnected() override;
    void onReceived(const void* buffer, size_t size) override;
    void onReceivedResponseHeader(const HTTP::HTTPResponse& response) override;
    void onReceivedResponse(const HTTP::HTTPResponse& response) override;
    void onReceivedResponseError(const HTTP::HTTPResponse& response, const std::string& error) override;

    //! Handle WebSocket close notification
    void onWSClose(const void* buffer, size_t size, int status = 1000) override { CloseAsync(); }
    //! Handle WebSocket ping notification
    void onWSPing(const void* buffer, size_t size) override { SendPongAsync(buffer, size); }
    //! Handle WebSocket error notification
    void onWSError(const std::string& message) override { onError(asio::error::fault, "WebSocket error", message); }

private:
    // Sync connect flag
    bool _sync_connect;

    // WebSocket clients cannot send response
    void SendResponse(const HTTP::HTTPResponse& response) override {}
};

/*! \example wss_chat_client.cpp WebSocket secure chat client example */

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WSS_CLIENT_H

```

`include/server/ws/wss_server.h`:

```h
/*!
    \file wss_server.h
    \brief WebSocket secure server definition
    \author Ivan Shynkarenka
    \date 28.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WSS_SERVER_H
#define CPPSERVER_HTTP_WSS_SERVER_H

#include "wss_session.h"

#include "server/http/https_server.h"

namespace CppServer {
namespace WS {

//! WebSocket secure server
/*!
    WebSocket secure server is used to communicate with clients using
    WebSocket secure protocol.

    https://en.wikipedia.org/wiki/WebSocket

    Thread-safe.
*/
class WSSServer : public HTTP::HTTPSServer, protected WebSocket
{
public:
    using HTTPSServer::HTTPSServer;

    WSSServer(const WSSServer&) = delete;
    WSSServer(WSSServer&&) = delete;
    virtual ~WSSServer() = default;

    WSSServer& operator=(const WSSServer&) = delete;
    WSSServer& operator=(WSSServer&&) = delete;

    // WebSocket connection methods
    virtual bool CloseAll() { return CloseAll(0, nullptr, 0); }
    virtual bool CloseAll(int status) { return CloseAll(status, nullptr, 0); }
    virtual bool CloseAll(int status, const void* buffer, size_t size);
    virtual bool CloseAll(int status, std::string_view text);

    //! Multicast data to all connected WebSocket sessions
    bool Multicast(const void* buffer, size_t size) override;

    // WebSocket multicast text methods
    size_t MulticastText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket multicast binary methods
    size_t MulticastBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket multicast ping methods
    size_t MulticastPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t MulticastPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()); }

protected:
    std::shared_ptr<Asio::SSLSession> CreateSession(const std::shared_ptr<Asio::SSLServer>& server) override { return std::make_shared<WSSSession>(std::dynamic_pointer_cast<WSSServer>(server)); }
};

/*! \example wss_chat_server.cpp WebSocket secure chat server example */

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WSS_SERVER_H

```

`include/server/ws/wss_session.h`:

```h
/*!
    \file wss_session.h
    \brief WebSocket secure session definition
    \author Ivan Shynkarenka
    \date 28.05.2019
    \copyright MIT License
*/

#ifndef CPPSERVER_HTTP_WSS_SESSION_H
#define CPPSERVER_HTTP_WSS_SESSION_H

#include "server/http/https_session.h"
#include "server/ws/ws.h"

namespace CppServer {
namespace WS {

class WSSServer;

//! WebSocket secure session
/*!
    WebSocket secure session is used to read and write data from the connected WebSocket secure client.

    Thread-safe.
*/
class WSSSession : public HTTP::HTTPSSession, protected WebSocket
{
    friend class WSSServer;

public:
    explicit WSSSession(const std::shared_ptr<WSSServer>& server);
    WSSSession(const WSSSession&) = delete;
    WSSSession(WSSSession&&) = delete;
    virtual ~WSSSession() = default;

    WSSSession& operator=(const WSSSession&) = delete;
    WSSSession& operator=(WSSSession&&) = delete;

    // WebSocket connection methods
    virtual bool Close() { return Close(0, nullptr, 0); }
    virtual bool Close(int status) { return Close(status, nullptr, 0); }
    virtual bool Close(int status, const void* buffer, size_t size) { SendCloseAsync(status, buffer, size); HTTPSSession::Disconnect(); return true; }
    virtual bool Close(int status, std::string_view text) { SendCloseAsync(status, text); HTTPSSession::Disconnect(); return true; }

    // WebSocket send text methods
    size_t SendText(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendText(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendText(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendTextAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, buffer, size); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendTextAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_TEXT, false, text.data(), text.size()); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket send binary methods
    size_t SendBinary(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendBinary(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendBinary(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendBinaryAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, buffer, size); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendBinaryAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_BINARY, false, text.data(), text.size()); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket close methods
    size_t SendClose(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendClose(int status, const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendClose(int status, std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendCloseAsync(int status, const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendCloseAsync(int status, std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket ping methods
    size_t SendPing(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPing(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPing(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPingAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, buffer, size); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPingAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PING, false, text.data(), text.size()); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket pong methods
    size_t SendPong(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    size_t SendPong(const void* buffer, size_t size, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    size_t SendPong(std::string_view text, const CppCommon::Timespan& timeout) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSSession::Send(_ws_send_buffer.data(), _ws_send_buffer.size(), timeout); }
    bool SendPongAsync(const void* buffer, size_t size) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, buffer, size); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }
    bool SendPongAsync(std::string_view text) { std::scoped_lock locker(_ws_send_lock); PrepareSendFrame(WS_FIN | WS_PONG, false, text.data(), text.size()); return HTTPSSession::SendAsync(_ws_send_buffer.data(), _ws_send_buffer.size()); }

    // WebSocket receive methods
    std::string ReceiveText();
    std::string ReceiveText(const CppCommon::Timespan& timeout);
    std::vector<uint8_t> ReceiveBinary();
    std::vector<uint8_t> ReceiveBinary(const CppCommon::Timespan& timeout);

protected:
    void onDisconnected() override;
    void onReceived(const void* buffer, size_t size) override;
    void onReceivedRequestHeader(const HTTP::HTTPRequest& request) override;
    void onReceivedRequest(const HTTP::HTTPRequest& request) override;
    void onReceivedRequestError(const HTTP::HTTPRequest& request, const std::string& error) override;

    //! Handle WebSocket close notification
    void onWSClose(const void* buffer, size_t size, int status = 1000) override { Close(); }
    //! Handle WebSocket ping notification
    void onWSPing(const void* buffer, size_t size) override { SendPongAsync(buffer, size); }
    //! Handle WebSocket error notification
    void onWSError(const std::string& message) override { onError(asio::error::fault, "WebSocket error", message); }

private:
    // WebSocket send response
    void SendResponse(const HTTP::HTTPResponse& response) override { SendResponseAsync(response); }
};

} // namespace WS
} // namespace CppServer

#endif // CPPSERVER_HTTP_WSS_SESSION_H

```

`modules/CMakeLists.txt`:

```txt
include("asio.cmake")
include("Catch2.cmake")
include("cpp-optparse.cmake")
include("CppBenchmark.cmake")
include("CppCommon.cmake")

```

`modules/Catch2.cmake`:

```cmake
if(NOT TARGET Catch2)

  # Module library
  file(GLOB SOURCE_FILES "Catch2/extras/catch_amalgamated.cpp")
  add_library(Catch2 ${SOURCE_FILES})
  target_include_directories(Catch2 PUBLIC "Catch2/extras")

  # Module folder
  set_target_properties(Catch2 PROPERTIES FOLDER "modules/Catch2")

endif()

```

`modules/CppBenchmark.cmake`:

```cmake
if(NOT TARGET cppbenchmark)

  # Module flag
  set(CPPBENCHMARK_MODULE Y)

  # Module subdirectory
  add_subdirectory("CppBenchmark")

  # Module folder
  set_target_properties(cppbenchmark PROPERTIES FOLDER "modules/CppBenchmark")

endif()

```

`modules/CppCommon.cmake`:

```cmake
if(NOT TARGET cppcommon)

  # Module flag
  set(CPPCOMMON_MODULE Y)

  # Module subdirectory
  add_subdirectory("CppCommon")

  # Module folder
  set_target_properties(cppcommon PROPERTIES FOLDER "modules/CppCommon")

endif()

```

`modules/asio.cmake`:

```cmake
if(NOT TARGET asio)

  # Module library
  file(GLOB SOURCE_FILES "asio/asio/src/*.cpp")
  add_library(asio ${SOURCE_FILES})
  if(MSVC)
    set_target_properties(asio PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}")
  else()
    set_target_properties(asio PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS} -Wno-shadow")
  endif()
  target_compile_definitions(asio PRIVATE ASIO_STANDALONE ASIO_SEPARATE_COMPILATION)
  target_include_directories(asio PUBLIC "asio/asio/include" PUBLIC ${OPENSSL_INCLUDE_DIR})
  target_link_libraries(asio ${OPENSSL_LIBRARIES})

  # Module folder
  set_target_properties(asio PROPERTIES FOLDER "modules/asio")

endif()

```

`modules/cpp-optparse.cmake`:

```cmake
if(NOT TARGET cpp-optparse)

  # Module library
  file(GLOB SOURCE_FILES "cpp-optparse/OptionParser.cpp")
  add_library(cpp-optparse ${SOURCE_FILES})
  if(MSVC)
    # C4244: 'conversion' conversion from 'type1' to 'type2', possible loss of data
    # C4996: <header> is removed in C++20
    set_target_properties(cpp-optparse PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS} /wd4244 /wd4996")
  else()
    set_target_properties(cpp-optparse PROPERTIES COMPILE_FLAGS "${PEDANTIC_COMPILE_FLAGS}")
  endif()
  target_include_directories(cpp-optparse PUBLIC "cpp-optparse")

  # Module folder
  set_target_properties(cpp-optparse PROPERTIES FOLDER "modules/cpp-optparse")

endif()

```

`performance/http_trace_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 02.05.2019
//

#include "server/asio/service.h"
#include "server/http/http_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class HTTPTraceClient : public HTTPClient
{
public:
    HTTPTraceClient(const std::shared_ptr<Service>& service, const std::string& address, int port, int messages)
        : HTTPClient(service, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendRequestAsync(request().MakeTraceRequest("/")); }

protected:
    void onConnected() override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
        HTTPClient::onSent(sent, pending);
    }

    void onReceived(const void* buffer, size_t size) override
    {
        _received += size;
        timestamp_stop = Timestamp::nano();
        total_bytes += size;
        HTTPClient::onReceived(buffer, size);
    }

    void onReceivedResponse(const HTTPResponse& response) override
    {
        if (response.status() == 200)
            ++total_messages;
        else
            ++total_errors;
        SendMessage();
    }

    void onReceivedResponseError(const HTTPResponse& response, const std::string& error) override
    {
        std::cout << "Response error: " << error << std::endl;
        ++total_errors;
        SendMessage();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP Trace client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create HTTP Trace clients
    std::vector<std::shared_ptr<HTTPTraceClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<HTTPTraceClient>(service, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/http_trace_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 02.05.2019
//

#include "server/asio/service.h"
#include "server/http/http_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

class HTTPTraceSession : public HTTPSession
{
public:
    using HTTPSession::HTTPSession;

protected:
    void onReceivedRequest(const HTTPRequest& request) override
    {
        // Process HTTP request methods
        if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP Trace session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPTraceServer : public HTTPServer
{
public:
    using HTTPServer::HTTPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<HTTPTraceSession>(std::dynamic_pointer_cast<HTTPServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP Trace server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new HTTP Trace server
    auto server = std::make_shared<HTTPTraceServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/https_trace_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 02.05.2019
//

#include "server/asio/service.h"
#include "server/http/https_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class HTTPSTraceClient : public HTTPSClient
{
public:
    HTTPSTraceClient(const std::shared_ptr<Service>& service, std::shared_ptr<SSLContext> context, const std::string& address, int port, int messages)
        : HTTPSClient(service, context, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendRequestAsync(request().MakeTraceRequest("/")); }

protected:
    void onHandshaked() override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
        HTTPSClient::onSent(sent, pending);
    }

    void onReceived(const void* buffer, size_t size) override
    {
        _received += size;
        timestamp_stop = Timestamp::nano();
        total_bytes += size;
        HTTPSClient::onReceived(buffer, size);
    }

    void onReceivedResponse(const HTTPResponse& response) override
    {
        if (response.status() == 200)
            ++total_messages;
        else
            ++total_errors;
        SendMessage();
    }

    void onReceivedResponseError(const HTTPResponse& response, const std::string& error) override
    {
        std::cout << "Response error: " << error << std::endl;
        ++total_errors;
        SendMessage();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS Trace client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create HTTPS Trace clients
    std::vector<std::shared_ptr<HTTPSTraceClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<HTTPSTraceClient>(service, context, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/https_trace_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 02.05.2019
//

#include "server/asio/service.h"
#include "server/http/https_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

class HTTPSTraceSession : public HTTPSSession
{
public:
    using HTTPSSession::HTTPSSession;

protected:
    void onReceivedRequest(const HTTPRequest& request) override
    {
        // Process HTTP request methods
        if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS Trace session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class HTTPSTraceServer : public HTTPSServer
{
public:
    using HTTPSServer::HTTPSServer;

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<HTTPSTraceSession>(std::dynamic_pointer_cast<HTTPSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS Trace server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new HTTPS Trace server
    auto server = std::make_shared<HTTPSTraceServer>(service, context, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/proto_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 07.01.2022
//

#include "server/asio/service.h"
#include "server/asio/tcp_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include "../proto/simple_protocol.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::string message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class ProtoClient : public TCPClient, public FBE::simple::Client
{
public:
    ProtoClient(const std::shared_ptr<Service>& service, const std::string& address, int port, int messages)
        : TCPClient(service, address, port),
          _messages(messages)
    {
    }

    void SendMessage()
    {
        simple::SimpleRequest message;
        message.Message = message_to_send;
        request(message);
    }

protected:
    void onConnected() override
    {
        // Reset FBE protocol buffers
        reset();

        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    size_t onSend(const void* data, size_t size) override
    {
        return SendAsync(data, size) ? size : 0;
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        _received += size;
        timestamp_stop = Timestamp::nano();
        total_bytes += size;

        receive(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

protected:
    // Protocol handlers
    void onReceive(const ::simple::SimpleResponse& response) override { Client::onReceive(response); SendMessage(); }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(4444).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create protocol clients
    std::vector<std::shared_ptr<ProtoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create protocol client
        auto client = std::make_shared<ProtoClient>(service, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/proto_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 07.01.2022
//

#include "server/asio/service.h"
#include "server/asio/tcp_server.h"
#include "system/cpu.h"

#include "../proto/simple_protocol.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class ProtoSession : public TCPSession, public FBE::simple::Sender, public FBE::simple::Receiver
{
public:
    using TCPSession::TCPSession;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Protocol session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

protected:
    // Protocol handlers
    void onReceive(const ::simple::SimpleRequest& request) override
    {
        // Send response
        simple::SimpleResponse response;
        response.id = request.id;
        response.Hash = 0;
        response.Length = (uint32_t)request.Message.size();
        send(response);
    }

    // Protocol implementation
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }
};

class ProtoServer : public TCPServer, public FBE::simple::Sender
{
public:
    using TCPServer::TCPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<ProtoSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "Protocol server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }

protected:
    // Protocol implementation
    size_t onSend(const void* data, size_t size) override { Multicast(data, size); return size; }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(4444).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new protocol server
    auto server = std::make_shared<ProtoServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/ssl_echo_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 16.03.2017
//

#include "server/asio/service.h"
#include "server/asio/ssl_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::vector<uint8_t> message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class EchoClient : public SSLClient
{
public:
    EchoClient(const std::shared_ptr<Service>& service, std::shared_ptr<SSLContext> context, const std::string& address, int port, int messages)
        : SSLClient(service, context, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendAsync(message_to_send.data(), message_to_send.size()); }

protected:
    void onHandshaked() override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        _received += size;
        while (_received >= message_to_send.size())
        {
            SendMessage();
            _received -= message_to_send.size();
        }

        timestamp_stop = Timestamp::nano();
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(2222).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create echo clients
    std::vector<std::shared_ptr<EchoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<EchoClient>(service, context, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsHandshaked())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/ssl_echo_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 16.03.2017
//

#include "server/asio/service.h"
#include "server/asio/ssl_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class EchoSession : public SSLSession
{
public:
    using SSLSession::SSLSession;

protected:
    void onReceived(const void* buffer, size_t size) override
    {
        // Resend the message back to the client
        SendAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class EchoServer : public SSLServer
{
public:
    using SSLServer::SSLServer;

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<EchoSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(2222).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new echo server
    auto server = std::make_shared<EchoServer>(service, context, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/ssl_multicast_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/ssl_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class MulticastClient : public SSLClient
{
public:
    using SSLClient::SSLClient;

protected:
    void onReceived(const void* buffer, size_t size) override
    {
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(2222).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create multicast clients
    std::vector<std::shared_ptr<MulticastClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        auto client = std::make_shared<MulticastClient>(service, context, address, port);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsHandshaked())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    timestamp_stop = Timestamp::nano();

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/ssl_multicast_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/ssl_server.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class MulticastSession : public SSLSession
{
public:
    using SSLSession::SSLSession;

    bool SendAsync(const void* buffer, size_t size) override
    {
        // Limit session send buffer to 1 megabyte
        const size_t limit = 1 * 1024 * 1024;
        size_t pending = bytes_pending();
        if ((pending + size) > limit)
            return false;
        if (size > (limit - pending))
            size = limit - pending;

        return SSLSession::SendAsync(buffer, size);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class MulticastServer : public SSLServer
{
public:
    using SSLServer::SSLServer;

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<MulticastSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "SSL server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(2222).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000000).help("Rate of messages per second to send. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");
    int messages_rate = options.get("messages");
    int message_size = options.get("size");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;
    std::cout << "Messages rate: " << messages_rate << std::endl;
    std::cout << "Message size: " << message_size << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new multicast server
    auto server = std::make_shared<MulticastServer>(service, context, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    // Start the multicasting thread
    std::atomic<bool> multicasting(true);
    auto multicaster = std::thread([&server, &multicasting, messages_rate, message_size]()
    {
        // Prepare message to multicast
        std::vector<uint8_t> message_to_send(message_size);

        // Multicasting loop
        while (multicasting)
        {
            auto start = UtcTimestamp();
            for (int i = 0; i < messages_rate; ++i)
                server->Multicast(message_to_send.data(), message_to_send.size());
            auto end = UtcTimestamp();

            // Sleep for remaining time or yield
            auto milliseconds = (end - start).milliseconds();
            if (milliseconds < 1000)
                Thread::Sleep(1000 - milliseconds);
            else
                Thread::Yield();
        }
    });

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the multicasting thread
    multicasting = false;
    multicaster.join();

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/tcp_echo_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 15.03.2017
//

#include "server/asio/service.h"
#include "server/asio/tcp_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::vector<uint8_t> message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class EchoClient : public TCPClient
{
public:
    EchoClient(const std::shared_ptr<Service>& service, const std::string& address, int port, int messages)
        : TCPClient(service, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendAsync(message_to_send.data(), message_to_send.size()); }

protected:
    void onConnected() override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
    }

    void onReceived(const void* buffer, size_t size) override
    {
        _received += size;
        while (_received >= message_to_send.size())
        {
            SendMessage();
            _received -= message_to_send.size();
        }

        timestamp_stop = Timestamp::nano();
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(1111).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create echo clients
    std::vector<std::shared_ptr<EchoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<EchoClient>(service, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/tcp_echo_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 15.03.2017
//

#include "server/asio/service.h"
#include "server/asio/tcp_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class EchoSession : public TCPSession
{
public:
    using TCPSession::TCPSession;

protected:
    void onReceived(const void* buffer, size_t size) override
    {
        // Resend the message back to the client
        SendAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class EchoServer : public TCPServer
{
public:
    using TCPServer::TCPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<EchoSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(1111).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new echo server
    auto server = std::make_shared<EchoServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/tcp_multicast_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/tcp_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class MulticastClient : public TCPClient
{
public:
    using TCPClient::TCPClient;

protected:
    void onReceived(const void* buffer, size_t size) override
    {
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(1111).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create multicast clients
    std::vector<std::shared_ptr<MulticastClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        auto client = std::make_shared<MulticastClient>(service, address, port);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    timestamp_stop = Timestamp::nano();

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/tcp_multicast_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/tcp_server.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class MulticastSession : public TCPSession
{
public:
    using TCPSession::TCPSession;

    bool SendAsync(const void* buffer, size_t size) override
    {
        // Limit session send buffer to 1 megabyte
        const size_t limit = 1 * 1024 * 1024;
        size_t pending = bytes_pending();
        if ((pending + size) > limit)
            return false;
        if (size > (limit - pending))
            size = limit - pending;

        return TCPSession::SendAsync(buffer, size);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class MulticastServer : public TCPServer
{
public:
    using TCPServer::TCPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<MulticastSession>(server);
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "TCP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(1111).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000000).help("Rate of messages per second to send. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");
    int messages_rate = options.get("messages");
    int message_size = options.get("size");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;
    std::cout << "Messages rate: " << messages_rate << std::endl;
    std::cout << "Message size: " << message_size << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new multicast server
    auto server = std::make_shared<MulticastServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    // Start the multicasting thread
    std::atomic<bool> multicasting(true);
    auto multicaster = std::thread([&server, &multicasting, messages_rate, message_size]()
    {
        // Prepare message to multicast
        std::vector<uint8_t> message_to_send(message_size);

        // Multicasting loop
        while (multicasting)
        {
            auto start = UtcTimestamp();
            for (int i = 0; i < messages_rate; ++i)
                server->Multicast(message_to_send.data(), message_to_send.size());
            auto end = UtcTimestamp();

            // Sleep for remaining time or yield
            auto milliseconds = (end - start).milliseconds();
            if (milliseconds < 1000)
                Thread::Sleep(1000 - milliseconds);
            else
                Thread::Yield();
        }
    });

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the multicasting thread
    multicasting = false;
    multicaster.join();

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/udp_echo_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 15.03.2017
//

#include "server/asio/service.h"
#include "server/asio/udp_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::vector<uint8_t> message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class EchoClient : public UDPClient
{
public:
    EchoClient(const std::shared_ptr<Service>& service, const std::string& address, int port, int messages)
        : UDPClient(service, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { Send(message_to_send.data(), message_to_send.size()); }

protected:
    void onConnected() override
    {
        // Start receive datagrams
        ReceiveAsync();

        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        timestamp_stop = Timestamp::nano();
        total_bytes += size;
        ++total_messages;

        // Continue receive datagrams
        ReceiveAsync();

        SendMessage();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(3333).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create echo clients
    std::vector<std::shared_ptr<EchoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<EchoClient>(service, address, port, messages_count);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/udp_echo_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 15.03.2017
//

#include "server/asio/service.h"
#include "server/asio/udp_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class EchoServer : public UDPServer
{
public:
    using UDPServer::UDPServer;

protected:
    void onStarted() override
    {
        // Start receive datagrams
        ReceiveAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        // Continue receive datagrams
        if (size == 0)
        {
            ReceiveAsync();
            return;
        }

        // Resend the message back to the client
        SendAsync(endpoint, buffer, size);
    }

    void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) override
    {
        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(3333).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new echo server
    auto server = std::make_shared<EchoServer>(service, port);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/udp_multicast_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/udp_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class MulticastClient : public UDPClient
{
public:
    MulticastClient(const std::shared_ptr<Service>& service, const std::string& address, const std::string& multicast, int port)
        : UDPClient(service, address, port),
          _multicast(multicast)
    {
    }

protected:
    void onConnected() override
    {
        // Join UDP multicast group
        JoinMulticastGroup(_multicast);

        // Start receive datagrams
        ReceiveAsync();
    }

    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override
    {
        total_bytes += size;

        // Continue receive datagrams
        ReceiveAsync();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "UDP client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    std::string _multicast;
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("239.255.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(3333).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create multicast clients
    std::vector<std::shared_ptr<MulticastClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        auto client = std::make_shared<MulticastClient>(service, "0.0.0.0", address, port);
        client->SetupMulticast(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->DisconnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    timestamp_stop = Timestamp::nano();

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/udp_multicast_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.03.2018
//

#include "server/asio/service.h"
#include "server/asio/udp_server.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;

class MulticastServer : public UDPServer
{
public:
    using UDPServer::UDPServer;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "UDP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("239.255.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(3333).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000000).help("Rate of messages per second to send. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads = options.get("threads");
    int messages_rate = options.get("messages");
    int message_size = options.get("size");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;
    std::cout << "Messages rate: " << messages_rate << std::endl;
    std::cout << "Message size: " << message_size << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new multicast server
    auto server = std::make_shared<MulticastServer>(service, 0);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start(address, port);
    std::cout << "Done!" << std::endl;

    // Start the multicasting thread
    std::atomic<bool> multicasting(true);
    auto multicaster = std::thread([&server, &multicasting, messages_rate, message_size]()
    {
        // Prepare message to multicast
        std::vector<uint8_t> message_to_send(message_size);

        // Multicasting loop
        while (multicasting)
        {
            auto start = UtcTimestamp();
            for (int i = 0; i < messages_rate; ++i)
                server->Multicast(message_to_send.data(), message_to_send.size());
            auto end = UtcTimestamp();

            // Sleep for remaining time or yield
            auto milliseconds = (end - start).milliseconds();
            if (milliseconds < 1000)
                Thread::Sleep(1000 - milliseconds);
            else
                Thread::Yield();
        }
    });

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the multicasting thread
    multicasting = false;
    multicaster.join();

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/ws_echo_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/ws_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

std::vector<uint8_t> message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class EchoClient : public WSClient
{
public:
    EchoClient(const std::shared_ptr<Service>& service, const std::string& address, int port, int messages)
        : WSClient(service, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendBinaryAsync(message_to_send.data(), message_to_send.size()); }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "http://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        _received += size;
        while (_received >= message_to_send.size())
        {
            SendMessage();
            _received -= message_to_send.size();
        }

        timestamp_stop = Timestamp::nano();
        total_bytes += size;
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create echo clients
    std::vector<std::shared_ptr<EchoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<EchoClient>(service, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->CloseAsync(1000);
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/ws_echo_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/ws_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

class EchoSession : public WSSession
{
public:
    using WSSession::WSSession;

protected:
    void onWSReceived(const void* buffer, size_t size) override
    {
        // Resend the message back to the client
        SendBinaryAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class EchoServer : public WSServer
{
public:
    using WSServer::WSServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<EchoSession>(std::dynamic_pointer_cast<WSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new echo server
    auto server = std::make_shared<EchoServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/ws_multicast_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/ws_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class MulticastClient : public WSClient
{
public:
    using WSClient::WSClient;

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "http://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create multicast clients
    std::vector<std::shared_ptr<MulticastClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        auto client = std::make_shared<MulticastClient>(service, address, port);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->CloseAsync(1000);
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    timestamp_stop = Timestamp::nano();

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/ws_multicast_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/ws_server.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

class MulticastSession : public WSSession
{
public:
    using WSSession::WSSession;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class MulticastServer : public WSServer
{
public:
    using WSServer::WSServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<MulticastSession>(std::dynamic_pointer_cast<WSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8080).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000000).help("Rate of messages per second to send. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");
    int messages_rate = options.get("messages");
    int message_size = options.get("size");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;
    std::cout << "Messages rate: " << messages_rate << std::endl;
    std::cout << "Message size: " << message_size << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create a new multicast server
    auto server = std::make_shared<MulticastServer>(service, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    // Start the multicasting thread
    std::atomic<bool> multicasting(true);
    auto multicaster = std::thread([&server, &multicasting, messages_rate, message_size]()
    {
        // Prepare message to multicast
        std::vector<uint8_t> message_to_send(message_size);

        // Multicasting loop
        while (multicasting)
        {
            auto start = UtcTimestamp();
            for (int i = 0; i < messages_rate; ++i)
                server->MulticastBinary(message_to_send.data(), message_to_send.size());
            auto end = UtcTimestamp();

            // Sleep for remaining time or yield
            auto milliseconds = (end - start).milliseconds();
            if (milliseconds < 1000)
                Thread::Sleep(1000 - milliseconds);
            else
                Thread::Yield();
        }
    });

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the multicasting thread
    multicasting = false;
    multicaster.join();

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/wss_echo_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/wss_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

std::vector<uint8_t> message_to_send;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class EchoClient : public WSSClient
{
public:
    EchoClient(const std::shared_ptr<Service>& service, std::shared_ptr<SSLContext> context, const std::string& address, int port, int messages)
        : WSSClient(service, context, address, port),
          _messages(messages)
    {
    }

    void SendMessage() { SendBinaryAsync(message_to_send.data(), message_to_send.size()); }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "https://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override
    {
        for (size_t i = _messages; i > 0; --i)
            SendMessage();
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        _received += size;
        while (_received >= message_to_send.size())
        {
            SendMessage();
            _received -= message_to_send.size();
        }

        timestamp_stop = Timestamp::nano();
        total_bytes += size;
    }

    void onSent(size_t sent, size_t pending) override
    {
        _sent += sent;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }

private:
    size_t _sent{0};
    size_t _received{0};
    size_t _messages{0};
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000).help("Count of messages to send at the same time. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int messages_count = options.get("messages");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Working messages: " << messages_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Prepare a message to send
    message_to_send.resize(message_size, 0);

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create echo clients
    std::vector<std::shared_ptr<EchoClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        // Create echo client
        auto client = std::make_shared<EchoClient>(service, context, address, port, messages_count);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->CloseAsync(1000);
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/wss_echo_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/wss_server.h"
#include "system/cpu.h"

#include <iostream>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

class EchoSession : public WSSSession
{
public:
    using WSSSession::WSSSession;

protected:
    void onWSReceived(const void* buffer, size_t size) override
    {
        // Resend the message back to the client
        SendBinaryAsync(buffer, size);
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class EchoServer : public WSSServer
{
public:
    using WSSServer::WSSServer;

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<EchoSession>(std::dynamic_pointer_cast<WSSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new echo server
    auto server = std::make_shared<EchoServer>(service, context, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`performance/wss_multicast_client.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/wss_client.h"

#include "benchmark/reporter_console.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

std::atomic<uint64_t> timestamp_start(Timestamp::nano());
std::atomic<uint64_t> timestamp_stop(Timestamp::nano());

std::atomic<uint64_t> total_errors(0);
std::atomic<uint64_t> total_bytes(0);
std::atomic<uint64_t> total_messages(0);

class MulticastClient : public WSSClient
{
public:
    using WSSClient::WSSClient;

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "https://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }

    void onWSReceived(const void* buffer, size_t size) override
    {
        total_bytes += size;
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure client caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        ++total_errors;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-a", "--address").dest("address").set_default("127.0.0.1").help("Server address. Default: %default");
    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-c", "--clients").dest("clients").action("store").type("int").set_default(100).help("Count of working clients. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");
    parser.add_option("-z", "--seconds").dest("seconds").action("store").type("int").set_default(10).help("Count of seconds to benchmarking. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Client parameters
    std::string address(options.get("address"));
    int port = options.get("port");
    int threads_count = options.get("threads");
    int clients_count = options.get("clients");
    int message_size = options.get("size");
    int seconds_count = options.get("seconds");

    std::cout << "Server address: " << address << std::endl;
    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads_count << std::endl;
    std::cout << "Working clients: " << clients_count << std::endl;
    std::cout << "Message size: " << message_size << std::endl;
    std::cout << "Seconds to benchmarking: " << seconds_count << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads_count);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL client context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_default_verify_paths();
    context->set_root_certs();
    context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
    context->load_verify_file("../tools/certificates/ca.pem");

    // Create multicast clients
    std::vector<std::shared_ptr<MulticastClient>> clients;
    for (int i = 0; i < clients_count; ++i)
    {
        auto client = std::make_shared<MulticastClient>(service, context, address, port);
        // client->SetupNoDelay(true);
        clients.emplace_back(client);
    }

    timestamp_start = Timestamp::nano();

    // Connect clients
    std::cout << "Clients connecting...";
    for (auto& client : clients)
        client->ConnectAsync();
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (!client->IsConnected())
            Thread::Yield();
    std::cout << "All clients connected!" << std::endl;

    // Wait for benchmarking
    std::cout << "Benchmarking...";
    Thread::Sleep(seconds_count * 1000);
    std::cout << "Done!" << std::endl;

    // Disconnect clients
    std::cout << "Clients disconnecting...";
    for (auto& client : clients)
        client->CloseAsync(1000);
    std::cout << "Done!" << std::endl;
    for (const auto& client : clients)
        while (client->IsConnected())
            Thread::Yield();
    std::cout << "All clients disconnected!" << std::endl;

    timestamp_stop = Timestamp::nano();

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    std::cout << std::endl;

    std::cout << "Errors: " << total_errors << std::endl;

    std::cout << std::endl;

    total_messages = total_bytes / message_size;

    std::cout << "Total time: " << CppBenchmark::ReporterConsole::GenerateTimePeriod(timestamp_stop - timestamp_start) << std::endl;
    std::cout << "Total data: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes) << std::endl;
    std::cout << "Total messages: " << total_messages << std::endl;
    std::cout << "Data throughput: " << CppBenchmark::ReporterConsole::GenerateDataSize(total_bytes * 1000000000 / (timestamp_stop - timestamp_start)) << "/s" << std::endl;
    if (total_messages > 0)
    {
        std::cout << "Message latency: " << CppBenchmark::ReporterConsole::GenerateTimePeriod((timestamp_stop - timestamp_start) / total_messages) << std::endl;
        std::cout << "Message throughput: " << total_messages * 1000000000 / (timestamp_stop - timestamp_start) << " msg/s" << std::endl;
    }

    return 0;
}

```

`performance/wss_multicast_server.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 28.05.2019
//

#include "server/asio/service.h"
#include "server/ws/wss_server.h"
#include "system/cpu.h"
#include "threads/thread.h"
#include "time/timestamp.h"

#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

#include <OptionParser.h>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

class MulticastSession : public WSSSession
{
public:
    using WSSSession::WSSSession;

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

class MulticastServer : public WSSServer
{
public:
    using WSSServer::WSSServer;

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<MulticastSession>(std::dynamic_pointer_cast<WSSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "WebSocket secure server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
    }
};

int main(int argc, char** argv)
{
    auto parser = optparse::OptionParser().version("1.0.0.0");

    parser.add_option("-p", "--port").dest("port").action("store").type("int").set_default(8443).help("Server port. Default: %default");
    parser.add_option("-t", "--threads").dest("threads").action("store").type("int").set_default(CPU::PhysicalCores()).help("Count of working threads. Default: %default");
    parser.add_option("-m", "--messages").dest("messages").action("store").type("int").set_default(1000000).help("Rate of messages per second to send. Default: %default");
    parser.add_option("-s", "--size").dest("size").action("store").type("int").set_default(32).help("Single message size. Default: %default");

    optparse::Values options = parser.parse_args(argc, argv);

    // Print help
    if (options.get("help"))
    {
        parser.print_help();
        return 0;
    }

    // Server port
    int port = options.get("port");
    int threads = options.get("threads");
    int messages_rate = options.get("messages");
    int message_size = options.get("size");

    std::cout << "Server port: " << port << std::endl;
    std::cout << "Working threads: " << threads << std::endl;
    std::cout << "Messages rate: " << messages_rate << std::endl;
    std::cout << "Message size: " << message_size << std::endl;

    std::cout << std::endl;

    // Create a new Asio service
    auto service = std::make_shared<Service>(threads);

    // Start the Asio service
    std::cout << "Asio service starting...";
    service->Start();
    std::cout << "Done!" << std::endl;

    // Create and prepare a new SSL server context
    auto context = std::make_shared<CppServer::Asio::SSLContext>(asio::ssl::context::tlsv13);
    context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
    context->use_certificate_chain_file("../tools/certificates/server.pem");
    context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
    context->use_tmp_dh_file("../tools/certificates/dh4096.pem");

    // Create a new multicast server
    auto server = std::make_shared<MulticastServer>(service, context, port);
    // server->SetupNoDelay(true);
    server->SetupReuseAddress(true);
    server->SetupReusePort(true);

    // Start the server
    std::cout << "Server starting...";
    server->Start();
    std::cout << "Done!" << std::endl;

    // Start the multicasting thread
    std::atomic<bool> multicasting(true);
    auto multicaster = std::thread([&server, &multicasting, messages_rate, message_size]()
    {
        // Prepare message to multicast
        std::vector<uint8_t> message_to_send(message_size);

        // Multicasting loop
        while (multicasting)
        {
            auto start = UtcTimestamp();
            for (int i = 0; i < messages_rate; ++i)
                server->MulticastBinary(message_to_send.data(), message_to_send.size());
            auto end = UtcTimestamp();

            // Sleep for remaining time or yield
            auto milliseconds = (end - start).milliseconds();
            if (milliseconds < 1000)
                Thread::Sleep(1000 - milliseconds);
            else
                Thread::Yield();
        }
    });

    std::cout << "Press Enter to stop the server or '!' to restart the server..." << std::endl;

    // Perform text input
    std::string line;
    while (getline(std::cin, line))
    {
        if (line.empty())
            break;

        // Restart the server
        if (line == "!")
        {
            std::cout << "Server restarting...";
            server->Restart();
            std::cout << "Done!" << std::endl;
            continue;
        }
    }

    // Stop the multicasting thread
    multicasting = false;
    multicaster.join();

    // Stop the server
    std::cout << "Server stopping...";
    server->Stop();
    std::cout << "Done!" << std::endl;

    // Stop the Asio service
    std::cout << "Asio service stopping...";
    service->Stop();
    std::cout << "Done!" << std::endl;

    return 0;
}

```

`proto/fbe.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "fbe.h"

#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#include <rpc.h>
#undef DELETE
#undef ERROR
#undef Yield
#undef min
#undef max
#undef uuid_t
#endif

namespace FBE {

std::string buffer_t::base64encode() const
{
    const char base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    std::string result;

    int val = 0;
    int valb = -6;
    for (auto c : _data)
    {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0)
        {
            result.push_back(base64[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }

    if (valb > -6)
        result.push_back(base64[((val << 8) >> (valb + 8)) & 0x3F]);

    while (result.size() % 4)
        result.push_back('=');

    return result;
}

buffer_t buffer_t::base64decode(const std::string& str)
{
    const char base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    buffer_t result;

    std::vector<int> pattern(256, -1);
    for (int i = 0; i < 64; ++i)
        pattern[base64[i]] = i;

    int val = 0;
    int valb = -8;
    for (auto c : str)
    {
        if (pattern[c] == -1)
            break;

        val = (val << 6) + pattern[c];
        valb += 6;

        if (valb >= 0)
        {
            result.push_back((uint8_t)((val >> valb) & 0xFF));
            valb -= 8;
        }
    }

    return result;
}

uint64_t utc()
{
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    struct timespec timestamp;
    if (clock_gettime(CLOCK_REALTIME, &timestamp) != 0)
        throw std::runtime_error("Cannot get value of CLOCK_REALTIME timer!");
    return (timestamp.tv_sec * 1000000000) + timestamp.tv_nsec;
#elif defined(_WIN32) || defined(_WIN64)
    FILETIME ft;
    GetSystemTimePreciseAsFileTime(&ft);

    ULARGE_INTEGER result;
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;
    return (result.QuadPart - 116444736000000000ull) * 100;
#endif
}

uint8_t unhex(char ch)
{
    if ((ch >= '0') && (ch <= '9'))
        return ch - '0';
    else if ((ch >= 'a') && (ch <= 'f'))
        return 10 + ch - 'a';
    else if ((ch >= 'A') && (ch <= 'F'))
        return 10 + ch - 'A';
    else
        return 255;
}

uuid_t::uuid_t(const std::string& uuid)
{
    char v1 = 0;
    char v2 = 0;
    bool pack = false;
    size_t index = 0;

    // Parse UUID string
    for (auto ch : uuid)
    {
        if ((ch == '-') || (ch == '{') || (ch == '}'))
            continue;

        if (pack)
        {
            v2 = ch;
            pack = false;
            uint8_t ui1 = unhex(v1);
            uint8_t ui2 = unhex(v2);
            if ((ui1 > 15) || (ui2 > 15))
                throw std::invalid_argument("Invalid UUID string: " + uuid);
            _data[index++] = ui1 * 16 + ui2;
            if (index >= 16)
                break;
        }
        else
        {
            v1 = ch;
            pack = true;
        }
    }

    // Fill remaining data with zeros
    for (; index < 16; ++index)
        _data[index++] = 0;
}

std::string uuid_t::string() const
{
    const char* digits = "0123456789abcdef";

    std::string result(36, '0');

    int index = 0;
    for (auto value : _data)
    {
        result[index++] = digits[(value >> 4) & 0x0F];
        result[index++] = digits[(value >> 0) & 0x0F];
        if ((index == 8) || (index == 13) || (index == 18) || (index == 23))
            result[index++] = '-';
    }

    return result;
}

uuid_t uuid_t::sequential()
{
    uuid_t result;
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    ::uuid_t uuid;
    uuid_generate_time(uuid);
    result._data[0] = uuid[0];
    result._data[1] = uuid[1];
    result._data[2] = uuid[2];
    result._data[3] = uuid[3];
    result._data[4] = uuid[4];
    result._data[5] = uuid[5];
    result._data[6] = uuid[6];
    result._data[7] = uuid[7];
    result._data[8] = uuid[8];
    result._data[9] = uuid[9];
    result._data[10] = uuid[10];
    result._data[11] = uuid[11];
    result._data[12] = uuid[12];
    result._data[13] = uuid[13];
    result._data[14] = uuid[14];
    result._data[15] = uuid[15];
#elif defined(_WIN32) || defined(_WIN64)
    ::UUID uuid;
    if (UuidCreateSequential(&uuid) != RPC_S_OK)
        throw std::runtime_error("Cannot generate sequential UUID!");

    result._data[0] = (uuid.Data1 >> 24) & 0xFF;
    result._data[1] = (uuid.Data1 >> 16) & 0xFF;
    result._data[2] = (uuid.Data1 >>  8) & 0xFF;
    result._data[3] = (uuid.Data1 >>  0) & 0xFF;
    result._data[4] = (uuid.Data2 >>  8) & 0xFF;
    result._data[5] = (uuid.Data2 >>  0) & 0xFF;

    result._data[6] = (uuid.Data3 >>  8) & 0xFF;
    result._data[7] = (uuid.Data3 >>  0) & 0xFF;

    result._data[8] = uuid.Data4[0];
    result._data[9] = uuid.Data4[1];

    result._data[10] = uuid.Data4[2];
    result._data[11] = uuid.Data4[3];
    result._data[12] = uuid.Data4[4];
    result._data[13] = uuid.Data4[5];
    result._data[14] = uuid.Data4[6];
    result._data[15] = uuid.Data4[7];
#endif
    return result;
}

uuid_t uuid_t::random()
{
    uuid_t result;
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    ::uuid_t uuid;
    uuid_generate_random(uuid);
    result._data[0] = uuid[0];
    result._data[1] = uuid[1];
    result._data[2] = uuid[2];
    result._data[3] = uuid[3];
    result._data[4] = uuid[4];
    result._data[5] = uuid[5];
    result._data[6] = uuid[6];
    result._data[7] = uuid[7];
    result._data[8] = uuid[8];
    result._data[9] = uuid[9];
    result._data[10] = uuid[10];
    result._data[11] = uuid[11];
    result._data[12] = uuid[12];
    result._data[13] = uuid[13];
    result._data[14] = uuid[14];
    result._data[15] = uuid[15];
#elif defined(_WIN32) || defined(_WIN64)
    ::UUID uuid;
    if (UuidCreate(&uuid) != RPC_S_OK)
        throw std::runtime_error("Cannot generate random UUID!");

    result._data[0] = (uuid.Data1 >> 24) & 0xFF;
    result._data[1] = (uuid.Data1 >> 16) & 0xFF;
    result._data[2] = (uuid.Data1 >>  8) & 0xFF;
    result._data[3] = (uuid.Data1 >>  0) & 0xFF;
    result._data[4] = (uuid.Data2 >>  8) & 0xFF;
    result._data[5] = (uuid.Data2 >>  0) & 0xFF;

    result._data[6] = (uuid.Data3 >>  8) & 0xFF;
    result._data[7] = (uuid.Data3 >>  0) & 0xFF;

    result._data[8] = uuid.Data4[0];
    result._data[9] = uuid.Data4[1];

    result._data[10] = uuid.Data4[2];
    result._data[11] = uuid.Data4[3];
    result._data[12] = uuid.Data4[4];
    result._data[13] = uuid.Data4[5];
    result._data[14] = uuid.Data4[6];
    result._data[15] = uuid.Data4[7];
#endif
    return result;
}

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, const uuid_t& uuid)
{
    const char* digits = "0123456789abcdef";

    std::array<char, 36> result;

    int index = 0;
    for (auto value : uuid.data())
    {
        result[index++] = digits[(value >> 4) & 0x0F];
        result[index++] = digits[(value >> 0) & 0x0F];
        if ((index == 8) || (index == 13) || (index == 18) || (index == 23))
            result[index++] = '-';
    }

    return record.StoreCustom(std::string_view(result.data(), result.size()));
}
#endif

void FBEBuffer::attach(const void* data, size_t size, size_t offset)
{
    assert((data != nullptr) && "Invalid buffer!");
    if (data == nullptr)
        throw std::invalid_argument("Invalid buffer!");
    assert((size > 0) && "Invalid size!");
    if (size == 0)
        throw std::invalid_argument("Invalid size!");
    assert((offset <= size) && "Invalid offset!");
    if (offset > size)
        throw std::invalid_argument("Invalid offset!");

    _data = (uint8_t*)data;
    _capacity = 0;
    _size = size;
    _offset = offset;
}

void FBEBuffer::attach(const std::vector<uint8_t>& buffer, size_t offset)
{
    assert((buffer.data() != nullptr) && "Invalid buffer!");
    if (buffer.data() == nullptr)
        throw std::invalid_argument("Invalid buffer!");
    assert((buffer.size() > 0) && "Invalid size!");
    if (buffer.size() == 0)
        throw std::invalid_argument("Invalid size!");
    assert((offset <= buffer.size()) && "Invalid offset!");
    if (offset > buffer.size())
        throw std::invalid_argument("Invalid offset!");

    _data = (uint8_t*)buffer.data();
    _capacity = 0;
    _size = buffer.size();
    _offset = offset;
}

void FBEBuffer::clone(const void* data, size_t size, size_t offset)
{
    assert((offset <= size) && "Invalid offset!");
    if (offset > size)
        throw std::invalid_argument("Invalid offset!");

    reserve(size);
    std::memcpy(_data, data, size);
    _capacity = size;
    _size = size;
    _offset = offset;
}

void FBEBuffer::clone(const std::vector<uint8_t>& buffer, size_t offset)
{
    assert((offset <= buffer.size()) && "Invalid offset!");
    if (offset > buffer.size())
        throw std::invalid_argument("Invalid offset!");

    size_t size = buffer.size();

    reserve(size);
    std::memcpy(_data, buffer.data(), size);
    _capacity = size;
    _size = size;
    _offset = offset;
}

size_t FBEBuffer::allocate(size_t size)
{
    size_t offset = _size;

    // Calculate a new buffer size
    size_t total = _size + size;

    if (total <= _capacity)
    {
        _size = total;
        return offset;
    }

    _capacity = std::max(total, 2 * _capacity);
    uint8_t* data = (uint8_t*)std::malloc(_capacity);
    std::memcpy(data, _data, _size);
    std::free(_data);
    _data = data;
    _size = total;
    return offset;
}

void FBEBuffer::remove(size_t offset, size_t size)
{
    assert(((offset + size) <= _size) && "Invalid offset & size!");
    if ((offset + size) > _size)
        throw std::invalid_argument("Invalid offset & size!");

    std::memcpy(_data + offset, _data + offset + size, _size - size - offset);
    _size -= size;
    if (_offset >= (offset + size))
        _offset -= size;
    else if (_offset >= offset)
    {
        _offset -= _offset - offset;
        if (_offset > _size)
            _offset = _size;
    }
}

void FBEBuffer::reserve(size_t capacity)
{
    if (capacity > _capacity)
    {
        _capacity = std::max(capacity, 2 * _capacity);
        uint8_t* data = (uint8_t*)std::malloc(_capacity);
        std::memcpy(data, _data, _size);
        std::free(_data);
        _data = data;
    }
}

void FBEBuffer::resize(size_t size)
{
    reserve(size);
    _size = size;
    if (_offset > _size)
        _offset = _size;
}

void FBEBuffer::reset()
{
    _size = 0;
    _offset = 0;
}

} // namespace FBE

```

`proto/fbe.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include <array>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstring>
#include <cctype>
#include <future>
#include <iomanip>
#include <limits>
#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <optional>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <vector>

#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
#include <time.h>
#include <uuid/uuid.h>
#elif defined(_WIN32) || defined(_WIN64)
#undef DELETE
#undef ERROR
#undef Yield
#undef min
#undef max
#undef uuid_t
#endif

namespace FBE {

//! Bytes buffer type
/*!
    Represents bytes buffer which is a lightweight wrapper around std::vector<uint8_t>
    with similar interface.
*/
class buffer_t
{
public:
    typedef std::vector<uint8_t>::iterator iterator;
    typedef std::vector<uint8_t>::const_iterator const_iterator;
    typedef std::vector<uint8_t>::reverse_iterator reverse_iterator;
    typedef std::vector<uint8_t>::const_reverse_iterator const_reverse_iterator;

    buffer_t() = default;
    buffer_t(size_t capacity) { reserve(capacity); }
    buffer_t(const std::string& str) { assign(str); }
    buffer_t(size_t size, uint8_t value) { assign(size, value); }
    buffer_t(const uint8_t* data, size_t size) { assign(data, size); }
    buffer_t(const std::vector<uint8_t>& other) : _data(other) {}
    buffer_t(std::vector<uint8_t>&& other) : _data(std::move(other)) {}
    buffer_t(const buffer_t& other) = default;
    buffer_t(buffer_t&& other) = default;
    ~buffer_t() = default;

    buffer_t& operator=(const std::string& str) { assign(str); return *this; }
    buffer_t& operator=(const std::vector<uint8_t>& other) { _data = other; return *this; }
    buffer_t& operator=(std::vector<uint8_t>&& other) { _data = std::move(other); return *this; }
    buffer_t& operator=(const buffer_t& other) = default;
    buffer_t& operator=(buffer_t&& other) = default;

    uint8_t& operator[](size_t index) { return _data[index]; }
    const uint8_t& operator[](size_t index) const { return _data[index]; }

    bool empty() const { return _data.empty(); }
    size_t capacity() const { return _data.capacity(); }
    size_t size() const { return _data.size(); }
    size_t max_size() const { return _data.max_size(); }

    std::vector<uint8_t>& buffer() noexcept { return _data; }
    const std::vector<uint8_t>& buffer() const noexcept { return _data; }
    uint8_t* data() noexcept { return _data.data(); }
    const uint8_t* data() const noexcept { return _data.data(); }
    uint8_t& at(size_t index) { return _data.at(index); }
    const uint8_t& at(size_t index) const { return _data.at(index); }
    uint8_t& front() { return _data.front(); }
    const uint8_t& front() const { return _data.front(); }
    uint8_t& back() { return _data.back(); }
    const uint8_t& back() const { return _data.back(); }

    void reserve(size_t capacity) { _data.reserve(capacity); }
    void resize(size_t size, uint8_t value = 0) { _data.resize(size, value); }
    void shrink_to_fit() { _data.shrink_to_fit(); }

    void assign(const std::string& str) { assign((const uint8_t*)str.c_str(), str.size()); }
    void assign(const std::vector<uint8_t>& vec) { assign(vec.begin(), vec.end()); }
    void assign(size_t size, uint8_t value) { _data.assign(size, value); }
    void assign(const uint8_t* data, size_t size) { _data.assign(data, data + size); }
    template <class InputIterator>
    void assign(InputIterator first, InputIterator last) { _data.assign(first, last); }
    iterator insert(const_iterator position, uint8_t value) { return _data.insert(position, value); }
    iterator insert(const_iterator position, const std::string& str) { return insert(position, (const uint8_t*)str.c_str(), str.size()); }
    iterator insert(const_iterator position, const std::vector<uint8_t>& vec) { return insert(position, vec.begin(), vec.end()); }
    iterator insert(const_iterator position, size_t size, uint8_t value) { return _data.insert(position, size, value); }
    iterator insert(const_iterator position, const uint8_t* data, size_t size) { return _data.insert(position, data, data + size); }
    template <class InputIterator>
    iterator insert(const_iterator position, InputIterator first, InputIterator last) { return _data.insert(position, first, last); }
    iterator erase(const_iterator position) { return _data.erase(position); }
    iterator erase(const_iterator first, const_iterator last) { return _data.erase(first, last); }
    void clear() noexcept { _data.clear(); }

    void push_back(uint8_t value) { _data.push_back(value); }
    void pop_back() { _data.pop_back(); }

    template <class... Args>
    iterator emplace(const_iterator position, Args&&... args) { return _data.emplace(position, args...); }
    template <class... Args>
    void emplace_back(Args&&... args) { _data.emplace_back(args...); }

    iterator begin() noexcept { return _data.begin(); }
    const_iterator begin() const noexcept { return _data.begin(); }
    const_iterator cbegin() const noexcept { return _data.cbegin(); }
    reverse_iterator rbegin() noexcept { return _data.rbegin(); }
    const_reverse_iterator rbegin() const noexcept { return _data.rbegin(); }
    const_reverse_iterator crbegin() const noexcept { return _data.crbegin(); }
    iterator end() noexcept { return _data.end(); }
    const_iterator end() const noexcept { return _data.end(); }
    const_iterator cend() const noexcept { return _data.cend(); }
    reverse_iterator rend() noexcept { return _data.rend(); }
    const_reverse_iterator rend() const noexcept { return _data.rend(); }
    const_reverse_iterator crend() const noexcept { return _data.crend(); }

    //! Get the string equivalent from the bytes buffer
    std::string string() const { return std::string(_data.begin(), _data.end()); }

    //! Encode the Base64 string from the bytes buffer
    std::string base64encode() const;
    //! Decode the bytes buffer from the Base64 string
    static buffer_t base64decode(const std::string& str);

    //! Swap two instances
    void swap(buffer_t& value) noexcept
    { using std::swap; swap(_data, value._data); }
    friend void swap(buffer_t& value1, buffer_t& value2) noexcept
    { value1.swap(value2); }

private:
    std::vector<uint8_t> _data;
};

//! Decimal type
/*!
    Represents decimal type using double and provides basic arithmetic operations.
*/
class decimal_t
{
public:
    decimal_t() noexcept { _value = 0.0; }
    decimal_t(int8_t value) noexcept { _value = (double)value; }
    decimal_t(uint8_t value) noexcept { _value = (double)value; }
    decimal_t(int16_t value) noexcept { _value = (double)value; }
    decimal_t(uint16_t value) noexcept { _value = (double)value; }
    decimal_t(int32_t value) noexcept { _value = (double)value; }
    decimal_t(uint32_t value) noexcept { _value = (double)value; }
    decimal_t(int64_t value) noexcept { _value = (double)value; }
    decimal_t(uint64_t value) noexcept { _value = (double)value; }
    decimal_t(float value) noexcept { _value = (double)value; }
    decimal_t(double value) noexcept { _value = value; }
    template <typename T>
    explicit decimal_t(const T& value) noexcept { _value = (double)value; }
    decimal_t(const decimal_t& value) noexcept = default;
    decimal_t(decimal_t&& value) noexcept = default;
    ~decimal_t() noexcept = default;

    template <typename T>
    decimal_t& operator=(const T& value) noexcept { _value = (double)value; return *this; }
    decimal_t& operator=(const decimal_t& value) noexcept = default;
    decimal_t& operator=(decimal_t&& value) noexcept = default;

    // Arithmetic operators
    decimal_t operator+() const noexcept { return decimal_t(_value); }
    decimal_t operator-() const noexcept { return decimal_t(-_value); }

    decimal_t& operator++() noexcept { return *this += 1; }
    decimal_t operator++(int) noexcept { decimal_t temp(*this); ++*this; return temp; }
    decimal_t& operator--() noexcept { return *this -= 1; }
    decimal_t operator--(int) noexcept { decimal_t temp(*this); --*this; return temp; }

    decimal_t& operator+=(const decimal_t& value) noexcept { return *this = *this + value; }
    decimal_t& operator-=(const decimal_t& value) noexcept { return *this = *this - value; }
    decimal_t& operator*=(const decimal_t& value) noexcept { return *this = *this * value; }
    decimal_t& operator/=(const decimal_t& value) { return *this = *this / value; }

    template <typename T>
    decimal_t& operator+=(const T& value) noexcept { return *this = *this + decimal_t(value); }
    template <typename T>
    decimal_t& operator-=(const T& value) noexcept { return *this = *this - decimal_t(value); }
    template <typename T>
    decimal_t& operator*=(const T& value) noexcept { return *this = *this * decimal_t(value); }
    template <typename T>
    decimal_t& operator/=(const T& value) { return *this = *this / decimal_t(value); }

    template <typename T>
    friend T& operator+=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) + value2); }
    template <typename T>
    friend T& operator-=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) - value2); }
    template <typename T>
    friend T& operator*=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) * value2); }
    template <typename T>
    friend T& operator/=(T& value1, const decimal_t& value2) { return value1 = (T)(decimal_t(value1) / value2); }

    template <typename T>
    friend decimal_t operator+(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) + value2; }
    template <typename T>
    friend decimal_t operator+(const decimal_t& value1, const T& value2) noexcept { return value1 + decimal_t(value2); }
    friend decimal_t operator+(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value + value2._value); }

    template <typename T>
    friend decimal_t operator-(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) - value2; }
    template <typename T>
    friend decimal_t operator-(const decimal_t& value1, const T& value2) noexcept { return value1 - decimal_t(value2); }
    friend decimal_t operator-(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value - value2._value); }

    template <typename T>
    friend decimal_t operator*(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) * value2; }
    template <typename T>
    friend decimal_t operator*(const decimal_t& value1, const T& value2) noexcept { return value1 * decimal_t(value2); }
    friend decimal_t operator*(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value * value2._value); }

    template <typename T>
    friend decimal_t operator/(const T& value1, const decimal_t& value2) { return decimal_t(value1) / value2; }
    template <typename T>
    friend decimal_t operator/(const decimal_t& value1, const T& value2) { return value1 / decimal_t(value2); }
    friend decimal_t operator/(const decimal_t& value1, const decimal_t& value2) { return decimal_t(value1._value / value2._value); }

    // Comparison operators
    template <typename T>
    friend bool operator==(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) == value2; }
    template <typename T>
    friend bool operator==(const decimal_t& value1, const T& value2) noexcept { return value1 == decimal_t(value2); }
    friend bool operator==(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value == value2._value; }

    template <typename T>
    friend bool operator!=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) != value2; }
    template <typename T>
    friend bool operator!=(const decimal_t& value1, const T& value2) noexcept { return value1 != decimal_t(value2); }
    friend bool operator!=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value != value2._value; }

    template <typename T>
    friend bool operator<(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) < value2; }
    template <typename T>
    friend bool operator<(const decimal_t& value1, const T& value2) noexcept { return value1 < decimal_t(value2); }
    friend bool operator<(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value < value2._value; }

    template <typename T>
    friend bool operator>(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) > value2; }
    template <typename T>
    friend bool operator>(const decimal_t& value1, const T& value2) noexcept { return value1 > decimal_t(value2); }
    friend bool operator>(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value > value2._value; }

    template <typename T>
    friend bool operator<=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) <= value2; }
    template <typename T>
    friend bool operator<=(const decimal_t& value1, const T& value2) noexcept { return value1 <= decimal_t(value2); }
    friend bool operator<=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value <= value2._value; }

    template <typename T>
    friend bool operator>=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) >= value2; }
    template <typename T>
    friend bool operator>=(const decimal_t& value1, const T& value2) noexcept { return value1 >= decimal_t(value2); }
    friend bool operator>=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value >= value2._value; }

    // Type cast
    operator bool() const noexcept { return (_value != 0.0); }
    operator uint8_t() const noexcept { return (uint8_t)_value; }
    operator uint16_t() const noexcept { return (uint16_t)_value; }
    operator uint32_t() const noexcept { return (uint32_t)_value; }
    operator uint64_t() const noexcept { return (uint64_t)_value; }
    operator float() const noexcept { return (float)_value; }
    operator double() const noexcept { return (double)_value; }

    //! Get string from the current decimal value
    std::string string() const { return std::to_string(_value); }

    //! Input instance from the given input stream
    friend std::istream& operator>>(std::istream& is, decimal_t& value)
    { is >> value._value; return is; }
    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const decimal_t& value)
    { os << value.string(); return os; }

#if defined(LOGGING_PROTOCOL)
    //! Store logging format
    friend CppLogging::Record& operator<<(CppLogging::Record& record, const decimal_t& value)
    { return record.StoreCustom(value._value); }
#endif

    //! Swap two instances
    void swap(decimal_t& value) noexcept
    { using std::swap; swap(_value, value._value); }
    friend void swap(decimal_t& value1, decimal_t& value2) noexcept
    { value1.swap(value2); }

private:
    double _value;
};

} // namespace FBE

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <>
struct fmt::formatter<FBE::decimal_t> : formatter<std::string_view>
{
    template <typename FormatContext>
    auto format(const FBE::decimal_t& value, FormatContext& ctx) const
    {
        return formatter<string_view>::format((double)value, ctx);
    }
};
#endif

template <>
struct std::hash<FBE::decimal_t>
{
    typedef FBE::decimal_t argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<double>()((double)value);
        return result;
    }
};

namespace FBE {

// Register a new enum-based flags macro
#define FBE_ENUM_FLAGS(type)\
inline FBE::Flags<type> operator|(type f1, type f2) noexcept { return FBE::Flags<type>(f1) | FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator&(type f1, type f2) noexcept { return FBE::Flags<type>(f1) & FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator^(type f1, type f2) noexcept { return FBE::Flags<type>(f1) ^ FBE::Flags<type>(f2); }

// Enum-based flags
template <typename TEnum>
class Flags
{
    // Enum underlying type
    typedef typename std::make_unsigned<typename std::underlying_type<TEnum>::type>::type type;

public:
    Flags() noexcept : _value(0) {}
    explicit Flags(type value) noexcept : _value(value) {}
    explicit Flags(TEnum value) noexcept : _value((type)value) {}
    Flags(const Flags&) noexcept = default;
    Flags(Flags&&) noexcept = default;
    ~Flags() noexcept = default;

    Flags& operator=(type value) noexcept
    { _value = value; return *this; }
    Flags& operator=(TEnum value) noexcept
    { _value = (type)value; return *this; }
    Flags& operator=(const Flags&) noexcept = default;
    Flags& operator=(Flags&&) noexcept = default;

    // Is any flag set?
    explicit operator bool() const noexcept { return isset(); }

    // Is no flag set?
    bool operator!() const noexcept { return !isset(); }

    // Reverse all flags
    Flags operator~() const noexcept { return Flags(~_value); }

    // Flags logical assign operators
    Flags& operator&=(const Flags& flags) noexcept
    { _value &= flags._value; return *this; }
    Flags& operator|=(const Flags& flags) noexcept
    { _value |= flags._value; return *this; }
    Flags& operator^=(const Flags& flags) noexcept
    { _value ^= flags._value; return *this; }

    // Flags logical friend operators
    friend Flags operator&(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value & flags2._value); }
    friend Flags operator|(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value | flags2._value); }
    friend Flags operator^(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value ^ flags2._value); }

    // Flags comparison
    friend bool operator==(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value == flags2._value; }
    friend bool operator!=(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value != flags2._value; }

    // Convert to the enum value
    operator TEnum() const noexcept { return (TEnum)_value; }

    //! Is any flag set?
    bool isset() const noexcept { return (_value != 0); }
    //! Is the given flag set?
    bool isset(type value) const noexcept { return (_value & value) != 0; }
    //! Is the given flag set?
    bool isset(TEnum value) const noexcept { return (_value & (type)value) != 0; }

    // Get the enum value
    TEnum value() const noexcept { return (TEnum)_value; }
    // Get the underlying enum value
    type underlying() const noexcept { return _value; }
    // Get the bitset value
    std::bitset<sizeof(type) * 8> bitset() const noexcept { return {_value}; }

    // Swap two instances
    void swap(Flags& flags) noexcept { using std::swap; swap(_value, flags._value); }
    template <typename UEnum>
    friend void swap(Flags<UEnum>& flags1, Flags<UEnum>& flags2) noexcept;

private:
    type _value;
};

template <typename TEnum>
inline void swap(Flags<TEnum>& flags1, Flags<TEnum>& flags2) noexcept
{
    flags1.swap(flags2);
}

// Get Epoch timestamp
inline uint64_t epoch() { return 0ull; }
// Get UTC timestamp
uint64_t utc();

//! Universally unique identifier (UUID)
/*!
    A universally unique identifier (UUID) is an identifier standard used
    in software construction. This implementation generates the following
    UUID types:
    - Nil UUID0 (all bits set to zero)
    - Sequential UUID1 (time based version)
    - Random UUID4 (randomly or pseudo-randomly generated version)

    A UUID is simply a 128-bit value: "123e4567-e89b-12d3-a456-426655440000"

    https://en.wikipedia.org/wiki/Universally_unique_identifier
    https://www.ietf.org/rfc/rfc4122.txt
*/
class uuid_t
{
public:
    //! Default constructor
    uuid_t() : _data() { _data.fill(0); }
    //! Initialize UUID with a given string
    /*!
        \param uuid - UUID string
    */
    explicit uuid_t(const std::string& uuid);
    //! Initialize UUID with a given 16 bytes data buffer
    /*!
        \param data - UUID 16 bytes data buffer
    */
    explicit uuid_t(const std::array<uint8_t, 16>& data) : _data(data) {}
    uuid_t(const uuid_t&) = default;
    uuid_t(uuid_t&&) noexcept = default;
    ~uuid_t() = default;

    uuid_t& operator=(const std::string& uuid)
    { _data = uuid_t(uuid).data(); return *this; }
    uuid_t& operator=(const std::array<uint8_t, 16>& data)
    { _data = data; return *this; }
    uuid_t& operator=(const uuid_t&) = default;
    uuid_t& operator=(uuid_t&&) noexcept = default;

    // UUID comparison
    friend bool operator==(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data == uuid2._data; }
    friend bool operator!=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data != uuid2._data; }
    friend bool operator<(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data < uuid2._data; }
    friend bool operator>(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data > uuid2._data; }
    friend bool operator<=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data <= uuid2._data; }
    friend bool operator>=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data >= uuid2._data; }

    //! Check if the UUID is nil UUID0 (all bits set to zero)
    explicit operator bool() const noexcept { return *this != nil(); }

    //! Get the UUID data buffer
    std::array<uint8_t, 16>& data() noexcept { return _data; }
    //! Get the UUID data buffer
    const std::array<uint8_t, 16>& data() const noexcept { return _data; }

    //! Get string from the current UUID in format "00000000-0000-0000-0000-000000000000"
    std::string string() const;

    //! Generate nil UUID0 (all bits set to zero)
    static uuid_t nil() { return uuid_t(); }
    //! Generate sequential UUID1 (time based version)
    static uuid_t sequential();
    //! Generate random UUID4 (randomly or pseudo-randomly generated version)
    static uuid_t random();

    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const uuid_t& uuid)
    { os << uuid.string(); return os; }

#if defined(LOGGING_PROTOCOL)
    //! Store logging format
    friend CppLogging::Record& operator<<(CppLogging::Record& record, const uuid_t& uuid);
#endif

    //! Swap two instances
    void swap(uuid_t& uuid) noexcept
    { using std::swap; swap(_data, uuid._data); }
    friend void swap(uuid_t& uuid1, uuid_t& uuid2) noexcept
    { uuid1.swap(uuid2); }

private:
    std::array<uint8_t, 16> _data;
};

} // namespace FBE

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <>
struct fmt::formatter<FBE::uuid_t> : formatter<std::string_view>
{
    template <typename FormatContext>
    auto format(const FBE::uuid_t& value, FormatContext& ctx) const
    {
        return formatter<string_view>::format(value.string(), ctx);
    }
};
#endif

template <>
struct std::hash<FBE::uuid_t>
{
    typedef FBE::uuid_t argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        std::hash<uint8_t> hasher;
        for (size_t i = 0; i < value.data().size(); ++i)
            result = result * 31 + hasher(value.data()[i]);
        return result;
    }
};

namespace FBE {

// Fast Binary Encoding buffer based on the dynamic byte buffer
class FBEBuffer
{
public:
    FBEBuffer() : _data(nullptr), _capacity(0), _size(0), _offset(0) {}
    // Initialize the read buffer with the given byte buffer and offset
    explicit FBEBuffer(const void* data, size_t size, size_t offset = 0) { attach(data, size, offset); }
    // Initialize the read buffer with the given byte vector and offset
    explicit FBEBuffer(const std::vector<uint8_t>& buffer, size_t offset = 0) { attach(buffer, offset); }
    // Initialize the read buffer with another buffer and offset
    explicit FBEBuffer(const FBEBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    // Initialize the write buffer with the given capacity
    explicit FBEBuffer(size_t capacity) : FBEBuffer() { reserve(capacity); }
    FBEBuffer(const FBEBuffer&) = delete;
    FBEBuffer(FBEBuffer&&) noexcept = delete;
    ~FBEBuffer() { if (_capacity > 0) std::free(_data); }

    FBEBuffer& operator=(const FBEBuffer&) = delete;
    FBEBuffer& operator=(FBEBuffer&&) noexcept = delete;

    bool empty() const noexcept { return (_data == nullptr) || (_size == 0); }
    const uint8_t* data() const noexcept { return _data; }
    uint8_t* data() noexcept { return _data; }
    size_t capacity() const noexcept { return _capacity; }
    size_t size() const noexcept { return _size; }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the current read buffer
    void attach(const void* data, size_t size, size_t offset = 0);
    // Attach the given byte vector with a given offset to the current read buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0);

    // Clone the given buffer with a given offset to the current buffer
    void clone(const void* data, size_t size, size_t offset = 0);
    // Clone the given vector with a given offset to the current buffer
    void clone(const std::vector<uint8_t>& buffer, size_t offset = 0);

    // Allocate memory in the current write buffer and return offset to the allocated memory block
    size_t allocate(size_t size);
    // Remove some memory of the given size from the current write buffer
    void remove(size_t offset, size_t size);
    // Reserve memory of the given capacity in the current write buffer
    void reserve(size_t capacity);
    // Resize the current write buffer
    void resize(size_t size);
    // Reset the current write buffer and its offset
    void reset();

    // Shift the current write buffer offset
    void shift(size_t offset) { _offset += offset; }
    // Unshift the current write buffer offset
    void unshift(size_t offset) { _offset -= offset; }

private:
    uint8_t* _data;
    size_t _capacity;
    size_t _size;
    size_t _offset;
};

// Fast Binary Encoding base model
class Model
{
public:
    Model() : Model(nullptr) {}
    Model(const std::shared_ptr<FBEBuffer>& buffer) { _buffer = buffer ? buffer : std::make_shared<FBEBuffer>(); }
    Model(const Model&) = default;
    Model(Model&&) noexcept = default;
    ~Model() = default;

    Model& operator=(const Model&) = default;
    Model& operator=(Model&&) noexcept = default;

    // Get the model buffer
    FBEBuffer& buffer() noexcept { return *_buffer; }
    const FBEBuffer& buffer() const noexcept { return *_buffer; }

    // Attach the model buffer
    void attach(const void* data, size_t size, size_t offset = 0) { _buffer->attach(data, size, offset); }
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0) { _buffer->attach(buffer, offset); }
    void attach(const FBEBuffer& buffer, size_t offset = 0) { _buffer->attach(buffer.data(), buffer.size(), offset); }

    // Model buffer operations
    size_t allocate(size_t size) { return _buffer->allocate(size); }
    void remove(size_t offset, size_t size) { _buffer->remove(offset, size); }
    void reserve(size_t capacity) { _buffer->reserve(capacity); }
    void resize(size_t size) { _buffer->resize(size); }
    void reset() { _buffer->reset(); }
    void shift(size_t offset) { _buffer->shift(offset); }
    void unshift(size_t offset) { _buffer->unshift(offset); }

private:
    std::shared_ptr<FBEBuffer> _buffer;
};

} // namespace FBE

```

`proto/fbe_models.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "fbe_models.h"

namespace FBE {

uint64_t FieldModel<decimal_t>::extract(double a) noexcept
{
    uint64_t result;
    std::memcpy(&result, &a, sizeof(double));
    return result;
}

uint64_t FieldModel<decimal_t>::uint32x32(uint32_t a, uint32_t b) noexcept
{
    return (uint64_t)a * (uint64_t)b;
}

void FieldModel<decimal_t>::uint64x64(uint64_t a, uint64_t b, uint64_t& low64, uint32_t& high32) noexcept
{
    uint64_t low = uint32x32((uint32_t)a, (uint32_t)b);
    uint64_t mid = uint32x32((uint32_t)a, (uint32_t)(b >> 32));
    uint64_t high = uint32x32((uint32_t)(a >> 32), (uint32_t)(b >> 32));
    high += (mid >> 32);
    low += (mid <<= 32);
    // Test for carry
    if (low < mid)
        high++;

    mid = uint32x32((uint32_t)(a >> 32), (uint32_t)b);
    high += (mid >> 32);
    low += (mid <<= 32);
    // Test for carry
    if (low < mid)
        high++;

    if (high > 0xFFFFFFFFu)
    {
        low64 = 0;
        high32 = 0;
    }
    low64 = low;
    high32 = (uint32_t)high;
}

void FieldModel<decimal_t>::get(decimal_t& value, decimal_t defaults) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
    {
        value = defaults;
        return;
    }

    // Value taken via reverse engineering the double that corresponds to 2^64
    const double ds2to64 = 1.8446744073709552e+019;

    // Read decimal parts
    uint64_t low = *((const uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    uint32_t high = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8));
    uint32_t flags = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12));

    // Calculate decimal value
    double dValue = ((double)low + (double)high * ds2to64) / pow(10.0, (uint8_t)(flags >> 16));
    if (flags & 0x80000000)
        dValue = -dValue;

    value = dValue;
}

void FieldModel<decimal_t>::set(decimal_t value) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    // The most we can scale by is 10^28, which is just slightly more
    // than 2^93.  So a float with an exponent of -94 could just
    // barely reach 0.5, but smaller exponents will always round to zero.
    const uint32_t DBLBIAS = 1022;

    // Get exponent value
    double dValue = (double)value;
    int32_t iExp = (int32_t)(((uint32_t)(extract(dValue) >> 52) & 0x7FFu) - DBLBIAS);
    if ((iExp < -94) || (iExp > 96))
    {
        // Value too big for .NET Decimal (exponent is limited to [-94, 96])
        memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
        return;
    }

    uint32_t flags = 0;
    if (dValue < 0)
    {
        dValue = -dValue;
        flags = 0x80000000;
    }

    // Round the input to a 15-digit integer.  The R8 format has
    // only 15 digits of precision, and we want to keep garbage digits
    // out of the Decimal were making.

    // Calculate max power of 10 input value could have by multiplying
    // the exponent by log10(2).  Using scaled integer multiplcation,
    // log10(2) * 2 ^ 16 = .30103 * 65536 = 19728.3.
    int32_t iPower = 14 - ((iExp * 19728) >> 16);

    // iPower is between -14 and 43
    if (iPower >= 0)
    {
        // We have less than 15 digits, scale input up.
        if (iPower > 28)
            iPower = 28;

        dValue *= pow(10.0, iPower);
    }
    else
    {
        if ((iPower != -1) || (dValue >= 1E15))
            dValue /= pow(10.0, -iPower);
        else
            iPower = 0; // didn't scale it
    }

    assert(dValue < 1E15);
    if ((dValue < 1E14) && (iPower < 28))
    {
        dValue *= 10;
        iPower++;
        assert(dValue >= 1E14);
    }

    // Round to int64
    uint64_t ulMant;
    ulMant = (uint64_t)(int64_t)dValue;
    dValue -= (int64_t)ulMant; // difference between input & integer
    if ((dValue > 0.5) || ((dValue == 0.5) && ((ulMant & 1) != 0)))
        ulMant++;

    if (ulMant == 0)
    {
        // Mantissa is 0
        memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
        return;
    }

    if (iPower < 0)
    {
        // Add -iPower factors of 10, -iPower <= (29 - 15) = 14
        iPower = -iPower;
        if (iPower < 10)
        {
            double pow10 = (double)powl(10.0, iPower);
            uint64_t low64 = uint32x32((uint32_t)ulMant, (uint32_t)pow10);
            uint64_t high64 = uint32x32((uint32_t)(ulMant >> 32), (uint32_t)pow10);
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)low64;
            high64 += low64 >> 32;
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4)) = (uint32_t)high64;
            high64 >>= 32;
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = (uint32_t)high64;
        }
        else
        {
            // Have a big power of 10.
            assert(iPower <= 14);
            uint64_t low64;
            uint32_t high32;
            uint64x64(ulMant, (uint64_t)pow(10.0, iPower), low64, high32);
            *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = low64;
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = high32;
        }
    }
    else
    {
        // Factor out powers of 10 to reduce the scale, if possible.
        // The maximum number we could factor out would be 14.  This
        // comes from the fact we have a 15-digit number, and the
        // MSD must be non-zero -- but the lower 14 digits could be
        // zero.  Note also the scale factor is never negative, so
        // we can't scale by any more than the power we used to
        // get the integer.
        int lmax = iPower;
        if (lmax > 14)
            lmax = 14;

        if ((((uint8_t)ulMant) == 0) && (lmax >= 8))
        {
            const uint32_t den = 100000000;
            uint64_t div = ulMant / den;
            if ((uint32_t)ulMant == (uint32_t)(div * den))
            {
                ulMant = div;
                iPower -= 8;
                lmax -= 8;
            }
        }

        if ((((uint32_t)ulMant & 0xF) == 0) && (lmax >= 4))
        {
            const uint32_t den = 10000;
            uint64_t div = ulMant / den;
            if ((uint32_t)ulMant == (uint32_t)(div * den))
            {
                ulMant = div;
                iPower -= 4;
                lmax -= 4;
            }
        }

        if ((((uint32_t)ulMant & 3) == 0) && (lmax >= 2))
        {
            const uint32_t den = 100;
            uint64_t div = ulMant / den;
            if ((uint32_t)ulMant == (uint32_t)(div * den))
            {
                ulMant = div;
                iPower -= 2;
                lmax -= 2;
            }
        }

        if ((((uint32_t)ulMant & 1) == 0) && (lmax >= 1))
        {
            const uint32_t den = 10;
            uint64_t div = ulMant / den;
            if ((uint32_t)ulMant == (uint32_t)(div * den))
            {
                ulMant = div;
                iPower--;
            }
        }

        flags |= (uint32_t)iPower << 16;

        *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = ulMant;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = 0;
    }

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12)) = flags;
}

void FieldModel<uuid_t>::get(uuid_t& value, uuid_t defaults) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
    {
        value = defaults;
        return;
    }

    std::memcpy(value.data().data(), (const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), fbe_size());
}

void FieldModel<uuid_t>::set(uuid_t value) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    std::memcpy((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), value.data().data(), fbe_size());
}

size_t FieldModel<buffer_t>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
    return (size_t)(4 + fbe_bytes_size);
}

bool FieldModel<buffer_t>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_bytes_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
    if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
        return false;

    return true;
}

size_t FieldModel<buffer_t>::get(void* data, size_t size) const noexcept
{
    assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
    if ((size > 0) && (data == nullptr))
        return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_bytes_offset == 0)
        return 0;

    assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
        return 0;

    uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
    assert(((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
        return 0;

    size_t result = std::min(size, (size_t)fbe_bytes_size);
    memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), result);
    return result;
}

void FieldModel<buffer_t>::get(std::vector<uint8_t>& value) const noexcept
{
    value.clear();

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_bytes_offset == 0)
        return;

    assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
        return;

    uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
    assert(((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
        return;

    const char* fbe_bytes = (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4);
    value.assign(fbe_bytes, fbe_bytes + fbe_bytes_size);
}

void FieldModel<buffer_t>::set(const void* data, size_t size)
{
    assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
    if ((size > 0) && (data == nullptr))
        return;

    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_bytes_size = (uint32_t)size;
    uint32_t fbe_bytes_offset = (uint32_t)(_buffer.allocate(4 + fbe_bytes_size) - _buffer.offset());
    assert(((fbe_bytes_offset > 0) && ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size()))
        return;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_bytes_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset)) = fbe_bytes_size;

    memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), data, fbe_bytes_size);
}

size_t FieldModel<std::string>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
    return (size_t)(4 + fbe_string_size);
}

bool FieldModel<std::string>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_string_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
    if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
        return false;

    return true;
}

size_t FieldModel<std::string>::get(char* data, size_t size) const noexcept
{
    assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
    if ((size > 0) && (data == nullptr))
        return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_string_offset == 0)
        return 0;

    assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
        return 0;

    uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
    assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
        return 0;

    size_t result = std::min(size, (size_t)fbe_string_size);
    memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), result);
    return result;
}

void FieldModel<std::string>::get(std::string& value) const noexcept
{
    value.clear();

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
    if (fbe_string_offset == 0)
        return;

    assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
        return;

    uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
    assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
        return;

    value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
}

void FieldModel<std::string>::get(std::string& value, const std::string& defaults) const noexcept
{
    value = defaults;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
    if (fbe_string_offset == 0)
        return;

    assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
        return;

    uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
    assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
        return;

    value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
}

void FieldModel<std::string>::set(const char* data, size_t size)
{
    assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
    if ((size > 0) && (data == nullptr))
        return;

    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_string_size = (uint32_t)size;
    uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
    assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size()))
        return;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

    memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), data, fbe_string_size);
}

void FieldModel<std::string>::set(const std::string& value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_string_size = (uint32_t)value.size();
    uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
    assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size()))
        return;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

    memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), value.data(), fbe_string_size);
}

} // namespace FBE

```

`proto/fbe_models.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace FBE {

// Fast Binary Encoding base field model
template <typename T, typename TBase = T>
class FieldModelBase
{
public:
    FieldModelBase(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return sizeof(TBase); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    bool verify() const noexcept { return true; }

    // Get the field value
    void get(T& value, T defaults = (T)0) const noexcept;
    // Set the field value
    void set(T value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model
template <typename T>
class FieldModel : public FieldModelBase<T>
{
public:
    using FieldModelBase<T>::FieldModelBase;
};

// Fast Binary Encoding field model bool specialization
template <>
class FieldModel<bool> : public FieldModelBase<bool, uint8_t>
{
public:
    using FieldModelBase<bool, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model char specialization
template <>
class FieldModel<char> : public FieldModelBase<char, uint8_t>
{
public:
    using FieldModelBase<char, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model wchar specialization
template <>
class FieldModel<wchar_t> : public FieldModelBase<wchar_t, uint32_t>
{
public:
    using FieldModelBase<wchar_t, uint32_t>::FieldModelBase;
};

// Fast Binary Encoding field model decimal specialization
template <>
class FieldModel<decimal_t>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 16; }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the decimal value is valid
    bool verify() const noexcept { return true; }

    // Get the decimal value
    void get(decimal_t& value, decimal_t defaults = decimal_t()) const noexcept;
    // Set the decimal value
    void set(decimal_t value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

    static uint64_t extract(double a) noexcept;
    static uint64_t uint32x32(uint32_t a, uint32_t b) noexcept;
    static void uint64x64(uint64_t a, uint64_t b, uint64_t& low64, uint32_t& high32) noexcept;
};

// Fast Binary Encoding field model UUID specialization
template <>
class FieldModel<uuid_t>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 16; }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the UUID value is valid
    bool verify() const noexcept { return true; }

    // Get the UUID value
    void get(uuid_t& value, uuid_t defaults = uuid_t::nil()) const noexcept;
    // Set the UUID value
    void set(uuid_t value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model bytes specialization
template <>
class FieldModel<buffer_t>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept;

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    bool verify() const noexcept;

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept;
    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept { return get(data, N); }
    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the bytes value
    void get(std::vector<uint8_t>& value) const noexcept;
    // Get the bytes value
    void get(buffer_t& value) const noexcept { get(value.buffer()); }

    // Set the bytes value
    void set(const void* data, size_t size);
    // Set the bytes value
    template <size_t N>
    void set(const uint8_t (&data)[N]) { set(data, N); }
    // Set the bytes value
    template <size_t N>
    void set(const std::array<uint8_t, N>& data) { set(data.data(), data.size()); }
    // Set the bytes value
    void set(const std::vector<uint8_t>& value) { set(value.data(), value.size()); }
    // Set the bytes value
    void set(const buffer_t& value) { set(value.buffer()); }

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model string specialization
template <>
class FieldModel<std::string>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept;

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    bool verify() const noexcept;

    // Get the string value
    size_t get(char* data, size_t size) const noexcept;
    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept { return get(data, N); }
    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the string value
    void get(std::string& value) const noexcept;
    // Get the string value
    void get(std::string& value, const std::string& defaults) const noexcept;

    // Set the string value
    void set(const char* data, size_t size);
    // Set the string value
    template <size_t N>
    void set(const char (&data)[N]) { set(data, N); }
    // Set the string value
    template <size_t N>
    void set(const std::array<char, N>& data) { set(data.data(), data.size()); }
    // Set the string value
    void set(const std::string& value);

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model optional specialization
template <typename T>
class FieldModel<std::optional<T>>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 1 + 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept;

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks if the object contains a value
    bool has_value() const noexcept;

    // Check if the optional value is valid
    bool verify() const noexcept;

    // Get the optional value (being phase)
    size_t get_begin() const noexcept;
    // Get the optional value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the optional value
    void get(std::optional<T>& opt, const std::optional<T>& defaults = std::nullopt) const noexcept;

    // Set the optional value (begin phase)
    size_t set_begin(bool has_value);
    // Set the optional value (end phase)
    void set_end(size_t fbe_begin);

    // Set the optional value
    void set(const std::optional<T>& opt);

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    // Base field model value
    FieldModel<T> value;
};

// Fast Binary Encoding field model array
template <typename T, size_t N>
class FieldModelArray
{
public:
    FieldModelArray(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), _model(buffer, offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return N * _model.fbe_size(); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the array
    const uint8_t* data() const noexcept;
    // Get the array
    uint8_t* data() noexcept;
    // Get the array offset
    size_t offset() const noexcept { return 0; }
    // Get the array size
    size_t size() const noexcept { return N; }

    // Array index operator
    FieldModel<T> operator[](size_t index) const noexcept;

    // Check if the array is valid
    bool verify() const noexcept;

    // Get the array as C-array
    template <size_t S>
    void get(T (&values)[S]) const noexcept;
    // Get the array as std::array
    template <size_t S>
    void get(std::array<T, S>& values) const noexcept;
    // Get the array as std::vector
    void get(std::vector<T>& values) const noexcept;

    // Set the array as C-array
    template <size_t S>
    void set(const T (&values)[S]) noexcept;
    // Set the array as std::array
    template <size_t S>
    void set(const std::array<T, S>& values) noexcept;
    // Set the array as std::vector
    void set(const std::vector<T>& values) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;
    FieldModel<T> _model;
};

// Fast Binary Encoding field model vector
template <typename T>
class FieldModelVector
{
public:
    FieldModelVector(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept;

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the vector offset
    size_t offset() const noexcept;
    // Get the vector size
    size_t size() const noexcept;

    // Vector index operator
    FieldModel<T> operator[](size_t index) const noexcept;

    // Resize the vector and get its first model
    FieldModel<T> resize(size_t size);

    // Check if the vector is valid
    bool verify() const noexcept;

    // Get the vector as std::vector
    void get(std::vector<T>& values) const noexcept;
    // Get the vector as std::list
    void get(std::list<T>& values) const noexcept;
    // Get the vector as std::set
    void get(std::set<T>& values) const noexcept;

    // Set the vector as std::vector
    void set(const std::vector<T>& values) noexcept;
    // Set the vector as std::list
    void set(const std::list<T>& values) noexcept;
    // Set the vector as std::set
    void set(const std::set<T>& values) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model map
template <typename TKey, typename TValue>
class FieldModelMap
{
public:
    FieldModelMap(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept;

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the map offset
    size_t offset() const noexcept;
    // Get the map size
    size_t size() const noexcept;

    // Map index operator
    std::pair<FieldModel<TKey>, FieldModel<TValue>> operator[](size_t index) const noexcept;

    // Resize the map and get its first model
    std::pair<FieldModel<TKey>, FieldModel<TValue>> resize(size_t size);

    // Check if the map is valid
    bool verify() const noexcept;

    // Get the map as std::map
    void get(std::map<TKey, TValue>& values) const noexcept;
    // Get the map as std::unordered_map
    void get(std::unordered_map<TKey, TValue>& values) const noexcept;

    // Set the map as std::map
    void set(const std::map<TKey, TValue>& values) noexcept;
    // Set the map as std::unordered_map
    void set(const std::unordered_map<TKey, TValue>& values) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;
};

} // namespace FBE

#include "fbe_models.inl"

```

`proto/fbe_models.inl`:

```inl
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

namespace FBE {

template <typename T, typename TBase>
inline void FieldModelBase<T, TBase>::get(T& value, T defaults) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
    {
        value = defaults;
        return;
    }

    value = (T)(*((const TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())));
}

template <typename T, typename TBase>
inline void FieldModelBase<T, TBase>::set(T value) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    *((TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (TBase)value;
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::fbe_extra() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
    if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_optional_offset);
    size_t fbe_result = value.fbe_size() + value.fbe_extra();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

template <typename T>
inline bool FieldModel<std::optional<T>>::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

template <typename T>
inline bool FieldModel<std::optional<T>>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = value.verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
    assert((fbe_optional_offset > 0) && "Model is broken!");
    if (fbe_optional_offset == 0)
        return 0;

    _buffer.shift(fbe_optional_offset);
    return fbe_optional_offset;
}

template <typename T>
inline void FieldModel<std::optional<T>>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

template <typename T>
inline void FieldModel<std::optional<T>>::get(std::optional<T>& opt, const std::optional<T>& defaults) const noexcept
{
    opt = defaults;

    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    T temp = T();
    value.get(temp);
    opt.emplace(temp);

    get_end(fbe_begin);
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_optional_size = (uint32_t)value.fbe_size();
    uint32_t fbe_optional_offset = (uint32_t)(_buffer.allocate(fbe_optional_size) - _buffer.offset());
    assert(((fbe_optional_offset > 0) && ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1)) = fbe_optional_offset;

    _buffer.shift(fbe_optional_offset);
    return fbe_optional_offset;
}

template <typename T>
inline void FieldModel<std::optional<T>>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

template <typename T>
inline void FieldModel<std::optional<T>>::set(const std::optional<T>& opt)
{
    size_t fbe_begin = set_begin(opt.has_value());
    if (fbe_begin == 0)
        return;

    if (opt)
        value.set(opt.value());

    set_end(fbe_begin);
}

template <typename T, size_t N>
inline const uint8_t* FieldModelArray<T, N>::data() const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    return _buffer.data() + _buffer.offset() + fbe_offset();
}

template <typename T, size_t N>
inline uint8_t* FieldModelArray<T, N>::data() noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    return _buffer.data() + _buffer.offset() + fbe_offset();
}

template <typename T, size_t N>
inline FieldModel<T> FieldModelArray<T, N>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    assert((index < N) && "Index is out of bounds!");

    FieldModel<T> fbe_model(_buffer, fbe_offset());
    fbe_model.fbe_shift(index * fbe_model.fbe_size());
    return fbe_model;
}

template <typename T, size_t N>
inline bool FieldModelArray<T, N>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    FieldModel<T> fbe_model(_buffer, fbe_offset());
    for (size_t i = N; i-- > 0;)
    {
        if (!fbe_model.verify())
            return false;
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }

    return true;
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::get(T (&values)[S]) const noexcept
{
    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.get(values[i]);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::get(std::array<T, S>& values) const noexcept
{
    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.get(values[i]);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
inline void FieldModelArray<T, N>::get(std::vector<T>& values) const noexcept
{
    values.clear();
    values.reserve(N);

    auto fbe_model = (*this)[0];
    for (size_t i = N; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value);
        values.emplace_back(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::set(const T (&values)[S]) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.set(values[i]);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::set(const std::array<T, S>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.set(values[i]);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
inline void FieldModelArray<T, N>::set(const std::vector<T>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < values.size()) && (i < N); ++i)
    {
        fbe_model.set(values[i]);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline size_t FieldModelVector<T>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

    size_t fbe_result = 4;
    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        fbe_result += fbe_model.fbe_size() + fbe_model.fbe_extra();
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
    return fbe_result;
}

template <typename T>
inline size_t FieldModelVector<T>::offset() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return fbe_vector_offset;
}

template <typename T>
inline size_t FieldModelVector<T>::size() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
    return fbe_vector_size;
}

template <typename T>
inline FieldModel<T> FieldModelVector<T>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

    uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

    [[maybe_unused]] uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
    assert((index < fbe_vector_size) && "Index is out of bounds!");

    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    fbe_model.fbe_shift(index * fbe_model.fbe_size());
    return fbe_model;
}

template <typename T>
inline FieldModel<T> FieldModelVector<T>::resize(size_t size)
{
    FieldModel<T> fbe_model(_buffer, fbe_offset());

    uint32_t fbe_vector_size = (uint32_t)(size * fbe_model.fbe_size());
    uint32_t fbe_vector_offset = (uint32_t)(_buffer.allocate(4 + fbe_vector_size) - _buffer.offset());
    assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_vector_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset)) = (uint32_t)size;

    memset((char*)(_buffer.data() + _buffer.offset() + fbe_vector_offset + 4), 0, fbe_vector_size);

    return FieldModel<T>(_buffer, fbe_vector_offset + 4);
}

template <typename T>
inline bool FieldModelVector<T>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_vector_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        if (!fbe_model.verify())
            return false;
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }

    return true;
}

template <typename T>
inline void FieldModelVector<T>::get(std::vector<T>& values) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    values.reserve(fbe_vector_size);

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value);
        values.emplace_back(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::get(std::list<T>& values) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value);
        values.emplace_back(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::get(std::set<T>& values) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value);
        values.emplace(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const std::vector<T>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const std::list<T>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const std::set<T>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

    size_t fbe_result = 4;
    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        fbe_result += fbe_model_key.fbe_size() + fbe_model_key.fbe_extra();
        fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        fbe_result += fbe_model_value.fbe_size() + fbe_model_value.fbe_extra();
        fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
    }
    return fbe_result;
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::offset() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return fbe_map_offset;
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::size() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
    return fbe_map_size;
}

template <typename TKey, typename TValue>
inline std::pair<FieldModel<TKey>, FieldModel<TValue>> FieldModelMap<TKey, TValue>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

    uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4) <= _buffer.size())) && "Model is broken!");

    [[maybe_unused]] uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
    assert((index < fbe_map_size) && "Index is out of bounds!");

    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    fbe_model_key.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    fbe_model_value.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    return std::make_pair(fbe_model_key, fbe_model_value);
}

template <typename TKey, typename TValue>
inline std::pair<FieldModel<TKey>, FieldModel<TValue>> FieldModelMap<TKey, TValue>::resize(size_t size)
{
    FieldModel<TKey> fbe_model_key(_buffer, fbe_offset());
    FieldModel<TValue> fbe_model_value(_buffer, fbe_offset() + fbe_model_key.fbe_size());

    uint32_t fbe_map_size = (uint32_t)(size * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    uint32_t fbe_map_offset = (uint32_t)(_buffer.allocate(4 + fbe_map_size) - _buffer.offset());
    assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4 + fbe_map_size) <= _buffer.size())) && "Model is broken!");

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_map_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset)) = (uint32_t)size;

    memset((char*)(_buffer.data() + _buffer.offset() + fbe_map_offset + 4), 0, fbe_map_size);

    return std::make_pair(FieldModel<TKey>(_buffer, fbe_map_offset + 4), FieldModel<TValue>(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size()));
}

template <typename TKey, typename TValue>
inline bool FieldModelMap<TKey, TValue>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_map_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        if (!fbe_model_key.verify())
            return false;
        fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        if (!fbe_model_value.verify())
            return false;
        fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
    }

    return true;
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(std::map<TKey, TValue>& values) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        TKey key = TKey();
        TValue value = TValue();
        fbe_model.first.get(key);
        fbe_model.second.get(value);
        values.emplace(key, value);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(std::unordered_map<TKey, TValue>& values) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        TKey key = TKey();
        TValue value = TValue();
        fbe_model.first.get(key);
        fbe_model.second.get(value);
        values.emplace(key, value);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const std::map<TKey, TValue>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const std::unordered_map<TKey, TValue>& values) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

} // namespace FBE

```

`proto/fbe_protocol.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "fbe_protocol.h"

namespace FBE {

size_t Sender::send_serialized(size_t serialized)
{
    assert((serialized > 0) && "Invalid size of the serialized buffer!");
    if (serialized == 0)
        return 0;

    // Shift the send buffer
    this->_buffer->shift(serialized);

    // Send the value
    size_t sent = onSend(this->_buffer->data(), this->_buffer->size());
    this->_buffer->remove(0, sent);
    return sent;
}

void Receiver::receive(const void* data, size_t size)
{
    if (size == 0)
        return;

    assert((data != nullptr) && "Invalid buffer!");
    if (data == nullptr)
        return;

    // Storage buffer
    uint8_t* buffer1 = _buffer->data();
    size_t offset0 = _buffer->offset();
    size_t offset1 = _buffer->size();
    size_t size1 = _buffer->size();

    // Receive buffer
    const uint8_t* buffer2 = (const uint8_t*)data;
    size_t offset2 = 0;
    size_t size2 = size;

    // While receive buffer is available to handle...
    while (offset2 < size2)
    {
        const uint8_t* message_buffer = nullptr;
        size_t message_size = 0;

        // Try to receive message size
        bool message_size_copied = false;
        bool message_size_found = false;
        while (!message_size_found)
        {
            // Look into the storage buffer
            if (offset0 < size1)
            {
                size_t count = std::min(size1 - offset0, (size_t)4);
                if (count == 4)
                {
                    message_size_copied = true;
                    message_size_found = true;
                    message_size = (size_t)(*((const uint32_t*)(buffer1 + offset0)));
                    offset0 += 4;
                    break;
                }
                else
                {
                    // Fill remaining data from the receive buffer
                    if (offset2 < size2)
                    {
                        count = std::min(size2 - offset2, 4 - count);

                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                    else
                        break;
                }
            }

            // Look into the receive buffer
            if (offset2 < size2)
            {
                size_t count = std::min(size2 - offset2, (size_t)4);
                if (count == 4)
                {
                    message_size_found = true;
                    message_size = (size_t)(*((const uint32_t*)(buffer2 + offset2)));
                    offset2 += 4;
                    break;
                }
                else
                {
                    // Allocate and refresh the storage buffer
                    _buffer->allocate(count);
                    buffer1 = _buffer->data();
                    size1 += count;

                    memcpy(buffer1 + offset1, buffer2 + offset2, count);
                    offset1 += count;
                    offset2 += count;
                    continue;
                }
            }
            else
                break;
        }

        if (!message_size_found)
            return;

        // Check the message full size
        size_t min_size = _final ? (4 + 4) : (4 + 4 + 4 + 4);
        assert((message_size >= min_size) && "Invalid receive data!");
        if (message_size < min_size)
            return;

        // Try to receive message body
        bool message_found = false;
        while (!message_found)
        {
            // Look into the storage buffer
            if (offset0 < size1)
            {
                size_t count = std::min(size1 - offset0, message_size - 4);
                if (count == (message_size - 4))
                {
                    message_found = true;
                    message_buffer = buffer1 + offset0 - 4;
                    offset0 += message_size - 4;
                    break;
                }
                else
                {
                    // Fill remaining data from the receive buffer
                    if (offset2 < size2)
                    {
                        // Copy message size into the storage buffer
                        if (!message_size_copied)
                        {
                            // Allocate and refresh the storage buffer
                            _buffer->allocate(4);
                            buffer1 = _buffer->data();
                            size1 += 4;

                            *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                            offset0 += 4;
                            offset1 += 4;

                            message_size_copied = true;
                        }

                        count = std::min(size2 - offset2, message_size - 4 - count);

                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                    else
                        break;
                }
            }

            // Look into the receive buffer
            if (offset2 < size2)
            {
                size_t count = std::min(size2 - offset2, message_size - 4);
                if (!message_size_copied && (count == (message_size - 4)))
                {
                    message_found = true;
                    message_buffer = buffer2 + offset2 - 4;
                    offset2 += message_size - 4;
                    break;
                }
                else
                {
                    // Copy message size into the storage buffer
                    if (!message_size_copied)
                    {
                        // Allocate and refresh the storage buffer
                        _buffer->allocate(4);
                        buffer1 = _buffer->data();
                        size1 += 4;

                        *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                        offset0 += 4;
                        offset1 += 4;

                        message_size_copied = true;
                    }

                    // Allocate and refresh the storage buffer
                    _buffer->allocate(count);
                    buffer1 = _buffer->data();
                    size1 += count;

                    memcpy(buffer1 + offset1, buffer2 + offset2, count);
                    offset1 += count;
                    offset2 += count;
                    continue;
                }
            }
            else
                break;
        }

        if (!message_found)
        {
            // Copy message size into the storage buffer
            if (!message_size_copied)
            {
                // Allocate and refresh the storage buffer
                _buffer->allocate(4);
                buffer1 = _buffer->data();
                size1 += 4;

                *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                offset0 += 4;
                offset1 += 4;

                message_size_copied = true;
            }
            return;
        }

        [[maybe_unused]] uint32_t fbe_struct_size;
        uint32_t fbe_struct_type;

        // Read the message parameters
        if (_final)
        {
            fbe_struct_size = *((const uint32_t*)(message_buffer));
            fbe_struct_type = *((const uint32_t*)(message_buffer + 4));
        }
        else
        {
            uint32_t fbe_struct_offset = *((const uint32_t*)(message_buffer + 4));
            fbe_struct_size = *((const uint32_t*)(message_buffer + fbe_struct_offset));
            fbe_struct_type = *((const uint32_t*)(message_buffer + fbe_struct_offset + 4));
        }

        // Handle the message
        onReceive(fbe_struct_type, message_buffer, message_size);

        // Reset the storage buffer
        _buffer->reset();

        // Refresh the storage buffer
        buffer1 = _buffer->data();
        offset0 = _buffer->offset();
        offset1 = _buffer->size();
        size1 = _buffer->size();
    }
}

} // namespace FBE

```

`proto/fbe_protocol.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace FBE {

// Fast Binary Encoding base sender
class Sender
{
public:
    Sender(const Sender&) = delete;
    Sender(Sender&&) noexcept = delete;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = delete;
    Sender& operator=(Sender&&) noexcept = delete;

    // Get the sender buffer
    FBEBuffer& buffer() noexcept { return *_buffer; }
    const FBEBuffer& buffer() const noexcept { return *_buffer; }

    // Get the final protocol flag
    bool final() const noexcept { return _final; }

    // Get the logging flag
    bool logging() const noexcept { return _logging; }
    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Reset the sender buffer
    void reset() noexcept { _buffer->reset(); }

    // Send serialized buffer.
    // Direct call of the method requires knowledge about internals of FBE models serialization.
    // Use it with care!
    size_t send_serialized(size_t serialized);

protected:
    // Send message handler
    virtual size_t onSend(const void* data, size_t size) = 0;
    // Send log message handler
    virtual void onSendLog(const std::string& message) const {}

protected:
    std::shared_ptr<FBEBuffer> _buffer;
    bool _logging;
    bool _final;

    Sender() : Sender(nullptr) {}
    Sender(const std::shared_ptr<FBEBuffer>& buffer) : _logging(false), _final(false) { _buffer = buffer ? buffer : std::make_shared<FBEBuffer>(); }

    // Enable/Disable final protocol
    void final(bool enable) noexcept { _final = enable; }
};

// Fast Binary Encoding base receiver
class Receiver
{
public:
    Receiver(const Receiver&) = delete;
    Receiver(Receiver&&) = delete;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = delete;
    Receiver& operator=(Receiver&&) = delete;

    // Get the receiver buffer
    FBEBuffer& buffer() noexcept { return *_buffer; }
    const FBEBuffer& buffer() const noexcept { return *_buffer; }

    // Get the final protocol flag
    bool final() const noexcept { return _final; }

    // Get the logging flag
    bool logging() const noexcept { return _logging; }
    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Reset the receiver buffer
    void reset() noexcept { _buffer->reset(); }

    // Receive data
    void receive(const void* data, size_t size);

protected:
    // Receive message handler
    virtual bool onReceive(size_t type, const void* data, size_t size) = 0;
    // Receive log message handler
    virtual void onReceiveLog(const std::string& message) const {}

protected:
    std::shared_ptr<FBEBuffer> _buffer;
    bool _logging;
    bool _final;

    Receiver() : Receiver(nullptr) {}
    Receiver(const std::shared_ptr<FBEBuffer>& buffer) : _logging(false), _final(false) { _buffer = buffer ? buffer : std::make_shared<FBEBuffer>(); }

    // Enable/Disable final protocol
    void final(bool enable) noexcept { _final = enable; }
};

} // namespace FBE

```

`proto/simple.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "simple.h"

namespace simple {

SimpleRequest::SimpleRequest()
    : id(FBE::uuid_t::sequential())
    , Message()
{}

SimpleRequest::SimpleRequest(const FBE::uuid_t& arg_id, const std::string& arg_Message)
    : id(arg_id)
    , Message(arg_Message)
{}

bool SimpleRequest::operator==(const SimpleRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleRequest::operator<(const SimpleRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleRequest::swap(SimpleRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Message, other.Message);
}

std::ostream& operator<<(std::ostream& stream, const SimpleRequest& value)
{
    stream << "SimpleRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Message="; stream << "\"" << value.Message << "\"";
    stream << ")";
    return stream;
}

SimpleResponse::SimpleResponse()
    : id(FBE::uuid_t::sequential())
    , Length((uint32_t)0ull)
    , Hash((uint32_t)0ull)
{}

SimpleResponse::SimpleResponse(const FBE::uuid_t& arg_id, uint32_t arg_Length, uint32_t arg_Hash)
    : id(arg_id)
    , Length(arg_Length)
    , Hash(arg_Hash)
{}

bool SimpleResponse::operator==(const SimpleResponse& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleResponse::operator<(const SimpleResponse& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleResponse::swap(SimpleResponse& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Length, other.Length);
    swap(Hash, other.Hash);
}

std::ostream& operator<<(std::ostream& stream, const SimpleResponse& value)
{
    stream << "SimpleResponse(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Length="; stream << value.Length;
    stream << ",Hash="; stream << value.Hash;
    stream << ")";
    return stream;
}

SimpleReject::SimpleReject()
    : id(FBE::uuid_t::sequential())
    , Error()
{}

SimpleReject::SimpleReject(const FBE::uuid_t& arg_id, const std::string& arg_Error)
    : id(arg_id)
    , Error(arg_Error)
{}

bool SimpleReject::operator==(const SimpleReject& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleReject::operator<(const SimpleReject& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleReject::swap(SimpleReject& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Error, other.Error);
}

std::ostream& operator<<(std::ostream& stream, const SimpleReject& value)
{
    stream << "SimpleReject(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Error="; stream << "\"" << value.Error << "\"";
    stream << ")";
    return stream;
}

SimpleNotify::SimpleNotify()
    : Notification()
{}

SimpleNotify::SimpleNotify(const std::string& arg_Notification)
    : Notification(arg_Notification)
{}

bool SimpleNotify::operator==(const SimpleNotify& other) const noexcept
{
    return (
        true
        );
}

bool SimpleNotify::operator<(const SimpleNotify& other) const noexcept
{
    return false;
}

void SimpleNotify::swap(SimpleNotify& other) noexcept
{
    using std::swap;
    swap(Notification, other.Notification);
}

std::ostream& operator<<(std::ostream& stream, const SimpleNotify& value)
{
    stream << "SimpleNotify(";
    stream << "Notification="; stream << "\"" << value.Notification << "\"";
    stream << ")";
    return stream;
}

DisconnectRequest::DisconnectRequest()
    : id(FBE::uuid_t::sequential())
{}

DisconnectRequest::DisconnectRequest(const FBE::uuid_t& arg_id)
    : id(arg_id)
{}

bool DisconnectRequest::operator==(const DisconnectRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool DisconnectRequest::operator<(const DisconnectRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void DisconnectRequest::swap(DisconnectRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
}

std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value)
{
    stream << "DisconnectRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ")";
    return stream;
}

} // namespace simple

```

`proto/simple.fbe`:

```fbe
/*
   Simple Fast Binary Encoding protocol for CppServer
   https://github.com/chronoxor/FastBinaryEncoding

   Generate protocol command: fbec --cpp --proto --input=simple.fbe --output=.
*/

// Domain declaration
domain com.chronoxor

// Package declaration
package simple

// Protocol version
version 1.0

// Simple request message
[request]
[response(SimpleResponse)]
[reject(SimpleReject)]
message SimpleRequest
{
    // Request Id
    uuid [id] = uuid1;
    // Request message
    string Message;
}

// Simple response
message SimpleResponse
{
    // Response Id
    uuid [id] = uuid1;
    // Calculated message length
    uint32 Length;
    // Calculated message hash
    uint32 Hash;
}

// Simple reject
message SimpleReject
{
    // Reject Id
    uuid [id] = uuid1;
    // Error message
    string Error;
}

// Simple notification
message SimpleNotify
{
    // Server notification
    string Notification;
}

// Disconnect request message
[request]
message DisconnectRequest
{
    // Request Id
    uuid [id] = uuid1;
}

```

`proto/simple.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace simple {
using namespace FBE;
} // namespace simple

namespace FBE {
using namespace ::simple;
} // namespace FBE

namespace simple {

struct SimpleResponse;

struct SimpleRequest
{
    typedef SimpleResponse Response;

    FBE::uuid_t id;
    std::string Message;

    size_t fbe_type() const noexcept { return 1; }

    SimpleRequest();
    SimpleRequest(const FBE::uuid_t& arg_id, const std::string& arg_Message);
    SimpleRequest(const SimpleRequest& other) = default;
    SimpleRequest(SimpleRequest&& other) = default;
    ~SimpleRequest() = default;

    SimpleRequest& operator=(const SimpleRequest& other) = default;
    SimpleRequest& operator=(SimpleRequest&& other) = default;

    bool operator==(const SimpleRequest& other) const noexcept;
    bool operator!=(const SimpleRequest& other) const noexcept { return !operator==(other); }
    bool operator<(const SimpleRequest& other) const noexcept;
    bool operator<=(const SimpleRequest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SimpleRequest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SimpleRequest& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const SimpleRequest& value);

    void swap(SimpleRequest& other) noexcept;
    friend void swap(SimpleRequest& value1, SimpleRequest& value2) noexcept { value1.swap(value2); }
};

} // namespace simple

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<simple::SimpleRequest> : ostream_formatter {};
#endif

template<>
struct std::hash<simple::SimpleRequest>
{
    typedef simple::SimpleRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace simple {

struct SimpleResponse
{
    FBE::uuid_t id;
    uint32_t Length;
    uint32_t Hash;

    size_t fbe_type() const noexcept { return 2; }

    SimpleResponse();
    SimpleResponse(const FBE::uuid_t& arg_id, uint32_t arg_Length, uint32_t arg_Hash);
    SimpleResponse(const SimpleResponse& other) = default;
    SimpleResponse(SimpleResponse&& other) = default;
    ~SimpleResponse() = default;

    SimpleResponse& operator=(const SimpleResponse& other) = default;
    SimpleResponse& operator=(SimpleResponse&& other) = default;

    bool operator==(const SimpleResponse& other) const noexcept;
    bool operator!=(const SimpleResponse& other) const noexcept { return !operator==(other); }
    bool operator<(const SimpleResponse& other) const noexcept;
    bool operator<=(const SimpleResponse& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SimpleResponse& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SimpleResponse& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const SimpleResponse& value);

    void swap(SimpleResponse& other) noexcept;
    friend void swap(SimpleResponse& value1, SimpleResponse& value2) noexcept { value1.swap(value2); }
};

} // namespace simple

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<simple::SimpleResponse> : ostream_formatter {};
#endif

template<>
struct std::hash<simple::SimpleResponse>
{
    typedef simple::SimpleResponse argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace simple {

struct SimpleReject
{
    FBE::uuid_t id;
    std::string Error;

    size_t fbe_type() const noexcept { return 3; }

    SimpleReject();
    SimpleReject(const FBE::uuid_t& arg_id, const std::string& arg_Error);
    SimpleReject(const SimpleReject& other) = default;
    SimpleReject(SimpleReject&& other) = default;
    ~SimpleReject() = default;

    SimpleReject& operator=(const SimpleReject& other) = default;
    SimpleReject& operator=(SimpleReject&& other) = default;

    bool operator==(const SimpleReject& other) const noexcept;
    bool operator!=(const SimpleReject& other) const noexcept { return !operator==(other); }
    bool operator<(const SimpleReject& other) const noexcept;
    bool operator<=(const SimpleReject& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SimpleReject& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SimpleReject& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const SimpleReject& value);

    void swap(SimpleReject& other) noexcept;
    friend void swap(SimpleReject& value1, SimpleReject& value2) noexcept { value1.swap(value2); }
};

} // namespace simple

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<simple::SimpleReject> : ostream_formatter {};
#endif

template<>
struct std::hash<simple::SimpleReject>
{
    typedef simple::SimpleReject argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace simple {

struct SimpleNotify
{
    std::string Notification;

    size_t fbe_type() const noexcept { return 4; }

    SimpleNotify();
    explicit SimpleNotify(const std::string& arg_Notification);
    SimpleNotify(const SimpleNotify& other) = default;
    SimpleNotify(SimpleNotify&& other) = default;
    ~SimpleNotify() = default;

    SimpleNotify& operator=(const SimpleNotify& other) = default;
    SimpleNotify& operator=(SimpleNotify&& other) = default;

    bool operator==(const SimpleNotify& other) const noexcept;
    bool operator!=(const SimpleNotify& other) const noexcept { return !operator==(other); }
    bool operator<(const SimpleNotify& other) const noexcept;
    bool operator<=(const SimpleNotify& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const SimpleNotify& other) const noexcept { return !operator<=(other); }
    bool operator>=(const SimpleNotify& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const SimpleNotify& value);

    void swap(SimpleNotify& other) noexcept;
    friend void swap(SimpleNotify& value1, SimpleNotify& value2) noexcept { value1.swap(value2); }
};

} // namespace simple

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<simple::SimpleNotify> : ostream_formatter {};
#endif

template<>
struct std::hash<simple::SimpleNotify>
{
    typedef simple::SimpleNotify argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace simple {

struct DisconnectRequest
{
    FBE::uuid_t id;

    size_t fbe_type() const noexcept { return 5; }

    DisconnectRequest();
    explicit DisconnectRequest(const FBE::uuid_t& arg_id);
    DisconnectRequest(const DisconnectRequest& other) = default;
    DisconnectRequest(DisconnectRequest&& other) = default;
    ~DisconnectRequest() = default;

    DisconnectRequest& operator=(const DisconnectRequest& other) = default;
    DisconnectRequest& operator=(DisconnectRequest&& other) = default;

    bool operator==(const DisconnectRequest& other) const noexcept;
    bool operator!=(const DisconnectRequest& other) const noexcept { return !operator==(other); }
    bool operator<(const DisconnectRequest& other) const noexcept;
    bool operator<=(const DisconnectRequest& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const DisconnectRequest& other) const noexcept { return !operator<=(other); }
    bool operator>=(const DisconnectRequest& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value);

    void swap(DisconnectRequest& other) noexcept;
    friend void swap(DisconnectRequest& value1, DisconnectRequest& value2) noexcept { value1.swap(value2); }
};

} // namespace simple

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<simple::DisconnectRequest> : ostream_formatter {};
#endif

template<>
struct std::hash<simple::DisconnectRequest>
{
    typedef simple::DisconnectRequest argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

namespace simple {

} // namespace simple

```

`proto/simple_models.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "simple_models.h"

namespace FBE {

FieldModel<::simple::SimpleRequest>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 4 + 4)
    , Message(buffer, id.fbe_offset() + id.fbe_size())
{}

size_t FieldModel<::simple::SimpleRequest>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + id.fbe_size()
        + Message.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::simple::SimpleRequest>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + id.fbe_extra()
        + Message.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::simple::SimpleRequest>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::simple::SimpleRequest>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
        return true;
    if (!id.verify())
        return false;
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Message.fbe_size()) > fbe_struct_size)
        return true;
    if (!Message.verify())
        return false;
    fbe_current_size += Message.fbe_size();

    return true;
}

size_t FieldModel<::simple::SimpleRequest>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleRequest>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleRequest>::get(::simple::SimpleRequest& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::simple::SimpleRequest>::get_fields(::simple::SimpleRequest& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
        id.get(fbe_value.id, FBE::uuid_t::sequential());
    else
        fbe_value.id = FBE::uuid_t::sequential();
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Message.fbe_size()) <= fbe_struct_size)
        Message.get(fbe_value.Message);
    else
        fbe_value.Message = "";
    fbe_current_size += Message.fbe_size();
}

size_t FieldModel<::simple::SimpleRequest>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleRequest>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleRequest>::set(const ::simple::SimpleRequest& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::simple::SimpleRequest>::set_fields(const ::simple::SimpleRequest& fbe_value) noexcept
{
    id.set(fbe_value.id);
    Message.set(fbe_value.Message);
}

namespace simple {

bool SimpleRequestModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SimpleRequestModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SimpleRequestModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SimpleRequestModel::serialize(const ::simple::SimpleRequest& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SimpleRequestModel::deserialize(::simple::SimpleRequest& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace simple

FieldModel<::simple::SimpleResponse>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 4 + 4)
    , Length(buffer, id.fbe_offset() + id.fbe_size())
    , Hash(buffer, Length.fbe_offset() + Length.fbe_size())
{}

size_t FieldModel<::simple::SimpleResponse>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + id.fbe_size()
        + Length.fbe_size()
        + Hash.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::simple::SimpleResponse>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + id.fbe_extra()
        + Length.fbe_extra()
        + Hash.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::simple::SimpleResponse>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::simple::SimpleResponse>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
        return true;
    if (!id.verify())
        return false;
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Length.fbe_size()) > fbe_struct_size)
        return true;
    if (!Length.verify())
        return false;
    fbe_current_size += Length.fbe_size();

    if ((fbe_current_size + Hash.fbe_size()) > fbe_struct_size)
        return true;
    if (!Hash.verify())
        return false;
    fbe_current_size += Hash.fbe_size();

    return true;
}

size_t FieldModel<::simple::SimpleResponse>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleResponse>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleResponse>::get(::simple::SimpleResponse& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::simple::SimpleResponse>::get_fields(::simple::SimpleResponse& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
        id.get(fbe_value.id, FBE::uuid_t::sequential());
    else
        fbe_value.id = FBE::uuid_t::sequential();
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Length.fbe_size()) <= fbe_struct_size)
        Length.get(fbe_value.Length);
    else
        fbe_value.Length = (uint32_t)0ull;
    fbe_current_size += Length.fbe_size();

    if ((fbe_current_size + Hash.fbe_size()) <= fbe_struct_size)
        Hash.get(fbe_value.Hash);
    else
        fbe_value.Hash = (uint32_t)0ull;
    fbe_current_size += Hash.fbe_size();
}

size_t FieldModel<::simple::SimpleResponse>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleResponse>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleResponse>::set(const ::simple::SimpleResponse& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::simple::SimpleResponse>::set_fields(const ::simple::SimpleResponse& fbe_value) noexcept
{
    id.set(fbe_value.id);
    Length.set(fbe_value.Length);
    Hash.set(fbe_value.Hash);
}

namespace simple {

bool SimpleResponseModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SimpleResponseModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SimpleResponseModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SimpleResponseModel::serialize(const ::simple::SimpleResponse& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SimpleResponseModel::deserialize(::simple::SimpleResponse& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace simple

FieldModel<::simple::SimpleReject>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 4 + 4)
    , Error(buffer, id.fbe_offset() + id.fbe_size())
{}

size_t FieldModel<::simple::SimpleReject>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + id.fbe_size()
        + Error.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::simple::SimpleReject>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + id.fbe_extra()
        + Error.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::simple::SimpleReject>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::simple::SimpleReject>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
        return true;
    if (!id.verify())
        return false;
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Error.fbe_size()) > fbe_struct_size)
        return true;
    if (!Error.verify())
        return false;
    fbe_current_size += Error.fbe_size();

    return true;
}

size_t FieldModel<::simple::SimpleReject>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleReject>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleReject>::get(::simple::SimpleReject& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::simple::SimpleReject>::get_fields(::simple::SimpleReject& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
        id.get(fbe_value.id, FBE::uuid_t::sequential());
    else
        fbe_value.id = FBE::uuid_t::sequential();
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + Error.fbe_size()) <= fbe_struct_size)
        Error.get(fbe_value.Error);
    else
        fbe_value.Error = "";
    fbe_current_size += Error.fbe_size();
}

size_t FieldModel<::simple::SimpleReject>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleReject>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleReject>::set(const ::simple::SimpleReject& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::simple::SimpleReject>::set_fields(const ::simple::SimpleReject& fbe_value) noexcept
{
    id.set(fbe_value.id);
    Error.set(fbe_value.Error);
}

namespace simple {

bool SimpleRejectModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SimpleRejectModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SimpleRejectModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SimpleRejectModel::serialize(const ::simple::SimpleReject& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SimpleRejectModel::deserialize(::simple::SimpleReject& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace simple

FieldModel<::simple::SimpleNotify>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , Notification(buffer, 4 + 4)
{}

size_t FieldModel<::simple::SimpleNotify>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + Notification.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::simple::SimpleNotify>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + Notification.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::simple::SimpleNotify>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::simple::SimpleNotify>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + Notification.fbe_size()) > fbe_struct_size)
        return true;
    if (!Notification.verify())
        return false;
    fbe_current_size += Notification.fbe_size();

    return true;
}

size_t FieldModel<::simple::SimpleNotify>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleNotify>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleNotify>::get(::simple::SimpleNotify& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::simple::SimpleNotify>::get_fields(::simple::SimpleNotify& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + Notification.fbe_size()) <= fbe_struct_size)
        Notification.get(fbe_value.Notification);
    else
        fbe_value.Notification = "";
    fbe_current_size += Notification.fbe_size();
}

size_t FieldModel<::simple::SimpleNotify>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::SimpleNotify>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::SimpleNotify>::set(const ::simple::SimpleNotify& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::simple::SimpleNotify>::set_fields(const ::simple::SimpleNotify& fbe_value) noexcept
{
    Notification.set(fbe_value.Notification);
}

namespace simple {

bool SimpleNotifyModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SimpleNotifyModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SimpleNotifyModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SimpleNotifyModel::serialize(const ::simple::SimpleNotify& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SimpleNotifyModel::deserialize(::simple::SimpleNotify& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace simple

FieldModel<::simple::DisconnectRequest>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 4 + 4)
{}

size_t FieldModel<::simple::DisconnectRequest>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + id.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::simple::DisconnectRequest>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + id.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::simple::DisconnectRequest>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::simple::DisconnectRequest>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
        return true;
    if (!id.verify())
        return false;
    fbe_current_size += id.fbe_size();

    return true;
}

size_t FieldModel<::simple::DisconnectRequest>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::DisconnectRequest>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::DisconnectRequest>::get(::simple::DisconnectRequest& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::simple::DisconnectRequest>::get_fields(::simple::DisconnectRequest& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
        id.get(fbe_value.id, FBE::uuid_t::sequential());
    else
        fbe_value.id = FBE::uuid_t::sequential();
    fbe_current_size += id.fbe_size();
}

size_t FieldModel<::simple::DisconnectRequest>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::simple::DisconnectRequest>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::simple::DisconnectRequest>::set(const ::simple::DisconnectRequest& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::simple::DisconnectRequest>::set_fields(const ::simple::DisconnectRequest& fbe_value) noexcept
{
    id.set(fbe_value.id);
}

namespace simple {

bool DisconnectRequestModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t DisconnectRequestModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t DisconnectRequestModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t DisconnectRequestModel::serialize(const ::simple::DisconnectRequest& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t DisconnectRequestModel::deserialize(::simple::DisconnectRequest& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace simple

} // namespace FBE

```

`proto/simple_models.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_models.h"

#include "simple.h"

namespace FBE {

// Fast Binary Encoding ::simple::SimpleRequest field model
template <>
class FieldModel<::simple::SimpleRequest>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::simple::SimpleRequest& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::simple::SimpleRequest& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::simple::SimpleRequest& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::simple::SimpleRequest& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<FBE::uuid_t> id;
    FieldModel<std::string> Message;
};

namespace simple {

// Fast Binary Encoding SimpleRequest model
class SimpleRequestModel : public FBE::Model
{
public:
    SimpleRequestModel() : model(this->buffer(), 4) {}
    SimpleRequestModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::simple::SimpleRequest>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::simple::SimpleRequest& value);
    // Deserialize the struct value
    size_t deserialize(::simple::SimpleRequest& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::simple::SimpleRequest> model;
};

} // namespace simple

// Fast Binary Encoding ::simple::SimpleResponse field model
template <>
class FieldModel<::simple::SimpleResponse>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::simple::SimpleResponse& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::simple::SimpleResponse& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::simple::SimpleResponse& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::simple::SimpleResponse& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<FBE::uuid_t> id;
    FieldModel<uint32_t> Length;
    FieldModel<uint32_t> Hash;
};

namespace simple {

// Fast Binary Encoding SimpleResponse model
class SimpleResponseModel : public FBE::Model
{
public:
    SimpleResponseModel() : model(this->buffer(), 4) {}
    SimpleResponseModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::simple::SimpleResponse>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::simple::SimpleResponse& value);
    // Deserialize the struct value
    size_t deserialize(::simple::SimpleResponse& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::simple::SimpleResponse> model;
};

} // namespace simple

// Fast Binary Encoding ::simple::SimpleReject field model
template <>
class FieldModel<::simple::SimpleReject>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::simple::SimpleReject& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::simple::SimpleReject& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::simple::SimpleReject& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::simple::SimpleReject& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<FBE::uuid_t> id;
    FieldModel<std::string> Error;
};

namespace simple {

// Fast Binary Encoding SimpleReject model
class SimpleRejectModel : public FBE::Model
{
public:
    SimpleRejectModel() : model(this->buffer(), 4) {}
    SimpleRejectModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::simple::SimpleReject>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::simple::SimpleReject& value);
    // Deserialize the struct value
    size_t deserialize(::simple::SimpleReject& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::simple::SimpleReject> model;
};

} // namespace simple

// Fast Binary Encoding ::simple::SimpleNotify field model
template <>
class FieldModel<::simple::SimpleNotify>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 4; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::simple::SimpleNotify& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::simple::SimpleNotify& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::simple::SimpleNotify& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::simple::SimpleNotify& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<std::string> Notification;
};

namespace simple {

// Fast Binary Encoding SimpleNotify model
class SimpleNotifyModel : public FBE::Model
{
public:
    SimpleNotifyModel() : model(this->buffer(), 4) {}
    SimpleNotifyModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::simple::SimpleNotify>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::simple::SimpleNotify& value);
    // Deserialize the struct value
    size_t deserialize(::simple::SimpleNotify& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::simple::SimpleNotify> model;
};

} // namespace simple

// Fast Binary Encoding ::simple::DisconnectRequest field model
template <>
class FieldModel<::simple::DisconnectRequest>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 5; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::simple::DisconnectRequest& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::simple::DisconnectRequest& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::simple::DisconnectRequest& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::simple::DisconnectRequest& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<FBE::uuid_t> id;
};

namespace simple {

// Fast Binary Encoding DisconnectRequest model
class DisconnectRequestModel : public FBE::Model
{
public:
    DisconnectRequestModel() : model(this->buffer(), 4) {}
    DisconnectRequestModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::simple::DisconnectRequest>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::simple::DisconnectRequest& value);
    // Deserialize the struct value
    size_t deserialize(::simple::DisconnectRequest& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::simple::DisconnectRequest> model;
};

} // namespace simple

} // namespace FBE

```

`proto/simple_protocol.cpp`:

```cpp
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4065) // C4065: switch statement contains 'default' but no 'case' labels
#endif

#include "simple_protocol.h"

namespace FBE {

namespace simple {

size_t Sender::send(const ::simple::SimpleRequest& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = SimpleRequestModel.serialize(value);
    assert((serialized > 0) && "simple::SimpleRequest serialization failed!");
    assert(SimpleRequestModel.verify() && "simple::SimpleRequest validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::simple::SimpleResponse& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = SimpleResponseModel.serialize(value);
    assert((serialized > 0) && "simple::SimpleResponse serialization failed!");
    assert(SimpleResponseModel.verify() && "simple::SimpleResponse validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::simple::SimpleReject& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = SimpleRejectModel.serialize(value);
    assert((serialized > 0) && "simple::SimpleReject serialization failed!");
    assert(SimpleRejectModel.verify() && "simple::SimpleReject validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::simple::SimpleNotify& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = SimpleNotifyModel.serialize(value);
    assert((serialized > 0) && "simple::SimpleNotify serialization failed!");
    assert(SimpleNotifyModel.verify() && "simple::SimpleNotify validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

size_t Sender::send(const ::simple::DisconnectRequest& value)
{
    // Serialize the value into the FBE stream
    size_t serialized = DisconnectRequestModel.serialize(value);
    assert((serialized > 0) && "simple::DisconnectRequest serialization failed!");
    assert(DisconnectRequestModel.verify() && "simple::DisconnectRequest validation failed!");

    // Log the value
    if (this->_logging)
    {
        std::string message = value.string();
        this->onSendLog(message);
    }

    // Send the serialized value
    return this->send_serialized(serialized);
}

bool Receiver::onReceive(size_t type, const void* data, size_t size)
{
    switch (type)
    {
        case FBE::simple::SimpleRequestModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            SimpleRequestModel.attach(data, size);
            assert(SimpleRequestModel.verify() && "simple::SimpleRequest validation failed!");
            [[maybe_unused]] size_t deserialized = SimpleRequestModel.deserialize(SimpleRequestValue);
            assert((deserialized > 0) && "simple::SimpleRequest deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = SimpleRequestValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(SimpleRequestValue);
            return true;
        }
        case FBE::simple::SimpleResponseModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            SimpleResponseModel.attach(data, size);
            assert(SimpleResponseModel.verify() && "simple::SimpleResponse validation failed!");
            [[maybe_unused]] size_t deserialized = SimpleResponseModel.deserialize(SimpleResponseValue);
            assert((deserialized > 0) && "simple::SimpleResponse deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = SimpleResponseValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(SimpleResponseValue);
            return true;
        }
        case FBE::simple::SimpleRejectModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            SimpleRejectModel.attach(data, size);
            assert(SimpleRejectModel.verify() && "simple::SimpleReject validation failed!");
            [[maybe_unused]] size_t deserialized = SimpleRejectModel.deserialize(SimpleRejectValue);
            assert((deserialized > 0) && "simple::SimpleReject deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = SimpleRejectValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(SimpleRejectValue);
            return true;
        }
        case FBE::simple::SimpleNotifyModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            SimpleNotifyModel.attach(data, size);
            assert(SimpleNotifyModel.verify() && "simple::SimpleNotify validation failed!");
            [[maybe_unused]] size_t deserialized = SimpleNotifyModel.deserialize(SimpleNotifyValue);
            assert((deserialized > 0) && "simple::SimpleNotify deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = SimpleNotifyValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(SimpleNotifyValue);
            return true;
        }
        case FBE::simple::DisconnectRequestModel::fbe_type():
        {
            // Deserialize the value from the FBE stream
            DisconnectRequestModel.attach(data, size);
            assert(DisconnectRequestModel.verify() && "simple::DisconnectRequest validation failed!");
            [[maybe_unused]] size_t deserialized = DisconnectRequestModel.deserialize(DisconnectRequestValue);
            assert((deserialized > 0) && "simple::DisconnectRequest deserialization failed!");

            // Log the value
            if (this->_logging)
            {
                std::string message = DisconnectRequestValue.string();
                this->onReceiveLog(message);
            }

            // Call receive handler with deserialized value
            onReceive(DisconnectRequestValue);
            return true;
        }
        default: break;
    }

    return false;
}

bool Proxy::onReceive(size_t type, const void* data, size_t size)
{
    switch (type)
    {
        case FBE::simple::SimpleRequestModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            SimpleRequestModel.attach(data, size);
            assert(SimpleRequestModel.verify() && "simple::SimpleRequest validation failed!");

            size_t fbe_begin = SimpleRequestModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(SimpleRequestModel, type, data, size);
            SimpleRequestModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::simple::SimpleResponseModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            SimpleResponseModel.attach(data, size);
            assert(SimpleResponseModel.verify() && "simple::SimpleResponse validation failed!");

            size_t fbe_begin = SimpleResponseModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(SimpleResponseModel, type, data, size);
            SimpleResponseModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::simple::SimpleRejectModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            SimpleRejectModel.attach(data, size);
            assert(SimpleRejectModel.verify() && "simple::SimpleReject validation failed!");

            size_t fbe_begin = SimpleRejectModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(SimpleRejectModel, type, data, size);
            SimpleRejectModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::simple::SimpleNotifyModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            SimpleNotifyModel.attach(data, size);
            assert(SimpleNotifyModel.verify() && "simple::SimpleNotify validation failed!");

            size_t fbe_begin = SimpleNotifyModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(SimpleNotifyModel, type, data, size);
            SimpleNotifyModel.model.get_end(fbe_begin);
            return true;
        }
        case FBE::simple::DisconnectRequestModel::fbe_type():
        {
            // Attach the FBE stream to the proxy model
            DisconnectRequestModel.attach(data, size);
            assert(DisconnectRequestModel.verify() && "simple::DisconnectRequest validation failed!");

            size_t fbe_begin = DisconnectRequestModel.model.get_begin();
            if (fbe_begin == 0)
                return false;
            // Call proxy handler
            onProxy(DisconnectRequestModel, type, data, size);
            DisconnectRequestModel.model.get_end(fbe_begin);
            return true;
        }
        default: break;
    }

    return false;
}

std::future<::simple::SimpleResponse> Client::request(const ::simple::SimpleRequest& value, uint64_t timeout)
{
    std::scoped_lock locker(this->_lock);

    std::promise<::simple::SimpleResponse> promise;
    std::future<::simple::SimpleResponse> future = promise.get_future();

    uint64_t current = utc();

    // Send the request message
    size_t serialized = Sender::send(value);
    if (serialized > 0)
    {
        // Calculate the unique timestamp
        this->_timestamp = (current <= this->_timestamp) ? this->_timestamp + 1 : current;

        // Register the request
        _requests_by_id_SimpleResponse.insert(std::make_pair(value.id, std::make_tuple(this->_timestamp, timeout * 1000000, std::move(promise))));
        if (timeout > 0)
            _requests_by_timestamp_SimpleResponse.insert(std::make_pair(this->_timestamp, value.id));
    }
    else
        promise.set_exception(std::make_exception_ptr(std::runtime_error("Send request failed!")));

    return future;
}

std::future<void> Client::request(const ::simple::DisconnectRequest& value, uint64_t timeout)
{
    std::promise<void> promise;
    std::future<void> future = promise.get_future();

    // Send the request message
    size_t serialized = Sender::send(value);
    if (serialized > 0)
        promise.set_value();
    else
        promise.set_exception(std::make_exception_ptr(std::runtime_error("Send request failed!")));

    return future;
}

bool Client::onReceiveResponse(const ::simple::SimpleResponse& response)
{
    std::scoped_lock locker(this->_lock);

    auto it_SimpleResponse = _requests_by_id_SimpleResponse.find(response.id);
    if (it_SimpleResponse != _requests_by_id_SimpleResponse.end())
    {
        auto timestamp = std::get<0>(it_SimpleResponse->second);
        [[maybe_unused]] auto timespan = std::get<1>(it_SimpleResponse->second);
        auto& promise = std::get<2>(it_SimpleResponse->second);
        promise.set_value(response);
        _requests_by_id_SimpleResponse.erase(response.id);
        _requests_by_timestamp_SimpleResponse.erase(timestamp);
        return true;
    }

    return false;
}

bool Client::onReceiveReject(const ::simple::SimpleReject& reject)
{
    std::scoped_lock locker(this->_lock);

    auto it_SimpleResponse = _requests_by_id_SimpleResponse.find(reject.id);
    if (it_SimpleResponse != _requests_by_id_SimpleResponse.end())
    {
        auto timestamp = std::get<0>(it_SimpleResponse->second);
        [[maybe_unused]] auto timespan = std::get<1>(it_SimpleResponse->second);
        auto& promise = std::get<2>(it_SimpleResponse->second);
        promise.set_exception(std::make_exception_ptr(std::runtime_error(reject.string())));
        _requests_by_id_SimpleResponse.erase(reject.id);
        _requests_by_timestamp_SimpleResponse.erase(timestamp);
        return true;
    }

    return false;
}

void Client::reset_requests()
{
    Sender::reset();
    Receiver::reset();

    for (auto& request : _requests_by_id_SimpleResponse)
        std::get<2>(request.second).set_exception(std::make_exception_ptr(std::runtime_error("Reset client!")));
    _requests_by_id_SimpleResponse.clear();
    _requests_by_timestamp_SimpleResponse.clear();
}

void Client::watchdog_requests(uint64_t utc)
{
    auto it_request_by_timestamp_SimpleResponse = _requests_by_timestamp_SimpleResponse.begin();
    while (it_request_by_timestamp_SimpleResponse != _requests_by_timestamp_SimpleResponse.end())
    {
        auto& it_request_by_id_SimpleResponse = _requests_by_id_SimpleResponse[it_request_by_timestamp_SimpleResponse->second];
        auto id = it_request_by_timestamp_SimpleResponse->second;
        auto timestamp = std::get<0>(it_request_by_id_SimpleResponse);
        auto timespan = std::get<1>(it_request_by_id_SimpleResponse);
        if ((timestamp + timespan) <= utc)
        {
            auto& promise = std::get<2>(it_request_by_id_SimpleResponse);
            promise.set_exception(std::make_exception_ptr(std::runtime_error("Timeout!")));
            _requests_by_id_SimpleResponse.erase(id);
            _requests_by_timestamp_SimpleResponse.erase(timestamp);
            it_request_by_timestamp_SimpleResponse = _requests_by_timestamp_SimpleResponse.begin();
            continue;
        }
        else
            break;
    }

}

} // namespace simple

} // namespace FBE

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

```

`proto/simple_protocol.h`:

```h
//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_protocol.h"

#include "simple_models.h"

namespace FBE {

namespace simple {

// Fast Binary Encoding simple protocol version
struct ProtocolVersion
{
    // Protocol major version
    static const int major = 1;
    // Protocol minor version
    static const int minor = 0;
};

// Fast Binary Encoding simple sender
class Sender : public virtual FBE::Sender
{
public:
    Sender()
        : SimpleRequestModel(this->_buffer)
        , SimpleResponseModel(this->_buffer)
        , SimpleRejectModel(this->_buffer)
        , SimpleNotifyModel(this->_buffer)
        , DisconnectRequestModel(this->_buffer)
    {}
    Sender(const Sender&) = delete;
    Sender(Sender&&) noexcept = delete;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = delete;
    Sender& operator=(Sender&&) noexcept = delete;

    size_t send(const ::simple::SimpleRequest& value);
    size_t send(const ::simple::SimpleResponse& value);
    size_t send(const ::simple::SimpleReject& value);
    size_t send(const ::simple::SimpleNotify& value);
    size_t send(const ::simple::DisconnectRequest& value);

public:
    // Sender models accessors
    FBE::simple::SimpleRequestModel SimpleRequestModel;
    FBE::simple::SimpleResponseModel SimpleResponseModel;
    FBE::simple::SimpleRejectModel SimpleRejectModel;
    FBE::simple::SimpleNotifyModel SimpleNotifyModel;
    FBE::simple::DisconnectRequestModel DisconnectRequestModel;
};

// Fast Binary Encoding simple receiver
class Receiver : public virtual FBE::Receiver
{
public:
    Receiver() {}
    Receiver(const Receiver&) = delete;
    Receiver(Receiver&&) = delete;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = delete;
    Receiver& operator=(Receiver&&) = delete;

protected:
    // Receive handlers
    virtual void onReceive(const ::simple::SimpleRequest& value) {}
    virtual void onReceive(const ::simple::SimpleResponse& value) {}
    virtual void onReceive(const ::simple::SimpleReject& value) {}
    virtual void onReceive(const ::simple::SimpleNotify& value) {}
    virtual void onReceive(const ::simple::DisconnectRequest& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override;

private:
    // Receiver values accessors
    ::simple::SimpleRequest SimpleRequestValue;
    ::simple::SimpleResponse SimpleResponseValue;
    ::simple::SimpleReject SimpleRejectValue;
    ::simple::SimpleNotify SimpleNotifyValue;
    ::simple::DisconnectRequest DisconnectRequestValue;

    // Receiver models accessors
    FBE::simple::SimpleRequestModel SimpleRequestModel;
    FBE::simple::SimpleResponseModel SimpleResponseModel;
    FBE::simple::SimpleRejectModel SimpleRejectModel;
    FBE::simple::SimpleNotifyModel SimpleNotifyModel;
    FBE::simple::DisconnectRequestModel DisconnectRequestModel;
};

// Fast Binary Encoding simple proxy
class Proxy : public virtual FBE::Receiver
{
public:
    Proxy() {}
    Proxy(const Proxy&) = delete;
    Proxy(Proxy&&) = delete;
    virtual ~Proxy() = default;

    Proxy& operator=(const Proxy&) = delete;
    Proxy& operator=(Proxy&&) = delete;

protected:
    // Proxy handlers
    virtual void onProxy(FBE::simple::SimpleRequestModel& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::simple::SimpleResponseModel& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::simple::SimpleRejectModel& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::simple::SimpleNotifyModel& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::simple::DisconnectRequestModel& model, size_t type, const void* data, size_t size) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override;

private:
    // Proxy models accessors
    FBE::simple::SimpleRequestModel SimpleRequestModel;
    FBE::simple::SimpleResponseModel SimpleResponseModel;
    FBE::simple::SimpleRejectModel SimpleRejectModel;
    FBE::simple::SimpleNotifyModel SimpleNotifyModel;
    FBE::simple::DisconnectRequestModel DisconnectRequestModel;
};

// Fast Binary Encoding simple client
class Client : public virtual Sender, protected virtual Receiver
{
public:
    Client() = default;
    Client(const Client&) = delete;
    Client(Client&&) = delete;
    virtual ~Client() = default;

    Client& operator=(const Client&) = delete;
    Client& operator=(Client&&) = delete;

    // Reset client buffers
    void reset() { std::scoped_lock locker(this->_lock); reset_requests(); }

    // Watchdog for timeouts
    void watchdog(uint64_t utc) { std::scoped_lock locker(this->_lock); watchdog_requests(utc); }

    std::future<::simple::SimpleResponse> request(const ::simple::SimpleRequest& value, uint64_t timeout = 0);
    std::future<void> request(const ::simple::DisconnectRequest& value, uint64_t timeout = 0);

protected:
    std::mutex _lock;
    uint64_t _timestamp{0};

    virtual bool onReceiveResponse(const ::simple::SimpleResponse& response);

    virtual bool onReceiveResponse(const ::simple::SimpleRequest& response) { return false; }
    virtual bool onReceiveResponse(const ::simple::SimpleReject& response) { return false; }
    virtual bool onReceiveResponse(const ::simple::SimpleNotify& response) { return false; }
    virtual bool onReceiveResponse(const ::simple::DisconnectRequest& response) { return false; }

    virtual bool onReceiveReject(const ::simple::SimpleReject& reject);

    virtual bool onReceiveReject(const ::simple::SimpleRequest& reject) { return false; }
    virtual bool onReceiveReject(const ::simple::SimpleResponse& reject) { return false; }
    virtual bool onReceiveReject(const ::simple::SimpleNotify& reject) { return false; }
    virtual bool onReceiveReject(const ::simple::DisconnectRequest& reject) { return false; }

    virtual void onReceiveNotify(const ::simple::SimpleRequest& notify) {}
    virtual void onReceiveNotify(const ::simple::SimpleResponse& notify) {}
    virtual void onReceiveNotify(const ::simple::SimpleReject& notify) {}
    virtual void onReceiveNotify(const ::simple::SimpleNotify& notify) {}
    virtual void onReceiveNotify(const ::simple::DisconnectRequest& notify) {}

    virtual void onReceive(const ::simple::SimpleRequest& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::simple::SimpleResponse& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::simple::SimpleReject& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::simple::SimpleNotify& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::simple::DisconnectRequest& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }

    // Reset client requests
    virtual void reset_requests();

    // Watchdog client requests for timeouts
    virtual void watchdog_requests(uint64_t utc);

private:
    std::unordered_map<FBE::uuid_t, std::tuple<uint64_t, uint64_t, std::promise<::simple::SimpleResponse>>> _requests_by_id_SimpleResponse;
    std::map<uint64_t, FBE::uuid_t> _requests_by_timestamp_SimpleResponse;
};

} // namespace simple

} // namespace FBE

```

`source/server/asio/service.cpp`:

```cpp
/*!
    \file service.cpp
    \brief Asio service implementation
    \author Ivan Shynkarenka
    \date 16.12.2016
    \copyright MIT License
*/

#include "server/asio/service.h"

#include "errors/fatal.h"

namespace CppServer {
namespace Asio {

Service::Service(int threads, bool pool)
    : _strand_required(false),
      _polling(false),
      _started(false),
      _round_robin_index(0)
{
    assert((threads >= 0) && "Working threads counter must not be negative!");

    if (threads == 0)
    {
        // Single Asio IO service without thread pool
        _services.emplace_back(std::make_shared<asio::io_service>());
    }
    else if (!pool)
    {
        // Io-service-per-thread design
        for (int thread = 0; thread < threads; ++thread)
        {
            _services.emplace_back(std::make_shared<asio::io_service>());
            _threads.emplace_back(std::thread());
        }
    }
    else
    {
        // Thread-pool design
        _services.emplace_back(std::make_shared<asio::io_service>());
        for (int thread = 0; thread < threads; ++thread)
            _threads.emplace_back(std::thread());
        _strand = std::make_shared<asio::io_service::strand>(*_services[0]);
        _strand_required = true;
    }
}

Service::Service(const std::shared_ptr<asio::io_service>& service, bool strands)
    : _strand_required(strands),
      _polling(false),
      _started(false),
      _round_robin_index(0)
{
    assert((service != nullptr) && "Asio IO service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio IO service is invalid!");

    _services.emplace_back(service);
    if (_strand_required)
        _strand = std::make_shared<asio::io_service::strand>(*_services[0]);
}

bool Service::Start(bool polling)
{
    assert(!IsStarted() && "Asio service is already started!");
    if (IsStarted())
        return false;

    // Update polling loop mode flag
    _polling = polling;

    // Reset round robin index
    _round_robin_index = 0;

    // Post the started handler
    auto self(this->shared_from_this());
    auto start_handler = [this, self]()
    {
        if (IsStarted())
            return;

         // Update the started flag
        _started = true;

        // Call the service started handler
        onStarted();
    };
    if (_strand_required)
        _strand->post(start_handler);
    else
        _services[0]->post(start_handler);

    // Start service working threads
    for (size_t thread = 0; thread < _threads.size(); ++thread)
        _threads[thread] = CppCommon::Thread::Start([this, self, thread]() { ServiceThread(self, _services[thread % _services.size()]); });

    // Wait for service is started
    while (!IsStarted())
        CppCommon::Thread::Yield();

    return true;
}

bool Service::Stop()
{
    assert(IsStarted() && "Asio service is not started!");
    if (!IsStarted())
        return false;

    // Post the stop routine
    auto self(this->shared_from_this());
    auto stop_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        // Stop Asio services
        for (auto& service : _services)
            service->stop();

        // Update the started flag
        _started = false;

        // Call the service stopped handler
        onStopped();
    };
    if (_strand_required)
        _strand->post(stop_handler);
    else
        _services[0]->post(stop_handler);

    // Wait for all service working threads
    for (auto& thread : _threads)
        thread.join();

    // Update polling loop mode flag
    _polling = false;

    // Wait for service is stopped
    while (IsStarted())
        CppCommon::Thread::Yield();

    return true;
}

bool Service::Restart()
{
    bool polling = IsPolling();

    if (!Stop())
        return false;

    // Reinitialize new Asio IO services
    for (size_t service = 0; service < _services.size(); ++service)
        _services[service] = std::make_shared<asio::io_service>();
    if (_strand_required)
        _strand = std::make_shared<asio::io_service::strand>(*_services[0]);

    return Start(polling);
}

void Service::ServiceThread(const std::shared_ptr<Service>& service, const std::shared_ptr<asio::io_service>& io_service)
{
    bool polling = service->IsPolling();

    // Call the initialize thread handler
    service->onThreadInitialize();

    try
    {
        // Attach the current working thread to the Asio service
        asio::io_service::work work(*io_service);

        // Service loop...
        do
        {
            // ...with handling some specific Asio errors
            try
            {
                if (polling)
                {
                    // Poll all pending handlers
                    io_service->poll();

                    // Call the idle handler
                    service->onIdle();
                }
                else
                {
                    // Run all pending handlers
                    io_service->run();
                    break;
                }
            }
            catch (const asio::system_error& ex)
            {
                std::error_code ec = ex.code();

                // Skip Asio disconnect errors
                if (ec == asio::error::not_connected)
                    continue;

                throw;
            }
        } while (service->IsStarted());
    }
    catch (const asio::system_error& ex)
    {
        service->SendError(ex.code());
    }
    catch (const std::exception& ex)
    {
        fatality(ex);
    }
    catch (...)
    {
        fatality("Asio service thread terminated!");
    }

    // Call the cleanup thread handler
    service->onThreadCleanup();

#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
    // Delete OpenSSL thread state
    OPENSSL_thread_stop();
#endif
}

void Service::SendError(std::error_code ec)
{
    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/ssl_client.cpp`:

```cpp
/*!
    \file ssl_client.cpp
    \brief SSL client implementation
    \author Ivan Shynkarenka
    \date 01.01.2017
    \copyright MIT License
*/

#include "server/asio/ssl_client.h"

namespace CppServer {
namespace Asio {

SSLClient::SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _context(context),
      _stream(*_io_service, *_context),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _handshaking(false),
      _handshaked(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");
}

SSLClient::SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, const std::string& scheme)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _scheme(scheme),
      _port(0),
      _context(context),
      _stream(*_io_service, *_context),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _handshaking(false),
      _handshaked(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");
}

SSLClient::SSLClient(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const asio::ip::tcp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _context(context),
      _endpoint(endpoint),
      _stream(*_io_service, *_context),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _handshaking(false),
      _handshaked(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");
}

SSLClient::~SSLClient()
{
}

size_t SSLClient::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _stream.next_layer().get_option(option);
    return option.value();
}

size_t SSLClient::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _stream.next_layer().get_option(option);
    return option.value();
}

void SSLClient::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    socket().set_option(option);
}

void SSLClient::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    socket().set_option(option);
}

bool SSLClient::Connect()
{
    if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
        return false;

    // Create a new SSL stream
    _stream = asio::ssl::stream<asio::ip::tcp::socket>(*_io_service, *_context);

    asio::error_code ec;

    // Create the server endpoint
    _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(_address), (unsigned short)_port);

    // Connect to the server
    socket().connect(_endpoint, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    // Apply the option: keep alive
    if (option_keep_alive())
        socket().set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (option_no_delay())
        socket().set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    // SSL handshake
    _stream.handshake(asio::ssl::stream_base::client, ec);

    // Disconnect on error
    if (ec)
    {
        // Disconnect in case of the bad handshake
        SendError(ec);
        Disconnect();
        return false;
    }

    // Update the handshaked flag
    _handshaked = true;

    // Call the client handshaked handler
    onHandshaked();

    // Call the empty send buffer handler
    if (_send_buffer_main.empty())
        onEmpty();

    return true;
}

bool SSLClient::Connect(const std::shared_ptr<TCPResolver>& resolver)
{
    if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
        return false;

    // Create a new SSL stream
    _stream = asio::ssl::stream<asio::ip::tcp::socket>(*_io_service, *_context);

    asio::error_code ec;

    // Resolve the server endpoint
    asio::ip::tcp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
    auto endpoints = resolver->resolver().resolve(query, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    //  Connect to the server
    _endpoint = asio::connect(socket(), endpoints, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    // Apply the option: keep alive
    if (option_keep_alive())
        socket().set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (option_no_delay())
        socket().set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    // SSL handshake
    _stream.handshake(asio::ssl::stream_base::client, ec);

    // Disconnect on error
    if (ec)
    {
        // Disconnect in case of the bad handshake
        SendError(ec);
        Disconnect();
        return false;
    }

    // Update the handshaked flag
    _handshaked = true;

    // Call the client handshaked handler
    onHandshaked();

    // Call the empty send buffer handler
    if (_send_buffer_main.empty())
        onEmpty();

    return true;
}

bool SSLClient::DisconnectInternal()
{
    if (!IsConnected() || _resolving || _connecting || _handshaking)
        return false;

    auto self(this->shared_from_this());

    // Close the client socket
    socket().close();

    // Update the handshaked flag
    _handshaking = false;
    _handshaked = false;

    // Update the connected flag
    _resolving = false;
    _connecting = false;
    _connected = false;

    // Update sending/receiving flags
    _receiving = false;
    _sending = false;

    // Clear send/receive buffers
    ClearBuffers();

    // Call the client disconnected handler
    onDisconnected();

    return true;
}

bool SSLClient::Reconnect()
{
    if (!Disconnect())
        return false;

    return Connect();
}

bool SSLClient::ConnectAsync()
{
    if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = make_alloc_handler(_connect_storage, [this, self]()
    {
        if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
            return;

        _connecting = true;

        // Create a new SSL stream
        _stream = asio::ssl::stream<asio::ip::tcp::socket>(*_io_service, *_context);

        // Async connect with the connect handler
        auto async_connect_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec1)
        {
            _connecting = false;

            if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
                return;

            if (!ec1)
            {
                // Apply the option: keep alive
                if (option_keep_alive())
                    socket().set_option(asio::ip::tcp::socket::keep_alive(true));
                // Apply the option: no delay
                if (option_no_delay())
                    socket().set_option(asio::ip::tcp::no_delay(true));

                // Prepare receive & send buffers
                _receive_buffer.resize(option_receive_buffer_size());
                _send_buffer_main.reserve(option_send_buffer_size());
                _send_buffer_flush.reserve(option_send_buffer_size());

                // Reset statistic
                _bytes_pending = 0;
                _bytes_sending = 0;
                _bytes_sent = 0;
                _bytes_received = 0;

                // Update the connected flag
                _connected = true;

                // Call the client connected handler
                onConnected();

                // Async SSL handshake with the handshake handler
                _handshaking = true;
                auto async_handshake_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec2)
                {
                    _handshaking = false;

                    if (IsHandshaked())
                        return;

                    if (!ec2)
                    {
                        // Update the handshaked flag
                        _handshaked = true;

                        // Try to receive something from the server
                        TryReceive();

                        // Call the client handshaked handler
                        onHandshaked();

                        // Call the empty send buffer handler
                        if (_send_buffer_main.empty())
                            onEmpty();
                    }
                    else
                    {
                        // Disconnect in case of the bad handshake
                        SendError(ec2);
                        DisconnectInternalAsync(true);
                    }
                });
                if (_strand_required)
                    _stream.async_handshake(asio::ssl::stream_base::client, bind_executor(_strand, async_handshake_handler));
                else
                    _stream.async_handshake(asio::ssl::stream_base::client, async_handshake_handler);
            }
            else
            {
                SendError(ec1);

                // Call the client disconnected handler
                onDisconnected();
            }
        });

        // Create the server endpoint
        _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(_address), (unsigned short)_port);

        if (_strand_required)
            socket().async_connect(_endpoint, bind_executor(_strand, async_connect_handler));
        else
            socket().async_connect(_endpoint, async_connect_handler);
    });
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool SSLClient::ConnectAsync(const std::shared_ptr<TCPResolver>& resolver)
{
    if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = make_alloc_handler(_connect_storage, [this, self, resolver]()
    {
        if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
            return;

        _resolving = true;

        // Create a new SSL stream
        _stream = asio::ssl::stream<asio::ip::tcp::socket>(*_io_service, *_context);

        // Async resolve with the resolve handler
        auto async_resolve_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec1, asio::ip::tcp::resolver::results_type endpoints)
        {
            _resolving = false;

            if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
                return;

            if (!ec1)
            {
                // Async connect with the connect handler
                _connecting = true;
                auto async_connect_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec2, const asio::ip::tcp::endpoint& endpoint)
                {
                    _connecting = false;

                    if (IsConnected() || IsHandshaked() || _resolving || _connecting || _handshaking)
                        return;

                    if (!ec2)
                    {
                        //  Connect to the server
                        _endpoint = endpoint;

                        // Apply the option: keep alive
                        if (option_keep_alive())
                            socket().set_option(asio::ip::tcp::socket::keep_alive(true));
                        // Apply the option: no delay
                        if (option_no_delay())
                            socket().set_option(asio::ip::tcp::no_delay(true));

                        // Prepare receive & send buffers
                        _receive_buffer.resize(option_receive_buffer_size());
                        _send_buffer_main.reserve(option_send_buffer_size());
                        _send_buffer_flush.reserve(option_send_buffer_size());

                        // Reset statistic
                        _bytes_pending = 0;
                        _bytes_sending = 0;
                        _bytes_sent = 0;
                        _bytes_received = 0;

                        // Update the connected flag
                        _connected = true;

                        // Call the client connected handler
                        onConnected();

                        // Async SSL handshake with the handshake handler
                        _handshaking = true;
                        auto async_handshake_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec3)
                        {
                            _handshaking = false;

                            if (IsHandshaked())
                                return;

                            if (!ec3)
                            {
                                // Update the handshaked flag
                                _handshaked = true;

                                // Try to receive something from the server
                                TryReceive();

                                // Call the client handshaked handler
                                onHandshaked();

                                // Call the empty send buffer handler
                                if (_send_buffer_main.empty())
                                    onEmpty();
                            }
                            else
                            {
                                // Disconnect in case of the bad handshake
                                SendError(ec3);
                                DisconnectInternalAsync(true);
                            }
                        });
                        if (_strand_required)
                            _stream.async_handshake(asio::ssl::stream_base::client, bind_executor(_strand, async_handshake_handler));
                        else
                            _stream.async_handshake(asio::ssl::stream_base::client, async_handshake_handler);
                    }
                    else
                    {
                        SendError(ec2);

                        // Call the client disconnected handler
                        onDisconnected();
                    }
                });
                if (_strand_required)
                    asio::async_connect(socket(), endpoints, bind_executor(_strand, async_connect_handler));
                else
                    asio::async_connect(socket(), endpoints, async_connect_handler);
            }
            else
            {
                SendError(ec1);

                // Call the client disconnected handler
                onDisconnected();
            }
        });

        // Resolve the server endpoint
        asio::ip::tcp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
        if (_strand_required)
            resolver->resolver().async_resolve(query, bind_executor(_strand, async_resolve_handler));
        else
            resolver->resolver().async_resolve(query, async_resolve_handler);
    });
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool SSLClient::DisconnectInternalAsync(bool dispatch)
{
    if (!IsConnected() || _resolving || _connecting || _handshaking)
        return false;

    // Dispatch or post the disconnect handler
    auto self(this->shared_from_this());
    auto disconnect_handler = make_alloc_handler(_connect_storage, [this, self]()
    {
        if (!IsConnected() || _resolving || _connecting || _handshaking)
            return;

        asio::error_code ec;

        // Cancel the client socket
        socket().cancel(ec);

        // Async SSL shutdown with the shutdown handler
        auto async_shutdown_handler = make_alloc_handler(_connect_storage, [this, self](std::error_code ec2) { DisconnectInternal(); });
        if (_strand_required)
            _stream.async_shutdown(bind_executor(_strand, async_shutdown_handler));
        else
            _stream.async_shutdown(async_shutdown_handler);
    });
    if (_strand_required)
    {
        if (dispatch)
            _strand.dispatch(disconnect_handler);
        else
            _strand.post(disconnect_handler);
    }
    else
    {
        if (dispatch)
            _io_service->dispatch(disconnect_handler);
        else
            _io_service->post(disconnect_handler);
    }

    return true;
}

bool SSLClient::ReconnectAsync()
{
    if (!DisconnectAsync())
        return false;

    while (IsConnected())
        CppCommon::Thread::Yield();

    return ConnectAsync();
}

size_t SSLClient::Send(const void* buffer, size_t size)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Send data to the server
    size_t sent = asio::write(_stream, asio::buffer(buffer, size), ec);
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return sent;
}

size_t SSLClient::Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_stream.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            socket().cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async write some data to the server
    size_t sent = 0;
    _stream.async_write_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send data to the server
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return sent;
}

bool SSLClient::SendAsync(const void* buffer, size_t size)
{
    if (!IsHandshaked())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    {
        std::scoped_lock locker(_send_lock);

        // Detect multiple send handlers
        bool send_required = _send_buffer_main.empty() || _send_buffer_flush.empty();

        // Check the send buffer limit
        if (((_send_buffer_main.size() + size) > _send_buffer_limit) && (_send_buffer_limit > 0))
        {
            SendError(asio::error::no_buffer_space);
            return false;
        }

        // Fill the main send buffer
        const uint8_t* bytes = (const uint8_t*)buffer;
        _send_buffer_main.insert(_send_buffer_main.end(), bytes, bytes + size);

        // Update statistic
        _bytes_pending = _send_buffer_main.size();

        // Avoid multiple send handlers
        if (!send_required)
            return true;
    }

    // Dispatch the send handler
    auto self(this->shared_from_this());
    auto send_handler = [this, self]()
    {
        // Try to send the main buffer
        TrySend();
    };
    if (_strand_required)
        _strand.dispatch(send_handler);
    else
        _io_service->dispatch(send_handler);

    return true;
}

size_t SSLClient::Receive(void* buffer, size_t size)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive data from the server
    size_t received = _stream.read_some(asio::buffer(buffer, size), ec);
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return received;
}

std::string SSLClient::Receive(size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size()));
    return text;
}

size_t SSLClient::Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_stream.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            socket().cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async read some data from the server
    size_t received = 0;
    _stream.async_read_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Received some data from the server
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return received;
}

std::string SSLClient::Receive(size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size(), timeout));
    return text;
}

void SSLClient::ReceiveAsync()
{
    // Try to receive data from the server
    TryReceive();
}

void SSLClient::TryReceive()
{
    if (_receiving)
        return;

    if (!IsHandshaked())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsHandshaked())
            return;

        // Received some data from the server
        if (size > 0)
        {
            // Update statistic
            _bytes_received += size;

            // Call the buffer received handler
            onReceived(_receive_buffer.data(), size);

            // If the receive buffer is full increase its size
            if (_receive_buffer.size() == size)
            {
                // Check the receive buffer limit
                if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
                {
                    SendError(asio::error::no_buffer_space);
                    DisconnectInternalAsync(true);
                    return;
                }

                _receive_buffer.resize(2 * size);
            }
        }

        // Try to receive again if the session is valid
        if (!ec)
            TryReceive();
        else
        {
            SendError(ec);
            DisconnectInternalAsync(true);
        }
    });
    if (_strand_required)
        _stream.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), bind_executor(_strand, async_receive_handler));
    else
        _stream.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), async_receive_handler);
}

void SSLClient::TrySend()
{
    if (_sending)
        return;

    if (!IsHandshaked())
        return;

    // Swap send buffers
    if (_send_buffer_flush.empty())
    {
        std::scoped_lock locker(_send_lock);

        // Swap flush and main buffers
        _send_buffer_flush.swap(_send_buffer_main);
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending += _send_buffer_flush.size();
    }

    // Check if the flush buffer is empty
    if (_send_buffer_flush.empty())
    {
        // Call the empty send buffer handler
        onEmpty();
        return;
    }

    // Async write with the write handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_write_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t size)
    {
        _sending = false;

        if (!IsHandshaked())
            return;

        // Send some data to the server
        if (size > 0)
        {
            // Update statistic
            _bytes_sending -= size;
            _bytes_sent += size;

            // Increase the flush buffer offset
            _send_buffer_flush_offset += size;

            // Successfully send the whole flush buffer
            if (_send_buffer_flush_offset == _send_buffer_flush.size())
            {
                // Clear the flush buffer
                _send_buffer_flush.clear();
                _send_buffer_flush_offset = 0;
            }

            // Call the buffer sent handler
            onSent(size, bytes_pending());
        }

        // Try to send again if the session is valid
        if (!ec)
            TrySend();
        else
        {
            SendError(ec);
            DisconnectInternalAsync(true);
        }
    });
    if (_strand_required)
        _stream.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), bind_executor(_strand, async_write_handler));
    else
        _stream.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), async_write_handler);
}

void SSLClient::ClearBuffers()
{
    {
        std::scoped_lock locker(_send_lock);

        // Clear send buffers
        _send_buffer_main.clear();
        _send_buffer_flush.clear();
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending = 0;
    }
}

void SSLClient::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    // Skip OpenSSL annoying errors
    if (ec == asio::ssl::error::stream_truncated)
        return;
    if (ec.category() == asio::error::get_ssl_category())
    {
        if ((ERR_GET_REASON(ec.value()) == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC) ||
            (ERR_GET_REASON(ec.value()) == SSL_R_PROTOCOL_IS_SHUTDOWN) ||
            (ERR_GET_REASON(ec.value()) == SSL_R_WRONG_VERSION_NUMBER))
            return;
    }

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/ssl_context.cpp`:

```cpp
/*!
    \file ssl_context.cpp
    \brief SSL context implementation
    \author Ivan Shynkarenka
    \date 12.02.2019
    \copyright MIT License
*/

#include "server/asio/ssl_context.h"

#if defined(_WIN32) || defined(_WIN64)
#include <wincrypt.h>
#endif

namespace CppServer {
namespace Asio {

void SSLContext::set_root_certs()
{
#if defined(_WIN32) || defined(_WIN64)
    HCERTSTORE hStore = CertOpenSystemStore(0, "ROOT");
    if (hStore == nullptr)
        return;

    X509_STORE* store = X509_STORE_new();
    PCCERT_CONTEXT pContext = nullptr;
    while ((pContext = CertEnumCertificatesInStore(hStore, pContext)) != nullptr)
    {
        // Convert from DER to internal format
        X509* x509 = d2i_X509(nullptr, (const unsigned char**)&pContext->pbCertEncoded, pContext->cbCertEncoded);
        if (x509 != nullptr)
        {
            X509_STORE_add_cert(store, x509);
            X509_free(x509);
        }
    }

    CertFreeCertificateContext(pContext);
    CertCloseStore(hStore, 0);

    // Attach X509_STORE to the current SSL context
    SSL_CTX_set_cert_store(native_handle(), store);
#endif
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/ssl_server.cpp`:

```cpp
/*!
    \file ssl_server.cpp
    \brief SSL server implementation
    \author Ivan Shynkarenka
    \date 30.12.2016
    \copyright MIT License
*/

#include "server/asio/ssl_server.h"

namespace CppServer {
namespace Asio {

SSLServer::SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, int port, InternetProtocol protocol)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _port(port),
      _context(context),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");

    // Prepare endpoint
    switch (protocol)
    {
        case InternetProtocol::IPv4:
            _endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), (unsigned short)port);
            break;
        case InternetProtocol::IPv6:
            _endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v6(), (unsigned short)port);
            break;
    }
}

SSLServer::SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _context(context),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");

    // Prepare endpoint
    _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(address), (unsigned short)port);
}

SSLServer::SSLServer(const std::shared_ptr<Service>& service, const std::shared_ptr<SSLContext>& context, const asio::ip::tcp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _context(context),
      _endpoint(endpoint),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    assert((context != nullptr) && "SSL context is invalid!");
    if (context == nullptr)
        throw CppCommon::ArgumentException("SSL context is invalid!");
}

bool SSLServer::Start()
{
    assert(!IsStarted() && "SSL server is already started!");
    if (IsStarted())
        return false;

    // Post the start handler
    auto self(this->shared_from_this());
    auto start_handler = [this, self]()
    {
        if (IsStarted())
            return;

        // Create a server acceptor
        _acceptor = asio::ip::tcp::acceptor(*_io_service);
        _acceptor.open(_endpoint.protocol());
        if (option_reuse_address())
            _acceptor.set_option(asio::ip::tcp::acceptor::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
        if (option_reuse_port())
        {
            typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
            _acceptor.set_option(reuse_port(true));
        }
#endif
        _acceptor.bind(_endpoint);
        _acceptor.listen();

        // Reset statistic
        _bytes_pending = 0;
        _bytes_sent = 0;
        _bytes_received = 0;

        // Update the started flag
        _started = true;

        // Call the server started handler
        onStarted();

        // Perform the first server accept
        Accept();
    };
    if (_strand_required)
        _strand.post(start_handler);
    else
        _io_service->post(start_handler);

    return true;
}

bool SSLServer::Stop()
{
    assert(IsStarted() && "SSL server is not started!");
    if (!IsStarted())
        return false;

    // Post the stop handler
    auto self(this->shared_from_this());
    auto stop_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        // Close the server acceptor
        _acceptor.close();

        // Reset the session
        _session->ResetServer();

        // Disconnect all sessions
        DisconnectAll();

        // Update the started flag
        _started = false;

        // Clear multicast buffer
        ClearBuffers();

        // Call the server stopped handler
        onStopped();
    };
    if (_strand_required)
        _strand.post(stop_handler);
    else
        _io_service->post(stop_handler);

    return true;
}

bool SSLServer::Restart()
{
    if (!Stop())
        return false;

    while (IsStarted())
        CppCommon::Thread::Yield();

    return Start();
}

void SSLServer::Accept()
{
    if (!IsStarted())
        return;

    // Dispatch the accept handler
    auto self(this->shared_from_this());
    auto accept_handler = make_alloc_handler(_acceptor_storage, [this, self]()
    {
        if (!IsStarted())
            return;

        // Create a new session to accept
        _session = CreateSession(self);

        auto async_accept_handler = make_alloc_handler(_acceptor_storage, [this, self](std::error_code ec)
        {
            if (!ec)
            {
                RegisterSession();

                // Connect a new session
                _session->Connect();
            }
            else
                SendError(ec);

            // Perform the next server accept
            Accept();
        });
        if (_strand_required)
            _acceptor.async_accept(_session->socket(), bind_executor(_strand, async_accept_handler));
        else
            _acceptor.async_accept(_session->socket(), async_accept_handler);
    });
    if (_strand_required)
        _strand.dispatch(accept_handler);
    else
        _io_service->dispatch(accept_handler);
}

bool SSLServer::Multicast(const void* buffer, size_t size)
{
    if (!IsStarted())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Multicast all sessions
    for (auto& session : _sessions)
        session.second->SendAsync(buffer, size);

    return true;
}

bool SSLServer::DisconnectAll()
{
    if (!IsStarted())
        return false;

    // Dispatch the disconnect all handler
    auto self(this->shared_from_this());
    auto disconnect_all_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        std::shared_lock<std::shared_mutex> locker(_sessions_lock);

        // Disconnect all sessions
        for (auto& session : _sessions)
            session.second->Disconnect();
    };
    if (_strand_required)
        _strand.dispatch(disconnect_all_handler);
    else
        _io_service->dispatch(disconnect_all_handler);

    return true;
}

std::shared_ptr<SSLSession> SSLServer::FindSession(const CppCommon::UUID& id)
{
    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Try to find the required session
    auto it = _sessions.find(id);
    return (it != _sessions.end()) ? it->second : nullptr;
}

void SSLServer::RegisterSession()
{
    std::unique_lock<std::shared_mutex> locker(_sessions_lock);

    // Register a new session
    _sessions.emplace(_session->id(), _session);
}

void SSLServer::UnregisterSession(const CppCommon::UUID& id)
{
    std::unique_lock<std::shared_mutex> locker(_sessions_lock);

    // Try to find the unregistered session
    auto it = _sessions.find(id);
    if (it != _sessions.end())
    {
        // Erase the session
        _sessions.erase(it);
    }
}

void SSLServer::ClearBuffers()
{
    // Update statistic
    _bytes_pending = 0;
}

void SSLServer::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    // Skip Winsock error 995: The I/O operation has been aborted because of either a thread exit or an application request
    if (ec.value() == 995)
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/ssl_session.cpp`:

```cpp
/*!
    \file ssl_session.cpp
    \brief SSL session implementation
    \author Ivan Shynkarenka
    \date 30.12.2016
    \copyright MIT License
*/

#include "server/asio/ssl_session.h"
#include "server/asio/ssl_server.h"

namespace CppServer {
namespace Asio {

SSLSession::SSLSession(const std::shared_ptr<SSLServer>& server)
    : _id(CppCommon::UUID::Sequential()),
      _server(server),
      _io_service(server->service()->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_server->_strand_required),
      _stream(*_io_service, *server->context()),
      _connected(false),
      _handshaked(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0)
{
}

size_t SSLSession::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _stream.next_layer().get_option(option);
    return option.value();
}

size_t SSLSession::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _stream.next_layer().get_option(option);
    return option.value();
}

void SSLSession::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    socket().set_option(option);
}

void SSLSession::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    socket().set_option(option);
}

void SSLSession::Connect()
{
    // Apply the option: keep alive
    if (_server->option_keep_alive())
        socket().set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (_server->option_no_delay())
        socket().set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the session connected handler
    onConnected();

    // Call the session connected handler in the server
    auto connected_session(this->shared_from_this());
    _server->onConnected(connected_session);

    // Async SSL handshake with the handshake handler
    auto self(this->shared_from_this());
    auto async_handshake_handler = [this, self](std::error_code ec)
    {
        if (IsHandshaked())
            return;

        if (!ec)
        {
            // Update the handshaked flag
            _handshaked = true;

            // Try to receive something from the client
            TryReceive();

            // Call the session handshaked handler
            onHandshaked();

            // Call the session handshaked handler in the server
            auto handshaked_session(this->shared_from_this());
            _server->onHandshaked(handshaked_session);

            // Call the empty send buffer handler
            if (_send_buffer_main.empty())
                onEmpty();
        }
        else
        {
            // Disconnect in case of the bad handshake
            SendError(ec);
            Disconnect(ec);
        }
    };
    if (_strand_required)
        _stream.async_handshake(asio::ssl::stream_base::server, bind_executor(_strand, async_handshake_handler));
    else
        _stream.async_handshake(asio::ssl::stream_base::server, async_handshake_handler);
}

void SSLSession::Disconnect(std::error_code ec)
{
    if (!IsConnected())
        return;

    // Close the session socket
    socket().close();

    // Update the handshaked flag
    _handshaked = false;

    // Update the connected flag
    _connected = false;

    // Update sending/receiving flags
    _receiving = false;
    _sending = false;

    // Clear send/receive buffers
    ClearBuffers();

    // Call the session disconnected handler
    onDisconnected();

    // Call the session disconnected handler in the server
    auto disconnected_session(this->shared_from_this());
    _server->onDisconnected(disconnected_session);

    // Dispatch the unregister session handler
    auto self(this->shared_from_this());
    auto unregister_session_handler = [this, self]()
    {
        _server->UnregisterSession(id());
    };
    if (_server->_strand_required)
        _server->_strand.dispatch(unregister_session_handler);
    else
        _server->_io_service->dispatch(unregister_session_handler);
}

bool SSLSession::DisconnectAsync(bool dispatch)
{
    if (!IsConnected())
        return false;

    // Dispatch or post the disconnect handler
    auto self(this->shared_from_this());
    auto disconnect_handler = [this, self]()
    {
        if (!IsConnected())
            return;

        asio::error_code ec;

        // Cancel the session socket
        socket().cancel(ec);

        // Async SSL shutdown with the shutdown handler
        auto async_shutdown_handler = [this, self](std::error_code ec2) { Disconnect(ec2); };
        if (_strand_required)
            _stream.async_shutdown(bind_executor(_strand, async_shutdown_handler));
        else
            _stream.async_shutdown(async_shutdown_handler);
    };
    if (_strand_required)
    {
        if (dispatch)
            _strand.dispatch(disconnect_handler);
        else
            _strand.post(disconnect_handler);
    }
    else
    {
        if (dispatch)
            _io_service->dispatch(disconnect_handler);
        else
            _io_service->post(disconnect_handler);
    }

    return true;
}

size_t SSLSession::Send(const void* buffer, size_t size)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Send data to the client
    size_t sent = asio::write(_stream, asio::buffer(buffer, size), ec);
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;
        _server->_bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect(ec);
    }

    return sent;
}

size_t SSLSession::Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_stream.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            socket().cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async write some data to the client
    size_t sent = 0;
    _stream.async_write_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send data to the client
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;
        _server->_bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect(error);
    }

    return sent;
}

bool SSLSession::SendAsync(const void* buffer, size_t size)
{
    if (!IsHandshaked())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    {
        std::scoped_lock locker(_send_lock);

        // Detect multiple send handlers
        bool send_required = _send_buffer_main.empty() || _send_buffer_flush.empty();

        // Check the send buffer limit
        if (((_send_buffer_main.size() + size) > _send_buffer_limit) && (_send_buffer_limit > 0))
        {
            SendError(asio::error::no_buffer_space);
            return false;
        }

        // Fill the main send buffer
        const uint8_t* bytes = (const uint8_t*)buffer;
        _send_buffer_main.insert(_send_buffer_main.end(), bytes, bytes + size);

        // Update statistic
        _bytes_pending = _send_buffer_main.size();

        // Avoid multiple send handlers
        if (!send_required)
            return true;
    }

    // Dispatch the send handler
    auto self(this->shared_from_this());
    auto send_handler = [this, self]()
    {
        // Try to send the main buffer
        TrySend();
    };
    if (_strand_required)
        _strand.dispatch(send_handler);
    else
        _io_service->dispatch(send_handler);

    return true;
}

size_t SSLSession::Receive(void* buffer, size_t size)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive data from the client
    size_t received = _stream.read_some(asio::buffer(buffer, size), ec);
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;
        _server->_bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect(ec);
    }

    return received;
}

std::string SSLSession::Receive(size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size()));
    return text;
}

size_t SSLSession::Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsHandshaked())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_stream.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            socket().cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async read some data from the client
    size_t received = 0;
    _stream.async_read_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Received some data from the client
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;
        _server->_bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect(error);
    }

    return received;
}

std::string SSLSession::Receive(size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size(), timeout));
    return text;
}

void SSLSession::ReceiveAsync()
{
    // Try to receive data from the client
    TryReceive();
}

void SSLSession::TryReceive()
{
    if (_receiving)
        return;

    if (!IsHandshaked())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsHandshaked())
            return;

        // Received some data from the client
        if (size > 0)
        {
            // Update statistic
            _bytes_received += size;
            _server->_bytes_received += size;

            // Call the buffer received handler
            onReceived(_receive_buffer.data(), size);

            // If the receive buffer is full increase its size
            if (_receive_buffer.size() == size)
            {
                // Check the receive buffer limit
                if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
                {
                    SendError(asio::error::no_buffer_space);
                    Disconnect(asio::error::no_buffer_space);
                    return;
                }

                _receive_buffer.resize(2 * size);
            }
        }

        // Try to receive again if the session is valid
        if (!ec)
            TryReceive();
        else
        {
            SendError(ec);
            Disconnect(ec);
        }
    });
    if (_strand_required)
        _stream.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), bind_executor(_strand, async_receive_handler));
    else
        _stream.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), async_receive_handler);
}

void SSLSession::TrySend()
{
    if (_sending)
        return;

    if (!IsHandshaked())
        return;

    // Swap send buffers
    if (_send_buffer_flush.empty())
    {
        std::scoped_lock locker(_send_lock);

        // Swap flush and main buffers
        _send_buffer_flush.swap(_send_buffer_main);
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending += _send_buffer_flush.size();
    }

    // Check if the flush buffer is empty
    if (_send_buffer_flush.empty())
    {
        // Call the empty send buffer handler
        onEmpty();
        return;
    }

    // Async write with the write handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_write_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t size)
    {
        _sending = false;

        if (!IsHandshaked())
            return;

        // Send some data to the client
        if (size > 0)
        {
            // Update statistic
            _bytes_sending -= size;
            _bytes_sent += size;
            _server->_bytes_sent += size;

            // Increase the flush buffer offset
            _send_buffer_flush_offset += size;

            // Successfully send the whole flush buffer
            if (_send_buffer_flush_offset == _send_buffer_flush.size())
            {
                // Clear the flush buffer
                _send_buffer_flush.clear();
                _send_buffer_flush_offset = 0;
            }

            // Call the buffer sent handler
            onSent(size, bytes_pending());
        }

        // Try to send again if the session is valid
        if (!ec)
            TrySend();
        else
        {
            SendError(ec);
            Disconnect(ec);
        }
    });
    if (_strand_required)
        _stream.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), bind_executor(_strand, async_write_handler));
    else
        _stream.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), async_write_handler);
}

void SSLSession::ClearBuffers()
{
    {
        std::scoped_lock locker(_send_lock);

        // Clear send buffers
        _send_buffer_main.clear();
        _send_buffer_flush.clear();
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending = 0;
    }
}

void SSLSession::ResetServer()
{
    // Reset cycle-reference to the server
    _server.reset();
}

void SSLSession::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    // Skip OpenSSL annoying errors
    if (ec == asio::ssl::error::stream_truncated)
        return;
    if (ec.category() == asio::error::get_ssl_category())
    {
        if ((ERR_GET_REASON(ec.value()) == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC) ||
            (ERR_GET_REASON(ec.value()) == SSL_R_PROTOCOL_IS_SHUTDOWN) ||
            (ERR_GET_REASON(ec.value()) == SSL_R_WRONG_VERSION_NUMBER))
            return;
    }

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/tcp_client.cpp`:

```cpp
/*!
    \file tcp_client.cpp
    \brief TCP client implementation
    \author Ivan Shynkarenka
    \date 15.12.2016
    \copyright MIT License
*/

#include "server/asio/tcp_client.h"

namespace CppServer {
namespace Asio {

TCPClient::TCPClient(const std::shared_ptr<Service>& service, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _socket(*_io_service),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

TCPClient::TCPClient(const std::shared_ptr<Service>& service, const std::string& address, const std::string& scheme)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _scheme(scheme),
      _port(0),
      _socket(*_io_service),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

TCPClient::TCPClient(const std::shared_ptr<Service>& service, const asio::ip::tcp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _endpoint(endpoint),
      _socket(*_io_service),
      _resolving(false),
      _connecting(false),
      _connected(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0),
      _option_keep_alive(false),
      _option_no_delay(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

size_t TCPClient::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

size_t TCPClient::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

void TCPClient::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    _socket.set_option(option);
}

void TCPClient::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    _socket.set_option(option);
}

bool TCPClient::Connect()
{
    if (IsConnected())
        return false;

    asio::error_code ec;

    // Create the server endpoint
    _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(_address), (unsigned short)_port);

    // Connect to the server
    _socket.connect(_endpoint, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    // Apply the option: keep alive
    if (option_keep_alive())
        _socket.set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (option_no_delay())
        _socket.set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    // Call the empty send buffer handler
    if (_send_buffer_main.empty())
        onEmpty();

    return true;
}

bool TCPClient::Connect(const std::shared_ptr<TCPResolver>& resolver)
{
    if (IsConnected())
        return false;

    asio::error_code ec;

    // Resolve the server endpoint
    asio::ip::tcp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
    auto endpoints = resolver->resolver().resolve(query, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    //  Connect to the server
    _endpoint = asio::connect(_socket, endpoints, ec);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    // Apply the option: keep alive
    if (option_keep_alive())
        _socket.set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (option_no_delay())
        _socket.set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    // Call the empty send buffer handler
    if (_send_buffer_main.empty())
        onEmpty();

    return true;
}

bool TCPClient::DisconnectInternal()
{
    if (!IsConnected())
        return false;

    // Close the client socket
    _socket.close();

    // Update the connected flag
    _resolving = false;
    _connecting = false;
    _connected = false;

    // Update sending/receiving flags
    _receiving = false;
    _sending = false;

    // Clear send/receive buffers
    ClearBuffers();

    // Call the client disconnected handler
    onDisconnected();

    return true;
}

bool TCPClient::Reconnect()
{
    if (!Disconnect())
        return false;

    return Connect();
}

bool TCPClient::ConnectAsync()
{
    if (IsConnected() || _resolving || _connecting)
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = [this, self]()
    {
        if (IsConnected() || _resolving || _connecting)
            return;

        // Async connect with the connect handler
        _connecting = true;
        auto async_connect_handler = [this, self](std::error_code ec)
        {
            _connecting = false;

            if (IsConnected() || _resolving || _connecting)
                return;

            if (!ec)
            {
                // Apply the option: keep alive
                if (option_keep_alive())
                    _socket.set_option(asio::ip::tcp::socket::keep_alive(true));
                // Apply the option: no delay
                if (option_no_delay())
                    _socket.set_option(asio::ip::tcp::no_delay(true));

                // Prepare receive & send buffers
                _receive_buffer.resize(option_receive_buffer_size());
                _send_buffer_main.reserve(option_send_buffer_size());
                _send_buffer_flush.reserve(option_send_buffer_size());

                // Reset statistic
                _bytes_pending = 0;
                _bytes_sending = 0;
                _bytes_sent = 0;
                _bytes_received = 0;

                // Update the connected flag
                _connected = true;

                // Try to receive something from the server
                TryReceive();

                // Call the client connected handler
                onConnected();

                // Call the empty send buffer handler
                if (_send_buffer_main.empty())
                    onEmpty();
            }
            else
            {
                SendError(ec);

                // Call the client disconnected handler
                onDisconnected();
            }
        };

        // Create the server endpoint
        _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(_address), (unsigned short)_port);

        if (_strand_required)
            _socket.async_connect(_endpoint, bind_executor(_strand, async_connect_handler));
        else
            _socket.async_connect(_endpoint, async_connect_handler);
    };
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool TCPClient::ConnectAsync(const std::shared_ptr<TCPResolver>& resolver)
{
    if (IsConnected() || _resolving || _connecting)
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = [this, self, resolver]()
    {
        if (IsConnected() || _resolving || _connecting)
            return;

        // Async resolve with the connect handler
        _resolving = true;
        auto async_resolve_handler = [this, self](std::error_code ec1, asio::ip::tcp::resolver::results_type endpoints)
        {
            _resolving = false;

            if (IsConnected() || _resolving || _connecting)
                return;

            if (!ec1)
            {
                // Async connect with the connect handler
                _connecting = true;
                auto async_connect_handler = [this, self](std::error_code ec2, const asio::ip::tcp::endpoint& endpoint)
                {
                    _connecting = false;

                    if (IsConnected() || _resolving || _connecting)
                        return;

                    if (!ec2)
                    {
                        //  Connect to the server
                        _endpoint = endpoint;

                        // Apply the option: keep alive
                        if (option_keep_alive())
                            _socket.set_option(asio::ip::tcp::socket::keep_alive(true));
                        // Apply the option: no delay
                        if (option_no_delay())
                            _socket.set_option(asio::ip::tcp::no_delay(true));

                        // Prepare receive & send buffers
                        _receive_buffer.resize(option_receive_buffer_size());
                        _send_buffer_main.reserve(option_send_buffer_size());
                        _send_buffer_flush.reserve(option_send_buffer_size());

                        // Reset statistic
                        _bytes_pending = 0;
                        _bytes_sending = 0;
                        _bytes_sent = 0;
                        _bytes_received = 0;

                        // Update the connected flag
                        _connected = true;

                        // Try to receive something from the server
                        TryReceive();

                        // Call the client connected handler
                        onConnected();

                        // Call the empty send buffer handler
                        if (_send_buffer_main.empty())
                            onEmpty();
                    }
                    else
                    {
                        SendError(ec2);

                        // Call the client disconnected handler
                        onDisconnected();
                    }
                };
                if (_strand_required)
                    asio::async_connect(_socket, endpoints, bind_executor(_strand, async_connect_handler));
                else
                    asio::async_connect(_socket, endpoints, async_connect_handler);
            }
            else
            {
                SendError(ec1);

                // Call the client disconnected handler
                onDisconnected();
            }
        };

        // Resolve the server endpoint
        asio::ip::tcp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
        if (_strand_required)
            resolver->resolver().async_resolve(query, bind_executor(_strand, async_resolve_handler));
        else
            resolver->resolver().async_resolve(query, async_resolve_handler);
    };
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool TCPClient::DisconnectInternalAsync(bool dispatch)
{
    if (!IsConnected() || _resolving || _connecting)
        return false;

    asio::error_code ec;

    // Cancel the client socket
    _socket.cancel(ec);

    // Dispatch or post the disconnect handler
    auto self(this->shared_from_this());
    auto disconnect_handler = [this, self]() { DisconnectInternal(); };
    if (_strand_required)
    {
        if (dispatch)
            _strand.dispatch(disconnect_handler);
        else
            _strand.post(disconnect_handler);
    }
    else
    {
        if (dispatch)
            _io_service->dispatch(disconnect_handler);
        else
            _io_service->post(disconnect_handler);
    }

    return true;
}

bool TCPClient::ReconnectAsync()
{
    if (!DisconnectAsync())
        return false;

    while (IsConnected())
        CppCommon::Thread::Yield();

    return ConnectAsync();
}

size_t TCPClient::Send(const void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Send data to the server
    size_t sent = asio::write(_socket, asio::buffer(buffer, size), ec);
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return sent;
}

size_t TCPClient::Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async write some data to the server
    size_t sent = 0;
    _socket.async_write_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send data to the server
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return sent;
}

bool TCPClient::SendAsync(const void* buffer, size_t size)
{
    if (!IsConnected())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    {
        std::scoped_lock locker(_send_lock);

        // Detect multiple send handlers
        bool send_required = _send_buffer_main.empty() || _send_buffer_flush.empty();

        // Check the send buffer limit
        if (((_send_buffer_main.size() + size) > _send_buffer_limit) && (_send_buffer_limit > 0))
        {
            SendError(asio::error::no_buffer_space);
            return false;
        }

        // Fill the main send buffer
        const uint8_t* bytes = (const uint8_t*)buffer;
        _send_buffer_main.insert(_send_buffer_main.end(), bytes, bytes + size);

        // Update statistic
        _bytes_pending = _send_buffer_main.size();

        // Avoid multiple send handlers
        if (!send_required)
            return true;
    }

    // Dispatch the send handler
    auto self(this->shared_from_this());
    auto send_handler = [this, self]()
    {
        // Try to send the main buffer
        TrySend();
    };
    if (_strand_required)
        _strand.dispatch(send_handler);
    else
        _io_service->dispatch(send_handler);

    return true;
}

size_t TCPClient::Receive(void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive data from the server
    size_t received = _socket.read_some(asio::buffer(buffer, size), ec);
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return received;
}

std::string TCPClient::Receive(size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size()));
    return text;
}

size_t TCPClient::Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async read some data from the server
    size_t received = 0;
    _socket.async_read_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Received some data from the server
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return received;
}

std::string TCPClient::Receive(size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size(), timeout));
    return text;
}

void TCPClient::ReceiveAsync()
{
    // Try to receive data from the server
    TryReceive();
}

void TCPClient::TryReceive()
{
    if (_receiving)
        return;

    if (!IsConnected())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsConnected())
            return;

        // Received some data from the server
        if (size > 0)
        {
            // Update statistic
            _bytes_received += size;

            // Call the buffer received handler
            onReceived(_receive_buffer.data(), size);

            // If the receive buffer is full increase its size
            if (_receive_buffer.size() == size)
            {
                // Check the receive buffer limit
                if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
                {
                    SendError(asio::error::no_buffer_space);
                    DisconnectInternalAsync(true);
                    return;
                }

                _receive_buffer.resize(2 * size);
            }
        }

        // Try to receive again if the session is valid
        if (!ec)
            TryReceive();
        else
        {
            SendError(ec);
            DisconnectInternalAsync(true);
        }
    });
    if (_strand_required)
        _socket.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), bind_executor(_strand, async_receive_handler));
    else
        _socket.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), async_receive_handler);
}

void TCPClient::TrySend()
{
    if (_sending)
        return;

    if (!IsConnected())
        return;

    // Swap send buffers
    if (_send_buffer_flush.empty())
    {
        std::scoped_lock locker(_send_lock);

        // Swap flush and main buffers
        _send_buffer_flush.swap(_send_buffer_main);
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending += _send_buffer_flush.size();
    }

    // Check if the flush buffer is empty
    if (_send_buffer_flush.empty())
    {
        // Call the empty send buffer handler
        onEmpty();
        return;
    }

    // Async write with the write handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_write_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t size)
    {
        _sending = false;

        if (!IsConnected())
            return;

        // Send some data to the server
        if (size > 0)
        {
            // Update statistic
            _bytes_sending -= size;
            _bytes_sent += size;

            // Increase the flush buffer offset
            _send_buffer_flush_offset += size;

            // Successfully send the whole flush buffer
            if (_send_buffer_flush_offset == _send_buffer_flush.size())
            {
                // Clear the flush buffer
                _send_buffer_flush.clear();
                _send_buffer_flush_offset = 0;
            }

            // Call the buffer sent handler
            onSent(size, bytes_pending());
        }

        // Try to send again if the session is valid
        if (!ec)
            TrySend();
        else
        {
            SendError(ec);
            DisconnectInternalAsync(true);
        }
    });
    if (_strand_required)
        _socket.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), bind_executor(_strand, async_write_handler));
    else
        _socket.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), async_write_handler);
}

void TCPClient::ClearBuffers()
{
    {
        std::scoped_lock locker(_send_lock);

        // Clear send buffers
        _send_buffer_main.clear();
        _send_buffer_flush.clear();
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending = 0;
    }
}

void TCPClient::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/tcp_resolver.cpp`:

```cpp
/*!
    \file tcp_resolver.cpp
    \brief TCP resolver implementation
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#include "server/asio/tcp_resolver.h"

namespace CppServer {
namespace Asio {

TCPResolver::TCPResolver(const std::shared_ptr<Service>& service)
    : _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _resolver(*_io_service)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/tcp_server.cpp`:

```cpp
/*!
    \file tcp_server.cpp
    \brief TCP server implementation
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#include "server/asio/tcp_server.h"

namespace CppServer {
namespace Asio {

TCPServer::TCPServer(const std::shared_ptr<Service>& service, int port, InternetProtocol protocol)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _port(port),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    // Prepare endpoint
    switch (protocol)
    {
        case InternetProtocol::IPv4:
            _endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), (unsigned short)port);
            break;
        case InternetProtocol::IPv6:
            _endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v6(), (unsigned short)port);
            break;
    }
}

TCPServer::TCPServer(const std::shared_ptr<Service>& service, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    // Prepare endpoint
    _endpoint = asio::ip::tcp::endpoint(asio::ip::make_address(address), (unsigned short)port);
}

TCPServer::TCPServer(const std::shared_ptr<Service>& service, const asio::ip::tcp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _endpoint(endpoint),
      _acceptor(*_io_service),
      _started(false),
      _bytes_pending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _option_keep_alive(false),
      _option_no_delay(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

bool TCPServer::Start()
{
    assert(!IsStarted() && "TCP server is already started!");
    if (IsStarted())
        return false;

    // Post the start handler
    auto self(this->shared_from_this());
    auto start_handler = [this, self]()
    {
        if (IsStarted())
            return;

        // Create a server acceptor
        _acceptor = asio::ip::tcp::acceptor(*_io_service);
        _acceptor.open(_endpoint.protocol());
        if (option_reuse_address())
            _acceptor.set_option(asio::ip::tcp::acceptor::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
        if (option_reuse_port())
        {
            typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
            _acceptor.set_option(reuse_port(true));
        }
#endif
        _acceptor.bind(_endpoint);
        _acceptor.listen();

        // Reset statistic
        _bytes_pending = 0;
        _bytes_sent = 0;
        _bytes_received = 0;

        // Update the started flag
        _started = true;

        // Call the server started handler
        onStarted();

        // Perform the first server accept
        Accept();
    };
    if (_strand_required)
        _strand.post(start_handler);
    else
        _io_service->post(start_handler);

    return true;
}

bool TCPServer::Stop()
{
    assert(IsStarted() && "TCP server is not started!");
    if (!IsStarted())
        return false;

    // Post the stop handler
    auto self(this->shared_from_this());
    auto stop_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        // Close the server acceptor
        _acceptor.close();

        // Reset the session
        _session->ResetServer();

        // Disconnect all sessions
        DisconnectAll();

        // Update the started flag
        _started = false;

        // Clear multicast buffer
        ClearBuffers();

        // Call the server stopped handler
        onStopped();
    };
    if (_strand_required)
        _strand.post(stop_handler);
    else
        _io_service->post(stop_handler);

    return true;
}

bool TCPServer::Restart()
{
    if (!Stop())
        return false;

    while (IsStarted())
        CppCommon::Thread::Yield();

    return Start();
}

void TCPServer::Accept()
{
    if (!IsStarted())
        return;

    // Dispatch the accept handler
    auto self(this->shared_from_this());
    auto accept_handler = make_alloc_handler(_acceptor_storage, [this, self]()
    {
        if (!IsStarted())
            return;

        // Create a new session to accept
        _session = CreateSession(self);

        auto async_accept_handler = make_alloc_handler(_acceptor_storage, [this, self](std::error_code ec)
        {
            if (!ec)
            {
                RegisterSession();

                // Connect a new session
                _session->Connect();
            }
            else
                SendError(ec);

            // Perform the next server accept
            Accept();
        });
        if (_strand_required)
            _acceptor.async_accept(_session->socket(), bind_executor(_strand, async_accept_handler));
        else
            _acceptor.async_accept(_session->socket(), async_accept_handler);
    });
    if (_strand_required)
        _strand.dispatch(accept_handler);
    else
        _io_service->dispatch(accept_handler);
}

bool TCPServer::Multicast(const void* buffer, size_t size)
{
    if (!IsStarted())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Multicast all sessions
    for (auto& session : _sessions)
        session.second->SendAsync(buffer, size);

    return true;
}

bool TCPServer::DisconnectAll()
{
    if (!IsStarted())
        return false;

    // Dispatch the disconnect all handler
    auto self(this->shared_from_this());
    auto disconnect_all_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        std::shared_lock<std::shared_mutex> locker(_sessions_lock);

        // Disconnect all sessions
        for (auto& session : _sessions)
            session.second->Disconnect();
    };
    if (_strand_required)
        _strand.dispatch(disconnect_all_handler);
    else
        _io_service->dispatch(disconnect_all_handler);

    return true;
}

std::shared_ptr<TCPSession> TCPServer::FindSession(const CppCommon::UUID& id)
{
    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Try to find the required session
    auto it = _sessions.find(id);
    return (it != _sessions.end()) ? it->second : nullptr;
}

void TCPServer::RegisterSession()
{
    std::unique_lock<std::shared_mutex> locker(_sessions_lock);

    // Register a new session
    _sessions.emplace(_session->id(), _session);
}

void TCPServer::UnregisterSession(const CppCommon::UUID& id)
{
    std::unique_lock<std::shared_mutex> locker(_sessions_lock);

    // Try to find the unregistered session
    auto it = _sessions.find(id);
    if (it != _sessions.end())
    {
        // Erase the session
        _sessions.erase(it);
    }
}

void TCPServer::ClearBuffers()
{
    // Update statistic
    _bytes_pending = 0;
}

void TCPServer::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    // Skip Winsock error 995: The I/O operation has been aborted because of either a thread exit or an application request
    if (ec.value() == 995)
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/tcp_session.cpp`:

```cpp
/*!
    \file tcp_session.cpp
    \brief TCP session implementation
    \author Ivan Shynkarenka
    \date 14.12.2016
    \copyright MIT License
*/

#include "server/asio/tcp_session.h"
#include "server/asio/tcp_server.h"

namespace CppServer {
namespace Asio {

TCPSession::TCPSession(const std::shared_ptr<TCPServer>& server)
    : _id(CppCommon::UUID::Sequential()),
      _server(server),
      _io_service(server->service()->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_server->_strand_required),
      _socket(*_io_service),
      _connected(false),
      _bytes_pending(0),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _receiving(false),
      _sending(false),
      _send_buffer_flush_offset(0)
{
}

size_t TCPSession::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

size_t TCPSession::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

void TCPSession::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    _socket.set_option(option);
}

void TCPSession::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    _socket.set_option(option);
}

void TCPSession::Connect()
{
    // Apply the option: keep alive
    if (_server->option_keep_alive())
        _socket.set_option(asio::ip::tcp::socket::keep_alive(true));
    // Apply the option: no delay
    if (_server->option_no_delay())
        _socket.set_option(asio::ip::tcp::no_delay(true));

    // Prepare receive & send buffers
    _receive_buffer.resize(option_receive_buffer_size());
    _send_buffer_main.reserve(option_send_buffer_size());
    _send_buffer_flush.reserve(option_send_buffer_size());

    // Reset statistic
    _bytes_pending = 0;
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;

    // Update the connected flag
    _connected = true;

    // Try to receive something from the client
    TryReceive();

    // Call the session connected handler
    onConnected();

    // Call the session connected handler in the server
    auto connected_session(this->shared_from_this());
    _server->onConnected(connected_session);

    // Call the empty send buffer handler
    if (_send_buffer_main.empty())
        onEmpty();
}

bool TCPSession::Disconnect(bool dispatch)
{
    if (!IsConnected())
        return false;

    // Dispatch or post the disconnect handler
    auto self(this->shared_from_this());
    auto disconnect_handler = [this, self]()
    {
        if (!IsConnected())
            return;

        // Close the session socket
        _socket.close();

        // Update the connected flag
        _connected = false;

        // Update sending/receiving flags
        _receiving = false;
        _sending = false;

        // Clear send/receive buffers
        ClearBuffers();

        // Call the session disconnected handler
        onDisconnected();

        // Call the session disconnected handler in the server
        auto disconnected_session(this->shared_from_this());
        _server->onDisconnected(disconnected_session);

        // Dispatch the unregister session handler
        auto unregister_session_handler = [this, self]()
        {
            _server->UnregisterSession(id());
        };
        if (_server->_strand_required)
            _server->_strand.dispatch(unregister_session_handler);
        else
            _server->_io_service->dispatch(unregister_session_handler);
    };
    if (_strand_required)
    {
        if (dispatch)
            _strand.dispatch(disconnect_handler);
        else
            _strand.post(disconnect_handler);
    }
    else
    {
        if (dispatch)
            _io_service->dispatch(disconnect_handler);
        else
            _io_service->post(disconnect_handler);
    }

    return true;
}

size_t TCPSession::Send(const void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Send data to the client
    size_t sent = asio::write(_socket, asio::buffer(buffer, size), ec);
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;
        _server->_bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return sent;
}

size_t TCPSession::Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async write some data to the client
    size_t sent = 0;
    _socket.async_write_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send data to the client
    if (sent > 0)
    {
        // Update statistic
        _bytes_sent += sent;
        _server->_bytes_sent += sent;

        // Call the buffer sent handler
        onSent(sent, bytes_pending());
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return sent;
}

bool TCPSession::SendAsync(const void* buffer, size_t size)
{
    if (!IsConnected())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    {
        std::scoped_lock locker(_send_lock);

        // Detect multiple send handlers
        bool send_required = _send_buffer_main.empty() || _send_buffer_flush.empty();

        // Check the send buffer limit
        if (((_send_buffer_main.size() + size) > _send_buffer_limit) && (_send_buffer_limit > 0))
        {
            SendError(asio::error::no_buffer_space);
            return false;
        }

        // Fill the main send buffer
        const uint8_t* bytes = (const uint8_t*)buffer;
        _send_buffer_main.insert(_send_buffer_main.end(), bytes, bytes + size);

        // Update statistic
        _bytes_pending = _send_buffer_main.size();

        // Avoid multiple send handlers
        if (!send_required)
            return true;
    }

    // Dispatch the send handler
    auto self(this->shared_from_this());
    auto send_handler = [this, self]()
    {
        // Try to send the main buffer
        TrySend();
    };
    if (_strand_required)
        _strand.dispatch(send_handler);
    else
        _io_service->dispatch(send_handler);

    return true;
}

size_t TCPSession::Receive(void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive data from the client
    size_t received = _socket.read_some(asio::buffer(buffer, size), ec);
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;
        _server->_bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return received;
}

std::string TCPSession::Receive(size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size()));
    return text;
}

size_t TCPSession::Receive(void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async read some data from the client
    size_t received = 0;
    _socket.async_read_some(asio::buffer(buffer, size), [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Received some data from the client
    if (received > 0)
    {
        // Update statistic
        _bytes_received += received;
        _server->_bytes_received += received;

        // Call the buffer received handler
        onReceived(buffer, received);
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return received;
}

std::string TCPSession::Receive(size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(text.data(), text.size(), timeout));
    return text;
}

void TCPSession::ReceiveAsync()
{
    // Try to receive data from the client
    TryReceive();
}

void TCPSession::TryReceive()
{
    if (_receiving)
        return;

    if (!IsConnected())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsConnected())
            return;

        // Received some data from the client
        if (size > 0)
        {
            // Update statistic
            _bytes_received += size;
            _server->_bytes_received += size;

            // Call the buffer received handler
            onReceived(_receive_buffer.data(), size);

            // If the receive buffer is full increase its size
            if (_receive_buffer.size() == size)
            {
                // Check the receive buffer limit
                if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
                {
                    SendError(asio::error::no_buffer_space);
                    Disconnect(true);
                    return;
                }

                _receive_buffer.resize(2 * size);
            }
        }

        // Try to receive again if the session is valid
        if (!ec)
            TryReceive();
        else
        {
            SendError(ec);
            Disconnect(true);
        }
    });
    if (_strand_required)
        _socket.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), bind_executor(_strand, async_receive_handler));
    else
        _socket.async_read_some(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), async_receive_handler);
}

void TCPSession::TrySend()
{
    if (_sending)
        return;

    if (!IsConnected())
        return;

    // Swap send buffers
    if (_send_buffer_flush.empty())
    {
        std::scoped_lock locker(_send_lock);

        // Swap flush and main buffers
        _send_buffer_flush.swap(_send_buffer_main);
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending += _send_buffer_flush.size();
    }

    // Check if the flush buffer is empty
    if (_send_buffer_flush.empty())
    {
        // Call the empty send buffer handler
        onEmpty();
        return;
    }

    // Async write with the write handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_write_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t size)
    {
        _sending = false;

        if (!IsConnected())
            return;

        // Send some data to the client
        if (size > 0)
        {
            // Update statistic
            _bytes_sending -= size;
            _bytes_sent += size;
            _server->_bytes_sent += size;

            // Increase the flush buffer offset
            _send_buffer_flush_offset += size;

            // Successfully send the whole flush buffer
            if (_send_buffer_flush_offset == _send_buffer_flush.size())
            {
                // Clear the flush buffer
                _send_buffer_flush.clear();
                _send_buffer_flush_offset = 0;
            }

            // Call the buffer sent handler
            onSent(size, bytes_pending());
        }

        // Try to send again if the session is valid
        if (!ec)
            TrySend();
        else
        {
            SendError(ec);
            Disconnect(true);
        }
    });
    if (_strand_required)
        _socket.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), bind_executor(_strand, async_write_handler));
    else
        _socket.async_write_some(asio::buffer(_send_buffer_flush.data() + _send_buffer_flush_offset, _send_buffer_flush.size() - _send_buffer_flush_offset), async_write_handler);
}

void TCPSession::ClearBuffers()
{
    {
        std::scoped_lock locker(_send_lock);

        // Clear send buffers
        _send_buffer_main.clear();
        _send_buffer_flush.clear();
        _send_buffer_flush_offset = 0;

        // Update statistic
        _bytes_pending = 0;
        _bytes_sending = 0;
    }
}

void TCPSession::ResetServer()
{
    // Reset cycle-reference to the server
    _server.reset();
}

void TCPSession::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/timer.cpp`:

```cpp
/*!
    \file timer.cpp
    \brief Timer implementation
    \author Ivan Shynkarenka
    \date 16.08.2018
    \copyright MIT License
*/

#include "server/asio/timer.h"

namespace CppServer {
namespace Asio {

Timer::Timer(const std::shared_ptr<Service>& service)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

Timer::Timer(const std::shared_ptr<Service>& service, const CppCommon::UtcTime& time)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service, time.chrono())
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

Timer::Timer(const std::shared_ptr<Service>& service, const CppCommon::Timespan& timespan)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service, timespan.chrono())
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

Timer::Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service),
    _action(action)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
    assert((action) && "Action function is invalid!");
    if (!action)
        throw CppCommon::ArgumentException("Action function is invalid!");
}

Timer::Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action, const CppCommon::UtcTime& time)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service, time.chrono()),
    _action(action)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
    assert((action) && "Action function is invalid!");
    if (!action)
        throw CppCommon::ArgumentException("Action function is invalid!");
}

Timer::Timer(const std::shared_ptr<Service>& service, const std::function<void(bool)>& action, const CppCommon::Timespan& timespan)
    : _service(service),
    _io_service(_service->GetAsioService()),
    _strand(*_io_service),
    _strand_required(_service->IsStrandRequired()),
    _timer(*_io_service, timespan.chrono()),
    _action(action)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
    assert((action) && "Action function is invalid!");
    if (!action)
        throw CppCommon::ArgumentException("Action function is invalid!");
}

CppCommon::UtcTime Timer::expire_time() const
{
    return CppCommon::UtcTime(_timer.expires_at());
}

CppCommon::Timespan Timer::expire_timespan() const
{
    return CppCommon::Timespan(_timer.expires_from_now());
}

bool Timer::Setup(const CppCommon::UtcTime& time)
{
    asio::error_code ec;
    _timer.expires_at(time.chrono(), ec);

    // Check for error
    if (ec)
    {
        SendError(ec);
        return false;
    }

    return true;
}

bool Timer::Setup(const CppCommon::Timespan& timespan)
{
    asio::error_code ec;
    _timer.expires_from_now(timespan.chrono(), ec);

    // Check for error
    if (ec)
    {
        SendError(ec);
        return false;
    }

    return true;
}

bool Timer::Setup(const std::function<void(bool)>& action)
{
    assert((action) && "Action function is invalid!");
    if (!action)
        return false;

    _action = action;
    return true;
}

bool Timer::Setup(const std::function<void(bool)>& action, const CppCommon::UtcTime& time)
{
    assert((action) && "Action function is invalid!");
    if (!action)
        return false;

    _action = action;
    return Setup(time);
}

bool Timer::Setup(const std::function<void(bool)>& action, const CppCommon::Timespan& timespan)
{
    assert((action) && "Action function is invalid!");
    if (!action)
        return false;

    _action = action;
    return Setup(timespan);
}

bool Timer::WaitAsync()
{
    auto self(this->shared_from_this());
    auto async_wait_handler = [this, self](const std::error_code& ec)
    {
        // Call the timer aborted handler
        if (ec == asio::error::operation_aborted)
            SendTimer(true);

        // Check for error
        if (ec)
        {
            SendError(ec);
            return;
        }

        // Call the timer expired handler
        SendTimer(false);
    };
    if (_strand_required)
        _timer.async_wait(bind_executor(_strand, async_wait_handler));
    else
        _timer.async_wait(async_wait_handler);

    return true;
}

bool Timer::WaitSync()
{
    asio::error_code ec;
    _timer.wait(ec);

    // Call the timer aborted handler
    if (ec == asio::error::operation_aborted)
        SendTimer(true);

    // Check for error
    if (ec)
    {
        SendError(ec);
        return false;
    }

    // Call the timer expired handler
    SendTimer(false);

    return true;
}

bool Timer::Cancel()
{
    asio::error_code ec;
    _timer.cancel(ec);

    // Check for error
    if (ec)
    {
        SendError(ec);
        return false;
    }

    return true;
}

void Timer::SendError(std::error_code ec)
{
    // Skip Asio abort error
    if (ec == asio::error::operation_aborted)
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

void Timer::SendTimer(bool canceled)
{
    // Call the timer handler
    onTimer(canceled);

    // Call the timer action
    if (_action)
        _action(canceled);
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/udp_client.cpp`:

```cpp
/*!
    \file udp_client.cpp
    \brief UDP client implementation
    \author Ivan Shynkarenka
    \date 23.12.2016
    \copyright MIT License
*/

#include "server/asio/udp_client.h"

namespace CppServer {
namespace Asio {

UDPClient::UDPClient(const std::shared_ptr<Service>& service, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _socket(*_io_service),
      _resolving(false),
      _connected(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false),
      _option_reuse_address(false),
      _option_reuse_port(false),
      _option_multicast(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

UDPClient::UDPClient(const std::shared_ptr<Service>& service, const std::string& address, const std::string& scheme)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _scheme(scheme),
      _port(0),
      _socket(*_io_service),
      _resolving(false),
      _connected(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false),
      _option_reuse_address(false),
      _option_reuse_port(false),
      _option_multicast(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

UDPClient::UDPClient(const std::shared_ptr<Service>& service, const asio::ip::udp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _endpoint(endpoint),
      _socket(*_io_service),
      _resolving(false),
      _connected(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false),
      _option_reuse_address(false),
      _option_reuse_port(false),
      _option_multicast(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

size_t UDPClient::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

size_t UDPClient::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

void UDPClient::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    _socket.set_option(option);
}

void UDPClient::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    _socket.set_option(option);
}

bool UDPClient::Connect()
{
    assert(!_address.empty() && "Server address must not be empty!");
    if (_address.empty())
        return false;
    assert((_port > 0) && "Server port number must be valid!");
    if (_port <= 0)
        return false;

    if (IsConnected())
        return false;

    // Create the server endpoint
    _endpoint = asio::ip::udp::endpoint(asio::ip::make_address(_address), (unsigned short)_port);

    // Open a client socket
    _socket.open(_endpoint.protocol());
    if (option_reuse_address())
        _socket.set_option(asio::ip::udp::socket::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
    if (option_reuse_port())
    {
        typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
        _socket.set_option(reuse_port(true));
    }
#endif
    if (option_multicast())
        _socket.bind(_endpoint);
    else
        _socket.bind(asio::ip::udp::endpoint(_endpoint.protocol(), 0));

    // Prepare receive buffer
    _receive_buffer.resize(option_receive_buffer_size());

    // Reset statistic
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;
    _datagrams_sent = 0;
    _datagrams_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    return true;
}

bool UDPClient::Connect(const std::shared_ptr<UDPResolver>& resolver)
{
    assert((resolver != nullptr) && "UDP resolver is invalid!");
    if (resolver == nullptr)
        return false;
    assert(!_address.empty() && "Server address must not be empty!");
    if (_address.empty())
        return false;
    assert((_port > 0) && "Server port number must be valid!");
    if (_port <= 0)
        return false;

    if (IsConnected())
        return false;

    std::error_code ec;

    // Resolve the server endpoint
    asio::ip::udp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
    auto endpoints = resolver->resolver().resolve(query, ec);

    // Check for resolve errors
    if (ec)
    {
        SendError(ec);

        // Call the client disconnected handler
        onDisconnected();

        return false;
    }

    _endpoint = *endpoints;

    // Open a client socket
    _socket.open(_endpoint.protocol());
    if (option_reuse_address())
        _socket.set_option(asio::ip::udp::socket::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
    if (option_reuse_port())
    {
        typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
        _socket.set_option(reuse_port(true));
    }
#endif
    if (option_multicast())
        _socket.bind(_endpoint);
    else
        _socket.bind(asio::ip::udp::endpoint(_endpoint.protocol(), 0));

    // Prepare receive buffer
    _receive_buffer.resize(option_receive_buffer_size());

    // Reset statistic
    _bytes_sending = 0;
    _bytes_sent = 0;
    _bytes_received = 0;
    _datagrams_sent = 0;
    _datagrams_received = 0;

    // Update the connected flag
    _connected = true;

    // Call the client connected handler
    onConnected();

    return true;
}

bool UDPClient::DisconnectInternal()
{
    if (!IsConnected())
        return false;

    // Close the client socket
    _socket.close();

    // Update the connected flag
    _resolving = false;
    _connected = false;

    // Update sending/receiving flags
    _receiving = false;
    _sending = false;

    // Clear send/receive buffers
    ClearBuffers();

    // Call the client disconnected handler
    onDisconnected();

    return true;
}

bool UDPClient::Reconnect()
{
    if (!Disconnect())
        return false;

    return Connect();
}

bool UDPClient::ConnectAsync()
{
    if (IsConnected())
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = [this, self]() { Connect(); };
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool UDPClient::ConnectAsync(const std::shared_ptr<UDPResolver>& resolver)
{
    assert((resolver != nullptr) && "UDP resolver is invalid!");
    if (resolver == nullptr)
        return false;

    if (IsConnected() || _resolving)
        return false;

    // Post the connect handler
    auto self(this->shared_from_this());
    auto connect_handler = [this, self, resolver]()
    {
        if (IsConnected() || _resolving)
            return;

        // Async DNS resolve with the resolve handler
        _resolving = true;
        auto async_resolve_handler = [this, self](std::error_code ec, asio::ip::udp::resolver::results_type endpoints)
        {
            _resolving = false;

            if (IsConnected() || _resolving)
                return;

            if (!ec)
            {
                // Resolve the server endpoint
                _endpoint = *endpoints;

                // Open a client socket
                _socket.open(_endpoint.protocol());
                if (option_reuse_address())
                    _socket.set_option(asio::ip::udp::socket::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
                if (option_reuse_port())
                {
                    typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
                    _socket.set_option(reuse_port(true));
                }
#endif
                if (option_multicast())
                    _socket.bind(_endpoint);
                else
                    _socket.bind(asio::ip::udp::endpoint(_endpoint.protocol(), 0));

                // Prepare receive buffer
                _receive_buffer.resize(option_receive_buffer_size());

                // Reset statistic
                _bytes_sending = 0;
                _bytes_sent = 0;
                _bytes_received = 0;
                _datagrams_sent = 0;
                _datagrams_received = 0;

                // Update the connected flag
                _connected = true;

                // Call the client connected handler
                onConnected();
            }
            else
            {
                SendError(ec);

                // Call the client disconnected handler
                onDisconnected();
            }
        };

        // Resolve the server endpoint
        asio::ip::udp::resolver::query query(_address, (_scheme.empty() ? std::to_string(_port) : _scheme));
        if (_strand_required)
            resolver->resolver().async_resolve(query, bind_executor(_strand, async_resolve_handler));
        else
            resolver->resolver().async_resolve(query, async_resolve_handler);
    };
    if (_strand_required)
        _strand.post(connect_handler);
    else
        _io_service->post(connect_handler);

    return true;
}

bool UDPClient::DisconnectInternalAsync(bool dispatch)
{
    if (!IsConnected())
        return false;

    asio::error_code ec;

    // Cancel the client socket
    _socket.cancel(ec);

    // Dispatch or post the disconnect handler
    auto self(this->shared_from_this());
    auto disconnect_handler = [this, self]() { DisconnectInternal(); };
    if (_strand_required)
    {
        if (dispatch)
            _strand.dispatch(disconnect_handler);
        else
            _strand.post(disconnect_handler);
    }
    else
    {
        if (dispatch)
            _io_service->dispatch(disconnect_handler);
        else
            _io_service->post(disconnect_handler);
    }

    return true;
}

bool UDPClient::ReconnectAsync()
{
    if (!DisconnectAsync())
        return false;

    while (IsConnected())
        CppCommon::Thread::Yield();

    return ConnectAsync();
}

void UDPClient::JoinMulticastGroup(const std::string& address)
{
    if (!IsConnected())
        return;

    asio::ip::address muticast_address = asio::ip::make_address(address);

    asio::ip::multicast::join_group join(muticast_address);
    _socket.set_option(join);

    // Call the client joined multicast group notification
    onJoinedMulticastGroup(address);
}

void UDPClient::LeaveMulticastGroup(const std::string& address)
{
    if (!IsConnected())
        return;

    asio::ip::address muticast_address = asio::ip::make_address(address);

    asio::ip::multicast::leave_group leave(muticast_address);
    _socket.set_option(leave);

    // Call the client left multicast group notification
    onLeftMulticastGroup(address);
}

void UDPClient::JoinMulticastGroupAsync(const std::string& address)
{
    if (!IsConnected())
        return;

    // Dispatch the join multicast group handler
    auto self(this->shared_from_this());
    auto join_multicast_group_handler = [this, self, address]() { JoinMulticastGroup(address); };
    if (_strand_required)
        _strand.dispatch(join_multicast_group_handler);
    else
        _io_service->dispatch(join_multicast_group_handler);
}

void UDPClient::LeaveMulticastGroupAsync(const std::string& address)
{
    if (!IsConnected())
        return;

    // Dispatch the leave multicast group handler
    auto self(this->shared_from_this());
    auto leave_multicast_group_handler = [this, self, address]() { LeaveMulticastGroup(address); };
    if (_strand_required)
        _strand.dispatch(leave_multicast_group_handler);
    else
        _io_service->dispatch(leave_multicast_group_handler);
}

size_t UDPClient::Send(const void* buffer, size_t size)
{
    // Send the datagram to the server endpoint
    return Send(_endpoint, buffer, size);
}

size_t UDPClient::Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Sent datagram to the server
    size_t sent = _socket.send_to(asio::const_buffer(buffer, size), endpoint, 0, ec);
    if (sent > 0)
    {
        // Update statistic
        ++_datagrams_sent;
        _bytes_sent += sent;

        // Call the datagram sent handler
        onSent(endpoint, sent);
    }

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return sent;
}

size_t UDPClient::Send(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    // Send the datagram to the server endpoint
    return Send(_endpoint, buffer, size, timeout);
}

size_t UDPClient::Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async send datagram to the server
    size_t sent = 0;
    _socket.async_send_to(asio::buffer(buffer, size), endpoint, [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send datagram to the server
    if (sent > 0)
    {
        // Update statistic
        ++_datagrams_sent;
        _bytes_sent += sent;

        // Call the datagram sent handler
        onSent(endpoint, sent);
    }

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return sent;
}

bool UDPClient::SendAsync(const void* buffer, size_t size)
{
    // Send the datagram to the server endpoint
    return SendAsync(_endpoint, buffer, size);
}

bool UDPClient::SendAsync(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size)
{
    if (_sending)
        return false;

    if (!IsConnected())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    // Check the send buffer limit
    if ((size > _send_buffer_limit) && (_send_buffer_limit > 0))
    {
        SendError(asio::error::no_buffer_space);
        return false;
    }

    // Fill the main send buffer
    const uint8_t* bytes = (const uint8_t*)buffer;
    _send_buffer.assign(bytes, bytes + size);

    // Update statistic
    _bytes_sending = _send_buffer.size();

    // Update send endpoint
    _send_endpoint = endpoint;

    // Async send-to with the send-to handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_send_to_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t sent)
    {
        _sending = false;

        if (!IsConnected())
            return;

        // Disconnect on error
        if (ec)
        {
            SendError(ec);
            DisconnectInternalAsync(true);
            return;
        }

        // Send some data to the server
        if (sent > 0)
        {
            // Update statistic
            _bytes_sending = 0;
            _bytes_sent += sent;

            // Clear the send buffer
            _send_buffer.clear();

            // Call the buffer sent handler
            onSent(_send_endpoint, sent);
        }
    });
    if (_strand_required)
        _socket.async_send_to(asio::buffer(_send_buffer.data(), _send_buffer.size()), _send_endpoint, bind_executor(_strand, async_send_to_handler));
    else
        _socket.async_send_to(asio::buffer(_send_buffer.data(), _send_buffer.size()), _send_endpoint, async_send_to_handler);

    return true;
}

size_t UDPClient::Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive datagram from the server
    size_t received = _socket.receive_from(asio::buffer(buffer, size), endpoint, 0, ec);

    // Update statistic
    ++_datagrams_received;
    _bytes_received += received;

    // Call the datagram received handler
    onReceived(endpoint, buffer, received);

    // Disconnect on error
    if (ec)
    {
        SendError(ec);
        Disconnect();
    }

    return received;
}

std::string UDPClient::Receive(asio::ip::udp::endpoint& endpoint, size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(endpoint, text.data(), text.size()));
    return text;
}

size_t UDPClient::Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsConnected())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async receive datagram from the server
    size_t received = 0;
    _socket.async_receive_from(asio::buffer(buffer, size), endpoint, [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Update statistic
    ++_datagrams_received;
    _bytes_received += received;

    // Call the datagram received handler
    onReceived(endpoint, buffer, received);

    // Disconnect on error
    if (error && (error != asio::error::timed_out))
    {
        SendError(error);
        Disconnect();
    }

    return received;
}

std::string UDPClient::Receive(asio::ip::udp::endpoint& endpoint, size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(endpoint, text.data(), text.size(), timeout));
    return text;
}

void UDPClient::ReceiveAsync()
{
    // Try to receive datagrams from the server
    TryReceive();
}

void UDPClient::TryReceive()
{
    if (_receiving)
        return;

    if (!IsConnected())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsConnected())
            return;

        // Disconnect on error
        if (ec)
        {
            SendError(ec);
            DisconnectInternalAsync(true);
            return;
        }

        // Update statistic
        ++_datagrams_received;
        _bytes_received += size;

        // Call the datagram received handler
        onReceived(_receive_endpoint, _receive_buffer.data(), size);

        // If the receive buffer is full increase its size
        if (_receive_buffer.size() == size)
        {
            // Check the receive buffer limit
            if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
            {
                SendError(asio::error::no_buffer_space);
                DisconnectInternalAsync(true);
                return;
            }

            _receive_buffer.resize(2 * size);
        }
    });
    if (_strand_required)
        _socket.async_receive_from(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), _receive_endpoint, bind_executor(_strand, async_receive_handler));
    else
        _socket.async_receive_from(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), _receive_endpoint, async_receive_handler);
}

void UDPClient::ClearBuffers()
{
    // Clear send buffers
    _send_buffer.clear();

    // Update statistic
    _bytes_sending = 0;
}

void UDPClient::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/udp_resolver.cpp`:

```cpp
/*!
    \file udp_resolver.cpp
    \brief UDP resolver implementation
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#include "server/asio/udp_resolver.h"

namespace CppServer {
namespace Asio {

UDPResolver::UDPResolver(const std::shared_ptr<Service>& service)
    : _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _resolver(*_io_service)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

} // namespace Asio
} // namespace CppServer

```

`source/server/asio/udp_server.cpp`:

```cpp
/*!
    \file udp_server.cpp
    \brief UDP server implementation
    \author Ivan Shynkarenka
    \date 22.12.2016
    \copyright MIT License
*/

#include "server/asio/udp_server.h"

namespace CppServer {
namespace Asio {

UDPServer::UDPServer(const std::shared_ptr<Service>& service, int port, InternetProtocol protocol)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _port(port),
      _socket(*_io_service),
      _started(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    // Prepare endpoint
    switch (protocol)
    {
        case InternetProtocol::IPv4:
            _endpoint = asio::ip::udp::endpoint(asio::ip::udp::v4(), (unsigned short)port);
            break;
        case InternetProtocol::IPv6:
            _endpoint = asio::ip::udp::endpoint(asio::ip::udp::v6(), (unsigned short)port);
            break;
    }
}

UDPServer::UDPServer(const std::shared_ptr<Service>& service, const std::string& address, int port)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(address),
      _port(port),
      _socket(*_io_service),
      _started(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false),
      _option_reuse_address(false),
      _option_reuse_port(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");

    // Prepare endpoint
    _endpoint = asio::ip::udp::endpoint(asio::ip::make_address(address), (unsigned short)port);
}

UDPServer::UDPServer(const std::shared_ptr<Service>& service, const asio::ip::udp::endpoint& endpoint)
    : _id(CppCommon::UUID::Sequential()),
      _service(service),
      _io_service(_service->GetAsioService()),
      _strand(*_io_service),
      _strand_required(_service->IsStrandRequired()),
      _address(endpoint.address().to_string()),
      _port(endpoint.port()),
      _endpoint(endpoint),
      _socket(*_io_service),
      _started(false),
      _bytes_sending(0),
      _bytes_sent(0),
      _bytes_received(0),
      _datagrams_sent(0),
      _datagrams_received(0),
      _receiving(false),
      _sending(false)
{
    assert((service != nullptr) && "Asio service is invalid!");
    if (service == nullptr)
        throw CppCommon::ArgumentException("Asio service is invalid!");
}

size_t UDPServer::option_receive_buffer_size() const
{
    asio::socket_base::receive_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

size_t UDPServer::option_send_buffer_size() const
{
    asio::socket_base::send_buffer_size option;
    _socket.get_option(option);
    return option.value();
}

void UDPServer::SetupReceiveBufferSize(size_t size)
{
    asio::socket_base::receive_buffer_size option((int)size);
    _socket.set_option(option);
}

void UDPServer::SetupSendBufferSize(size_t size)
{
    asio::socket_base::send_buffer_size option((int)size);
    _socket.set_option(option);
}

bool UDPServer::Start()
{
    assert(!IsStarted() && "UDP server is already started!");
    if (IsStarted())
        return false;

    // Post the start handler
    auto self(this->shared_from_this());
    auto start_handler = [this, self]()
    {
        if (IsStarted())
            return;

        // Open a server socket
        _socket.open(_endpoint.protocol());
        if (option_reuse_address())
            _socket.set_option(asio::ip::udp::socket::reuse_address(true));
#if (defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)) && !defined(__CYGWIN__)
        if (option_reuse_port())
        {
            typedef asio::detail::socket_option::boolean<SOL_SOCKET, SO_REUSEPORT> reuse_port;
            _socket.set_option(reuse_port(true));
        }
#endif
        _socket.bind(_endpoint);

        // Prepare receive buffer
        _receive_buffer.resize(option_receive_buffer_size());

        // Reset statistic
        _bytes_sending = 0;
        _bytes_sent = 0;
        _bytes_received = 0;
        _datagrams_sent = 0;
        _datagrams_received = 0;

         // Update the started flag
        _started = true;

        // Call the server started handler
        onStarted();
    };
    if (_strand_required)
        _strand.post(start_handler);
    else
        _io_service->post(start_handler);

    return true;
}

bool UDPServer::Start(const std::string& multicast_address, int multicast_port)
{
    _multicast_endpoint = asio::ip::udp::endpoint(asio::ip::make_address(multicast_address), (unsigned short)multicast_port);
    return Start();
}

bool UDPServer::Start(const asio::ip::udp::endpoint& multicast_endpoint)
{
    _multicast_endpoint = multicast_endpoint;
    return Start();
}

bool UDPServer::Stop()
{
    assert(IsStarted() && "UDP server is not started!");
    if (!IsStarted())
        return false;

    // Post the stop handler
    auto self(this->shared_from_this());
    auto stop_handler = [this, self]()
    {
        if (!IsStarted())
            return;

        // Close the server socket
        _socket.close();

        // Update the started flag
        _started = false;

        // Update sending/receiving flags
        _receiving = false;
        _sending = false;

        // Clear send/receive buffers
        ClearBuffers();

        // Call the server stopped handler
        onStopped();
    };
    if (_strand_required)
        _strand.post(stop_handler);
    else
        _io_service->post(stop_handler);

    return true;
}

bool UDPServer::Restart()
{
    if (!Stop())
        return false;

    while (IsStarted())
        CppCommon::Thread::Yield();

    return Start();
}

size_t UDPServer::Multicast(const void* buffer, size_t size)
{
    // Send the datagram to the multicast endpoint
    return Send(_multicast_endpoint, buffer, size);
}

size_t UDPServer::Multicast(const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    // Send the datagram to the multicast endpoint
    return Send(_multicast_endpoint, buffer, size, timeout);
}

bool UDPServer::MulticastAsync(const void* buffer, size_t size)
{
    // Send the datagram to the multicast endpoint
    return SendAsync(_multicast_endpoint, buffer, size);
}

size_t UDPServer::Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size)
{
    if (!IsStarted())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Sent datagram to the client
    size_t sent = _socket.send_to(asio::const_buffer(buffer, size), endpoint, 0, ec);
    if (sent > 0)
    {
        // Update statistic
        ++_datagrams_sent;
        _bytes_sent += sent;

        // Call the datagram sent handler
        onSent(endpoint, sent);
    }

    // Check for error
    if (ec)
        SendError(ec);

    return sent;
}

size_t UDPServer::Send(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsStarted())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async send datagram to the client
    size_t sent = 0;
    _socket.async_send_to(asio::buffer(buffer, size), endpoint, [&](std::error_code ec, size_t write) { async_done_handler(ec); sent = write; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Send datagram to the client
    if (sent > 0)
    {
        // Update statistic
        ++_datagrams_sent;
        _bytes_sent += sent;

        // Call the datagram sent handler
        onSent(endpoint, sent);
    }

    // Check for error
    if (error && (error != asio::error::timed_out))
        SendError(error);

    return sent;
}

bool UDPServer::SendAsync(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size)
{
    if (_sending)
        return false;

    if (!IsStarted())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    // Check the send buffer limit
    if ((size > _send_buffer_limit) && (_send_buffer_limit > 0))
    {
        SendError(asio::error::no_buffer_space);

        // Call the buffer sent zero handler
        onSent(_send_endpoint,  0);

        return false;
    }

    // Fill the main send buffer
    const uint8_t* bytes = (const uint8_t*)buffer;
    _send_buffer.assign(bytes, bytes + size);

    // Update statistic
    _bytes_sending = _send_buffer.size();

    // Update send endpoint
    _send_endpoint = endpoint;

    // Async send-to with the send-to handler
    _sending = true;
    auto self(this->shared_from_this());
    auto async_send_to_handler = make_alloc_handler(_send_storage, [this, self](std::error_code ec, size_t sent)
    {
        _sending = false;

        if (!IsStarted())
            return;

        // Check for error
        if (ec)
        {
            SendError(ec);

            // Call the buffer sent zero handler
            onSent(_send_endpoint, 0);

            return;
        }

        // Send some data to the client
        if (sent > 0)
        {
            // Update statistic
            _bytes_sending = 0;
            _bytes_sent += sent;

            // Clear the send buffer
            _send_buffer.clear();

            // Call the buffer sent handler
            onSent(_send_endpoint, sent);
        }
    });
    if (_strand_required)
        _socket.async_send_to(asio::buffer(_send_buffer.data(), _send_buffer.size()), _send_endpoint, bind_executor(_strand, async_send_to_handler));
    else
        _socket.async_send_to(asio::buffer(_send_buffer.data(), _send_buffer.size()), _send_endpoint, async_send_to_handler);

    return true;
}

size_t UDPServer::Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size)
{
    if (!IsStarted())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    asio::error_code ec;

    // Receive datagram from the client
    size_t received = _socket.receive_from(asio::buffer(buffer, size), endpoint, 0, ec);

    // Update statistic
    ++_datagrams_received;
    _bytes_received += received;

    // Call the datagram received handler
    onReceived(endpoint, buffer, received);

    // Check for error
    if (ec)
        SendError(ec);

    return received;
}

std::string UDPServer::Receive(asio::ip::udp::endpoint& endpoint, size_t size)
{
    std::string text(size, 0);
    text.resize(Receive(endpoint, text.data(), text.size()));
    return text;
}

size_t UDPServer::Receive(asio::ip::udp::endpoint& endpoint, void* buffer, size_t size, const CppCommon::Timespan& timeout)
{
    if (!IsStarted())
        return 0;

    if (size == 0)
        return 0;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return 0;

    int done = 0;
    std::mutex mtx;
    std::condition_variable cv;
    asio::error_code error;
    asio::system_timer timer(_socket.get_executor());

    // Prepare done handler
    auto async_done_handler = [&](asio::error_code ec)
    {
        std::unique_lock<std::mutex> lck(mtx);
        if (done++ == 0)
        {
            error = ec;
            _socket.cancel();
            timer.cancel();
        }
        cv.notify_one();
    };

    // Async wait for timeout
    timer.expires_from_now(timeout.chrono());
    timer.async_wait([&](const asio::error_code& ec) { async_done_handler(ec ? ec : asio::error::timed_out); });

    // Async receive datagram from the client
    size_t received = 0;
    _socket.async_receive_from(asio::buffer(buffer, size), endpoint, [&](std::error_code ec, size_t read) { async_done_handler(ec); received = read; });

    // Wait for complete or timeout
    std::unique_lock<std::mutex> lck(mtx);
    cv.wait(lck, [&]() { return done == 2; });

    // Update statistic
    ++_datagrams_received;
    _bytes_received += received;

    // Call the datagram received handler
    onReceived(endpoint, buffer, received);

    // Check for error
    if (error && (error != asio::error::timed_out))
        SendError(error);

    return received;
}

std::string UDPServer::Receive(asio::ip::udp::endpoint& endpoint, size_t size, const CppCommon::Timespan& timeout)
{
    std::string text(size, 0);
    text.resize(Receive(endpoint, text.data(), text.size(), timeout));
    return text;
}

void UDPServer::ReceiveAsync()
{
    // Try to receive datagrams from clients
    TryReceive();
}

void UDPServer::TryReceive()
{
    if (_receiving)
        return;

    if (!IsStarted())
        return;

    // Async receive with the receive handler
    _receiving = true;
    auto self(this->shared_from_this());
    auto async_receive_handler = make_alloc_handler(_receive_storage, [this, self](std::error_code ec, size_t size)
    {
        _receiving = false;

        if (!IsStarted())
            return;

        // Check for error
        if (ec)
        {
            SendError(ec);

            // Call the datagram received zero handler
            onReceived(_receive_endpoint, _receive_buffer.data(), 0);

            return;
        }

        // Update statistic
        ++_datagrams_received;
        _bytes_received += size;

        // Call the datagram received handler
        onReceived(_receive_endpoint, _receive_buffer.data(), size);

        // If the receive buffer is full increase its size
        if (_receive_buffer.size() == size)
        {
            // Check the receive buffer limit
            if (((2 * size) > _receive_buffer_limit) && (_receive_buffer_limit > 0))
            {
                SendError(asio::error::no_buffer_space);

                // Call the datagram received zero handler
                onReceived(_receive_endpoint, _receive_buffer.data(), 0);

                return;
            }

            _receive_buffer.resize(2 * size);
        }
    });
    if (_strand_required)
        _socket.async_receive_from(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), _receive_endpoint, bind_executor(_strand, async_receive_handler));
    else
        _socket.async_receive_from(asio::buffer(_receive_buffer.data(), _receive_buffer.size()), _receive_endpoint, async_receive_handler);
}

void UDPServer::ClearBuffers()
{
    // Clear send buffers
    _send_buffer.clear();

    // Update statistic
    _bytes_sending = 0;
}

void UDPServer::SendError(std::error_code ec)
{
    // Skip Asio disconnect errors
    if ((ec == asio::error::connection_aborted) ||
        (ec == asio::error::connection_refused) ||
        (ec == asio::error::connection_reset) ||
        (ec == asio::error::eof) ||
        (ec == asio::error::operation_aborted))
        return;

    onError(ec.value(), ec.category().name(), ec.message());
}

} // namespace Asio
} // namespace CppServer

```

`source/server/http/http_client.cpp`:

```cpp
/*!
    \file http_client.cpp
    \brief HTTP client implementation
    \author Ivan Shynkarenka
    \date 08.02.2019
    \copyright MIT License
*/

#include "server/http/http_client.h"

namespace CppServer {
namespace HTTP {

void HTTPClient::onReceived(const void* buffer, size_t size)
{
    // Receive HTTP response header
    if (_response.IsPendingHeader())
    {
        if (_response.ReceiveHeader(buffer, size))
            onReceivedResponseHeader(_response);

        size = 0;
    }

    // Check for HTTP response error
    if (_response.error())
    {
        onReceivedResponseError(_response, "Invalid HTTP response!");
        _response.Clear();
        DisconnectAsync();
        return;
    }

    // Receive HTTP response body
    if (_response.ReceiveBody(buffer, size))
    {
        onReceivedResponse(_response);
        _response.Clear();
        return;
    }

    // Check for HTTP response error
    if (_response.error())
    {
        onReceivedResponseError(_response, "Invalid HTTP response!");
        _response.Clear();
        DisconnectAsync();
        return;
    }
}

void HTTPClient::onDisconnected()
{
    // Receive HTTP response body
    if (_response.IsPendingBody())
    {
        onReceivedResponse(_response);
        _response.Clear();
        return;
    }
}

std::future<HTTPResponse> HTTPClientEx::SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout)
{
    // Create TCP resolver if the current one is empty
    if (!_resolver)
        _resolver = std::make_shared<Asio::TCPResolver>(service());
    // Create timeout check timer if the current one is empty
    if (!_timeout)
        _timeout = std::make_shared<Asio::Timer>(service());

    _promise = std::promise<HTTPResponse>();
    _request = request;

    // Check if the HTTP request is valid
    if (_request.empty() || _request.error())
    {
        SetPromiseError("Invalid HTTP request!");
        return _promise.get_future();
    }

    if (!IsConnected())
    {
        // Connect to the Web server
        if (!ConnectAsync(_resolver))
        {
            SetPromiseError("Connection failed!");
            return _promise.get_future();
        }
    }
    else
    {
        // Send prepared HTTP request
        if (!SendRequestAsync())
        {
            SetPromiseError("Failed to send HTTP request!");
            return _promise.get_future();
        }
    }

    // Setup timeout check timer
    auto self(this->shared_from_this());
    auto timeout_handler = [this, self](bool canceled)
    {
        if (canceled)
            return;

        // Disconnect on timeout
        onReceivedResponseError(_response, "Timeout!");
        _response.Clear();
        DisconnectAsync();
    };
    if (!_timeout->Setup(timeout_handler, timeout) || !_timeout->WaitAsync())
    {
        SetPromiseError("Failed to setup timeout timer!");
        return _promise.get_future();
    }

    return _promise.get_future();
}

void HTTPClientEx::onConnected()
{
    HTTPClient::onConnected();

    // Send prepared HTTP request on connect
    if (!_request.empty() && !_request.error())
        if (!SendRequestAsync())
            SetPromiseError("Failed to send HTTP request!");
}

void HTTPClientEx::onDisconnected()
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    HTTPClient::onDisconnected();
}

void HTTPClientEx::onReceivedResponse(const HTTPResponse& response)
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    SetPromiseValue(response);
}

void HTTPClientEx::onReceivedResponseError(const HTTPResponse& response, const std::string& error)
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    SetPromiseError(error);
}

void HTTPClientEx::SetPromiseValue(const HTTPResponse& response)
{
    _promise.set_value(response);
    _request.Clear();
}

void HTTPClientEx::SetPromiseError(const std::string& error)
{
    _promise.set_exception(std::make_exception_ptr(std::runtime_error(error)));
    _request.Clear();
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/http_request.cpp`:

```cpp
/*!
    \file http_request.cpp
    \brief HTTP request implementation
    \author Ivan Shynkarenka
    \date 07.02.2019
    \copyright MIT License
*/

#include "server/http/http_request.h"

#include "string/string_utils.h"
#include "utility/countof.h"

#include <cassert>

namespace CppServer {
namespace HTTP {

std::tuple<std::string_view, std::string_view> HTTPRequest::header(size_t i) const noexcept
{
    assert((i < _headers.size()) && "Index out of bounds!");
    if (i >= _headers.size())
        return std::make_tuple(std::string_view(), std::string_view());

    auto item = _headers[i];

    return std::make_tuple(std::string_view(_cache.data() + std::get<0>(item), std::get<1>(item)), std::string_view(_cache.data() + std::get<2>(item), std::get<3>(item)));
}

std::tuple<std::string_view, std::string_view> HTTPRequest::cookie(size_t i) const noexcept
{
    assert((i < _cookies.size()) && "Index out of bounds!");
    if (i >= _cookies.size())
        return std::make_tuple(std::string_view(), std::string_view());

    auto item = _cookies[i];

    return std::make_tuple(std::string_view(_cache.data() + std::get<0>(item), std::get<1>(item)), std::string_view(_cache.data() + std::get<2>(item), std::get<3>(item)));
}

HTTPRequest& HTTPRequest::Clear()
{
    _error = false;
    _method_index = 0;
    _method_size = 0;
    _url_index = 0;
    _url_size = 0;
    _protocol_index = 0;
    _protocol_size = 0;
    _headers.clear();
    _cookies.clear();
    _body_index = 0;
    _body_size = 0;
    _body_length = 0;
    _body_length_provided = false;

    _cache.clear();
    _cache_size = 0;
    return *this;
}

HTTPRequest& HTTPRequest::SetBegin(std::string_view method, std::string_view url, std::string_view protocol)
{
    // Clear the HTTP request cache
    Clear();

    size_t index = 0;

    // Append the HTTP request method
    _cache.append(method);
    _method_index = index;
    _method_size = method.size();

    _cache.append(" ");
    index = _cache.size();

    // Append the HTTP request URL
    _cache.append(url);
    _url_index = index;
    _url_size = url.size();

    _cache.append(" ");
    index = _cache.size();

    // Append the HTTP request protocol version
    _cache.append(protocol);
    _protocol_index = index;
    _protocol_size = protocol.size();

    _cache.append("\r\n");
    return *this;
}

HTTPRequest& HTTPRequest::SetHeader(std::string_view key, std::string_view value)
{
    size_t index = _cache.size();

    // Append the HTTP request header's key
    _cache.append(key);
    size_t key_index = index;
    size_t key_size = key.size();

    _cache.append(": ");
    index = _cache.size();

    // Append the HTTP request header's value
    _cache.append(value);
    size_t value_index = index;
    size_t value_size = value.size();

    _cache.append("\r\n");

    // Add the header to the corresponding collection
    _headers.emplace_back(key_index, key_size, value_index, value_size);
    return *this;
}

HTTPRequest& HTTPRequest::SetCookie(std::string_view name, std::string_view value)
{
    size_t index = _cache.size();

    // Append the HTTP request header's key
    _cache.append("Cookie");
    size_t key_index = index;
    size_t key_size = 6;

    _cache.append(": ");
    index = _cache.size();

    // Append the HTTP request header's value
    size_t value_index = index;

    // Append Cookie
    index = _cache.size();
    _cache.append(name);
    size_t name_index = index;
    size_t name_size = name.size();
    _cache.append("=");
    index = _cache.size();
    _cache.append(value);
    size_t cookie_index = index;
    size_t cookie_size = value.size();

    size_t value_size = _cache.size() - value_index;

    _cache.append("\r\n");

    // Add the header to the corresponding collection
    _headers.emplace_back(key_index, key_size, value_index, value_size);
    // Add the cookie to the corresponding collection
    _cookies.emplace_back(name_index, name_size, cookie_index, cookie_size);
    return *this;
}

HTTPRequest& HTTPRequest::AddCookie(std::string_view name, std::string_view value)
{
    // Append Cookie
    _cache.append("; ");
    size_t index = _cache.size();
    _cache.append(name);
    size_t name_index = index;
    size_t name_size = name.size();
    _cache.append("=");
    index = _cache.size();
    _cache.append(value);
    size_t cookie_index = index;
    size_t cookie_size = value.size();

    // Add the cookie to the corresponding collection
    _cookies.emplace_back(name_index, name_size, cookie_index, cookie_size);
    return *this;
}

HTTPRequest& HTTPRequest::SetBody(std::string_view body)
{
    // Append content length header
    char buffer[32];
    SetHeader("Content-Length", FastConvert(body.size(), buffer, CppCommon::countof(buffer)));

    _cache.append("\r\n");

    size_t index = _cache.size();

    // Append the HTTP request body
    _cache.append(body);
    _body_index = index;
    _body_size = body.size();
    _body_length = body.size();
    _body_length_provided = true;
    return *this;
}

HTTPRequest& HTTPRequest::SetBodyLength(size_t length)
{
    // Append content length header
    char buffer[32];
    SetHeader("Content-Length", FastConvert(length, buffer, CppCommon::countof(buffer)));

    _cache.append("\r\n");

    size_t index = _cache.size();

    // Clear the HTTP request body
    _body_index = index;
    _body_size = 0;
    _body_length = length;
    _body_length_provided = true;
    return *this;
}

HTTPRequest& HTTPRequest::MakeHeadRequest(std::string_view url)
{
    Clear();
    SetBegin("HEAD", url);
    SetBody();
    return *this;
}

HTTPRequest& HTTPRequest::MakeGetRequest(std::string_view url)
{
    Clear();
    SetBegin("GET", url);
    SetBody();
    return *this;
}

HTTPRequest& HTTPRequest::MakePostRequest(std::string_view url, std::string_view content, std::string_view content_type)
{
    Clear();
    SetBegin("POST", url);
    if (!content_type.empty())
        SetHeader("Content-Type", content_type);
    SetBody(content);
    return *this;
}

HTTPRequest& HTTPRequest::MakePutRequest(std::string_view url, std::string_view content, std::string_view content_type)
{
    Clear();
    SetBegin("PUT", url);
    if (!content_type.empty())
        SetHeader("Content-Type", content_type);
    SetBody(content);
    return *this;
}

HTTPRequest& HTTPRequest::MakeDeleteRequest(std::string_view url)
{
    Clear();
    SetBegin("DELETE", url);
    SetBody();
    return *this;
}

HTTPRequest& HTTPRequest::MakeOptionsRequest(std::string_view url)
{
    Clear();
    SetBegin("OPTIONS", url);
    SetBody();
    return *this;
}

HTTPRequest& HTTPRequest::MakeTraceRequest(std::string_view url)
{
    Clear();
    SetBegin("TRACE", url);
    SetBody();
    return *this;
}

bool HTTPRequest::IsPendingHeader() const
{
    return (!_error && (_body_index == 0));
}

bool HTTPRequest::IsPendingBody() const
{
    return (!_error && (_body_index > 0) && (_body_size > 0));
}

bool HTTPRequest::ReceiveHeader(const void* buffer, size_t size)
{
    // Update the request cache
    _cache.insert(_cache.end(), (const char*)buffer, (const char*)buffer + size);

    // Try to seek for HTTP header separator
    for (size_t i = _cache_size; i < _cache.size(); ++i)
    {
        // Check for the request cache out of bounds
        if ((i + 3) >= _cache.size())
            break;

        // Check for the header separator
        if ((_cache[i + 0] == '\r') && (_cache[i + 1] == '\n') && (_cache[i + 2] == '\r') && (_cache[i + 3] == '\n'))
        {
            size_t index = 0;

            // Set the error flag for a while...
            _error = true;

            // Parse method
            _method_index = index;
            _method_size = 0;
            while (_cache[index] != ' ')
            {
                ++_method_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse URL
            _url_index = index;
            _url_size = 0;
            while (_cache[index] != ' ')
            {
                ++_url_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse protocol version
            _protocol_index = index;
            _protocol_size = 0;
            while (_cache[index] != '\r')
            {
                ++_protocol_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            ++index;
            if ((index >= _cache.size()) || (_cache[index] != '\n'))
                return false;
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse headers
            while ((index < _cache.size()) && (index < i))
            {
                // Parse header name
                size_t header_name_index = index;
                size_t header_name_size = 0;
                while (_cache[index] != ':')
                {
                    ++header_name_size;
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }
                ++index;
                if (index >= i)
                    break;
                if (index >= _cache.size())
                    return false;

                // Skip all prefix space characters
                while (std::isspace(_cache[index]))
                {
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }

                // Parse header value
                size_t header_value_index = index;
                size_t header_value_size = 0;
                while (_cache[index] != '\r')
                {
                    ++header_value_size;
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }
                ++index;
                if ((index >= _cache.size()) || (_cache[index] != '\n'))
                    return false;
                ++index;
                if (index >= _cache.size())
                    return false;

                // Validate header name and value (sometimes value can be empty)
                if (header_name_size == 0)
                    return false;

                // Add a new header
                _headers.emplace_back(header_name_index, header_name_size, header_value_index, header_value_size);

                // Try to find the body content length
                if (CppCommon::StringUtils::CompareNoCase(std::string_view(_cache.data() + header_name_index, header_name_size), "Content-Length"))
                {
                    _body_length = 0;
                    for (size_t j = header_value_index; j < (header_value_index + header_value_size); ++j)
                    {
                        if ((_cache[j] < '0') || (_cache[j] > '9'))
                            return false;
                        _body_length *= 10;
                        _body_length += _cache[j] - '0';
                        _body_length_provided = true;
                    }
                }

                // Try to find Cookies
                if (CppCommon::StringUtils::CompareNoCase(std::string_view(_cache.data() + header_name_index, header_name_size), "Cookie"))
                {
                    bool name = true;
                    bool token = false;
                    size_t current = header_value_index;
                    size_t name_index = index;
                    size_t name_size = 0;
                    size_t cookie_index = index;
                    size_t cookie_size = 0;
                    for (size_t j = header_value_index; j < (header_value_index + header_value_size); ++j)
                    {
                        if (_cache[j] == ' ')
                        {
                            if (token)
                            {
                                if (name)
                                {
                                    name_index = current;
                                    name_size = j - current;
                                }
                                else
                                {
                                    cookie_index = current;
                                    cookie_size = j - current;
                                }
                            }
                            token = false;
                            continue;
                        }
                        if (_cache[j] == '=')
                        {
                            if (token)
                            {
                                if (name)
                                {
                                    name_index = current;
                                    name_size = j - current;
                                }
                                else
                                {
                                    cookie_index = current;
                                    cookie_size = j - current;
                                }
                            }
                            token = false;
                            name = false;
                            continue;
                        }
                        if (_cache[j] == ';')
                        {
                            if (token)
                            {
                                if (name)
                                {
                                    name_index = current;
                                    name_size = j - current;
                                }
                                else
                                {
                                    cookie_index = current;
                                    cookie_size = j - current;
                                }

                                // Validate the cookie
                                if ((name_size > 0) && (cookie_size > 0))
                                {
                                    // Add the cookie to the corresponding collection
                                    _cookies.emplace_back(name_index, name_size, cookie_index, cookie_size);

                                    // Resset the current cookie values
                                    name_index = j;
                                    name_size = 0;
                                    cookie_index = j;
                                    cookie_size = 0;
                                }
                            }
                            token = false;
                            name = true;
                            continue;
                        }
                        if (!token)
                        {
                            current = j;
                            token = true;
                        }
                    }

                    // Process the last cookie
                    if (token)
                    {
                        if (name)
                        {
                            name_index = current;
                            name_size = header_value_index + header_value_size - current;
                        }
                        else
                        {
                            cookie_index = current;
                            cookie_size = header_value_index + header_value_size - current;
                        }

                        // Validate the cookie
                        if ((name_size > 0) && (cookie_size > 0))
                        {
                            // Add the cookie to the corresponding collection
                            _cookies.emplace_back(name_index, name_size, cookie_index, cookie_size);
                        }
                    }
                }
            }

            // Reset the error flag
            _error = false;

            // Update the body index and size
            _body_index = i + 4;
            _body_size = _cache.size() - i - 4;

            // Update the parsed cache size
            _cache_size = _cache.size();

            return true;
        }
    }

    // Update the parsed cache size
    _cache_size = (_cache.size() >= 3) ? (_cache.size() - 3) : 0;

    return false;
}

bool HTTPRequest::ReceiveBody(const void* buffer, size_t size)
{
    // Update HTTP request cache
    _cache.insert(_cache.end(), (const char*)buffer, (const char*)buffer + size);

    // Update the parsed cache size
    _cache_size = _cache.size();

    // Update body size
    _body_size += size;

    // Check if the body length was provided
    if (_body_length_provided)
    {
        // Was the body fully received?
        if (_body_size >= _body_length)
        {
            _body_size = _body_length;
            return true;
        }
    }
    else
    {
        // HEAD/GET/DELETE/OPTIONS/TRACE request might have no body
        if ((method() == "HEAD") || (method() == "GET") || (method() == "DELETE") || (method() == "OPTIONS") || (method() == "TRACE"))
        {
            _body_length = 0;
            _body_size = 0;
            return true;
        }

        // Check the body content to find the request body end
        if (_body_size >= 4)
        {
            size_t index = _body_index + _body_size - 4;

            // Was the body fully received?
            if ((_cache[index + 0] == '\r') && (_cache[index + 1] == '\n') && (_cache[index + 2] == '\r') && (_cache[index + 3] == '\n'))
            {
                _body_length = _body_size;
                return true;
            }
        }
    }

    // Body was received partially...
    return false;
}

std::string_view HTTPRequest::FastConvert(size_t value, char* buffer, size_t size)
{
    size_t index = size;
    do
    {
        buffer[--index] = '0' + (value % 10);
        value /= 10;
    }
    while (value > 0);
    return std::string_view(buffer + index, size - index);
}

std::ostream& operator<<(std::ostream& os, const HTTPRequest& request)
{
    os << "Request method: " << request.method() << std::endl;
    os << "Request URL: " << request.url() << std::endl;
    os << "Request protocol: " << request.protocol() << std::endl;
    os << "Request headers: " << request.headers() << std::endl;
    for (size_t i = 0; i < request.headers(); ++i)
    {
        auto header = request.header(i);
        os << std::get<0>(header) << ": " << std::get<1>(header) << std::endl;
    }
    os << "Request body:" << request.body_length() << std::endl;
    os << request.body() << std::endl;
    return os;
}

void HTTPRequest::swap(HTTPRequest& request) noexcept
{
    using std::swap;
    swap(_error, request._error);
    swap(_method_index, request._method_index);
    swap(_method_size, request._method_size);
    swap(_url_index, request._url_index);
    swap(_url_size, request._url_size);
    swap(_protocol_index, request._protocol_index);
    swap(_protocol_size, request._protocol_size);
    swap(_headers, request._headers);
    swap(_cookies, request._cookies);
    swap(_body_index, request._body_index);
    swap(_body_size, request._body_size);
    swap(_body_length, request._body_length);
    swap(_body_length_provided, request._body_length_provided);
    swap(_cache, request._cache);
    swap(_cache_size, request._cache_size);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/http_response.cpp`:

```cpp
/*!
    \file http_response.cpp
    \brief HTTP response implementation
    \author Ivan Shynkarenka
    \date 15.02.2019
    \copyright MIT License
*/

#include "server/http/http_response.h"

#include "errors/exceptions.h"
#include "string/format.h"
#include "string/string_utils.h"
#include "utility/countof.h"

#include <cassert>

namespace CppServer {
namespace HTTP {

const std::unordered_map<std::string, std::string> HTTPResponse::_mime_table =
{
    // Base content types
    { ".html",      "text/html" },
    { ".css",       "text/css" },
    { ".js",        "text/javascript" },
    { ".vue",       "text/html" },
    { ".xml",       "text/xml" },

    // Application content types
    { ".atom",      "application/atom+xml" },
    { ".fastsoap",  "application/fastsoap" },
    { ".gzip",      "application/gzip" },
    { ".json",      "application/json" },
    { ".map",       "application/json" },
    { ".pdf",       "application/pdf" },
    { ".ps",        "application/postscript" },
    { ".soap",      "application/soap+xml" },
    { ".sql",       "application/sql" },
    { ".xslt",      "application/xslt+xml" },
    { ".zip",       "application/zip" },
    { ".zlib",      "application/zlib" },

    // Audio content types
    { ".aac",       "audio/aac" },
    { ".ac3",       "audio/ac3" },
    { ".mp3",       "audio/mpeg" },
    { ".ogg",       "audio/ogg" },

    // Font content types
    { ".ttf",       "font/ttf" },

    // Image content types
    { ".bmp",       "image/bmp" },
    { ".emf",       "image/emf" },
    { ".gif",       "image/gif" },
    { ".jpg",       "image/jpeg" },
    { ".jpm",       "image/jpm" },
    { ".jpx",       "image/jpx" },
    { ".jrx",       "image/jrx" },
    { ".png",       "image/png" },
    { ".svg",       "image/svg+xml" },
    { ".tiff",      "image/tiff" },
    { ".wmf",       "image/wmf" },

    // Message content types
    { ".http",      "message/http" },
    { ".s-http",    "message/s-http" },

    // Model content types
    { ".mesh",      "model/mesh" },
    { ".vrml",      "model/vrml" },

    // Text content types
    { ".csv",       "text/csv" },
    { ".plain",     "text/plain" },
    { ".richtext",  "text/richtext" },
    { ".rtf",       "text/rtf" },
    { ".rtx",       "text/rtx" },
    { ".sgml",      "text/sgml" },
    { ".strings",   "text/strings" },
    { ".url",       "text/uri-list" },

    // Video content types
    { ".H264",      "video/H264" },
    { ".H265",      "video/H265" },
    { ".mp4",       "video/mp4" },
    { ".mpeg",      "video/mpeg" },
    { ".raw",       "video/raw" }
};

std::tuple<std::string_view, std::string_view> HTTPResponse::header(size_t i) const noexcept
{
    assert((i < _headers.size()) && "Index out of bounds!");
    if (i >= _headers.size())
        return std::make_tuple(std::string_view(), std::string_view());

    auto item = _headers[i];

    return std::make_tuple(std::string_view(_cache.data() + std::get<0>(item), std::get<1>(item)), std::string_view(_cache.data() + std::get<2>(item), std::get<3>(item)));
}

HTTPResponse& HTTPResponse::Clear()
{
    _error = false;
    _status = 0;
    _status_phrase_index = 0;
    _status_phrase_size = 0;
    _protocol_index = 0;
    _protocol_size = 0;
    _headers.clear();
    _body_index = 0;
    _body_size = 0;
    _body_length = 0;
    _body_length_provided = false;

    _cache.clear();
    _cache_size = 0;
    return *this;
}

HTTPResponse& HTTPResponse::SetBegin(int status, std::string_view protocol)
{
    std::string status_phrase;

    switch (status)
    {
        case 100: status_phrase = "Continue"; break;
        case 101: status_phrase = "Switching Protocols"; break;
        case 102: status_phrase = "Processing"; break;
        case 103: status_phrase = "Early Hints"; break;

        case 200: status_phrase = "OK"; break;
        case 201: status_phrase = "Created"; break;
        case 202: status_phrase = "Accepted"; break;
        case 203: status_phrase = "Non-Authoritative Information"; break;
        case 204: status_phrase = "No Content"; break;
        case 205: status_phrase = "Reset Content"; break;
        case 206: status_phrase = "Partial Content"; break;
        case 207: status_phrase = "Multi-Status"; break;
        case 208: status_phrase = "Already Reported"; break;

        case 226: status_phrase = "IM Used"; break;

        case 300: status_phrase = "Multiple Choices"; break;
        case 301: status_phrase = "Moved Permanently"; break;
        case 302: status_phrase = "Found"; break;
        case 303: status_phrase = "See Other"; break;
        case 304: status_phrase = "Not Modified"; break;
        case 305: status_phrase = "Use Proxy"; break;
        case 306: status_phrase = "Switch Proxy"; break;
        case 307: status_phrase = "Temporary Redirect"; break;
        case 308: status_phrase = "Permanent Redirect"; break;

        case 400: status_phrase = "Bad Request"; break;
        case 401: status_phrase = "Unauthorized"; break;
        case 402: status_phrase = "Payment Required"; break;
        case 403: status_phrase = "Forbidden"; break;
        case 404: status_phrase = "Not Found"; break;
        case 405: status_phrase = "Method Not Allowed"; break;
        case 406: status_phrase = "Not Acceptable"; break;
        case 407: status_phrase = "Proxy Authentication Required"; break;
        case 408: status_phrase = "Request Timeout"; break;
        case 409: status_phrase = "Conflict"; break;
        case 410: status_phrase = "Gone"; break;
        case 411: status_phrase = "Length Required"; break;
        case 412: status_phrase = "Precondition Failed"; break;
        case 413: status_phrase = "Payload Too Large"; break;
        case 414: status_phrase = "URI Too Long"; break;
        case 415: status_phrase = "Unsupported Media Type"; break;
        case 416: status_phrase = "Range Not Satisfiable"; break;
        case 417: status_phrase = "Expectation Failed"; break;

        case 421: status_phrase = "Misdirected Request"; break;
        case 422: status_phrase = "Unprocessable Entity"; break;
        case 423: status_phrase = "Locked"; break;
        case 424: status_phrase = "Failed Dependency"; break;
        case 425: status_phrase = "Too Early"; break;
        case 426: status_phrase = "Upgrade Required"; break;
        case 427: status_phrase = "Unassigned"; break;
        case 428: status_phrase = "Precondition Required"; break;
        case 429: status_phrase = "Too Many Requests"; break;
        case 431: status_phrase = "Request Header Fields Too Large"; break;

        case 451: status_phrase = "Unavailable For Legal Reasons"; break;

        case 500: status_phrase = "Internal Server Error"; break;
        case 501: status_phrase = "Not Implemented"; break;
        case 502: status_phrase = "Bad Gateway"; break;
        case 503: status_phrase = "Service Unavailable"; break;
        case 504: status_phrase = "Gateway Timeout"; break;
        case 505: status_phrase = "HTTP Version Not Supported"; break;
        case 506: status_phrase = "Variant Also Negotiates"; break;
        case 507: status_phrase = "Insufficient Storage"; break;
        case 508: status_phrase = "Loop Detected"; break;

        case 510: status_phrase = "Not Extended"; break;
        case 511: status_phrase = "Network Authentication Required"; break;

        default: status_phrase = "Unknown"; break;
    }

    SetBegin(status, status_phrase, protocol);
    return *this;
}

HTTPResponse& HTTPResponse::SetBegin(int status, std::string_view status_phrase, std::string_view protocol)
{
    // Clear the HTTP response cache
    Clear();

    size_t index = 0;

    // Append the HTTP response protocol version
    _cache.append(protocol);
    _protocol_index = index;
    _protocol_size = protocol.size();

    _cache.append(" ");
    index = _cache.size();

    // Append the HTTP response status
    char buffer[32];
    _cache.append(FastConvert(status, buffer, CppCommon::countof(buffer)));
    _status = status;

    _cache.append(" ");
    index = _cache.size();

    // Append the HTTP response status phrase
    _cache.append(status_phrase);
    _status_phrase_index = index;
    _status_phrase_size = status_phrase.size();

    _cache.append("\r\n");
    return *this;
}

HTTPResponse& HTTPResponse::SetContentType(std::string_view extension)
{
    // Try to lookup the content type in mime table
    const auto& mime = _mime_table.find(std::string(extension));
    if (mime != _mime_table.end())
        return SetHeader("Content-Type", mime->second);

    return *this;
}

HTTPResponse& HTTPResponse::SetHeader(std::string_view key, std::string_view value)
{
    size_t index = _cache.size();

    // Append the HTTP response header's key
    _cache.append(key);
    size_t key_index = index;
    size_t key_size = key.size();

    _cache.append(": ");
    index = _cache.size();

    // Append the HTTP response header's value
    _cache.append(value);
    size_t value_index = index;
    size_t value_size = value.size();

    _cache.append("\r\n");

    // Add the header to the corresponding collection
    _headers.emplace_back(key_index, key_size, value_index, value_size);
    return *this;
}

HTTPResponse& HTTPResponse::SetCookie(std::string_view name, std::string_view value, size_t max_age, std::string_view path, std::string_view domain, bool secure, bool strict, bool http_only)
{
    size_t index = _cache.size();

    // Append the HTTP response header's key
    _cache.append("Set-Cookie");
    size_t key_index = index;
    size_t key_size = 10;

    _cache.append(": ");
    index = _cache.size();

    // Append the HTTP response header's value
    size_t value_index = index;

    char buffer[32];

    // Append cookie
    _cache.append(name);
    _cache.append("=");
    _cache.append(value);
    _cache.append("; Max-Age=");
    _cache.append(FastConvert(max_age, buffer, CppCommon::countof(buffer)));
    if (!domain.empty())
    {
        _cache.append("; Domain=");
        _cache.append(domain);
    }
    if (!path.empty())
    {
        _cache.append("; Path=");
        _cache.append(path);
    }
    if (secure)
        _cache.append("; Secure");
    if (strict)
        _cache.append("; SameSite=Strict");
    if (http_only)
        _cache.append("; HttpOnly");

    size_t value_size = _cache.size() - value_index;

    _cache.append("\r\n");

    // Add the header to the corresponding collection
    _headers.emplace_back(key_index, key_size, value_index, value_size);
    return *this;
}

HTTPResponse& HTTPResponse::SetBody(std::string_view body)
{
    // Append non empty content length header
    char buffer[32];
    SetHeader("Content-Length", FastConvert(body.size(), buffer, CppCommon::countof(buffer)));

    _cache.append("\r\n");

    size_t index = _cache.size();

    // Append the HTTP response body
    _cache.append(body);
    _body_index = index;
    _body_size = body.size();
    _body_length = body.size();
    _body_length_provided = true;
    return *this;
}

HTTPResponse& HTTPResponse::SetBodyLength(size_t length)
{
    // Append content length header
    char buffer[32];
    SetHeader("Content-Length", FastConvert(length, buffer, CppCommon::countof(buffer)));

    _cache.append("\r\n");

    size_t index = _cache.size();

    // Clear the HTTP response body
    _body_index = index;
    _body_size = 0;
    _body_length = length;
    _body_length_provided = true;
    return *this;
}

HTTPResponse& HTTPResponse::MakeOKResponse(int status)
{
    Clear();
    SetBegin(status);
    SetBody();
    return *this;
}

HTTPResponse& HTTPResponse::MakeErrorResponse(int status, std::string_view content, std::string_view content_type)
{
    Clear();
    SetBegin(status);
    if (!content_type.empty())
        SetHeader("Content-Type", content_type);
    SetBody(content);
    return *this;
}

HTTPResponse& HTTPResponse::MakeHeadResponse()
{
    Clear();
    SetBegin(200);
    SetBody();
    return *this;
}

HTTPResponse& HTTPResponse::MakeGetResponse(std::string_view content, std::string_view content_type)
{
    Clear();
    SetBegin(200);
    if (!content_type.empty())
        SetHeader("Content-Type", content_type);
    SetBody(content);
    return *this;
}

HTTPResponse& HTTPResponse::MakeOptionsResponse(std::string_view allow)
{
    Clear();
    SetBegin(200);
    SetHeader("Allow", allow);
    SetBody();
    return *this;
}

HTTPResponse& HTTPResponse::MakeTraceResponse(std::string_view request)
{
    Clear();
    SetBegin(200);
    SetHeader("Content-Type", "message/http");
    SetBody(request);
    return *this;
}

bool HTTPResponse::IsPendingHeader() const
{
    return (!_error && (_body_index == 0));
}

bool HTTPResponse::IsPendingBody() const
{
    return (!_error && (_body_index > 0) && (_body_size > 0));
}

bool HTTPResponse::ReceiveHeader(const void* buffer, size_t size)
{
    // Update the response cache
    _cache.insert(_cache.end(), (const char*)buffer, (const char*)buffer + size);

    // Try to seek for HTTP header separator
    for (size_t i = _cache_size; i < _cache.size(); ++i)
    {
        // Check for the response cache out of bounds
        if ((i + 3) >= _cache.size())
            break;

        // Check for the header separator
        if ((_cache[i + 0] == '\r') && (_cache[i + 1] == '\n') && (_cache[i + 2] == '\r') && (_cache[i + 3] == '\n'))
        {
            size_t index = 0;

            // Set the error flag for a while...
            _error = true;

            // Parse protocol version
            _protocol_index = index;
            _protocol_size = 0;
            while (_cache[index] != ' ')
            {
                ++_protocol_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse status code
            size_t status_index = index;
            size_t status_size = 0;
            while (_cache[index] != ' ')
            {
                if ((_cache[index] < '0') || (_cache[index] > '9'))
                    return false;
                ++status_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            _status = 0;
            for (size_t j = status_index; j < (status_index + status_size); ++j)
            {
                _status *= 10;
                _status += _cache[j] - '0';
            }
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse status phrase
            _status_phrase_index = index;
            _status_phrase_size = 0;
            while (_cache[index] != '\r')
            {
                ++_status_phrase_size;
                ++index;
                if (index >= _cache.size())
                    return false;
            }
            ++index;
            if ((index >= _cache.size()) || (_cache[index] != '\n'))
                return false;
            ++index;
            if (index >= _cache.size())
                return false;

            // Parse headers
            while ((index < _cache.size()) && (index < i))
            {
                // Parse header name
                size_t header_name_index = index;
                size_t header_name_size = 0;
                while (_cache[index] != ':')
                {
                    ++header_name_size;
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }
                ++index;
                if (index >= i)
                    break;
                if (index >= _cache.size())
                    return false;

                // Skip all prefix space characters
                while (std::isspace(_cache[index]))
                {
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }

                // Parse header value
                size_t header_value_index = index;
                size_t header_value_size = 0;
                while (_cache[index] != '\r')
                {
                    ++header_value_size;
                    ++index;
                    if (index >= i)
                        break;
                    if (index >= _cache.size())
                        return false;
                }
                ++index;
                if ((index >= _cache.size()) || (_cache[index] != '\n'))
                    return false;
                ++index;
                if (index >= _cache.size())
                    return false;

                // Validate header name and value (sometimes value can be empty)
                if (header_name_size == 0)
                    return false;

                // Add a new header
                _headers.emplace_back(header_name_index, header_name_size, header_value_index, header_value_size);

                // Try to find the body content length
                if (CppCommon::StringUtils::CompareNoCase(std::string_view(_cache.data() + header_name_index, header_name_size), "Content-Length"))
                {
                    _body_length = 0;
                    for (size_t j = header_value_index; j < (header_value_index + header_value_size); ++j)
                    {
                        if ((_cache[j] < '0') || (_cache[j] > '9'))
                            return false;
                        _body_length *= 10;
                        _body_length += _cache[j] - '0';
                        _body_length_provided = true;
                    }
                }
            }

            // Reset the error flag
            _error = false;

            // Update the body index and size
            _body_index = i + 4;
            _body_size = _cache.size() - i - 4;

            // Update the parsed cache size
            _cache_size = _cache.size();

            return true;
        }
    }

    // Update the parsed cache size
    _cache_size = (_cache.size() >= 3) ? (_cache.size() - 3) : 0;

    return false;
}

bool HTTPResponse::ReceiveBody(const void* buffer, size_t size)
{
    // Update HTTP response cache
    _cache.insert(_cache.end(), (const char*)buffer, (const char*)buffer + size);

    // Update the parsed cache size
    _cache_size = _cache.size();

    // Update body size
    _body_size += size;

    // Check if the body length was provided
    if (_body_length_provided)
    {
        // Was the body fully received?
        if (_body_size >= _body_length)
        {
            _body_size = _body_length;
            return true;
        }
    }
    else
    {
        // Check the body content to find the response body end
        if (_body_size >= 4)
        {
            size_t index = _body_index + _body_size - 4;

            // Was the body fully received?
            if ((_cache[index + 0] == '\r') && (_cache[index + 1] == '\n') && (_cache[index + 2] == '\r') && (_cache[index + 3] == '\n'))
            {
                _body_length = _body_size;
                return true;
            }
        }
    }

    // Body was received partially...
    return false;
}

std::string_view HTTPResponse::FastConvert(size_t value, char* buffer, size_t size)
{
    size_t index = size;
    do
    {
        buffer[--index] = '0' + (value % 10);
        value /= 10;
    }
    while (value > 0);
    return std::string_view(buffer + index, size - index);
}

std::ostream& operator<<(std::ostream& os, const HTTPResponse& response)
{
    os << "Status: " << response.status() << std::endl;
    os << "Status phrase: " << response.status_phrase() << std::endl;
    os << "Protocol: " << response.protocol() << std::endl;
    os << "Headers: " << response.headers() << std::endl;
    for (size_t i = 0; i < response.headers(); ++i)
    {
        auto header = response.header(i);
        os << std::get<0>(header) << ": " << std::get<1>(header) << std::endl;
    }
    os << "Body:" << response.body_length() << std::endl;
    os << response.body() << std::endl;
    return os;
}

void HTTPResponse::swap(HTTPResponse& response) noexcept
{
    using std::swap;
    swap(_error, response._error);
    swap(_status, response._status);
    swap(_status_phrase_index, response._status_phrase_index);
    swap(_status_phrase_size, response._status_phrase_size);
    swap(_protocol_index, response._protocol_index);
    swap(_protocol_size, response._protocol_size);
    swap(_headers, response._headers);
    swap(_body_index, response._body_index);
    swap(_body_size, response._body_size);
    swap(_body_length, response._body_length);
    swap(_body_length_provided, response._body_length_provided);
    swap(_cache, response._cache);
    swap(_cache_size, response._cache_size);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/http_server.cpp`:

```cpp
/*!
    \file http_server.cpp
    \brief HTTP server implementation
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "server/http/http_server.h"

#include "string/format.h"

namespace CppServer {
namespace HTTP {

void HTTPServer::AddStaticContent(const CppCommon::Path& path, const std::string& prefix, const CppCommon::Timespan& timeout)
{
    auto hanlder = [](CppCommon::FileCache & cache, const std::string& key, const std::string& value, const CppCommon::Timespan& timespan)
    {
        auto response = HTTPResponse();
        response.SetBegin(200);
        response.SetContentType(CppCommon::Path(key).extension().string());
        response.SetHeader("Cache-Control", CppCommon::format("max-age={}", timespan.seconds()));
        response.SetBody(value);
        return cache.insert(key, response.cache(), timespan);
    };

    cache().insert_path(path, prefix, timeout, hanlder);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/http_session.cpp`:

```cpp
/*!
    \file http_session.cpp
    \brief HTTP session implementation
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "server/http/http_session.h"
#include "server/http/http_server.h"

namespace CppServer {
namespace HTTP {

HTTPSession::HTTPSession(const std::shared_ptr<HTTPServer>& server)
    : Asio::TCPSession(server),
      _cache(server->cache())
{
}

void HTTPSession::onReceived(const void* buffer, size_t size)
{
    // Receive HTTP request header
    if (_request.IsPendingHeader())
    {
        if (_request.ReceiveHeader(buffer, size))
            onReceivedRequestHeader(_request);

        size = 0;
    }

    // Check for HTTP request error
    if (_request.error())
    {
        onReceivedRequestError(_request, "Invalid HTTP request!");
        _request.Clear();
        Disconnect();
        return;
    }

    // Receive HTTP request body
    if (_request.ReceiveBody(buffer, size))
    {
        onReceivedRequestInternal(_request);
        _request.Clear();
        return;
    }

    // Check for HTTP request error
    if (_request.error())
    {
        onReceivedRequestError(_request, "Invalid HTTP request!");
        _request.Clear();
        Disconnect();
        return;
    }
}

void HTTPSession::onDisconnected()
{
    // Receive HTTP request body
    if (_request.IsPendingBody())
    {
        onReceivedRequestInternal(_request);
        _request.Clear();
        return;
    }
}

void HTTPSession::onReceivedRequestInternal(const HTTPRequest& request)
{
    // Try to get the cached response
    if (request.method() == "GET")
    {
        std::string_view url = request.url();
        size_t index = url.find('?');
        auto response = cache().find(std::string((index == std::string_view::npos) ? url : url.substr(0, index)));
        if (response.first)
        {
            // Process the request with the cached response
            onReceivedCachedRequest(request, response.second);
            return;
        }
    }

    // Process the request
    onReceivedRequest(request);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/https_client.cpp`:

```cpp
/*!
    \file https_client.cpp
    \brief HTTPS client implementation
    \author Ivan Shynkarenka
    \date 12.02.2019
    \copyright MIT License
*/

#include "server/http/https_client.h"

namespace CppServer {
namespace HTTP {

void HTTPSClient::onReceived(const void* buffer, size_t size)
{
    // Receive HTTP response header
    if (_response.IsPendingHeader())
    {
        if (_response.ReceiveHeader(buffer, size))
            onReceivedResponseHeader(_response);

        size = 0;
    }

    // Check for HTTP response error
    if (_response.error())
    {
        onReceivedResponseError(_response, "Invalid HTTP response!");
        _response.Clear();
        DisconnectAsync();
        return;
    }

    // Receive HTTP response body
    if (_response.ReceiveBody(buffer, size))
    {
        onReceivedResponse(_response);
        _response.Clear();
        return;
    }

    // Check for HTTP response error
    if (_response.error())
    {
        onReceivedResponseError(_response, "Invalid HTTP response!");
        _response.Clear();
        DisconnectAsync();
        return;
    }
}

void HTTPSClient::onDisconnected()
{
    // Receive HTTP response body
    if (_response.IsPendingBody())
    {
        onReceivedResponse(_response);
        _response.Clear();
        return;
    }
}

std::future<HTTPResponse> HTTPSClientEx::SendRequest(const HTTPRequest& request, const CppCommon::Timespan& timeout)
{
    // Create TCP resolver if the current one is empty
    if (!_resolver)
        _resolver = std::make_shared<Asio::TCPResolver>(service());
    // Create timeout check timer if the current one is empty
    if (!_timeout)
        _timeout = std::make_shared<Asio::Timer>(service());

    _promise = std::promise<HTTPResponse>();
    _request = request;

    // Check if the HTTP request is valid
    if (_request.empty() || _request.error())
    {
        SetPromiseError("Invalid HTTP request!");
        return _promise.get_future();
    }

    if (!IsHandshaked())
    {
        // Connect to the Web server
        if (!ConnectAsync(_resolver))
        {
            SetPromiseError("Connection failed!");
            return _promise.get_future();
        }
    }
    else
    {
        // Send prepared HTTP request
        if (!SendRequestAsync())
        {
            SetPromiseError("Failed to send HTTP request!");
            return _promise.get_future();
        }
    }

    // Setup timeout check timer
    auto self(this->shared_from_this());
    auto timeout_handler = [this, self](bool canceled)
    {
        if (canceled)
            return;

        // Disconnect on timeout
        onReceivedResponseError(_response, "Timeout!");
        _response.Clear();
        DisconnectAsync();
    };
    if (!_timeout->Setup(timeout_handler, timeout) || !_timeout->WaitAsync())
    {
        SetPromiseError("Failed to setup timeout timer!");
        return _promise.get_future();
    }

    return _promise.get_future();
}

void HTTPSClientEx::onHandshaked()
{
    HTTPSClient::onHandshaked();

    // Send prepared HTTP request on connect
    if (!_request.empty() && !_request.error())
        if (!SendRequestAsync())
            SetPromiseError("Failed to send HTTP request!");
}

void HTTPSClientEx::onDisconnected()
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    HTTPSClient::onDisconnected();
}

void HTTPSClientEx::onReceivedResponse(const HTTPResponse& response)
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    SetPromiseValue(response);
}

void HTTPSClientEx::onReceivedResponseError(const HTTPResponse& response, const std::string& error)
{
    // Cancel timeout check timer
    if (_timeout)
        _timeout->Cancel();

    SetPromiseError(error);
}

void HTTPSClientEx::SetPromiseValue(const HTTPResponse& response)
{
    _promise.set_value(response);
    _request.Clear();
}

void HTTPSClientEx::SetPromiseError(const std::string& error)
{
    _promise.set_exception(std::make_exception_ptr(std::runtime_error(error)));
    _request.Clear();
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/https_server.cpp`:

```cpp
/*!
    \file https_server.cpp
    \brief HTTPS server implementation
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "server/http/https_server.h"

#include "string/format.h"

namespace CppServer {
namespace HTTP {

void HTTPSServer::AddStaticContent(const CppCommon::Path& path, const std::string& prefix, const CppCommon::Timespan& timeout)
{
    auto hanlder = [](CppCommon::FileCache & cache, const std::string& key, const std::string& value, const CppCommon::Timespan& timespan)
    {
        auto response = HTTPResponse();
        response.SetBegin(200);
        response.SetContentType(CppCommon::Path(key).extension().string());
        response.SetHeader("Cache-Control", CppCommon::format("max-age={}", timespan.seconds()));
        response.SetBody(value);
        return cache.insert(key, response.cache(), timespan);
    };

    cache().insert_path(path, prefix, timeout, hanlder);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/http/https_session.cpp`:

```cpp
/*!
    \file https_session.cpp
    \brief HTTPS session implementation
    \author Ivan Shynkarenka
    \date 30.04.2019
    \copyright MIT License
*/

#include "server/http/https_session.h"
#include "server/http/https_server.h"

namespace CppServer {
namespace HTTP {

HTTPSSession::HTTPSSession(const std::shared_ptr<HTTPSServer>& server)
    : Asio::SSLSession(server),
      _cache(server->cache())
{
}

void HTTPSSession::onReceived(const void* buffer, size_t size)
{
    // Receive HTTP request header
    if (_request.IsPendingHeader())
    {
        if (_request.ReceiveHeader(buffer, size))
            onReceivedRequestHeader(_request);

        size = 0;
    }

    // Check for HTTP request error
    if (_request.error())
    {
        onReceivedRequestError(_request, "Invalid HTTP request!");
        _request.Clear();
        Disconnect();
        return;
    }

    // Receive HTTP request body
    if (_request.ReceiveBody(buffer, size))
    {
        onReceivedRequestInternal(_request);
        _request.Clear();
        return;
    }

    // Check for HTTP request error
    if (_request.error())
    {
        onReceivedRequestError(_request, "Invalid HTTP request!");
        _request.Clear();
        Disconnect();
        return;
    }
}

void HTTPSSession::onDisconnected()
{
    // Receive HTTP request body
    if (_request.IsPendingBody())
    {
        onReceivedRequestInternal(_request);
        _request.Clear();
        return;
    }
}

void HTTPSSession::onReceivedRequestInternal(const HTTPRequest& request)
{
    // Try to get the cached response
    if (request.method() == "GET")
    {
        std::string_view url = request.url();
        size_t index = url.find('?');
        auto response = cache().find(std::string((index == std::string_view::npos) ? url : url.substr(0, index)));
        if (response.first)
        {
            // Process the request with the cached response
            onReceivedCachedRequest(request, response.second);
            return;
        }
    }

    // Process the request
    onReceivedRequest(request);
}

} // namespace HTTP
} // namespace CppServer

```

`source/server/ws/ws.cpp`:

```cpp
/*!
    \file ws.cpp
    \brief WebSocket C++ Library implementation
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#include "server/ws/ws.h"

#include "string/encoding.h"
#include "string/format.h"
#include "string/string_utils.h"

#include <algorithm>
#include <openssl/sha.h>

namespace CppServer {
namespace WS {

void WebSocket::InitWSNonce()
{
    std::generate(_ws_nonce.begin(), _ws_nonce.end(), []() { return (uint8_t)std::rand(); });
}

bool WebSocket::PerformClientUpgrade(const HTTP::HTTPResponse& response, const CppCommon::UUID& id)
{
    if (response.status() != 101)
        return false;

    bool error = false;
    bool accept = false;
    bool connection = false;
    bool upgrade = false;

    // Validate WebSocket handshake headers
    for (size_t i = 0; i < response.headers(); ++i)
    {
        auto header = response.header(i);
        auto key = std::get<0>(header);
        auto value = std::get<1>(header);

        if (CppCommon::StringUtils::CompareNoCase(key, "Connection"))
        {
            if (!CppCommon::StringUtils::CompareNoCase(value, "Upgrade"))
            {
                error = true;
                onWSError("Invalid WebSocket handshaked response: 'Connection' header value must be 'Upgrade'");
                break;
            }

            connection = true;
        }
        else if (CppCommon::StringUtils::CompareNoCase(key, "Upgrade"))
        {
            if (!CppCommon::StringUtils::CompareNoCase(value, "websocket"))
            {
                error = true;
                onWSError("Invalid WebSocket handshaked response: 'Upgrade' header value must be 'websocket'");
                break;
            }

            upgrade = true;
        }
        else if (CppCommon::StringUtils::CompareNoCase(key, "Sec-WebSocket-Accept"))
        {
            // Calculate the original WebSocket hash
            std::string wskey = CppCommon::Encoding::Base64Encode(ws_nonce()) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            char wshash[SHA_DIGEST_LENGTH];
            SHA1((const unsigned char*)wskey.data(), wskey.size(), (unsigned char*)wshash);

            // Get the received WebSocket hash
            wskey = CppCommon::Encoding::Base64Decode(value);

            // Compare original and received hashes
            if (std::strncmp(wskey.data(), wshash, std::min(wskey.size(), sizeof(wshash))) != 0)
            {
                error = true;
                onWSError("Invalid WebSocket handshaked response: 'Sec-WebSocket-Accept' value validation failed");
                break;
            }

            accept = true;
        }
    }

    // Failed to perform WebSocket handshake
    if (!accept || !connection || !upgrade)
    {
        if (!error)
            onWSError("Invalid WebSocket response");
        return false;
    }

    // WebSocket successfully handshaked!
    _ws_handshaked = true;
    *((uint32_t*)_ws_send_mask) = rand();
    onWSConnected(response);

    return true;
}

bool WebSocket::PerformServerUpgrade(const HTTP::HTTPRequest& request, HTTP::HTTPResponse& response)
{
    if (request.method() != "GET")
        return false;

    bool error = false;
    bool connection = false;
    bool upgrade = false;
    bool ws_key = false;
    bool ws_version = false;

    std::string accept;

    // Validate WebSocket handshake headers
    for (size_t i = 0; i < request.headers(); ++i)
    {
        auto header = request.header(i);
        auto key = std::get<0>(header);
        auto value = std::get<1>(header);

        if (CppCommon::StringUtils::CompareNoCase(key, "Connection"))
        {
            if (!CppCommon::StringUtils::CompareNoCase(value, "Upgrade") && !CppCommon::StringUtils::CompareNoCase(CppCommon::StringUtils::RemoveBlank(value), "keep-alive,Upgrade"))
            {
                error = true;
                response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Connection' header value must be 'Upgrade' or 'keep-alive, Upgrade'");
                break;
            }

            connection = true;
        }
        else if (CppCommon::StringUtils::CompareNoCase(key, "Upgrade"))
        {
            if (!CppCommon::StringUtils::CompareNoCase(value, "websocket"))
            {
                error = true;
                response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Upgrade' header value must be 'websocket'");
                break;
            }

            upgrade = true;
        }
        else if (CppCommon::StringUtils::CompareNoCase(key, "Sec-WebSocket-Key"))
        {
            if (value.empty())
            {
                error = true;
                response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Key' header value must be non empty");
                break;
            }

            // Calculate WebSocket accept value
            std::string wskey = std::string(value) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            char wshash[SHA_DIGEST_LENGTH];
            SHA1((const unsigned char*)wskey.data(), wskey.size(), (unsigned char*)wshash);

            accept = CppCommon::Encoding::Base64Encode(std::string(wshash, sizeof(wshash)));

            ws_key = true;
        }
        else if (CppCommon::StringUtils::CompareNoCase(key, "Sec-WebSocket-Version"))
        {
            if (!CppCommon::StringUtils::CompareNoCase(value, "13"))
            {
                error = true;
                response.MakeErrorResponse(400, "Invalid WebSocket handshaked request: 'Sec-WebSocket-Version' header value must be '13'");
                break;
            }

            ws_version = true;
        }
    }

    // Filter out non WebSocket handshake requests
    if (!connection && !upgrade && !ws_key && !ws_version)
        return false;

    // Failed to perform WebSocket handshake
    if (!connection || !upgrade || !ws_key || !ws_version)
    {
        if (!error)
            response.MakeErrorResponse(400, "Invalid WebSocket response");
        SendResponse(response);
        return false;
    }

    // Prepare WebSocket upgrade success response
    response.Clear();
    response.SetBegin(101, "HTTP/1.1");
    response.SetHeader("Connection", "Upgrade");
    response.SetHeader("Upgrade", "websocket");
    response.SetHeader("Sec-WebSocket-Accept", accept);
    response.SetBody();

    // Validate WebSocket upgrade request and response
    if (!onWSConnecting(request, response))
        return false;

    // Send WebSocket upgrade response
    SendResponse(response);

    // WebSocket successfully handshaked!
    _ws_handshaked = true;
    *((uint32_t*)_ws_send_mask) = 0;
    onWSConnected(request);

    return true;
}

void WebSocket::PrepareSendFrame(uint8_t opcode, bool mask, const void* buffer, size_t size, int status)
{
    // Check if we need to store additional 2 bytes of close status frame
    bool store_status = ((opcode & WS_CLOSE) == WS_CLOSE) && ((size > 0) || (status != 0));
    if (store_status)
        size += 2;

    // Clear the previous WebSocket send buffer
    _ws_send_buffer.clear();

    // Append WebSocket frame opcode
    _ws_send_buffer.push_back(opcode);

    // Append WebSocket frame size
    if (size <= 125)
        _ws_send_buffer.push_back((size & 0xFF) | (mask ? 0x80 : 0));
    else if (size <= 65535)
    {
        _ws_send_buffer.push_back(126 | (mask ? 0x80 : 0));
        _ws_send_buffer.push_back((size >> 8) & 0xFF);
        _ws_send_buffer.push_back(size & 0xFF);
    }
    else
    {
        _ws_send_buffer.push_back(127 | (mask ? 0x80 : 0));
        for (int i = 7; i >= 0; --i)
            _ws_send_buffer.push_back((size >> (8 * i)) & 0xFF);
    }

    if (mask)
    {
        // Append WebSocket frame mask
        _ws_send_buffer.push_back(_ws_send_mask[0]);
        _ws_send_buffer.push_back(_ws_send_mask[1]);
        _ws_send_buffer.push_back(_ws_send_mask[2]);
        _ws_send_buffer.push_back(_ws_send_mask[3]);
    }

    // Resize WebSocket frame buffer
    size_t offset = _ws_send_buffer.size();
    _ws_send_buffer.resize(offset + size);

    size_t index = 0;
    const uint8_t* data = (const uint8_t*)buffer;

    // Append WebSocket close status
    // RFC 6455: If there is a body, the first two bytes of the body MUST
    // be a 2-byte unsigned integer (in network byte order) representing
    // a status code with value code.
    if (store_status)
    {
        index += 2;
        _ws_send_buffer[offset + 0] = ((status >> 8) & 0xFF) ^ _ws_send_mask[0];
        _ws_send_buffer[offset + 1] = (status & 0xFF) ^ _ws_send_mask[1];
    }

    // Mask WebSocket frame content
    for (size_t i = index; i < size; ++i)
        _ws_send_buffer[offset + i] = data[i - index] ^ _ws_send_mask[i % 4];
}

void WebSocket::PrepareReceiveFrame(const void* buffer, size_t size)
{
    const uint8_t* data = (const uint8_t*)buffer;

    // Clear received data after WebSocket frame was processed
    if (_ws_frame_received)
    {
        _ws_frame_received = false;
        _ws_header_size = 0;
        _ws_payload_size = 0;
        _ws_receive_frame_buffer.clear();
        *((uint32_t*)_ws_receive_mask) = 0;
    }
    if (_ws_final_received)
    {
        _ws_final_received = false;
        _ws_receive_final_buffer.clear();
    }

    while (size > 0)
    {
        // Clear received data after WebSocket frame was processed
        if (_ws_frame_received)
        {
            _ws_frame_received = false;
            _ws_header_size = 0;
            _ws_payload_size = 0;
            _ws_receive_frame_buffer.clear();
            *((uint32_t*)_ws_receive_mask) = 0;
        }
        if (_ws_final_received)
        {
            _ws_final_received = false;
            _ws_receive_final_buffer.clear();
        }

        // Prepare WebSocket frame opcode and mask flag
        if (_ws_receive_frame_buffer.size() < 2)
        {
            for (size_t i = 0; i < 2; ++i, ++data, --size)
            {
                if (size == 0)
                    return;
                _ws_receive_frame_buffer.push_back(*data);
            }
        }

        uint8_t opcode = _ws_receive_frame_buffer[0] & 0x0F;
        bool fin = ((_ws_receive_frame_buffer[0] >> 7) & 0x01) != 0;
        bool mask = ((_ws_receive_frame_buffer[1] >> 7) & 0x01) != 0;
        size_t payload = _ws_receive_frame_buffer[1] & (~0x80);

        // Prepare WebSocket opcode
        _ws_opcode = (opcode != 0) ? opcode : _ws_opcode;

        // Prepare WebSocket frame size
        if (payload <= 125)
        {
            _ws_header_size = 2 + (mask ? 4 : 0);
            _ws_payload_size = payload;
            _ws_receive_frame_buffer.reserve(_ws_header_size + _ws_payload_size);
            _ws_receive_final_buffer.reserve(_ws_header_size + _ws_payload_size);
        }
        else if (payload == 126)
        {
            if (_ws_receive_frame_buffer.size() < 4)
            {
                for (size_t i = 0; i < 2; ++i, ++data, --size)
                {
                    if (size == 0)
                        return;
                    _ws_receive_frame_buffer.push_back(*data);
                }
            }

            payload = (((size_t)_ws_receive_frame_buffer[2] << 8) | ((size_t)_ws_receive_frame_buffer[3] << 0));
            _ws_header_size = 4 + (mask ? 4 : 0);
            _ws_payload_size = payload;
            _ws_receive_frame_buffer.reserve(_ws_header_size + _ws_payload_size);
            _ws_receive_final_buffer.reserve(_ws_header_size + _ws_payload_size);
        }
        else if (payload == 127)
        {
            if (_ws_receive_frame_buffer.size() < 10)
            {
                for (size_t i = 0; i < 8; ++i, ++data, --size)
                {
                    if (size == 0)
                        return;
                    _ws_receive_frame_buffer.push_back(*data);
                }
            }

            payload = (((size_t)_ws_receive_frame_buffer[2] << 56) | ((size_t)_ws_receive_frame_buffer[3] << 48) | ((size_t)_ws_receive_frame_buffer[4] << 40) | ((size_t)_ws_receive_frame_buffer[5] << 32) | ((size_t)_ws_receive_frame_buffer[6] << 24) | ((size_t)_ws_receive_frame_buffer[7] << 16) | ((size_t)_ws_receive_frame_buffer[8] << 8) | ((size_t)_ws_receive_frame_buffer[9] << 0));
            _ws_header_size = 10 + (mask ? 4 : 0);
            _ws_payload_size = payload;
            _ws_receive_frame_buffer.reserve(_ws_header_size + _ws_payload_size);
            _ws_receive_final_buffer.reserve(_ws_header_size + _ws_payload_size);
        }

        // Prepare WebSocket frame mask
        if (mask)
        {
            if (_ws_receive_frame_buffer.size() < _ws_header_size)
            {
                for (size_t i = 0; i < 4; ++i, ++data, --size)
                {
                    if (size == 0)
                        return;
                    _ws_receive_frame_buffer.push_back(*data);
                    _ws_receive_mask[i] = *data;
                }
            }
        }

        size_t total = _ws_header_size + _ws_payload_size;
        size_t length = std::min(total - _ws_receive_frame_buffer.size(), size);

        // Prepare WebSocket frame payload
        _ws_receive_frame_buffer.insert(_ws_receive_frame_buffer.end(), data, data + length);
        data += length;
        size -= length;

        // Process WebSocket frame
        if (_ws_receive_frame_buffer.size() == total)
        {
            // Unmask WebSocket frame content
            if (mask)
            {
                for (size_t i = 0; i < _ws_payload_size; ++i)
                    _ws_receive_final_buffer.push_back(_ws_receive_frame_buffer[_ws_header_size + i] ^ _ws_receive_mask[i % 4]);
            }
            else
                _ws_receive_final_buffer.insert(_ws_receive_final_buffer.end(), _ws_receive_frame_buffer.begin() + _ws_header_size, _ws_receive_frame_buffer.end());

            _ws_frame_received = true;

            // Finalize WebSocket frame
            if (fin)
            {
                _ws_final_received = true;

                switch (_ws_opcode)
                {
                    case WS_PING:
                    {
                        // Call the WebSocket ping handler
                        onWSPing(_ws_receive_final_buffer.data(), _ws_receive_final_buffer.size());
                        break;
                    }
                    case WS_PONG:
                    {
                        // Call the WebSocket pong handler
                        onWSPong(_ws_receive_final_buffer.data(), _ws_receive_final_buffer.size());
                        break;
                    }
                    case WS_CLOSE:
                    {
                        size_t sindex = 0;
                        int status = 1000;

                        // Read WebSocket close status
                        if (_ws_receive_final_buffer.size() >= 2)
                        {
                            sindex += 2;
                            status = ((_ws_receive_final_buffer[0] << 8) | (_ws_receive_final_buffer[1] << 0));
                        }

                        // Call the WebSocket close handler
                        onWSClose(_ws_receive_final_buffer.data() + sindex, _ws_receive_final_buffer.size() - sindex, status);
                        break;
                    }
                    case WS_BINARY:
                    case WS_TEXT:
                    {
                        // Call the WebSocket received handler
                        onWSReceived(_ws_receive_final_buffer.data(), _ws_receive_final_buffer.size());
                        break;
                    }
                }
            }
        }
    }
}

size_t WebSocket::RequiredReceiveFrameSize()
{
    if (_ws_frame_received)
        return 0;

    // Required WebSocket frame opcode and mask flag
    if (_ws_receive_frame_buffer.size() < 2)
        return 2 - _ws_receive_frame_buffer.size();

    bool mask = ((_ws_receive_frame_buffer[1] >> 7) & 0x01) != 0;
    size_t payload = _ws_receive_frame_buffer[1] & (~0x80);

    // Required WebSocket frame size
    if ((payload == 126) && (_ws_receive_frame_buffer.size() < 4))
        return 4 - _ws_receive_frame_buffer.size();
    if ((payload == 127) && (_ws_receive_frame_buffer.size() < 10))
        return 10 - _ws_receive_frame_buffer.size();

    // Required WebSocket frame mask
    if ((mask) && (_ws_receive_frame_buffer.size() < _ws_header_size))
        return _ws_header_size - _ws_receive_frame_buffer.size();

    // Required WebSocket frame payload
    return _ws_header_size + _ws_payload_size - _ws_receive_frame_buffer.size();
}

void WebSocket::ClearWSBuffers()
{
    _ws_frame_received = false;
    _ws_final_received = false;
    _ws_header_size = 0;
    _ws_payload_size = 0;
    _ws_receive_frame_buffer.clear();
    _ws_receive_final_buffer.clear();
    *((uint32_t*)_ws_receive_mask) = 0;

    std::scoped_lock locker(_ws_send_lock);

    _ws_send_buffer.clear();
    *((uint32_t*)_ws_send_mask) = 0;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/ws_client.cpp`:

```cpp
/*!
    \file ws_client.cpp
    \brief WebSocket client implementation
    \author Ivan Shynkarenka
    \date 22.05.2019
    \copyright MIT License
*/

#include "server/ws/ws_client.h"

namespace CppServer {
namespace WS {

bool WSClient::Connect()
{
    _sync_connect = true;
    return HTTPClient::Connect();
}

bool WSClient::Connect(const std::shared_ptr<Asio::TCPResolver>& resolver)
{
    _sync_connect = true;
    return HTTPClient::Connect(resolver);
}

bool WSClient::ConnectAsync()
{
    _sync_connect = false;
    return HTTPClient::ConnectAsync();
}

bool WSClient::ConnectAsync(const std::shared_ptr<Asio::TCPResolver>& resolver)
{
    _sync_connect = false;
    return HTTPClient::ConnectAsync(resolver);
}

void WSClient::onConnected()
{
    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Fill the WebSocket upgrade HTTP request
    onWSConnecting(_request);

    // Set empty body of the WebSocket upgrade HTTP request
    _request.SetBody();

    // Send the WebSocket upgrade HTTP request
    if (_sync_connect)
        Send(_request.cache());
    else
        SendAsync(_request.cache());
}

void WSClient::onDisconnected()
{
    // Disconnect WebSocket
    if (_ws_handshaked)
    {
        _ws_handshaked = false;
        onWSDisconnected();
    }

    // Reset WebSocket upgrade HTTP request and response
    _request.Clear();
    _response.Clear();

    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Initialize new WebSocket random nonce
    InitWSNonce();
}

void WSClient::onReceived(const void* buffer, size_t size)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame
        PrepareReceiveFrame(buffer, size);
        return;
    }

    HTTPClient::onReceived(buffer, size);
}

void WSClient::onReceivedResponseHeader(const HTTP::HTTPResponse& response)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
        return;

    // Try to perform WebSocket upgrade
    if (!PerformClientUpgrade(response, id()))
    {
        HTTPClient::onReceivedResponseHeader(response);
        return;
    }
}

void WSClient::onReceivedResponse(const HTTP::HTTPResponse& response)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame from the remaining response body
        auto body = response.body();
        PrepareReceiveFrame(body.data(), body.size());
        return;
    }

    HTTPClient::onReceivedResponse(response);
}

void WSClient::onReceivedResponseError(const HTTP::HTTPResponse& response, const std::string& error)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        onError(asio::error::fault, "WebSocket error", error);
        return;
    }

    HTTPClient::onReceivedResponseError(response, error);
}

std::string WSClient::ReceiveText()
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPClient::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::string WSClient::ReceiveText(const CppCommon::Timespan& timeout)
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPClient::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSClient::ReceiveBinary()
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPClient::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSClient::ReceiveBinary(const CppCommon::Timespan& timeout)
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPClient::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/ws_server.cpp`:

```cpp
/*!
    \file ws_server.cpp
    \brief WebSocket server implementation
    \author Ivan Shynkarenka
    \date 27.05.2019
    \copyright MIT License
*/

#include "server/ws/ws_server.h"

namespace CppServer {
namespace WS {

bool WSServer::CloseAll(int status, const void* buffer, size_t size)
{
    std::scoped_lock locker(_ws_send_lock);

    PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status);
    if (!Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()))
        return false;

    return HTTPServer::DisconnectAll();
}

bool WSServer::CloseAll(int status, std::string_view text)
{
    std::scoped_lock locker(_ws_send_lock);

    PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status);
    if (!Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()))
        return false;

    return HTTPServer::DisconnectAll();
}

bool WSServer::Multicast(const void* buffer, size_t size)
{
    if (!IsStarted())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Multicast all WebSocket sessions
    for (auto& session : _sessions)
    {
        auto ws_session = std::dynamic_pointer_cast<WSSession>(session.second);
        if (ws_session)
        {
            std::scoped_lock ws_locker(ws_session->_ws_send_lock);

            if (ws_session->_ws_handshaked)
                ws_session->SendAsync(buffer, size);
        }
    }

    return true;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/ws_session.cpp`:

```cpp
/*!
    \file ws_session.cpp
    \brief WebSocket session implementation
    \author Ivan Shynkarenka
    \date 27.05.2019
    \copyright MIT License
*/

#include "server/ws/ws_session.h"
#include "server/ws/ws_server.h"

namespace CppServer {
namespace WS {

WSSession::WSSession(const std::shared_ptr<WSServer>& server)
    : HTTP::HTTPSession(server)
{
}

void WSSession::onDisconnected()
{
    // Disconnect WebSocket
    if (_ws_handshaked)
    {
        _ws_handshaked = false;
        onWSDisconnected();
    }

    // Reset WebSocket upgrade HTTP request and response
    _request.Clear();
    _response.Clear();

    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Initialize new WebSocket random nonce
    InitWSNonce();
}

void WSSession::onReceived(const void* buffer, size_t size)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame
        PrepareReceiveFrame(buffer, size);
        return;
    }

    HTTPSession::onReceived(buffer, size);
}

void WSSession::onReceivedRequestHeader(const HTTP::HTTPRequest& request)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
        return;

    // Try to perform WebSocket upgrade
    if (!PerformServerUpgrade(request, response()))
    {
        HTTPSession::onReceivedRequestHeader(request);
        return;
    }
}

void WSSession::onReceivedRequest(const HTTP::HTTPRequest& request)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame from the remaining request body
        auto body = _request.body();
        PrepareReceiveFrame(body.data(), body.size());
        return;
    }

    HTTPSession::onReceivedRequest(request);
}

void WSSession::onReceivedRequestError(const HTTP::HTTPRequest& request, const std::string& error)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        onError(asio::error::fault, "WebSocket error", error);
        return;
    }

    HTTPSession::onReceivedRequestError(request, error);
}

std::string WSSession::ReceiveText()
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSession::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::string WSSession::ReceiveText(const CppCommon::Timespan& timeout)
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSession::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSession::ReceiveBinary()
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSession::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSession::ReceiveBinary(const CppCommon::Timespan& timeout)
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSession::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/wss_client.cpp`:

```cpp
/*!
    \file wss_client.cpp
    \brief WebSocket secure client implementation
    \author Ivan Shynkarenka
    \date 23.05.2019
    \copyright MIT License
*/

#include "server/ws/wss_client.h"

namespace CppServer {
namespace WS {

bool WSSClient::Connect()
{
    _sync_connect = true;
    return HTTPSClient::Connect();
}

bool WSSClient::Connect(const std::shared_ptr<Asio::TCPResolver>& resolver)
{
    _sync_connect = true;
    return HTTPSClient::Connect(resolver);
}

bool WSSClient::ConnectAsync()
{
    _sync_connect = false;
    return HTTPSClient::ConnectAsync();
}

bool WSSClient::ConnectAsync(const std::shared_ptr<Asio::TCPResolver>& resolver)
{
    _sync_connect = false;
    return HTTPSClient::ConnectAsync(resolver);
}

void WSSClient::onHandshaked()
{
    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Fill the WebSocket upgrade HTTP request
    onWSConnecting(_request);

    // Set empty body of the WebSocket upgrade HTTP request
    _request.SetBody();

    // Send the WebSocket upgrade HTTP request
    if (_sync_connect)
        Send(_request.cache());
    else
        SendAsync(_request.cache());
}

void WSSClient::onDisconnected()
{
    // Disconnect WebSocket
    if (_ws_handshaked)
    {
        _ws_handshaked = false;
        onWSDisconnected();
    }

    // Reset WebSocket upgrade HTTP request and response
    _request.Clear();
    _response.Clear();

    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Initialize new WebSocket random nonce
    InitWSNonce();
}

void WSSClient::onReceived(const void* buffer, size_t size)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame
        PrepareReceiveFrame(buffer, size);
        return;
    }

    HTTPSClient::onReceived(buffer, size);
}

void WSSClient::onReceivedResponseHeader(const HTTP::HTTPResponse& response)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
        return;

    // Try to perform WebSocket upgrade
    if (!PerformClientUpgrade(response, id()))
    {
        HTTPSClient::onReceivedResponseHeader(response);
        return;
    }
}

void WSSClient::onReceivedResponse(const HTTP::HTTPResponse& response)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame from the remaining response body
        auto body = response.body();
        PrepareReceiveFrame(body.data(), body.size());
        return;
    }

    HTTPSClient::onReceivedResponse(response);
}

void WSSClient::onReceivedResponseError(const HTTP::HTTPResponse& response, const std::string& error)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        onError(asio::error::fault, "WebSocket error", error);
        return;
    }

    HTTPSClient::onReceivedResponseError(response, error);
}

std::string WSSClient::ReceiveText()
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSClient::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::string WSSClient::ReceiveText(const CppCommon::Timespan& timeout)
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSClient::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSClient::ReceiveBinary()
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSClient::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSClient::ReceiveBinary(const CppCommon::Timespan& timeout)
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSClient::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/wss_server.cpp`:

```cpp
/*!
    \file wss_server.cpp
    \brief WebSocket secure server implementation
    \author Ivan Shynkarenka
    \date 27.05.2019
    \copyright MIT License
*/

#include "server/ws/wss_server.h"

namespace CppServer {
namespace WS {

bool WSSServer::CloseAll(int status, const void* buffer, size_t size)
{
    std::scoped_lock locker(_ws_send_lock);

    PrepareSendFrame(WS_FIN | WS_CLOSE, false, buffer, size, status);
    if (!Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()))
        return false;

    return HTTPSServer::DisconnectAll();
}

bool WSSServer::CloseAll(int status, std::string_view text)
{
    std::scoped_lock locker(_ws_send_lock);

    PrepareSendFrame(WS_FIN | WS_CLOSE, false, text.data(), text.size(), status);
    if (!Multicast(_ws_send_buffer.data(), _ws_send_buffer.size()))
        return false;

    return HTTPSServer::DisconnectAll();
}

bool WSSServer::Multicast(const void* buffer, size_t size)
{
    if (!IsStarted())
        return false;

    if (size == 0)
        return true;

    assert((buffer != nullptr) && "Pointer to the buffer should not be null!");
    if (buffer == nullptr)
        return false;

    std::shared_lock<std::shared_mutex> locker(_sessions_lock);

    // Multicast all WebSocket sessions
    for (auto& session : _sessions)
    {
        auto wss_session = std::dynamic_pointer_cast<WSSSession>(session.second);
        if (wss_session)
        {
            std::scoped_lock ws_locker(wss_session->_ws_send_lock);

            if (wss_session->_ws_handshaked)
                wss_session->SendAsync(buffer, size);
        }
    }

    return true;
}

} // namespace WS
} // namespace CppServer

```

`source/server/ws/wss_session.cpp`:

```cpp
/*!
    \file wss_session.cpp
    \brief WebSocket secure session implementation
    \author Ivan Shynkarenka
    \date 28.05.2019
    \copyright MIT License
*/

#include "server/ws/wss_session.h"
#include "server/ws/wss_server.h"

namespace CppServer {
namespace WS {

WSSSession::WSSSession(const std::shared_ptr<WSSServer>& server)
    : HTTP::HTTPSSession(server)
{
}

void WSSSession::onDisconnected()
{
    // Disconnect WebSocket
    if (_ws_handshaked)
    {
        _ws_handshaked = false;
        onWSDisconnected();
    }

    // Reset WebSocket upgrade HTTP request and response
    _request.Clear();
    _response.Clear();

    // Clear WebSocket send/receive buffers
    ClearWSBuffers();

    // Initialize new WebSocket random nonce
    InitWSNonce();
}

void WSSSession::onReceived(const void* buffer, size_t size)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame
        PrepareReceiveFrame(buffer, size);
        return;
    }

    HTTPSSession::onReceived(buffer, size);
}

void WSSSession::onReceivedRequestHeader(const HTTP::HTTPRequest& request)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
        return;

    // Try to perform WebSocket upgrade
    if (!PerformServerUpgrade(request, response()))
    {
        HTTPSSession::onReceivedRequestHeader(request);
        return;
    }
}

void WSSSession::onReceivedRequest(const HTTP::HTTPRequest& request)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        // Prepare receive frame from the remaining request body
        auto body = _request.body();
        PrepareReceiveFrame(body.data(), body.size());
        return;
    }

    HTTPSSession::onReceivedRequest(request);
}

void WSSSession::onReceivedRequestError(const HTTP::HTTPRequest& request, const std::string& error)
{
    // Check for WebSocket handshaked status
    if (_ws_handshaked)
    {
        onError(asio::error::fault, "WebSocket error", error);
        return;
    }

    HTTPSSession::onReceivedRequestError(request, error);
}

std::string WSSSession::ReceiveText()
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSSession::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::string WSSSession::ReceiveText(const CppCommon::Timespan& timeout)
{
    std::string result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSSession::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSSession::ReceiveBinary()
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSSession::Receive(cache.data(), required);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

std::vector<uint8_t> WSSSession::ReceiveBinary(const CppCommon::Timespan& timeout)
{
    std::vector<uint8_t> result;

    if (!_ws_handshaked)
        return result;

    std::vector<uint8_t> cache;

    // Receive WebSocket frame data
    while (!_ws_final_received)
    {
        while (!_ws_frame_received)
        {
            size_t required = RequiredReceiveFrameSize();
            cache.resize(required);
            size_t received = HTTPSSession::Receive(cache.data(), required, timeout);
            if (received != required)
                return result;
            PrepareReceiveFrame(cache.data(), received);
        }
        if (!_ws_final_received)
            PrepareReceiveFrame(nullptr, 0);
    }

    // Copy WebSocket frame data
    result.insert(result.end(), _ws_receive_final_buffer.data() + _ws_header_size, _ws_receive_final_buffer.data() + _ws_header_size + _ws_payload_size);
    PrepareReceiveFrame(nullptr, 0);
    return result;
}

} // namespace WS
} // namespace CppServer

```

`tests/test.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 26.05.2016
//

#include "test.h"

```

`tests/test.h`:

```h
//
// Created by Ivan Shynkarenka on 26.05.2016
//

#include <catch_amalgamated.hpp>

```

`tests/test_http.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 08.05.2019
//

#include "test.h"

#include "server/http/http_client.h"
#include "server/http/http_server.h"
#include "string/string_utils.h"
#include "threads/thread.h"

#include <map>
#include <mutex>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPCacheSession : public HTTPSession
{
public:
    using HTTPSession::HTTPSession;

protected:
    void onReceivedRequest(const HTTPRequest& request) override
    {
        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
        FAIL();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        FAIL();
    }
};

class HTTPCacheServer : public HTTPServer
{
public:
    using HTTPServer::HTTPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override
    {
        return std::make_shared<HTTPCacheSession>(std::dynamic_pointer_cast<HTTPServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTP server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        FAIL();
    }
};

TEST_CASE("HTTP server & client test", "[CppServer][HTTP]")
{
    // HTTP server address and port
    std::string address = "127.0.0.1";
    int port = 8080;

    // Create and start Asio service
    auto service = std::make_shared<Service>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start HTTP server
    auto server = std::make_shared<HTTPCacheServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create a new HTTP client
    auto client = std::make_shared<HTTPClientEx>(service, address, port);

    // Test CRUD operations
    auto response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 404);
    response = client->SendPostRequest("/test", "old_value").get();
    REQUIRE(response.status() == 200);
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "old_value");
    response = client->SendPutRequest("/test", "new_value").get();
    REQUIRE(response.status() == 200);
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "new_value");
    response = client->SendDeleteRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "new_value");
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 404);

    // Stop the HTTP server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();
}

```

`tests/test_https.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 08.05.2019
//

#include "test.h"

#include "server/http/https_client.h"
#include "server/http/https_server.h"
#include "string/string_utils.h"
#include "threads/thread.h"

#include <map>
#include <mutex>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::HTTP;

class Cache : public CppCommon::Singleton<Cache>
{
   friend CppCommon::Singleton<Cache>;

public:
    std::string GetAllCache()
    {
        std::scoped_lock locker(_cache_lock);
        std::string result;
        result += "[\n";
        for (const auto& item : _cache)
        {
            result += "  {\n";
            result += "    \"key\": \"" + item.first + "\",\n";
            result += "    \"value\": \"" + item.second + "\",\n";
            result += "  },\n";
        }
        result += "]\n";
        return result;
    }

    bool GetCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            return true;
        }
        else
            return false;
    }

    void PutCacheValue(std::string_view key, std::string_view value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.emplace(key, value);
        if (!it.second)
            it.first->second = value;
    }

    bool DeleteCacheValue(std::string_view key, std::string& value)
    {
        std::scoped_lock locker(_cache_lock);
        auto it = _cache.find(key);
        if (it != _cache.end())
        {
            value = it->second;
            _cache.erase(it);
            return true;
        }
        else
            return false;
    }

private:
    std::mutex _cache_lock;
    std::map<std::string, std::string, std::less<>> _cache;
};

class HTTPSCacheSession : public HTTPSSession
{
public:
    using HTTPSSession::HTTPSSession;

protected:
    void onReceivedRequest(const HTTPRequest& request) override
    {
        // Process HTTP request methods
        if (request.method() == "HEAD")
            SendResponseAsync(response().MakeHeadResponse());
        else if (request.method() == "GET")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            if (key.empty())
            {
                // Response with all cache values
                SendResponseAsync(response().MakeGetResponse(Cache::GetInstance().GetAllCache(), "application/json; charset=UTF-8"));
            }
            // Get the cache value by the given key
            else if (Cache::GetInstance().GetCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Required cache value was not found for the key: " + key));
        }
        else if ((request.method() == "POST") || (request.method() == "PUT"))
        {
            std::string key(request.url());
            std::string value(request.body());

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Put the cache value
            Cache::GetInstance().PutCacheValue(key, value);

            // Response with the cache value
            SendResponseAsync(response().MakeOKResponse());
        }
        else if (request.method() == "DELETE")
        {
            std::string key(request.url());
            std::string value;

            // Decode the key value
            key = CppCommon::Encoding::URLDecode(key);
            CppCommon::StringUtils::ReplaceFirst(key, "/api/cache", "");
            CppCommon::StringUtils::ReplaceFirst(key, "?key=", "");

            // Delete the cache value
            if (Cache::GetInstance().DeleteCacheValue(key, value))
            {
                // Response with the cache value
                SendResponseAsync(response().MakeGetResponse(value));
            }
            else
                SendResponseAsync(response().MakeErrorResponse(404, "Deleted cache value was not found for the key: " + key));
        }
        else if (request.method() == "OPTIONS")
            SendResponseAsync(response().MakeOptionsResponse());
        else if (request.method() == "TRACE")
            SendResponseAsync(response().MakeTraceResponse(request.cache()));
        else
            SendResponseAsync(response().MakeErrorResponse("Unsupported HTTP method: " + std::string(request.method())));
    }

    void onReceivedRequestError(const HTTPRequest& request, const std::string& error) override
    {
        std::cout << "Request error: " << error << std::endl;
        FAIL();
    }

    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS session caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        FAIL();
    }
};

class HTTPSCacheServer : public HTTPSServer
{
public:
    using HTTPSServer::HTTPSServer;

    static std::shared_ptr<SSLContext> CreateContext()
    {
        auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
        context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
        context->use_certificate_chain_file("../tools/certificates/server.pem");
        context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
        context->use_tmp_dh_file("../tools/certificates/dh4096.pem");
        return context;
    }

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override
    {
        return std::make_shared<HTTPSCacheSession>(std::dynamic_pointer_cast<HTTPSServer>(server));
    }

protected:
    void onError(int error, const std::string& category, const std::string& message) override
    {
        std::cout << "HTTPS server caught an error with code " << error << " and category '" << category << "': " << message << std::endl;
        FAIL();
    }
};

TEST_CASE("HTTPS server & client test", "[CppServer][HTTP]")
{
    // HTTPS server address and port
    std::string address = "127.0.0.1";
    int port = 8443;

    // Create and start Asio service
    auto service = std::make_shared<Service>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = HTTPSCacheServer::CreateContext();

    // Create and start HTTPS server
    auto server = std::make_shared<HTTPSCacheServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL client context
    auto client_context = HTTPSCacheServer::CreateContext();

    // Create a new HTTPS client
    auto client = std::make_shared<HTTPSClientEx>(service, client_context, address, port);

    // Test CRUD operations
    auto response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 404);
    response = client->SendPostRequest("/test", "old_value").get();
    REQUIRE(response.status() == 200);
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "old_value");
    response = client->SendPutRequest("/test", "new_value").get();
    REQUIRE(response.status() == 200);
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "new_value");
    response = client->SendDeleteRequest("/test").get();
    REQUIRE(response.status() == 200);
    REQUIRE(response.body() == "new_value");
    response = client->SendGetRequest("/test").get();
    REQUIRE(response.status() == 404);

    // Stop the HTTPS server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();
}

```

`tests/test_proto.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 07.01.2022
//

#include "test.h"

#include "server/asio/tcp_client.h"
#include "server/asio/tcp_server.h"
#include "threads/thread.h"

#include "../proto/simple_protocol.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class ProtoService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class ProtoClient : public TCPClient, public FBE::simple::Client
{
public:
    using TCPClient::TCPClient;

protected:
    void onConnected() override { reset(); connected = true; }
    void onDisconnected() override { disconnected = true; }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class ProtoSession : public TCPSession, public FBE::simple::Sender, public FBE::simple::Receiver
{
public:
    using TCPSession::TCPSession;

protected:
    void onConnected() override { connected = true; }
    void onDisconnected() override { disconnected = true; }
    void onReceived(const void* buffer, size_t size) override { receive(buffer, size); }
    size_t onSend(const void* data, size_t size) override { return SendAsync(data, size) ? size : 0; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

protected:
    // Protocol handlers
    void onReceive(const ::simple::SimpleRequest& request) override
    {
        // Send response
        simple::SimpleResponse response;
        response.id = request.id;
        response.Hash = 0;
        response.Length = (uint32_t)request.Message.size();
        send(response);
    }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class ProtoServer : public TCPServer, public FBE::simple::Sender
{
public:
    using TCPServer::TCPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override { return std::make_shared<ProtoSession>(server); }

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onConnected(std::shared_ptr<TCPSession>& session) override { connected = true; ++clients; }
    void onDisconnected(std::shared_ptr<TCPSession>& session) override { disconnected = true; --clients; }
    size_t onSend(const void* data, size_t size) override { Multicast(data, size); return size; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> clients{0};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("Protocol server test", "[CppServer][Proto]")
{
    const std::string address = "127.0.0.1";
    const int port = 4444;

    // Create and start Asio service
    auto service = std::make_shared<ProtoService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start protocol server
    auto server = std::make_shared<ProtoServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect protocol client
    auto client = std::make_shared<ProtoClient>(service, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->IsConnected() || !client->connected || (server->clients != 1))
        Thread::Yield();

    // Send a request to the protocol server
    simple::SimpleRequest request;
    request.Message = "test";
    auto response = client->request(request).get();
    REQUIRE(response.id == request.id);
    REQUIRE(response.Hash == 0);
    REQUIRE(response.Length == 4);

    // Disconnect the protocol client
    REQUIRE(client->DisconnectAsync());
    while (client->IsConnected() || (server->clients != 0))
        Thread::Yield();

    // Stop the protocol server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the protocol server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);

    // Check the protocol client state
    REQUIRE(client->connected);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() > 0);
    REQUIRE(client->bytes_received() > 0);
    REQUIRE(!client->errors);
}

TEST_CASE("Protocol multicast test", "[CppServer][Proto]")
{
    const std::string address = "127.0.0.1";
    const int port = 4442;

    // Create and start Asio service
    auto service = std::make_shared<ProtoService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start protocol server
    auto server = std::make_shared<ProtoServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect protocol client
    auto client1 = std::make_shared<ProtoClient>(service, address, port);
    REQUIRE(client1->ConnectAsync());
    while (!client1->IsConnected() || (server->clients != 1))
        Thread::Yield();

    // Create a server notification
    simple::SimpleNotify notify;
    notify.Notification = "test";

    // Multicast the notification to all clients
    server->send(notify);

    // Wait for all data processed...
    while (client1->bytes_received() == 0)
        Thread::Yield();

    // Create and connect protocol client
    auto client2 = std::make_shared<ProtoClient>(service, address, port);
    REQUIRE(client2->ConnectAsync());
    while (!client2->IsConnected() || (server->clients != 2))
        Thread::Yield();

    // Multicast the notification to all clients
    server->send(notify);

    // Wait for all data processed...
    while (client2->bytes_received() == 0)
        Thread::Yield();

    // Create and connect protocol client
    auto client3 = std::make_shared<ProtoClient>(service, address, port);
    REQUIRE(client3->ConnectAsync());
    while (!client3->IsConnected() || (server->clients != 3))
        Thread::Yield();

    // Multicast some data to all clients
    server->send(notify);

    // Wait for all data processed...
    while (client3->bytes_received() == 0)
        Thread::Yield();

    // Disconnect the protocol client
    REQUIRE(client1->DisconnectAsync());
    while (client1->IsConnected() || (server->clients != 2))
        Thread::Yield();

    // Disconnect the protocol client
    REQUIRE(client2->DisconnectAsync());
    while (client2->IsConnected() || (server->clients != 1))
        Thread::Yield();

    // Disconnect the protocol client
    REQUIRE(client3->DisconnectAsync());
    while (client3->IsConnected() || (server->clients != 0))
        Thread::Yield();

    // Stop the protocol server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the protocol server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() == 0);
    REQUIRE(!server->errors);

    // Check the protocol client state
    REQUIRE(client1->bytes_sent() == 0);
    REQUIRE(client2->bytes_sent() == 0);
    REQUIRE(client3->bytes_sent() == 0);
    REQUIRE(client1->bytes_received() > 0);
    REQUIRE(client2->bytes_received() > 0);
    REQUIRE(client3->bytes_received() > 0);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("Protocol server random test", "[CppServer][Proto]")
{
    const std::string address = "127.0.0.1";
    const int port = 4443;

    // Create and start Asio service
    auto service = std::make_shared<ProtoService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start protocol server
    auto server = std::make_shared<ProtoServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Clients collection
    std::vector<std::shared_ptr<ProtoClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Disconnect all clients
        if ((rand() % 1000) == 0)
        {
            server->DisconnectAll();
        }
        // Create a new client and connect
        else if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect protocol client
                auto client = std::make_shared<ProtoClient>(service, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsConnected())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->DisconnectAsync();
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else
                {
                    client->ConnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->ReconnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Multicast a notification to all clients
        else if ((rand() % 10) == 0)
        {
            simple::SimpleNotify notify;
            notify.Notification = "test";
            server->send(notify);
        }
        // Send a request from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected() && client->connected)
                {
                    simple::SimpleRequest request;
                    request.Message = "test";
                    client->request(request);
                }
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->DisconnectAsync();
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the protocol server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the protocol server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tests/test_ssl.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 01.01.2017
//

#include "test.h"

#include "server/asio/ssl_client.h"
#include "server/asio/ssl_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class EchoSSLService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class EchoSSLClient : public SSLClient
{
public:
    using SSLClient::SSLClient;

    static std::shared_ptr<SSLContext> CreateContext()
    {
        auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
        context->set_default_verify_paths();
        context->set_root_certs();
        context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
        context->load_verify_file("../tools/certificates/ca.pem");
        return context;
    }

protected:
    void onConnected() override { connected = true; }
    void onHandshaked() override { handshaked = true; }
    void onDisconnected() override { disconnected = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> handshaked{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoSSLSession : public SSLSession
{
public:
    using SSLSession::SSLSession;

protected:
    void onConnected() override { connected = true; }
    void onHandshaked() override { handshaked = true; }
    void onDisconnected() override { disconnected = true; }
    void onReceived(const void* buffer, size_t size) override { SendAsync(buffer, size); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> handshaked{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoSSLServer : public SSLServer
{
public:
    using SSLServer::SSLServer;

    static std::shared_ptr<SSLContext> CreateContext()
    {
        auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
        context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
        context->use_certificate_chain_file("../tools/certificates/server.pem");
        context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
        context->use_tmp_dh_file("../tools/certificates/dh4096.pem");
        return context;
    }

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override { return std::make_shared<EchoSSLSession>(server); }

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onConnected(std::shared_ptr<SSLSession>& session) override { connected = true; }
    void onHandshaked(std::shared_ptr<SSLSession>& session) override { handshaked = true; ++clients; }
    void onDisconnected(std::shared_ptr<SSLSession>& session) override { disconnected = true; --clients; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> connected{false};
    std::atomic<bool> handshaked{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> clients{0};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("SSL server test", "[CppServer][SSL]")
{
    const std::string address = "127.0.0.1";
    const int port = 2222;

    // Create and start Asio service
    auto service = std::make_shared<EchoSSLService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoSSLServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoSSLServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL client context
    auto client_context = EchoSSLServer::CreateContext();

    // Create and connect Echo client
    auto client = std::make_shared<EchoSSLClient>(service, client_context, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->IsConnected() || !client->IsHandshaked() || (server->clients != 1))
        Thread::Yield();

    // Send a message to the Echo server
    client->SendAsync("test");

    // Wait for all data processed...
    while (client->bytes_received() != 4)
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client->DisconnectAsync());
    while (client->IsConnected() || client->IsHandshaked() || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->handshaked);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() == 4);
    REQUIRE(server->bytes_received() == 4);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client->connected);
    REQUIRE(client->handshaked);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() == 4);
    REQUIRE(client->bytes_received() == 4);
    REQUIRE(!client->errors);
}

TEST_CASE("SSL server multicast test", "[CppServer][SSL]")
{
    const std::string address = "127.0.0.1";
    const int port = 2223;

    // Create and start Asio service
    auto service = std::make_shared<EchoSSLService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoSSLServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoSSLServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL client context
    auto client_context = EchoSSLClient::CreateContext();

    // Create and connect Echo client
    auto client1 = std::make_shared<EchoSSLClient>(service, client_context, address, port);
    REQUIRE(client1->ConnectAsync());
    while (!client1->IsConnected() || !client1->IsHandshaked() || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while (client1->bytes_received() != 4)
        Thread::Yield();

    // Create and connect Echo client
    auto client2 = std::make_shared<EchoSSLClient>(service, client_context, address, port);
    REQUIRE(client2->ConnectAsync());
    while (!client2->IsConnected() || !client2->IsHandshaked() || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 8) || (client2->bytes_received() != 4))
        Thread::Yield();

    // Create and connect Echo client
    auto client3 = std::make_shared<EchoSSLClient>(service, client_context, address, port);
    REQUIRE(client3->ConnectAsync());
    while (!client3->IsConnected() || !client3->IsHandshaked() || (server->clients != 3))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 8) || (client3->bytes_received() != 4))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client1->DisconnectAsync());
    while (client1->IsConnected() || client1->IsHandshaked() || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 8))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client2->DisconnectAsync());
    while (client2->IsConnected() || client2->IsHandshaked() || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 12))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client3->DisconnectAsync());
    while (client3->IsConnected() || client3->IsHandshaked() || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->handshaked);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() == 36);
    REQUIRE(server->bytes_received() == 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client1->bytes_sent() == 0);
    REQUIRE(client2->bytes_sent() == 0);
    REQUIRE(client3->bytes_sent() == 0);
    REQUIRE(client1->bytes_received() == 12);
    REQUIRE(client2->bytes_received() == 12);
    REQUIRE(client3->bytes_received() == 12);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("SSL server random test", "[CppServer][SSL]")
{
    const std::string address = "127.0.0.1";
    const int port = 2224;

    // Create and start Asio service
    auto service = std::make_shared<EchoSSLService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoSSLServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoSSLServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Create and prepare a new SSL client context
    auto client_context = EchoSSLClient::CreateContext();

    // Clients collection
    std::vector<std::shared_ptr<EchoSSLClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Disconnect all clients
        if ((rand() % 1000) == 0)
        {
            server->DisconnectAll();
        }
        // Create a new client and connect
        else if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect Echo client
                auto client = std::make_shared<EchoSSLClient>(service, client_context, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsHandshaked())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                {
                    client->DisconnectAsync();
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else if (!client->IsConnected())
                {
                    client->ConnectAsync();
                    while (!client->IsHandshaked())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                {
                    client->ReconnectAsync();
                    while (!client->IsHandshaked())
                        Thread::Yield();
                }
            }
        }
        // Multicast a message to all clients
        else if ((rand() % 10) == 0)
        {
            server->Multicast("test");
        }
        // Send a message from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                    client->SendAsync("test");
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->DisconnectAsync();
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->handshaked);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tests/test_tcp.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 16.12.2016
//

#include "test.h"

#include "server/asio/tcp_client.h"
#include "server/asio/tcp_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class EchoTCPService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class EchoTCPClient : public TCPClient
{
public:
    using TCPClient::TCPClient;

protected:
    void onConnected() override { connected = true; }
    void onDisconnected() override { disconnected = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoTCPSession : public TCPSession
{
public:
    using TCPSession::TCPSession;

protected:
    void onConnected() override { connected = true; }
    void onDisconnected() override { disconnected = true; }
    void onReceived(const void* buffer, size_t size) override { SendAsync(buffer, size); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoTCPServer : public TCPServer
{
public:
    using TCPServer::TCPServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override { return std::make_shared<EchoTCPSession>(server); }

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onConnected(std::shared_ptr<TCPSession>& session) override { connected = true; ++clients; }
    void onDisconnected(std::shared_ptr<TCPSession>& session) override { disconnected = true; --clients; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> clients{0};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("TCP server test", "[CppServer][TCP]")
{
    const std::string address = "127.0.0.1";
    const int port = 1111;

    // Create and start Asio service
    auto service = std::make_shared<EchoTCPService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoTCPServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect Echo client
    auto client = std::make_shared<EchoTCPClient>(service, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->IsConnected() || (server->clients != 1))
        Thread::Yield();

    // Send a message to the Echo server
    client->SendAsync("test");

    // Wait for all data processed...
    while (client->bytes_received() != 4)
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client->DisconnectAsync());
    while (client->IsConnected() || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() == 4);
    REQUIRE(server->bytes_received() == 4);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client->connected);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() == 4);
    REQUIRE(client->bytes_received() == 4);
    REQUIRE(!client->errors);
}

TEST_CASE("TCP server multicast test", "[CppServer][TCP]")
{
    const std::string address = "127.0.0.1";
    const int port = 1112;

    // Create and start Asio service
    auto service = std::make_shared<EchoTCPService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoTCPServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect Echo client
    auto client1 = std::make_shared<EchoTCPClient>(service, address, port);
    REQUIRE(client1->ConnectAsync());
    while (!client1->IsConnected() || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while (client1->bytes_received() != 4)
        Thread::Yield();

    // Create and connect Echo client
    auto client2 = std::make_shared<EchoTCPClient>(service, address, port);
    REQUIRE(client2->ConnectAsync());
    while (!client2->IsConnected() || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 8) || (client2->bytes_received() != 4))
        Thread::Yield();

    // Create and connect Echo client
    auto client3 = std::make_shared<EchoTCPClient>(service, address, port);
    REQUIRE(client3->ConnectAsync());
    while (!client3->IsConnected() || (server->clients != 3))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 8) || (client3->bytes_received() != 4))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client1->DisconnectAsync());
    while (client1->IsConnected() || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 8))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client2->DisconnectAsync());
    while (client2->IsConnected() || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 12))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client3->DisconnectAsync());
    while (client3->IsConnected() || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() == 36);
    REQUIRE(server->bytes_received() == 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client1->bytes_sent() == 0);
    REQUIRE(client2->bytes_sent() == 0);
    REQUIRE(client3->bytes_sent() == 0);
    REQUIRE(client1->bytes_received() == 12);
    REQUIRE(client2->bytes_received() == 12);
    REQUIRE(client3->bytes_received() == 12);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("TCP server random test", "[CppServer][TCP]")
{
    const std::string address = "127.0.0.1";
    const int port = 1113;

    // Create and start Asio service
    auto service = std::make_shared<EchoTCPService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoTCPServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Clients collection
    std::vector<std::shared_ptr<EchoTCPClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Disconnect all clients
        if ((rand() % 1000) == 0)
        {
            server->DisconnectAll();
        }
        // Create a new client and connect
        else if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect Echo client
                auto client = std::make_shared<EchoTCPClient>(service, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsConnected())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->DisconnectAsync();
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else
                {
                    client->ConnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->ReconnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Multicast a message to all clients
        else if ((rand() % 10) == 0)
        {
            server->Multicast("test");
        }
        // Send a message from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                    client->SendAsync("test");
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->DisconnectAsync();
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tests/test_timer.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 16.08.2018
//

#include "test.h"

#include "server/asio/timer.h"
#include "threads/thread.h"

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class AsioTimer : public Timer
{
public:
    using Timer::Timer;

protected:
    void onTimer(bool aborted) override
    {
        if (aborted)
            canceled = true;
        else
            expired = true;
    }

    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> canceled{false};
    std::atomic<bool> expired{false};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("Asio timer test", "[CppServer][Timer]")
{
    // Create and start Asio service
    auto service = std::make_shared<Service>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create Asio timer
    auto timer = std::make_shared<AsioTimer>(service);

    // Setup and synchronously wait for the timer
    timer->Setup(UtcTime() + Timespan::seconds(1));
    timer->WaitSync();

    // Setup and asynchronously wait for the timer
    timer->Setup(Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    Thread::Sleep(2000);

    // Setup and asynchronously wait for the timer
    timer->Setup(Timespan::seconds(1));
    timer->WaitAsync();

    // Wait for a while...
    Thread::Sleep(500);

    // Cancel the timer
    timer->Cancel();

    // Wait for a while...
    Thread::Sleep(500);

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the timer state
    REQUIRE(timer->canceled);
    REQUIRE(timer->expired);
    REQUIRE(!timer->errors);
}

```

`tests/test_udp.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 27.12.2016
//

#include "test.h"

#include "server/asio/udp_client.h"
#include "server/asio/udp_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class EchoUDPService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class EchoUDPClient : public UDPClient
{
public:
    using UDPClient::UDPClient;

protected:
    void onConnected() override { connected = true; ReceiveAsync(); }
    void onDisconnected() override { disconnected = true; }
    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override { ReceiveAsync(); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoUDPServer : public UDPServer
{
public:
    using UDPServer::UDPServer;

protected:
    void onStarted() override { started = true; ReceiveAsync(); }
    void onStopped() override { stopped = true; }
    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override { SendAsync(endpoint, buffer, size); }
    void onSent(const asio::ip::udp::endpoint& endpoint, size_t sent) override { ReceiveAsync(); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("UDP server test", "[CppServer][UDP]")
{
    const std::string address = "127.0.0.1";
    const int port = 3333;

    // Create and start Asio service
    auto service = std::make_shared<EchoUDPService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoUDPServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect Echo client
    auto client = std::make_shared<EchoUDPClient>(service, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->IsConnected())
        Thread::Yield();

    // Send a message to the Echo server
    client->Send("test");

    // Wait for all data processed...
    while (client->bytes_received() != 4)
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client->DisconnectAsync());
    while (client->IsConnected())
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->bytes_sent() == 4);
    REQUIRE(server->bytes_received() == 4);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client->connected);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() == 4);
    REQUIRE(client->bytes_received() == 4);
    REQUIRE(!client->errors);
}

TEST_CASE("UDP server random test", "[CppServer][UDP]")
{
    const std::string address = "127.0.0.1";
    const int port = 3334;

    // Create and start Asio service
    auto service = std::make_shared<EchoUDPService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoUDPServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Clients collection
    std::vector<std::shared_ptr<EchoUDPClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Create a new client and connect
        if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect Echo client
                auto client = std::make_shared<EchoUDPClient>(service, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsConnected())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->DisconnectAsync();
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else
                {
                    client->ConnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->ReconnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Send a message from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                    client->Send("test");
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->DisconnectAsync();
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tests/test_udp_multicast.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 27.12.2016
//

#include "test.h"

#include "server/asio/udp_client.h"
#include "server/asio/udp_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;

namespace {

class MulticastUDPService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class MulticastUDPClient : public UDPClient
{
public:
    using UDPClient::UDPClient;

protected:
    void onConnected() override { connected = true; ReceiveAsync(); }
    void onDisconnected() override { disconnected = true; }
    void onReceived(const asio::ip::udp::endpoint& endpoint, const void* buffer, size_t size) override { ReceiveAsync(); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class MulticastUDPServer : public UDPServer
{
public:
    using UDPServer::UDPServer;

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("UDP server multicast test", "[CppServer][UDP]")
{
    const std::string listen_address = "0.0.0.0";
    const std::string multicast_address = "239.255.0.1";
    const int multicast_port = 3335;

    // Create and start Asio service
    auto service = std::make_shared<MulticastUDPService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start multicast server
    auto server = std::make_shared<MulticastUDPServer>(service, 0);
    REQUIRE(server->Start(multicast_address, multicast_port));
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect multicast client
    auto client1 = std::make_shared<MulticastUDPClient>(service, listen_address, multicast_port);
    client1->SetupMulticast(true);
    REQUIRE(client1->ConnectAsync());
    while (!client1->IsConnected())
        Thread::Yield();

    // Join multicast group
    client1->JoinMulticastGroup(multicast_address);

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while (client1->bytes_received() != 4)
        Thread::Yield();

    // Create and connect multicast client
    auto client2 = std::make_shared<MulticastUDPClient>(service, listen_address, multicast_port);
    client2->SetupMulticast(true);
    REQUIRE(client2->ConnectAsync());
    while (!client2->IsConnected())
        Thread::Yield();

    // Join multicast group
    client2->JoinMulticastGroup(multicast_address);

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 8) || (client2->bytes_received() != 4))
        Thread::Yield();

    // Create and connect multicast client
    auto client3 = std::make_shared<MulticastUDPClient>(service, listen_address, multicast_port);
    client3->SetupMulticast(true);
    REQUIRE(client3->ConnectAsync());
    while (!client3->IsConnected())
        Thread::Yield();

    // Join multicast group
    client3->JoinMulticastGroup(multicast_address);

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 8) || (client3->bytes_received() != 4))
        Thread::Yield();

    // Leave multicast group
    client1->LeaveMulticastGroup(multicast_address);

    // Disconnect the multicast client
    REQUIRE(client1->DisconnectAsync());
    while (client1->IsConnected())
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 8))
        Thread::Yield();

    // Leave multicast group
    client2->LeaveMulticastGroup(multicast_address);

    // Disconnect the multicast client
    REQUIRE(client2->DisconnectAsync());
    while (client2->IsConnected())
        Thread::Yield();

    // Multicast some data to all clients
    server->Multicast("test");

    // Wait for all data processed...
    while ((client1->bytes_received() != 12) || (client2->bytes_received() != 12) || (client3->bytes_received() != 12))
        Thread::Yield();

    // Leave multicast group
    client3->LeaveMulticastGroup(multicast_address);

    // Disconnect the multicast client
    REQUIRE(client3->DisconnectAsync());
    while (client3->IsConnected())
        Thread::Yield();

    // Stop the multicast server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the multicast server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->bytes_sent() == 20);
    REQUIRE(server->bytes_received() == 0);
    REQUIRE(!server->errors);

    // Check the multicast client state
    REQUIRE(client1->bytes_sent() == 0);
    REQUIRE(client2->bytes_sent() == 0);
    REQUIRE(client3->bytes_sent() == 0);
    REQUIRE(client1->bytes_received() == 12);
    REQUIRE(client2->bytes_received() == 12);
    REQUIRE(client3->bytes_received() == 12);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("UDP server multicast random test", "[CppServer][UDP]")
{
    const std::string listen_address = "0.0.0.0";
    const std::string multicast_address = "239.255.0.1";
    const int multicast_port = 3336;

    // Create and start Asio service
    auto service = std::make_shared<MulticastUDPService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start multicast server
    auto server = std::make_shared<MulticastUDPServer>(service, 0);
    REQUIRE(server->Start(multicast_address, multicast_port));
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Clients collection
    std::vector<std::shared_ptr<MulticastUDPClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Create a new client and connect
        if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect multicast client
                auto client = std::make_shared<MulticastUDPClient>(service, listen_address, multicast_port);
                clients.emplace_back(client);
                client->SetupMulticast(true);
                client->ConnectAsync();
                while (!client->IsConnected())
                    Thread::Yield();

                // Join multicast group
                client->JoinMulticastGroup(multicast_address);
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    // Leave multicast group
                    client->LeaveMulticastGroup(multicast_address);

                    client->DisconnectAsync();
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else
                {
                    client->ConnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();

                    // Join multicast group
                    client->JoinMulticastGroup(multicast_address);
                }
            }
        }
        // Multicast a message to all clients
        else if ((rand() % 10) == 0)
        {
            server->Multicast("test");
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->DisconnectAsync();
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the multicast server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the multicast server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() == 0);
    REQUIRE(!server->errors);
}

```

`tests/test_ws.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.05.2019
//

#include "test.h"

#include "server/ws/ws_client.h"
#include "server/ws/ws_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

namespace {

class EchoWSService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class EchoWSClient : public WSClient
{
public:
    using WSClient::WSClient;

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "http://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }
    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override { connected = true; }
    void onWSDisconnected() override { disconnected = true; }
    void onWSReceived(const void* buffer, size_t size) override { received += size; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> received{0};
    std::atomic<bool> errors{false};
};

class EchoWSSession : public WSSession
{
public:
    using WSSession::WSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override { connected = true; }
    void onWSDisconnected() override { disconnected = true; }
    void onWSReceived(const void* buffer, size_t size) override { SendBinaryAsync(buffer, size); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoWSServer : public WSServer
{
public:
    using WSServer::WSServer;

protected:
    std::shared_ptr<TCPSession> CreateSession(const std::shared_ptr<TCPServer>& server) override { return std::make_shared<EchoWSSession>(std::dynamic_pointer_cast<WSServer>(server)); }

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onConnected(std::shared_ptr<TCPSession>& session) override { connected = true; ++clients; }
    void onDisconnected(std::shared_ptr<TCPSession>& session) override { disconnected = true; --clients; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> clients{0};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("WebSocket server test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8081;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect Echo client
    auto client = std::make_shared<EchoWSClient>(service, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->connected || (server->clients != 1))
        Thread::Yield();

    // Send a message to the Echo server
    client->SendTextAsync("test");

    // Wait for all data processed...
    while (client->received != 4)
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client->CloseAsync(1000));
    while (!client->disconnected || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client->connected);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() > 0);
    REQUIRE(client->bytes_received() > 0);
    REQUIRE(!client->errors);
}

TEST_CASE("WebSocket server multicast test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8082;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and connect Echo client
    auto client1 = std::make_shared<EchoWSClient>(service, address, port);
    REQUIRE(client1->ConnectAsync());
    while (!client1->connected || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while (client1->received != 4)
        Thread::Yield();

    // Create and connect Echo client
    auto client2 = std::make_shared<EchoWSClient>(service, address, port);
    REQUIRE(client2->ConnectAsync());
    while (!client2->connected || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 8) || (client2->received != 4))
        Thread::Yield();

    // Create and connect Echo client
    auto client3 = std::make_shared<EchoWSClient>(service, address, port);
    REQUIRE(client3->ConnectAsync());
    while (!client3->connected || (server->clients != 3))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 8) || (client3->received != 4))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client1->CloseAsync(1000));
    while (!client1->disconnected || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 12) || (client3->received != 8))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client2->CloseAsync(1000));
    while (!client2->disconnected || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 12) || (client3->received != 12))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client3->CloseAsync(1000));
    while (!client3->disconnected || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client1->bytes_sent() > 0);
    REQUIRE(client2->bytes_sent() > 0);
    REQUIRE(client3->bytes_sent() > 0);
    REQUIRE(client1->bytes_received() > 0);
    REQUIRE(client2->bytes_received() > 0);
    REQUIRE(client3->bytes_received() > 0);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("WebSocket server random test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8083;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSServer>(service, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Clients collection
    std::vector<std::shared_ptr<EchoWSClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Disconnect all clients
        if ((rand() % 1000) == 0)
        {
            server->CloseAll(1000);
        }
        // Create a new client and connect
        else if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect Echo client
                auto client = std::make_shared<EchoWSClient>(service, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsConnected())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->CloseAsync(1000);
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else
                {
                    client->ConnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                {
                    client->ReconnectAsync();
                    while (!client->IsConnected())
                        Thread::Yield();
                }
            }
        }
        // Multicast a message to all clients
        else if ((rand() % 10) == 0)
        {
            server->MulticastText("test");
        }
        // Send a message from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsConnected())
                    client->SendTextAsync("test");
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->CloseAsync(1000);
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tests/test_wss.cpp`:

```cpp
//
// Created by Ivan Shynkarenka on 29.05.2019
//

#include "test.h"

#include "server/ws/wss_client.h"
#include "server/ws/wss_server.h"
#include "threads/thread.h"

#include <atomic>
#include <chrono>
#include <vector>

using namespace CppCommon;
using namespace CppServer::Asio;
using namespace CppServer::WS;

namespace {

class EchoWSSService : public Service
{
public:
    using Service::Service;

protected:
    void onThreadInitialize() override { thread_initialize = true; }
    void onThreadCleanup() override { thread_cleanup = true; }
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onIdle() override { idle = true; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> thread_initialize{false};
    std::atomic<bool> thread_cleanup{false};
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> idle{false};
    std::atomic<bool> errors{false};
};

class EchoWSSClient : public WSSClient
{
public:
    using WSSClient::WSSClient;

    static std::shared_ptr<SSLContext> CreateContext()
    {
        auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
        context->set_default_verify_paths();
        context->set_root_certs();
        context->set_verify_mode(asio::ssl::verify_peer | asio::ssl::verify_fail_if_no_peer_cert);
        context->load_verify_file("../tools/certificates/ca.pem");
        return context;
    }

protected:
    void onWSConnecting(CppServer::HTTP::HTTPRequest& request) override
    {
        request.SetBegin("GET", "/");
        request.SetHeader("Host", "localhost");
        request.SetHeader("Origin", "https://localhost");
        request.SetHeader("Upgrade", "websocket");
        request.SetHeader("Connection", "Upgrade");
        request.SetHeader("Sec-WebSocket-Key", CppCommon::Encoding::Base64Encode(ws_nonce()));
        request.SetHeader("Sec-WebSocket-Protocol", "chat, superchat");
        request.SetHeader("Sec-WebSocket-Version", "13");
    }
    void onWSConnected(const CppServer::HTTP::HTTPResponse& response) override { connected = true; }
    void onWSDisconnected() override { disconnected = true; }
    void onWSReceived(const void* buffer, size_t size) override { received += size; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> received{0};
    std::atomic<bool> errors{false};
};

class EchoWSSSession : public WSSSession
{
public:
    using WSSSession::WSSSession;

protected:
    void onWSConnected(const CppServer::HTTP::HTTPRequest& request) override { connected = true; }
    void onWSDisconnected() override { disconnected = true; }
    void onWSReceived(const void* buffer, size_t size) override { SendBinaryAsync(buffer, size); }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<bool> errors{false};
};

class EchoWSSServer : public WSSServer
{
public:
    using WSSServer::WSSServer;

    static std::shared_ptr<SSLContext> CreateContext()
    {
        auto context = std::make_shared<SSLContext>(asio::ssl::context::tlsv13);
        context->set_password_callback([](size_t max_length, asio::ssl::context::password_purpose purpose) -> std::string { return "qwerty"; });
        context->use_certificate_chain_file("../tools/certificates/server.pem");
        context->use_private_key_file("../tools/certificates/server.pem", asio::ssl::context::pem);
        context->use_tmp_dh_file("../tools/certificates/dh4096.pem");
        return context;
    }

protected:
    std::shared_ptr<SSLSession> CreateSession(const std::shared_ptr<SSLServer>& server) override { return std::make_shared<EchoWSSSession>(std::dynamic_pointer_cast<WSSServer>(server)); }

protected:
    void onStarted() override { started = true; }
    void onStopped() override { stopped = true; }
    void onConnected(std::shared_ptr<SSLSession>& session) override { connected = true; ++clients; }
    void onDisconnected(std::shared_ptr<SSLSession>& session) override { disconnected = true; --clients; }
    void onError(int error, const std::string& category, const std::string& message) override { errors = true; }

public:
    std::atomic<bool> started{false};
    std::atomic<bool> stopped{false};
    std::atomic<bool> connected{false};
    std::atomic<bool> disconnected{false};
    std::atomic<size_t> clients{0};
    std::atomic<bool> errors{false};
};

} // namespace

TEST_CASE("WebSocket secure server test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8444;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSSService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoWSSServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSSServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL client context
    auto client_context = EchoWSSServer::CreateContext();

    // Create and connect Echo client
    auto client = std::make_shared<EchoWSSClient>(service, client_context, address, port);
    REQUIRE(client->ConnectAsync());
    while (!client->connected || (server->clients != 1))
        Thread::Yield();

    // Send a message to the Echo server
    client->SendTextAsync("test");

    // Wait for all data processed...
    while (client->received != 4)
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client->CloseAsync(1000));
    while (!client->disconnected || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(!service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client->connected);
    REQUIRE(client->disconnected);
    REQUIRE(client->bytes_sent() > 0);
    REQUIRE(client->bytes_received() > 0);
    REQUIRE(!client->errors);
}

TEST_CASE("WebSocket secure server multicast test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8445;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSSService>();
    REQUIRE(service->Start(true));
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoWSSServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSSServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL client context
    auto client_context = EchoWSSServer::CreateContext();

    // Create and connect Echo client
    auto client1 = std::make_shared<EchoWSSClient>(service, client_context, address, port);
    REQUIRE(client1->ConnectAsync());
    while (!client1->connected || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while (client1->received != 4)
        Thread::Yield();

    // Create and connect Echo client
    auto client2 = std::make_shared<EchoWSSClient>(service, client_context, address, port);
    REQUIRE(client2->ConnectAsync());
    while (!client2->connected || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 8) || (client2->received != 4))
        Thread::Yield();

    // Create and connect Echo client
    auto client3 = std::make_shared<EchoWSSClient>(service, client_context, address, port);
    REQUIRE(client3->ConnectAsync());
    while (!client3->connected || (server->clients != 3))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 8) || (client3->received != 4))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client1->CloseAsync(1000));
    while (!client1->disconnected || (server->clients != 2))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 12) || (client3->received != 8))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client2->CloseAsync(1000));
    while (!client2->disconnected || (server->clients != 1))
        Thread::Yield();

    // Multicast some data to all clients
    server->MulticastText("test");

    // Wait for all data processed...
    while ((client1->received != 12) || (client2->received != 12) || (client3->received != 12))
        Thread::Yield();

    // Disconnect the Echo client
    REQUIRE(client3->CloseAsync(1000));
    while (!client3->disconnected || (server->clients != 0))
        Thread::Yield();

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Asio service state
    REQUIRE(service->thread_initialize);
    REQUIRE(service->thread_cleanup);
    REQUIRE(service->started);
    REQUIRE(service->stopped);
    REQUIRE(service->idle);
    REQUIRE(!service->errors);

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);

    // Check the Echo client state
    REQUIRE(client1->bytes_sent() > 0);
    REQUIRE(client2->bytes_sent() > 0);
    REQUIRE(client3->bytes_sent() > 0);
    REQUIRE(client1->bytes_received() > 0);
    REQUIRE(client2->bytes_received() > 0);
    REQUIRE(client3->bytes_received() > 0);
    REQUIRE(!client1->errors);
    REQUIRE(!client2->errors);
    REQUIRE(!client3->errors);
}

TEST_CASE("WebSocket secure server random test", "[CppServer][WebSocket]")
{
    const std::string address = "127.0.0.1";
    const int port = 8446;

    // Create and start Asio service
    auto service = std::make_shared<EchoWSSService>();
    REQUIRE(service->Start());
    while (!service->IsStarted())
        Thread::Yield();

    // Create and prepare a new SSL server context
    auto server_context = EchoWSSServer::CreateContext();

    // Create and start Echo server
    auto server = std::make_shared<EchoWSSServer>(service, server_context, port);
    REQUIRE(server->Start());
    while (!server->IsStarted())
        Thread::Yield();

    // Test duration in seconds
    const int duration = 10;

    // Create and prepare a new SSL client context
    auto client_context = EchoWSSServer::CreateContext();

    // Clients collection
    std::vector<std::shared_ptr<EchoWSSClient>> clients;

    // Start random test
    auto start = std::chrono::high_resolution_clock::now();
    while (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::high_resolution_clock::now() - start).count() < duration)
    {
        // Disconnect all clients
        if ((rand() % 1000) == 0)
        {
            server->CloseAll(1000);
        }
        // Create a new client and connect
        else if ((rand() % 100) == 0)
        {
            if (clients.size() < 100)
            {
                // Create and connect Echo client
                auto client = std::make_shared<EchoWSSClient>(service, client_context, address, port);
                clients.emplace_back(client);
                client->ConnectAsync();
                while (!client->IsHandshaked())
                    Thread::Yield();
            }
        }
        // Connect/Disconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                {
                    client->CloseAsync(1000);
                    while (client->IsConnected())
                        Thread::Yield();
                }
                else if (!client->IsConnected())
                {
                    client->ConnectAsync();
                    while (!client->IsHandshaked())
                        Thread::Yield();
                }
            }
        }
        // Reconnect the random client
        else if ((rand() % 100) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                {
                    client->ReconnectAsync();
                    while (!client->IsHandshaked())
                        Thread::Yield();
                }
            }
        }
        // Multicast a message to all clients
        else if ((rand() % 10) == 0)
        {
            server->MulticastText("test");
        }
        // Send a message from the random client
        else if ((rand() % 1) == 0)
        {
            if (!clients.empty())
            {
                size_t index = rand() % clients.size();
                auto client = clients.at(index);
                if (client->IsHandshaked())
                    client->SendTextAsync("test");
            }
        }

        // Sleep for a while...
        Thread::Sleep(1);
    }

    // Disconnect clients
    for (auto& client : clients)
    {
        client->CloseAsync(1000);
        while (client->IsConnected())
            Thread::Yield();
    }

    // Stop the Echo server
    REQUIRE(server->Stop());
    while (server->IsStarted())
        Thread::Yield();

    // Stop the Asio service
    REQUIRE(service->Stop());
    while (service->IsStarted())
        Thread::Yield();

    // Check the Echo server state
    REQUIRE(server->started);
    REQUIRE(server->stopped);
    REQUIRE(server->connected);
    REQUIRE(server->disconnected);
    REQUIRE(server->bytes_sent() > 0);
    REQUIRE(server->bytes_received() > 0);
    REQUIRE(!server->errors);
}

```

`tools/certificates/ca-secret.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJJwIBAAKCAgEAsJ3ML7gQGdfV0VqV/unEm1DHktyVOPBrZDenb8Z0ZUQJWI17
spGN0SS4O2piNK6r1Jfe/oiSzoCLzMSMct/GlywZXDiE7O5BY2cnU2VXL7iMmmet
MDlk1bSMt/3sUQRNXqAS0uXinEqiklLt159uFMcJRbW2bWNYTWBh/U+bU8RR37LH
foBHFHgikKb+8cXxAq7m81gMijpbRUGW+IfR66AHJcLW9Jk9cYbWgFP41iEFPxIJ
ETpOYnd+ZDpSWTBDCtlesgoUGDjrBzK5unHGMz9mB1OT5gQAUqcMYxf5+ySBVuVE
AZ4xBmLlEswi39/qCQrhMKse82/DHtMsfaoKzVbuU+MMfr5T8nolpLN3Xg2iEkBc
vJj+VIVFydvrbnSOzhxSJj9uXdWXMUOi8TdbzcjOAOgCFFq68qOUdHW6sMbPlzbB
e/I8RbXo4UsXl58vhv3Hav6c/f9avOKzMIen96mpyBKXFemcFcQnwM4AblKuy0xi
e+frIih8CuQhwh3O/jmVhBLVZecK6DdSGBjneTZ2z0CEDZJvuF/gs91oxMyu8jzc
5XHZ6cWTomqL9uW/CAl6XBvfQa6x1pxciGxwjbjTVWV+jj84CfnNWoVv5lCkX7aT
v+lzhDXKulz1E5EHmGgpU3cvZUwc/ZqEGOQSOELwrGLS6Tj2BCxTiggAWUkCAwEA
AQKCAgAOaZIUAs0tjrNgFihPWPw2QG1Iyr9SmivpTbFYKbWt3dN1anZBqCcOfhSa
pJ/G9MoI2yvTUYnJWCwQVamwZhpqk6quH96ZBwhG+E/5OjfXKRQwNW2olcZougcR
rKLwKY22vxFKLIBFiMGjdyj5g4UUJPnYum9cldLK3aahaTGfsFGOE6S76fPi87q+
WyJK0IBOW7909CZx0TlJeYS8WzkCJVjv9+pao3akIQC4ECIqNx+aefpLcZqb5mxl
+Wxm4s1VwU888B2brGlheP42/LnTzMSirGtRRdpQ5FjabUZ0/BGh6auXBjWx87gF
xKrD4h3TBxRBSHWKIACoL0teJdYjsL3T73ubjivozhugpnUaJxN3C5KKIJspIT+Z
G60K5h9539oXADmo8EQtFEMBisyHXNP9HLE0MKU7oA/sxmBgfFcUAbfynXdUhKWn
YM+oht2x1qO23FLRPEQxqTKRR5la7qu0MN9ptVHaorSK4JG4uhlFN+8Czt09mF2A
Yj4TKsRzAlI1NtT3wa8IJefW5g2dtj+E67oZDXqscr5IqiMOwDH8qlQwEQCdGXuj
rVoqzjcKeQ2IXlORmdWQF6QPkmePbZBXpwSR19rjEXJXCvCA0+0C6EHdzs477s3t
mujp4ATeJf83/LImlQarMkacQrF+0R1GMC13Hd34efFqUo3eAQKCAQEA5EN1yPCP
uQpzes2Fv7YC4JUTvHLiXKnrQYgSqZBLwyagGcIa4lTsWqmuOCc/RCBhqfYax4ie
/3k2GJha6z4vlUFRwECfIlj2W7iGwc+96uPozuTFIfnM1cOtuNu7KLI9J98Ljb5M
EfZVOSW0viMkdB0u9JSvdLESfkEw8sZcewjGkArm6K+JJpNjj7+qAtkww4yTHLUD
OCHj2FicbUeMvKoU856oznjwkiUWilEqaCYW8bVII6nsKTdtKqIYRE+joX0zBeRH
w1QbIouuo9B0W08phSvXI7IrdhfIuE783RZrUmgvL3XHaiZn8DZFW8fYXA8Pc5Gk
nODyt8aaX5teuQKCAQEAxhPDO6OK/IFDi0pk7oBq3kcZwCbZ5MPEAOHKkf1hukri
aQCviX1WMuFieTGCL9R/ZPQk5cXQaMiFVijdTuIKQRYCaLgusezJ5XpC3fVC5NLD
silr1/Y3hmLi3dDUbfXMgRdhWZfBYemJLi7GsgOFbR7zZ+BuidF+pIdnpTlwUWqb
q5bj9cVtYPrIAiO4SYmaZ/Eq8X+KqQNBN/B5Eb8kYGcMkJ8zAe8jOYYKxnvkaBBj
ZeQHVsyaAHG0D6/A1y1FwM0sK1HbbhG/JeJ8Va1vENEmn3dR2/bUAg0buioq9FZc
n+7PFB3KuhOtjeEjsoWounSBrQWP5AY2ae3PG9gHEQKCAQA0N3pqTR2TpuBj50AB
axGdbnzlTyKZMAWxJ/+c6nVqXxugyNZ9kA/Bba99CP1gCEhPKQ1XN9mnd4L4fWHP
Dpqz+g1JfX7pzJAOy1eIXo2Dfj9zlMHD0/EXtXu4Hgvic2OqC0wJUM72DPPR7t45
4LAmH8buDFVWzGr+lssrvlTJkGhb6yKHeCBXwr+z0pSBsk2FblL47i+eV6JXi229
UfDP99hzIohbMy9VP0a4vXiF+rCk+mNWRTjQ9Oz0I8CJX+5+srVJU79W35aVgH6i
2rzDZoiI/k5ozAlFKouwHeGacdZ7M3oX0Umc7sw4FzImnMDRzmAqf9a4TH05rSUD
WfeBAoIBAA97zgAkeaHhbOk/iIJIUZJMlou5vcCvOOwkulQNLY2FewtgPViPDqTt
j2gP4bBheQ/oMdYwT2lRe3LPwPUAoHKUCN4sv6Gy89lXZFC7cl42x4tux3pbSd3c
bwWN5H0wAKt6q2Z4gWpo+gs9JtUVh2GPUNGm7p0hXjf4SbbVtZz3q3GPWwSESVeS
Yv4f0rEU65gCdyvnn2w0z+1Sg/RKL8rFY2sOtssI6YT+oGsBlko4NbzqRVSYq9Ur
DjtHrthjNpeqsjA0tuV0x69rc/KymwMChnViu2hpdAsxASDdWPw+oAD0hwV4irdf
AGsd1U+IOTdSEiz3SVc20RwYtd7kVTECggEAHWLYo/djtnMExdJDzzBL3/DqZTOo
U44Z5+kuuooI+2XM8b96zIPSZCyywE+yzYaTuglQCelDfRuFHOhmMIwqSfKkdrqy
2ywFfLZv8APvOJLVIqlCRinUwcAxgsFv5C5f4U+7rs7cblALE+g/VXQBvkcUsDLr
RyIdQHKMaZ7alsO4U3vYAjvBQoKP7aCu1bwNb4EqZtrT9N+OzcASiOtUpAHTruuh
IB/99GbOUZYTWJ9zZR9+yBfUzgKUmxe3LXU9xpKQC7cX2LVPHHSjefXimW9824Nn
cQcy4VYKjeBvO4ZubG4NevBTDUCql4mV3AFkbJEkdbHgA5B3OFAxk4ECZg==
-----END RSA PRIVATE KEY-----

```

`tools/certificates/ca.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIF0zCCA7ugAwIBAgIUVHt5rwzXTJ9E0k2ymFaSL3g3vrkwDQYJKoZIhvcNAQEL
BQAweTELMAkGA1UEBhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1p
bnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJvb3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUg
Q0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMTkwNjAxMTI1MjQzWhcN
MjkwNTI5MTI1MjQzWjB5MQswCQYDVQQGEwJCWTEQMA4GA1UECAwHQmVsYXJ1czEO
MAwGA1UEBwwFTWluc2sxGDAWBgNVBAoMD0V4YW1wbGUgcm9vdCBDQTEYMBYGA1UE
CwwPRXhhbXBsZSBDQSB1bml0MRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCAiIwDQYJ
KoZIhvcNAQEBBQADggIPADCCAgoCggIBALCdzC+4EBnX1dFalf7pxJtQx5LclTjw
a2Q3p2/GdGVECViNe7KRjdEkuDtqYjSuq9SX3v6Iks6Ai8zEjHLfxpcsGVw4hOzu
QWNnJ1NlVy+4jJpnrTA5ZNW0jLf97FEETV6gEtLl4pxKopJS7defbhTHCUW1tm1j
WE1gYf1Pm1PEUd+yx36ARxR4IpCm/vHF8QKu5vNYDIo6W0VBlviH0eugByXC1vSZ
PXGG1oBT+NYhBT8SCRE6TmJ3fmQ6UlkwQwrZXrIKFBg46wcyubpxxjM/ZgdTk+YE
AFKnDGMX+fskgVblRAGeMQZi5RLMIt/f6gkK4TCrHvNvwx7TLH2qCs1W7lPjDH6+
U/J6JaSzd14NohJAXLyY/lSFRcnb6250js4cUiY/bl3VlzFDovE3W83IzgDoAhRa
uvKjlHR1urDGz5c2wXvyPEW16OFLF5efL4b9x2r+nP3/WrziszCHp/epqcgSlxXp
nBXEJ8DOAG5SrstMYnvn6yIofArkIcIdzv45lYQS1WXnCug3UhgY53k2ds9AhA2S
b7hf4LPdaMTMrvI83OVx2enFk6Jqi/blvwgJelwb30GusdacXIhscI2401Vlfo4/
OAn5zVqFb+ZQpF+2k7/pc4Q1yrpc9RORB5hoKVN3L2VMHP2ahBjkEjhC8Kxi0uk4
9gQsU4oIAFlJAgMBAAGjUzBRMB0GA1UdDgQWBBT5rkAeN4XZ9gqJuwIztAd0OPh6
7zAfBgNVHSMEGDAWgBT5rkAeN4XZ9gqJuwIztAd0OPh67zAPBgNVHRMBAf8EBTAD
AQH/MA0GCSqGSIb3DQEBCwUAA4ICAQA9m09SI1qKVBNaJLKRoQcOqgy0C4iZM8Eh
VG3ZeQHity2FJIBseIJGcBWaCytrGyeRTN+1f5cJ8bkc3V84hqbBO4sGIRN5Jjkc
cLeCBsHC2HvrI6RfiKIqt1tHTsjKvVQlV4em0ujTx2oSuDbAWUxCJgj8JE5lcR+8
xPrqvCDqKcn9su1cQzpn2PaqApK8G4Wf5n7awWTYxmR174w2jFZt39f2y07vION/
nSrlKn5Z7capzvQdRXEreupFlYe9cgJOoCnkzBA6LrcdpF5mnPmkUhyn+8hA0nxU
kOJ8kzlLPNdm/6Gl9IPY1qF66+Yx8v5DEwy6Ah9TYj0itWE9LVe5M4GTZEsoxmjt
9HC96xqkfZyk7eHoibZwIVMWw44toUj0PVUz4db9Ot5aYe5Zr9beBHO1STEeTutK
Z4M9GJ3LekmfStO9VSe8VoLePRICF2uoLthaS6qGfr4duzwneqDRwjpHmJX4YNa7
svf6g9a/YSA6UGISHCjXPP9kJOfb6raNkcurNiVhXzGNpXD5pO5oSAnCE9tF6gpv
bwAqhIJGyo9zxMeQHC2F7dDmqa/seFYamtRdn2JkV6vXBTkQmcdmvpBsKzlqg6L+
9vS1ig7ZLwIdeuoD7blMOZH9IIF0eHxJgykxP/i+EzSR8gfDC2iEDgOzIKipa5Ts
NC3uMWWz3A==
-----END CERTIFICATE-----

```

`tools/certificates/ca.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJJwIBAAKCAgEAsJ3ML7gQGdfV0VqV/unEm1DHktyVOPBrZDenb8Z0ZUQJWI17
spGN0SS4O2piNK6r1Jfe/oiSzoCLzMSMct/GlywZXDiE7O5BY2cnU2VXL7iMmmet
MDlk1bSMt/3sUQRNXqAS0uXinEqiklLt159uFMcJRbW2bWNYTWBh/U+bU8RR37LH
foBHFHgikKb+8cXxAq7m81gMijpbRUGW+IfR66AHJcLW9Jk9cYbWgFP41iEFPxIJ
ETpOYnd+ZDpSWTBDCtlesgoUGDjrBzK5unHGMz9mB1OT5gQAUqcMYxf5+ySBVuVE
AZ4xBmLlEswi39/qCQrhMKse82/DHtMsfaoKzVbuU+MMfr5T8nolpLN3Xg2iEkBc
vJj+VIVFydvrbnSOzhxSJj9uXdWXMUOi8TdbzcjOAOgCFFq68qOUdHW6sMbPlzbB
e/I8RbXo4UsXl58vhv3Hav6c/f9avOKzMIen96mpyBKXFemcFcQnwM4AblKuy0xi
e+frIih8CuQhwh3O/jmVhBLVZecK6DdSGBjneTZ2z0CEDZJvuF/gs91oxMyu8jzc
5XHZ6cWTomqL9uW/CAl6XBvfQa6x1pxciGxwjbjTVWV+jj84CfnNWoVv5lCkX7aT
v+lzhDXKulz1E5EHmGgpU3cvZUwc/ZqEGOQSOELwrGLS6Tj2BCxTiggAWUkCAwEA
AQKCAgAOaZIUAs0tjrNgFihPWPw2QG1Iyr9SmivpTbFYKbWt3dN1anZBqCcOfhSa
pJ/G9MoI2yvTUYnJWCwQVamwZhpqk6quH96ZBwhG+E/5OjfXKRQwNW2olcZougcR
rKLwKY22vxFKLIBFiMGjdyj5g4UUJPnYum9cldLK3aahaTGfsFGOE6S76fPi87q+
WyJK0IBOW7909CZx0TlJeYS8WzkCJVjv9+pao3akIQC4ECIqNx+aefpLcZqb5mxl
+Wxm4s1VwU888B2brGlheP42/LnTzMSirGtRRdpQ5FjabUZ0/BGh6auXBjWx87gF
xKrD4h3TBxRBSHWKIACoL0teJdYjsL3T73ubjivozhugpnUaJxN3C5KKIJspIT+Z
G60K5h9539oXADmo8EQtFEMBisyHXNP9HLE0MKU7oA/sxmBgfFcUAbfynXdUhKWn
YM+oht2x1qO23FLRPEQxqTKRR5la7qu0MN9ptVHaorSK4JG4uhlFN+8Czt09mF2A
Yj4TKsRzAlI1NtT3wa8IJefW5g2dtj+E67oZDXqscr5IqiMOwDH8qlQwEQCdGXuj
rVoqzjcKeQ2IXlORmdWQF6QPkmePbZBXpwSR19rjEXJXCvCA0+0C6EHdzs477s3t
mujp4ATeJf83/LImlQarMkacQrF+0R1GMC13Hd34efFqUo3eAQKCAQEA5EN1yPCP
uQpzes2Fv7YC4JUTvHLiXKnrQYgSqZBLwyagGcIa4lTsWqmuOCc/RCBhqfYax4ie
/3k2GJha6z4vlUFRwECfIlj2W7iGwc+96uPozuTFIfnM1cOtuNu7KLI9J98Ljb5M
EfZVOSW0viMkdB0u9JSvdLESfkEw8sZcewjGkArm6K+JJpNjj7+qAtkww4yTHLUD
OCHj2FicbUeMvKoU856oznjwkiUWilEqaCYW8bVII6nsKTdtKqIYRE+joX0zBeRH
w1QbIouuo9B0W08phSvXI7IrdhfIuE783RZrUmgvL3XHaiZn8DZFW8fYXA8Pc5Gk
nODyt8aaX5teuQKCAQEAxhPDO6OK/IFDi0pk7oBq3kcZwCbZ5MPEAOHKkf1hukri
aQCviX1WMuFieTGCL9R/ZPQk5cXQaMiFVijdTuIKQRYCaLgusezJ5XpC3fVC5NLD
silr1/Y3hmLi3dDUbfXMgRdhWZfBYemJLi7GsgOFbR7zZ+BuidF+pIdnpTlwUWqb
q5bj9cVtYPrIAiO4SYmaZ/Eq8X+KqQNBN/B5Eb8kYGcMkJ8zAe8jOYYKxnvkaBBj
ZeQHVsyaAHG0D6/A1y1FwM0sK1HbbhG/JeJ8Va1vENEmn3dR2/bUAg0buioq9FZc
n+7PFB3KuhOtjeEjsoWounSBrQWP5AY2ae3PG9gHEQKCAQA0N3pqTR2TpuBj50AB
axGdbnzlTyKZMAWxJ/+c6nVqXxugyNZ9kA/Bba99CP1gCEhPKQ1XN9mnd4L4fWHP
Dpqz+g1JfX7pzJAOy1eIXo2Dfj9zlMHD0/EXtXu4Hgvic2OqC0wJUM72DPPR7t45
4LAmH8buDFVWzGr+lssrvlTJkGhb6yKHeCBXwr+z0pSBsk2FblL47i+eV6JXi229
UfDP99hzIohbMy9VP0a4vXiF+rCk+mNWRTjQ9Oz0I8CJX+5+srVJU79W35aVgH6i
2rzDZoiI/k5ozAlFKouwHeGacdZ7M3oX0Umc7sw4FzImnMDRzmAqf9a4TH05rSUD
WfeBAoIBAA97zgAkeaHhbOk/iIJIUZJMlou5vcCvOOwkulQNLY2FewtgPViPDqTt
j2gP4bBheQ/oMdYwT2lRe3LPwPUAoHKUCN4sv6Gy89lXZFC7cl42x4tux3pbSd3c
bwWN5H0wAKt6q2Z4gWpo+gs9JtUVh2GPUNGm7p0hXjf4SbbVtZz3q3GPWwSESVeS
Yv4f0rEU65gCdyvnn2w0z+1Sg/RKL8rFY2sOtssI6YT+oGsBlko4NbzqRVSYq9Ur
DjtHrthjNpeqsjA0tuV0x69rc/KymwMChnViu2hpdAsxASDdWPw+oAD0hwV4irdf
AGsd1U+IOTdSEiz3SVc20RwYtd7kVTECggEAHWLYo/djtnMExdJDzzBL3/DqZTOo
U44Z5+kuuooI+2XM8b96zIPSZCyywE+yzYaTuglQCelDfRuFHOhmMIwqSfKkdrqy
2ywFfLZv8APvOJLVIqlCRinUwcAxgsFv5C5f4U+7rs7cblALE+g/VXQBvkcUsDLr
RyIdQHKMaZ7alsO4U3vYAjvBQoKP7aCu1bwNb4EqZtrT9N+OzcASiOtUpAHTruuh
IB/99GbOUZYTWJ9zZR9+yBfUzgKUmxe3LXU9xpKQC7cX2LVPHHSjefXimW9824Nn
cQcy4VYKjeBvO4ZubG4NevBTDUCql4mV3AFkbJEkdbHgA5B3OFAxk4ECZg==
-----END RSA PRIVATE KEY-----

```

`tools/certificates/ca.pem`:

```pem
Bag Attributes
    localKeyID: AF DA B7 C8 1C BE 13 E9 5A 0A 22 47 A6 C3 E6 15 75 8C 7A A8 
subject=C = BY, ST = Belarus, L = Minsk, O = Example root CA, OU = Example CA unit, CN = example.com

issuer=C = BY, ST = Belarus, L = Minsk, O = Example root CA, OU = Example CA unit, CN = example.com

-----BEGIN CERTIFICATE-----
MIIF0zCCA7ugAwIBAgIUVHt5rwzXTJ9E0k2ymFaSL3g3vrkwDQYJKoZIhvcNAQEL
BQAweTELMAkGA1UEBhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1p
bnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJvb3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUg
Q0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMTkwNjAxMTI1MjQzWhcN
MjkwNTI5MTI1MjQzWjB5MQswCQYDVQQGEwJCWTEQMA4GA1UECAwHQmVsYXJ1czEO
MAwGA1UEBwwFTWluc2sxGDAWBgNVBAoMD0V4YW1wbGUgcm9vdCBDQTEYMBYGA1UE
CwwPRXhhbXBsZSBDQSB1bml0MRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCAiIwDQYJ
KoZIhvcNAQEBBQADggIPADCCAgoCggIBALCdzC+4EBnX1dFalf7pxJtQx5LclTjw
a2Q3p2/GdGVECViNe7KRjdEkuDtqYjSuq9SX3v6Iks6Ai8zEjHLfxpcsGVw4hOzu
QWNnJ1NlVy+4jJpnrTA5ZNW0jLf97FEETV6gEtLl4pxKopJS7defbhTHCUW1tm1j
WE1gYf1Pm1PEUd+yx36ARxR4IpCm/vHF8QKu5vNYDIo6W0VBlviH0eugByXC1vSZ
PXGG1oBT+NYhBT8SCRE6TmJ3fmQ6UlkwQwrZXrIKFBg46wcyubpxxjM/ZgdTk+YE
AFKnDGMX+fskgVblRAGeMQZi5RLMIt/f6gkK4TCrHvNvwx7TLH2qCs1W7lPjDH6+
U/J6JaSzd14NohJAXLyY/lSFRcnb6250js4cUiY/bl3VlzFDovE3W83IzgDoAhRa
uvKjlHR1urDGz5c2wXvyPEW16OFLF5efL4b9x2r+nP3/WrziszCHp/epqcgSlxXp
nBXEJ8DOAG5SrstMYnvn6yIofArkIcIdzv45lYQS1WXnCug3UhgY53k2ds9AhA2S
b7hf4LPdaMTMrvI83OVx2enFk6Jqi/blvwgJelwb30GusdacXIhscI2401Vlfo4/
OAn5zVqFb+ZQpF+2k7/pc4Q1yrpc9RORB5hoKVN3L2VMHP2ahBjkEjhC8Kxi0uk4
9gQsU4oIAFlJAgMBAAGjUzBRMB0GA1UdDgQWBBT5rkAeN4XZ9gqJuwIztAd0OPh6
7zAfBgNVHSMEGDAWgBT5rkAeN4XZ9gqJuwIztAd0OPh67zAPBgNVHRMBAf8EBTAD
AQH/MA0GCSqGSIb3DQEBCwUAA4ICAQA9m09SI1qKVBNaJLKRoQcOqgy0C4iZM8Eh
VG3ZeQHity2FJIBseIJGcBWaCytrGyeRTN+1f5cJ8bkc3V84hqbBO4sGIRN5Jjkc
cLeCBsHC2HvrI6RfiKIqt1tHTsjKvVQlV4em0ujTx2oSuDbAWUxCJgj8JE5lcR+8
xPrqvCDqKcn9su1cQzpn2PaqApK8G4Wf5n7awWTYxmR174w2jFZt39f2y07vION/
nSrlKn5Z7capzvQdRXEreupFlYe9cgJOoCnkzBA6LrcdpF5mnPmkUhyn+8hA0nxU
kOJ8kzlLPNdm/6Gl9IPY1qF66+Yx8v5DEwy6Ah9TYj0itWE9LVe5M4GTZEsoxmjt
9HC96xqkfZyk7eHoibZwIVMWw44toUj0PVUz4db9Ot5aYe5Zr9beBHO1STEeTutK
Z4M9GJ3LekmfStO9VSe8VoLePRICF2uoLthaS6qGfr4duzwneqDRwjpHmJX4YNa7
svf6g9a/YSA6UGISHCjXPP9kJOfb6raNkcurNiVhXzGNpXD5pO5oSAnCE9tF6gpv
bwAqhIJGyo9zxMeQHC2F7dDmqa/seFYamtRdn2JkV6vXBTkQmcdmvpBsKzlqg6L+
9vS1ig7ZLwIdeuoD7blMOZH9IIF0eHxJgykxP/i+EzSR8gfDC2iEDgOzIKipa5Ts
NC3uMWWz3A==
-----END CERTIFICATE-----
Bag Attributes
    localKeyID: AF DA B7 C8 1C BE 13 E9 5A 0A 22 47 A6 C3 E6 15 75 8C 7A A8 
Key Attributes: <No Attributes>
-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIJnDBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIbkPItz8YVQsCAggA
MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECB2lOXdQbwaPBIIJSJicIa12m+lO
CB1kHvtRYUbtOMtM2yVhmnpiDYK/2OcugcTmoTMpOdnqRZuQhrvmmRLOhh/Hp8ch
/4Nyw1tXxmgXwEdDun1/CUd0PDRrbPn01qmN4KGdG+lxMZktbJhsq054JfJ4oG59
xkkBJEJpMSGJnLSnL+FtEs2FjemFOAFaGMP9IFtwOWXDQZGoT+7rq4BoWJoNns94
/BIAkl9o57gXAmgucoZUF6KVmTc0f2TQThY0AW2IKXLODqF4RKNbSyUKXroBxp/3
uETO2VZe/XnfqlHq4KKRSFCxh+hjMkIyxRNTiYto94PyVUdFRl4lwzc3ZxyTmwec
vPAtoTQr+Pd01AY7VzfAiVZFS/YWA34nmrJKM32D/9z9PwF1t+/DxAKjpGbeDLEX
+n/fjhxMcaw1Dje+u4T5zQ11ufHpKuJNGazbAJcoFrfhj31obPT7Ghwe2U1xzU4e
d6LpkU7mFFh3SAnZBlGuAkLv9DdL4TG+rNkTSGB4Q68B9Eb+RyQvq4ep+4wBgLVX
fsERe9C/BJRCj1UBi19VxMgvrl2GWzkhJ642P0Xal+IjT9oeEQZDIelnWQppJmxP
KXtpVeiwrjspfYT6RwIxf/k8Bn48fOfAhly1AQQFhwd5E2zok7wdQNuayS3zcgmy
H96dgnv2T/hYSgjil3latkuD+0LvIfRWi3FXxFzt8idj/9xUn74UfNWAilXqEbeM
omxfn46hsbP/6NPO8CfLyYzSIqMNUqFTfN5RLYY4Gj/iGRcRY1K2vbFAoEqwVBFs
19nHupOgQCQsJl9GpLFSoZT2oArCLGhMhOee7+buWibZMI355S92qHdzzQm9ABDH
q7PNfKjdZ3SSsl7jqtI/Du31XPJ93nwtf4iLtzluCl/cUdZp9Fi0BCz1/BCBRUJi
Rk3VFhJgWjKeNL3lEiAVlZNkWj1SRVGYmFZRyunpsXxM6zM3zcPzztairUGc5fLS
yR51Vc3+2FbmT3Tq5Zw/Nhjvu0Df6gDoISgAKiZwEeLDbVApTwcM6Vfw83DG/7hS
u40zgdv1v5OeCfRYvpA/+RHuV1G24sgi/hRx2SsjT52tKnpV7dKKLlpyfmCmhkq9
6DZuvD3MJ5JqRqryG2XaTbAl88tb7kheL0w5iiXq7r0F4IWpCXQsa4S9GeBpBRRT
UABm8rYITfpJYROKmCBCJQm8RHaBg7aoXji9903tuQrA3z3Vc3rcZGSsTurK+rM7
cz1s3s3MLEL/zLD7C//rtO4X3r1ytebg+TT9e/XqNCaARlOFDmFXcf6tyBk2SMRk
+0TJ4TV1n7ZBldbdpFiFxTFSpoPA07jA3OP1Y0I18BTADnkN2KkQVTDbtDrR+BeV
51xZEVgCgKfxo2GD6LzwmGbn58/dRYKf+M+SgXitCSFUgUMMS+FGJdkKa5/xCewi
qoDAIF+xovJp9G5nntACkCoSvNjTuRrxMJYWASOJduVO5zfCuUZq8syqr5my4xf3
y/R8wWh3V89OrohElWdKJT/nBNv4KvA+nHQA/bqjmPNwCdNcYJ9HImQfDiawVgfr
K0q5EHxrxbx7JGWf86Kpv+o+9mwHvUm1792QzobvKe7oVdG9QXP0rR9e6WKTz3VA
ggw6jPA9em2n2hIVGP5BjuIi6/9bPTBt/E92f+IX1J05+Mhx/2y+7jAPvYQNsViK
ccta6mOkshBX5otj/n/7YfzyqqPWEQagtV3Q6kVz2uLE3xwQYkxqcAvJ9vDE7L2x
vW0mzbbhQ5/9H7QmumtonJ0zwYUHlOONechYBPA9FrPLEaza7iNrdw+VbfcgMbKg
iem3m6LVcSXLbwjrR6sinxyI1RKOyV7jhUELQo93c92CHUNbpmADs4sO77e3cIom
QXFknBLlZDDaC5Prxmz0hCn1MYVn0MG1q5wm5b2RY/fJ8GBP+8+v4BgIGoyIChsZ
V1Wf/ga8HqogLWDocfxy7h+5I0nd5Kk/vVRWZK62gplHjgad4G66dQ9GI/EZVSG1
eWehNf7AgHBDbVzVRY1s9ifCjuxDGk6euR5RC9oQ+ORHWmwHcdk+qW1WZ8PCSvbK
41CuBeAhscTgZ8BkEjdeJwtCORiheoF2rG0MXPGMwwv3aLvko4ppg+akM/I08j3B
gda11SQ+1ReVlHPvSlW/E1XZph98OI3CJMpAMvs5HtgOu0kcxuqmxVL2dHawB0io
hBLOHSdSF8d1gCEjqz3Pm+DV2lpCb1UE6a57EOZW88FlS92Zx6nxHV48jVgEaaQy
fsHbMduaN6GCAZ6G2kAImQ0vEPDUb0ue/na8k1ET9IYxIggsMFRoyIp9+OEvVnOA
xkS3S7xThKH8uTF+mu5hmWnLpSeOpdwC1GNHDv1DXiVwTTbA9mcTMNT2OtWi08KA
buKxlfQhmYrZFn7BNjGQsiB01/QBk1xsUK5Y23+7CoQy0rLjdhZOUDeynLERTwRl
qDo+Xy66AsGVyEjQUXQGomcWrqRcl2gahFrqTgi8fMcxypTI1qgcaGTNPdDOG3s4
k5xyVooMZRfugkr24zxs4PRTmHEEi4bRPQWBWbnui30junLAknS52pAMfm5zsTub
rBuONlRvOTABDRnjhOGn8k9JOQwl0kHTcSK3tgqDMW/K4/TrU7x3vo5B4tCI9Wj9
1ZWHmLJUITUB+N1VF7gvkozud3GRuVduDfFp3cdO1n023Od35mJxykGMZc8ub88q
o/m1zqULWMpQejPt7pruTX16JzhxbQq5riLGIkG5yDo9H84dEX855jtYsUWZNxw7
nTl/T8AhFco8WkpMGVF2mHX1UWgpliCyasyVaNxz2e29I5+SXfVlfNVnVbL2hoYJ
Yl/fUHsHroprC10M345GMLAIiCQpvCYFSbOS2i48CdCgfhmh2KtI2eePN9IWW4Jn
ab+ygz0iHzgqCZjUFE6+3x2oITuttWtIpqzC05EIvb2MY+DecqYVq/E+8BpQIHc9
fSKnjIcUgDwx5YKhR54Yb4vinyo9+O3hRGaiTPkkIOIilu0G4jH/SA7RptkDLZas
gf8zGnsdLX9H9OFLEnHtwTxMDAnc/pCwSgQ0yjJZ6mKv0r7yhHippzfeei8TxFnV
x8KYHI1pdREuhPQhV3bfJMLFcL/mbZjimo6qib4s3tjhtWQEBGxAmlEUkVo6NBV+
71k7C/Fq2RqklHTlnAgzuA==
-----END ENCRYPTED PRIVATE KEY-----

```

`tools/certificates/client-secret.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJKwIBAAKCAgEAyG7fNpmwFMip2daVMWleNfQ4djHJpAD3CY4PFL+CDU3MRwve
QWyX04iOpInhRk8pTsPisWCqouBxmo14jprAOv5XVEm4eHTcvxQ1UsUBPSzF3h1o
Uy2PuOnd803N1ja239z2jAMbdNwnihz9SoNT9i5wD3rDUK3vbUx1i8ixC/wX0RMI
Vb1RtE+dCbyhsiXTesotB2uqzd4cDl0gLBmD9+lOlPKA5Qx3bzFJAjr7YlPEBL7J
CL+bj+fC2lX7Hbn3tj3fPtgHjuglIL26WM8K8OYDdM2fq2X0XfPTcJasqxxs3+Bw
5P/7hXRx+Su2gEaNa0TlAwa+PL28TKmGYppP6mEKG97P/fR45Uw1Nv7SNFXP8awQ
3T610ViLm+krj3AsE7hr5JwRCPbedQvHm2mrQ+onv6Xtm8PDzbuqpAHltUQWBmnc
dcByH42ugeGQmajwM/4hZVPpPhk7+67HFCUN/Qs1HX2KnJJ9M++sMt5Le6nk9bVo
YSoKXwmlDPvBiT43gcL+ckk+QjbrpJ6hZFRdPAIJzjFSvsFbAi5Qaxam6J3OWiTq
3wDqO/GnPFtFvtmpUc9iExRBy772u8mNb2BnEPD2rDnw0bTxuWHkWIo6iQljl8z+
PxLWtMyxBbcQpa46JrS6Tcdx2WpGSOGOdCpmQ+O2qe2B4u2+/GRJTP5bwQ8CAwEA
AQKCAgEAxAqVrszxydJfN19H+9VovXMLCqg15oC/IAxfudZ6uNKAXHlCQVGayt8F
TfBCdEeXSqAUCZRYMgk/dICtCyZXoRwGhL26fa8n/okggr2IMbKqMk8nLDwjGCU+
3uwZyU0o35s7VsTvRQTUc6VZJVmAdQkEuE9F3JLT3V7slfWNHgDLtsZb36jV0nwQ
SGbE7P9McwxusJRhswxs+quhfSDT0FbVcqAi7GWeKBbXpyPTn1/5GP8WmMT4ve9c
ybtRa8jqfcjUo54e/msXbYfFTXns5KTFeqhoZPfK5V5IUBY/+vlJkEvxgDrUY7r6
g1F7JspbJjFzodsllTmrhHxHogf24rU0HZyAWujcv8zb7t2i2R4Ocwi3hnBNCMZp
ZkxjGT3nLSGjlmGkmvXd0fXwzJ/XiNuC97SJmz/1tPWlzeiGFUrFjiOgflmLfzMK
HpvF73Z2uPN4Dq9QpmqCJrCA9sNQ1kNEtE1xihITsR4ak2FUPTEXiYCGzmQohgvJ
H0VG/kXlUeGgcnbWoeJVCiTS6Y6VHj2XPp82aWxA1uNXhPSimbAEdX7SrWdbiXFg
wIEmxKZzlfHmecwPKViP0BllfRTHfxyyrwH5URh+ceQ+QQzoLb1DyPQfaKVJRmct
strCGl9QcRNUYTsc8g20jq7ViI3IkpfJVcrCVKnqr6QYP5p419kCggEBAP6Xdi0H
M7saxmvc5+FmVnFTkrzpiX5VhD6VP8UufiHE21Bt64hSfOGtSX9KVmwrVc07mra1
RihewdNgXeY+q1L0fXAaFXR68WUPB6i/lNtswuYNDaDE1kOmB/9eCNrzgG+7Tkcj
JlrUGy+/48FSSzhKFUWpIkD6ih67eMaqILJAcWfh2T1g5ZaKrAcQadq1xEFADoO0
4662f6dYmEDT0OAiXN1hI60/gY5y1UIOUp+AO+m6g4LEEjn7xOr2bnmJMg4NnAWb
yTIzEg8Qf6IK8dGjYD5cVJQRZAvBabQ51s8S2/xYSECPnPo1XARcdALUmxB/fCL0
mIqY5agHhq0XNUsCggEBAMmKtsj3xzQ4nPeIjtkbNwxXNYjsuh1X9DxiIYm02Njs
RS3F6Ms9Ig1eiglgkIU9qfXZSwxcXtF2KOqLJCoNxgBwf7GL9UgOa6/768NgKfZp
g1YlPkhLIjEMEZZfCOqFGJ/rwmJY8VESyP0HIwLbK6ds1cHR/xln6GvuoHJMPB0B
fgj30MX0Yvf3AiVBJp+hrHN55Nd6eh+He61jybqgEmw+ZnfjlsrWzaZDGJQsYYf8
F0jyujcCk9Dpb/YohygpTM/mtlHUDGvazbtwF2+HA571N2z89hQA6iVRMPheJ2sU
1uVcshzQfc3S3p/8ruXEsH7aW+n/b86oYID7oGgJvM0CggEBAKvT/eaWHcwCXjke
d0Ihl+YUyczGsg2aGg9DHC8xGeAgxQSbq4PuaGrIUfqfaYTIGrjRqbH21ssYaSkI
uVdUpLzwVlj6wdBDyfizFDBIXWdbGI+77566OwKdZHhuNvvPrLe8azCIALL8xPyN
PmKT8EClf4XsiTnh3qavUOyElly4MdIzFDPg2hOotEJwSYFbfIGtgh5ST/jzI2UG
3nuiei9MAfFIRpP/cKl7x4M1t33/RnCReYEgZEzOKDGM8TMF7cqeVNdUNY6z+VRB
hmMPj/Y1lheAqXTl5+gnOfhxsRFBYUgHLXylcQVOTjSDUak3ZRDVeir9epbQau/l
ZHgeWdECggEBAKXDuKk82pRCCCC0KcG516IHzJltE3r1D4XmtGz92Ok6E4AdamZX
Rr22R1SFHvjoCfWSnl5xTu96/xZCESGhqHxOC0jts3Vrnvjk/Dn6yyjICeT9xudR
HLM4mPKUAdJaXDGUiJG5U+n5yGQMzagYuiP/qSS8YtPzmb/ESiUYPM0ioBYiNY3L
fucyO4qGtozPPfbQh/8O1ok+NuQa0h30cJKlFESBZVI6MHUSdJHSmvlsx34RXkXG
ketfRN4y4U+QAIRy3vwYq4q+MT58aForsze3urmiqYc0ZWECEYQGdOdnAYUuo7R9
ayuxx7fQ7c0/5GbBlJ22obBY3t7Xl0xazfUCggEBALkEvbBtKc/GYaYgUPbxGfzi
lsPQxzQoFYe6agV/YG1ZOC8wTDaTAQyctFVO7nqkLBS6iecmwirkML9aeehsZVeW
xkcqYMAFC+6z1mvgjtmZqlFaoP4sso41Gte/eixanTD4ljnbytIeLLsn92boN3+n
8iQr3TE7B9jpLh6/ZOJU7r3X31f0kFwNJainu3YFXy6l4qUwe5xNrJALAHJc/Cbt
m+mO99OHBZSTzJHOHXrErR2g6fsIf4zGodwxzo+mxQAC0+ikgmLGL+XGkDtb+9ur
fFZIACGhB8aba2yIKMUkjn72QvpaX1KRsh3MKH1ZDdDmOSVY9UE0c/GKpItbjaA=
-----END RSA PRIVATE KEY-----

```

`tools/certificates/client.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIFcTCCA1kCAQEwDQYJKoZIhvcNAQELBQAweTELMAkGA1UEBhMCQlkxEDAOBgNV
BAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJv
b3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUgQ0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBs
ZS5jb20wHhcNMTkwNjAxMTI1MjQ1WhcNMjkwNTI5MTI1MjQ1WjCBgzELMAkGA1UE
BhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRcwFQYDVQQK
DA5FeGFtcGxlIGNsaWVudDEcMBoGA1UECwwTRXhhbXBsZSBjbGllbnQgdW5pdDEb
MBkGA1UEAwwSY2xpZW50LmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEAyG7fNpmwFMip2daVMWleNfQ4djHJpAD3CY4PFL+CDU3MRwve
QWyX04iOpInhRk8pTsPisWCqouBxmo14jprAOv5XVEm4eHTcvxQ1UsUBPSzF3h1o
Uy2PuOnd803N1ja239z2jAMbdNwnihz9SoNT9i5wD3rDUK3vbUx1i8ixC/wX0RMI
Vb1RtE+dCbyhsiXTesotB2uqzd4cDl0gLBmD9+lOlPKA5Qx3bzFJAjr7YlPEBL7J
CL+bj+fC2lX7Hbn3tj3fPtgHjuglIL26WM8K8OYDdM2fq2X0XfPTcJasqxxs3+Bw
5P/7hXRx+Su2gEaNa0TlAwa+PL28TKmGYppP6mEKG97P/fR45Uw1Nv7SNFXP8awQ
3T610ViLm+krj3AsE7hr5JwRCPbedQvHm2mrQ+onv6Xtm8PDzbuqpAHltUQWBmnc
dcByH42ugeGQmajwM/4hZVPpPhk7+67HFCUN/Qs1HX2KnJJ9M++sMt5Le6nk9bVo
YSoKXwmlDPvBiT43gcL+ckk+QjbrpJ6hZFRdPAIJzjFSvsFbAi5Qaxam6J3OWiTq
3wDqO/GnPFtFvtmpUc9iExRBy772u8mNb2BnEPD2rDnw0bTxuWHkWIo6iQljl8z+
PxLWtMyxBbcQpa46JrS6Tcdx2WpGSOGOdCpmQ+O2qe2B4u2+/GRJTP5bwQ8CAwEA
ATANBgkqhkiG9w0BAQsFAAOCAgEAgbhW3XJDV/j8TNZLVlH2U4ocmdUUO8xT4sqw
S1SzGrL7t6PA2Lus/LCnbOwakq12SzuH2YmTE4y7wXY/313kmYcn220qohdEgxBk
JTNdSvQ6/k1FgJcqCoMLHq6+J8fpW7cYrigHknK+gvKMFoE/cPVAADn1KaRg08LP
fbg4Fmi0ZAvf5VT0KqlfgodORoruiDj0y2nnX7HGKy59mzNteJTescvwt2uDvuhF
xtWsPP/vyYE+XGuaJTxIYUiPhsjVuC91P6Jj8UZo4IJrBSrtbMv2TkvBYh2NstDN
gCDef8ESu3rv9O+UWJh5QdSnY8NFoAe2ZtItjQ1zGXT1DFtd2OAFQUW0z7E4IgRQ
DppXhY2xdcNP4sQibytGfqC8Qi0DexWtLPXVPj7J25Cvw9q7/FkqwKbN3RxB8WA0
nen4VHW6SqPxQfdlmDQuxQymwhONPDI1YBjsQ569c9d2k67xulyadLNPhtLDG/NR
jh6y+hB/NXZyPDqQM+/IsqvvQnGUHmssmaF9udYo6JfJx6YfaFkJeGE1P6+67lJi
wFXaXWtr26QgsNQXBgqKpwk9bo2S8JFObPAJTCSCRFaXOtB/kApQ+mTxamG2ycyd
fg5p4Ef30Nfj3/oHdbw7aj3O1xj/4y6HfT1cLV/A1t9LJ7kO134rHao2NRuvughr
5kfERrg=
-----END CERTIFICATE-----

```

`tools/certificates/client.csr`:

```csr
-----BEGIN CERTIFICATE REQUEST-----
MIIEyTCCArECAQAwgYMxCzAJBgNVBAYTAkJZMRAwDgYDVQQIDAdCZWxhcnVzMQ4w
DAYDVQQHDAVNaW5zazEXMBUGA1UECgwORXhhbXBsZSBjbGllbnQxHDAaBgNVBAsM
E0V4YW1wbGUgY2xpZW50IHVuaXQxGzAZBgNVBAMMEmNsaWVudC5leGFtcGxlLmNv
bTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMhu3zaZsBTIqdnWlTFp
XjX0OHYxyaQA9wmODxS/gg1NzEcL3kFsl9OIjqSJ4UZPKU7D4rFgqqLgcZqNeI6a
wDr+V1RJuHh03L8UNVLFAT0sxd4daFMtj7jp3fNNzdY2tt/c9owDG3TcJ4oc/UqD
U/YucA96w1Ct721MdYvIsQv8F9ETCFW9UbRPnQm8obIl03rKLQdrqs3eHA5dICwZ
g/fpTpTygOUMd28xSQI6+2JTxAS+yQi/m4/nwtpV+x2597Y93z7YB47oJSC9uljP
CvDmA3TNn6tl9F3z03CWrKscbN/gcOT/+4V0cfkrtoBGjWtE5QMGvjy9vEyphmKa
T+phChvez/30eOVMNTb+0jRVz/GsEN0+tdFYi5vpK49wLBO4a+ScEQj23nULx5tp
q0PqJ7+l7ZvDw827qqQB5bVEFgZp3HXAch+NroHhkJmo8DP+IWVT6T4ZO/uuxxQl
Df0LNR19ipySfTPvrDLeS3up5PW1aGEqCl8JpQz7wYk+N4HC/nJJPkI266SeoWRU
XTwCCc4xUr7BWwIuUGsWpuidzlok6t8A6jvxpzxbRb7ZqVHPYhMUQcu+9rvJjW9g
ZxDw9qw58NG08blh5FiKOokJY5fM/j8S1rTMsQW3EKWuOia0uk3HcdlqRkjhjnQq
ZkPjtqntgeLtvvxkSUz+W8EPAgMBAAGgADANBgkqhkiG9w0BAQsFAAOCAgEAcBC/
68GhRRHZ3LE1/ik8Y9FoHsIW02gmVSNXbjCWxhklXR+t8fq9Oc7IhaKGTAXYGH/D
PGpGMSpzsdPKilvPRm/IrOJ93rMtfWtQ+x9ksTsgZw72GlNB9ccryjqZIRCK/1Up
Pyi28TFrb085kP6mrIqk5dQpL7Zpi1XYe6Nh6r/IrLllyNi7noZhyKbBSp+urzTS
WpI8K1p6/ivX3eZ5ZCAqca5kb9Qi7aXOUQ1OV7OZkOPTXtUMiMAzk1UC4Bvsg9MR
S0jTiUIktTFZSRfBPZ/S/ZHsTg7iPtgTmKAGbZSBiMsuWbqafdI5NDa8wzSOrLTB
uoD723L+t1Z57Trv69nkJQmqJTwz3mDDdSoEF6rUMywYZsAJBS8HH0ckrvrFZN88
afV3FEeIDAKtZuGJS4rPxSzDWrnguqK76ocXOdDm5ILgWAX5Lhwog4UattKpAm8y
HiWO6M1Q8/UsleZSKLHLs5VMFSg1854W9Gxdx/nVfnKOAlg/ldd1g5yY/H+rHjBl
QXgwcLsBrQ3xZ+1beJi2AWhPcpr3MlguLocX3VXIxiY5pK4O9bscN+BuNVFTeZbV
paoTsnad2wZKpQcJEsC+q2lwrbCuzP63aw1mn3Rhfa1XLYRR87Fu4V4DIzLRexwS
mqvlo9Lf+E/y/TxryhOqcb0VZJHFJ2vhxqABSQI=
-----END CERTIFICATE REQUEST-----

```

`tools/certificates/client.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJKwIBAAKCAgEAyG7fNpmwFMip2daVMWleNfQ4djHJpAD3CY4PFL+CDU3MRwve
QWyX04iOpInhRk8pTsPisWCqouBxmo14jprAOv5XVEm4eHTcvxQ1UsUBPSzF3h1o
Uy2PuOnd803N1ja239z2jAMbdNwnihz9SoNT9i5wD3rDUK3vbUx1i8ixC/wX0RMI
Vb1RtE+dCbyhsiXTesotB2uqzd4cDl0gLBmD9+lOlPKA5Qx3bzFJAjr7YlPEBL7J
CL+bj+fC2lX7Hbn3tj3fPtgHjuglIL26WM8K8OYDdM2fq2X0XfPTcJasqxxs3+Bw
5P/7hXRx+Su2gEaNa0TlAwa+PL28TKmGYppP6mEKG97P/fR45Uw1Nv7SNFXP8awQ
3T610ViLm+krj3AsE7hr5JwRCPbedQvHm2mrQ+onv6Xtm8PDzbuqpAHltUQWBmnc
dcByH42ugeGQmajwM/4hZVPpPhk7+67HFCUN/Qs1HX2KnJJ9M++sMt5Le6nk9bVo
YSoKXwmlDPvBiT43gcL+ckk+QjbrpJ6hZFRdPAIJzjFSvsFbAi5Qaxam6J3OWiTq
3wDqO/GnPFtFvtmpUc9iExRBy772u8mNb2BnEPD2rDnw0bTxuWHkWIo6iQljl8z+
PxLWtMyxBbcQpa46JrS6Tcdx2WpGSOGOdCpmQ+O2qe2B4u2+/GRJTP5bwQ8CAwEA
AQKCAgEAxAqVrszxydJfN19H+9VovXMLCqg15oC/IAxfudZ6uNKAXHlCQVGayt8F
TfBCdEeXSqAUCZRYMgk/dICtCyZXoRwGhL26fa8n/okggr2IMbKqMk8nLDwjGCU+
3uwZyU0o35s7VsTvRQTUc6VZJVmAdQkEuE9F3JLT3V7slfWNHgDLtsZb36jV0nwQ
SGbE7P9McwxusJRhswxs+quhfSDT0FbVcqAi7GWeKBbXpyPTn1/5GP8WmMT4ve9c
ybtRa8jqfcjUo54e/msXbYfFTXns5KTFeqhoZPfK5V5IUBY/+vlJkEvxgDrUY7r6
g1F7JspbJjFzodsllTmrhHxHogf24rU0HZyAWujcv8zb7t2i2R4Ocwi3hnBNCMZp
ZkxjGT3nLSGjlmGkmvXd0fXwzJ/XiNuC97SJmz/1tPWlzeiGFUrFjiOgflmLfzMK
HpvF73Z2uPN4Dq9QpmqCJrCA9sNQ1kNEtE1xihITsR4ak2FUPTEXiYCGzmQohgvJ
H0VG/kXlUeGgcnbWoeJVCiTS6Y6VHj2XPp82aWxA1uNXhPSimbAEdX7SrWdbiXFg
wIEmxKZzlfHmecwPKViP0BllfRTHfxyyrwH5URh+ceQ+QQzoLb1DyPQfaKVJRmct
strCGl9QcRNUYTsc8g20jq7ViI3IkpfJVcrCVKnqr6QYP5p419kCggEBAP6Xdi0H
M7saxmvc5+FmVnFTkrzpiX5VhD6VP8UufiHE21Bt64hSfOGtSX9KVmwrVc07mra1
RihewdNgXeY+q1L0fXAaFXR68WUPB6i/lNtswuYNDaDE1kOmB/9eCNrzgG+7Tkcj
JlrUGy+/48FSSzhKFUWpIkD6ih67eMaqILJAcWfh2T1g5ZaKrAcQadq1xEFADoO0
4662f6dYmEDT0OAiXN1hI60/gY5y1UIOUp+AO+m6g4LEEjn7xOr2bnmJMg4NnAWb
yTIzEg8Qf6IK8dGjYD5cVJQRZAvBabQ51s8S2/xYSECPnPo1XARcdALUmxB/fCL0
mIqY5agHhq0XNUsCggEBAMmKtsj3xzQ4nPeIjtkbNwxXNYjsuh1X9DxiIYm02Njs
RS3F6Ms9Ig1eiglgkIU9qfXZSwxcXtF2KOqLJCoNxgBwf7GL9UgOa6/768NgKfZp
g1YlPkhLIjEMEZZfCOqFGJ/rwmJY8VESyP0HIwLbK6ds1cHR/xln6GvuoHJMPB0B
fgj30MX0Yvf3AiVBJp+hrHN55Nd6eh+He61jybqgEmw+ZnfjlsrWzaZDGJQsYYf8
F0jyujcCk9Dpb/YohygpTM/mtlHUDGvazbtwF2+HA571N2z89hQA6iVRMPheJ2sU
1uVcshzQfc3S3p/8ruXEsH7aW+n/b86oYID7oGgJvM0CggEBAKvT/eaWHcwCXjke
d0Ihl+YUyczGsg2aGg9DHC8xGeAgxQSbq4PuaGrIUfqfaYTIGrjRqbH21ssYaSkI
uVdUpLzwVlj6wdBDyfizFDBIXWdbGI+77566OwKdZHhuNvvPrLe8azCIALL8xPyN
PmKT8EClf4XsiTnh3qavUOyElly4MdIzFDPg2hOotEJwSYFbfIGtgh5ST/jzI2UG
3nuiei9MAfFIRpP/cKl7x4M1t33/RnCReYEgZEzOKDGM8TMF7cqeVNdUNY6z+VRB
hmMPj/Y1lheAqXTl5+gnOfhxsRFBYUgHLXylcQVOTjSDUak3ZRDVeir9epbQau/l
ZHgeWdECggEBAKXDuKk82pRCCCC0KcG516IHzJltE3r1D4XmtGz92Ok6E4AdamZX
Rr22R1SFHvjoCfWSnl5xTu96/xZCESGhqHxOC0jts3Vrnvjk/Dn6yyjICeT9xudR
HLM4mPKUAdJaXDGUiJG5U+n5yGQMzagYuiP/qSS8YtPzmb/ESiUYPM0ioBYiNY3L
fucyO4qGtozPPfbQh/8O1ok+NuQa0h30cJKlFESBZVI6MHUSdJHSmvlsx34RXkXG
ketfRN4y4U+QAIRy3vwYq4q+MT58aForsze3urmiqYc0ZWECEYQGdOdnAYUuo7R9
ayuxx7fQ7c0/5GbBlJ22obBY3t7Xl0xazfUCggEBALkEvbBtKc/GYaYgUPbxGfzi
lsPQxzQoFYe6agV/YG1ZOC8wTDaTAQyctFVO7nqkLBS6iecmwirkML9aeehsZVeW
xkcqYMAFC+6z1mvgjtmZqlFaoP4sso41Gte/eixanTD4ljnbytIeLLsn92boN3+n
8iQr3TE7B9jpLh6/ZOJU7r3X31f0kFwNJainu3YFXy6l4qUwe5xNrJALAHJc/Cbt
m+mO99OHBZSTzJHOHXrErR2g6fsIf4zGodwxzo+mxQAC0+ikgmLGL+XGkDtb+9ur
fFZIACGhB8aba2yIKMUkjn72QvpaX1KRsh3MKH1ZDdDmOSVY9UE0c/GKpItbjaA=
-----END RSA PRIVATE KEY-----

```

`tools/certificates/client.pem`:

```pem
Bag Attributes
    localKeyID: 08 10 CC 85 C2 C5 23 26 18 57 45 6E 42 68 41 B1 10 98 B4 FC 
subject=C = BY, ST = Belarus, L = Minsk, O = Example client, OU = Example client unit, CN = client.example.com

issuer=C = BY, ST = Belarus, L = Minsk, O = Example root CA, OU = Example CA unit, CN = example.com

-----BEGIN CERTIFICATE-----
MIIFcTCCA1kCAQEwDQYJKoZIhvcNAQELBQAweTELMAkGA1UEBhMCQlkxEDAOBgNV
BAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJv
b3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUgQ0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBs
ZS5jb20wHhcNMTkwNjAxMTI1MjQ1WhcNMjkwNTI5MTI1MjQ1WjCBgzELMAkGA1UE
BhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRcwFQYDVQQK
DA5FeGFtcGxlIGNsaWVudDEcMBoGA1UECwwTRXhhbXBsZSBjbGllbnQgdW5pdDEb
MBkGA1UEAwwSY2xpZW50LmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEAyG7fNpmwFMip2daVMWleNfQ4djHJpAD3CY4PFL+CDU3MRwve
QWyX04iOpInhRk8pTsPisWCqouBxmo14jprAOv5XVEm4eHTcvxQ1UsUBPSzF3h1o
Uy2PuOnd803N1ja239z2jAMbdNwnihz9SoNT9i5wD3rDUK3vbUx1i8ixC/wX0RMI
Vb1RtE+dCbyhsiXTesotB2uqzd4cDl0gLBmD9+lOlPKA5Qx3bzFJAjr7YlPEBL7J
CL+bj+fC2lX7Hbn3tj3fPtgHjuglIL26WM8K8OYDdM2fq2X0XfPTcJasqxxs3+Bw
5P/7hXRx+Su2gEaNa0TlAwa+PL28TKmGYppP6mEKG97P/fR45Uw1Nv7SNFXP8awQ
3T610ViLm+krj3AsE7hr5JwRCPbedQvHm2mrQ+onv6Xtm8PDzbuqpAHltUQWBmnc
dcByH42ugeGQmajwM/4hZVPpPhk7+67HFCUN/Qs1HX2KnJJ9M++sMt5Le6nk9bVo
YSoKXwmlDPvBiT43gcL+ckk+QjbrpJ6hZFRdPAIJzjFSvsFbAi5Qaxam6J3OWiTq
3wDqO/GnPFtFvtmpUc9iExRBy772u8mNb2BnEPD2rDnw0bTxuWHkWIo6iQljl8z+
PxLWtMyxBbcQpa46JrS6Tcdx2WpGSOGOdCpmQ+O2qe2B4u2+/GRJTP5bwQ8CAwEA
ATANBgkqhkiG9w0BAQsFAAOCAgEAgbhW3XJDV/j8TNZLVlH2U4ocmdUUO8xT4sqw
S1SzGrL7t6PA2Lus/LCnbOwakq12SzuH2YmTE4y7wXY/313kmYcn220qohdEgxBk
JTNdSvQ6/k1FgJcqCoMLHq6+J8fpW7cYrigHknK+gvKMFoE/cPVAADn1KaRg08LP
fbg4Fmi0ZAvf5VT0KqlfgodORoruiDj0y2nnX7HGKy59mzNteJTescvwt2uDvuhF
xtWsPP/vyYE+XGuaJTxIYUiPhsjVuC91P6Jj8UZo4IJrBSrtbMv2TkvBYh2NstDN
gCDef8ESu3rv9O+UWJh5QdSnY8NFoAe2ZtItjQ1zGXT1DFtd2OAFQUW0z7E4IgRQ
DppXhY2xdcNP4sQibytGfqC8Qi0DexWtLPXVPj7J25Cvw9q7/FkqwKbN3RxB8WA0
nen4VHW6SqPxQfdlmDQuxQymwhONPDI1YBjsQ569c9d2k67xulyadLNPhtLDG/NR
jh6y+hB/NXZyPDqQM+/IsqvvQnGUHmssmaF9udYo6JfJx6YfaFkJeGE1P6+67lJi
wFXaXWtr26QgsNQXBgqKpwk9bo2S8JFObPAJTCSCRFaXOtB/kApQ+mTxamG2ycyd
fg5p4Ef30Nfj3/oHdbw7aj3O1xj/4y6HfT1cLV/A1t9LJ7kO134rHao2NRuvughr
5kfERrg=
-----END CERTIFICATE-----
Bag Attributes
    localKeyID: 08 10 CC 85 C2 C5 23 26 18 57 45 6E 42 68 41 B1 10 98 B4 FC 
Key Attributes: <No Attributes>
-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIJpDBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIn9ZRs1XzmiICAggA
MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECEOmLgWyK/QPBIIJUEbtCkNHCcGd
JSEUtl2rGfDSw3sw0VEoM4zj8kLRqU9M5dX0hpxeNtfGTylkdK0UkVhUpPgFIeB/
aeC2slvZR+BGVBoFM4Ihx8uD2wCtwAY6BzSwXK8BXnvj81yoF/dzzRHUO1c6/WZi
o/UT+rOnU7z3/icw0dfYMgo25zh1oslIlTI16LRH1h376LhoyNPLM3JvdI1R7Jy/
P57QUVgcaV40AyKLmvGKw1TXgJYAvhi27nQTkux03JMri7b6d6fSQkpZ8t3lsvz6
SnF5TduRH8LHUuEfa9ciXaj/2BJTltC/uVqJ0YH7zOi/ggKid303lxMTtyA7MbnJ
grafC7aRkbrlxpZAi3+eX3ZJXTHbNoYDWep5VLmdDuGf2uE3LJvg4KTSQaLnuKRt
PGeq596+45u1YkAhreuJYitOAg8eWXxmC8hjIc5cVQ9G/MgEAl9g6dYODU3ULD8j
kcC516ybv49TYrThYQf3wJTiFLTdrkGsDHvUyquCHFEr+87WYzVdrw8m3LuzMMBV
GXfN3tPWdM7P4GKXcmIUC+S+JTXnTUoGrKjmew1Q5yhvb2YFV8f5h7IaAJNqabzG
JJf1UBBfA03LrGfeJjKG8uki3FNlLxokZvdGo67rjcWAcHnk1laysEHYuY8Z5ZPJ
WVExjYci3P5JIWE8eYFut57UFSCacNfPDhNt/SpZXwp+shTb//NvdpWG0V/xhvxh
Wj8NbOkAzaW1pzHVYE4wq/zxsoOIbvwKxyJfDakPos6hFgGHc+MB9+5nMYuLlF9B
ItT86BEAU3YXiF3IyzZDhY/YCUEYTOWAI/LlAZ5kkzM0q3A2HF8FGcrggIdDqu5u
DunKvRZzV77nimeGjiH+Eh5xKaf/In6nJkgvDZCwspjc1RCrtdTHvVRmydVBjuaM
F+M3dpIOyWlhnmw62FCMq0Fh2AzK2qpXz41Z1DKCf6BBdDwb32vqcrRyZzP1+c5Q
ObHQozYt04MQD2AaeifAY76SD+N+i4UAdDd5J0jXebMqP7vm9PocjMWhkQtkeZbR
jm4c3vCjgtC5kJlIf2AZ9FQ4d1946iXuX+kA4T15zGnWKugtTUt/8ps+oET6PskC
r4aycy/zDcj/wEKiKunDEIauUkutw1OAKDEt2YLFogyeCqdO4518XWRIVdWcKN+M
6VxS6jdelY4ZGBSMFhjK/1b+nV0F07lPXhMIlf9fB9AemainilcGjuKgCxiAnnQ2
QuS48YhH55R79XG415uZTXqzYDaKlYyu+p8mwTEnheC6McAUagM+1TALOk/gj16N
k6+tpnsoqFcqE/YqAXGNMOC3ckdRFWCiPeuPBJlqC/DpIQ953tbB8qca0zRLee28
c6MhFVVIjrFzSsXuB2eXOxzCFOZyqPIlc56rm45aEwUNHEZ+RcAHAvU6+CFAjypT
SmhlyByrUT106gN+K1EBYYBu9WQusFKU/tDEo05WKjaFLi4t3GD5NoThYVJNZCPj
0TZrKDS9W6dkBGNHZB7YlGNOcENFWrczx6r6w2Nu6EtObagcr2/s+tSYPEO5QnpP
QF9IQNpQ4SyknGEcLpX9GtH5dkJir6sGXVsUpv5DvsOsjySCHmNGudhwIdCF1T+D
nIEyfe1r103ErOf3vZqRbaAygdQeFlhCBMDveTS45XGyhs0atSLb1RssO7p4DWmc
ZLpp7MlXmLk0QVSeiUhUvvhhTzE1S64T35Fc0vmhsdJoSK+A0tOm45eu/9nX0+rU
WkXehiFpIz5t6oxBIT5O1r2iQ20rfJIGRvVPQhmUbJahH/vewa4shBgdvmFThNWd
NfGonuu5MFa9Q2N43NmnIH+RwHAc5ZAmX6ujgBFwXMUIFvuwupj9lz6jPHXqlHdZ
Po90i2tvkDyMn8jG5/ab94OSo+WV2E77ofg+zyrY8EEDttQiDY+e/73Szdgz5I41
esUJ0d+pj4i2pC9ssCY9NU7Z4jZxFb1cjYcqgXb4nVU6qURWH5+IyhT9+xQyTE+G
VYFTHFSw9vphAh22Mic0oi1ltGv1PovnVRWCXio6PLP7sxhrWM56zyEfT4OrKRC6
1lwosYxoU7bvGHhB9rbJoDPOUZL+EtmMr1sWB9IIF4L7T/twicCnQinbVw+ewkjK
hnTlBtYYaxa31RSOWLvLraa58T/M8hJc3iiWOwiuGKA4MdwctVHlMvbylS1930Ox
MsxbGKGnq6slMxXrxHAA3QuXpqqQglQlaGt+BLQcDCIA4vaitBwURzU3/CAXuhkx
wyIxCyDeCYFXZ/DMQz/U02IZiN17EjQmCNCK8dvYXjZAlsZ7x+Tme5spcAeCCmFt
LLqWDFiXoEszVPQnav4IJgKcreyY7qG7GBvrGtOvX1GNzknYtzBgEo8cuRgt/pTs
4SSwvS34XCEwltomBtWpYQrqhXNpyQVfAisbxAmTtXCjrv7UfPMphbiVVydplTXZ
h/xuXH+ydxXeD9jIdUKzOxhLfBK7DBiR3MMdwm8FIWdVm395/NpFgVc/xSi0RCCs
X2Xe/56qZBhGez1r202GPOQPzH93RutmBLPRvQxg5lX8AbDwsG5lb/gpTmpp7ZsW
9rG58bhLMLknhxefip26zRkECFPQmg2rqlzNxFejyiHnZIpqrNCw9W0KU9kBSNd/
DreiF1sHAmAyN4AayetoQKHFJCqcSjuldOI+sKlohlicbzG89So4jzmJJj5PAiA7
yRzYM0sYh/NPkv1M8Oc+JoO+1GX8tmPQHuiL9BZGo+MQQHmkcE7U8r+ZwhDIdy+B
2Rej5ZGX3orwnkh6FKZNIVdRF2DdbhLusOCYRpnjxXeuuYNWSZgobDrLEzdqstNj
9BkZ6RgqShIWCkwfxAIuyYSSDp4KPxmz4GhQB0ZdtJAo2zhLnHGi0m836oWRPr9+
ewW1E0h/n37ZqWo4fy6UGGiptr00uvB53H6O20QUifmp4QILHj6J0t67ZaUEeDSV
FJYd/5+xuiD90U0AtOgUoynkBW880cvkZ6UQDFVBVrkouyRQHDn+Alb2NSa/yG77
79MwhPXx+9cslW3n3S5K8zoKlREi9nZekKqZO47zL1g0KqKS10RD5U3C5dHoljQR
feBED0fz6PGo0pDOABdT3byCRej2wIc5pYYhBfxCGl3v3zqH9AnNVS9mPENKBpka
kHY3GGTTwLDiNocHF3gSqLheW0gog+N9
-----END ENCRYPTED PRIVATE KEY-----

```

`tools/certificates/dh4096.pem`:

```pem
-----BEGIN DH PARAMETERS-----
MIICCAKCAgEA3vn3BRdZq7LQFwt94mhU6oZdPKSsrO4Iylb3FVEp4BY4JNGKAANc
m1nFkCTSTLonQBNyDmfYPh1aHaXhl1J7QOGDMo+ydMNnsRDv72iuwJxb2RFC2pb7
B1mbgkzHFW0xcMefIAnvYXxS5tcPV1zoxYAeo75YsJXb7NxBquW45py/0W3Tf8lB
Ml60GjRSA9bnlS8hLDbz/Y0i2Fp01MH4Isq0EvaYn/BckBJpfMGDI67+cjeSfZY9
+FV9po0qNVV8kl8D0oSWp1xBSigNuKb0x/XloW9zlrNClpHlFU46gbvlNA3E57w7
B4OUTUHuMYVmVnxIAngJLTXAD9iii+Am979qiJbZMgwA1iGxtsPxS5/dyzYfFSp4
dfQnMNvuxRzJyYtk8Q/pZZxNdDhlKlIPpF1UlXQwoO4ppOOCUndAIomzMyP2/Up4
FlYd1Cgo9rg3FKyGBxbQtwS8JhthJrqjnhiI/eaSyzP9aNFl0YsTfCMeMOtfgWia
BoD4BFvsuBZa+YFE0un2d7uSAHdCq7BCY2kNu+kD7jVp6bh9ZcZayWnZZy/1Gp1E
ChvXuaFwfqwNBTde7HlR1mBg3LYHvG41yNgdAabSAudTdUVkrWQM9yjSdMFYciVe
ncyqkwNnZhcMf/CeBFx3fJndJih25N8lIMhNkSXUQ507Idh5MUV1DbMCAQI=
-----END DH PARAMETERS-----

```

`tools/certificates/generate.bat`:

```bat
@echo off

rem Certificate Authority (CA)
openssl genrsa -passout pass:qwerty -out ca-secret.key 4096
openssl rsa -passin pass:qwerty -in ca-secret.key -out ca.key
openssl req -new -x509 -days 3650 -subj "/C=BY/ST=Belarus/L=Minsk/O=Example root CA/OU=Example CA unit/CN=example.com" -key ca.key -out ca.crt
openssl pkcs12 -export -passout pass:qwerty -inkey ca.key -in ca.crt -out ca.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in ca.pfx -out ca.pem

rem SSL Server certificate
openssl genrsa -passout pass:qwerty -out server-secret.key 4096
openssl rsa -passin pass:qwerty -in server-secret.key -out server.key
openssl req -new -subj "/C=BY/ST=Belarus/L=Minsk/O=Example server/OU=Example server unit/CN=server.example.com" -key server.key -out server.csr
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt
openssl pkcs12 -export -passout pass:qwerty -inkey server.key -in server.crt -out server.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in server.pfx -out server.pem

rem SSL Client certificate
openssl genrsa -passout pass:qwerty -out client-secret.key 4096
openssl rsa -passin pass:qwerty -in client-secret.key -out client.key
openssl req -new -subj "/C=BY/ST=Belarus/L=Minsk/O=Example client/OU=Example client unit/CN=client.example.com" -key client.key -out client.csr
openssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt
openssl pkcs12 -export -passout pass:qwerty -inkey client.key -in client.crt -out client.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in client.pfx -out client.pem

rem Diffie–Hellman (D-H) key exchange
openssl dhparam -out dh4096.pem 4096

```

`tools/certificates/generate.sh`:

```sh
#!/bin/bash

# Certificate Authority (CA)
openssl genrsa -passout pass:qwerty -out ca-secret.key 4096
openssl rsa -passin pass:qwerty -in ca-secret.key -out ca.key
openssl req -new -x509 -days 3650 -subj '/C=BY/ST=Belarus/L=Minsk/O=Example root CA/OU=Example CA unit/CN=example.com' -key ca.key -out ca.crt
openssl pkcs12 -export -passout pass:qwerty -inkey ca.key -in ca.crt -out ca.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in ca.pfx -out ca.pem

# SSL Server certificate
openssl genrsa -passout pass:qwerty -out server-secret.key 4096
openssl rsa -passin pass:qwerty -in server-secret.key -out server.key
openssl req -new -subj '/C=BY/ST=Belarus/L=Minsk/O=Example server/OU=Example server unit/CN=server.example.com' -key server.key -out server.csr
openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt
openssl pkcs12 -export -passout pass:qwerty -inkey server.key -in server.crt -out server.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in server.pfx -out server.pem

# SSL Client certificate
openssl genrsa -passout pass:qwerty -out client-secret.key 4096
openssl rsa -passin pass:qwerty -in client-secret.key -out client.key
openssl req -new -subj '/C=BY/ST=Belarus/L=Minsk/O=Example client/OU=Example client unit/CN=client.example.com' -key client.key -out client.csr
openssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt
openssl pkcs12 -export -passout pass:qwerty -inkey client.key -in client.crt -out client.pfx
openssl pkcs12 -passin pass:qwerty -passout pass:qwerty -in client.pfx -out client.pem

# Diffie–Hellman (D-H) key exchange
openssl dhparam -out dh4096.pem 4096

```

`tools/certificates/server-secret.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJJwIBAAKCAgEAtdVvGlBsP+78L+bpRgvPdti+AVgM1JCMP7mOHvv3m+x0gIp1
j/Sg/S0h/leYsPu7H2k5xv41Y4fmWPX7u0xPLdI+/u1zHHc6IGEaM0aEddEruDUr
QcQt+h62c/nIJ+tcXuSHrTZREbczZq4gm7exvAuvYd0B/lg2kXLQ9Y7eqShhKPtH
B6a5YH2snJWJbk8E9WVwem37nrH5DJ99/q+hQHl9rdrP03KAEIbMLGgo3r2YuOoa
7qoywusyH9xMpWzDt0QhXxhfmWnSNyZG8ztfoXt6TDTZQ2HD/H/dZlt3skgJAWcU
tlF4l0tZ55495SC4ozFyk84tNJPBD/QkRYmn3GfJ1zHgdFru+H2qYHJv5B4ssUbS
cPkXwcsASci/JiyIbhPzOpbpCTUGX3OAMBKIFtxJNKmHeosftR9I97dNfJZCCiC7
k5NL8GaTw0484tLqfuH1bOmUULsfLaEj6rsiXLz9uB8T16/K9pKf2LIB++eCEU71
S4n6BHyiH09uL1KZ0msc5beggUiUglCUYy31aIFuZl/wCuH8GJZv0kepAWLIL23h
PwpzS5o+tZHefwS//qG8mcy7a+NcLlIsLNPRVToYmlcNnfeAxcDqwRm2GKfAY4i7
CUt4vgyEGbFxBNsh6ozTkd9tE3qkRtpMRKcX3ZQmYJNjEOl7XCnUk9SLMOECAwEA
AQKCAgBb3rJ7wRZwVvbj3O8PjPgNPAUD+NDCtSWnLME5tmSsSxOxvkMXsKmGQT9j
mi5zfTxV6nxepiGjYA5p9B5zy2JV7FwXwTDfuP2NToJGVeKnBD/qmjJ4z/3K2aml
fxY51RieeShzw3XCVaWKw3+GLZGHSQAbmeZf84Heivw4lS66mMQ+SHbizsHqlpSX
qJX/Pb1rnwztTpRK4fDLB+pIu8PlJ3zwUhWe58L8lp6h8R51K6X2B5ID88oh4WM5
5bxz+DgKaEnUGiRzBpxHcPd3/Q+cLx7jUfBTsxmqgZADH0Oit/KU2tgEJbWf+1o5
RCJRme6vxVP2ib0dS2nH/bo1yA8e2uGu5n7ZRxEdmA7wNGsxokBp5ifAOtsVGwEP
CmKD6+kRVlb5zEc+jGsZISpra/3CL42eM1vLGaY9bVBhVrW5YyOyvaK0S6vjzPsf
T2rqWpgZ7y+bAwfGgkKM7AJOJ2NMGuLkcdiWfKQsL3UdMKSsplk+rnEB/c339AxX
+Y07rYMX68mp8vBYsbZQmLwO/25Wbba18jIzkqlHYrk7vhW4U5X2A6QULfrvp3/W
10Voae61GznWKJ8be8iK3Hf3Qw6xirQayj66wRdJjmAwv7+hwdIDY10wregKqtut
64g3FPgYmyxk2PmD7dRbVeWdxod3LKfA4wRYJ7t0Lj2V3n/sgQKCAQEA3B5VfB//
t0hjZM4tRWUn9oDb1qrtzAM+2KR4Td+CQDk7eEVfZNuOORZLii8irmtCcFSsOTtV
zQcIf4wZU0xIpeFkUit+QxqZogMI+IIA6JzQwmiCMWyb40pLO3v1EA5K6EAXhSTM
EZBYyycsYtQKUp7gv/dq5H4XmpQVb4ZDfoo2zqYAAHOmg76lRXopeWAvtN2of+PJ
A6+F24xcDARo3BrMRC7nHxwgLCm6gJzt09xnG4cMlix0aTT23y/7CuS7NZFHKITv
DMzJ5Ye5gU8TVh902/LAiy6MjVbTXjhcRerHUnhg4r47vsB653yXnMYIEmYC7s+/
GHdQqS7mTK0oBQKCAQEA03l0qHimEvaknNCCEkvRJGCXWeAWXE718SLGsPsdeMup
nQmUacWmX//eYKk3RrlzJr7tABW6EeTJ6enoC9/tLNQD/sOm3Eh5pRd3o+Re33Xo
8uHh+mAqCM8jeaPMhkQZww8m168HAC4N4uxMRcOFAqB5ys3BHJvbjJsWwX86uoaw
tf8cK59P5e7lJzVhQ0sEgQGHcIeqquzvqSHxYgp55l+g8Hf1MI7qWCD+Gt86HDzZ
kNsNqHJcJdHPr9MI8KXuvgl6aGoXIvit8XQ7Hg8OtX0ExqGoeNjBNyIyifk9ydtO
3of4mXy0q29yTzV0Kt/cZvp2bG+7Hd5JJ5GLa18ILQKCAQAG5FxA2q+jCX0zNtFs
DtLFgRthCVEQxjk9h0jNB2aIpEIcbe+itM0rNGuBFCC93VXjNoN990GkfcfiVnyk
gwrzRq9hc0MszrRowjeRsGBe6CoRLDyHV6M55qWcYzE1I31s8DTMUm6hTie5lKxr
G8CG/bqDyDdsmBYdHO3e5BFQ8PruVXxCh1x7W4jJOB38UuqrexU/i95LYz+JtEdd
iPXPjnc+20kZTEQlndjdFgzMSWZhEkVunk22zZW9Pz9ZA/hooPfdaOwjNnZL3YgN
aHBujeWWzW8B7J8x/bn4hUM+XS+IgYRnFRXBzz0J6njEy96M1OzalV6iYXoBEhrb
48ARAoIBABcIaX5X9a6nEnLJ+wDHJTZTFukBES5oozzqTr3D/AfGFuk1u+ZxUpeu
JKhehdi8JiCYNvQFaci9JIjHozB36TsytGSxJqFje2xRzAQbwYGRNBgQJi7A/pML
DJAZGROeozetlMt1EswgN/75Qa1viDMrC1jdZCUbjKQZ2DanBtx+Aw0vhf/yUB95
D5hfpgJQT2NFqVzGSf5n5AqF2eaVwYUn8T1/s0LgrgF/Rm3i1k9xCTlPwoMQQZ0U
5wv9bkHXsNMd8SkiNPboIvnjcPTrKuz1eumvfcv7v7+jh+GjNemga0ytfpQpEvyB
HPAnoElzLGxC51cULEsqhMk8fvTo2tkCggEAWGVqTvBZOW/HH9F56eXU+N4EFbDd
QAJbY7uGnpUWzlfz7idUmCxVgTZ+qLwQGvebD+EVINiT3mWXl25nWWSDArMGMLtq
UD9GB9RuY6xA3drK0mW0EMuUzU6Qxq3AYUEKhSXiRjipCD0fIZbq7hBMQ+a1Tj2P
phVxgVMA+z1AEyQy1LogNuXy/0LfYoFisqQfwzwqlLYcd6jdsGrp53NM8GogRCSV
x0vMddjjnZhbVnukmPWZfasuOstBy9PcB5uzvQzDLAv59Yho/RD4sqamPXQpbY3S
aqhG8KD/fYudFbY0J06VESq2bL/ZpMMPK9MJgmcLVXcR/MBjoXUI24PzAg==
-----END RSA PRIVATE KEY-----

```

`tools/certificates/server.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIFcTCCA1kCAQEwDQYJKoZIhvcNAQELBQAweTELMAkGA1UEBhMCQlkxEDAOBgNV
BAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJv
b3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUgQ0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBs
ZS5jb20wHhcNMTkwNjAxMTI1MjQ0WhcNMjkwNTI5MTI1MjQ0WjCBgzELMAkGA1UE
BhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRcwFQYDVQQK
DA5FeGFtcGxlIHNlcnZlcjEcMBoGA1UECwwTRXhhbXBsZSBzZXJ2ZXIgdW5pdDEb
MBkGA1UEAwwSc2VydmVyLmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEAtdVvGlBsP+78L+bpRgvPdti+AVgM1JCMP7mOHvv3m+x0gIp1
j/Sg/S0h/leYsPu7H2k5xv41Y4fmWPX7u0xPLdI+/u1zHHc6IGEaM0aEddEruDUr
QcQt+h62c/nIJ+tcXuSHrTZREbczZq4gm7exvAuvYd0B/lg2kXLQ9Y7eqShhKPtH
B6a5YH2snJWJbk8E9WVwem37nrH5DJ99/q+hQHl9rdrP03KAEIbMLGgo3r2YuOoa
7qoywusyH9xMpWzDt0QhXxhfmWnSNyZG8ztfoXt6TDTZQ2HD/H/dZlt3skgJAWcU
tlF4l0tZ55495SC4ozFyk84tNJPBD/QkRYmn3GfJ1zHgdFru+H2qYHJv5B4ssUbS
cPkXwcsASci/JiyIbhPzOpbpCTUGX3OAMBKIFtxJNKmHeosftR9I97dNfJZCCiC7
k5NL8GaTw0484tLqfuH1bOmUULsfLaEj6rsiXLz9uB8T16/K9pKf2LIB++eCEU71
S4n6BHyiH09uL1KZ0msc5beggUiUglCUYy31aIFuZl/wCuH8GJZv0kepAWLIL23h
PwpzS5o+tZHefwS//qG8mcy7a+NcLlIsLNPRVToYmlcNnfeAxcDqwRm2GKfAY4i7
CUt4vgyEGbFxBNsh6ozTkd9tE3qkRtpMRKcX3ZQmYJNjEOl7XCnUk9SLMOECAwEA
ATANBgkqhkiG9w0BAQsFAAOCAgEAC/W9uU6zNgUzoxP3qCIXgpPPItKzkbQArXK9
MNqWnBM+ccUbaGCUMG/i5dmfT2YeTMC72Z71xb6QznFJHXOuKKVPzLNwVuIR/xwE
j3BeQkUZ33Kf8TUxz5owHV9Px944KiEwhIOyPjgbG9WPL5IsXMBMLZi4EAVOza7T
lqykOfgV2kwFEOPD4Sz2bYOxp7eNu+cQAMf/COQrMC2L97OtcrquipRAaY2rxb3Z
pD8r3ymRs14K5rf6LTUrxrCIeZewxLyX8FedBZPCUCRLb7lsu1r7OHtbt+xUy+7i
KtmEqgLpJ9Iu8xK4rf8ReLkgT5SownaGI+ddYdyB5aiR2DgLXKxGQZ6l6sznkzDk
X2UZAtzhTxRaZ8wHMmR5z7q/F8EM+PR0a1Y5Of+Yosv9dTERMyNosnd9EHXTbgSo
ARaPso0J9V3jXm44+qd4pHgnLr7SOp3B5Jf71yhN1p5fKYqPkbiCiZFxOXO3s5z6
+4247z7ZCD7k9UMqKflj4eLQD+OnTJ6VFyrovTQnjCsbTsEmI1S8arvAEosAX5GU
vR05YZnEO9rEzOSh9tBuuht8woK5tQpLQwksgOiQATcZCN/ioz1SmyrRIfwEBh66
MB4SMwGjiaARsWhV+iEpS8mwvI1WtX/4Xgo7NropbFyIuJsZsmvDfuffqp9Z8f/b
kYDiTio=
-----END CERTIFICATE-----

```

`tools/certificates/server.csr`:

```csr
-----BEGIN CERTIFICATE REQUEST-----
MIIEyTCCArECAQAwgYMxCzAJBgNVBAYTAkJZMRAwDgYDVQQIDAdCZWxhcnVzMQ4w
DAYDVQQHDAVNaW5zazEXMBUGA1UECgwORXhhbXBsZSBzZXJ2ZXIxHDAaBgNVBAsM
E0V4YW1wbGUgc2VydmVyIHVuaXQxGzAZBgNVBAMMEnNlcnZlci5leGFtcGxlLmNv
bTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALXVbxpQbD/u/C/m6UYL
z3bYvgFYDNSQjD+5jh7795vsdICKdY/0oP0tIf5XmLD7ux9pOcb+NWOH5lj1+7tM
Ty3SPv7tcxx3OiBhGjNGhHXRK7g1K0HELfoetnP5yCfrXF7kh602URG3M2auIJu3
sbwLr2HdAf5YNpFy0PWO3qkoYSj7RwemuWB9rJyViW5PBPVlcHpt+56x+Qyfff6v
oUB5fa3az9NygBCGzCxoKN69mLjqGu6qMsLrMh/cTKVsw7dEIV8YX5lp0jcmRvM7
X6F7ekw02UNhw/x/3WZbd7JICQFnFLZReJdLWeeePeUguKMxcpPOLTSTwQ/0JEWJ
p9xnydcx4HRa7vh9qmByb+QeLLFG0nD5F8HLAEnIvyYsiG4T8zqW6Qk1Bl9zgDAS
iBbcSTSph3qLH7UfSPe3TXyWQgogu5OTS/Bmk8NOPOLS6n7h9WzplFC7Hy2hI+q7
Ily8/bgfE9evyvaSn9iyAfvnghFO9UuJ+gR8oh9Pbi9SmdJrHOW3oIFIlIJQlGMt
9WiBbmZf8Arh/BiWb9JHqQFiyC9t4T8Kc0uaPrWR3n8Ev/6hvJnMu2vjXC5SLCzT
0VU6GJpXDZ33gMXA6sEZthinwGOIuwlLeL4MhBmxcQTbIeqM05HfbRN6pEbaTESn
F92UJmCTYxDpe1wp1JPUizDhAgMBAAGgADANBgkqhkiG9w0BAQsFAAOCAgEAOiyt
IFW99oEKt3GynnA4qyo1ppaQVOdhErqE7VzOOLUEMYsHfIOOQexLNzmRUwjgZ6cj
h8ee5qrPSmG+s4nLos08LNTi61edFSb2wiL8GwUJo9PhraWjQdB/SJLjaJ1UIILS
0C11M+IdHNSgriW1OKdeAV0rj7391MhTNl/7FeAqhYw7geVfOuO7c3DxLt0Ce07K
Qcf/1jt4vm8SzY1evZKfd4Spapgpo1FMpMbA/ymxX7eI8lbOxYSCE8rwf0ojGzhN
bCs0Lu9oby+LA23EPB/1aMCXMnuKBdstX9I1iFXqjSl9Ljiz+ShKYgeM9atWNtyW
FsFcl39S0vFrdVhcAiIiC0PxjEAxGRKFjyuSxhjBLUcv91WZMfexqS8FkamlX/t6
VKUS9VUW7fK6AFXvrGOMbpvoxBtEcYcU71Wj16I1GSXn4u2/VzwL2xGTqMRVRdvc
INwAOqEzgi4FEeT86V7kuKmAfr5s67y3Kprpkfz9xW1sfU58qDjntIXrD+GynUzS
2H9BL44LlJMtxs7IYV1RO+Po0zFYlUWY8M951PIpvRSXYGX0uTH8GFHiltQQpiIo
+fpwkJw8R7iq6K4Z3M0iL9ZtACC6lGYDnH2PZXUbMXijCcvkN8Fm9knewOR+x7FQ
KRv51X528kMxA5FB9ZEBPMbh2gxppoBe3275svM=
-----END CERTIFICATE REQUEST-----

```

`tools/certificates/server.key`:

```key
-----BEGIN RSA PRIVATE KEY-----
MIIJJwIBAAKCAgEAtdVvGlBsP+78L+bpRgvPdti+AVgM1JCMP7mOHvv3m+x0gIp1
j/Sg/S0h/leYsPu7H2k5xv41Y4fmWPX7u0xPLdI+/u1zHHc6IGEaM0aEddEruDUr
QcQt+h62c/nIJ+tcXuSHrTZREbczZq4gm7exvAuvYd0B/lg2kXLQ9Y7eqShhKPtH
B6a5YH2snJWJbk8E9WVwem37nrH5DJ99/q+hQHl9rdrP03KAEIbMLGgo3r2YuOoa
7qoywusyH9xMpWzDt0QhXxhfmWnSNyZG8ztfoXt6TDTZQ2HD/H/dZlt3skgJAWcU
tlF4l0tZ55495SC4ozFyk84tNJPBD/QkRYmn3GfJ1zHgdFru+H2qYHJv5B4ssUbS
cPkXwcsASci/JiyIbhPzOpbpCTUGX3OAMBKIFtxJNKmHeosftR9I97dNfJZCCiC7
k5NL8GaTw0484tLqfuH1bOmUULsfLaEj6rsiXLz9uB8T16/K9pKf2LIB++eCEU71
S4n6BHyiH09uL1KZ0msc5beggUiUglCUYy31aIFuZl/wCuH8GJZv0kepAWLIL23h
PwpzS5o+tZHefwS//qG8mcy7a+NcLlIsLNPRVToYmlcNnfeAxcDqwRm2GKfAY4i7
CUt4vgyEGbFxBNsh6ozTkd9tE3qkRtpMRKcX3ZQmYJNjEOl7XCnUk9SLMOECAwEA
AQKCAgBb3rJ7wRZwVvbj3O8PjPgNPAUD+NDCtSWnLME5tmSsSxOxvkMXsKmGQT9j
mi5zfTxV6nxepiGjYA5p9B5zy2JV7FwXwTDfuP2NToJGVeKnBD/qmjJ4z/3K2aml
fxY51RieeShzw3XCVaWKw3+GLZGHSQAbmeZf84Heivw4lS66mMQ+SHbizsHqlpSX
qJX/Pb1rnwztTpRK4fDLB+pIu8PlJ3zwUhWe58L8lp6h8R51K6X2B5ID88oh4WM5
5bxz+DgKaEnUGiRzBpxHcPd3/Q+cLx7jUfBTsxmqgZADH0Oit/KU2tgEJbWf+1o5
RCJRme6vxVP2ib0dS2nH/bo1yA8e2uGu5n7ZRxEdmA7wNGsxokBp5ifAOtsVGwEP
CmKD6+kRVlb5zEc+jGsZISpra/3CL42eM1vLGaY9bVBhVrW5YyOyvaK0S6vjzPsf
T2rqWpgZ7y+bAwfGgkKM7AJOJ2NMGuLkcdiWfKQsL3UdMKSsplk+rnEB/c339AxX
+Y07rYMX68mp8vBYsbZQmLwO/25Wbba18jIzkqlHYrk7vhW4U5X2A6QULfrvp3/W
10Voae61GznWKJ8be8iK3Hf3Qw6xirQayj66wRdJjmAwv7+hwdIDY10wregKqtut
64g3FPgYmyxk2PmD7dRbVeWdxod3LKfA4wRYJ7t0Lj2V3n/sgQKCAQEA3B5VfB//
t0hjZM4tRWUn9oDb1qrtzAM+2KR4Td+CQDk7eEVfZNuOORZLii8irmtCcFSsOTtV
zQcIf4wZU0xIpeFkUit+QxqZogMI+IIA6JzQwmiCMWyb40pLO3v1EA5K6EAXhSTM
EZBYyycsYtQKUp7gv/dq5H4XmpQVb4ZDfoo2zqYAAHOmg76lRXopeWAvtN2of+PJ
A6+F24xcDARo3BrMRC7nHxwgLCm6gJzt09xnG4cMlix0aTT23y/7CuS7NZFHKITv
DMzJ5Ye5gU8TVh902/LAiy6MjVbTXjhcRerHUnhg4r47vsB653yXnMYIEmYC7s+/
GHdQqS7mTK0oBQKCAQEA03l0qHimEvaknNCCEkvRJGCXWeAWXE718SLGsPsdeMup
nQmUacWmX//eYKk3RrlzJr7tABW6EeTJ6enoC9/tLNQD/sOm3Eh5pRd3o+Re33Xo
8uHh+mAqCM8jeaPMhkQZww8m168HAC4N4uxMRcOFAqB5ys3BHJvbjJsWwX86uoaw
tf8cK59P5e7lJzVhQ0sEgQGHcIeqquzvqSHxYgp55l+g8Hf1MI7qWCD+Gt86HDzZ
kNsNqHJcJdHPr9MI8KXuvgl6aGoXIvit8XQ7Hg8OtX0ExqGoeNjBNyIyifk9ydtO
3of4mXy0q29yTzV0Kt/cZvp2bG+7Hd5JJ5GLa18ILQKCAQAG5FxA2q+jCX0zNtFs
DtLFgRthCVEQxjk9h0jNB2aIpEIcbe+itM0rNGuBFCC93VXjNoN990GkfcfiVnyk
gwrzRq9hc0MszrRowjeRsGBe6CoRLDyHV6M55qWcYzE1I31s8DTMUm6hTie5lKxr
G8CG/bqDyDdsmBYdHO3e5BFQ8PruVXxCh1x7W4jJOB38UuqrexU/i95LYz+JtEdd
iPXPjnc+20kZTEQlndjdFgzMSWZhEkVunk22zZW9Pz9ZA/hooPfdaOwjNnZL3YgN
aHBujeWWzW8B7J8x/bn4hUM+XS+IgYRnFRXBzz0J6njEy96M1OzalV6iYXoBEhrb
48ARAoIBABcIaX5X9a6nEnLJ+wDHJTZTFukBES5oozzqTr3D/AfGFuk1u+ZxUpeu
JKhehdi8JiCYNvQFaci9JIjHozB36TsytGSxJqFje2xRzAQbwYGRNBgQJi7A/pML
DJAZGROeozetlMt1EswgN/75Qa1viDMrC1jdZCUbjKQZ2DanBtx+Aw0vhf/yUB95
D5hfpgJQT2NFqVzGSf5n5AqF2eaVwYUn8T1/s0LgrgF/Rm3i1k9xCTlPwoMQQZ0U
5wv9bkHXsNMd8SkiNPboIvnjcPTrKuz1eumvfcv7v7+jh+GjNemga0ytfpQpEvyB
HPAnoElzLGxC51cULEsqhMk8fvTo2tkCggEAWGVqTvBZOW/HH9F56eXU+N4EFbDd
QAJbY7uGnpUWzlfz7idUmCxVgTZ+qLwQGvebD+EVINiT3mWXl25nWWSDArMGMLtq
UD9GB9RuY6xA3drK0mW0EMuUzU6Qxq3AYUEKhSXiRjipCD0fIZbq7hBMQ+a1Tj2P
phVxgVMA+z1AEyQy1LogNuXy/0LfYoFisqQfwzwqlLYcd6jdsGrp53NM8GogRCSV
x0vMddjjnZhbVnukmPWZfasuOstBy9PcB5uzvQzDLAv59Yho/RD4sqamPXQpbY3S
aqhG8KD/fYudFbY0J06VESq2bL/ZpMMPK9MJgmcLVXcR/MBjoXUI24PzAg==
-----END RSA PRIVATE KEY-----

```

`tools/certificates/server.pem`:

```pem
Bag Attributes
    localKeyID: E0 CE 21 61 3C AC 4B FA 23 2C A1 80 75 5F 5A 47 4A 2B 29 9B 
subject=C = BY, ST = Belarus, L = Minsk, O = Example server, OU = Example server unit, CN = server.example.com

issuer=C = BY, ST = Belarus, L = Minsk, O = Example root CA, OU = Example CA unit, CN = example.com

-----BEGIN CERTIFICATE-----
MIIFcTCCA1kCAQEwDQYJKoZIhvcNAQELBQAweTELMAkGA1UEBhMCQlkxEDAOBgNV
BAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRgwFgYDVQQKDA9FeGFtcGxlIHJv
b3QgQ0ExGDAWBgNVBAsMD0V4YW1wbGUgQ0EgdW5pdDEUMBIGA1UEAwwLZXhhbXBs
ZS5jb20wHhcNMTkwNjAxMTI1MjQ0WhcNMjkwNTI5MTI1MjQ0WjCBgzELMAkGA1UE
BhMCQlkxEDAOBgNVBAgMB0JlbGFydXMxDjAMBgNVBAcMBU1pbnNrMRcwFQYDVQQK
DA5FeGFtcGxlIHNlcnZlcjEcMBoGA1UECwwTRXhhbXBsZSBzZXJ2ZXIgdW5pdDEb
MBkGA1UEAwwSc2VydmVyLmV4YW1wbGUuY29tMIICIjANBgkqhkiG9w0BAQEFAAOC
Ag8AMIICCgKCAgEAtdVvGlBsP+78L+bpRgvPdti+AVgM1JCMP7mOHvv3m+x0gIp1
j/Sg/S0h/leYsPu7H2k5xv41Y4fmWPX7u0xPLdI+/u1zHHc6IGEaM0aEddEruDUr
QcQt+h62c/nIJ+tcXuSHrTZREbczZq4gm7exvAuvYd0B/lg2kXLQ9Y7eqShhKPtH
B6a5YH2snJWJbk8E9WVwem37nrH5DJ99/q+hQHl9rdrP03KAEIbMLGgo3r2YuOoa
7qoywusyH9xMpWzDt0QhXxhfmWnSNyZG8ztfoXt6TDTZQ2HD/H/dZlt3skgJAWcU
tlF4l0tZ55495SC4ozFyk84tNJPBD/QkRYmn3GfJ1zHgdFru+H2qYHJv5B4ssUbS
cPkXwcsASci/JiyIbhPzOpbpCTUGX3OAMBKIFtxJNKmHeosftR9I97dNfJZCCiC7
k5NL8GaTw0484tLqfuH1bOmUULsfLaEj6rsiXLz9uB8T16/K9pKf2LIB++eCEU71
S4n6BHyiH09uL1KZ0msc5beggUiUglCUYy31aIFuZl/wCuH8GJZv0kepAWLIL23h
PwpzS5o+tZHefwS//qG8mcy7a+NcLlIsLNPRVToYmlcNnfeAxcDqwRm2GKfAY4i7
CUt4vgyEGbFxBNsh6ozTkd9tE3qkRtpMRKcX3ZQmYJNjEOl7XCnUk9SLMOECAwEA
ATANBgkqhkiG9w0BAQsFAAOCAgEAC/W9uU6zNgUzoxP3qCIXgpPPItKzkbQArXK9
MNqWnBM+ccUbaGCUMG/i5dmfT2YeTMC72Z71xb6QznFJHXOuKKVPzLNwVuIR/xwE
j3BeQkUZ33Kf8TUxz5owHV9Px944KiEwhIOyPjgbG9WPL5IsXMBMLZi4EAVOza7T
lqykOfgV2kwFEOPD4Sz2bYOxp7eNu+cQAMf/COQrMC2L97OtcrquipRAaY2rxb3Z
pD8r3ymRs14K5rf6LTUrxrCIeZewxLyX8FedBZPCUCRLb7lsu1r7OHtbt+xUy+7i
KtmEqgLpJ9Iu8xK4rf8ReLkgT5SownaGI+ddYdyB5aiR2DgLXKxGQZ6l6sznkzDk
X2UZAtzhTxRaZ8wHMmR5z7q/F8EM+PR0a1Y5Of+Yosv9dTERMyNosnd9EHXTbgSo
ARaPso0J9V3jXm44+qd4pHgnLr7SOp3B5Jf71yhN1p5fKYqPkbiCiZFxOXO3s5z6
+4247z7ZCD7k9UMqKflj4eLQD+OnTJ6VFyrovTQnjCsbTsEmI1S8arvAEosAX5GU
vR05YZnEO9rEzOSh9tBuuht8woK5tQpLQwksgOiQATcZCN/ioz1SmyrRIfwEBh66
MB4SMwGjiaARsWhV+iEpS8mwvI1WtX/4Xgo7NropbFyIuJsZsmvDfuffqp9Z8f/b
kYDiTio=
-----END CERTIFICATE-----
Bag Attributes
    localKeyID: E0 CE 21 61 3C AC 4B FA 23 2C A1 80 75 5F 5A 47 4A 2B 29 9B 
Key Attributes: <No Attributes>
-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIJnDBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIMf/cteIjuFQCAggA
MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECO/G++gNo4keBIIJSGSPwhp9gx4d
ITJ8aS95yfOIeKgX1USZYlpcVmC22izBarUTtCLr2T6KyXWr1wGDq27qczx93pEN
fU9kDkdqVkB3dSeUpcTGW9T9yNeclXi7QdDsDRoDniqoltl54KucuXp/4o84KbHa
6L4aV+bFWJ4t75ATZEvhT0zKwtBT2c2hl4sEm60X0m7QXu6ZNIFDUJ8beriq3Gxh
QlUFBNx4Sg5HG+OveFCgsZ8IixKY3/aPRmczpDsOSpGc9/yAEapgitjzLNDsr+Ss
1spmCDKbqAXQLLtEfzRXPD8VeeHN7XV0yhXuv0Hu/YRDXD9Bm2r3OYiCU1wGigjl
bKE+x8AtPjdxSZjSNU7aS+RQGbiOG0F3CzTHolJYUkMIqrzx5L4dfY1rq8+y2ye0
7x6Z7u0YSm/aNfCRQjGKUsKrv3aflrWdq0HgDjzLNQ3kEag06stZBN2JcDo9/tV3
zOEqKIv6jT3IMJQ49jud8N+POxaEuSa84ATwQR4HfPcbQeNbFz8mAtUXK29EYLEe
4uUyiJ1uboFgMHWWo3r/wi2kElGIPJiWR8gfaiHhgBvT4y0EZXJNwkyaH0xiRrqO
Ap2jtpCQTQbE35Y5TtTZwoLcp5fyketzb/OdCMXSW03iu7Gu6T4HQxS0B2Ti4GMj
V6mmLKP4Ay+z68cLXzwzaIO+8E5JEnXPbylOWRLfS0BdFHY6fxoEHXyx8Yi7Is89
O42fBsu3qhlPQabNlAOTgIDP30byo03VSsSAtj0C/NreKaIsTRxQu+2dQhZRhk0n
q0AeavWj9rXANRo8W7JNQFwwljbzFOiscYQ9Whbl8yQhY9wGCIC3Zip56JmucQJK
XM+Cred3ME2gzPxoiBVoKQtj0JGhe9gFP9LTnftwjoznvVO2lLV+G6TLB2Sg/Pu5
LbZ3kbYSD9NEksQKK78z48W/4OPuf68/SvT39aQx6gAkxCLOFV7yvNPkzKncBSwu
7K7RvK3n6zWERTJ48q1DtocCJikYbzqTiWKNvfMbTd61+JtoT8wZZy4wQSf5eU+X
3MOCS4n2yNrbYyJYmABfvRmfokbN3GH93gHGgQLL+GDlXcNrG2K3t2VVI2WGhe8Y
UwfjwDHTkYf3Xhnbx9XXfOGKgzU+7/1tlD4mf5v3mrgrl/vrftBea1ppIYFj7cN6
s+3QS9YkojmHcOAx8w+OYK3ASUfzxuRD4cp7lfCnU+nZIBQThGqBOfeKZKi/SEqn
mXItCBwE2xo6c+sdKwDF8DCmZFsIqHORUwJgDbjmQKCpoo1CDJ7dOLpQo3Ibi8XN
uYY9S4Y39Je3TT5giKPl3bOZoqPJqC6DZRoa8SV5/wQnbbqGt9wJV6dy61DBdg8X
RCV1wJC5afFkuIbits0M0PqbPmvCmrmjJZETDqsVoD4eI7KyhotVguptgbsdBpoy
RbODGQB3K8At+WqksaJ+x6CYJAz7jgtHdrQhI+JyFLWiRsoZU1j7Idd/NnEw6Agr
Dhn/N+zK1yEuyXNHAEEq1rK8w6ouzCmyI+3IXk/i11dI4bm/5r/ST0T1g4eZjIov
mzLtAjd+FPgKn0WqmCe5NYTZaUV/dus71UGbGHLM/Zzj8PKtLGOo35pE1wNAB1Sv
dqqQ278QpoNYX0U89L9ChAKgCyC+jIyUWXeoaApxiB8ol1adFYH7N4u2nt//nApT
5hE8yGN75pwBPb0q+4WBSi2Qosbl6W3fDxh5/tbbc9iE+ss88tF3ZnaYwVJUSEnP
8rNByofYZdpxynpOKhAAEvxad7vC7CBhuceb88fuqLhx1MEvki71iTqAMWYpYOb/
+2WrHzu1irb4b+SSXwUeZQfyJy3wkGPei3OuyVM/qNsSj9djoM8Ff7FouKg6y2f6
y9MhAJ1Wzmpk0DPxILYlw92JM5kN3kCD5KXef/KGo2zydpe5pNi3pkQ8wkxSZ8IQ
fxEnHvSmginY6u2XmOqdDKDisOAY9oMtitm73OVZOpUux80qIHqIEMvsKDzi/aC5
fdEfuA0AFSmjtYb/IGcfMSKaOr4wTlGookso0dqdN30NBBAdH9nskYYS5i/3dTwg
TQ14/G92PlYo4GJed3FpnKSm/2PbiRxEOXcN79P90nm2E6D+OYoauAZwZ98KkcYP
CYVUUqlGPkdQE3OFeXwtPb9w6J5jUrlCt7RTe9+8O4jfGWmwXuLNLHLFj9leK4/s
NYCCTz+TZshibA/sxCDl8MxJJtMuMaHTFIRCKSAeL0p7j4FGR/dG0xNVRRwKAwo6
b28IpwlZgCgD7spRfIaTiC/kvRA7jmc8E15Bi0iR2N1OyBRxeloKiXQ3gUelW6Ov
UBP124aDetBcNPM9w34eoLS7pFwfV1UsOQdzaQ0ohF3wPVMIAUX/LWU2ORmo7snN
sSlEHSPa9KyUvAeUgjzGGWaL19jJ/TqdC6gb7Om/LqISCIKcKW3xhWMdMn1JSOka
Fdf8sb4MCeavSrBHs7ypBeNbnITfuXw6McpiM7iAZp9lBd5nRY7nZr88RuWXoCfT
zXjGegmLKRcnqvCCrkPgCreBJucfMFd3ACMuKVBVsk3c7LLfZHrNaIturccWT26C
J0wQ8tmTmeMc1wTsb54GCcyRxMwclCod9ON8xK7WcxkDfhiweJwxmfDEZit8CoXF
q/Svu82D5lgY0nhVVVZQUUgo3nUCLTtkpIjTDOIvRPrN4z4eOZA2nME2EaOCOK6L
rLb6/0aJ0o/GxHFrYEoWaU42gZs57+nlO5yRBNydA0nsw8cvTpKtTAwZNbWLvRNM
rpjcIUwcp191llZsvTGohkS1div5yuh1RzWUXJmzLzIIIe6VNVW26r88qfJ1fYoW
xhjK8F0l2X1iFeYl/u+wxPwnq28x65m5jIA6W6lgAFH8LW+8HIYVLVpbcpqqYRkh
+9MoSWX3H9i+gJIeqQXRcID4I6S9vH14llOW9BLLobx5PGFJUbcMr8/1MhGmJGGH
h8bJohJKeBUcQ+HhVVC4zJ15Jm4xsmgohQ4OFvR5UiW3XrUCsncRzx5sgnfU/StV
TTMIBNkGoLaxrRwv41toCsiRL9RkHeDCVKTi9BvwynAbghW1wv8S8uLTff1lKJyb
DHe/ke3ENL3fTuMxJHDxaFvdMpCXGT8d4bEUMN1iR9NFdwtjfyKqB89I2YQ8nWLG
/RZ0jx2ufryCZ9/5sty56Q==
-----END ENCRYPTED PRIVATE KEY-----

```

`www/api/index.html`:

```html
<!-- HTML for static distribution bundle build -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Swagger UI</title>
    <link rel="stylesheet" type="text/css" href="./swagger/swagger-ui.css" />
    <link rel="stylesheet" type="text/css" href="./swagger/index.css" />
    <link rel="icon" type="image/png" href="./swagger/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="./swagger/favicon-16x16.png" sizes="16x16" />
  </head>

  <body>
    <div id="swagger-ui"></div>
    <script src="./swagger/swagger-ui-bundle.js" charset="UTF-8"> </script>
    <script src="./swagger/swagger-ui-standalone-preset.js" charset="UTF-8"> </script>
    <script src="./swagger.js" charset="UTF-8"> </script>
  </body>
</html>

```

`www/api/openapi.yaml`:

```yaml
openapi: 3.0.0

info:
  version: 1.0
  title: HTTP Cache Server API
  description: HTTP Cache Server API
  contact:
    name: chronoxor
    url: https://github.com/chronoxor/CppServer
    email: chronoxor@gmail.com

servers:
- url: /api
  description: Cache API

tags:
- name: Cache
  description: Cache methods

paths:
  /cache:
    get:
      tags:
      - Cache
      summary: Get the cache value
      operationId: GetCacheValue
      parameters:
      - name: key
        in: query
        description: Cache key (optional)
        required: false
        schema:
          type: string
          example: 'test'
      responses:
        200:
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CacheItems'
            text/plain:
              schema:
                type: string
        404:
          description: Cache key not found
          content: {}
        500:
          description: Internal server error
          content: {}
    post:
      tags:
      - Cache
      summary: Create the cache value
      operationId: CreateCacheValue
      parameters:
      - name: key
        in: query
        description: Cache key
        required: true
        schema:
          type: string
          example: 'test'
      requestBody:
        description: Cache value to create
        required: true
        content:
          text/plain:
            schema:
              type: string
              example: 'value'
      responses:
        200:
          description: Success
          content: {}
        500:
          description: Internal server error
          content: {}
    put:
      tags:
      - Cache
      summary: Modify the cache value
      operationId: ModifyCacheValue
      parameters:
      - name: key
        in: query
        description: Cache key
        required: true
        schema:
          type: string
          example: 'test'
      requestBody:
        description: Cache value to modify
        required: true
        content:
          text/plain:
            schema:
              type: string
              example: 'modified'
      responses:
        200:
          description: Success
          content: {}
        500:
          description: Internal server error
          content: {}
    delete:
      tags:
      - Cache
      summary: Delete the cache value
      operationId: DeleteCacheValue
      parameters:
      - name: key
        in: query
        description: Cache key
        required: true
        schema:
          type: string
          example: 'test'
      responses:
        200:
          description: Success
          content:
            text/plain:
              schema:
                type: string
        404:
          description: Cache key not found
          content: {}
        500:
          description: Internal server error
          content: {}
    head:
      tags:
      - Cache
      summary: Get the cache headers
      operationId: GetCacheHeaders
      responses:
        200:
          description: Success
          content: {}
        500:
          description: Internal server error
          content: {}
    options:
      tags:
      - Cache
      summary: Get the cache options
      operationId: GetCacheOptions
      responses:
        200:
          description: Success
          content: {}
        500:
          description: Internal server error
          content: {}

components:
  schemas:
    CacheItem:
      type: object
      properties:
        key:
          type: string
        value:
          type: string
    CacheItems:
      type: array
      items:
        $ref: '#/components/schemas/CacheItem'

```

`www/api/swagger.js`:

```js
window.onload = function() {
  //<editor-fold desc="Changeable Configuration Block">

  // the following lines will be replaced by docker/configurator, when it runs in a docker-container
  window.ui = SwaggerUIBundle({
    url: "openapi.yaml",
    defaultModelsExpandDepth: 0,
    displayRequestDuration: true,
    dom_id: '#swagger-ui',
    deepLinking: true,
    presets: [
      SwaggerUIBundle.presets.apis,
      SwaggerUIStandalonePreset
    ],
    plugins: [
      SwaggerUIBundle.plugins.DownloadUrl
    ],
    layout: "StandaloneLayout"
  });

  //</editor-fold>
};

```

`www/ws/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WebSocket chat client example</title>
  <link rel="icon" type="image/png" href="./favicon.png"/>
</head>
<body>
  <script>

  function init()
  {
    document.myform.url.value = "ws://localhost:8080/"
    document.myform.inputtext.value = "Hello World!"
    document.myform.disconnectButton.disabled = true
  }

  function doConnect()
  {
    websocket = new WebSocket(document.myform.url.value)
    websocket.onopen = function(evt) { onOpen(evt) }
    websocket.onclose = function(evt) { onClose(evt) }
    websocket.onmessage = function(evt) { onMessage(evt) }
    websocket.onerror = function(evt) { onError(evt) }
  }

  function onOpen(evt)
  {
    writeToScreen("connected\n")
    document.myform.connectButton.disabled = true
    document.myform.disconnectButton.disabled = false
  }

  function onClose(evt)
  {
    writeToScreen("disconnected\n")
    document.myform.connectButton.disabled = false
    document.myform.disconnectButton.disabled = true
  }

  function onMessage(evt)
  {
    writeToScreen("response: " + evt.data + '\n')
  }

  function onError(evt)
  {
    writeToScreen('error: ' + evt.data + '\n')

    websocket.close()

    document.myform.connectButton.disabled = false
    document.myform.disconnectButton.disabled = true
  }

  function doSend(message)
  {
    writeToScreen("sent: " + message + '\n')
    websocket.send(message)
  }

  function writeToScreen(message)
  {
    document.myform.outputtext.value += message
    document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight
  }

  window.addEventListener("load", init, false)

  function sendText()
  {
    doSend(document.myform.inputtext.value)
  }

  function clearText()
  {
    document.myform.outputtext.value = ""
  }

  function doDisconnect()
  {
    websocket.close()
  }

  </script>
  <form name="myform">
    <p>
      <textarea name="url" cols="50" rows="1"></textarea>
    </p>
    <p>
      <input type="button" name=connectButton value="Connect" onClick="doConnect()">
      <input type="button" name=disconnectButton value="Disconnect" onClick="doDisconnect()">
    </p>
    <p>
      <textarea name="outputtext" cols="50" rows="20"></textarea>
    </p>
    <p>
      <textarea name="inputtext" cols="50" rows="1"></textarea>
    </p>
    <p>
      <input type="button" name=sendButton value="Send" onClick="sendText()">
      <input type="button" name=clearButton value="Clear" onClick="clearText()">
    </p>
 </form>
</body>
</html>

```

`www/wss/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WebSocket chat client example</title>
  <link rel="icon" type="image/png" href="./favicon.png"/>
</head>
<body>
  <script>

  function init()
  {
    document.myform.url.value = "wss://localhost:8443/"
    document.myform.inputtext.value = "Hello World!"
    document.myform.disconnectButton.disabled = true
  }

  function doConnect()
  {
    websocket = new WebSocket(document.myform.url.value)
    websocket.onopen = function(evt) { onOpen(evt) }
    websocket.onclose = function(evt) { onClose(evt) }
    websocket.onmessage = function(evt) { onMessage(evt) }
    websocket.onerror = function(evt) { onError(evt) }
  }

  function onOpen(evt)
  {
    writeToScreen("connected\n")
    document.myform.connectButton.disabled = true
    document.myform.disconnectButton.disabled = false
  }

  function onClose(evt)
  {
    writeToScreen("disconnected\n")
    document.myform.connectButton.disabled = false
    document.myform.disconnectButton.disabled = true
  }

  function onMessage(evt)
  {
    writeToScreen("response: " + evt.data + '\n')
  }

  function onError(evt)
  {
    writeToScreen('error: ' + evt.data + '\n')

    websocket.close()

    document.myform.connectButton.disabled = false
    document.myform.disconnectButton.disabled = true
  }

  function doSend(message)
  {
    writeToScreen("sent: " + message + '\n')
    websocket.send(message)
  }

  function writeToScreen(message)
  {
    document.myform.outputtext.value += message
    document.myform.outputtext.scrollTop = document.myform.outputtext.scrollHeight
  }

  window.addEventListener("load", init, false)

  function sendText()
  {
    doSend(document.myform.inputtext.value)
  }

  function clearText()
  {
    document.myform.outputtext.value = ""
  }

  function doDisconnect()
  {
    websocket.close()
  }

  </script>
  <form name="myform">
    <p>
      <textarea name="url" cols="50" rows="1"></textarea>
    </p>
    <p>
      <input type="button" name=connectButton value="Connect" onClick="doConnect()">
      <input type="button" name=disconnectButton value="Disconnect" onClick="doDisconnect()">
    </p>
    <p>
      <textarea name="outputtext" cols="50" rows="20"></textarea>
    </p>
    <p>
      <textarea name="inputtext" cols="50" rows="1"></textarea>
    </p>
    <p>
      <input type="button" name=sendButton value="Send" onClick="sendText()">
      <input type="button" name=clearButton value="Clear" onClick="clearText()">
    </p>
 </form>
</body>
</html>

```