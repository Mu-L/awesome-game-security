Project Path: arc_Half-People_HPCS2_3zzae951

Source Tree:

```txt
arc_Half-People_HPCS2_3zzae951
├── API
│   ├── ChangeLog.md
│   ├── README.md
│   └── include
│       └── nlohmann
│           ├── LICENSES
│           │   ├── Apache-2.0.txt
│           │   ├── BSD-3-Clause.txt
│           │   ├── GPL-3.0-only.txt
│           │   └── MIT.txt
│           ├── adl_serializer.hpp
│           ├── byte_container_with_subtype.hpp
│           ├── detail
│           │   ├── abi_macros.hpp
│           │   ├── conversions
│           │   │   ├── from_json.hpp
│           │   │   ├── to_chars.hpp
│           │   │   └── to_json.hpp
│           │   ├── exceptions.hpp
│           │   ├── hash.hpp
│           │   ├── input
│           │   │   ├── binary_reader.hpp
│           │   │   ├── input_adapters.hpp
│           │   │   ├── json_sax.hpp
│           │   │   ├── lexer.hpp
│           │   │   ├── parser.hpp
│           │   │   └── position_t.hpp
│           │   ├── iterators
│           │   │   ├── internal_iterator.hpp
│           │   │   ├── iter_impl.hpp
│           │   │   ├── iteration_proxy.hpp
│           │   │   ├── iterator_traits.hpp
│           │   │   ├── json_reverse_iterator.hpp
│           │   │   └── primitive_iterator.hpp
│           │   ├── json_custom_base_class.hpp
│           │   ├── json_pointer.hpp
│           │   ├── json_ref.hpp
│           │   ├── macro_scope.hpp
│           │   ├── macro_unscope.hpp
│           │   ├── meta
│           │   │   ├── call_std
│           │   │   │   ├── begin.hpp
│           │   │   │   └── end.hpp
│           │   │   ├── cpp_future.hpp
│           │   │   ├── detected.hpp
│           │   │   ├── identity_tag.hpp
│           │   │   ├── is_sax.hpp
│           │   │   ├── std_fs.hpp
│           │   │   ├── type_traits.hpp
│           │   │   └── void_t.hpp
│           │   ├── output
│           │   │   ├── binary_writer.hpp
│           │   │   ├── output_adapters.hpp
│           │   │   └── serializer.hpp
│           │   ├── string_concat.hpp
│           │   ├── string_escape.hpp
│           │   └── value_t.hpp
│           ├── json.hpp
│           ├── json_fwd.hpp
│           ├── ordered_map.hpp
│           └── thirdparty
│               └── hedley
│                   ├── hedley.hpp
│                   └── hedley_undef.hpp
├── HPCS2
│   ├── HPCS2
│   │   ├── HPCS2.vcxproj
│   │   ├── HPCS2.vcxproj.filters
│   │   ├── HPCS2.vcxproj.user
│   │   ├── Source.cpp
│   │   ├── handle_hijack.hpp
│   │   ├── memory.cpp
│   │   ├── memory.hpp
│   │   ├── offset
│   │   │   ├── animationsystem.dll.hpp
│   │   │   ├── client.dll.hpp
│   │   │   ├── engine2.dll.hpp
│   │   │   ├── host.dll.hpp
│   │   │   ├── interfaces.hpp
│   │   │   ├── materialsystem2.dll.hpp
│   │   │   ├── networksystem.dll.hpp
│   │   │   ├── offsets.hpp
│   │   │   ├── particles.dll.hpp
│   │   │   ├── pulse_system.dll.hpp
│   │   │   ├── rendersystemdx11.dll.hpp
│   │   │   ├── resourcesystem.dll.hpp
│   │   │   ├── scenesystem.dll.hpp
│   │   │   ├── schemasystem.dll.hpp
│   │   │   ├── server.dll.hpp
│   │   │   ├── soundsystem.dll.hpp
│   │   │   ├── vphysics2.dll.hpp
│   │   │   └── worldrenderer.dll.hpp
│   │   └── x64
│   │       └── Release
│   │           ├── HPCS2.Build.CppClean.log
│   │           ├── HPCS2.exe.recipe
│   │           ├── HPCS2.iobj
│   │           ├── HPCS2.ipdb
│   │           ├── HPCS2.log
│   │           ├── HPCS2.tlog
│   │           │   ├── CL.command.1.tlog
│   │           │   ├── CL.read.1.tlog
│   │           │   ├── CL.write.1.tlog
│   │           │   ├── HPCS2.lastbuildstate
│   │           │   ├── link.command.1.tlog
│   │           │   ├── link.read.1.tlog
│   │           │   ├── link.write.1.tlog
│   │           │   └── unsuccessfulbuild
│   │           ├── HPCS2.vcxproj.FileListAbsolute.txt
│   │           └── vc142.pdb
│   ├── HPCS2.APS
│   ├── HPCS2.rc
│   ├── HPCS2.sln
│   ├── HPCS2.vcxproj
│   ├── HPCS2.vcxproj.filters
│   ├── HPCS2.vcxproj.user
│   ├── Source.cpp
│   ├── api
│   │   └── ini.h
│   ├── handle_hijack.hpp
│   ├── hpcs2logo.ico
│   ├── memory.cpp
│   ├── memory.hpp
│   ├── offset
│   │   ├── animationsystem.dll.hpp
│   │   ├── client.dll.hpp
│   │   ├── engine2.dll.hpp
│   │   ├── host.dll.hpp
│   │   ├── interfaces.hpp
│   │   ├── materialsystem2.dll.hpp
│   │   ├── networksystem.dll.hpp
│   │   ├── offsets.hpp
│   │   ├── particles.dll.hpp
│   │   ├── pulse_system.dll.hpp
│   │   ├── rendersystemdx11.dll.hpp
│   │   ├── resourcesystem.dll.hpp
│   │   ├── scenesystem.dll.hpp
│   │   ├── schemasystem.dll.hpp
│   │   ├── server.dll.hpp
│   │   ├── soundsystem.dll.hpp
│   │   ├── vphysics2.dll.hpp
│   │   └── worldrenderer.dll.hpp
│   ├── resource.h
│   ├── resource1.h
│   ├── resource2.h
│   └── x64
│       └── Release
│           ├── HPCS2.Build.CppClean.log
│           ├── HPCS2.exe.recipe
│           ├── HPCS2.iobj
│           ├── HPCS2.ipdb
│           ├── HPCS2.log
│           ├── HPCS2.pdb
│           ├── HPCS2.tlog
│           │   ├── CL.command.1.tlog
│           │   ├── CL.read.1.tlog
│           │   ├── CL.write.1.tlog
│           │   ├── HPCS2.lastbuildstate
│           │   ├── link.command.1.tlog
│           │   ├── link.read.1.tlog
│           │   └── link.write.1.tlog
│           ├── HPCS2.vcxproj.FileListAbsolute.txt
│           └── vc142.pdb
├── HPCS2.sln
├── LICENSE
├── README.md
└── x64
    └── Release
        ├── Configuration.ini
        └── HPCS2.pdb

```

`API/ChangeLog.md`:

```md
# Changelog
All notable changes to this project will be documented in this file. This project adheres to [Semantic Versioning](http://semver.org/).

## [3.11.2](https://github.com/nlohmann/json/releases/tag/3.11.2) (2022-08-12)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.11.1...3.11.2)

- MSVC natvis visualizer does not work after introduction of inline ABI namespace [\#3696](https://github.com/nlohmann/json/issues/3696)
- The use of parenthesis gives compilation errors in some situations [\#3682](https://github.com/nlohmann/json/issues/3682)
- extern from/to\_json result in linker error [\#3657](https://github.com/nlohmann/json/issues/3657)
- json\_fwd.hpp no longer standalone [\#3656](https://github.com/nlohmann/json/issues/3656)
- regression: `.value<size_t>` is compilation error. [\#3655](https://github.com/nlohmann/json/issues/3655)
- Regression: no match for 'operator!=' comparing json\_pointer and const char \*/string\_t [\#3654](https://github.com/nlohmann/json/issues/3654)
- Regression: call to member function 'value' is ambiguous [\#3652](https://github.com/nlohmann/json/issues/3652)
- macOS 10.15 Actions runner image deprecation [\#3612](https://github.com/nlohmann/json/issues/3612)

- generate\_natvis.py: validate version number; cleanup [\#3698](https://github.com/nlohmann/json/pull/3698) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add Python script for generating Natvis file and update file for 3.11.2 [\#3697](https://github.com/nlohmann/json/pull/3697) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- fix typo in json\_pointer.md [\#3692](https://github.com/nlohmann/json/pull/3692) ([eltociear](https://github.com/eltociear))
- Add amalgamated json-fwd.hpp to release [\#3687](https://github.com/nlohmann/json/pull/3687) ([nlohmann](https://github.com/nlohmann))
- Documentation updates for 3.11.2 [\#3686](https://github.com/nlohmann/json/pull/3686) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Make json\_pointer usable as map key \(again\) [\#3685](https://github.com/nlohmann/json/pull/3685) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Deprecate json\_pointer/string\_t comparisons [\#3684](https://github.com/nlohmann/json/pull/3684) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Restructure inline namespace and allow version component to be disabled [\#3683](https://github.com/nlohmann/json/pull/3683) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Properly constrain non-string json\_pointer overloads [\#3681](https://github.com/nlohmann/json/pull/3681) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Amalgamate the forward declaration header [\#3679](https://github.com/nlohmann/json/pull/3679) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix 'const' qualifier on bool& has no effect [\#3678](https://github.com/nlohmann/json/pull/3678) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix whitespace in workflow files [\#3675](https://github.com/nlohmann/json/pull/3675) ([nlohmann](https://github.com/nlohmann))
- Attempt to fix labeler permissions [\#3674](https://github.com/nlohmann/json/pull/3674) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Refine 'Publish documentation' workflow [\#3673](https://github.com/nlohmann/json/pull/3673) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Documentation change [\#3672](https://github.com/nlohmann/json/pull/3672) ([nlohmann](https://github.com/nlohmann))
- Add labeler action [\#3671](https://github.com/nlohmann/json/pull/3671) ([nlohmann](https://github.com/nlohmann))
- Complete contributor list [\#3670](https://github.com/nlohmann/json/pull/3670) ([nlohmann](https://github.com/nlohmann))
- Add json\_pointer/string\_t equality comparison operators [\#3664](https://github.com/nlohmann/json/pull/3664) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Reimplement value\(\) access functions [\#3663](https://github.com/nlohmann/json/pull/3663) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Complete contributor list [\#3662](https://github.com/nlohmann/json/pull/3662) ([nlohmann](https://github.com/nlohmann))
- Adjust naming of GitHub action jobs [\#3661](https://github.com/nlohmann/json/pull/3661) ([nlohmann](https://github.com/nlohmann))
- Publish documentation on push to develop branch [\#3660](https://github.com/nlohmann/json/pull/3660) ([nlohmann](https://github.com/nlohmann))
- Add Discord badge to README [\#3651](https://github.com/nlohmann/json/pull/3651) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Miscellaneous small fixes [\#3643](https://github.com/nlohmann/json/pull/3643) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Minor BJData fixes [\#3637](https://github.com/nlohmann/json/pull/3637) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Update CI [\#3626](https://github.com/nlohmann/json/pull/3626) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))

## [v3.11.1](https://github.com/nlohmann/json/releases/tag/v3.11.1) (2022-08-01)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.11.0...v3.11.1)

- Regression: no matching literal operator for call to 'operator""\_json' [\#3645](https://github.com/nlohmann/json/issues/3645)
- \_json  operator""\(\)  [\#3644](https://github.com/nlohmann/json/issues/3644)

- Fix global UDLs [\#3646](https://github.com/nlohmann/json/pull/3646) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))

## [v3.11.0](https://github.com/nlohmann/json/releases/tag/v3.11.0) (2022-08-01)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.5...v3.11.0)

- ICPC: warning \#1098: the qualifier on this friend declaration is ignored [\#3632](https://github.com/nlohmann/json/issues/3632)
- Starting with 3.10.4, just adding `\#include json.hpp` causes compile error: `overload resolution selected deleted operator '=' [\#3620](https://github.com/nlohmann/json/issues/3620)
- xwidgets doesn't compile with version \>3.10.3 [\#3602](https://github.com/nlohmann/json/issues/3602)
- json\_pointer\_\_pop\_back.cpp example does not compile [\#3600](https://github.com/nlohmann/json/issues/3600)
- nlohmann::json::array 'push\_back' is ambiguous [\#3589](https://github.com/nlohmann/json/issues/3589)
- Multiple versions causing conflict [\#3588](https://github.com/nlohmann/json/issues/3588)
- ERROR: ThreadSanitizer: SEGV on unknown address [\#3584](https://github.com/nlohmann/json/issues/3584)
- unicode4 test consistently fails on RISC-V hardware [\#3579](https://github.com/nlohmann/json/issues/3579)
- sax\_parse\(iterator, json\_sax\_t \*\) string callback clobbers spaces [\#3574](https://github.com/nlohmann/json/issues/3574)
- Nlohmann JSON Parse crash with raylib-cpp [\#3570](https://github.com/nlohmann/json/issues/3570)
- ordered\_json doesn't accept keys of types other than string\_t \(e.g., string\_view\) [\#3558](https://github.com/nlohmann/json/issues/3558)
- turning an object into an array [\#3547](https://github.com/nlohmann/json/issues/3547)
- json:parse\_bjdata\_fuzzer: ASSERT: ref\_stack.back\(\)-\>is\_array\(\) [\#3541](https://github.com/nlohmann/json/issues/3541)
- Warning about potential null dereference in GCC 12.1 \(Fedora 36\) [\#3525](https://github.com/nlohmann/json/issues/3525)
- Enable 32bit unit test in CI [\#3524](https://github.com/nlohmann/json/issues/3524)
- Error when roundtripping BJData [\#3519](https://github.com/nlohmann/json/issues/3519)
- ASSERT error while parsing BJData [\#3513](https://github.com/nlohmann/json/issues/3513)
- An exception occurred when sending a string with double quotes [\#3504](https://github.com/nlohmann/json/issues/3504)
- Binary reader for BJData creates incorrect SAX events [\#3503](https://github.com/nlohmann/json/issues/3503)
- It can't support  "nan", "inf", "-inf" for float type [\#3494](https://github.com/nlohmann/json/issues/3494)
- ASAN error while parsing BJData \(Heap-buffer-overflow READ 1\) [\#3492](https://github.com/nlohmann/json/issues/3492)
- UBSAN error while parsing BJData \(Null-dereference\) [\#3491](https://github.com/nlohmann/json/issues/3491)
- UBSAN error while parsing BJData \(Invalid-bool-value\) [\#3490](https://github.com/nlohmann/json/issues/3490)
- json:parse\_bjdata\_fuzzer reaches assertion [\#3475](https://github.com/nlohmann/json/issues/3475)
- Compilation with -fmodules-ts and use inside of a module [\#3472](https://github.com/nlohmann/json/issues/3472)
- json.exception.parse\_error.101 only occurs outside of IDE  [\#3467](https://github.com/nlohmann/json/issues/3467)
- json:parse\_bjdata\_fuzzer reaches assertion [\#3461](https://github.com/nlohmann/json/issues/3461)
- NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE\_WITH\_DEFAULT can not parse { "key" : null} [\#3458](https://github.com/nlohmann/json/issues/3458)
- Unable to compile when using Microsoft's \_CRTDBG [\#3457](https://github.com/nlohmann/json/issues/3457)
- Compilation errors when including `<filesystem>` and using `--std=c++17` or above \(MinGW/Win10\) [\#3449](https://github.com/nlohmann/json/issues/3449)
- Weird things on for statement [\#3447](https://github.com/nlohmann/json/issues/3447)
- Parsing error when there is a json string within a Json [\#3445](https://github.com/nlohmann/json/issues/3445)
- ordered\_json vs json types comparison [\#3443](https://github.com/nlohmann/json/issues/3443)
- Error occurred when converting nlohmann::json to std::any [\#3428](https://github.com/nlohmann/json/issues/3428)
- I was forced to report an assertion error when copying an array of strings [\#3419](https://github.com/nlohmann/json/issues/3419)
- About Serialization Error invalid UTF-8 byte at index [\#3414](https://github.com/nlohmann/json/issues/3414)
- Comparison of NaN differs between json and float [\#3409](https://github.com/nlohmann/json/issues/3409)
- when i use it in C++ sserver,it it constantly show that fatal error: adl\_serializer.hpp: No such file or directory [\#3404](https://github.com/nlohmann/json/issues/3404)
- parse error [\#3403](https://github.com/nlohmann/json/issues/3403)
- CMake script MAIN\_PROJECT always OFF [\#3390](https://github.com/nlohmann/json/issues/3390)
- Parser unable to handle large floating point numbers [\#3389](https://github.com/nlohmann/json/issues/3389)
- Compilation error if json\_pointer is used with alternative string type [\#3388](https://github.com/nlohmann/json/issues/3388)
- Unit tests conversions & items fail to build \(Clang \<4.0/C++14 only\) [\#3384](https://github.com/nlohmann/json/issues/3384)
- Regression test for \#3070 is not being run and fails when enabled [\#3377](https://github.com/nlohmann/json/issues/3377)
- Refactor unit tests to use more convenient doctest assertion macros [\#3365](https://github.com/nlohmann/json/issues/3365)
- An json.h issue reported in a static code analyzer [\#3361](https://github.com/nlohmann/json/issues/3361)
- Mixing different JSON\_DIAGNOSTICS settings in separately compiled units leads to core [\#3360](https://github.com/nlohmann/json/issues/3360)
- json::out\_of\_range exception matches against lot of others while testing [\#3352](https://github.com/nlohmann/json/issues/3352)
- use mipsel-openwrt-linux-g++ -std=c++11 to compile, it has some errors "error: 'snprintf' is not a member of 'std'" [\#3349](https://github.com/nlohmann/json/issues/3349)
- Add proper issue templates [\#3348](https://github.com/nlohmann/json/issues/3348)
- switch from json to ordered\_json [\#3343](https://github.com/nlohmann/json/issues/3343)
- Json dump use to compilation errors [\#3339](https://github.com/nlohmann/json/issues/3339)
- Ambiguous conversion from nlohmann::basic\_json\<\> to custom class. [\#3333](https://github.com/nlohmann/json/issues/3333)
- Iterator doesn't satisfy std::incrementable because post-increment may change constness [\#3331](https://github.com/nlohmann/json/issues/3331)
- Inconsistent handling of floating point numbers after parse\(\) [\#3329](https://github.com/nlohmann/json/issues/3329)
- Documentation for `ordered_json` should show proper use of the `parse()` function. [\#3325](https://github.com/nlohmann/json/issues/3325)
- "type must be boolean, but is object" error thrown on non-boolean object [\#3319](https://github.com/nlohmann/json/issues/3319)
- Incomplete Type in request parms [\#3318](https://github.com/nlohmann/json/issues/3318)
- 小米 MIX4 MIUI13  bug [\#3316](https://github.com/nlohmann/json/issues/3316)
- json.exception.parse\_error.101 when parsing data received over a socket [\#3313](https://github.com/nlohmann/json/issues/3313)
- Parse to custom class from unordered\_json breaks on G++11.2.0 with C++20 [\#3312](https://github.com/nlohmann/json/issues/3312)
- try to assign dumped string to a class member varible [\#3300](https://github.com/nlohmann/json/issues/3300)
- includedir in pkgconfig is error if install\_headers\(\) has subdir argument.  [\#3284](https://github.com/nlohmann/json/issues/3284)
- SHA-256 sum of json-3.10.5.tar.xz changes over time \(but not the content itself\) [\#3281](https://github.com/nlohmann/json/issues/3281)
- items\(\) method does not follow order of json message [\#3278](https://github.com/nlohmann/json/issues/3278)
- Perplexing template deduction failure serialising a 3rd party type using base class [\#3267](https://github.com/nlohmann/json/issues/3267)
- json.hpp 'isfinite' is not a member of 'std' also isinf; snprintf; stoull and to\_string members of std [\#3263](https://github.com/nlohmann/json/issues/3263)
- JSON build fails for C++ cmake [\#3256](https://github.com/nlohmann/json/issues/3256)
- Unexpected implicit conversion [\#3254](https://github.com/nlohmann/json/issues/3254)
- Add a function that checks for valid json in a C++ string  [\#3245](https://github.com/nlohmann/json/issues/3245)
- Replace use of standard IO from error handling [\#3239](https://github.com/nlohmann/json/issues/3239)
- Use Catch for unit tests [\#3232](https://github.com/nlohmann/json/issues/3232)
- Exception thrown during initialization causes a memory leak [\#3215](https://github.com/nlohmann/json/issues/3215)
- Tests failing when compiling with c++20 [\#3207](https://github.com/nlohmann/json/issues/3207)
- ambiguous regression [\#3204](https://github.com/nlohmann/json/issues/3204)
- Deserialization: if class is\_constructible from std::string wrong from\_json overload is being selected, compilation failed [\#3171](https://github.com/nlohmann/json/issues/3171)
- 'clang++ ./json.hpp' with no usage: Compiler syntax problem in clang 3.7.0 \(tizen :/ \) [\#3153](https://github.com/nlohmann/json/issues/3153)
- build failure on upcoming gcc-12: test/src/unit-regression1.cpp:392:22: error: ambiguous overload for 'operator=' [\#3138](https://github.com/nlohmann/json/issues/3138)
- Applying JSON patch creates parent object [\#3134](https://github.com/nlohmann/json/issues/3134)
- Iterators cannot be used with range-v3 [\#3130](https://github.com/nlohmann/json/issues/3130)
- std::shared\_ptr\<T\> == nlohmann::json compiles, which seem undesirable [\#3026](https://github.com/nlohmann/json/issues/3026)
- Error in test\download\_test\_data.vcxproj custom build step when compiling with Visual Studio 2019 16.7.7 msbuild on Windows 10 [\#2593](https://github.com/nlohmann/json/issues/2593)
- Consider putting the user-defined literals in a namespace [\#1682](https://github.com/nlohmann/json/issues/1682)
- Using versioned namespaces [\#1539](https://github.com/nlohmann/json/issues/1539)
- How can I use std::string\_view as the json\_key to "operator \[\]" ? [\#1529](https://github.com/nlohmann/json/issues/1529)
- serialize std::variant\<...\> [\#1261](https://github.com/nlohmann/json/issues/1261)

- Prepare 3.11.0 release [\#3635](https://github.com/nlohmann/json/pull/3635) ([nlohmann](https://github.com/nlohmann))
- Fix warning [\#3634](https://github.com/nlohmann/json/pull/3634) ([nlohmann](https://github.com/nlohmann))
- Add license header to new files [\#3633](https://github.com/nlohmann/json/pull/3633) ([nlohmann](https://github.com/nlohmann))
- Add a unit test including windows.h [\#3631](https://github.com/nlohmann/json/pull/3631) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fixed latest build error in msvc platform [\#3630](https://github.com/nlohmann/json/pull/3630) ([KsaNL](https://github.com/KsaNL))
- Add regression tests for \#3204 and \#3333 [\#3629](https://github.com/nlohmann/json/pull/3629) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix patch::add creating nonexistent parents [\#3628](https://github.com/nlohmann/json/pull/3628) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Adjust JSON Pointer examples [\#3622](https://github.com/nlohmann/json/pull/3622) ([nlohmann](https://github.com/nlohmann))
- Disable exceptions on ICPC [\#3621](https://github.com/nlohmann/json/pull/3621) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- build: install .pc and .cmake files to share/ [\#3619](https://github.com/nlohmann/json/pull/3619) ([Tachi107](https://github.com/Tachi107))
- Fix MinGW CI failures [\#3618](https://github.com/nlohmann/json/pull/3618) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix Unicode test timeout \(for real this time!\) [\#3614](https://github.com/nlohmann/json/pull/3614) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Use 'concurrency' in GitHub workflows [\#3610](https://github.com/nlohmann/json/pull/3610) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Use swap\(\) by ADL [\#3609](https://github.com/nlohmann/json/pull/3609) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Move UDLs out of the global namespace [\#3605](https://github.com/nlohmann/json/pull/3605) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Re-add value\_type detection to distinguish string types [\#3604](https://github.com/nlohmann/json/pull/3604) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add operator\<\<\(json\_pointer\) [\#3601](https://github.com/nlohmann/json/pull/3601) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add documentation for comparing json and ordered\_json [\#3599](https://github.com/nlohmann/json/pull/3599) ([nlohmann](https://github.com/nlohmann))
- Clean up after \#3581 [\#3596](https://github.com/nlohmann/json/pull/3596) ([nlohmann](https://github.com/nlohmann))
- Add assertion if nullptr is passed to parse function [\#3593](https://github.com/nlohmann/json/pull/3593) ([nlohmann](https://github.com/nlohmann))
- Minor documentation fixes [\#3592](https://github.com/nlohmann/json/pull/3592) ([nlohmann](https://github.com/nlohmann))
- Add versioned, ABI-tagged inline namespace and namespace macros [\#3590](https://github.com/nlohmann/json/pull/3590) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add badge for https://repology.org/project/nlohmann-json/versions [\#3586](https://github.com/nlohmann/json/pull/3586) ([nlohmann](https://github.com/nlohmann))
- Add error message if test suite cannot be found [\#3585](https://github.com/nlohmann/json/pull/3585) ([nlohmann](https://github.com/nlohmann))
- add patch\_inplace function [\#3581](https://github.com/nlohmann/json/pull/3581) ([wolfv](https://github.com/wolfv))
- Enable overriding test properties and set Unicode test timeouts [\#3580](https://github.com/nlohmann/json/pull/3580) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Ignore output directory [\#3572](https://github.com/nlohmann/json/pull/3572) ([NN---](https://github.com/NN---))
- Optimize output vector adapter write [\#3569](https://github.com/nlohmann/json/pull/3569) ([romainreignier](https://github.com/romainreignier))
- Add overloads for more key types to ordered\_map and fix ordered\_map::erase\(first, last\) with first == last [\#3564](https://github.com/nlohmann/json/pull/3564) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Make certain usage patterns more prominent in the README [\#3557](https://github.com/nlohmann/json/pull/3557) ([jez](https://github.com/jez))
- CI: fix "JSON\_MultipleHeaders" option spelling [\#3555](https://github.com/nlohmann/json/pull/3555) ([karzhenkov](https://github.com/karzhenkov))
- More documentation updates for 3.11.0 [\#3553](https://github.com/nlohmann/json/pull/3553) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Use DOCTEST\_\* compiler macros and suppress pragmas warning [\#3550](https://github.com/nlohmann/json/pull/3550) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add unit test to make sure iterator\_input\_adapter advances iterators correctly [\#3548](https://github.com/nlohmann/json/pull/3548) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Use REUSE framework [\#3546](https://github.com/nlohmann/json/pull/3546) ([nlohmann](https://github.com/nlohmann))
- Use `std::iterator_traits` to extract `iterator_category` [\#3544](https://github.com/nlohmann/json/pull/3544) ([Mike-Leo-Smith](https://github.com/Mike-Leo-Smith))
- BJData dimension length can not be string\_t::npos, fix \#3541 [\#3543](https://github.com/nlohmann/json/pull/3543) ([fangq](https://github.com/fangq))
- Allow disabling default enum conversions [\#3536](https://github.com/nlohmann/json/pull/3536) ([zxey](https://github.com/zxey))
- Add to\_json\(\) for std::vector\<bool\>::reference [\#3534](https://github.com/nlohmann/json/pull/3534) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- CI: Enable 32bit unit test \(3\) [\#3532](https://github.com/nlohmann/json/pull/3532) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Use new CI image [\#3528](https://github.com/nlohmann/json/pull/3528) ([nlohmann](https://github.com/nlohmann))
- Fix ndarray dimension signedness, fix ndarray length overflow \(2\); add 32bit unit test [\#3523](https://github.com/nlohmann/json/pull/3523) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Small documentation fixes [\#3520](https://github.com/nlohmann/json/pull/3520) ([nlohmann](https://github.com/nlohmann))
- Add assertion to converting constructor [\#3517](https://github.com/nlohmann/json/pull/3517) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- CI: Remove -Wstrict-overflow [\#3516](https://github.com/nlohmann/json/pull/3516) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix nlohmann/json\#3513, explain is\_ndarray flag [\#3514](https://github.com/nlohmann/json/pull/3514) ([fangq](https://github.com/fangq))
- Prevent ndarray size vector from recursive use, fix nlohmann/json\#3503 [\#3505](https://github.com/nlohmann/json/pull/3505) ([fangq](https://github.com/fangq))
- prevent ndarray dimension vector from recusive array, nlohmann/json\#3500 [\#3502](https://github.com/nlohmann/json/pull/3502) ([fangq](https://github.com/fangq))
- Discard optimized containers with negative counts in UBJSON/BJData \(\#3491,\#3492,\#3490\) [\#3500](https://github.com/nlohmann/json/pull/3500) ([fangq](https://github.com/fangq))
- Update json.hpp [\#3499](https://github.com/nlohmann/json/pull/3499) ([ivanovmp](https://github.com/ivanovmp))
- Add assertion for invariant in SAX-DOM parser [\#3498](https://github.com/nlohmann/json/pull/3498) ([nlohmann](https://github.com/nlohmann))
- Add more macOS builders [\#3485](https://github.com/nlohmann/json/pull/3485) ([nlohmann](https://github.com/nlohmann))
- change bjdata ndarray flag to detect negative size, as part of \#3475 [\#3479](https://github.com/nlohmann/json/pull/3479) ([fangq](https://github.com/fangq))
- Document fuzzer usage [\#3478](https://github.com/nlohmann/json/pull/3478) ([nlohmann](https://github.com/nlohmann))
- Add build step for ICPC \(with fixes\) [\#3465](https://github.com/nlohmann/json/pull/3465) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Complete documentation for 3.11.0 [\#3464](https://github.com/nlohmann/json/pull/3464) ([nlohmann](https://github.com/nlohmann))
- Handle invalid BJData optimized type, fix \#3461 [\#3463](https://github.com/nlohmann/json/pull/3463) ([fangq](https://github.com/fangq))
- Reorganize directories [\#3462](https://github.com/nlohmann/json/pull/3462) ([nlohmann](https://github.com/nlohmann))
- Enable rapid testing and development on Compiler Explorer [\#3456](https://github.com/nlohmann/json/pull/3456) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- cpplint 1.6.0 [\#3454](https://github.com/nlohmann/json/pull/3454) ([nlohmann](https://github.com/nlohmann))
- Disable regression test for \#3070 on GCC \<8.4 [\#3451](https://github.com/nlohmann/json/pull/3451) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix C++20/gcc-12 issues \(Part 2\) [\#3446](https://github.com/nlohmann/json/pull/3446) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Overwork documentation [\#3444](https://github.com/nlohmann/json/pull/3444) ([nlohmann](https://github.com/nlohmann))
- Fix typo in basic\_json documentation [\#3439](https://github.com/nlohmann/json/pull/3439) ([jhnlee](https://github.com/jhnlee))
- Exclude std::any from implicit conversion \(fixes \#3428\) [\#3437](https://github.com/nlohmann/json/pull/3437) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Document which version introduced the macros [\#3431](https://github.com/nlohmann/json/pull/3431) ([nlohmann](https://github.com/nlohmann))
- Fix constraints on from\_json\(\) for strings \(fixes \#3171, \#3267, \#3312, \#3384\) [\#3427](https://github.com/nlohmann/json/pull/3427) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- at.md: fix typo [\#3426](https://github.com/nlohmann/json/pull/3426) ([heinemml](https://github.com/heinemml))
- Implement support for string\_view \(attempt no. 3\) [\#3423](https://github.com/nlohmann/json/pull/3423) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- CI: speedup AppVeyor builds by ~30% [\#3422](https://github.com/nlohmann/json/pull/3422) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Restore disabled check for \#3070 \(except on MSVC\) [\#3421](https://github.com/nlohmann/json/pull/3421) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Update CI image [\#3420](https://github.com/nlohmann/json/pull/3420) ([nlohmann](https://github.com/nlohmann))
- Add check if different version is also included [\#3418](https://github.com/nlohmann/json/pull/3418) ([nlohmann](https://github.com/nlohmann))
- Report the right \_\_cplusplus value for MSVC in basic\_json meta\(\) [\#3417](https://github.com/nlohmann/json/pull/3417) ([flagarde](https://github.com/flagarde))
- CI: windows-2016 has been deprecated; remove jobs [\#3416](https://github.com/nlohmann/json/pull/3416) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Re-template json\_pointer on string type [\#3415](https://github.com/nlohmann/json/pull/3415) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Refactor unit tests to use more convenient doctest assertion macros \(Part 2\) [\#3405](https://github.com/nlohmann/json/pull/3405) ([kkarbowiak](https://github.com/kkarbowiak))
- Refactor unit tests to use more convenient doctest assertion macros [\#3393](https://github.com/nlohmann/json/pull/3393) ([kkarbowiak](https://github.com/kkarbowiak))
- Improve unit testing \(Part 1\) [\#3380](https://github.com/nlohmann/json/pull/3380) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix C++20/gcc-12 issues \(Part 1\) [\#3379](https://github.com/nlohmann/json/pull/3379) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add clarification to avoid misunderstanding that cause \#3360 [\#3378](https://github.com/nlohmann/json/pull/3378) ([puffetto](https://github.com/puffetto))
- Fix ordered\_map ctor with initializer\_list \(fixes \#3343\) [\#3370](https://github.com/nlohmann/json/pull/3370) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Fix and update CI [\#3368](https://github.com/nlohmann/json/pull/3368) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- FetchContent\_MakeAvailable [\#3351](https://github.com/nlohmann/json/pull/3351) ([nlohmann](https://github.com/nlohmann))
- Avoid clash with Arduino defines [\#3338](https://github.com/nlohmann/json/pull/3338) ([DarkZeros](https://github.com/DarkZeros))
- Support UBJSON-derived Binary JData \(BJData\) format [\#3336](https://github.com/nlohmann/json/pull/3336) ([fangq](https://github.com/fangq))
- Make iterator operator++/--\(int\) equality-preserving [\#3332](https://github.com/nlohmann/json/pull/3332) ([falbrechtskirchinger](https://github.com/falbrechtskirchinger))
- Add note on parsing ordered\_json [\#3326](https://github.com/nlohmann/json/pull/3326) ([nlohmann](https://github.com/nlohmann))
- Fix CITATION.cff and add automatic validation of your citation metadata [\#3320](https://github.com/nlohmann/json/pull/3320) ([fdiblen](https://github.com/fdiblen))
- .github/workflows/windows.yml: Add support for Visual Studio 2022 [\#3295](https://github.com/nlohmann/json/pull/3295) ([t-b](https://github.com/t-b))
- Add maintainer targets to create source archive [\#3289](https://github.com/nlohmann/json/pull/3289) ([nlohmann](https://github.com/nlohmann))
- Fix a typo [\#3265](https://github.com/nlohmann/json/pull/3265) ([fhuberts](https://github.com/fhuberts))
- Fix typo [\#3249](https://github.com/nlohmann/json/pull/3249) ([rex4539](https://github.com/rex4539))
- Add documentation for JSON Lines [\#3247](https://github.com/nlohmann/json/pull/3247) ([nlohmann](https://github.com/nlohmann))
- Improve documentation InputType and IteratorType [\#3246](https://github.com/nlohmann/json/pull/3246) ([nlohmann](https://github.com/nlohmann))
- Remove stringstream [\#3244](https://github.com/nlohmann/json/pull/3244) ([nlohmann](https://github.com/nlohmann))
- fix \_MSC\_VER version to check for std::filesystem [\#3240](https://github.com/nlohmann/json/pull/3240) ([gcerretani](https://github.com/gcerretani))
- Add macros NLOHMANN\_DEFINE\_TYPE\_INTRUSIVE\_WITH\_DEFAULT and ...\_NON\_INTRUSIVE\_WITH\_DEFAULT [\#3143](https://github.com/nlohmann/json/pull/3143) ([pketelsen](https://github.com/pketelsen))

## [v3.10.5](https://github.com/nlohmann/json/releases/tag/v3.10.5) (2022-01-03)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.4...v3.10.5)

- \#include \<filesystem\> doesn't work with gcc-7 when `-std=c++17` is specified. [\#3203](https://github.com/nlohmann/json/issues/3203)
- Not able to use nlohmann json with c++ code built using emscripten to wasm [\#3200](https://github.com/nlohmann/json/issues/3200)
- Warning for shadowed variables [\#3188](https://github.com/nlohmann/json/issues/3188)
- Accessing missing keys on const json object leads to assert [\#3183](https://github.com/nlohmann/json/issues/3183)
- Data member is available, but null is reported, and program throws error [\#3173](https://github.com/nlohmann/json/issues/3173)
- serialization problem, from\_json need construct new object [\#3169](https://github.com/nlohmann/json/issues/3169)
- std::filesystem unavailable on macOS lower deployment targets [\#3156](https://github.com/nlohmann/json/issues/3156)
- \[json.exception.type\_error.305\] cannot use operator\[\] with a string argument with string [\#3151](https://github.com/nlohmann/json/issues/3151)
- json::dump\(\) is not compatible with C++ standards [\#3147](https://github.com/nlohmann/json/issues/3147)
- Issue with json::parse decoding codepoints [\#3142](https://github.com/nlohmann/json/issues/3142)
- Simple parse of json object thinks it should be an array [\#3136](https://github.com/nlohmann/json/issues/3136)
- How to properly read a Json string that may be null in some cases? [\#3135](https://github.com/nlohmann/json/issues/3135)
- Deadlock on create json - windows only [\#3129](https://github.com/nlohmann/json/issues/3129)
- Wrong parsing of int64 values nearest of limit [\#3126](https://github.com/nlohmann/json/issues/3126)
- ordered\_json doesn't support range based erase [\#3108](https://github.com/nlohmann/json/issues/3108)
- Apple build failed with json/single\_include/nlohmann/json.hpp:4384:57: 'path' is unavailable [\#3097](https://github.com/nlohmann/json/issues/3097)
- GCC 7.5.0 with --std=c++17: filesystem: No such file or directory [\#3090](https://github.com/nlohmann/json/issues/3090)
- Drop Travis CI [\#3087](https://github.com/nlohmann/json/issues/3087)
- ordered\_json::reset\(\) compile error with nvcc [\#3013](https://github.com/nlohmann/json/issues/3013)
- Support for unordered\_map as object\_t [\#2932](https://github.com/nlohmann/json/issues/2932)
- Compiler warning with Intel compiler, same as \#755 [\#2712](https://github.com/nlohmann/json/issues/2712)
- Compiler warnings with NVCC 11.2 [\#2676](https://github.com/nlohmann/json/issues/2676)
- some static analysis warning at line 11317 [\#1390](https://github.com/nlohmann/json/issues/1390)
- Compiling with icpc [\#755](https://github.com/nlohmann/json/issues/755)

- Fix compilation error with NVCC [\#3234](https://github.com/nlohmann/json/pull/3234) ([nlohmann](https://github.com/nlohmann))
- Remove Travis CI [\#3233](https://github.com/nlohmann/json/pull/3233) ([nlohmann](https://github.com/nlohmann))
- Add build step for NVCC and fix a warning [\#3227](https://github.com/nlohmann/json/pull/3227) ([nlohmann](https://github.com/nlohmann))
- Update cpplint [\#3225](https://github.com/nlohmann/json/pull/3225) ([nlohmann](https://github.com/nlohmann))
- Fix: Warning for shadowed variables \(\#3188\) [\#3193](https://github.com/nlohmann/json/pull/3193) ([kernie](https://github.com/kernie))
- Fix FAQ hyperlink typo in readme [\#3148](https://github.com/nlohmann/json/pull/3148) ([Prince-Mendiratta](https://github.com/Prince-Mendiratta))
- Docs: Update `skip_comments` to `ignore_comments` [\#3145](https://github.com/nlohmann/json/pull/3145) ([daniel-kun](https://github.com/daniel-kun))
- fix typos in documentation [\#3140](https://github.com/nlohmann/json/pull/3140) ([striezel](https://github.com/striezel))
- Fix spelling [\#3125](https://github.com/nlohmann/json/pull/3125) ([axic](https://github.com/axic))
- Extend std specializations [\#3121](https://github.com/nlohmann/json/pull/3121) ([nlohmann](https://github.com/nlohmann))
- Add missing erase\(first, last\) function to ordered\_map [\#3109](https://github.com/nlohmann/json/pull/3109) ([nlohmann](https://github.com/nlohmann))
- Fix typos in operator\[\] documentation [\#3102](https://github.com/nlohmann/json/pull/3102) ([axnsan12](https://github.com/axnsan12))
- Add C++17 copies of the test binaries [\#3101](https://github.com/nlohmann/json/pull/3101) ([nlohmann](https://github.com/nlohmann))
- Add examples for parsing from iterator pair [\#3100](https://github.com/nlohmann/json/pull/3100) ([nlohmann](https://github.com/nlohmann))
- Update CI [\#3088](https://github.com/nlohmann/json/pull/3088) ([nlohmann](https://github.com/nlohmann))
- Consolidate documentation [\#3071](https://github.com/nlohmann/json/pull/3071) ([nlohmann](https://github.com/nlohmann))
- Add recursive update function [\#3069](https://github.com/nlohmann/json/pull/3069) ([nlohmann](https://github.com/nlohmann))

## [v3.10.4](https://github.com/nlohmann/json/releases/tag/v3.10.4) (2021-10-16)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.3...v3.10.4)

- Compiler error in output serializer due to 'incompatible initializer' [\#3081](https://github.com/nlohmann/json/issues/3081)
- Strange behaviour when using std::sort on std::vector\<json\> [\#3080](https://github.com/nlohmann/json/issues/3080)
- Unhandled exception: nlohmann::detail::parse\_error [\#3078](https://github.com/nlohmann/json/issues/3078)
- explicit constructor with default does not compile [\#3077](https://github.com/nlohmann/json/issues/3077)
- Parse an object but get an array using GCC [\#3076](https://github.com/nlohmann/json/issues/3076)
- Version 3.10.3 breaks backward-compatibility with 3.10.2 [\#3070](https://github.com/nlohmann/json/issues/3070)
- Feature request, Add to\_json/from\_json to align with other to/from binary api.  [\#3067](https://github.com/nlohmann/json/issues/3067)
- vcpkg is out of date [\#3066](https://github.com/nlohmann/json/issues/3066)

- Revert invalid fix [\#3082](https://github.com/nlohmann/json/pull/3082) ([nlohmann](https://github.com/nlohmann))
- Allow to use get with explicit constructor [\#3079](https://github.com/nlohmann/json/pull/3079) ([nlohmann](https://github.com/nlohmann))
- fix std::filesystem::path regression [\#3073](https://github.com/nlohmann/json/pull/3073) ([theodelrieu](https://github.com/theodelrieu))

## [v3.10.3](https://github.com/nlohmann/json/releases/tag/v3.10.3) (2021-10-08)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.2...v3.10.3)

- Parsing an emtpy string returns a string with size 1 instead of expected 0 [\#3057](https://github.com/nlohmann/json/issues/3057)
- Linking error  "duplicate symbol: std::type\_info::operator==" on static build with MinGW [\#3042](https://github.com/nlohmann/json/issues/3042)
- Yet another assertion failure when inserting into arrays with JSON\_DIAGNOSTICS set [\#3032](https://github.com/nlohmann/json/issues/3032)
- accept and parse function not work well with a pure number string [\#3029](https://github.com/nlohmann/json/issues/3029)
- push\_back doesn't work for serializing containers [\#3027](https://github.com/nlohmann/json/issues/3027)
- Strange behaviour when creating array with single element [\#3025](https://github.com/nlohmann/json/issues/3025)
- Input ordered\_json doesn't work [\#3023](https://github.com/nlohmann/json/issues/3023)
- Issue iterating through 'items' [\#3021](https://github.com/nlohmann/json/issues/3021)
- Cannot spell the namespace right [\#3015](https://github.com/nlohmann/json/issues/3015)
- JSON Parse error when reading json object from file [\#3011](https://github.com/nlohmann/json/issues/3011)
- Parent pointer not properly set when using update\(\) [\#3007](https://github.com/nlohmann/json/issues/3007)
- Overwriting terminated null character [\#3001](https://github.com/nlohmann/json/issues/3001)
- 'operator =' is ambiguous on VS2017 [\#2997](https://github.com/nlohmann/json/issues/2997)
- JSON Patch for Array Elements [\#2994](https://github.com/nlohmann/json/issues/2994)
- JSON Parse throwing error [\#2983](https://github.com/nlohmann/json/issues/2983)
- to\_{binary format} does not provide a mechanism for specifying a custom allocator for the returned type. [\#2982](https://github.com/nlohmann/json/issues/2982)
- 3.10.1 zip json.hpp has version number 3.10.0 instead of 3.10.1 [\#2973](https://github.com/nlohmann/json/issues/2973)
- Assertion failure when serializing array with JSON\_DIAGNOSTICS set [\#2926](https://github.com/nlohmann/json/issues/2926)

- Fix Clang version [\#3040](https://github.com/nlohmann/json/pull/3040) ([nlohmann](https://github.com/nlohmann))
- Fix assertion failure for JSON\_DIAGNOSTICS [\#3037](https://github.com/nlohmann/json/pull/3037) ([carlsmedstad](https://github.com/carlsmedstad))
- meta: fix is\_compatible/constructible traits [\#3020](https://github.com/nlohmann/json/pull/3020) ([theodelrieu](https://github.com/theodelrieu))
- Set parent pointers for values inserted via update\(\) \(fixes \#3007\). [\#3008](https://github.com/nlohmann/json/pull/3008) ([AnthonyVH](https://github.com/AnthonyVH))
- Allow allocators for output\_vector\_adapter [\#2989](https://github.com/nlohmann/json/pull/2989) ([nlohmann](https://github.com/nlohmann))
- Re-add Clang 12 [\#2986](https://github.com/nlohmann/json/pull/2986) ([nlohmann](https://github.com/nlohmann))
- Use new Docker image [\#2981](https://github.com/nlohmann/json/pull/2981) ([nlohmann](https://github.com/nlohmann))
- Update docset generation script [\#2967](https://github.com/nlohmann/json/pull/2967) ([nlohmann](https://github.com/nlohmann))

## [v3.10.2](https://github.com/nlohmann/json/releases/tag/v3.10.2) (2021-08-26)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.1...v3.10.2)

- Annoying -Wundef on new JSON\_DIAGNOSTICS macro [\#2975](https://github.com/nlohmann/json/issues/2975)
- += issue with multiple redirection. [\#2970](https://github.com/nlohmann/json/issues/2970)
- "incomplete type ‘nlohmann::detail::wide\_string\_input\_helper" compilation error [\#2969](https://github.com/nlohmann/json/issues/2969)

- Fix -Wunused warnings on JSON\_DIAGNOSTICS  [\#2976](https://github.com/nlohmann/json/pull/2976) ([gcerretani](https://github.com/gcerretani))

## [v3.10.1](https://github.com/nlohmann/json/releases/tag/v3.10.1) (2021-08-24)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.10.0...v3.10.1)

- JSON\_DIAGNOSTICS assertion for ordered\_json [\#2962](https://github.com/nlohmann/json/issues/2962)
- Inserting in unordered json using a pointer retains the leading slash [\#2958](https://github.com/nlohmann/json/issues/2958)
- Test  \#9: test-cbor test case sample.json fails in debug mode - Stack overflow [\#2955](https://github.com/nlohmann/json/issues/2955)
- 3.10.0 broke at least the Bear project [\#2953](https://github.com/nlohmann/json/issues/2953)
- 2 tests fail in 3.10.0: cmake\_fetch\_content\_configure, cmake\_fetch\_content\_build [\#2951](https://github.com/nlohmann/json/issues/2951)
- ctest \(58+60,/67 cmake\_import\_configure\) fails when build with -D JSON\_Install:BOOL=OFF because of missing nlohmann\_jsonTargets.cmake [\#2946](https://github.com/nlohmann/json/issues/2946)
- Document vcpkg usage [\#2944](https://github.com/nlohmann/json/issues/2944)
- Linker error LNK2005 when compiling \(x64\) json-3.10.0.zip with Visual Studio 2019 16.11.1  [\#2941](https://github.com/nlohmann/json/issues/2941)
- Move Travis jobs to travis-ci.com [\#2938](https://github.com/nlohmann/json/issues/2938)

- Fixed typo in docs/api/basic\_json/parse.md [\#2968](https://github.com/nlohmann/json/pull/2968) ([mbadhan](https://github.com/mbadhan))
- Add link to Homebrew package [\#2966](https://github.com/nlohmann/json/pull/2966) ([nlohmann](https://github.com/nlohmann))
- Fix parent update for diagnostics with ordered\_json [\#2963](https://github.com/nlohmann/json/pull/2963) ([nlohmann](https://github.com/nlohmann))
- Set stack size for some unit tests when using MSVC [\#2961](https://github.com/nlohmann/json/pull/2961) ([nlohmann](https://github.com/nlohmann))
- Add regression test [\#2960](https://github.com/nlohmann/json/pull/2960) ([nlohmann](https://github.com/nlohmann))
- Update Travis badge [\#2959](https://github.com/nlohmann/json/pull/2959) ([nlohmann](https://github.com/nlohmann))
- Fix some extra ";" clang warnings [\#2957](https://github.com/nlohmann/json/pull/2957) ([Hallot](https://github.com/Hallot))
- Add documentation for integration via vcpkg [\#2954](https://github.com/nlohmann/json/pull/2954) ([nlohmann](https://github.com/nlohmann))
- Avoid duplicate AppVeyor builds [\#2952](https://github.com/nlohmann/json/pull/2952) ([nlohmann](https://github.com/nlohmann))
- 🚨 fix gdb\_pretty\_printer failure on basic types [\#2950](https://github.com/nlohmann/json/pull/2950) ([senyai](https://github.com/senyai))
- Add header to use value\_t [\#2948](https://github.com/nlohmann/json/pull/2948) ([nlohmann](https://github.com/nlohmann))
- Skip some tests if JSON\_Install is not set [\#2947](https://github.com/nlohmann/json/pull/2947) ([nlohmann](https://github.com/nlohmann))
- Remove outdated json\_unit test binary [\#2945](https://github.com/nlohmann/json/pull/2945) ([nlohmann](https://github.com/nlohmann))
- Updating the Homebrew Command [\#2943](https://github.com/nlohmann/json/pull/2943) ([amirmasoudabdol](https://github.com/amirmasoudabdol))

## [v3.10.0](https://github.com/nlohmann/json/releases/tag/v3.10.0) (2021-08-17)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.9.1...v3.10.0)

- Latest version 3.9.1 uses throw instead of JSON\_THROW in the amalgamated json.hpp file [\#2934](https://github.com/nlohmann/json/issues/2934)
- Copy to a variable inside a Structure [\#2933](https://github.com/nlohmann/json/issues/2933)
- warning C4068: unknown pragma 'GCC' on MSVC/cl [\#2924](https://github.com/nlohmann/json/issues/2924)
- Errors during ninja test [\#2918](https://github.com/nlohmann/json/issues/2918)
- compiler warning: "not return a value" [\#2917](https://github.com/nlohmann/json/issues/2917)
- Comparison floating points causes warning [\#2909](https://github.com/nlohmann/json/issues/2909)
- Why can't I have std::vector\<json&\> testList? [\#2900](https://github.com/nlohmann/json/issues/2900)
- \[json.hpp\] from releases doesnt work [\#2897](https://github.com/nlohmann/json/issues/2897)
- g++ \(11\) -Wuseless-cast gives lots of warnings [\#2893](https://github.com/nlohmann/json/issues/2893)
- Cannot serialize and immediatly deserialize json to/from bson [\#2892](https://github.com/nlohmann/json/issues/2892)
- Floating-point precision conversion error [\#2876](https://github.com/nlohmann/json/issues/2876)
- How to avoid escaping for an already escaped string in .dump\(\) [\#2870](https://github.com/nlohmann/json/issues/2870)
- can't parse std::vector\<std::byte\> [\#2869](https://github.com/nlohmann/json/issues/2869)
- ASAN detects memory leaks [\#2865](https://github.com/nlohmann/json/issues/2865)
- Binary subtype field cannot represent all CBOR tags [\#2863](https://github.com/nlohmann/json/issues/2863)
- string literals possibly being parsed as another type due to the presence of only digits and full-stops [\#2852](https://github.com/nlohmann/json/issues/2852)
- json::parse\(\) works only with absolute paths [\#2851](https://github.com/nlohmann/json/issues/2851)
- Compiler Warnings on Raspberry Pi OS [\#2850](https://github.com/nlohmann/json/issues/2850)
- Braced initialization and aggregate initialization behavior is different for `json::array()` function call. [\#2848](https://github.com/nlohmann/json/issues/2848)
- 3.9.1: test suite is failing [\#2845](https://github.com/nlohmann/json/issues/2845)
- Documentation for macro JSON\_NO\_IO is missing [\#2842](https://github.com/nlohmann/json/issues/2842)
- Assertion failure when inserting into arrays with JSON\_DIAGNOSTICS set [\#2838](https://github.com/nlohmann/json/issues/2838)
- HELP! There is a memory leak in the code?! [\#2837](https://github.com/nlohmann/json/issues/2837)
- Elegant conversion of a 2-D-json array to a standard C++ array [\#2805](https://github.com/nlohmann/json/issues/2805)
- Swift Package Manager support [\#2802](https://github.com/nlohmann/json/issues/2802)
- Referencing a subkey which doesn't exist gives crash [\#2797](https://github.com/nlohmann/json/issues/2797)
- Failed benchmark due to renamed branch [\#2796](https://github.com/nlohmann/json/issues/2796)
- Build Errors with VS 2019 and json Version 3.9.1 when attempting to replicate SAX Example [\#2782](https://github.com/nlohmann/json/issues/2782)
- Value with spaces cannot be parsed [\#2781](https://github.com/nlohmann/json/issues/2781)
- \[Question\] CBOR rfc support. [\#2779](https://github.com/nlohmann/json/issues/2779)
- Using JSON.hpp header file in Visual Studio 2013 \(C++ Project\) [\#2775](https://github.com/nlohmann/json/issues/2775)
- compilation error on clang-8 + C++17 [\#2759](https://github.com/nlohmann/json/issues/2759)
- Undefined symbol EOF  [\#2755](https://github.com/nlohmann/json/issues/2755)
- Parsing a string into json object behaves differently under g++ and MinGW compilers. [\#2746](https://github.com/nlohmann/json/issues/2746)
- big git history size [\#2742](https://github.com/nlohmann/json/issues/2742)
- How to get reference of std::vector\<T\> [\#2735](https://github.com/nlohmann/json/issues/2735)
- CMake failure in VS2019 Community [\#2734](https://github.com/nlohmann/json/issues/2734)
- Possibility to use with custom c++ version to use in intel sgx enclaves [\#2730](https://github.com/nlohmann/json/issues/2730)
- Possibility to use without the dependency to file io and streams to use in intel sgx enclaves [\#2728](https://github.com/nlohmann/json/issues/2728)
- error C2784& error C2839... in my visual studio 2015 compiler [\#2726](https://github.com/nlohmann/json/issues/2726)
- `-fno-expection` not respected anymore in 3.9.1 [\#2725](https://github.com/nlohmann/json/issues/2725)
- When exceptions disabled with JSON\_NOEXCEPTION, lib just aborts without any message [\#2724](https://github.com/nlohmann/json/issues/2724)
- Critical error detected c0000374 on windows10 msvc 2019 16.8.5 [\#2710](https://github.com/nlohmann/json/issues/2710)
- unused parameter error/warning [\#2706](https://github.com/nlohmann/json/issues/2706)
- How to store data into a Map from json file [\#2691](https://github.com/nlohmann/json/issues/2691)
- Tests do not compile with pre-release glibc [\#2686](https://github.com/nlohmann/json/issues/2686)
- compile errors .... chromium-style [\#2680](https://github.com/nlohmann/json/issues/2680)
- .dump\(\) not allowing compact form [\#2678](https://github.com/nlohmann/json/issues/2678)
- error: no matching function for call to ‘nlohmann::basic\_json\<\>::value\(int, std::set\<int\>&\)’ [\#2671](https://github.com/nlohmann/json/issues/2671)
- Compiler warning: unused parameter [\#2668](https://github.com/nlohmann/json/issues/2668)
- Deserializing to a struct as shown on the project homepage throws compile time errors [\#2665](https://github.com/nlohmann/json/issues/2665)
- Unable to compile on MSVC 2019 with SDL checking enabled: This function or variable may be unsafe [\#2664](https://github.com/nlohmann/json/issues/2664)
- terminating with uncaught exception of type nlohmann::detail::type\_error: \[json.exception.type\_error.302\] type must be array, but is object [\#2661](https://github.com/nlohmann/json/issues/2661)
- unused-parameter on OSX when Diagnostics is off [\#2658](https://github.com/nlohmann/json/issues/2658)
- std::pair wrong serialization [\#2655](https://github.com/nlohmann/json/issues/2655)
- The result of json is\_number\_integer\(\) function is wrong when read a json file  [\#2653](https://github.com/nlohmann/json/issues/2653)
- 2 backslash cause problem [\#2652](https://github.com/nlohmann/json/issues/2652)
- No support for using an external/system copy of Hedley [\#2651](https://github.com/nlohmann/json/issues/2651)
- error: incomplete type 'qfloat16' used in type trait expression [\#2650](https://github.com/nlohmann/json/issues/2650)
- Unused variable in exception class when not using improved diagnostics [\#2646](https://github.com/nlohmann/json/issues/2646)
- I am trying to do this - converting from wstring works incorrectly! [\#2642](https://github.com/nlohmann/json/issues/2642)
- Exception 207 On ARM Processor During Literal String Parsing [\#2634](https://github.com/nlohmann/json/issues/2634)
- double free or corruption \(!prev\) error on Json push\_back and write [\#2632](https://github.com/nlohmann/json/issues/2632)
- nlohmann::detail::parse\_error: syntax error while parsing CBOR string: expected length specification \(0x60-0x7B\) or indefinite string type \(0x7F\) [\#2629](https://github.com/nlohmann/json/issues/2629)
- please allow disabling implicit conversions in non-single-file use [\#2621](https://github.com/nlohmann/json/issues/2621)
- Preserve decimal formatting [\#2618](https://github.com/nlohmann/json/issues/2618)
- Visual Studio Visual Assist code issues reported by VA code inspection of file json.hpp [\#2615](https://github.com/nlohmann/json/issues/2615)
- Missing get function and no viable overloaded '=' on mac [\#2610](https://github.com/nlohmann/json/issues/2610)
- corruption when parse from string [\#2603](https://github.com/nlohmann/json/issues/2603)
- Parse from byte-vector results in compile error [\#2602](https://github.com/nlohmann/json/issues/2602)
- Memory leak when working on ARM Linux [\#2601](https://github.com/nlohmann/json/issues/2601)
- Unhandled exception in test-cbor.exe Stack overflow when debugging project with Visual Studio 2019 16.7.7 compiled with c++17 or c++latest [\#2598](https://github.com/nlohmann/json/issues/2598)
- Error in download\_test\_data.vcxproj when compiling with Visual Studio 2019 16.7.7 Professional msbuild on Windows 10 2004 Professional [\#2594](https://github.com/nlohmann/json/issues/2594)
- Warnings  C4715 and C4127 when building json-3.9.1 with Visual Studio 2019 16.7.7 [\#2592](https://github.com/nlohmann/json/issues/2592)
- I tried some change to dump\(\) for \[1,2,3...\] [\#2584](https://github.com/nlohmann/json/issues/2584)
- try/catch block does not catch parsing error [\#2579](https://github.com/nlohmann/json/issues/2579)
- Serializing uint64\_t is broken for large values [\#2578](https://github.com/nlohmann/json/issues/2578)
- deserializing arrays should be part of the library [\#2575](https://github.com/nlohmann/json/issues/2575)
- Deserialization to std::array with non-default constructable types fails [\#2574](https://github.com/nlohmann/json/issues/2574)
- Compilation error when trying to use same type for number\_integer\_t and number\_unsigned\_t in basic\_json template specification. [\#2573](https://github.com/nlohmann/json/issues/2573)
- compiler error: directive output may be truncated writing between 2 and 8 bytes [\#2572](https://github.com/nlohmann/json/issues/2572)
- Incorrect convert map to json when key cannot construct an string i.e. int  [\#2564](https://github.com/nlohmann/json/issues/2564)
- no matching function for call to ‘nlohmann::basic\_json\<\>::basic\_json\(\<brace-enclosed initializer list\>\)’ [\#2559](https://github.com/nlohmann/json/issues/2559)
- type\_error factory creates a dangling pointer \(in VisualStudio 2019\) [\#2535](https://github.com/nlohmann/json/issues/2535)
- Cannot assign from ordered\_json vector\<CustomStruct\> to value in not ordered json [\#2528](https://github.com/nlohmann/json/issues/2528)
- Qt6: Break changes [\#2519](https://github.com/nlohmann/json/issues/2519)
- valgrind memcheck Illegal instruction when use nlohmann::json::parse [\#2518](https://github.com/nlohmann/json/issues/2518)
- Buffer overflow [\#2515](https://github.com/nlohmann/json/issues/2515)
- Including CTest in the top-level CMakeLists.txt sets BUILD\_TESTING=ON for parent projects [\#2513](https://github.com/nlohmann/json/issues/2513)
- Compilation error when using NLOHMANN\_JSON\_SERIALIZE\_ENUM ordered\_json on libc++ [\#2491](https://github.com/nlohmann/json/issues/2491)
- Missing "void insert\( InputIt first, InputIt last \);" overload in nlohmann::ordered\_map [\#2490](https://github.com/nlohmann/json/issues/2490)
- Could not find a package configuration file provided by "nlohmann\_json" [\#2482](https://github.com/nlohmann/json/issues/2482)
- json becomes empty for unknown reason [\#2470](https://github.com/nlohmann/json/issues/2470)
- Using std::wstring as StringType fails compiling [\#2459](https://github.com/nlohmann/json/issues/2459)
- Sample code in GIF slide outdated \(cannot use emplace\(\) with array\) [\#2457](https://github.com/nlohmann/json/issues/2457)
- from\_json\<std::wstring\> is treated as an array on latest MSVC [\#2453](https://github.com/nlohmann/json/issues/2453)
- MemorySanitizer: use-of-uninitialized-value [\#2449](https://github.com/nlohmann/json/issues/2449)
- I need help [\#2441](https://github.com/nlohmann/json/issues/2441)
- type conversion failing with clang ext\_vector\_type  [\#2436](https://github.com/nlohmann/json/issues/2436)
- json::parse\(\) can't be resolved under specific circumstances [\#2427](https://github.com/nlohmann/json/issues/2427)
- from\_\*\(ptr, len\) deprecation [\#2426](https://github.com/nlohmann/json/issues/2426)
- Error ONLY in release mode [\#2425](https://github.com/nlohmann/json/issues/2425)
- "Custom data source" exemple make no sense [\#2423](https://github.com/nlohmann/json/issues/2423)
- Refuses to compile in project [\#2419](https://github.com/nlohmann/json/issues/2419)
- Compilation failure of tests with C++20 standard \(caused by change of u8 literals\)  [\#2413](https://github.com/nlohmann/json/issues/2413)
- No matching function for call to 'input\_adapter' under Xcode of with nlohmann version 3.9.1 [\#2412](https://github.com/nlohmann/json/issues/2412)
- Git tags are not valid semvers [\#2409](https://github.com/nlohmann/json/issues/2409)
- after dump, stderr output disappear [\#2403](https://github.com/nlohmann/json/issues/2403)
- Using custom string. [\#2398](https://github.com/nlohmann/json/issues/2398)
- value\(\) throws unhandled exception for partially specified json object [\#2393](https://github.com/nlohmann/json/issues/2393)
- assertion on runtime causes program to stop when accessing const json with missing key [\#2392](https://github.com/nlohmann/json/issues/2392)
- Usage with -fno-elide-constructors causes dump\(\) output to be array of `null`s [\#2387](https://github.com/nlohmann/json/issues/2387)
- Build fails with clang-cl due to override of CMAKE\_CXX\_COMPILER\(?\) [\#2384](https://github.com/nlohmann/json/issues/2384)
- std::optional not working with primitive types [\#2383](https://github.com/nlohmann/json/issues/2383)
- Unexpected array when initializing a json const& on gcc 4.8.5 using uniform syntax [\#2370](https://github.com/nlohmann/json/issues/2370)
- setprecision support [\#2362](https://github.com/nlohmann/json/issues/2362)
- json::parse\(allow\_exceptions = false\) documentation is misleading. [\#2360](https://github.com/nlohmann/json/issues/2360)
- std::begin and std::end usage without specifying std namespace [\#2359](https://github.com/nlohmann/json/issues/2359)
- Custom object conversion to json hangs in background thread [\#2358](https://github.com/nlohmann/json/issues/2358)
- Add support of nullable fields to NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE and NLOHMANN\_DEFINE\_TYPE\_INTRUSIVE [\#2356](https://github.com/nlohmann/json/issues/2356)
- the portfile for the vcpkg is not working. [\#2351](https://github.com/nlohmann/json/issues/2351)
- Compiler warns of implicit fallthrough when defining preprocessor macro NDEBUG [\#2348](https://github.com/nlohmann/json/issues/2348)
- Compile error on Intel compiler running in Windows [\#2346](https://github.com/nlohmann/json/issues/2346)
- Build error caused by overwriting CMAKE\_CXX\_COMPILER [\#2343](https://github.com/nlohmann/json/issues/2343)
- Error: an attribute list cannot appear here     JSON\_HEDLEY\_DEPRECATED\_FOR [\#2342](https://github.com/nlohmann/json/issues/2342)
- compiler warning [\#2341](https://github.com/nlohmann/json/issues/2341)
- 3.9.0: tests make build non-reproducible [\#2324](https://github.com/nlohmann/json/issues/2324)
- Initialization different between gcc/clang [\#2311](https://github.com/nlohmann/json/issues/2311)
- Attempt to `get()` a numeric value as a type which cannot represent it should throw [\#2310](https://github.com/nlohmann/json/issues/2310)
- Surprising behaviour with overloaded operators [\#2256](https://github.com/nlohmann/json/issues/2256)
- ADL issue in input\_adapter [\#2248](https://github.com/nlohmann/json/issues/2248)
- Output adapters should be templated. [\#2172](https://github.com/nlohmann/json/issues/2172)
- error when using nlohmann::json, std::function and std::bind [\#2147](https://github.com/nlohmann/json/issues/2147)
- Remove undefined behavior for const operator\[\] [\#2111](https://github.com/nlohmann/json/issues/2111)
- json\({}\) gives null instead of empty object with GCC and -std=c++17 [\#2046](https://github.com/nlohmann/json/issues/2046)
- GDB pretty printing support [\#1952](https://github.com/nlohmann/json/issues/1952)
- Always compile tests with all warnings enabled and error out on warnings [\#1798](https://github.com/nlohmann/json/issues/1798)
- Fixes Cppcheck warnings [\#1759](https://github.com/nlohmann/json/issues/1759)
- How to get position info or parser context with custom from\_json\(\) that may throw exceptions? [\#1508](https://github.com/nlohmann/json/issues/1508)
- Suggestion to improve value\(\) accessors with respect to move semantics [\#1275](https://github.com/nlohmann/json/issues/1275)
- Add Key name to Exception [\#932](https://github.com/nlohmann/json/issues/932)

- Overwork warning flags [\#2936](https://github.com/nlohmann/json/pull/2936) ([nlohmann](https://github.com/nlohmann))
- Treat MSVC warnings as errors [\#2930](https://github.com/nlohmann/json/pull/2930) ([nlohmann](https://github.com/nlohmann))
- All: fix warnings when compiling with -Wswitch-enum [\#2927](https://github.com/nlohmann/json/pull/2927) ([fhuberts](https://github.com/fhuberts))
- Guard GCC pragmas [\#2925](https://github.com/nlohmann/json/pull/2925) ([nlohmann](https://github.com/nlohmann))
- Supress -Wfloat-equal on intended float comparisions [\#2911](https://github.com/nlohmann/json/pull/2911) ([Finkman](https://github.com/Finkman))
- Fix binary subtypes [\#2908](https://github.com/nlohmann/json/pull/2908) ([nlohmann](https://github.com/nlohmann))
- Fix useless-cast warnings [\#2902](https://github.com/nlohmann/json/pull/2902) ([nlohmann](https://github.com/nlohmann))
- Add regression test [\#2898](https://github.com/nlohmann/json/pull/2898) ([nlohmann](https://github.com/nlohmann))
- Refactor Unicode tests [\#2889](https://github.com/nlohmann/json/pull/2889) ([nlohmann](https://github.com/nlohmann))
- CMake cleanup [\#2885](https://github.com/nlohmann/json/pull/2885) ([nlohmann](https://github.com/nlohmann))
- Avoid string in case of empty CBOR objects [\#2879](https://github.com/nlohmann/json/pull/2879) ([nlohmann](https://github.com/nlohmann))
- Suppress C4127 warning in unit-json\_pointer.cpp [\#2875](https://github.com/nlohmann/json/pull/2875) ([nlohmann](https://github.com/nlohmann))
- Fix truncation warning [\#2874](https://github.com/nlohmann/json/pull/2874) ([nlohmann](https://github.com/nlohmann))
- Fix memory leak in to\_json [\#2872](https://github.com/nlohmann/json/pull/2872) ([nlohmann](https://github.com/nlohmann))
- Fix assertion failure in diagnostics [\#2866](https://github.com/nlohmann/json/pull/2866) ([nlohmann](https://github.com/nlohmann))
- Update documentation [\#2861](https://github.com/nlohmann/json/pull/2861) ([nlohmann](https://github.com/nlohmann))
- Consistency with `using` in README.md [\#2826](https://github.com/nlohmann/json/pull/2826) ([justanotheranonymoususer](https://github.com/justanotheranonymoususer))
- Properly constrain the basic\_json conversion operator [\#2825](https://github.com/nlohmann/json/pull/2825) ([ldionne](https://github.com/ldionne))
- Fix CI [\#2817](https://github.com/nlohmann/json/pull/2817) ([nlohmann](https://github.com/nlohmann))
- Specified git branch for google benchmark fetch in benchmark test [\#2795](https://github.com/nlohmann/json/pull/2795) ([grafail](https://github.com/grafail))
- Add C++ standards to macOS matrix [\#2790](https://github.com/nlohmann/json/pull/2790) ([nlohmann](https://github.com/nlohmann))
- Update URLs to HTTPS [\#2789](https://github.com/nlohmann/json/pull/2789) ([TotalCaesar659](https://github.com/TotalCaesar659))
- Link to Conan Center package added [\#2771](https://github.com/nlohmann/json/pull/2771) ([offa](https://github.com/offa))
- Keep consistent formatting [\#2770](https://github.com/nlohmann/json/pull/2770) ([jasmcaus](https://github.com/jasmcaus))
- Add a cmake option to use SYSTEM in target\_include\_directories [\#2762](https://github.com/nlohmann/json/pull/2762) ([jpl-mac](https://github.com/jpl-mac))
- replace EOF with std::char\_traits\<char\>::eof\(\) [\#2756](https://github.com/nlohmann/json/pull/2756) ([nlohmann](https://github.com/nlohmann))
- Fix typo in README [\#2754](https://github.com/nlohmann/json/pull/2754) ([mortenfyhn](https://github.com/mortenfyhn))
- Update documentation [\#2749](https://github.com/nlohmann/json/pull/2749) ([nlohmann](https://github.com/nlohmann))
- Add documentation for numbers [\#2747](https://github.com/nlohmann/json/pull/2747) ([nlohmann](https://github.com/nlohmann))
- Use Clang 12 in CI [\#2737](https://github.com/nlohmann/json/pull/2737) ([nlohmann](https://github.com/nlohmann))
- Fixes \#2730 [\#2731](https://github.com/nlohmann/json/pull/2731) ([theShmoo](https://github.com/theShmoo))
- Possibility to use without the dependency to file io and streams to use in intel sgx enclaves [\#2729](https://github.com/nlohmann/json/pull/2729) ([theShmoo](https://github.com/theShmoo))
- Update json.hpp [\#2707](https://github.com/nlohmann/json/pull/2707) ([raduteo](https://github.com/raduteo))
- pkg-config.pc.in: Don't concatenate paths [\#2690](https://github.com/nlohmann/json/pull/2690) ([doronbehar](https://github.com/doronbehar))
- add more CI steps [\#2689](https://github.com/nlohmann/json/pull/2689) ([nlohmann](https://github.com/nlohmann))
- Update doctest from 2.4.4 to 2.4.6 \(fixes \#2686\) [\#2687](https://github.com/nlohmann/json/pull/2687) ([musicinmybrain](https://github.com/musicinmybrain))
- License fix [\#2683](https://github.com/nlohmann/json/pull/2683) ([nlohmann](https://github.com/nlohmann))
- Update parse\_exceptions.md - correct `json::exception::parse_error` [\#2679](https://github.com/nlohmann/json/pull/2679) ([frasermarlow](https://github.com/frasermarlow))
- Remove HEDLEY annotation from exception::what\(\) [\#2673](https://github.com/nlohmann/json/pull/2673) ([remyjette](https://github.com/remyjette))
- Fix amount of entries in the json object [\#2659](https://github.com/nlohmann/json/pull/2659) ([abbaswasim](https://github.com/abbaswasim))
- Fix missing 1.78 in example in README.md [\#2625](https://github.com/nlohmann/json/pull/2625) ([wawiesel](https://github.com/wawiesel))
- Add GDB pretty printer [\#2607](https://github.com/nlohmann/json/pull/2607) ([nlohmann](https://github.com/nlohmann))
- readme: fix tilde character display [\#2582](https://github.com/nlohmann/json/pull/2582) ([bl-ue](https://github.com/bl-ue))
- Add support for deserialization of STL containers of non-default constructable types \(fixes \#2574\). [\#2576](https://github.com/nlohmann/json/pull/2576) ([AnthonyVH](https://github.com/AnthonyVH))
- Better diagnostics [\#2562](https://github.com/nlohmann/json/pull/2562) ([nlohmann](https://github.com/nlohmann))
- CI targets [\#2561](https://github.com/nlohmann/json/pull/2561) ([nlohmann](https://github.com/nlohmann))
- Add switch to skip non-reproducible tests. [\#2560](https://github.com/nlohmann/json/pull/2560) ([nlohmann](https://github.com/nlohmann))
- Fix compilation of input\_adapter\(container\) in edge cases [\#2553](https://github.com/nlohmann/json/pull/2553) ([jasujm](https://github.com/jasujm))
- Allow parsing from std::byte containers [\#2550](https://github.com/nlohmann/json/pull/2550) ([nlohmann](https://github.com/nlohmann))
- Travis doesn't run any tests in C++17 mode [\#2540](https://github.com/nlohmann/json/pull/2540) ([karzhenkov](https://github.com/karzhenkov))
- Doctest is updated to v2.4.3 [\#2538](https://github.com/nlohmann/json/pull/2538) ([YarikTH](https://github.com/YarikTH))
- Fix warnings [\#2537](https://github.com/nlohmann/json/pull/2537) ([nlohmann](https://github.com/nlohmann))
- Fix a shadowing warning [\#2536](https://github.com/nlohmann/json/pull/2536) ([nlohmann](https://github.com/nlohmann))
- Clarify license of is\_complete\_type implementation [\#2534](https://github.com/nlohmann/json/pull/2534) ([nlohmann](https://github.com/nlohmann))
- Do not unconditionally redefine C++14 constructs [\#2533](https://github.com/nlohmann/json/pull/2533) ([nlohmann](https://github.com/nlohmann))
- Doctest is updated to v2.4.1 [\#2525](https://github.com/nlohmann/json/pull/2525) ([YarikTH](https://github.com/YarikTH))
- Add MAIN\_PROJECT check for test and install options [\#2514](https://github.com/nlohmann/json/pull/2514) ([globberwops](https://github.com/globberwops))
- Ranged insert test section is added in unit-ordered\_json.cpp [\#2512](https://github.com/nlohmann/json/pull/2512) ([YarikTH](https://github.com/YarikTH))
- Add asserts to suppress C28020 [\#2447](https://github.com/nlohmann/json/pull/2447) ([jbzdarkid](https://github.com/jbzdarkid))
- Change argument name "subtype" in byte\_container\_with\_subtype [\#2444](https://github.com/nlohmann/json/pull/2444) ([linev](https://github.com/linev))
- 📝  add CPM.Cmake example [\#2406](https://github.com/nlohmann/json/pull/2406) ([leozz37](https://github.com/leozz37))
- Fix move constructor of json\_ref [\#2405](https://github.com/nlohmann/json/pull/2405) ([karzhenkov](https://github.com/karzhenkov))
- Properly select "Release" build for Travis [\#2375](https://github.com/nlohmann/json/pull/2375) ([karzhenkov](https://github.com/karzhenkov))
- Update Hedley [\#2367](https://github.com/nlohmann/json/pull/2367) ([nlohmann](https://github.com/nlohmann))
- Fix and extend documentation of discarded values [\#2363](https://github.com/nlohmann/json/pull/2363) ([nlohmann](https://github.com/nlohmann))
- Fix typos in documentation [\#2354](https://github.com/nlohmann/json/pull/2354) ([rbuch](https://github.com/rbuch))
- Remove "\#define private public" from tests [\#2352](https://github.com/nlohmann/json/pull/2352) ([nlohmann](https://github.com/nlohmann))
- Remove -Wimplicit-fallthrough warning [\#2349](https://github.com/nlohmann/json/pull/2349) ([nlohmann](https://github.com/nlohmann))
- Fix code to work without exceptions [\#2347](https://github.com/nlohmann/json/pull/2347) ([nlohmann](https://github.com/nlohmann))
- fix cmake script overwriting compiler path [\#2344](https://github.com/nlohmann/json/pull/2344) ([ongjunjie](https://github.com/ongjunjie))

## [v3.9.1](https://github.com/nlohmann/json/releases/tag/v3.9.1) (2020-08-06)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.9.0...v3.9.1)

- Can't parse not formatted JSON. [\#2340](https://github.com/nlohmann/json/issues/2340)
- parse returns desired array contained in array when JSON text begins with square bracket on gcc 7.5.0 [\#2339](https://github.com/nlohmann/json/issues/2339)
- Unexpected deserialization difference between Mac and Linux [\#2338](https://github.com/nlohmann/json/issues/2338)
- Reading ordered\_json from file causes compile error [\#2331](https://github.com/nlohmann/json/issues/2331)
- ignore\_comment=true fails on multiple consecutive lines starting with comments [\#2330](https://github.com/nlohmann/json/issues/2330)
- Update documentation about Homebrew installation and CMake integration - Homebrew [\#2326](https://github.com/nlohmann/json/issues/2326)
- Chinese character initialize error [\#2325](https://github.com/nlohmann/json/issues/2325)
- json.update and vector\<pair\>does not work with ordered\_json [\#2315](https://github.com/nlohmann/json/issues/2315)
- Ambiguous call to overloaded function [\#2210](https://github.com/nlohmann/json/issues/2210)

- Fix fallthrough warning [\#2333](https://github.com/nlohmann/json/pull/2333) ([nlohmann](https://github.com/nlohmann))
- Fix lexer to properly cope with repeated comments [\#2332](https://github.com/nlohmann/json/pull/2332) ([nlohmann](https://github.com/nlohmann))
- Fix name of Homebrew formula in documentation [\#2327](https://github.com/nlohmann/json/pull/2327) ([nlohmann](https://github.com/nlohmann))
- fix typo [\#2320](https://github.com/nlohmann/json/pull/2320) ([wx257osn2](https://github.com/wx257osn2))
- Fix a bug due to missing overloads in ordered\_map container [\#2319](https://github.com/nlohmann/json/pull/2319) ([nlohmann](https://github.com/nlohmann))
- cmake: install pkg-config file relative to current\_binary\_dir [\#2318](https://github.com/nlohmann/json/pull/2318) ([eli-schwartz](https://github.com/eli-schwartz))
- Fixed installation of pkg-config file on other than Ubuntu [\#2314](https://github.com/nlohmann/json/pull/2314) ([xvitaly](https://github.com/xvitaly))

## [v3.9.0](https://github.com/nlohmann/json/releases/tag/v3.9.0) (2020-07-27)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.8.0...v3.9.0)

- Unknown Type Name clang error when using NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE [\#2313](https://github.com/nlohmann/json/issues/2313)
- Clang 10.0 / GCC 10.1 warnings on disabled exceptions [\#2304](https://github.com/nlohmann/json/issues/2304)
- Application stalls indefinitely with message byte size 10 [\#2293](https://github.com/nlohmann/json/issues/2293)
- linker error [\#2292](https://github.com/nlohmann/json/issues/2292)
- Add support for high-precision numbers in UBJSON encoding [\#2286](https://github.com/nlohmann/json/issues/2286)
- NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE fails if the length of the argument is 10 [\#2280](https://github.com/nlohmann/json/issues/2280)
- Custom types : MACRO expansion bug [\#2267](https://github.com/nlohmann/json/issues/2267)
- to/from\_json Failing To Convert String [\#2238](https://github.com/nlohmann/json/issues/2238)
- clang 9.0 report warning: unused type alias 'size\_type' \[-Wunused-local-typedef\] [\#2221](https://github.com/nlohmann/json/issues/2221)
- Enormous array created when working with map\<int,T\> [\#2220](https://github.com/nlohmann/json/issues/2220)
- Can I disable sorting of json values [\#2219](https://github.com/nlohmann/json/issues/2219)
- Getting Qt types to work [\#2217](https://github.com/nlohmann/json/issues/2217)
- Convert to Qt QVariant  [\#2216](https://github.com/nlohmann/json/issues/2216)
- How to custom serialize same data type of vector? [\#2215](https://github.com/nlohmann/json/issues/2215)
- json constructor does not support std::optional [\#2214](https://github.com/nlohmann/json/issues/2214)
- Failing to Parse Valid JSON [\#2209](https://github.com/nlohmann/json/issues/2209)
- \(De-\)Serialization of std::variant with namespaces [\#2208](https://github.com/nlohmann/json/issues/2208)
- Addint support for complex type [\#2207](https://github.com/nlohmann/json/issues/2207)
- array\_index possible out of range [\#2205](https://github.com/nlohmann/json/issues/2205)
- Object deserialized as array [\#2204](https://github.com/nlohmann/json/issues/2204)
- Sending to a function a reference to a sub-branch [\#2200](https://github.com/nlohmann/json/issues/2200)
- How to Serialize derived class to JSON object?  [\#2199](https://github.com/nlohmann/json/issues/2199)
- JSON incorrectly serialized [\#2198](https://github.com/nlohmann/json/issues/2198)
- Exception Unhandled out\_of\_range error [\#2197](https://github.com/nlohmann/json/issues/2197)
- msgpack serialisation : float is treated as 64bit float, not 32bit float. [\#2196](https://github.com/nlohmann/json/issues/2196)
- Is it possible to use compile-time type guarantees for JSON structures? [\#2195](https://github.com/nlohmann/json/issues/2195)
- Question : performance against python dict [\#2194](https://github.com/nlohmann/json/issues/2194)
- vs2017 compile error [\#2192](https://github.com/nlohmann/json/issues/2192)
- Check if a key exists [\#2191](https://github.com/nlohmann/json/issues/2191)
- Failed to run tests due to missing test data on builders without Internet access [\#2190](https://github.com/nlohmann/json/issues/2190)
- 3.8.0: unit-cbor.cpp test failures [\#2189](https://github.com/nlohmann/json/issues/2189)
- 'nlohmann/json.hpp' file not found [\#2188](https://github.com/nlohmann/json/issues/2188)
- How to send json data over the wire? [\#2185](https://github.com/nlohmann/json/issues/2185)
- Ubuntu 16 not supporting nlohmann/json? [\#2184](https://github.com/nlohmann/json/issues/2184)
- .get\<std::string\> causing emdash errors [\#2180](https://github.com/nlohmann/json/issues/2180)
- Object properties should not be re-sorted alphabetically [\#2179](https://github.com/nlohmann/json/issues/2179)
- Custom type registration : instrusive API [\#2175](https://github.com/nlohmann/json/issues/2175)
- Many version of the function "void to\_json\(json& j, const MyStruct& struct\)" [\#2171](https://github.com/nlohmann/json/issues/2171)
- How should strings be escaped? [\#2155](https://github.com/nlohmann/json/issues/2155)
- Adding a value to an existing json puts it at the beginning instead of the end [\#2149](https://github.com/nlohmann/json/issues/2149)
- The header file is big, can we use what we need. [\#2134](https://github.com/nlohmann/json/issues/2134)
- Changing the default format for unordered\_map \(or other set\) [\#2132](https://github.com/nlohmann/json/issues/2132)
- Getting size of deserialized bson document [\#2131](https://github.com/nlohmann/json/issues/2131)
- implicit conversion failure [\#2128](https://github.com/nlohmann/json/issues/2128)
- Error thrown when parsing in a subclass [\#2124](https://github.com/nlohmann/json/issues/2124)
- explicit conversion to string not considered for std::map keys in GCC8 [\#2096](https://github.com/nlohmann/json/issues/2096)
- Add support for JSONC [\#2061](https://github.com/nlohmann/json/issues/2061)
- Library provides template arg for string\_type but assumes std::string in some places [\#2059](https://github.com/nlohmann/json/issues/2059)
- incremental parsing with sax\_parser [\#2030](https://github.com/nlohmann/json/issues/2030)
- Question about flatten and unflatten [\#1989](https://github.com/nlohmann/json/issues/1989)
- CBOR parser doesn't skip tags [\#1968](https://github.com/nlohmann/json/issues/1968)
- Compilation failure using Clang on Windows [\#1898](https://github.com/nlohmann/json/issues/1898)
- Fail to build when including json.hpp as a system include [\#1818](https://github.com/nlohmann/json/issues/1818)
- Parsing string into json doesn't preserve the order correctly. [\#1817](https://github.com/nlohmann/json/issues/1817)
- \[C++17\] Allow std::optional to convert to nlohmann::json [\#1749](https://github.com/nlohmann/json/issues/1749)
- How can I save json object in file in order?  [\#1717](https://github.com/nlohmann/json/issues/1717)
- Support for Comments [\#1513](https://github.com/nlohmann/json/issues/1513)
- clang compiler: error : unknown type name 'not' [\#1119](https://github.com/nlohmann/json/issues/1119)
- dump\(\) without alphabetical order [\#1106](https://github.com/nlohmann/json/issues/1106)
- operator T\(\) considered harmful [\#958](https://github.com/nlohmann/json/issues/958)
- Order of the elements in JSON object [\#952](https://github.com/nlohmann/json/issues/952)
- How to prevent alphabetical sorting of data? [\#727](https://github.com/nlohmann/json/issues/727)
- Why is an object ordering values by Alphabetical Order?  [\#660](https://github.com/nlohmann/json/issues/660)
- Feature request: Comments [\#597](https://github.com/nlohmann/json/issues/597)
- Head Elements Sorting [\#543](https://github.com/nlohmann/json/issues/543)
- Automatic ordered JSON [\#424](https://github.com/nlohmann/json/issues/424)
- Support for comments. [\#376](https://github.com/nlohmann/json/issues/376)
- Optional comment support. [\#363](https://github.com/nlohmann/json/issues/363)
- Strip comments / Minify [\#294](https://github.com/nlohmann/json/issues/294)
- maintaining order of keys during iteration [\#106](https://github.com/nlohmann/json/issues/106)

- Update documentation [\#2312](https://github.com/nlohmann/json/pull/2312) ([nlohmann](https://github.com/nlohmann))
- Fix bug in CBOR tag handling [\#2308](https://github.com/nlohmann/json/pull/2308) ([nlohmann](https://github.com/nlohmann))
- added inline to NLOHMANN\_DEFINE\_TYPE\_NON\_INTRUSIVE macro [\#2306](https://github.com/nlohmann/json/pull/2306) ([jwittbrodt](https://github.com/jwittbrodt))
- fixes unused variable 'ex' for \#2304 [\#2305](https://github.com/nlohmann/json/pull/2305) ([AODQ](https://github.com/AODQ))
- Cleanup [\#2303](https://github.com/nlohmann/json/pull/2303) ([nlohmann](https://github.com/nlohmann))
- Add test with multiple translation units [\#2301](https://github.com/nlohmann/json/pull/2301) ([nlohmann](https://github.com/nlohmann))
- Merge GitHub actions [\#2300](https://github.com/nlohmann/json/pull/2300) ([nlohmann](https://github.com/nlohmann))
- Fix unused parameter [\#2299](https://github.com/nlohmann/json/pull/2299) ([nlohmann](https://github.com/nlohmann))
- Add support for high-precision numbers in UBJSON encoding [\#2297](https://github.com/nlohmann/json/pull/2297) ([nlohmann](https://github.com/nlohmann))
- fix eof for get\_binary and get\_string [\#2294](https://github.com/nlohmann/json/pull/2294) ([jprochazk](https://github.com/jprochazk))
- Serialisation macros: increase upper bound on number of member variables [\#2287](https://github.com/nlohmann/json/pull/2287) ([pfeatherstone](https://github.com/pfeatherstone))
- add inline specifier for detail::combine [\#2285](https://github.com/nlohmann/json/pull/2285) ([T0b1-iOS](https://github.com/T0b1-iOS))
- Add static assertion for missing binary function in SAX interface [\#2282](https://github.com/nlohmann/json/pull/2282) ([nlohmann](https://github.com/nlohmann))
- Add test for target\_include\_directories [\#2279](https://github.com/nlohmann/json/pull/2279) ([nlohmann](https://github.com/nlohmann))
- Clean up maintainer Makefiles and fix some linter warnings [\#2274](https://github.com/nlohmann/json/pull/2274) ([nlohmann](https://github.com/nlohmann))
- Add option to ignore CBOR tags [\#2273](https://github.com/nlohmann/json/pull/2273) ([nlohmann](https://github.com/nlohmann))
- Hash function without allocation [\#2269](https://github.com/nlohmann/json/pull/2269) ([nlohmann](https://github.com/nlohmann))
- Add ClangCL for MSVC [\#2268](https://github.com/nlohmann/json/pull/2268) ([t-b](https://github.com/t-b))
- Makefile: Always use SED variable [\#2264](https://github.com/nlohmann/json/pull/2264) ([t-b](https://github.com/t-b))
- Add Xcode 12 CI [\#2262](https://github.com/nlohmann/json/pull/2262) ([nlohmann](https://github.com/nlohmann))
- Make library work with Clang on Windows [\#2259](https://github.com/nlohmann/json/pull/2259) ([nlohmann](https://github.com/nlohmann))
- Add ordered\_json specialization with ordered object keys [\#2258](https://github.com/nlohmann/json/pull/2258) ([nlohmann](https://github.com/nlohmann))
- Add pkg-config file [\#2253](https://github.com/nlohmann/json/pull/2253) ([ericonr](https://github.com/ericonr))
- Fix regression from \#2181 [\#2251](https://github.com/nlohmann/json/pull/2251) ([nlohmann](https://github.com/nlohmann))
- Tag binary values in cbor if set [\#2244](https://github.com/nlohmann/json/pull/2244) ([matthewbauer](https://github.com/matthewbauer))
- Make assert configurable via JSON\_ASSERT [\#2242](https://github.com/nlohmann/json/pull/2242) ([nlohmann](https://github.com/nlohmann))
- Add specialization of get\_to [\#2233](https://github.com/nlohmann/json/pull/2233) ([nlohmann](https://github.com/nlohmann))
- Refine documentation of error\_handler parameter [\#2232](https://github.com/nlohmann/json/pull/2232) ([nlohmann](https://github.com/nlohmann))
- Simplify conversion from/to custom types [\#2225](https://github.com/nlohmann/json/pull/2225) ([nlohmann](https://github.com/nlohmann))
- Remove unused typedefs [\#2224](https://github.com/nlohmann/json/pull/2224) ([nlohmann](https://github.com/nlohmann))
- Enable CMake policy CMP0077 [\#2222](https://github.com/nlohmann/json/pull/2222) ([alexreinking](https://github.com/alexreinking))
- Add option to ignore comments in parse/accept functions [\#2212](https://github.com/nlohmann/json/pull/2212) ([nlohmann](https://github.com/nlohmann))
- Fix Clang-Tidy warnings [\#2211](https://github.com/nlohmann/json/pull/2211) ([nlohmann](https://github.com/nlohmann))
- Simple ordered\_json that works on all supported compilers [\#2206](https://github.com/nlohmann/json/pull/2206) ([gatopeich](https://github.com/gatopeich))
- Use unsigned indizies for array index in json pointer [\#2203](https://github.com/nlohmann/json/pull/2203) ([t-b](https://github.com/t-b))
- Add option to not rely on Internet connectivity during test stage [\#2202](https://github.com/nlohmann/json/pull/2202) ([nlohmann](https://github.com/nlohmann))
- Serialize floating-point numbers with 32 bit when possible \(MessagePack\) [\#2201](https://github.com/nlohmann/json/pull/2201) ([nlohmann](https://github.com/nlohmann))
- Fix consistency in function `int_to_string()` [\#2193](https://github.com/nlohmann/json/pull/2193) ([dota17](https://github.com/dota17))
- Fix issue\#1275 [\#2181](https://github.com/nlohmann/json/pull/2181) ([dota17](https://github.com/dota17))
- C++20 support by removing swap specialization [\#2176](https://github.com/nlohmann/json/pull/2176) ([gracicot](https://github.com/gracicot))
- Feat/explicit conversion operator [\#1559](https://github.com/nlohmann/json/pull/1559) ([theodelrieu](https://github.com/theodelrieu))

## [v3.8.0](https://github.com/nlohmann/json/releases/tag/v3.8.0) (2020-06-14)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.7.3...v3.8.0)

- sorry delete this issue, i'm stupid [\#2187](https://github.com/nlohmann/json/issues/2187)
- Append to a std::nlohmann::json type [\#2186](https://github.com/nlohmann/json/issues/2186)
- Some troubles to compile the last revision [\#2177](https://github.com/nlohmann/json/issues/2177)
- ​\#​ Top level CMakeLists.txt​
​project​\(FOO\)
...
​option​\(FOO\_USE\_EXTERNAL\_JSON ​"Use an external JSON library"​ ​OFF​\)
...
​add\_subdirectory​\(thirdparty\)
...
​add\_library​\(foo ...\)
...
​\#​ Note that the namespaced target will always be available regardless of the​
​\#​ import method​
​target\_link\_libraries​\(foo ​PRIVATE​ nlohmann\_json::nlohmann\_json\) [\#2170](https://github.com/nlohmann/json/issues/2170)
- https://www.github.com/nlohmann/json/tree/develop/include%2Fnlohmann%2Fjson\_fwd.hpp [\#2169](https://github.com/nlohmann/json/issues/2169)
- templated from\_json of non primitive types causes gcc error [\#2168](https://github.com/nlohmann/json/issues/2168)
- few warnings/errors in copy assignment [\#2167](https://github.com/nlohmann/json/issues/2167)
- Different output when upgrading from clang 9 to clang 10 [\#2166](https://github.com/nlohmann/json/issues/2166)
- Cannot build with VS 2019 / C++17 [\#2163](https://github.com/nlohmann/json/issues/2163)
- Q: When I received an illegal string,How the program knows? [\#2162](https://github.com/nlohmann/json/issues/2162)
- Problem while reading a json file [\#2161](https://github.com/nlohmann/json/issues/2161)
- converting std::chrono::system\_clock::time\_point to json. [\#2159](https://github.com/nlohmann/json/issues/2159)
-  how to parse vector\<struct\> format [\#2157](https://github.com/nlohmann/json/issues/2157)
- nlohmann::json and =nullptr [\#2156](https://github.com/nlohmann/json/issues/2156)
- test-cbor fails [\#2154](https://github.com/nlohmann/json/issues/2154)
- Accessing array inside array syntax?  [\#2151](https://github.com/nlohmann/json/issues/2151)
- Best way to catch errors when querying json [\#2150](https://github.com/nlohmann/json/issues/2150)
- JSON Data Mapping Key-Value from other Key-Value [\#2148](https://github.com/nlohmann/json/issues/2148)
- Conflicts with std \<any\> compiling with GCC 10 [\#2146](https://github.com/nlohmann/json/issues/2146)
- Incorrect CMake FetchContent example [\#2142](https://github.com/nlohmann/json/issues/2142)
- Help for a Beginner? [\#2141](https://github.com/nlohmann/json/issues/2141)
- Read Json from File [\#2139](https://github.com/nlohmann/json/issues/2139)
- How to feed a predefined integer value into json string [\#2138](https://github.com/nlohmann/json/issues/2138)
- getting json array inside json object [\#2135](https://github.com/nlohmann/json/issues/2135)
- Add .contains example to doc [\#2133](https://github.com/nlohmann/json/issues/2133)
- Is it safe to return string.c\_str\(\) received from get\(\)? [\#2130](https://github.com/nlohmann/json/issues/2130)
- GCC 10: Compilation error when including any before including json header in C++17 mode [\#2129](https://github.com/nlohmann/json/issues/2129)
- Intersection of two json files [\#2127](https://github.com/nlohmann/json/issues/2127)
- App crashes when dump method called for non ascii chars. [\#2126](https://github.com/nlohmann/json/issues/2126)
- iterator based erase method [\#2122](https://github.com/nlohmann/json/issues/2122)
- quick and convenient api to get/set nested json values [\#2120](https://github.com/nlohmann/json/issues/2120)
- assigning nullptr to std::string [\#2118](https://github.com/nlohmann/json/issues/2118)
- usless\_cast warnings with gcc 9.3 and 10.1 \(C++17\) [\#2114](https://github.com/nlohmann/json/issues/2114)
- clang 10 warning [\#2113](https://github.com/nlohmann/json/issues/2113)
- Possible incorrect \_MSC\_VER reference [\#2112](https://github.com/nlohmann/json/issues/2112)
- warning under gcc 10.1 [\#2110](https://github.com/nlohmann/json/issues/2110)
- Wdeprecated-declarations from GCC v10.1.0 [\#2109](https://github.com/nlohmann/json/issues/2109)
- Global std::vector from json [\#2108](https://github.com/nlohmann/json/issues/2108)
- heap-buffer-overflow when using nlohmann/json, ASAN, and gtest [\#2107](https://github.com/nlohmann/json/issues/2107)
- exception 0x770DC5AF when i read an special char in json file [\#2106](https://github.com/nlohmann/json/issues/2106)
- json::parse\(\) fails to parse a dump\(2,' '\) output, yet does successfully parse dump\(\) [\#2105](https://github.com/nlohmann/json/issues/2105)
- run test-udt error  in MSVC 19.16.27034.0 [\#2103](https://github.com/nlohmann/json/issues/2103)
- Unable to dump to stringstream [\#2102](https://github.com/nlohmann/json/issues/2102)
- Can't ad an object in another objet [\#2101](https://github.com/nlohmann/json/issues/2101)
- Implicit conversion causes "cannot use operator\[\] with a string argument with string" [\#2098](https://github.com/nlohmann/json/issues/2098)
- C++20: char8\_t [\#2097](https://github.com/nlohmann/json/issues/2097)
- Compilation issues when included in project [\#2094](https://github.com/nlohmann/json/issues/2094)
- string value with null character causes infinite loop [\#2093](https://github.com/nlohmann/json/issues/2093)
- corrupted size vs. prev\_size \(aborted\) [\#2092](https://github.com/nlohmann/json/issues/2092)
- Get string field content without return std::string copy  [\#2091](https://github.com/nlohmann/json/issues/2091)
- JSON Comments \(JSON 5\) [\#2090](https://github.com/nlohmann/json/issues/2090)
- Remove \#include \<ciso646\> [\#2089](https://github.com/nlohmann/json/issues/2089)
- JSON library as a git submodule [\#2088](https://github.com/nlohmann/json/issues/2088)
- Apple Clang 11.0.3 on MacOS Catalina 10.15.4 not compiling [\#2087](https://github.com/nlohmann/json/issues/2087)
- Value function return empty object even if it exist [\#2086](https://github.com/nlohmann/json/issues/2086)
- Cannot debug but Run works [\#2085](https://github.com/nlohmann/json/issues/2085)
- Question about serialization. [\#2084](https://github.com/nlohmann/json/issues/2084)
- How to include in an external project [\#2083](https://github.com/nlohmann/json/issues/2083)
- Missing tests for binary values [\#2082](https://github.com/nlohmann/json/issues/2082)
- How to override default string serialization? [\#2079](https://github.com/nlohmann/json/issues/2079)
- Can't have a json type as a property in an arbitrary type [\#2078](https://github.com/nlohmann/json/issues/2078)
- New release? [\#2075](https://github.com/nlohmann/json/issues/2075)
- CMake FetchContent \> Updating the documentation? [\#2073](https://github.com/nlohmann/json/issues/2073)
- How to convert STL Vector \(of user defined type\) to Json [\#2072](https://github.com/nlohmann/json/issues/2072)
- how to make an array of objects [\#2070](https://github.com/nlohmann/json/issues/2070)
- ‘\_\_int64’ was not declared [\#2068](https://github.com/nlohmann/json/issues/2068)
- \[json.exception.type\_error.317\] cannot serialize binary data to text JSON [\#2067](https://github.com/nlohmann/json/issues/2067)
- Unexpected end of input; expected '\[', '{', or a literal [\#2066](https://github.com/nlohmann/json/issues/2066)
- Json structure can be nested? [\#2065](https://github.com/nlohmann/json/issues/2065)
- Bug: returning reference to local temporary object [\#2064](https://github.com/nlohmann/json/issues/2064)
- Allow to use non strict parsing [\#2063](https://github.com/nlohmann/json/issues/2063)
- Crashing on json::at [\#2062](https://github.com/nlohmann/json/issues/2062)
- How to convert a const std::vector\<char8\_t\> message to a json, to be able to parse it and extract information from it? Can you point to any examples? [\#2058](https://github.com/nlohmann/json/issues/2058)
- Nice library [\#2057](https://github.com/nlohmann/json/issues/2057)
- json.hpp:15372:22: error: expected unqualified-id if \(not std::isfinite\(x\)\): Started getting this bug after updating my XCode [\#2056](https://github.com/nlohmann/json/issues/2056)
- Confused as how I can extract the values from the JSON object. [\#2055](https://github.com/nlohmann/json/issues/2055)
- Warnings with GCC 10 [\#2052](https://github.com/nlohmann/json/issues/2052)
- Warnings with Clang 10 [\#2049](https://github.com/nlohmann/json/issues/2049)
- Update doctest [\#2048](https://github.com/nlohmann/json/issues/2048)
- Unclear error message: "cannot use operator\[\] with a string argument with array" [\#2047](https://github.com/nlohmann/json/issues/2047)
- Serializing std::variant\<T, std::vector\<T\>\> [\#2045](https://github.com/nlohmann/json/issues/2045)
- Crash when parse big jsonfile [\#2042](https://github.com/nlohmann/json/issues/2042)
- How to check if a key exists without silently generating null objects on the path [\#2041](https://github.com/nlohmann/json/issues/2041)
- Crash when traversing over items\(\) of temporary json objects [\#2040](https://github.com/nlohmann/json/issues/2040)
- How to parse multiple line value ? [\#2039](https://github.com/nlohmann/json/issues/2039)
- SAX API uses unsigned std::size\_t but  -1 if element size is not known; [\#2037](https://github.com/nlohmann/json/issues/2037)
- How to parse big decimal data [\#2036](https://github.com/nlohmann/json/issues/2036)
- how use   template \<typename T\> struct adl\_serializer  [\#2035](https://github.com/nlohmann/json/issues/2035)
- auto iterator returned by find to handle value depending if is string or numeric. [\#2032](https://github.com/nlohmann/json/issues/2032)
- pass find returned iterator to numeric variable. [\#2031](https://github.com/nlohmann/json/issues/2031)
- Parse error on valid json file [\#2029](https://github.com/nlohmann/json/issues/2029)
- Is here any elegant way to combine serialization and deserialization code? [\#2028](https://github.com/nlohmann/json/issues/2028)
- Notes about dump function [\#2027](https://github.com/nlohmann/json/issues/2027)
- Different JSON printouts for empty dictionary on Linux and Mac. [\#2026](https://github.com/nlohmann/json/issues/2026)
- easier way to get exception reason out of json\_sax\_dom\_callback\_parser without exceptions [\#2024](https://github.com/nlohmann/json/issues/2024)
- Using fifo\_map with base class and derived class [\#2023](https://github.com/nlohmann/json/issues/2023)
- Error reading JSON File  [\#2022](https://github.com/nlohmann/json/issues/2022)
- Parse causing crash on android.  Cannot catch. [\#2021](https://github.com/nlohmann/json/issues/2021)
- Extra backslashes in nested json [\#2020](https://github.com/nlohmann/json/issues/2020)
- How to create patch for merge\_patch input ? [\#2018](https://github.com/nlohmann/json/issues/2018)
- CppUTest/include/CppUTestExt/MockSupport.h:40: error: default argument for ‘MockFailureReporter\* failureReporterForThisCall’ has type ‘void\*’ [\#2017](https://github.com/nlohmann/json/issues/2017)
- including another file [\#2016](https://github.com/nlohmann/json/issues/2016)
- GNU PREREQ Error with gcc 9.3.0 [\#2015](https://github.com/nlohmann/json/issues/2015)
- Parse error: json.exception.parse\_error.101 - invalid string: ill-formed UTF-8 byte [\#2014](https://github.com/nlohmann/json/issues/2014)
- Add more flexibility to basic\_json's ObjectType \(and ArrayType\) [\#2013](https://github.com/nlohmann/json/issues/2013)
- afl persistent mode [\#2012](https://github.com/nlohmann/json/issues/2012)
- Compiler Errors under VS2019 in Appveyor CI [\#2009](https://github.com/nlohmann/json/issues/2009)
- Another compilation failure with Visual Studio [\#2007](https://github.com/nlohmann/json/issues/2007)
- Implicit cast to std::string broken again with VS2019 16.5.0 [\#2006](https://github.com/nlohmann/json/issues/2006)
- error: no matching member function for call to 'AddRaw' [\#2005](https://github.com/nlohmann/json/issues/2005)
- When I re-create an object again after the network request, an error is reported [\#2003](https://github.com/nlohmann/json/issues/2003)
- How to merge \(and not replace\) different Json::Value objects in jsoncpp [\#2001](https://github.com/nlohmann/json/issues/2001)
- scalar transforms to list [\#2000](https://github.com/nlohmann/json/issues/2000)
- Dump JSON containing multibyte characters [\#1999](https://github.com/nlohmann/json/issues/1999)
- Build error  when modify value [\#1998](https://github.com/nlohmann/json/issues/1998)
- How do i include a vector of pointers in my json? [\#1997](https://github.com/nlohmann/json/issues/1997)
- Compiler error wrt incomplete types changed in gcc8.3.0-26 [\#1996](https://github.com/nlohmann/json/issues/1996)
- NaN-like comparison behavior of discarded is inconvenient [\#1988](https://github.com/nlohmann/json/issues/1988)
- Maintaining JSON package in my CMake [\#1987](https://github.com/nlohmann/json/issues/1987)
- reading int number and string number [\#1986](https://github.com/nlohmann/json/issues/1986)
- Build error: keyword is hidden by macro definition! [\#1985](https://github.com/nlohmann/json/issues/1985)
- JSON patch diff for op=add formation is not as per standard \(RFC 6902\) [\#1983](https://github.com/nlohmann/json/issues/1983)
- json\_pointer.contains\(\) exception is incorrectly raised [\#1982](https://github.com/nlohmann/json/issues/1982)
- Error with non existing key [\#1981](https://github.com/nlohmann/json/issues/1981)
- Closed [\#1978](https://github.com/nlohmann/json/issues/1978)
- Where is the library built and what is the name? [\#1977](https://github.com/nlohmann/json/issues/1977)
- The cmake\_import example does not build [\#1976](https://github.com/nlohmann/json/issues/1976)
- Dumping core when reading invalid file [\#1975](https://github.com/nlohmann/json/issues/1975)
- Abort in dump\(\) method [\#1973](https://github.com/nlohmann/json/issues/1973)
- Unclear docs regarding parser\_callback\_t callbacks [\#1972](https://github.com/nlohmann/json/issues/1972)
- Possible memory leak on push\_back [\#1971](https://github.com/nlohmann/json/issues/1971)
- Is it possible to get a safe mutable reference/pointer to internal variant used in nlohmann json?  [\#1970](https://github.com/nlohmann/json/issues/1970)
- Getting a flatten json to map\<string, string\> [\#1957](https://github.com/nlohmann/json/issues/1957)
- forced type conversion or lexical cast without exception. [\#1955](https://github.com/nlohmann/json/issues/1955)
- Add json\_view type support to avoid excessive copying [\#1954](https://github.com/nlohmann/json/issues/1954)
- Adding "examples" section for real-life usages [\#1953](https://github.com/nlohmann/json/issues/1953)
- Add nlohmann::json::key\_type [\#1951](https://github.com/nlohmann/json/issues/1951)
- cannot use operator\[\] with a string argument with string [\#1949](https://github.com/nlohmann/json/issues/1949)
- std::ifstream \>\> json error [\#1948](https://github.com/nlohmann/json/issues/1948)
- Cannot update json data in an iterator? [\#1947](https://github.com/nlohmann/json/issues/1947)
- How can i build this library in VS 2017? [\#1943](https://github.com/nlohmann/json/issues/1943)
- json\_pointer.contains\(\) exceptions when path not found [\#1942](https://github.com/nlohmann/json/issues/1942)
- Nested objects serialize/deserialize [\#1941](https://github.com/nlohmann/json/issues/1941)
- Compile warning on architectures that are not x86 [\#1939](https://github.com/nlohmann/json/issues/1939)
- Version of nlohmann-json-dev in debian packages [\#1938](https://github.com/nlohmann/json/issues/1938)
- Create a json object for every cycle  [\#1937](https://github.com/nlohmann/json/issues/1937)
- How to get the object name? [\#1936](https://github.com/nlohmann/json/issues/1936)
- Reserve and resize function for basic json [\#1935](https://github.com/nlohmann/json/issues/1935)
- How to use json parse in tsl::ordread\_map? [\#1934](https://github.com/nlohmann/json/issues/1934)
- C++14 support is not enabled with msvc2015 [\#1932](https://github.com/nlohmann/json/issues/1932)
- Need help with to\_json for derived class, keep getting "cannot use operator" [\#1931](https://github.com/nlohmann/json/issues/1931)
- How to handle std::vector\<std::uint8\_t\> [\#1930](https://github.com/nlohmann/json/issues/1930)
- Heap corruption issue [\#1929](https://github.com/nlohmann/json/issues/1929)
- Add `std::wistream` support. [\#1928](https://github.com/nlohmann/json/issues/1928)
- This i can write and read any file thanks [\#1927](https://github.com/nlohmann/json/issues/1927)
- How can I get this simple example working? [\#1926](https://github.com/nlohmann/json/issues/1926)
- emplace\_back does not seems to work with the int 0 [\#1925](https://github.com/nlohmann/json/issues/1925)
- Why nlohmann does not release memory [\#1924](https://github.com/nlohmann/json/issues/1924)
- Is it possible to have template `json::parse` with `noexcept` specifier? [\#1922](https://github.com/nlohmann/json/issues/1922)
- JSON to wstring? [\#1921](https://github.com/nlohmann/json/issues/1921)
- GCC 10 tests build failure [\#1920](https://github.com/nlohmann/json/issues/1920)
- Size of binary json representations [\#1919](https://github.com/nlohmann/json/issues/1919)
- Accessing strings \(for example in keys or values\) without having the lib create a copy of it. [\#1916](https://github.com/nlohmann/json/issues/1916)
- operator== documentation should show how to apply custom comparison function [\#1915](https://github.com/nlohmann/json/issues/1915)
- char8\_t and std::u8string support [\#1914](https://github.com/nlohmann/json/issues/1914)
- std::is\_pod is deprecated in C++20 [\#1913](https://github.com/nlohmann/json/issues/1913)
- Incomplete types reported by \(experimental\) GCC10 [\#1912](https://github.com/nlohmann/json/issues/1912)
- Compile warnings on MSVC 14.2 [\#1911](https://github.com/nlohmann/json/issues/1911)
- How to parse json file with   type composition  of std::optional  and std::variant [\#1910](https://github.com/nlohmann/json/issues/1910)
- why root\_schema be  implemented as unique\_ptr in json-validator.cpp，could I use it as shared\_ptr? [\#1908](https://github.com/nlohmann/json/issues/1908)
- compile error in gcc-6.3.0 [\#1906](https://github.com/nlohmann/json/issues/1906)
- Scalar constexpr is odr-used when used as json initializer [\#1905](https://github.com/nlohmann/json/issues/1905)
- install Slack app [\#1904](https://github.com/nlohmann/json/issues/1904)
- typo in a comment [\#1903](https://github.com/nlohmann/json/issues/1903)
- Watch JSON variables in Debug [\#1902](https://github.com/nlohmann/json/issues/1902)
- does Json sdk cares about dfc dfd utf8 issue? [\#1901](https://github.com/nlohmann/json/issues/1901)
- Allow multiple line string value in JSON [\#1897](https://github.com/nlohmann/json/issues/1897)
- Writing map to json file  [\#1896](https://github.com/nlohmann/json/issues/1896)
- Small documentation mistake [\#1895](https://github.com/nlohmann/json/issues/1895)
- why static function `parse` cann't find in visual studio 2019 [\#1894](https://github.com/nlohmann/json/issues/1894)
- Best way to handle json files with missing key value pairs. [\#1893](https://github.com/nlohmann/json/issues/1893)
- accessing json object as multimap [\#1892](https://github.com/nlohmann/json/issues/1892)
- What is the best way to parse vec3s into glm::vec3 [\#1891](https://github.com/nlohmann/json/issues/1891)
- Get array of items without using vector [\#1890](https://github.com/nlohmann/json/issues/1890)
- Build errors \(clang 11.0.0\) on macOS 10.15.2 [\#1889](https://github.com/nlohmann/json/issues/1889)
- Multiple arrays to vectors help [\#1888](https://github.com/nlohmann/json/issues/1888)
- json::parse\(begin, end\) parse error on first character using uchar\* [\#1887](https://github.com/nlohmann/json/issues/1887)
- issue in free\(\) [\#1886](https://github.com/nlohmann/json/issues/1886)
- is\_number\_unsigned\(\) returns false for positive integers \(int or 0 or 1 literals\) [\#1885](https://github.com/nlohmann/json/issues/1885)
- MSVC build failure with /Zc:\_\_cplusplus and C++17 [\#1883](https://github.com/nlohmann/json/issues/1883)
- RFC 6901 op:replace & arrays [\#1882](https://github.com/nlohmann/json/issues/1882)
- Problem with serialization of my custom template doubly-linked list [\#1881](https://github.com/nlohmann/json/issues/1881)
- is\_array\(\) is True, but raise 'cannot use operator\[\] for object iterators' [\#1880](https://github.com/nlohmann/json/issues/1880)
- Serialize dynamic array [\#1879](https://github.com/nlohmann/json/issues/1879)
- Serialization of struct object. [\#1877](https://github.com/nlohmann/json/issues/1877)
- warning:c4503 [\#1875](https://github.com/nlohmann/json/issues/1875)
- Why are flattened empty objects/arrays not representable? [\#1874](https://github.com/nlohmann/json/issues/1874)
- Container Overflow \(ASAN\) when using operator \>\> on an ifs [\#1873](https://github.com/nlohmann/json/issues/1873)
- Sub-array to vector or map object? [\#1870](https://github.com/nlohmann/json/issues/1870)
- WIP: QT \(cute\) type supports [\#1869](https://github.com/nlohmann/json/issues/1869)
- Compiler flags to disable features and shrink code size [\#1868](https://github.com/nlohmann/json/issues/1868)
- null strings [\#1867](https://github.com/nlohmann/json/issues/1867)
- Struct with array of struct and \_\_attribute\_\_\(\(packed\)\) [\#1866](https://github.com/nlohmann/json/issues/1866)
- Best way to extract numbers in the string? [\#1865](https://github.com/nlohmann/json/issues/1865)
- Displaying \\?\Volume{guid} from string to json giving error [\#1864](https://github.com/nlohmann/json/issues/1864)
- not working when compiling as x86 [\#1863](https://github.com/nlohmann/json/issues/1863)
- Skipping evaluation of log line expressions with a macro, is it possible? [\#1862](https://github.com/nlohmann/json/issues/1862)
- Suppress warnings [\#1861](https://github.com/nlohmann/json/issues/1861)
- conflit with g++ compile option -mwindows [\#1860](https://github.com/nlohmann/json/issues/1860)
- How to serialize nested classes to semi-flat JSON object? [\#1859](https://github.com/nlohmann/json/issues/1859)
- Memory Requirement for large json file [\#1858](https://github.com/nlohmann/json/issues/1858)
- Query a binary format \(BSON, CBOR, MessagePack, UBJSON\) [\#1856](https://github.com/nlohmann/json/issues/1856)
- Documentation on operator\[\] behavior with missing keys [\#1855](https://github.com/nlohmann/json/issues/1855)
- Problem in converting string into JSON; Can't parse successfully. [\#1854](https://github.com/nlohmann/json/issues/1854)
- json.at\_or\_default\(key, defaultval\) [\#1852](https://github.com/nlohmann/json/issues/1852)
- please improve the enum conversion documentation \(my example gist provided\) [\#1851](https://github.com/nlohmann/json/issues/1851)
- Default value returned on ValueType nlohmann::basic\_json::value \(const typename object\_t::key\_type& key, const ValueType& default\_value\) 	 [\#1850](https://github.com/nlohmann/json/issues/1850)
- Accounting for arbitrary precision numerical literals [\#1849](https://github.com/nlohmann/json/issues/1849)
- While trying to make a simple array, I get a nested array instead [\#1848](https://github.com/nlohmann/json/issues/1848)
- How to reuse the parser and serializer intermediate storage? [\#1847](https://github.com/nlohmann/json/issues/1847)
- Too much content in json.hpp leads to slow compilation [\#1845](https://github.com/nlohmann/json/issues/1845)
- Cannot read some data in json file [\#1843](https://github.com/nlohmann/json/issues/1843)
- Precompiled JSON library? [\#1842](https://github.com/nlohmann/json/issues/1842)
- Please change assert into throw\(maybe\) in line 17946 [\#1841](https://github.com/nlohmann/json/issues/1841)
- JSON for modern C++ ECCN information [\#1840](https://github.com/nlohmann/json/issues/1840)
- CI: reduce build time for Travis valgrind [\#1836](https://github.com/nlohmann/json/issues/1836)
- How do I traverse a json object and add new elements into the hierarchy [\#1834](https://github.com/nlohmann/json/issues/1834)
- Invalid UTF-8 byte at index 1: 0x65 [\#1831](https://github.com/nlohmann/json/issues/1831)
- Serialize big data in json [\#1828](https://github.com/nlohmann/json/issues/1828)
- Backslash '\' in value causes exception [\#1827](https://github.com/nlohmann/json/issues/1827)
- from\_json for non default constructible class with dependency injection [\#1819](https://github.com/nlohmann/json/issues/1819)
- Semi-frequent timeouts in `test-unicode_all` with 3.6.1 \(aarch64\) [\#1816](https://github.com/nlohmann/json/issues/1816)
- input\_adapter not user extensible [\#1813](https://github.com/nlohmann/json/issues/1813)
- crash at json::destroy on android  [\#1812](https://github.com/nlohmann/json/issues/1812)
- Logs are repeating while cmake [\#1809](https://github.com/nlohmann/json/issues/1809)
- Add a the possibility to add dynamic json objects [\#1795](https://github.com/nlohmann/json/issues/1795)
- Unnecessary test data file in the release [\#1790](https://github.com/nlohmann/json/issues/1790)
- Add support for parse stack limiting [\#1788](https://github.com/nlohmann/json/issues/1788)
- GCC -Wuseless-cast warnings [\#1777](https://github.com/nlohmann/json/issues/1777)
- compilation issue with NVCC 9.0 [\#1773](https://github.com/nlohmann/json/issues/1773)
- Unexpected behavior with fifo\_map json when copy and append  [\#1763](https://github.com/nlohmann/json/issues/1763)
- Parse error [\#1761](https://github.com/nlohmann/json/issues/1761)
- Assignment \(using value\(\)\) to nonexistent element behaves differently on Xcode 8 vs Xcode 10 [\#1758](https://github.com/nlohmann/json/issues/1758)
- Readme out of date [\#1756](https://github.com/nlohmann/json/issues/1756)
- cmake\_\* tests don't use the build system's compiler [\#1747](https://github.com/nlohmann/json/issues/1747)
- Static assertions for template type properties required [\#1729](https://github.com/nlohmann/json/issues/1729)
- Use float and possibly half in json::to\_cbor [\#1719](https://github.com/nlohmann/json/issues/1719)
- json::from\_cbor does not respect allow\_exceptions = false when input is string literal [\#1715](https://github.com/nlohmann/json/issues/1715)
- /Zc:\_\_cplusplus leads to C2416 [\#1695](https://github.com/nlohmann/json/issues/1695)
- `unflatten` vs objects with number-ish keys [\#1575](https://github.com/nlohmann/json/issues/1575)
- A "thinner" source code tar as part of release? [\#1572](https://github.com/nlohmann/json/issues/1572)
- Repository is almost 450MB [\#1497](https://github.com/nlohmann/json/issues/1497)
- Substantial performance penalty caused by polymorphic input adapter  [\#1457](https://github.com/nlohmann/json/issues/1457)
- Move tests to a separate repo [\#1235](https://github.com/nlohmann/json/issues/1235)
- reduce repos size [\#1185](https://github.com/nlohmann/json/issues/1185)
- CMakeLists.txt in release zips? [\#1184](https://github.com/nlohmann/json/issues/1184)
- Minimal branch? [\#1066](https://github.com/nlohmann/json/issues/1066)
- Move test blobs to a submodule? [\#732](https://github.com/nlohmann/json/issues/732)
- \[Question\] When using this as git submodule, will it clone the whole thing include test data and benchmark? [\#620](https://github.com/nlohmann/json/issues/620)
- Need to improve ignores.. [\#567](https://github.com/nlohmann/json/issues/567)
- Minimal repository \(current size very large\) [\#556](https://github.com/nlohmann/json/issues/556)
- For a header-only library you have to clone 214MB [\#482](https://github.com/nlohmann/json/issues/482)
- 17 MB / 90 MB repo size!? [\#96](https://github.com/nlohmann/json/issues/96)

- Improve parse\_ubjson\_fuzzer [\#2182](https://github.com/nlohmann/json/pull/2182) ([tanuj208](https://github.com/tanuj208))
- Add input adapter tests [\#2178](https://github.com/nlohmann/json/pull/2178) ([nlohmann](https://github.com/nlohmann))
- Fix warnings [\#2174](https://github.com/nlohmann/json/pull/2174) ([nlohmann](https://github.com/nlohmann))
- Fix PR\#1006 [\#2158](https://github.com/nlohmann/json/pull/2158) ([dota17](https://github.com/dota17))
- Fix issue\#1972 [\#2153](https://github.com/nlohmann/json/pull/2153) ([dota17](https://github.com/dota17))
- Update URLs to HTTPS [\#2152](https://github.com/nlohmann/json/pull/2152) ([TotalCaesar659](https://github.com/TotalCaesar659))
- Fix Issue\#1813: user defined input adapters [\#2145](https://github.com/nlohmann/json/pull/2145) ([FrancoisChabot](https://github.com/FrancoisChabot))
- Fix issue\#1939: Cast character to unsigned for comparison [\#2144](https://github.com/nlohmann/json/pull/2144) ([XyFreak](https://github.com/XyFreak))
- Fix issue\#2142: readme: fix typo in CMake FetchContent example [\#2143](https://github.com/nlohmann/json/pull/2143) ([quentin-dev](https://github.com/quentin-dev))
- Respect allow\_exceptions=false for binary formats [\#2140](https://github.com/nlohmann/json/pull/2140) ([nlohmann](https://github.com/nlohmann))
- Fix issue 2112 [\#2137](https://github.com/nlohmann/json/pull/2137) ([dota17](https://github.com/dota17))
- Add bleeding edge GCC to CI [\#2136](https://github.com/nlohmann/json/pull/2136) ([aokellermann](https://github.com/aokellermann))
- Clean up implementation of binary type [\#2125](https://github.com/nlohmann/json/pull/2125) ([nlohmann](https://github.com/nlohmann))
- Fixed a compilation error in MSVC [\#2121](https://github.com/nlohmann/json/pull/2121) ([gistrec](https://github.com/gistrec))
- Overwork CI [\#2119](https://github.com/nlohmann/json/pull/2119) ([nlohmann](https://github.com/nlohmann))
- Fix warnings from Clang 10 and GCC 9 [\#2116](https://github.com/nlohmann/json/pull/2116) ([nlohmann](https://github.com/nlohmann))
- Do not include \<ciso646\> when using C++17 [\#2115](https://github.com/nlohmann/json/pull/2115) ([nlohmann](https://github.com/nlohmann))
- Fix issue\#2086: disallow json::value\_t type parameter in value\(\) [\#2104](https://github.com/nlohmann/json/pull/2104) ([dota17](https://github.com/dota17))
- Fix Coveralls integration [\#2100](https://github.com/nlohmann/json/pull/2100) ([nlohmann](https://github.com/nlohmann))
- Add tests for binary values [\#2099](https://github.com/nlohmann/json/pull/2099) ([nlohmann](https://github.com/nlohmann))
- Use external test data [\#2081](https://github.com/nlohmann/json/pull/2081) ([nlohmann](https://github.com/nlohmann))
- Remove Doozer CI [\#2080](https://github.com/nlohmann/json/pull/2080) ([nlohmann](https://github.com/nlohmann))
- Fix README.md. Missing ``` [\#2077](https://github.com/nlohmann/json/pull/2077) ([ArthurSonzogni](https://github.com/ArthurSonzogni))
- Fix error message about invalid surrogate pairs [\#2076](https://github.com/nlohmann/json/pull/2076) ([rmisev](https://github.com/rmisev))
- Add CMake fetchcontent documentation and tests [\#2074](https://github.com/nlohmann/json/pull/2074) ([ArthurSonzogni](https://github.com/ArthurSonzogni))
- Properly pass serialize\_binary to dump function [\#2071](https://github.com/nlohmann/json/pull/2071) ([nlohmann](https://github.com/nlohmann))
- Fix returning reference to local temporary object [\#2069](https://github.com/nlohmann/json/pull/2069) ([nlohmann](https://github.com/nlohmann))
- updated wandbox link [\#2060](https://github.com/nlohmann/json/pull/2060) ([alexandermyasnikov](https://github.com/alexandermyasnikov))
- Fix bug in diff function [\#2054](https://github.com/nlohmann/json/pull/2054) ([nlohmann](https://github.com/nlohmann))
- Fix GCC compiler warnings [\#2053](https://github.com/nlohmann/json/pull/2053) ([nlohmann](https://github.com/nlohmann))
- Fix Clang compiler warnings [\#2051](https://github.com/nlohmann/json/pull/2051) ([nlohmann](https://github.com/nlohmann))
- Update doctest to 2.3.7 [\#2050](https://github.com/nlohmann/json/pull/2050) ([nlohmann](https://github.com/nlohmann))
- Fix issue\#1719 [\#2044](https://github.com/nlohmann/json/pull/2044) ([dota17](https://github.com/dota17))
- Add missing testcase about NaN in unit-constructor1.cpp [\#2043](https://github.com/nlohmann/json/pull/2043) ([dota17](https://github.com/dota17))
- Templatize basic\_json constructor from json\_ref [\#2034](https://github.com/nlohmann/json/pull/2034) ([ArtemSarmini](https://github.com/ArtemSarmini))
- Replace deprecated std::is\_pod [\#2033](https://github.com/nlohmann/json/pull/2033) ([nlohmann](https://github.com/nlohmann))
- Fixes \#1971 \(memory leak in basic\_json::push\_back\) [\#2025](https://github.com/nlohmann/json/pull/2025) ([ArtemSarmini](https://github.com/ArtemSarmini))
- fix \#1982:json\_pointer.contains\(\) exception is incorrectly raised [\#2019](https://github.com/nlohmann/json/pull/2019) ([dota17](https://github.com/dota17))
- Update LICENSE.MIT [\#2010](https://github.com/nlohmann/json/pull/2010) ([magamig](https://github.com/magamig))
- PR for \#2006 to test in AppVeyor. [\#2008](https://github.com/nlohmann/json/pull/2008) ([garethsb](https://github.com/garethsb))
- Added wsjcpp.yml [\#2004](https://github.com/nlohmann/json/pull/2004) ([sea-kg](https://github.com/sea-kg))
- fix error 'setw' is not a member of 'std' in Wandbox example [\#2002](https://github.com/nlohmann/json/pull/2002) ([alexandermyasnikov](https://github.com/alexandermyasnikov))
- catch exceptions for json\_pointer : ..../+99 [\#1990](https://github.com/nlohmann/json/pull/1990) ([dota17](https://github.com/dota17))
- Modify the document about operator== [\#1984](https://github.com/nlohmann/json/pull/1984) ([dota17](https://github.com/dota17))
- Rename argument array\_index to array\_indx in json\_pointer methods [\#1980](https://github.com/nlohmann/json/pull/1980) ([linev](https://github.com/linev))
- README: Fix string representation of `dump`ed `json` [\#1979](https://github.com/nlohmann/json/pull/1979) ([alexweej](https://github.com/alexweej))
- fix warnings in serializer.hpp for VS2019 [\#1969](https://github.com/nlohmann/json/pull/1969) ([dota17](https://github.com/dota17))
- Fix C26451 warnnings in to\_chars.hpp [\#1967](https://github.com/nlohmann/json/pull/1967) ([dota17](https://github.com/dota17))
- appveyor.yml: Compile and test with latest version for \_\_cplusplus ma… [\#1958](https://github.com/nlohmann/json/pull/1958) ([t-b](https://github.com/t-b))
- Fix typo in examples [\#1956](https://github.com/nlohmann/json/pull/1956) ([dota17](https://github.com/dota17))
- templated input adapters [\#1950](https://github.com/nlohmann/json/pull/1950) ([FrancoisChabot](https://github.com/FrancoisChabot))
- Update README.md : add a FAQ about memory release [\#1933](https://github.com/nlohmann/json/pull/1933) ([dota17](https://github.com/dota17))
- Some typos [\#1923](https://github.com/nlohmann/json/pull/1923) ([Coeur](https://github.com/Coeur))
- Fix link to parse function in README [\#1918](https://github.com/nlohmann/json/pull/1918) ([kastiglione](https://github.com/kastiglione))
- Readme: Updated links to hunter repo & docs [\#1917](https://github.com/nlohmann/json/pull/1917) ([jothepro](https://github.com/jothepro))
- Adds instruction for using Build2's package manager [\#1909](https://github.com/nlohmann/json/pull/1909) ([Klaim](https://github.com/Klaim))
- Update README.md [\#1907](https://github.com/nlohmann/json/pull/1907) ([pauljurczak](https://github.com/pauljurczak))
- Fix warning: ignoring return value [\#1871](https://github.com/nlohmann/json/pull/1871) ([sonulohani](https://github.com/sonulohani))
- docs: add central repository as conan source to readme [\#1857](https://github.com/nlohmann/json/pull/1857) ([gocarlos](https://github.com/gocarlos))
- README: Package in MSYS2 renamed to nlohmann-json [\#1853](https://github.com/nlohmann/json/pull/1853) ([podsvirov](https://github.com/podsvirov))
- Fix msvc warnings [\#1846](https://github.com/nlohmann/json/pull/1846) ([MBalszun](https://github.com/MBalszun))
- Update tests that generate CMake projects to use main project's C++ compiler [\#1844](https://github.com/nlohmann/json/pull/1844) ([Tridacnid](https://github.com/Tridacnid))
- make CMake's version config file architecture-independent [\#1746](https://github.com/nlohmann/json/pull/1746) ([uhoreg](https://github.com/uhoreg))
- Add binary type support to all binary file formats, as well as an internally represented binary type [\#1662](https://github.com/nlohmann/json/pull/1662) ([OmnipotentEntity](https://github.com/OmnipotentEntity))

## [v3.7.3](https://github.com/nlohmann/json/releases/tag/v3.7.3) (2019-11-17)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.7.2...v3.7.3)

- Project branches [\#1839](https://github.com/nlohmann/json/issues/1839)
- Quadratic destruction complexity introduced in \#1436 [\#1837](https://github.com/nlohmann/json/issues/1837)
- Trying to open a file [\#1814](https://github.com/nlohmann/json/issues/1814)
- Comparing data type with value\_t::number\_integer fails [\#1783](https://github.com/nlohmann/json/issues/1783)
- CMake version config file is architecture-dependent [\#1697](https://github.com/nlohmann/json/issues/1697)

- Fix quadratic destruction complexity [\#1838](https://github.com/nlohmann/json/pull/1838) ([nickaein](https://github.com/nickaein))

## [v3.7.2](https://github.com/nlohmann/json/releases/tag/v3.7.2) (2019-11-10)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.7.1...v3.7.2)

- Segmentation fault in destructor in case of large inputs [\#1835](https://github.com/nlohmann/json/issues/1835)
- type\_name\(\) is not consistent with type\(\) [\#1833](https://github.com/nlohmann/json/issues/1833)
- json::parse is not a member [\#1832](https://github.com/nlohmann/json/issues/1832)
- How do you deal with json\* ? [\#1829](https://github.com/nlohmann/json/issues/1829)
- Combined find\_package/add\_subdirectory not linking libraries [\#1771](https://github.com/nlohmann/json/issues/1771)
- example code for ifstream reading a json file results in no operator error [\#1766](https://github.com/nlohmann/json/issues/1766)
- Warning: unsequenced modification and access to 'range' [\#1674](https://github.com/nlohmann/json/issues/1674)
- Segmentation fault \(stack overflow\) due to unbounded recursion [\#1419](https://github.com/nlohmann/json/issues/1419)
- Stack-overflow \(OSS-Fuzz 4234\) [\#832](https://github.com/nlohmann/json/issues/832)

- Configure WhiteSource Bolt for GitHub [\#1830](https://github.com/nlohmann/json/pull/1830) ([mend-bolt-for-github[bot]](https://github.com/apps/mend-bolt-for-github))
- Prevent stackoverflow caused by recursive deconstruction [\#1436](https://github.com/nlohmann/json/pull/1436) ([nickaein](https://github.com/nickaein))

## [v3.7.1](https://github.com/nlohmann/json/releases/tag/v3.7.1) (2019-11-06)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.7.0...v3.7.1)

- std::is\_constructible is always true with tuple [\#1825](https://github.com/nlohmann/json/issues/1825)
- Can't compile from\_json\(std::valarray\<T\>\). [\#1824](https://github.com/nlohmann/json/issues/1824)
- json class should have a get\_or member function [\#1823](https://github.com/nlohmann/json/issues/1823)
- NLOHMANN\_JSON\_SERIALIZE\_ENUM macro capture's json objects by value [\#1822](https://github.com/nlohmann/json/issues/1822)
- Parse fails when number literals start with zero [\#1820](https://github.com/nlohmann/json/issues/1820)
- Weird behaviour of `contains` with `json_pointer` [\#1815](https://github.com/nlohmann/json/issues/1815)
- strange behaviour with json\_pointer and .contains\(\) [\#1811](https://github.com/nlohmann/json/issues/1811)
- Can \#1695 be re-opened? [\#1808](https://github.com/nlohmann/json/issues/1808)
- Merge two json objects [\#1807](https://github.com/nlohmann/json/issues/1807)
- std::is\_constructible\<json, std::unordered\_map\<std::string, Data\>\> when to\_json not defined [\#1805](https://github.com/nlohmann/json/issues/1805)
- Private data on parsing [\#1802](https://github.com/nlohmann/json/issues/1802)
- Capturing Line and Position when querying [\#1800](https://github.com/nlohmann/json/issues/1800)
- json error on parsing DBL\_MAX from string [\#1796](https://github.com/nlohmann/json/issues/1796)
- De/Serialisation of vector of tupple object with nested obect need Help please [\#1794](https://github.com/nlohmann/json/issues/1794)
- Output json is corrupted [\#1793](https://github.com/nlohmann/json/issues/1793)
- variable name byte sometimes used as a \#define [\#1792](https://github.com/nlohmann/json/issues/1792)
- Can't read json file [\#1791](https://github.com/nlohmann/json/issues/1791)
- Problems with special German letters [\#1789](https://github.com/nlohmann/json/issues/1789)
- Support for trailing commas [\#1787](https://github.com/nlohmann/json/issues/1787)
- json\_pointer construction bug [\#1786](https://github.com/nlohmann/json/issues/1786)
- Visual Studio 2017 warning [\#1784](https://github.com/nlohmann/json/issues/1784)
- ciso646 header become obsolete [\#1782](https://github.com/nlohmann/json/issues/1782)
- Migrate LGTM.com installation from OAuth to GitHub App [\#1781](https://github.com/nlohmann/json/issues/1781)
- JSON comparison, contains and operator& [\#1778](https://github.com/nlohmann/json/issues/1778)
- pass a json object to a class contructor adds an array around the object [\#1776](https://github.com/nlohmann/json/issues/1776)
- 'Float' number\_float\_function\_t template parameter name conflicts with C '\#define Float float' [\#1775](https://github.com/nlohmann/json/issues/1775)
- A weird building problem :-\( [\#1774](https://github.com/nlohmann/json/issues/1774)
- What is this json\_ref? [\#1772](https://github.com/nlohmann/json/issues/1772)
- Interoperability with other languages [\#1770](https://github.com/nlohmann/json/issues/1770)
- Json dump [\#1768](https://github.com/nlohmann/json/issues/1768)
- json\_pointer\<\>::back\(\) should be const [\#1764](https://github.com/nlohmann/json/issues/1764)
- How to get value from array [\#1762](https://github.com/nlohmann/json/issues/1762)
- Merge two jsons [\#1757](https://github.com/nlohmann/json/issues/1757)
- Unable to locate nlohmann\_jsonConfig.cmake [\#1755](https://github.com/nlohmann/json/issues/1755)
- json.hpp won;t compile VS2019 CLR/CLI app but does in console app [\#1754](https://github.com/nlohmann/json/issues/1754)
- \[Nested Json Objects\] Segmentation fault [\#1753](https://github.com/nlohmann/json/issues/1753)
- remove/replace assert with exceptions [\#1752](https://github.com/nlohmann/json/issues/1752)
- Add array support for update\(\) function [\#1751](https://github.com/nlohmann/json/issues/1751)
- Is there a reason the `get_to` method is defined in `include/nlohmann/json.hpp` but not in `single_include/nlohmann/json.hpp`? [\#1750](https://github.com/nlohmann/json/issues/1750)
- how to validate json object before calling dump\(\) [\#1748](https://github.com/nlohmann/json/issues/1748)
- Unable to invoke accessors on json objects in lldb [\#1745](https://github.com/nlohmann/json/issues/1745)
- Escaping string before parsing [\#1743](https://github.com/nlohmann/json/issues/1743)
- Construction in a member initializer list using curly braces is set as 'array' [\#1742](https://github.com/nlohmann/json/issues/1742)
- Read a subkey from json object [\#1740](https://github.com/nlohmann/json/issues/1740)
- Serialize vector of glm:vec2 [\#1739](https://github.com/nlohmann/json/issues/1739)
- Support nlohmann::basic\_json::value with JSON\_NOEXCEPTION [\#1738](https://github.com/nlohmann/json/issues/1738)
- how to know the parse is error [\#1737](https://github.com/nlohmann/json/issues/1737)
- How to check if a given key exists in a JSON object [\#1736](https://github.com/nlohmann/json/issues/1736)
- Allow The Colon Key-Value Delimiter To Have A Space Before It \[@ READ ONLY\] [\#1735](https://github.com/nlohmann/json/issues/1735)
- Allow Tail { "Key": "Value" } Comma \[@ READ ONLY\] [\#1734](https://github.com/nlohmann/json/issues/1734)
- No-throw json::value\(\) [\#1733](https://github.com/nlohmann/json/issues/1733)
- JsonObject.dump\(\)  [\#1732](https://github.com/nlohmann/json/issues/1732)
- basic\_json has no member "parse" [\#1731](https://github.com/nlohmann/json/issues/1731)
- Exception "type must be string, but is array" [\#1730](https://github.com/nlohmann/json/issues/1730)
- json::contains usage to find a path [\#1727](https://github.com/nlohmann/json/issues/1727)
- How to create JSON Object from my Structures of Data and Json File from that Object [\#1726](https://github.com/nlohmann/json/issues/1726)
- please provide an API to read JSON from file directly. [\#1725](https://github.com/nlohmann/json/issues/1725)
- How to modify a value stored at a key? [\#1723](https://github.com/nlohmann/json/issues/1723)
- CMake not correctly finding the configuration package for 3.7.0  [\#1721](https://github.com/nlohmann/json/issues/1721)
- name typo in the "spack package management" section of README.md [\#1720](https://github.com/nlohmann/json/issues/1720)
- How to add json to another json? [\#1718](https://github.com/nlohmann/json/issues/1718)
- json::parse\(\) ubsan regression with v3.7.0 [\#1716](https://github.com/nlohmann/json/issues/1716)
- What I am doing wrong?!? [\#1714](https://github.com/nlohmann/json/issues/1714)
- Potential memory leak detected by Valgrind [\#1713](https://github.com/nlohmann/json/issues/1713)
- json::parse is not thread safe? [\#1712](https://github.com/nlohmann/json/issues/1712)
- static analysis alarm by cppcheck [\#1711](https://github.com/nlohmann/json/issues/1711)
- The compilation time is slow [\#1710](https://github.com/nlohmann/json/issues/1710)
- not linking properly with cmake [\#1709](https://github.com/nlohmann/json/issues/1709)
- Error in dump\(\) with int64\_t minimum value [\#1708](https://github.com/nlohmann/json/issues/1708)
- Crash on trying to deserialize json string on 3ds homebrew [\#1707](https://github.com/nlohmann/json/issues/1707)
- Can't compile VS2019. 13 Errors  [\#1706](https://github.com/nlohmann/json/issues/1706)
- find an object that matches the search criteria [\#1705](https://github.com/nlohmann/json/issues/1705)
- IntelliSense goes crazy on VS2019 [\#1704](https://github.com/nlohmann/json/issues/1704)
- Installing on Ubuntu 16.04 [\#1703](https://github.com/nlohmann/json/issues/1703)
- Where is json::parse now? [\#1702](https://github.com/nlohmann/json/issues/1702)
- Forward header should't be amalgamated [\#1700](https://github.com/nlohmann/json/issues/1700)
- Json support for Cmake version 2.8.12 [\#1699](https://github.com/nlohmann/json/issues/1699)
- Intruisive scientific notation when using .dump\(\); [\#1698](https://github.com/nlohmann/json/issues/1698)
- Is there support for automatic serialization/deserialization? [\#1696](https://github.com/nlohmann/json/issues/1696)
- on MSVC dump\(\) will hard crash for larger json [\#1693](https://github.com/nlohmann/json/issues/1693)
- puzzled implicit conversions [\#1692](https://github.com/nlohmann/json/issues/1692)
- Information: My project uses this awesome library [\#1691](https://github.com/nlohmann/json/issues/1691)
- Consider listing files explicitly instead of using GLOB [\#1686](https://github.com/nlohmann/json/issues/1686)
- Failing tests on MSVC with VS2019 15.9.13 x64 [\#1685](https://github.com/nlohmann/json/issues/1685)
- Change from v2 to v3. Encoding with cp1252 [\#1680](https://github.com/nlohmann/json/issues/1680)
- How to add Fifo\_map into json using Cmake [\#1679](https://github.com/nlohmann/json/issues/1679)
- include.zip should contain meson.build [\#1672](https://github.com/nlohmann/json/issues/1672)
- \[Question\] How do I parse JSON into custom types? [\#1669](https://github.com/nlohmann/json/issues/1669)
- Binary \(0x05\) data type for BSON to JSON conversion [\#1668](https://github.com/nlohmann/json/issues/1668)
- Possible to call dump from lldb? [\#1666](https://github.com/nlohmann/json/issues/1666)
- Segmentation fault when linked with libunwind [\#1665](https://github.com/nlohmann/json/issues/1665)
- Should I include single-header after my to\_json and from\_json custom functions declaration? Why not? [\#1663](https://github.com/nlohmann/json/issues/1663)
- Errors/Warnings in VS 2019 when Including Header File [\#1659](https://github.com/nlohmann/json/issues/1659)
- Return null object from object's const operator\[\] as well. [\#1658](https://github.com/nlohmann/json/issues/1658)
- Can't stream json object in to std::basic\_stringstream\<wchar\_t\> [\#1656](https://github.com/nlohmann/json/issues/1656)
- C2440 in vs2015 cannot convert from 'initializer-list' to nlohmann::basic\_json [\#1655](https://github.com/nlohmann/json/issues/1655)
- Issues around get and pointers [\#1653](https://github.com/nlohmann/json/issues/1653)
- Non-member operator== breaks enum \(de\)serialization [\#1647](https://github.com/nlohmann/json/issues/1647)
- Valgrind: bytes in 1 blocks are definitely lost [\#1646](https://github.com/nlohmann/json/issues/1646)
- Convenient way to make 'basic\_json' accept 'QString' as an key type as well? [\#1640](https://github.com/nlohmann/json/issues/1640)
- mongodb: nan, inf [\#1599](https://github.com/nlohmann/json/issues/1599)
- Error in adl\_serializer [\#1590](https://github.com/nlohmann/json/issues/1590)
- Injecting class during serialization [\#1584](https://github.com/nlohmann/json/issues/1584)
- output\_adapter not user extensible [\#1534](https://github.com/nlohmann/json/issues/1534)
- Inclusion of nlohmann/json.hpp causes OS/ABI to change on Linux [\#1410](https://github.com/nlohmann/json/issues/1410)
- Add library versioning using inline namespaces [\#1394](https://github.com/nlohmann/json/issues/1394)
- CBOR byte string support [\#1129](https://github.com/nlohmann/json/issues/1129)
- How to deserialize array with derived objects [\#716](https://github.com/nlohmann/json/issues/716)

- Add restriction for tuple specialization of to\_json [\#1826](https://github.com/nlohmann/json/pull/1826) ([cbegue](https://github.com/cbegue))
- Fix for \#1647 [\#1821](https://github.com/nlohmann/json/pull/1821) ([AnthonyVH](https://github.com/AnthonyVH))
- Fix issue \#1805 [\#1806](https://github.com/nlohmann/json/pull/1806) ([cbegue](https://github.com/cbegue))
- Fix some spelling errors - mostly in comments & documentation. [\#1803](https://github.com/nlohmann/json/pull/1803) ([flopp](https://github.com/flopp))
- Update Hedley to v11. [\#1799](https://github.com/nlohmann/json/pull/1799) ([nemequ](https://github.com/nemequ))
- iteration\_proxy: Fix integer truncation from std::size\_t to int [\#1797](https://github.com/nlohmann/json/pull/1797) ([t-b](https://github.com/t-b))
- appveyor.yml: Add MSVC 16 2019 support [\#1780](https://github.com/nlohmann/json/pull/1780) ([t-b](https://github.com/t-b))
- test/CMakeLists.txt: Use an explicit list instead of GLOB [\#1779](https://github.com/nlohmann/json/pull/1779) ([t-b](https://github.com/t-b))
- Make json\_pointer::back const \(resolves \#1764\) [\#1769](https://github.com/nlohmann/json/pull/1769) ([chris0x44](https://github.com/chris0x44))
- did you mean 'serialization'? [\#1767](https://github.com/nlohmann/json/pull/1767) ([0xflotus](https://github.com/0xflotus))
- Allow items\(\) to be used with custom string [\#1765](https://github.com/nlohmann/json/pull/1765) ([crazyjul](https://github.com/crazyjul))
- Cppcheck fixes [\#1760](https://github.com/nlohmann/json/pull/1760) ([Xav83](https://github.com/Xav83))
- Fix and add test's for SFINAE problem [\#1741](https://github.com/nlohmann/json/pull/1741) ([tete17](https://github.com/tete17))
- Fix clang sanitizer invocation [\#1728](https://github.com/nlohmann/json/pull/1728) ([t-b](https://github.com/t-b))
- Add gcc 9 and compile with experimental C++20 support [\#1724](https://github.com/nlohmann/json/pull/1724) ([t-b](https://github.com/t-b))
- Fix int64 min issue [\#1722](https://github.com/nlohmann/json/pull/1722) ([t-b](https://github.com/t-b))
- release: add singleinclude and meson.build to include.zip [\#1694](https://github.com/nlohmann/json/pull/1694) ([eli-schwartz](https://github.com/eli-schwartz))

## [v3.7.0](https://github.com/nlohmann/json/releases/tag/v3.7.0) (2019-07-28)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.6.1...v3.7.0)

- How can I retrieve uknown strings from json file in my C++ program. [\#1684](https://github.com/nlohmann/json/issues/1684)
- contains\(\) is sometimes causing stack-based buffer overrun exceptions [\#1683](https://github.com/nlohmann/json/issues/1683)
- How to deserialize arrays  from json [\#1681](https://github.com/nlohmann/json/issues/1681)
- Compilation failed in VS2015 [\#1678](https://github.com/nlohmann/json/issues/1678)
- Why the compiled object file is so huge? [\#1677](https://github.com/nlohmann/json/issues/1677)
- From Version 2.1.1 to 3.6.1 serialize std::set [\#1676](https://github.com/nlohmann/json/issues/1676)
- Qt deprecation model halting compiltion [\#1675](https://github.com/nlohmann/json/issues/1675)
-  Build For Raspberry pi , Rapbery with new Compiler C++17 [\#1671](https://github.com/nlohmann/json/issues/1671)
- Build from Raspberry pi [\#1667](https://github.com/nlohmann/json/issues/1667)
- Can not translate map with integer key to dict string ?  [\#1664](https://github.com/nlohmann/json/issues/1664)
- Double type converts to scientific notation [\#1661](https://github.com/nlohmann/json/issues/1661)
- Missing v3.6.1 tag on master branch [\#1657](https://github.com/nlohmann/json/issues/1657)
- Support Fleese Binary Data Format [\#1654](https://github.com/nlohmann/json/issues/1654)
- Suggestion: replace alternative tokens for !, && and || with their symbols [\#1652](https://github.com/nlohmann/json/issues/1652)
- Build failure test-allocator.vcxproj [\#1651](https://github.com/nlohmann/json/issues/1651)
- How to provide function json& to\_json\(\) which is similar as 'void to\_json\(json&j, const CObject& obj\)'  ? [\#1650](https://github.com/nlohmann/json/issues/1650)
- Can't throw exception when starting file is a number [\#1649](https://github.com/nlohmann/json/issues/1649)
- to\_json / from\_json with nested type [\#1648](https://github.com/nlohmann/json/issues/1648)
- How to create a json object from a std::string, created by j.dump? [\#1645](https://github.com/nlohmann/json/issues/1645)
- Problem getting vector \(array\) of strings [\#1644](https://github.com/nlohmann/json/issues/1644)
- json.hpp compilation issue with other typedefs with same name [\#1642](https://github.com/nlohmann/json/issues/1642)
- nlohmann::adl\_serializer\<T,void\>::to\_json no matching overloaded function found [\#1641](https://github.com/nlohmann/json/issues/1641)
- overwrite adl\_serializer\<bool, void\> to change behaviour [\#1638](https://github.com/nlohmann/json/issues/1638)
- json.SelectToken\("Manufacturers.Products.Price"\); [\#1637](https://github.com/nlohmann/json/issues/1637)
- Add json type as value [\#1636](https://github.com/nlohmann/json/issues/1636)
- Unit conversion test error: conversion from 'nlohmann::json' to non-scalar type 'std::string\_view' requested [\#1634](https://github.com/nlohmann/json/issues/1634)
- nlohmann VS JsonCpp by C++17 [\#1633](https://github.com/nlohmann/json/issues/1633)
- To integrate an inline helper function that return type name as string [\#1632](https://github.com/nlohmann/json/issues/1632)
- Return JSON as reference [\#1631](https://github.com/nlohmann/json/issues/1631)
- Updating from an older version causes problems with assing a json object to a struct [\#1630](https://github.com/nlohmann/json/issues/1630)
- Can without default constructor function for user defined classes when only to\_json is needed? [\#1629](https://github.com/nlohmann/json/issues/1629)
- Compilation fails with clang 6.x-8.x in C++14 mode [\#1628](https://github.com/nlohmann/json/issues/1628)
- Treating floating point as string [\#1627](https://github.com/nlohmann/json/issues/1627)
- error parsing character å [\#1626](https://github.com/nlohmann/json/issues/1626)
- \[Help\] How to Improve Json Output Performance with Large Json Arrays [\#1624](https://github.com/nlohmann/json/issues/1624)
- Suggested link changes for reporting new issues \[blob/develop/REAME.md and blob/develop/.github/CONTRIBUTING.md\] [\#1623](https://github.com/nlohmann/json/issues/1623)
- Broken link to issue template in CONTRIBUTING.md [\#1622](https://github.com/nlohmann/json/issues/1622)
- Missing word in README.md file  [\#1621](https://github.com/nlohmann/json/issues/1621)
- Package manager instructions in README for brew is incorrect [\#1620](https://github.com/nlohmann/json/issues/1620)
- Building with Visual Studio 2019 [\#1619](https://github.com/nlohmann/json/issues/1619)
- Precedence of to\_json and builtin harmful [\#1617](https://github.com/nlohmann/json/issues/1617)
- The type json is missing from the html documentation [\#1616](https://github.com/nlohmann/json/issues/1616)
- variant is not support in Release 3.6.1? [\#1615](https://github.com/nlohmann/json/issues/1615)
- Replace assert with throw for const operator\[\] [\#1614](https://github.com/nlohmann/json/issues/1614)
- Memory Overhead is Too High \(10x or more\) [\#1613](https://github.com/nlohmann/json/issues/1613)
- program crash everytime, when other data type incomming in json stream as expected [\#1612](https://github.com/nlohmann/json/issues/1612)
- Improved Enum Support [\#1611](https://github.com/nlohmann/json/issues/1611)
- is it possible convert json object back to stl container ? [\#1610](https://github.com/nlohmann/json/issues/1610)
- Add C++17-like emplace.back\(\) for arrays. [\#1609](https://github.com/nlohmann/json/issues/1609)
- is\_nothrow\_copy\_constructible fails for json::const\_iterator on MSVC2015 x86 Debug build [\#1608](https://github.com/nlohmann/json/issues/1608)
- Reading and writing array elements [\#1607](https://github.com/nlohmann/json/issues/1607)
- Converting json::value to int [\#1605](https://github.com/nlohmann/json/issues/1605)
- I have a vector of keys and and a string of value and i want to create nested json array [\#1604](https://github.com/nlohmann/json/issues/1604)
- In compatible JSON object from nlohmann::json to nohman::json - unexpected end of input; expected '\[', '{', or a literal [\#1603](https://github.com/nlohmann/json/issues/1603)
- json parser crash if having a large number integer in message  [\#1602](https://github.com/nlohmann/json/issues/1602)
- Value method with undocumented throwing 302 exception [\#1601](https://github.com/nlohmann/json/issues/1601)
- Accessing value with json pointer adds key if not existing [\#1600](https://github.com/nlohmann/json/issues/1600)
- README.md broken link to project documentation [\#1597](https://github.com/nlohmann/json/issues/1597)
- Random Kudos: Thanks for your work on this! [\#1596](https://github.com/nlohmann/json/issues/1596)
- json::parse return value and errors [\#1595](https://github.com/nlohmann/json/issues/1595)
- initializer list constructor makes curly brace initialization fragile [\#1594](https://github.com/nlohmann/json/issues/1594)
- trying to log message for missing keyword, difference between \["foo"\] and at\("foo"\) [\#1593](https://github.com/nlohmann/json/issues/1593)
- std::string and std::wstring `to_json`  [\#1592](https://github.com/nlohmann/json/issues/1592)
- I have a C structure which I need to convert to a JSON. How do I do it? Haven't found proper examples so far. [\#1591](https://github.com/nlohmann/json/issues/1591)
- dump\_escaped possible error ? [\#1589](https://github.com/nlohmann/json/issues/1589)
- json::parse\(\) into a vector\<string\> results in unhandled exception [\#1587](https://github.com/nlohmann/json/issues/1587)
- push\_back\(\)/emplace\_back\(\) on array invalidates pointers to existing array items [\#1586](https://github.com/nlohmann/json/issues/1586)
- Getting nlohmann::detail::parse\_error on JSON generated by nlohmann::json not sure why [\#1583](https://github.com/nlohmann/json/issues/1583)
- getting error terminate called after throwing an instance of 'std::domain\_error'   what\(\):  cannot use at\(\) with string [\#1582](https://github.com/nlohmann/json/issues/1582)
- how i create json file  [\#1581](https://github.com/nlohmann/json/issues/1581)
- prevent rounding of double datatype values [\#1580](https://github.com/nlohmann/json/issues/1580)
- Documentation Container Overview Doesn't Reference Const Methods [\#1579](https://github.com/nlohmann/json/issues/1579)
- Writing an array into a nlohmann::json object [\#1578](https://github.com/nlohmann/json/issues/1578)
- compilation error when using with another library [\#1577](https://github.com/nlohmann/json/issues/1577)
- Homebrew on OSX doesn't install cmake config file [\#1576](https://github.com/nlohmann/json/issues/1576)
- JSON Parse Out of Range Error [\#1574](https://github.com/nlohmann/json/issues/1574)
- Integrating into existing CMake Project [\#1573](https://github.com/nlohmann/json/issues/1573)
- conversion to std::string failed [\#1571](https://github.com/nlohmann/json/issues/1571)
- jPtr operation does not throw [\#1569](https://github.com/nlohmann/json/issues/1569)
- How to generate dll file for this project [\#1568](https://github.com/nlohmann/json/issues/1568)
- how to pass variable data to json in c [\#1567](https://github.com/nlohmann/json/issues/1567)
- I want to achieve an upgraded function. [\#1566](https://github.com/nlohmann/json/issues/1566)
- How to determine the type of elements read from a JSON array? [\#1564](https://github.com/nlohmann/json/issues/1564)
- try\_get\_to [\#1563](https://github.com/nlohmann/json/issues/1563)
- example code  compile error [\#1562](https://github.com/nlohmann/json/issues/1562)
- How to iterate over nested json object [\#1561](https://github.com/nlohmann/json/issues/1561)
- Build Option/Separate Function to Allow to Throw on Duplicate Keys [\#1560](https://github.com/nlohmann/json/issues/1560)
- Compiler Switches -Weffc++ & -Wshadow are throwing errors [\#1558](https://github.com/nlohmann/json/issues/1558)
- warning: use of the 'nodiscard' attribute is a C++17 extension [\#1557](https://github.com/nlohmann/json/issues/1557)
- Import/Export compressed JSON files [\#1556](https://github.com/nlohmann/json/issues/1556)
- GDB renderers for json library [\#1554](https://github.com/nlohmann/json/issues/1554)
- Is it possible to construct a json string object from a binary buffer? [\#1553](https://github.com/nlohmann/json/issues/1553)
- json objects in list [\#1552](https://github.com/nlohmann/json/issues/1552)
- Matrix output [\#1550](https://github.com/nlohmann/json/issues/1550)
- Using json merge\_patch on ordered non-alphanumeric datasets [\#1549](https://github.com/nlohmann/json/issues/1549)
- Invalid parsed value for big integer [\#1548](https://github.com/nlohmann/json/issues/1548)
- Integrating with android ndk issues. [\#1547](https://github.com/nlohmann/json/issues/1547)
- add noexcept json::value\("key", default\) method variant? [\#1546](https://github.com/nlohmann/json/issues/1546)
- Thank you! 🙌 [\#1545](https://github.com/nlohmann/json/issues/1545)
- Output and input matrix [\#1544](https://github.com/nlohmann/json/issues/1544)
- Add regression tests for MSVC [\#1543](https://github.com/nlohmann/json/issues/1543)
- \[Help Needed!\] Season of Docs [\#1542](https://github.com/nlohmann/json/issues/1542)
- program still abort\(\) or exit\(\) with try catch [\#1541](https://github.com/nlohmann/json/issues/1541)
- Have a json::type\_error exception because of JSON object [\#1540](https://github.com/nlohmann/json/issues/1540)
- Quoted numbers [\#1538](https://github.com/nlohmann/json/issues/1538)
- Reading a JSON file into an object [\#1537](https://github.com/nlohmann/json/issues/1537)
- Releases 3.6.0 and 3.6.1 don't build on conda / windows [\#1536](https://github.com/nlohmann/json/issues/1536)
- \[Clang\] warning: use of the 'nodiscard' attribute is a C++17 extension \[-Wc++17-extensions\] [\#1535](https://github.com/nlohmann/json/issues/1535)
- wchar\_t/std::wstring json can be created but not accessed [\#1533](https://github.com/nlohmann/json/issues/1533)
- json stringify [\#1532](https://github.com/nlohmann/json/issues/1532)
- How can I use it from gcc on RPI [\#1528](https://github.com/nlohmann/json/issues/1528)
- std::pair treated as an array instead of key-value in `std::vector<std::pair<>>` [\#1520](https://github.com/nlohmann/json/issues/1520)
- Excessive Memory Usage for Large Json File [\#1516](https://github.com/nlohmann/json/issues/1516)
- SAX dumper [\#1512](https://github.com/nlohmann/json/issues/1512)
- Conversion to user type containing a std::vector not working with documented approach [\#1511](https://github.com/nlohmann/json/issues/1511)
- Inconsistent use of type alias. [\#1507](https://github.com/nlohmann/json/issues/1507)
- Is there a current way to represent strings as json int? [\#1503](https://github.com/nlohmann/json/issues/1503)
- Intermittent issues with loadJSON [\#1484](https://github.com/nlohmann/json/issues/1484)
- use json construct std::string [\#1462](https://github.com/nlohmann/json/issues/1462)
- JSON Creation [\#1461](https://github.com/nlohmann/json/issues/1461)
- Null bytes in files are treated like EOF [\#1095](https://github.com/nlohmann/json/issues/1095)
- Feature: to\_string\(const json& j\); [\#916](https://github.com/nlohmann/json/issues/916)

- Use GNUInstallDirs instead of hard-coded path. [\#1673](https://github.com/nlohmann/json/pull/1673) ([ghost](https://github.com/ghost))
- Package Manager: MSYS2 \(pacman\) [\#1670](https://github.com/nlohmann/json/pull/1670) ([podsvirov](https://github.com/podsvirov))
- Fix json.hpp compilation issue with other typedefs with same name \(Issue \#1642\) [\#1643](https://github.com/nlohmann/json/pull/1643) ([kevinlul](https://github.com/kevinlul))
- Add explicit conversion from json to std::string\_view in conversion unit test [\#1639](https://github.com/nlohmann/json/pull/1639) ([taylorhoward92](https://github.com/taylorhoward92))
- Minor fixes in docs [\#1625](https://github.com/nlohmann/json/pull/1625) ([nickaein](https://github.com/nickaein))
- Fix broken links to documentation [\#1598](https://github.com/nlohmann/json/pull/1598) ([nickaein](https://github.com/nickaein))
- Added to\_string and added basic tests [\#1585](https://github.com/nlohmann/json/pull/1585) ([Macr0Nerd](https://github.com/Macr0Nerd))
- Regression tests for MSVC [\#1570](https://github.com/nlohmann/json/pull/1570) ([nickaein](https://github.com/nickaein))
- Fix/1511 [\#1555](https://github.com/nlohmann/json/pull/1555) ([theodelrieu](https://github.com/theodelrieu))
- Remove C++17 extension warning from clang; \#1535 [\#1551](https://github.com/nlohmann/json/pull/1551) ([heavywatal](https://github.com/heavywatal))
- moved from Catch to doctest for unit tests [\#1439](https://github.com/nlohmann/json/pull/1439) ([onqtam](https://github.com/onqtam))

## [v3.6.1](https://github.com/nlohmann/json/releases/tag/v3.6.1) (2019-03-20)

[Full Changelog](https://github.com/nlohmann/json/compare/3.6.1...v3.6.1)

## [3.6.1](https://github.com/nlohmann/json/releases/tag/3.6.1) (2019-03-20)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.6.0...3.6.1)

- Failed to build with \<Windows.h\> [\#1531](https://github.com/nlohmann/json/issues/1531)
- Compiling 3.6.0 with GCC \> 7, array vs std::array \#590 is back [\#1530](https://github.com/nlohmann/json/issues/1530)
- 3.6.0: warning: missing initializer for member 'std::array\<char, 9ul\>::\_M\_elems' \[-Wmissing-field-initializers\] [\#1527](https://github.com/nlohmann/json/issues/1527)
- unable to parse json  [\#1525](https://github.com/nlohmann/json/issues/1525)

## [v3.6.0](https://github.com/nlohmann/json/releases/tag/v3.6.0) (2019-03-19)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.5.0...v3.6.0)

- How can I turn a string of a json array into a json array? [\#1526](https://github.com/nlohmann/json/issues/1526)
- Minor: missing a std:: namespace tag [\#1521](https://github.com/nlohmann/json/issues/1521)
- how to precision to four decimal for double when use to\_json [\#1519](https://github.com/nlohmann/json/issues/1519)
- error parse [\#1518](https://github.com/nlohmann/json/issues/1518)
- Compile error: template argument deduction/substitution failed [\#1515](https://github.com/nlohmann/json/issues/1515)
- std::complex type [\#1510](https://github.com/nlohmann/json/issues/1510)
- CBOR byte string support [\#1509](https://github.com/nlohmann/json/issues/1509)
- Compilation error getting a std::pair\<\> on latest VS 2017 compiler [\#1506](https://github.com/nlohmann/json/issues/1506)
- "Integration" section of documentation needs update? [\#1505](https://github.com/nlohmann/json/issues/1505)
- Json object from string from a TCP socket [\#1504](https://github.com/nlohmann/json/issues/1504)
- MSVC warning C4946 \("reinterpret\_cast used between related classes"\) compiling json.hpp [\#1502](https://github.com/nlohmann/json/issues/1502)
- How to programmatically fill an n-th dimensional JSON object? [\#1501](https://github.com/nlohmann/json/issues/1501)
- Error compiling with clang and `JSON_NOEXCEPTION`: need to include `cstdlib` [\#1500](https://github.com/nlohmann/json/issues/1500)
- The code compiles unsuccessfully with android-ndk-r10e [\#1499](https://github.com/nlohmann/json/issues/1499)
- Cmake 3.1 in develop, when is it likely to make it into a stable release? [\#1498](https://github.com/nlohmann/json/issues/1498)
- Some Help please object inside array [\#1494](https://github.com/nlohmann/json/issues/1494)
- How to get data into vector of user-defined type from a Json object [\#1493](https://github.com/nlohmann/json/issues/1493)
- how to find subelement  without loop [\#1490](https://github.com/nlohmann/json/issues/1490)
- json to std::map [\#1487](https://github.com/nlohmann/json/issues/1487)
- Type in README.md [\#1486](https://github.com/nlohmann/json/issues/1486)
- Error in parsing and reading msgpack-lite  [\#1485](https://github.com/nlohmann/json/issues/1485)
- Compiling issues with libc 2.12 [\#1483](https://github.com/nlohmann/json/issues/1483)
- How do I use reference or pointer binding values? [\#1482](https://github.com/nlohmann/json/issues/1482)
- Compilation fails in MSVC with the Microsoft Language Extensions disabled [\#1481](https://github.com/nlohmann/json/issues/1481)
- Functional visit [\#1480](https://github.com/nlohmann/json/issues/1480)
- \[Question\] Unescaped dump [\#1479](https://github.com/nlohmann/json/issues/1479)
- Some Help please [\#1478](https://github.com/nlohmann/json/issues/1478)
- Global variables are stored within the JSON file, how do I declare them as global variables when I read them out in my C++ program?  [\#1476](https://github.com/nlohmann/json/issues/1476)
- Unable to modify one of the values within the JSON file, and save it  [\#1475](https://github.com/nlohmann/json/issues/1475)
- Documentation of parse function has two identical @pre causes [\#1473](https://github.com/nlohmann/json/issues/1473)
- GCC 9.0 build failure [\#1472](https://github.com/nlohmann/json/issues/1472)
- Can we have an `exists()` method? [\#1471](https://github.com/nlohmann/json/issues/1471)
- How to parse multi object json from file? [\#1470](https://github.com/nlohmann/json/issues/1470)
- How to returns the name of the upper object? [\#1467](https://github.com/nlohmann/json/issues/1467)
- Error: "tuple\_size" has already been declared in the current scope [\#1466](https://github.com/nlohmann/json/issues/1466)
- Checking keys of two jsons against eachother [\#1465](https://github.com/nlohmann/json/issues/1465)
- Disable installation when used as meson subproject [\#1463](https://github.com/nlohmann/json/issues/1463)
- Unpack list of integers to a std::vector\<int\> [\#1460](https://github.com/nlohmann/json/issues/1460)
- Implement DRY definition of JSON representation of a c++ class  [\#1459](https://github.com/nlohmann/json/issues/1459)
- json.exception.type\_error.305 with GCC 4.9 when using C++ {} initializer [\#1458](https://github.com/nlohmann/json/issues/1458)
- API to convert an "uninitialized" json into an empty object or empty array [\#1456](https://github.com/nlohmann/json/issues/1456)
- How to parse a vector of objects with const attributes [\#1453](https://github.com/nlohmann/json/issues/1453)
- NLOHMANN\_JSON\_SERIALIZE\_ENUM potentially requires duplicate definitions [\#1450](https://github.com/nlohmann/json/issues/1450)
- Question about making json object from file directory [\#1449](https://github.com/nlohmann/json/issues/1449)
- .get\(\) throws error if used with userdefined structs in unordered\_map [\#1448](https://github.com/nlohmann/json/issues/1448)
- Integer Overflow \(OSS-Fuzz 12506\) [\#1447](https://github.com/nlohmann/json/issues/1447)
- If a string has too many invalid UTF-8 characters, json::dump attempts to index an array out of bounds. [\#1445](https://github.com/nlohmann/json/issues/1445)
- Setting values of .JSON file [\#1444](https://github.com/nlohmann/json/issues/1444)
- alias object\_t::key\_type in basic\_json [\#1442](https://github.com/nlohmann/json/issues/1442)
- Latest Ubuntu package is 2.1.1 [\#1438](https://github.com/nlohmann/json/issues/1438)
- lexer.hpp\(1363\)  '\_snprintf': is not a  member | Visualstudio 2017 [\#1437](https://github.com/nlohmann/json/issues/1437)
- Static method invites inadvertent logic error. [\#1433](https://github.com/nlohmann/json/issues/1433)
- EOS compilation produces "fatal error: 'nlohmann/json.hpp' file not found" [\#1432](https://github.com/nlohmann/json/issues/1432)
- Support for bad commas [\#1429](https://github.com/nlohmann/json/issues/1429)
- Please have one base exception class for all json exceptions [\#1427](https://github.com/nlohmann/json/issues/1427)
- Compilation warning: 'tuple\_size' defined as a class template here but previously declared as a struct template [\#1426](https://github.com/nlohmann/json/issues/1426)
- Which version can be used with GCC 4.8.2 ? [\#1424](https://github.com/nlohmann/json/issues/1424)
- Ignore nullptr values on constructing json object from a container [\#1422](https://github.com/nlohmann/json/issues/1422)
- Support for custom float precision via unquoted strings [\#1421](https://github.com/nlohmann/json/issues/1421)
- It is possible to call `json::find` with a json\_pointer as argument. This causes runtime UB/crash. [\#1418](https://github.com/nlohmann/json/issues/1418)
- Dump throwing exception [\#1416](https://github.com/nlohmann/json/issues/1416)
- Build error  [\#1415](https://github.com/nlohmann/json/issues/1415)
- Append version to include.zip [\#1412](https://github.com/nlohmann/json/issues/1412)
- error C2039: '\_snprintf': is not a member of 'std' - Windows [\#1408](https://github.com/nlohmann/json/issues/1408)
- Deserializing to vector [\#1407](https://github.com/nlohmann/json/issues/1407)
- Efficient way to set a `json` object as value into another `json` key [\#1406](https://github.com/nlohmann/json/issues/1406)
- Document return value of parse\(\) when allow\_exceptions == false and parsing fails [\#1405](https://github.com/nlohmann/json/issues/1405)
- Unexpected behaviour with structured binding [\#1404](https://github.com/nlohmann/json/issues/1404)
- Which native types does get\<type\>\(\) allow? [\#1403](https://github.com/nlohmann/json/issues/1403)
- Add something like Json::StaticString [\#1402](https://github.com/nlohmann/json/issues/1402)
- -Wmismatched-tags in 3.5.0? [\#1401](https://github.com/nlohmann/json/issues/1401)
- Coverity Scan reports an UNCAUGHT\_EXCEPT issue [\#1400](https://github.com/nlohmann/json/issues/1400)
- fff [\#1399](https://github.com/nlohmann/json/issues/1399)
- sorry this is not an issue, just a Question, How to change a key value in a file and save it ? [\#1398](https://github.com/nlohmann/json/issues/1398)
- appveyor x64 builds appear to be using Win32 toolset [\#1374](https://github.com/nlohmann/json/issues/1374)
- Serializing/Deserializing  a Class containing a vector of itself [\#1373](https://github.com/nlohmann/json/issues/1373)
- Retrieving array elements. [\#1369](https://github.com/nlohmann/json/issues/1369)
- Deserialize [\#1366](https://github.com/nlohmann/json/issues/1366)
- call of overloaded for push\_back and operator+= is ambiguous [\#1352](https://github.com/nlohmann/json/issues/1352)
- got an error and cann't figure it out [\#1351](https://github.com/nlohmann/json/issues/1351)
- Improve number-to-string conversion [\#1334](https://github.com/nlohmann/json/issues/1334)
- Implicit type conversion error on MSVC [\#1333](https://github.com/nlohmann/json/issues/1333)
- NuGet Package [\#1132](https://github.com/nlohmann/json/issues/1132)

- Change macros to numeric\_limits [\#1514](https://github.com/nlohmann/json/pull/1514) ([naszta](https://github.com/naszta))
- fix GCC 7.1.1 - 7.2.1 on CentOS [\#1496](https://github.com/nlohmann/json/pull/1496) ([lieff](https://github.com/lieff))
- Update Buckaroo instructions in README.md [\#1495](https://github.com/nlohmann/json/pull/1495) ([njlr](https://github.com/njlr))
- Fix gcc9 build error test/src/unit-allocator.cpp \(Issue \#1472\) [\#1492](https://github.com/nlohmann/json/pull/1492) ([stac47](https://github.com/stac47))
- Fix typo in README.md [\#1491](https://github.com/nlohmann/json/pull/1491) ([nickaein](https://github.com/nickaein))
- Do proper endian conversions [\#1489](https://github.com/nlohmann/json/pull/1489) ([andreas-schwab](https://github.com/andreas-schwab))
- Fix documentation [\#1477](https://github.com/nlohmann/json/pull/1477) ([nickaein](https://github.com/nickaein))
- Implement contains\(\) member function [\#1474](https://github.com/nlohmann/json/pull/1474) ([nickaein](https://github.com/nickaein))
- Add operator/= and operator/ to construct a JSON pointer by appending two JSON pointers [\#1469](https://github.com/nlohmann/json/pull/1469) ([garethsb](https://github.com/garethsb))
- Disable Clang -Wmismatched-tags warning on tuple\_size / tuple\_element [\#1468](https://github.com/nlohmann/json/pull/1468) ([past-due](https://github.com/past-due))
- Disable installation when used as meson subproject. \#1463 [\#1464](https://github.com/nlohmann/json/pull/1464) ([elvisoric](https://github.com/elvisoric))
- docs: README typo [\#1455](https://github.com/nlohmann/json/pull/1455) ([wythe](https://github.com/wythe))
- remove extra semicolon from readme [\#1451](https://github.com/nlohmann/json/pull/1451) ([Afforix](https://github.com/Afforix))
- attempt to fix \#1445, flush buffer in serializer::dump\_escaped in UTF8\_REJECT case. [\#1446](https://github.com/nlohmann/json/pull/1446) ([scinart](https://github.com/scinart))
- Use C++11 features supported by CMake 3.1. [\#1441](https://github.com/nlohmann/json/pull/1441) ([iwanders](https://github.com/iwanders))
- :rotating\_light: fixed unused variable warning [\#1435](https://github.com/nlohmann/json/pull/1435) ([pboettch](https://github.com/pboettch))
- allow push\_back\(\) and pop\_back\(\) calls on json\_pointer [\#1434](https://github.com/nlohmann/json/pull/1434) ([pboettch](https://github.com/pboettch))
- Add instructions about using nlohmann/json with the conda package manager [\#1430](https://github.com/nlohmann/json/pull/1430) ([nicoddemus](https://github.com/nicoddemus))
- Updated year in README.md [\#1425](https://github.com/nlohmann/json/pull/1425) ([jef](https://github.com/jef))
- Fixed broken links in the README file [\#1423](https://github.com/nlohmann/json/pull/1423) ([skypjack](https://github.com/skypjack))
- Fixed broken links in the README file [\#1420](https://github.com/nlohmann/json/pull/1420) ([skypjack](https://github.com/skypjack))
- docs: typo in README [\#1417](https://github.com/nlohmann/json/pull/1417) ([wythe](https://github.com/wythe))
- Fix x64 target platform for appveyor [\#1414](https://github.com/nlohmann/json/pull/1414) ([nickaein](https://github.com/nickaein))
- Improve dump\_integer performance [\#1411](https://github.com/nlohmann/json/pull/1411) ([nickaein](https://github.com/nickaein))
- buildsystem: relax requirement on cmake version [\#1409](https://github.com/nlohmann/json/pull/1409) ([yann-morin-1998](https://github.com/yann-morin-1998))
- CMake: Optional Install if Embedded [\#1330](https://github.com/nlohmann/json/pull/1330) ([ax3l](https://github.com/ax3l))

## [v3.5.0](https://github.com/nlohmann/json/releases/tag/v3.5.0) (2018-12-21)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.4.0...v3.5.0)

- Copyconstructor inserts original into array with single element [\#1397](https://github.com/nlohmann/json/issues/1397)
- Get value without explicit typecasting [\#1395](https://github.com/nlohmann/json/issues/1395)
- Big file parsing [\#1393](https://github.com/nlohmann/json/issues/1393)
- Adding Structured Binding Support [\#1388](https://github.com/nlohmann/json/issues/1388)
- map\<json::value\_t, string\> exhibits unexpected behavior [\#1387](https://github.com/nlohmann/json/issues/1387)
- Error Code Return [\#1386](https://github.com/nlohmann/json/issues/1386)
- using unordered\_map as object type [\#1385](https://github.com/nlohmann/json/issues/1385)
- float precision [\#1384](https://github.com/nlohmann/json/issues/1384)
- \[json.exception.type\_error.316\] invalid UTF-8 byte at index 1: 0xC3 [\#1383](https://github.com/nlohmann/json/issues/1383)
- Inconsistent Constructor \(GCC vs. Clang\) [\#1381](https://github.com/nlohmann/json/issues/1381)
- \#define or || [\#1379](https://github.com/nlohmann/json/issues/1379)
- How to iterate inside the values ? [\#1377](https://github.com/nlohmann/json/issues/1377)
- items\(\) unable to get the elements [\#1375](https://github.com/nlohmann/json/issues/1375)
- conversion json to std::map doesn't work for types \<int, double\>  [\#1372](https://github.com/nlohmann/json/issues/1372)
- A minor issue in the build instructions [\#1371](https://github.com/nlohmann/json/issues/1371)
- Using this library without stream ? [\#1370](https://github.com/nlohmann/json/issues/1370)
- Writing and reading BSON data [\#1368](https://github.com/nlohmann/json/issues/1368)
- Retrieving array elements from object type iterator. [\#1367](https://github.com/nlohmann/json/issues/1367)
- json::dump\(\) silently crashes if items contain accented letters [\#1365](https://github.com/nlohmann/json/issues/1365)
- warnings in MSVC \(2015\) in 3.4.0 related to bool... [\#1364](https://github.com/nlohmann/json/issues/1364)
- Cant compile with -C++17 and beyond compiler options [\#1362](https://github.com/nlohmann/json/issues/1362)
- json to concrete type conversion through reference or pointer fails [\#1361](https://github.com/nlohmann/json/issues/1361)
- the first attributes of JSON string is misplaced  [\#1360](https://github.com/nlohmann/json/issues/1360)
- Copy-construct using initializer-list converts objects to arrays [\#1359](https://github.com/nlohmann/json/issues/1359)
- About value\(key, default\_value\) and operator\[\]\(key\)  [\#1358](https://github.com/nlohmann/json/issues/1358)
- Problem with printing json response object [\#1356](https://github.com/nlohmann/json/issues/1356)
- Serializing pointer segfaults [\#1355](https://github.com/nlohmann/json/issues/1355)
- Read `long long int` data as a number. [\#1354](https://github.com/nlohmann/json/issues/1354)
- eclipse oxygen in ubuntu get\<size\_t\> is ambiguous  [\#1353](https://github.com/nlohmann/json/issues/1353)
- Can't build on Visual Studio 2017 v15.8.9 [\#1350](https://github.com/nlohmann/json/issues/1350)
- cannot parse from string? [\#1349](https://github.com/nlohmann/json/issues/1349)
- Error: out\_of\_range [\#1348](https://github.com/nlohmann/json/issues/1348)
- expansion pattern 'CompatibleObjectType' contains no argument packs, with CUDA 10 [\#1347](https://github.com/nlohmann/json/issues/1347)
- Unable to update a value for a nested\(multi-level\) json file [\#1344](https://github.com/nlohmann/json/issues/1344)
- Fails to compile when std::iterator\_traits is not SFINAE friendly. [\#1341](https://github.com/nlohmann/json/issues/1341)
- EOF flag not set on exhausted input streams. [\#1340](https://github.com/nlohmann/json/issues/1340)
- Shadowed Member in merge\_patch [\#1339](https://github.com/nlohmann/json/issues/1339)
- Periods/literal dots in keys? [\#1338](https://github.com/nlohmann/json/issues/1338)
- Protect macro expansion of commonly defined macros [\#1337](https://github.com/nlohmann/json/issues/1337)
- How to validate an input before parsing? [\#1336](https://github.com/nlohmann/json/issues/1336)
- Non-verifying dump\(\) alternative for debugging/logging needed [\#1335](https://github.com/nlohmann/json/issues/1335)
- Json Libarary is not responding for me in c++ [\#1332](https://github.com/nlohmann/json/issues/1332)
- Question - how to find an object in an array [\#1331](https://github.com/nlohmann/json/issues/1331)
- Nesting additional data in json object [\#1328](https://github.com/nlohmann/json/issues/1328)
- can to\_json\(\) be defined inside a class? [\#1324](https://github.com/nlohmann/json/issues/1324)
- CodeBlocks IDE can't find `json.hpp` header [\#1318](https://github.com/nlohmann/json/issues/1318)
- Change json\_pointer to provide an iterator begin/end/etc, don't use vectors, and also enable string\_view [\#1312](https://github.com/nlohmann/json/issues/1312)
- Xcode - adding it to library  [\#1300](https://github.com/nlohmann/json/issues/1300)
- unicode: accept char16\_t, char32\_t sequences [\#1298](https://github.com/nlohmann/json/issues/1298)
- unicode: char16\_t\* is compiler error, but char16\_t\[\] is accepted [\#1297](https://github.com/nlohmann/json/issues/1297)
- Dockerfile Project Help Needed [\#1296](https://github.com/nlohmann/json/issues/1296)
- Comparisons between large unsigned and negative signed integers [\#1295](https://github.com/nlohmann/json/issues/1295)
- CMake alias to `nlohmann::json` [\#1291](https://github.com/nlohmann/json/issues/1291)
- Release zips without tests [\#1285](https://github.com/nlohmann/json/issues/1285)
- separate object\_t::key\_type from basic\_json::key\_type, and use an allocator which returns object\_t::key\_type [\#1274](https://github.com/nlohmann/json/issues/1274)
- Is there a nice way to associate external values with json elements? [\#1256](https://github.com/nlohmann/json/issues/1256)
- Delete by json\_pointer [\#1248](https://github.com/nlohmann/json/issues/1248)
- Expose lexer, as a StAX parser [\#1219](https://github.com/nlohmann/json/issues/1219)
- Subclassing json\(\) & error on recursive load [\#1201](https://github.com/nlohmann/json/issues/1201)
- Check value for existence by json\_pointer [\#1194](https://github.com/nlohmann/json/issues/1194)

- Feature/add file input adapter [\#1392](https://github.com/nlohmann/json/pull/1392) ([dumarjo](https://github.com/dumarjo))
-  Added Support for Structured Bindings  [\#1391](https://github.com/nlohmann/json/pull/1391) ([pratikpc](https://github.com/pratikpc))
- Link to issue \#958 broken [\#1382](https://github.com/nlohmann/json/pull/1382) ([kjpus](https://github.com/kjpus))
- readme: fix typo [\#1380](https://github.com/nlohmann/json/pull/1380) ([manu-chroma](https://github.com/manu-chroma))
- recommend using explicit from JSON conversions [\#1363](https://github.com/nlohmann/json/pull/1363) ([theodelrieu](https://github.com/theodelrieu))
- Fix merge\_patch shadow warning [\#1346](https://github.com/nlohmann/json/pull/1346) ([ax3l](https://github.com/ax3l))
- Allow installation via Meson [\#1345](https://github.com/nlohmann/json/pull/1345) ([mpoquet](https://github.com/mpoquet))
- Set eofbit on exhausted input stream. [\#1343](https://github.com/nlohmann/json/pull/1343) ([mefyl](https://github.com/mefyl))
- Add a SFINAE friendly iterator\_traits and use that instead. [\#1342](https://github.com/nlohmann/json/pull/1342) ([dgavedissian](https://github.com/dgavedissian))
- Fix EOL Whitespaces & CMake Spelling [\#1329](https://github.com/nlohmann/json/pull/1329) ([ax3l](https://github.com/ax3l))

## [v3.4.0](https://github.com/nlohmann/json/releases/tag/v3.4.0) (2018-10-30)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.3.0...v3.4.0)

- Big uint64\_t values are serialized wrong [\#1327](https://github.com/nlohmann/json/issues/1327)
- \[Question\] Efficient check for equivalency? [\#1325](https://github.com/nlohmann/json/issues/1325)
- Can't use ifstream and .clear\(\) [\#1321](https://github.com/nlohmann/json/issues/1321)
- \[Warning\] -Wparentheses on line 555 on single\_include [\#1319](https://github.com/nlohmann/json/issues/1319)
- Compilation error using at and find with enum struct [\#1316](https://github.com/nlohmann/json/issues/1316)
- Parsing JSON from a web address [\#1311](https://github.com/nlohmann/json/issues/1311)
- How to convert JSON to Struct with embeded subject [\#1310](https://github.com/nlohmann/json/issues/1310)
- Null safety/coalescing function? [\#1309](https://github.com/nlohmann/json/issues/1309)
- Building fails using single include file: json.hpp [\#1308](https://github.com/nlohmann/json/issues/1308)
- json::parse\(std::string\) Exception inside packaged Lib [\#1306](https://github.com/nlohmann/json/issues/1306)
- Problem in Dockerfile with installation of library [\#1304](https://github.com/nlohmann/json/issues/1304)
- compile error in from\_json converting to container with std::pair [\#1299](https://github.com/nlohmann/json/issues/1299)
- Json that I am trying to parse, and I am lost Structure Array below top level [\#1293](https://github.com/nlohmann/json/issues/1293)
- Serializing std::variant causes stack overflow [\#1292](https://github.com/nlohmann/json/issues/1292)
- How do I go about customising from\_json to support \_\_int128\_t/\_\_uint128\_t? [\#1290](https://github.com/nlohmann/json/issues/1290)
- merge\_patch: inconsistent behaviour merging empty sub-object [\#1289](https://github.com/nlohmann/json/issues/1289)
- Buffer over/underrun using UBJson? [\#1288](https://github.com/nlohmann/json/issues/1288)
- Enable the latest C++ standard with Visual Studio [\#1287](https://github.com/nlohmann/json/issues/1287)
- truncation of constant value in to\_cbor\(\) [\#1286](https://github.com/nlohmann/json/issues/1286)
- eosio.wasmsdk error [\#1284](https://github.com/nlohmann/json/issues/1284)
- use the same interface for writing arrays and non-arrays [\#1283](https://github.com/nlohmann/json/issues/1283)
- How to read json file with optional  entries and entries with different types [\#1281](https://github.com/nlohmann/json/issues/1281)
- merge result not as espected [\#1279](https://github.com/nlohmann/json/issues/1279)
- how to get only "name" from below json [\#1278](https://github.com/nlohmann/json/issues/1278)
- syntax error  on right json string [\#1276](https://github.com/nlohmann/json/issues/1276)
- Parsing JSON Array where members have no key, using custom types [\#1267](https://github.com/nlohmann/json/issues/1267)
- I get a json exception periodically from json::parse for the same json  [\#1263](https://github.com/nlohmann/json/issues/1263)
- GCC 8.2.1. Compilation error: invalid conversion from... [\#1246](https://github.com/nlohmann/json/issues/1246)
- BSON support [\#1244](https://github.com/nlohmann/json/issues/1244)
- enum to json mapping [\#1208](https://github.com/nlohmann/json/issues/1208)
- Soften the landing when dumping non-UTF8 strings \(type\_error.316 exception\) [\#1198](https://github.com/nlohmann/json/issues/1198)

- Add macro to define enum/JSON mapping [\#1323](https://github.com/nlohmann/json/pull/1323) ([nlohmann](https://github.com/nlohmann))
- Add BSON support [\#1320](https://github.com/nlohmann/json/pull/1320) ([nlohmann](https://github.com/nlohmann))
- Properly convert constants to CharType [\#1315](https://github.com/nlohmann/json/pull/1315) ([nlohmann](https://github.com/nlohmann))
- Allow to set error handler for decoding errors [\#1314](https://github.com/nlohmann/json/pull/1314) ([nlohmann](https://github.com/nlohmann))
- Add Meson related info to README [\#1305](https://github.com/nlohmann/json/pull/1305) ([koponomarenko](https://github.com/koponomarenko))
- Improve diagnostic messages for binary formats [\#1303](https://github.com/nlohmann/json/pull/1303) ([nlohmann](https://github.com/nlohmann))
- add new is\_constructible\_\* traits used in from\_json [\#1301](https://github.com/nlohmann/json/pull/1301) ([theodelrieu](https://github.com/theodelrieu))
- add constraints for variadic json\_ref constructors [\#1294](https://github.com/nlohmann/json/pull/1294) ([theodelrieu](https://github.com/theodelrieu))
- Improve diagnostic messages [\#1282](https://github.com/nlohmann/json/pull/1282) ([nlohmann](https://github.com/nlohmann))
- Removed linter warnings [\#1280](https://github.com/nlohmann/json/pull/1280) ([nlohmann](https://github.com/nlohmann))
- Thirdparty benchmark: Fix Clang detection. [\#1277](https://github.com/nlohmann/json/pull/1277) ([Lord-Kamina](https://github.com/Lord-Kamina))

## [v3.3.0](https://github.com/nlohmann/json/releases/tag/v3.3.0) (2018-10-05)

[Full Changelog](https://github.com/nlohmann/json/compare/3.3.0...v3.3.0)

## [3.3.0](https://github.com/nlohmann/json/releases/tag/3.3.0) (2018-10-05)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.2.0...3.3.0)

- When key is not found print the key name into error too [\#1273](https://github.com/nlohmann/json/issues/1273)
- Visual Studio 2017 15.8.5 "conditional expression is constant" warning on Line 1851 in json.hpp [\#1268](https://github.com/nlohmann/json/issues/1268)
- how can we get this working on WSL? [\#1264](https://github.com/nlohmann/json/issues/1264)
- Help needed [\#1259](https://github.com/nlohmann/json/issues/1259)
- A way to get to a JSON values "key" [\#1258](https://github.com/nlohmann/json/issues/1258)
- While compiling got 76 errors [\#1255](https://github.com/nlohmann/json/issues/1255)
- Two blackslashes on json output file [\#1253](https://github.com/nlohmann/json/issues/1253)
- Including nlohmann the badwrong way. [\#1250](https://github.com/nlohmann/json/issues/1250)
- how to build with clang? [\#1247](https://github.com/nlohmann/json/issues/1247)
- Cmake target\_link\_libraries unable to find nlohmann\_json since version 3.2.0 [\#1243](https://github.com/nlohmann/json/issues/1243)
- \[Question\] Access to end\(\) iterator reference [\#1242](https://github.com/nlohmann/json/issues/1242)
- Parsing different json format [\#1241](https://github.com/nlohmann/json/issues/1241)
- Parsing Multiple JSON Files [\#1240](https://github.com/nlohmann/json/issues/1240)
- Doesn't compile under C++17 [\#1239](https://github.com/nlohmann/json/issues/1239)
- Conversion operator for nlohmann::json is not SFINAE friendly [\#1237](https://github.com/nlohmann/json/issues/1237)
- Custom deserialization of number\_float\_t [\#1236](https://github.com/nlohmann/json/issues/1236)
- deprecated-declarations warnings when compiling tests with GCC 8.2.1. [\#1233](https://github.com/nlohmann/json/issues/1233)
- Incomplete type with json\_fwd.hpp [\#1232](https://github.com/nlohmann/json/issues/1232)
- Parse Error [\#1229](https://github.com/nlohmann/json/issues/1229)
- json::get function with argument [\#1227](https://github.com/nlohmann/json/issues/1227)
- questions regarding from\_json [\#1226](https://github.com/nlohmann/json/issues/1226)
- Lambda in unevaluated context [\#1225](https://github.com/nlohmann/json/issues/1225)
- NLohmann doesn't compile when enabling strict warning policies [\#1224](https://github.com/nlohmann/json/issues/1224)
- Creating array of objects [\#1223](https://github.com/nlohmann/json/issues/1223)
- Somewhat unhelpful error message "cannot use operator\[\] with object" [\#1220](https://github.com/nlohmann/json/issues/1220)
- single\_include json.hpp [\#1218](https://github.com/nlohmann/json/issues/1218)
- Maps with enum class keys which are convertible to JSON strings should be converted to JSON dictionaries [\#1217](https://github.com/nlohmann/json/issues/1217)
- Adding JSON Array to the Array  [\#1216](https://github.com/nlohmann/json/issues/1216)
- Best way to output a vector of a given type to json [\#1215](https://github.com/nlohmann/json/issues/1215)
- compiler warning: double definition of macro JSON\_INTERNAL\_CATCH  [\#1213](https://github.com/nlohmann/json/issues/1213)
- Compilation error when using MOCK\_METHOD1 from GMock and nlohmann::json [\#1212](https://github.com/nlohmann/json/issues/1212)
- Issues parsing a previously encoded binary \(non-UTF8\) string. [\#1211](https://github.com/nlohmann/json/issues/1211)
- Yet another ordering question: char \* and parse\(\) [\#1209](https://github.com/nlohmann/json/issues/1209)
- Error using gcc 8.1.0 on Ubuntu 14.04 [\#1207](https://github.com/nlohmann/json/issues/1207)
- "type must be string, but is " std::string\(j.type\_name\(\)  [\#1206](https://github.com/nlohmann/json/issues/1206)
- Returning empty json object from a function of type const json& ? [\#1205](https://github.com/nlohmann/json/issues/1205)
- VS2017 compiler suggests using constexpr if [\#1204](https://github.com/nlohmann/json/issues/1204)
- Template instatiation error on compiling [\#1203](https://github.com/nlohmann/json/issues/1203)
- BUG - json dump field with unicode -\> array of ints \(instead of string\) [\#1197](https://github.com/nlohmann/json/issues/1197)
- Compile error using Code::Blocks // mingw-w64 GCC 8.1.0 - "Incomplete Type" [\#1193](https://github.com/nlohmann/json/issues/1193)
- SEGFAULT on arm target  [\#1190](https://github.com/nlohmann/json/issues/1190)
- Compiler crash with old Clang [\#1179](https://github.com/nlohmann/json/issues/1179)
- Custom Precision on floating point numbers [\#1170](https://github.com/nlohmann/json/issues/1170)
- Can we have a json\_view class like std::string\_view? [\#1158](https://github.com/nlohmann/json/issues/1158)
- improve error handling [\#1152](https://github.com/nlohmann/json/issues/1152)
- We should remove static\_asserts [\#960](https://github.com/nlohmann/json/issues/960)

- Fix warning C4127: conditional expression is constant [\#1272](https://github.com/nlohmann/json/pull/1272) ([antonioborondo](https://github.com/antonioborondo))
- Turn off additional deprecation warnings for GCC. [\#1271](https://github.com/nlohmann/json/pull/1271) ([chuckatkins](https://github.com/chuckatkins))
- docs: Add additional CMake documentation [\#1270](https://github.com/nlohmann/json/pull/1270) ([chuckatkins](https://github.com/chuckatkins))
- unit-testsuites.cpp: fix hangup if file not found [\#1262](https://github.com/nlohmann/json/pull/1262) ([knilch0r](https://github.com/knilch0r))
- Fix broken cmake imported target alias [\#1260](https://github.com/nlohmann/json/pull/1260) ([chuckatkins](https://github.com/chuckatkins))
- GCC 48 [\#1257](https://github.com/nlohmann/json/pull/1257) ([henryiii](https://github.com/henryiii))
- Add version and license to meson.build [\#1252](https://github.com/nlohmann/json/pull/1252) ([koponomarenko](https://github.com/koponomarenko))
- \#1179 Reordered the code. It seems to stop clang 3.4.2 in RHEL 7 from crash… [\#1249](https://github.com/nlohmann/json/pull/1249) ([LEgregius](https://github.com/LEgregius))
- Use a version check to provide backwards comatible CMake imported target names [\#1245](https://github.com/nlohmann/json/pull/1245) ([chuckatkins](https://github.com/chuckatkins))
- Fix issue \#1237 [\#1238](https://github.com/nlohmann/json/pull/1238) ([theodelrieu](https://github.com/theodelrieu))
- Add a get overload taking a parameter. [\#1231](https://github.com/nlohmann/json/pull/1231) ([theodelrieu](https://github.com/theodelrieu))
- Move lambda out of unevaluated context [\#1230](https://github.com/nlohmann/json/pull/1230) ([mandreyel](https://github.com/mandreyel))
- Remove static asserts [\#1228](https://github.com/nlohmann/json/pull/1228) ([theodelrieu](https://github.com/theodelrieu))
- Better error 305 [\#1221](https://github.com/nlohmann/json/pull/1221) ([rivertam](https://github.com/rivertam))
- Fix \#1213 [\#1214](https://github.com/nlohmann/json/pull/1214) ([simnalamburt](https://github.com/simnalamburt))
- Export package to allow builds without installing [\#1202](https://github.com/nlohmann/json/pull/1202) ([dennisfischer](https://github.com/dennisfischer))

## [v3.2.0](https://github.com/nlohmann/json/releases/tag/v3.2.0) (2018-08-20)

[Full Changelog](https://github.com/nlohmann/json/compare/3.2.0...v3.2.0)

## [3.2.0](https://github.com/nlohmann/json/releases/tag/3.2.0) (2018-08-20)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.1.2...3.2.0)

- Am I doing this wrong? Getting an empty string [\#1199](https://github.com/nlohmann/json/issues/1199)
- Incompatible Pointer Type [\#1196](https://github.com/nlohmann/json/issues/1196)
- json.exception.type\_error.316 [\#1195](https://github.com/nlohmann/json/issues/1195)
- Strange warnings in Code::Blocks 17.12, GNU GCC [\#1192](https://github.com/nlohmann/json/issues/1192)
- \[Question\] Current place in code to change floating point resolution [\#1191](https://github.com/nlohmann/json/issues/1191)
- Add key name when throwing type error [\#1189](https://github.com/nlohmann/json/issues/1189)
- Not able to include in visual studio code? [\#1188](https://github.com/nlohmann/json/issues/1188)
- Get an Index or row number of an element [\#1186](https://github.com/nlohmann/json/issues/1186)
- Difference between `merge_patch` and `update` [\#1183](https://github.com/nlohmann/json/issues/1183)
- Is there a way to get an element from a JSON without throwing an exception on failure? [\#1182](https://github.com/nlohmann/json/issues/1182)
- to\_string? [\#1181](https://github.com/nlohmann/json/issues/1181)
- How to cache a json object's pointer into a map? [\#1180](https://github.com/nlohmann/json/issues/1180)
- Can this library work within a Qt project for Android using Qt Creator? [\#1178](https://github.com/nlohmann/json/issues/1178)
- How to get all keys of one object? [\#1177](https://github.com/nlohmann/json/issues/1177)
- How can I only parse the first level and get the value as string? [\#1175](https://github.com/nlohmann/json/issues/1175)
- I have a query regarding nlohmann::basic\_json::basic\_json [\#1174](https://github.com/nlohmann/json/issues/1174)
- unordered\_map with vectors won't convert to json? [\#1173](https://github.com/nlohmann/json/issues/1173)
- return json objects from functions [\#1172](https://github.com/nlohmann/json/issues/1172)
- Problem when exporting to CBOR [\#1171](https://github.com/nlohmann/json/issues/1171)
- Roundtripping null to nullptr does not work [\#1169](https://github.com/nlohmann/json/issues/1169)
- MSVC fails to compile std::swap specialization for nlohmann::json [\#1168](https://github.com/nlohmann/json/issues/1168)
- Unexpected behaviour of is\_null - Part II [\#1167](https://github.com/nlohmann/json/issues/1167)
- Floating point imprecision [\#1166](https://github.com/nlohmann/json/issues/1166)
- Combine json objects into one? [\#1165](https://github.com/nlohmann/json/issues/1165)
- Is there any way to know if the object has changed? [\#1164](https://github.com/nlohmann/json/issues/1164)
- Value throws on null string [\#1163](https://github.com/nlohmann/json/issues/1163)
- Weird template issue in large project [\#1162](https://github.com/nlohmann/json/issues/1162)
- \_json returns a different result vs ::parse [\#1161](https://github.com/nlohmann/json/issues/1161)
- Showing difference between two json objects [\#1160](https://github.com/nlohmann/json/issues/1160)
- no instance of overloaded function "std::swap" matches the specified type	 [\#1159](https://github.com/nlohmann/json/issues/1159)
- resize\(...\)? [\#1157](https://github.com/nlohmann/json/issues/1157)
- Issue with struct nested in class' to\_json [\#1155](https://github.com/nlohmann/json/issues/1155)
- Deserialize std::map with std::nan [\#1154](https://github.com/nlohmann/json/issues/1154)
- Parse throwing errors [\#1149](https://github.com/nlohmann/json/issues/1149)
- cocoapod integration [\#1148](https://github.com/nlohmann/json/issues/1148)
- wstring parsing [\#1147](https://github.com/nlohmann/json/issues/1147)
- Is it possible to dump a two-dimensional array to "\[\[null\],\[1,2,3\]\]"? [\#1146](https://github.com/nlohmann/json/issues/1146)
- Want to write a class member variable and a struct variable \( this structure is inside the class\) to the json file [\#1145](https://github.com/nlohmann/json/issues/1145)
- Does json support converting an instance of a struct into json string? [\#1143](https://github.com/nlohmann/json/issues/1143)
- \#Most efficient way to search for child parameters \(recursive find?\) [\#1141](https://github.com/nlohmann/json/issues/1141)
-  could not find to\_json\(\) method in T's namespace [\#1140](https://github.com/nlohmann/json/issues/1140)
- chars get treated as JSON numbers not JSON strings [\#1139](https://github.com/nlohmann/json/issues/1139)
- How do I count number of objects in array? [\#1137](https://github.com/nlohmann/json/issues/1137)
- Serializing a vector of classes? [\#1136](https://github.com/nlohmann/json/issues/1136)
- Compile error. Unable convert form nullptr to nullptr&& [\#1135](https://github.com/nlohmann/json/issues/1135)
- std::unordered\_map in struct, serialization [\#1133](https://github.com/nlohmann/json/issues/1133)
- dump\(\) can't handle umlauts [\#1131](https://github.com/nlohmann/json/issues/1131)
- Add a way to get a key reference from the iterator [\#1127](https://github.com/nlohmann/json/issues/1127)
- can't not parse "\\“ string [\#1123](https://github.com/nlohmann/json/issues/1123)
-  if  json file  contain Internationalization   chars   ,  get  exception [\#1122](https://github.com/nlohmann/json/issues/1122)
- How to use a json::iterator dereferenced value in code? [\#1120](https://github.com/nlohmann/json/issues/1120)
- Disable implicit conversions from json to std::initializer\_list\<T\> for any T [\#1118](https://github.com/nlohmann/json/issues/1118)
- Implicit conversions to complex types can lead to surprising and confusing errors [\#1116](https://github.com/nlohmann/json/issues/1116)
- How can I write from\_json for a complex datatype that is not default constructible? [\#1115](https://github.com/nlohmann/json/issues/1115)
- Compile error in VS2015 when compiling unit-conversions.cpp [\#1114](https://github.com/nlohmann/json/issues/1114)
- ADL Serializer for std::any / boost::any [\#1113](https://github.com/nlohmann/json/issues/1113)
- Unexpected behaviour of is\_null [\#1112](https://github.com/nlohmann/json/issues/1112)
- How to resolve  " undefined reference to `std::\_\_throw\_bad\_cast\(\)'" [\#1111](https://github.com/nlohmann/json/issues/1111)
- cannot compile on ubuntu 18.04 and 16.04 [\#1110](https://github.com/nlohmann/json/issues/1110)
- JSON representation for floating point values has too many digits [\#1109](https://github.com/nlohmann/json/issues/1109)
- Not working for classes containing "\_declspec\(dllimport\)" in their declaration [\#1108](https://github.com/nlohmann/json/issues/1108)
- Get keys from json object [\#1107](https://github.com/nlohmann/json/issues/1107)
- Cannot deserialize types using std::ratio [\#1105](https://github.com/nlohmann/json/issues/1105)
-  i want to learn json [\#1104](https://github.com/nlohmann/json/issues/1104)
- Type checking during compile [\#1103](https://github.com/nlohmann/json/issues/1103)
- Iterate through sub items [\#1102](https://github.com/nlohmann/json/issues/1102)
- cppcheck failing for version 3.1.2 [\#1101](https://github.com/nlohmann/json/issues/1101)
- Deserializing std::map [\#1100](https://github.com/nlohmann/json/issues/1100)
- accessing key by reference [\#1098](https://github.com/nlohmann/json/issues/1098)
- clang 3.8.0 croaks while trying to compile with debug symbols [\#1097](https://github.com/nlohmann/json/issues/1097)
- Serialize a list of class objects with json [\#1096](https://github.com/nlohmann/json/issues/1096)
- Small question [\#1094](https://github.com/nlohmann/json/issues/1094)
- Upgrading to 3.x: to\_/from\_json with enum class [\#1093](https://github.com/nlohmann/json/issues/1093)
- Q: few questions about json construction [\#1092](https://github.com/nlohmann/json/issues/1092)
- general crayCC compilation failure [\#1091](https://github.com/nlohmann/json/issues/1091)
- Merge Patch clears original data [\#1090](https://github.com/nlohmann/json/issues/1090)
- \[Question\] how to use nlohmann/json in c++? [\#1088](https://github.com/nlohmann/json/issues/1088)
- C++17 decomposition declaration support [\#1087](https://github.com/nlohmann/json/issues/1087)
- \[Question\] Access multi-level json objects [\#1086](https://github.com/nlohmann/json/issues/1086)
- Serializing vector [\#1085](https://github.com/nlohmann/json/issues/1085)
- update nested value in multi hierarchy json object [\#1084](https://github.com/nlohmann/json/issues/1084)
- Overriding default values? [\#1083](https://github.com/nlohmann/json/issues/1083)
- detail namespace collision with Cereal? [\#1082](https://github.com/nlohmann/json/issues/1082)
- Error using json.dump\(\); [\#1081](https://github.com/nlohmann/json/issues/1081)
- Consuming TCP Stream [\#1080](https://github.com/nlohmann/json/issues/1080)
- Compilation error with strong typed enums in map in combination with namespaces [\#1079](https://github.com/nlohmann/json/issues/1079)
- cassert error [\#1076](https://github.com/nlohmann/json/issues/1076)
- Valid json data not being parsed [\#1075](https://github.com/nlohmann/json/issues/1075)
- Feature request :: Better testing for key existance without try/catch [\#1074](https://github.com/nlohmann/json/issues/1074)
- Hi, I have input like a.b.c and want to convert it to \"a\"{\"b\": \"c\"} form. Any suggestions how do I do this? Thanks. [\#1073](https://github.com/nlohmann/json/issues/1073)
- ADL deserializer not picked up for non default-constructible type [\#1072](https://github.com/nlohmann/json/issues/1072)
- Deserializing std::array doesn't compiler \(no insert\(\)\) [\#1071](https://github.com/nlohmann/json/issues/1071)
- Serializing OpenCV Mat problem [\#1070](https://github.com/nlohmann/json/issues/1070)
- Compilation error with ICPC compiler [\#1068](https://github.com/nlohmann/json/issues/1068)
- Not existing value, crash [\#1065](https://github.com/nlohmann/json/issues/1065)
- cyryllic symbols [\#1064](https://github.com/nlohmann/json/issues/1064)
- newbie usage question [\#1063](https://github.com/nlohmann/json/issues/1063)
- Trying j\["strTest"\] = "%A" produces "strTest": "-0X1.CCCCCCCCCCCCCP+205" [\#1062](https://github.com/nlohmann/json/issues/1062)
- convert json value to std::string??? [\#1061](https://github.com/nlohmann/json/issues/1061)
- Commented out test cases, should they be removed? [\#1060](https://github.com/nlohmann/json/issues/1060)
- different behaviour between clang and gcc with braced initialization [\#1059](https://github.com/nlohmann/json/issues/1059)
- json array:  initialize with prescribed size and `resize` method. [\#1057](https://github.com/nlohmann/json/issues/1057)
- Is it possible to use exceptions istead of assertions? [\#1056](https://github.com/nlohmann/json/issues/1056)
- when using assign operator in with json object a static assertion fails.. [\#1055](https://github.com/nlohmann/json/issues/1055)
- Iterate over leafs of a JSON data structure: enrich the JSON pointer API [\#1054](https://github.com/nlohmann/json/issues/1054)
- \[Feature request\] Access by path [\#1053](https://github.com/nlohmann/json/issues/1053)
- document that implicit js -\> primitive conversion does not work for std::string::value\_type and why [\#1052](https://github.com/nlohmann/json/issues/1052)
- error: ‘BasicJsonType’ in namespace ‘::’ does not name a type [\#1051](https://github.com/nlohmann/json/issues/1051)
- Destructor is called when filling object through assignement [\#1050](https://github.com/nlohmann/json/issues/1050)
- Is this thing thread safe for reads? [\#1049](https://github.com/nlohmann/json/issues/1049)
- clang-tidy: Call to virtual function during construction  [\#1046](https://github.com/nlohmann/json/issues/1046)
- Using STL algorithms with JSON containers with expected results? [\#1045](https://github.com/nlohmann/json/issues/1045)
- Usage with gtest/gmock not working as expected [\#1044](https://github.com/nlohmann/json/issues/1044)
- Consequences of from\_json / to\_json being in namespace of data struct. [\#1042](https://github.com/nlohmann/json/issues/1042)
- const\_reference operator\[\]\(const typename object\_t::key\_type& key\) const throw instead of assert [\#1039](https://github.com/nlohmann/json/issues/1039)
- Trying to retrieve data from nested objects [\#1038](https://github.com/nlohmann/json/issues/1038)
- Direct download link for json\_fwd.hpp? [\#1037](https://github.com/nlohmann/json/issues/1037)
- I know the library supports UTF-8, but failed to dump the value [\#1036](https://github.com/nlohmann/json/issues/1036)
- Putting a Vec3-like vector into a json object [\#1035](https://github.com/nlohmann/json/issues/1035)
- Ternary operator crash [\#1034](https://github.com/nlohmann/json/issues/1034)
- Issued with Clion Inspection Resolution since 2018.1 [\#1033](https://github.com/nlohmann/json/issues/1033)
- Some testcases fail and one never finishes [\#1032](https://github.com/nlohmann/json/issues/1032)
- Can this class work with wchar\_t / std::wstring? [\#1031](https://github.com/nlohmann/json/issues/1031)
- Makefile: Valgrind flags have no effect [\#1030](https://github.com/nlohmann/json/issues/1030)
- 「==」 Should be 「\>」 [\#1029](https://github.com/nlohmann/json/issues/1029)
- HOCON reader? [\#1027](https://github.com/nlohmann/json/issues/1027)
- add json string in previous string?? [\#1025](https://github.com/nlohmann/json/issues/1025)
- RFC: fluent parsing interface [\#1023](https://github.com/nlohmann/json/issues/1023)
- Does it support chinese character? [\#1022](https://github.com/nlohmann/json/issues/1022)
- to/from\_msgpack only works with standard typization [\#1021](https://github.com/nlohmann/json/issues/1021)
- Build failure using latest clang and GCC compilers [\#1020](https://github.com/nlohmann/json/issues/1020)
- can two json objects be concatenated? [\#1019](https://github.com/nlohmann/json/issues/1019)
- Erase by integer index [\#1018](https://github.com/nlohmann/json/issues/1018)
- Function find overload taking a json\_pointer [\#1017](https://github.com/nlohmann/json/issues/1017)
- I think should implement an parser function [\#1016](https://github.com/nlohmann/json/issues/1016)
- Readme gif [\#1015](https://github.com/nlohmann/json/issues/1015)
- Python bindings [\#1014](https://github.com/nlohmann/json/issues/1014)
- how to add two json string in single object?? [\#1012](https://github.com/nlohmann/json/issues/1012)
- how to serialize class Object \(convert data in object into json\)?? [\#1011](https://github.com/nlohmann/json/issues/1011)
- Enable forward declaration of json by making json a class instead of a using declaration [\#997](https://github.com/nlohmann/json/issues/997)
- compilation error while using intel c++ compiler 2018 [\#994](https://github.com/nlohmann/json/issues/994)
- How to create a json variable? [\#990](https://github.com/nlohmann/json/issues/990)
- istream \>\> json  --- 1st character skipped in stream [\#976](https://github.com/nlohmann/json/issues/976)
- Add a SAX parser [\#971](https://github.com/nlohmann/json/issues/971)
- How to solve large json file? [\#927](https://github.com/nlohmann/json/issues/927)
- json\_pointer public push\_back, pop\_back [\#837](https://github.com/nlohmann/json/issues/837)
- Using input\_adapter in a slightly unexpected way [\#834](https://github.com/nlohmann/json/issues/834)

- Fix -Wno-sometimes-uninitialized by initializing "result" in parse\_sax [\#1200](https://github.com/nlohmann/json/pull/1200) ([thyu](https://github.com/thyu))
- \[RFC\] Introduce a new macro function: JSON\_INTERNAL\_CATCH [\#1187](https://github.com/nlohmann/json/pull/1187) ([simnalamburt](https://github.com/simnalamburt))
- Fix unit tests that were silently skipped or crashed \(depending on the compiler\) [\#1176](https://github.com/nlohmann/json/pull/1176) ([grembo](https://github.com/grembo))
- Refactor/no virtual sax [\#1153](https://github.com/nlohmann/json/pull/1153) ([theodelrieu](https://github.com/theodelrieu))
- Fixed compiler error in VS 2015 for debug mode [\#1151](https://github.com/nlohmann/json/pull/1151) ([sonulohani](https://github.com/sonulohani))
- Fix links to cppreference named requirements \(formerly concepts\) [\#1144](https://github.com/nlohmann/json/pull/1144) ([jrakow](https://github.com/jrakow))
- meson: fix include directory [\#1142](https://github.com/nlohmann/json/pull/1142) ([jrakow](https://github.com/jrakow))
- Feature/unordered map conversion [\#1138](https://github.com/nlohmann/json/pull/1138) ([theodelrieu](https://github.com/theodelrieu))
- fixed compile error for \#1045 [\#1134](https://github.com/nlohmann/json/pull/1134) ([Daniel599](https://github.com/Daniel599))
-  test \(non\)equality for alt\_string implementation  [\#1130](https://github.com/nlohmann/json/pull/1130) ([agrianius](https://github.com/agrianius))
- remove stringstream dependency [\#1117](https://github.com/nlohmann/json/pull/1117) ([TinyTinni](https://github.com/TinyTinni))
- Provide a from\_json overload for std::map [\#1089](https://github.com/nlohmann/json/pull/1089) ([theodelrieu](https://github.com/theodelrieu))
- fix typo in README [\#1078](https://github.com/nlohmann/json/pull/1078) ([martin-mfg](https://github.com/martin-mfg))
- Fix typo [\#1058](https://github.com/nlohmann/json/pull/1058) ([dns13](https://github.com/dns13))
- Misc cmake packaging enhancements [\#1048](https://github.com/nlohmann/json/pull/1048) ([chuckatkins](https://github.com/chuckatkins))
- Fixed incorrect LLVM version number in README [\#1047](https://github.com/nlohmann/json/pull/1047) ([jammehcow](https://github.com/jammehcow))
- Fix trivial typo in comment. [\#1043](https://github.com/nlohmann/json/pull/1043) ([coryan](https://github.com/coryan))
- Package Manager: Spack [\#1041](https://github.com/nlohmann/json/pull/1041) ([ax3l](https://github.com/ax3l))
- CMake: 3.8+ is Sufficient [\#1040](https://github.com/nlohmann/json/pull/1040) ([ax3l](https://github.com/ax3l))
- Added support for string\_view in C++17 [\#1028](https://github.com/nlohmann/json/pull/1028) ([gracicot](https://github.com/gracicot))
- Added public target\_compile\_features for auto and constexpr [\#1026](https://github.com/nlohmann/json/pull/1026) ([ktonon](https://github.com/ktonon))

## [v3.1.2](https://github.com/nlohmann/json/releases/tag/v3.1.2) (2018-03-14)

[Full Changelog](https://github.com/nlohmann/json/compare/3.1.2...v3.1.2)

## [3.1.2](https://github.com/nlohmann/json/releases/tag/3.1.2) (2018-03-14)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.1.1...3.1.2)

- STL containers are always serialized to a nested array like \[\[1,2,3\]\] [\#1013](https://github.com/nlohmann/json/issues/1013)
- The library doesn't want to insert an unordered\_map [\#1010](https://github.com/nlohmann/json/issues/1010)
- Convert Json to uint8\_t [\#1008](https://github.com/nlohmann/json/issues/1008)
- How to compare two JSON objects? [\#1007](https://github.com/nlohmann/json/issues/1007)
- Syntax checking [\#1003](https://github.com/nlohmann/json/issues/1003)
- more than one operator '=' matches these operands [\#1002](https://github.com/nlohmann/json/issues/1002)
- How to check if key existed  [\#1000](https://github.com/nlohmann/json/issues/1000)
- nlohmann::json::parse exhaust memory in go binding [\#999](https://github.com/nlohmann/json/issues/999)
- Range-based iteration over a non-array object [\#998](https://github.com/nlohmann/json/issues/998)
- get\<T\> for types that are not default constructible [\#996](https://github.com/nlohmann/json/issues/996)
- Prevent Null values to appear in .dump\(\) [\#995](https://github.com/nlohmann/json/issues/995)
- number parsing [\#993](https://github.com/nlohmann/json/issues/993)
- C2664 \(C++/CLR\) cannot convert 'nullptr' to 'nullptr &&' [\#987](https://github.com/nlohmann/json/issues/987)
- Uniform initialization from another json object differs between gcc and clang. [\#985](https://github.com/nlohmann/json/issues/985)
- Problem with adding the lib as a submodule [\#983](https://github.com/nlohmann/json/issues/983)
- UTF-8/Unicode error [\#982](https://github.com/nlohmann/json/issues/982)
- "forcing MSVC stacktrace to show which T we're talking about." error [\#980](https://github.com/nlohmann/json/issues/980)
- reverse order of serialization  [\#979](https://github.com/nlohmann/json/issues/979)
- Assigning between different json types [\#977](https://github.com/nlohmann/json/issues/977)
- Support serialisation of `unique_ptr<>` and `shared_ptr<>` [\#975](https://github.com/nlohmann/json/issues/975)
- Unexpected end of input \(not same as one before\) [\#974](https://github.com/nlohmann/json/issues/974)
- Segfault on direct initializing json object [\#973](https://github.com/nlohmann/json/issues/973)
- Segmentation fault on G++ when trying to assign json string literal to custom json type. [\#972](https://github.com/nlohmann/json/issues/972)
- os\_defines.h:44:19: error: missing binary operator before token "\(" [\#970](https://github.com/nlohmann/json/issues/970)
- Passing an iteration object by reference to a function [\#967](https://github.com/nlohmann/json/issues/967)
- Json and fmt::lib's format\_arg\(\) [\#964](https://github.com/nlohmann/json/issues/964)

- Allowing for user-defined string type in lexer/parser [\#1009](https://github.com/nlohmann/json/pull/1009) ([nlohmann](https://github.com/nlohmann))
- dump to alternative string type, as defined in basic\_json template [\#1006](https://github.com/nlohmann/json/pull/1006) ([agrianius](https://github.com/agrianius))
- Fix memory leak during parser callback [\#1001](https://github.com/nlohmann/json/pull/1001) ([nlohmann](https://github.com/nlohmann))
- fixed misprinted condition detected by PVS Studio. [\#992](https://github.com/nlohmann/json/pull/992) ([bogemic](https://github.com/bogemic))
- Fix/basic json conversion [\#986](https://github.com/nlohmann/json/pull/986) ([theodelrieu](https://github.com/theodelrieu))
- Make integration section concise [\#981](https://github.com/nlohmann/json/pull/981) ([wla80](https://github.com/wla80))

## [v3.1.1](https://github.com/nlohmann/json/releases/tag/v3.1.1) (2018-02-13)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.1.0...v3.1.1)

- Updation of child object isn't reflected in parent Object [\#968](https://github.com/nlohmann/json/issues/968)
- How to add user defined C++ path to sublime text  [\#966](https://github.com/nlohmann/json/issues/966)
- fast number parsing [\#965](https://github.com/nlohmann/json/issues/965)
- With non-unique keys, later stored entries are not taken into account anymore [\#963](https://github.com/nlohmann/json/issues/963)
- Timeout \(OSS-Fuzz 6034\) [\#962](https://github.com/nlohmann/json/issues/962)
- Incorrect parsing of indefinite length CBOR strings. [\#961](https://github.com/nlohmann/json/issues/961)
- Reload a json file at runtime without emptying my std::ifstream [\#959](https://github.com/nlohmann/json/issues/959)
- Split headers should be part of the release [\#956](https://github.com/nlohmann/json/issues/956)
- Coveralls shows no coverage data [\#953](https://github.com/nlohmann/json/issues/953)
- Feature request: Implicit conversion to bool [\#951](https://github.com/nlohmann/json/issues/951)
- converting json to vector of type with templated constructor [\#924](https://github.com/nlohmann/json/issues/924)
- No structured bindings support? [\#901](https://github.com/nlohmann/json/issues/901)
- \[Request\] Macro generating from\_json\(\) and to\_json\(\) [\#895](https://github.com/nlohmann/json/issues/895)
- basic\_json::value throws exception instead of returning default value [\#871](https://github.com/nlohmann/json/issues/871)

- Fix constraints on from\_json\(CompatibleArrayType\) [\#969](https://github.com/nlohmann/json/pull/969) ([theodelrieu](https://github.com/theodelrieu))
- Make coveralls watch the include folder [\#957](https://github.com/nlohmann/json/pull/957) ([theodelrieu](https://github.com/theodelrieu))
- Fix links in README.md [\#955](https://github.com/nlohmann/json/pull/955) ([patrikhuber](https://github.com/patrikhuber))
- Add a note about installing the library with cget [\#954](https://github.com/nlohmann/json/pull/954) ([pfultz2](https://github.com/pfultz2))

## [v3.1.0](https://github.com/nlohmann/json/releases/tag/v3.1.0) (2018-02-01)

[Full Changelog](https://github.com/nlohmann/json/compare/3.1.0...v3.1.0)

## [3.1.0](https://github.com/nlohmann/json/releases/tag/3.1.0) (2018-02-01)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.0.1...3.1.0)

- I have a proposal [\#949](https://github.com/nlohmann/json/issues/949)
- VERSION define\(s\) [\#948](https://github.com/nlohmann/json/issues/948)
- v3.0.1 compile error in icc 16.0.4 [\#947](https://github.com/nlohmann/json/issues/947)
- Use in VS2017 15.5.5 [\#946](https://github.com/nlohmann/json/issues/946)
- Process for reporting Security Bugs? [\#945](https://github.com/nlohmann/json/issues/945)
- Please expose a NLOHMANN\_JSON\_VERSION macro [\#943](https://github.com/nlohmann/json/issues/943)
- Change header include directory to nlohmann/json [\#942](https://github.com/nlohmann/json/issues/942)
- string\_type in binary\_reader [\#941](https://github.com/nlohmann/json/issues/941)
- compile error with clang 5.0 -std=c++1z and no string\_view [\#939](https://github.com/nlohmann/json/issues/939)
- Allow overriding JSON\_THROW to something else than abort\(\) [\#938](https://github.com/nlohmann/json/issues/938)
- Handle invalid string in Json file [\#937](https://github.com/nlohmann/json/issues/937)
- Unused variable 'kMinExp' [\#935](https://github.com/nlohmann/json/issues/935)
- yytext is already defined [\#933](https://github.com/nlohmann/json/issues/933)
- Equality operator fails [\#931](https://github.com/nlohmann/json/issues/931)
- use in visual studio 2015 [\#929](https://github.com/nlohmann/json/issues/929)
- Relative includes of json\_fwd.hpp in detail/meta.hpp. \[Develop branch\] [\#928](https://github.com/nlohmann/json/issues/928)
- GCC 7.x issue [\#926](https://github.com/nlohmann/json/issues/926)
- json\_fwd.hpp not installed [\#923](https://github.com/nlohmann/json/issues/923)
- Use Google Benchmarks [\#921](https://github.com/nlohmann/json/issues/921)
- Move class json\_pointer to separate file [\#920](https://github.com/nlohmann/json/issues/920)
- Unable to locate 'to\_json\(\)' and 'from\_json\(\)' methods in the same namespace [\#917](https://github.com/nlohmann/json/issues/917)
- \[answered\]Read key1 from .value example  [\#914](https://github.com/nlohmann/json/issues/914)
- Don't use `define private public` in test files [\#913](https://github.com/nlohmann/json/issues/913)
- value\(\) template argument type deduction [\#912](https://github.com/nlohmann/json/issues/912)
- Installation path is incorrect [\#910](https://github.com/nlohmann/json/issues/910)
- H [\#909](https://github.com/nlohmann/json/issues/909)
- Build failure using clang 5 [\#908](https://github.com/nlohmann/json/issues/908)
- Amalgate [\#907](https://github.com/nlohmann/json/issues/907)
- Update documentation and tests wrt. split headers [\#906](https://github.com/nlohmann/json/issues/906)
- Lib not working on ubuntu 16.04 [\#905](https://github.com/nlohmann/json/issues/905)
- Problem when writing to file. [\#904](https://github.com/nlohmann/json/issues/904)
- C2864 error when compiling with VS2015 and VS 2017 [\#903](https://github.com/nlohmann/json/issues/903)
- \[json.exception.type\_error.304\] cannot use at\(\) with object [\#902](https://github.com/nlohmann/json/issues/902)
- How do I forward nlohmann::json declaration? [\#899](https://github.com/nlohmann/json/issues/899)
- How to effectively store binary data? [\#898](https://github.com/nlohmann/json/issues/898)
- How to get the length of a JSON string without retrieving its std::string? [\#897](https://github.com/nlohmann/json/issues/897)
- Regression Tests Failure using "ctest" [\#887](https://github.com/nlohmann/json/issues/887)
- Discuss: add JSON Merge Patch \(RFC 7396\)? [\#877](https://github.com/nlohmann/json/issues/877)
- Discuss: replace static "iterator\_wrapper" function with "items" member function [\#874](https://github.com/nlohmann/json/issues/874)
- Make optional user-data available in from\_json [\#864](https://github.com/nlohmann/json/issues/864)
- Casting to std::string not working in VS2015 [\#861](https://github.com/nlohmann/json/issues/861)
- Sequential reading of JSON arrays [\#851](https://github.com/nlohmann/json/issues/851)
- Idea: Handle Multimaps Better [\#816](https://github.com/nlohmann/json/issues/816)
- Floating point rounding [\#777](https://github.com/nlohmann/json/issues/777)
- Loss of precision when serializing \<double\> [\#360](https://github.com/nlohmann/json/issues/360)

- Templatize std::string in binary\_reader \#941 [\#950](https://github.com/nlohmann/json/pull/950) ([kaidokert](https://github.com/kaidokert))
- fix cmake install directory \(for real this time\) [\#944](https://github.com/nlohmann/json/pull/944) ([theodelrieu](https://github.com/theodelrieu))
- Allow overriding THROW/CATCH/TRY macros with no-exceptions \#938 [\#940](https://github.com/nlohmann/json/pull/940) ([kaidokert](https://github.com/kaidokert))
- Removed compiler warning about unused variable 'kMinExp' [\#936](https://github.com/nlohmann/json/pull/936) ([zerodefect](https://github.com/zerodefect))
- Fix a typo in README.md [\#930](https://github.com/nlohmann/json/pull/930) ([Pipeliner](https://github.com/Pipeliner))
- Howto installation of json\_fwd.hpp \(fixes \#923\) [\#925](https://github.com/nlohmann/json/pull/925) ([zerodefect](https://github.com/zerodefect))
- fix sfinae on basic\_json UDT constructor [\#919](https://github.com/nlohmann/json/pull/919) ([theodelrieu](https://github.com/theodelrieu))
- Floating-point formatting [\#915](https://github.com/nlohmann/json/pull/915) ([abolz](https://github.com/abolz))
- Fix/cmake install [\#911](https://github.com/nlohmann/json/pull/911) ([theodelrieu](https://github.com/theodelrieu))
- fix link to the documentation of the emplace function [\#900](https://github.com/nlohmann/json/pull/900) ([Dobiasd](https://github.com/Dobiasd))
- JSON Merge Patch \(RFC 7396\) [\#876](https://github.com/nlohmann/json/pull/876) ([nlohmann](https://github.com/nlohmann))
- Refactor/split it [\#700](https://github.com/nlohmann/json/pull/700) ([theodelrieu](https://github.com/theodelrieu))

## [v3.0.1](https://github.com/nlohmann/json/releases/tag/v3.0.1) (2017-12-29)

[Full Changelog](https://github.com/nlohmann/json/compare/3.0.1...v3.0.1)

## [3.0.1](https://github.com/nlohmann/json/releases/tag/3.0.1) (2017-12-29)

[Full Changelog](https://github.com/nlohmann/json/compare/v3.0.0...3.0.1)

- Problem parsing array to global vector [\#896](https://github.com/nlohmann/json/issues/896)
- Invalid RFC6902 copy operation succeeds [\#894](https://github.com/nlohmann/json/issues/894)
- How to rename a key during looping? [\#893](https://github.com/nlohmann/json/issues/893)
- clang++-6.0 \(6.0.0-svn321357-1\) warning [\#892](https://github.com/nlohmann/json/issues/892)
- Make json.hpp aware of the modules TS? [\#891](https://github.com/nlohmann/json/issues/891)
- All enum values not handled in switch cases. \( -Wswitch-enum \) [\#889](https://github.com/nlohmann/json/issues/889)
- JSON Pointer resolve failure resulting in incorrect exception code [\#888](https://github.com/nlohmann/json/issues/888)
- Unexpected nested arrays from std::vector [\#886](https://github.com/nlohmann/json/issues/886)
- erase multiple elements from a json object [\#884](https://github.com/nlohmann/json/issues/884)
- Container function overview in Doxygen is not updated [\#883](https://github.com/nlohmann/json/issues/883)
- How to use this for binary file uploads [\#881](https://github.com/nlohmann/json/issues/881)
- Allow setting JSON\_BuildTests=OFF from parent CMakeLists.txt [\#846](https://github.com/nlohmann/json/issues/846)
- Unit test fails for local-independent str-to-num [\#845](https://github.com/nlohmann/json/issues/845)
- Another idea about type support [\#774](https://github.com/nlohmann/json/issues/774)

- Includes CTest module/adds BUILD\_TESTING option [\#885](https://github.com/nlohmann/json/pull/885) ([TinyTinni](https://github.com/TinyTinni))
- Fix MSVC warning C4819 [\#882](https://github.com/nlohmann/json/pull/882) ([erengy](https://github.com/erengy))
- Merge branch 'develop' into coverity\_scan [\#880](https://github.com/nlohmann/json/pull/880) ([nlohmann](https://github.com/nlohmann))
- :wrench: Fix up a few more effc++ items [\#858](https://github.com/nlohmann/json/pull/858) ([mattismyname](https://github.com/mattismyname))

## [v3.0.0](https://github.com/nlohmann/json/releases/tag/v3.0.0) (2017-12-17)

[Full Changelog](https://github.com/nlohmann/json/compare/3.0.0...v3.0.0)

## [3.0.0](https://github.com/nlohmann/json/releases/tag/3.0.0) (2017-12-17)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.1.1...3.0.0)

- unicode strings [\#878](https://github.com/nlohmann/json/issues/878)
- Visual Studio 2017 15.5 C++17 std::allocator deprecations [\#872](https://github.com/nlohmann/json/issues/872)
- Typo "excpetion" [\#869](https://github.com/nlohmann/json/issues/869)
- Explicit array example in README.md incorrect [\#867](https://github.com/nlohmann/json/issues/867)
- why don't you release this from Feb. ? [\#865](https://github.com/nlohmann/json/issues/865)
- json::parse throws std::invalid\_argument when processing string generated by json::dump\(\) [\#863](https://github.com/nlohmann/json/issues/863)
- code analysis: potential bug? [\#859](https://github.com/nlohmann/json/issues/859)
- MSVC2017, 15.5 new issues.   [\#857](https://github.com/nlohmann/json/issues/857)
- very basic: fetching string value/content without quotes [\#853](https://github.com/nlohmann/json/issues/853)
- Ambiguous function call to get with pointer type and constant json object in VS2015 \(15.4.4\) [\#852](https://github.com/nlohmann/json/issues/852)
- How to put  object in the array as a member? [\#850](https://github.com/nlohmann/json/issues/850)
- misclick, please ignore [\#849](https://github.com/nlohmann/json/issues/849)
- Make XML great again. [\#847](https://github.com/nlohmann/json/issues/847)
- Converting to array not working [\#843](https://github.com/nlohmann/json/issues/843)
- Iteration weirdness [\#842](https://github.com/nlohmann/json/issues/842)
- Use reference or pointer as Object value [\#841](https://github.com/nlohmann/json/issues/841)
- Ambiguity in parsing nested maps [\#840](https://github.com/nlohmann/json/issues/840)
- could not find from\_json\(\) method in T's namespace [\#839](https://github.com/nlohmann/json/issues/839)
- Incorrect parse error with binary data in keys? [\#838](https://github.com/nlohmann/json/issues/838)
- using dump\(\) when std::wstring is StringType with VS2017 [\#836](https://github.com/nlohmann/json/issues/836)
- Show the path of the currently parsed value when an error occurs [\#835](https://github.com/nlohmann/json/issues/835)
- Repetitive data type while reading [\#833](https://github.com/nlohmann/json/issues/833)
- Storing multiple types inside map [\#831](https://github.com/nlohmann/json/issues/831)
- Application terminating [\#830](https://github.com/nlohmann/json/issues/830)
- Missing CMake hunter package? [\#828](https://github.com/nlohmann/json/issues/828)
- std::map\<std::string, std::string\> from json object yields C2665: 'std::pair\<const \_Kty,\_Ty\>::pair': none of the 2 overloads could convert all the argument types [\#827](https://github.com/nlohmann/json/issues/827)
- object.dump gives quoted string, want to use .dump\(\) to generate javascripts. [\#826](https://github.com/nlohmann/json/issues/826)
- Assertion failed on \["NoExistKey"\] of an not existing key of const json& [\#825](https://github.com/nlohmann/json/issues/825)
- vs2015 error : static member will remain uninitialized at runtime but use in constant-expressions is supported [\#824](https://github.com/nlohmann/json/issues/824)
- Code Checking Warnings from json.hpp on VS2017 Community [\#821](https://github.com/nlohmann/json/issues/821)
- Missing iostream in try online [\#820](https://github.com/nlohmann/json/issues/820)
- Floating point value loses decimal point during dump [\#818](https://github.com/nlohmann/json/issues/818)
- Conan package for the library [\#817](https://github.com/nlohmann/json/issues/817)
- stream error  [\#815](https://github.com/nlohmann/json/issues/815)
- Link error when using find\(\) on the latest commit [\#814](https://github.com/nlohmann/json/issues/814)
- ABI issue with json object between 2 shared libraries [\#813](https://github.com/nlohmann/json/issues/813)
- scan\_string\(\) return token\_type::parse\_error; when parse ansi file [\#812](https://github.com/nlohmann/json/issues/812)
- segfault when using fifo\_map with json [\#810](https://github.com/nlohmann/json/issues/810)
- This shit is shit  [\#809](https://github.com/nlohmann/json/issues/809)
- \_finite and \_isnan are no members of "std" [\#808](https://github.com/nlohmann/json/issues/808)
- how to print out the line which causing exception? [\#806](https://github.com/nlohmann/json/issues/806)
- {} uses copy constructor, while = does not [\#805](https://github.com/nlohmann/json/issues/805)
- json.hpp:8955: multiple definition of function that is not defined twice or more. [\#804](https://github.com/nlohmann/json/issues/804)
- \[question\] to\_json for base and derived class [\#803](https://github.com/nlohmann/json/issues/803)
- Misleading error message - unexpected '"' - on incorrect utf-8 symbol [\#802](https://github.com/nlohmann/json/issues/802)
- json data = std::string\_view\("hi"\); doesn't work? [\#801](https://github.com/nlohmann/json/issues/801)
- Thread safety of parse\(\) [\#800](https://github.com/nlohmann/json/issues/800)
- Numbers as strings [\#799](https://github.com/nlohmann/json/issues/799)
- Tests failing on arm [\#797](https://github.com/nlohmann/json/issues/797)
- Using your library \(without modification\) in another library [\#796](https://github.com/nlohmann/json/issues/796)
- Iterating over sub-object [\#794](https://github.com/nlohmann/json/issues/794)
- how to get the json object again from which printed by the method of dump\(\) [\#792](https://github.com/nlohmann/json/issues/792)
- ppa to include source [\#791](https://github.com/nlohmann/json/issues/791)
- Different include paths in macOS and Ubuntu [\#790](https://github.com/nlohmann/json/issues/790)
- Missing break after line 12886 in switch/case [\#789](https://github.com/nlohmann/json/issues/789)
- All unit tests fail? [\#787](https://github.com/nlohmann/json/issues/787)
- More use of move semantics in deserialization [\#786](https://github.com/nlohmann/json/issues/786)
- warning C4706 - Visual Studio 2017 \(/W4\) [\#784](https://github.com/nlohmann/json/issues/784)
- Compile error in clang 5.0 [\#782](https://github.com/nlohmann/json/issues/782)
- Error Installing appium\_lib with Ruby v2.4.2 Due to JSON [\#781](https://github.com/nlohmann/json/issues/781)
- ::get\<int\>\(\) fails in new\(er\) release \[MSVC\] [\#780](https://github.com/nlohmann/json/issues/780)
- Type Conversion [\#779](https://github.com/nlohmann/json/issues/779)
- Segfault on nested parsing [\#778](https://github.com/nlohmann/json/issues/778)
- Build warnings: shadowing exception id [\#776](https://github.com/nlohmann/json/issues/776)
- multi-level JSON support. [\#775](https://github.com/nlohmann/json/issues/775)
- SIGABRT on dump\(\) [\#773](https://github.com/nlohmann/json/issues/773)
- \[Question\] Custom StringType template parameter \(possibility for a KeyType template parameter\) [\#772](https://github.com/nlohmann/json/issues/772)
- constexpr ALL the Things! [\#771](https://github.com/nlohmann/json/issues/771)
- error: ‘BasicJsonType’ in namespace ‘::’ does not name a type [\#770](https://github.com/nlohmann/json/issues/770)
- Program calls abort function [\#769](https://github.com/nlohmann/json/issues/769)
- \[Question\] Floating point resolution config during dump\(\) ? [\#768](https://github.com/nlohmann/json/issues/768)
- make check - no test ran [\#767](https://github.com/nlohmann/json/issues/767)
- The library cannot work properly with custom allocator based containers [\#766](https://github.com/nlohmann/json/issues/766)
- Documentation or feature request. [\#763](https://github.com/nlohmann/json/issues/763)
- warnings in msvc about mix/max macro while windows.h is used in the project [\#762](https://github.com/nlohmann/json/issues/762)
- std::signbit ambiguous [\#761](https://github.com/nlohmann/json/issues/761)
- How to use value for std::experimental::optional type? [\#760](https://github.com/nlohmann/json/issues/760)
- Cannot load json file properly [\#759](https://github.com/nlohmann/json/issues/759)
- Compilation error with unordered\_map\< int, int \> [\#758](https://github.com/nlohmann/json/issues/758)
- CBOR string [\#757](https://github.com/nlohmann/json/issues/757)
- Proposal: out\_of\_range should be a subclass of std::out\_of\_range [\#756](https://github.com/nlohmann/json/issues/756)
- Getter is setting the value to null if the key does not exist [\#754](https://github.com/nlohmann/json/issues/754)
- parsing works sometimes and crashes others [\#752](https://github.com/nlohmann/json/issues/752)
- Static\_assert failed "incompatible pointer type" with Xcode [\#751](https://github.com/nlohmann/json/issues/751)
- user-defined literal operator not found [\#750](https://github.com/nlohmann/json/issues/750)
- getting clean string from it.key\(\) [\#748](https://github.com/nlohmann/json/issues/748)
- Best method for exploring and obtaining values of nested json objects when the names are not known beforehand? [\#747](https://github.com/nlohmann/json/issues/747)
- null char at the end of string [\#746](https://github.com/nlohmann/json/issues/746)
- Incorrect sample for operator \>\> in docs [\#745](https://github.com/nlohmann/json/issues/745)
- User-friendly documentation [\#744](https://github.com/nlohmann/json/issues/744)
- Retrieve all values that match a json path [\#743](https://github.com/nlohmann/json/issues/743)
- Compilation issue with gcc 7.2 [\#742](https://github.com/nlohmann/json/issues/742)
- CMake target nlohmann\_json does not have src into its interface includes [\#741](https://github.com/nlohmann/json/issues/741)
- Error when serializing empty json: type must be string, but is object [\#740](https://github.com/nlohmann/json/issues/740)
- Conversion error for std::map\<int, std::string\>  [\#739](https://github.com/nlohmann/json/issues/739)
- Dumping Json to file as array [\#738](https://github.com/nlohmann/json/issues/738)
- nesting json objects [\#737](https://github.com/nlohmann/json/issues/737)
- where to find general help? [\#736](https://github.com/nlohmann/json/issues/736)
- Compilation Error on Clang 5.0 Upgrade [\#735](https://github.com/nlohmann/json/issues/735)
- Compilation error with std::map\<std::string, std::string\> on vs 2015 [\#734](https://github.com/nlohmann/json/issues/734)
- Benchmarks for Binary formats [\#733](https://github.com/nlohmann/json/issues/733)
- Support \n symbols in json string. [\#731](https://github.com/nlohmann/json/issues/731)
- Project's name is too generic and hard to search for [\#730](https://github.com/nlohmann/json/issues/730)
- Visual Studio 2015 IntelliTrace problems [\#729](https://github.com/nlohmann/json/issues/729)
- How to erase nested objects inside other objects? [\#728](https://github.com/nlohmann/json/issues/728)
- Serialization for CBOR [\#726](https://github.com/nlohmann/json/issues/726)
- Using json Object as value in a map [\#725](https://github.com/nlohmann/json/issues/725)
- std::regex and nlohmann::json value [\#724](https://github.com/nlohmann/json/issues/724)
- Warnings when compiling with VisualStudio 2015 [\#723](https://github.com/nlohmann/json/issues/723)
- Has this lib the unicode \(wstring\) support? [\#722](https://github.com/nlohmann/json/issues/722)
- When will be 3.0 in master? [\#721](https://github.com/nlohmann/json/issues/721)
- Determine the type from error message. [\#720](https://github.com/nlohmann/json/issues/720)
- Compile-Error C2100 \(MS VS2015\) in line 887 json.hpp [\#719](https://github.com/nlohmann/json/issues/719)
- from\_json not working for boost::optional example [\#718](https://github.com/nlohmann/json/issues/718)
- about from\_json and to\_json function [\#717](https://github.com/nlohmann/json/issues/717)
- How to detect parse failure? [\#715](https://github.com/nlohmann/json/issues/715)
- Parse throw std::ios\_base::failure exception when failbit set to true [\#714](https://github.com/nlohmann/json/issues/714)
- Is there a way of format just making a pretty print without changing the key's orders ? [\#713](https://github.com/nlohmann/json/issues/713)
- Serialization of array of not same model items [\#712](https://github.com/nlohmann/json/issues/712)
- pointer to json parse vector [\#711](https://github.com/nlohmann/json/issues/711)
- Gtest SEH Exception [\#709](https://github.com/nlohmann/json/issues/709)
- broken from\_json implementation for pair and tuple  [\#707](https://github.com/nlohmann/json/issues/707)
- Unevaluated lambda in assert breaks gcc 7 build [\#705](https://github.com/nlohmann/json/issues/705)
- Issues when adding values to firebase database [\#704](https://github.com/nlohmann/json/issues/704)
- Floating point equality - revisited [\#703](https://github.com/nlohmann/json/issues/703)
- Conversion from valarray\<double\> to json fails to build [\#702](https://github.com/nlohmann/json/issues/702)
- internal compiler error \(gcc7\)  [\#701](https://github.com/nlohmann/json/issues/701)
- One build system to rule them all [\#698](https://github.com/nlohmann/json/issues/698)
- Generated nlohmann\_jsonConfig.cmake does not set JSON\_INCLUDE\_DIR [\#695](https://github.com/nlohmann/json/issues/695)
- support the Chinese language in json string [\#694](https://github.com/nlohmann/json/issues/694)
- NaN problem within develop branch [\#693](https://github.com/nlohmann/json/issues/693)
- Please post example of specialization for boost::filesystem [\#692](https://github.com/nlohmann/json/issues/692)
- Impossible to do an array of composite objects [\#691](https://github.com/nlohmann/json/issues/691)
- How to save json to file? [\#690](https://github.com/nlohmann/json/issues/690)
- my simple json parser [\#689](https://github.com/nlohmann/json/issues/689)
- problem with new struct parsing syntax [\#688](https://github.com/nlohmann/json/issues/688)
- Parse error while parse the json string contains  UTF 8 encoded document bytes string [\#684](https://github.com/nlohmann/json/issues/684)
- \[question\] how to get a string value by pointer [\#683](https://github.com/nlohmann/json/issues/683)
- create json object from string variable [\#681](https://github.com/nlohmann/json/issues/681)
- adl\_serializer and CRTP [\#680](https://github.com/nlohmann/json/issues/680)
- Is there a way to control the precision of serialized floating point numbers? [\#677](https://github.com/nlohmann/json/issues/677)
- Is there a way to get the path of a value? [\#676](https://github.com/nlohmann/json/issues/676)
- Could the parser locate errors to line? [\#675](https://github.com/nlohmann/json/issues/675)
- There is performance inefficiency found by coverity tool json2.1.1/include/nlohmann/json.hpp [\#673](https://github.com/nlohmann/json/issues/673)
- include problem, when cmake on osx [\#672](https://github.com/nlohmann/json/issues/672)
- Operator= ambiguous in C++1z and GCC 7.1.1 [\#670](https://github.com/nlohmann/json/issues/670)
- should't the cmake install target be to nlohman/json.hpp [\#668](https://github.com/nlohmann/json/issues/668)
- deserialise from `std::vector` [\#667](https://github.com/nlohmann/json/issues/667)
- How to iterate? [\#665](https://github.com/nlohmann/json/issues/665)
- could this json lib work on windows? [\#664](https://github.com/nlohmann/json/issues/664)
- How does from\_json work? [\#662](https://github.com/nlohmann/json/issues/662)
- insert\(or merge\) object should replace same key , not ignore [\#661](https://github.com/nlohmann/json/issues/661)
- Parse method doesn't handle newlines. [\#659](https://github.com/nlohmann/json/issues/659)
- Compilation "note" on GCC 6 ARM [\#658](https://github.com/nlohmann/json/issues/658)
- Adding additional push\_back/operator+= rvalue overloads for JSON object [\#657](https://github.com/nlohmann/json/issues/657)
- dump's parameter "ensure\_ascii" creates too long sequences [\#656](https://github.com/nlohmann/json/issues/656)
- Question: parsing `void *` [\#655](https://github.com/nlohmann/json/issues/655)
- how should I check a string is valid JSON string ? [\#653](https://github.com/nlohmann/json/issues/653)
- Question: thread safety of read only accesses [\#651](https://github.com/nlohmann/json/issues/651)
- Eclipse: Method 'size' could not be resolved [\#649](https://github.com/nlohmann/json/issues/649)
- Update/Add object fields [\#648](https://github.com/nlohmann/json/issues/648)
- No exception raised for Out Of Range input of numbers [\#647](https://github.com/nlohmann/json/issues/647)
- Package Name [\#646](https://github.com/nlohmann/json/issues/646)
- What is the meaning of operator\[\]\(T\* key\) [\#645](https://github.com/nlohmann/json/issues/645)
- Which is the correct way to json objects as parameters to functions? [\#644](https://github.com/nlohmann/json/issues/644)
- Method to get string representations of values [\#642](https://github.com/nlohmann/json/issues/642)
-  CBOR serialization of a given JSON value does not serialize [\#641](https://github.com/nlohmann/json/issues/641)
- Are we forced to use "-fexceptions" flag in android ndk project [\#640](https://github.com/nlohmann/json/issues/640)
- Comparison of objects containing floats [\#639](https://github.com/nlohmann/json/issues/639)
- 'localeconv' is not supported by NDK for SDK  \<=20 [\#638](https://github.com/nlohmann/json/issues/638)
- \[Question\] cLion integration [\#637](https://github.com/nlohmann/json/issues/637)
- How to construct an iteratable usage in nlohmann json? [\#636](https://github.com/nlohmann/json/issues/636)
- \[Question\] copy assign json-container to vector [\#635](https://github.com/nlohmann/json/issues/635)
- Get size without .dump\(\) [\#634](https://github.com/nlohmann/json/issues/634)
- Segmentation fault when parsing invalid json file [\#633](https://github.com/nlohmann/json/issues/633)
- How to serialize from json to vector\<customType\>? [\#632](https://github.com/nlohmann/json/issues/632)
- no member named 'thousands\_sep' in 'lconv' [\#631](https://github.com/nlohmann/json/issues/631)
- \[Question\] Any fork for \(the unsupported\) Visual Studio 2012 version? [\#628](https://github.com/nlohmann/json/issues/628)
- Dependency injection in serializer [\#627](https://github.com/nlohmann/json/issues/627)
- from\_json for std::array [\#625](https://github.com/nlohmann/json/issues/625)
- Discussion: How to structure the parsing function families [\#623](https://github.com/nlohmann/json/issues/623)
- Question: How to erase subtree [\#622](https://github.com/nlohmann/json/issues/622)
- Insertion into nested json field [\#621](https://github.com/nlohmann/json/issues/621)
- Question: return static json object from function [\#618](https://github.com/nlohmann/json/issues/618)
- icc16 error [\#617](https://github.com/nlohmann/json/issues/617)
- \[-Wdeprecated-declarations\] in row `j >> ss;` in file `json.hpp:7405:26` and FAILED unit tests with MinGWx64! [\#616](https://github.com/nlohmann/json/issues/616)
- to\_json for pairs, tuples [\#614](https://github.com/nlohmann/json/issues/614)
- Using uninitialized memory 'buf' in line 11173 v2.1.1? [\#613](https://github.com/nlohmann/json/issues/613)
- How to parse multiple same Keys of JSON and save them? [\#612](https://github.com/nlohmann/json/issues/612)
- "Multiple declarations" error when using types defined with `typedef` [\#611](https://github.com/nlohmann/json/issues/611)
- 2.1.1+ breaks compilation of shared\_ptr\<json\> == 0 [\#610](https://github.com/nlohmann/json/issues/610)
- a bug of inheritance ?  [\#608](https://github.com/nlohmann/json/issues/608)
- std::map key conversion with to\_json [\#607](https://github.com/nlohmann/json/issues/607)
- json.hpp:6384:62: error: wrong number of template arguments \(1, should be 2\) [\#606](https://github.com/nlohmann/json/issues/606)
- Incremental parsing: Where's the push version? [\#605](https://github.com/nlohmann/json/issues/605)
- Is there a way to validate the structure of a json object ? [\#604](https://github.com/nlohmann/json/issues/604)
- \[Question\] Issue when using Appveyor when compiling library [\#603](https://github.com/nlohmann/json/issues/603)
- BOM not skipped when using json:parse\(iterator\) [\#602](https://github.com/nlohmann/json/issues/602)
- Use of the binary type in CBOR and Message Pack [\#601](https://github.com/nlohmann/json/issues/601)
- Newbie issue: how does one convert a map in Json back to std::map? [\#600](https://github.com/nlohmann/json/issues/600)
- Plugin system [\#599](https://github.com/nlohmann/json/issues/599)
- Using custom types for scalars? [\#596](https://github.com/nlohmann/json/issues/596)
- Issues with the arithmetic in iterator and reverse iterator [\#593](https://github.com/nlohmann/json/issues/593)
- not enough examples [\#592](https://github.com/nlohmann/json/issues/592)
- in-class initialization for type 'const T' is not yet implemented [\#591](https://github.com/nlohmann/json/issues/591)
- compiling with gcc 7 -\> error on bool operator \< [\#590](https://github.com/nlohmann/json/issues/590)
- Parsing from stream leads to an array [\#589](https://github.com/nlohmann/json/issues/589)
- Buggy support for binary string data [\#587](https://github.com/nlohmann/json/issues/587)
- C++17's ambiguous conversion [\#586](https://github.com/nlohmann/json/issues/586)
- How does the messagepack encoding/decoding compare to msgpack-cpp in terms of performance? [\#585](https://github.com/nlohmann/json/issues/585)
- is it possible to check existence of a value deep in hierarchy? [\#584](https://github.com/nlohmann/json/issues/584)
- loading from a stream and exceptions [\#582](https://github.com/nlohmann/json/issues/582)
- Visual Studio seems not to have all min\(\) function versions [\#581](https://github.com/nlohmann/json/issues/581)
- Supporting of the json schema [\#580](https://github.com/nlohmann/json/issues/580)
- Stack-overflow \(OSS-Fuzz 1444\) [\#577](https://github.com/nlohmann/json/issues/577)
- Heap-buffer-overflow \(OSS-Fuzz 1400\) [\#575](https://github.com/nlohmann/json/issues/575)
- JSON escape quotes [\#574](https://github.com/nlohmann/json/issues/574)
- error: static\_assert failed [\#573](https://github.com/nlohmann/json/issues/573)
- Storing floats, and round trip serialisation/deserialisation diffs [\#572](https://github.com/nlohmann/json/issues/572)
- JSON.getLong produces inconsistent results [\#571](https://github.com/nlohmann/json/issues/571)
- Request: Object.at\(\) with default return value [\#570](https://github.com/nlohmann/json/issues/570)
- Internal structure gets corrupted while parsing [\#569](https://github.com/nlohmann/json/issues/569)
- create template \<typename Iter\> basic\_json from\_cbor\(Iter begin, Iter end\) [\#568](https://github.com/nlohmann/json/issues/568)
- Conan.io [\#566](https://github.com/nlohmann/json/issues/566)
- contradictory documentation regarding json::find [\#565](https://github.com/nlohmann/json/issues/565)
- Unexpected '\"' in middle of array [\#564](https://github.com/nlohmann/json/issues/564)
- Support parse std::pair to Json object [\#563](https://github.com/nlohmann/json/issues/563)
- json and Microsoft Visual c++ Compiler Nov 2012 CTP [\#562](https://github.com/nlohmann/json/issues/562)
- from\_json declaration order and exceptions [\#561](https://github.com/nlohmann/json/issues/561)
- Tip: Don't upgrade to VS2017 if using json initializer list constructs [\#559](https://github.com/nlohmann/json/issues/559)
- parse error - unexpected end of input [\#558](https://github.com/nlohmann/json/issues/558)
- Cant modify existing numbers inside a json object [\#557](https://github.com/nlohmann/json/issues/557)
- Better support for SAX style serialize and deserialize in new version? [\#554](https://github.com/nlohmann/json/issues/554)
- Cannot convert from json array to std::array [\#553](https://github.com/nlohmann/json/issues/553)
- Do not define an unnamed namespace in a header file \(DCL59-CPP\) [\#552](https://github.com/nlohmann/json/issues/552)
- Parse error on known good json file [\#551](https://github.com/nlohmann/json/issues/551)
- Warning on Intel compiler \(icc 17\) [\#550](https://github.com/nlohmann/json/issues/550)
- multiple versions of 'vsnprintf' [\#549](https://github.com/nlohmann/json/issues/549)
- illegal indirection [\#548](https://github.com/nlohmann/json/issues/548)
- Ambiguous compare operators with clang-5.0 [\#547](https://github.com/nlohmann/json/issues/547)
- Using tsl::ordered\_map [\#546](https://github.com/nlohmann/json/issues/546)
- Compiler support errors are inconvenient [\#544](https://github.com/nlohmann/json/issues/544)
- Duplicate symbols error happens while to\_json/from\_json method implemented inside entity definition header file [\#542](https://github.com/nlohmann/json/issues/542)
- consider adding a bool json::is\_valid\(std::string const&\) non-member function [\#541](https://github.com/nlohmann/json/issues/541)
- Help request [\#539](https://github.com/nlohmann/json/issues/539)
- How to deal with missing keys in `from_json`? [\#538](https://github.com/nlohmann/json/issues/538)
- recursive from\_msgpack implementation will stack overflow [\#537](https://github.com/nlohmann/json/issues/537)
- Exception objects must be nothrow copy constructible \(ERR60-CPP\) [\#531](https://github.com/nlohmann/json/issues/531)
- Support for multiple root elements [\#529](https://github.com/nlohmann/json/issues/529)
- Port has\_shape from dropbox/json11 [\#528](https://github.com/nlohmann/json/issues/528)
- dump\_float: truncation from ptrdiff\_t to long [\#527](https://github.com/nlohmann/json/issues/527)
- Make exception base class visible in basic\_json [\#525](https://github.com/nlohmann/json/issues/525)
- msgpack unit test failures on ppc64 arch [\#524](https://github.com/nlohmann/json/issues/524)
- How about split the implementation out, and only leave the interface? [\#523](https://github.com/nlohmann/json/issues/523)
- VC++2017 not enough actual parameters for macro 'max' [\#522](https://github.com/nlohmann/json/issues/522)
- crash on empty ifstream [\#521](https://github.com/nlohmann/json/issues/521)
- Suggestion: Support tabs for indentation when serializing to stream. [\#520](https://github.com/nlohmann/json/issues/520)
- Abrt in get\_number \(OSS-Fuzz 885\) [\#519](https://github.com/nlohmann/json/issues/519)
- Abrt on unknown address \(OSS-Fuzz 884\) [\#518](https://github.com/nlohmann/json/issues/518)
- Stack-overflow \(OSS-Fuzz 869\) [\#517](https://github.com/nlohmann/json/issues/517)
- Assertion error \(OSS-Fuzz 868\) [\#516](https://github.com/nlohmann/json/issues/516)
- NaN to json and back [\#515](https://github.com/nlohmann/json/issues/515)
- Comparison of NaN [\#514](https://github.com/nlohmann/json/issues/514)
- why it's not possible to serialize c++11 enums directly [\#513](https://github.com/nlohmann/json/issues/513)
- clang compile error: use of overloaded operator '\<=' is ambiguous   with \(nlohmann::json{{"a", 5}}\)\["a"\] \<= 10 [\#512](https://github.com/nlohmann/json/issues/512)
- Why not also look inside the type for \(static\) to\_json and from\_json funtions? [\#511](https://github.com/nlohmann/json/issues/511)
- Parser issues [\#509](https://github.com/nlohmann/json/issues/509)
- I may not understand [\#507](https://github.com/nlohmann/json/issues/507)
- VS2017 min / max problem for 2.1.1 [\#506](https://github.com/nlohmann/json/issues/506)
- CBOR/MessagePack is not read until the end [\#505](https://github.com/nlohmann/json/issues/505)
- Assertion error \(OSS-Fuzz 856\) [\#504](https://github.com/nlohmann/json/issues/504)
- Return position in parse error exceptions [\#503](https://github.com/nlohmann/json/issues/503)
- conversion from/to C array is not supported [\#502](https://github.com/nlohmann/json/issues/502)
- error C2338: could not find to\_json\(\) method in T's namespace [\#501](https://github.com/nlohmann/json/issues/501)
- Test suite fails in en\_GB.UTF-8 [\#500](https://github.com/nlohmann/json/issues/500)
- cannot use operator\[\] with number [\#499](https://github.com/nlohmann/json/issues/499)
- consider using \_\_cpp\_exceptions and/or \_\_EXCEPTIONS to disable/enable exception support [\#498](https://github.com/nlohmann/json/issues/498)
- Stack-overflow \(OSS-Fuzz issue 814\) [\#497](https://github.com/nlohmann/json/issues/497)
- Using in Unreal Engine - handling custom types conversion [\#495](https://github.com/nlohmann/json/issues/495)
- Conversion from vector\<bool\> to json fails to build [\#494](https://github.com/nlohmann/json/issues/494)
- fill\_line\_buffer incorrectly tests m\_stream for eof but not fail or bad bits [\#493](https://github.com/nlohmann/json/issues/493)
- Compiling with \_GLIBCXX\_DEBUG yields iterator-comparison warnings during tests [\#492](https://github.com/nlohmann/json/issues/492)
- crapy interface [\#491](https://github.com/nlohmann/json/issues/491)
- Fix Visual Studo 2013 builds. [\#490](https://github.com/nlohmann/json/issues/490)
- Failed to compile with -D\_GLIBCXX\_PARALLEL [\#489](https://github.com/nlohmann/json/issues/489)
- Input several field with the same name [\#488](https://github.com/nlohmann/json/issues/488)
- read in .json file yields strange sizes [\#487](https://github.com/nlohmann/json/issues/487)
- json::value\_t can't be a map's key type in VC++ 2015 [\#486](https://github.com/nlohmann/json/issues/486)
- Using fifo\_map [\#485](https://github.com/nlohmann/json/issues/485)
- Cannot get float pointer for value stored as `0` [\#484](https://github.com/nlohmann/json/issues/484)
- byte string support [\#483](https://github.com/nlohmann/json/issues/483)
- https://github.com/nlohmann/json\#execute-unit-tests [\#481](https://github.com/nlohmann/json/issues/481)
- Remove deprecated constructor basic\_json\(std::istream&\) [\#480](https://github.com/nlohmann/json/issues/480)
- writing the binary json file? [\#479](https://github.com/nlohmann/json/issues/479)
- CBOR/MessagePack from uint8\_t \* and size [\#478](https://github.com/nlohmann/json/issues/478)
- Streaming binary representations  [\#477](https://github.com/nlohmann/json/issues/477)
- Reuse memory in to\_cbor and to\_msgpack functions [\#476](https://github.com/nlohmann/json/issues/476)
- Error Using JSON Library with arrays C++ [\#475](https://github.com/nlohmann/json/issues/475)
- Moving forward to version 3.0.0 [\#474](https://github.com/nlohmann/json/issues/474)
- Inconsistent behavior in conversion to array type [\#473](https://github.com/nlohmann/json/issues/473)
- Create a \[key:member\_pointer\] map to ease parsing custom types [\#471](https://github.com/nlohmann/json/issues/471)
- MSVC 2015 update 2 [\#469](https://github.com/nlohmann/json/issues/469)
- VS2017 implicit to std::string conversion fix. [\#464](https://github.com/nlohmann/json/issues/464)
- How to make sure a string or string literal is a valid JSON? [\#458](https://github.com/nlohmann/json/issues/458)
- basic\_json templated on a "policy" class [\#456](https://github.com/nlohmann/json/issues/456)
- json::value\(const json\_pointer&, ValueType\) requires exceptions to return the default value. [\#440](https://github.com/nlohmann/json/issues/440)
- is it possible merge two json object [\#428](https://github.com/nlohmann/json/issues/428)
- Is it possible to turn this into a shared library? [\#420](https://github.com/nlohmann/json/issues/420)
- Further thoughts on performance improvements [\#418](https://github.com/nlohmann/json/issues/418)
- nan number stored as null [\#388](https://github.com/nlohmann/json/issues/388)
- Behavior of operator\>\> should more closely resemble that of built-in overloads. [\#367](https://github.com/nlohmann/json/issues/367)
- Request: range-based-for over a json-object to expose .first/.second [\#350](https://github.com/nlohmann/json/issues/350)
- feature wish: JSONPath [\#343](https://github.com/nlohmann/json/issues/343)
- UTF-8/Unicode escape and dump [\#330](https://github.com/nlohmann/json/issues/330)
- Serialized value not always can be parsed. [\#329](https://github.com/nlohmann/json/issues/329)
- Is there a way to forward declare nlohmann::json? [\#314](https://github.com/nlohmann/json/issues/314)
- Exception line [\#301](https://github.com/nlohmann/json/issues/301)
- Do not throw exception when default\_value's type does not match the actual type [\#278](https://github.com/nlohmann/json/issues/278)
- dump\(\) method doesn't work with a custom allocator [\#268](https://github.com/nlohmann/json/issues/268)
- Readme documentation enhancements [\#248](https://github.com/nlohmann/json/issues/248)
- Use user-defined exceptions [\#244](https://github.com/nlohmann/json/issues/244)
- Incorrect C++11 allocator model support [\#161](https://github.com/nlohmann/json/issues/161)

- :white\_check\_mark: re-added tests for algorithms [\#879](https://github.com/nlohmann/json/pull/879) ([nlohmann](https://github.com/nlohmann))
- Overworked library toward 3.0.0 release [\#875](https://github.com/nlohmann/json/pull/875) ([nlohmann](https://github.com/nlohmann))
- :rotating\_light: remove C4996 warnings \#872 [\#873](https://github.com/nlohmann/json/pull/873) ([nlohmann](https://github.com/nlohmann))
- :boom: throwing an exception in case dump encounters a non-UTF-8 string \#838 [\#870](https://github.com/nlohmann/json/pull/870) ([nlohmann](https://github.com/nlohmann))
- :memo: fixing documentation \#867 [\#868](https://github.com/nlohmann/json/pull/868) ([nlohmann](https://github.com/nlohmann))
- iter\_impl template conformance with C++17 [\#860](https://github.com/nlohmann/json/pull/860) ([bogemic](https://github.com/bogemic))
- Std allocator conformance cpp17 [\#856](https://github.com/nlohmann/json/pull/856) ([bogemic](https://github.com/bogemic))
- cmake: use BUILD\_INTERFACE/INSTALL\_INTERFACE [\#855](https://github.com/nlohmann/json/pull/855) ([theodelrieu](https://github.com/theodelrieu))
- to/from\_json: add a MSVC-specific static\_assert to force a stacktrace [\#854](https://github.com/nlohmann/json/pull/854) ([theodelrieu](https://github.com/theodelrieu))
- Add .natvis for MSVC debug view [\#844](https://github.com/nlohmann/json/pull/844) ([TinyTinni](https://github.com/TinyTinni))
- Updated hunter package links [\#829](https://github.com/nlohmann/json/pull/829) ([jowr](https://github.com/jowr))
- Typos README [\#811](https://github.com/nlohmann/json/pull/811) ([Itja](https://github.com/Itja))
- add forwarding references to json\_ref constructor [\#807](https://github.com/nlohmann/json/pull/807) ([theodelrieu](https://github.com/theodelrieu))
- Add transparent comparator and perfect forwarding support to find\(\) and count\(\) [\#795](https://github.com/nlohmann/json/pull/795) ([jseward](https://github.com/jseward))
- Error : 'identifier "size\_t" is undefined' in linux [\#793](https://github.com/nlohmann/json/pull/793) ([sonulohani](https://github.com/sonulohani))
- Fix Visual Studio 2017 warnings [\#788](https://github.com/nlohmann/json/pull/788) ([jseward](https://github.com/jseward))
- Fix warning C4706 on Visual Studio 2017 [\#785](https://github.com/nlohmann/json/pull/785) ([jseward](https://github.com/jseward))
- Set GENERATE\_TAGFILE in Doxyfile [\#783](https://github.com/nlohmann/json/pull/783) ([eld00d](https://github.com/eld00d))
- using more CMake [\#765](https://github.com/nlohmann/json/pull/765) ([nlohmann](https://github.com/nlohmann))
- Simplified istream handing \#367 [\#764](https://github.com/nlohmann/json/pull/764) ([pjkundert](https://github.com/pjkundert))
- Add info for the vcpkg package. [\#753](https://github.com/nlohmann/json/pull/753) ([gregmarr](https://github.com/gregmarr))
- fix from\_json implementation for pair/tuple [\#708](https://github.com/nlohmann/json/pull/708) ([theodelrieu](https://github.com/theodelrieu))
- Update json.hpp [\#686](https://github.com/nlohmann/json/pull/686) ([GoWebProd](https://github.com/GoWebProd))
- Remove duplicate word [\#685](https://github.com/nlohmann/json/pull/685) ([daixtrose](https://github.com/daixtrose))
- To fix compilation issue for intel OSX compiler [\#682](https://github.com/nlohmann/json/pull/682) ([kbthomp1](https://github.com/kbthomp1))
- Digraph warning [\#679](https://github.com/nlohmann/json/pull/679) ([traits](https://github.com/traits))
- massage -\> message [\#678](https://github.com/nlohmann/json/pull/678) ([DmitryKuk](https://github.com/DmitryKuk))
- Fix "not constraint" grammar in docs [\#674](https://github.com/nlohmann/json/pull/674) ([wincent](https://github.com/wincent))
- Add documentation for integration with CMake and hunter [\#671](https://github.com/nlohmann/json/pull/671) ([dan-42](https://github.com/dan-42))
- REFACTOR: rewrite CMakeLists.txt for better inlcude and reuse [\#669](https://github.com/nlohmann/json/pull/669) ([dan-42](https://github.com/dan-42))
- enable\_testing only if the JSON\_BuildTests is ON [\#666](https://github.com/nlohmann/json/pull/666) ([effolkronium](https://github.com/effolkronium))
- Support moving from rvalues in std::initializer\_list [\#663](https://github.com/nlohmann/json/pull/663) ([himikof](https://github.com/himikof))
- add ensure\_ascii parameter to dump. \#330 [\#654](https://github.com/nlohmann/json/pull/654) ([ryanjmulder](https://github.com/ryanjmulder))
- Rename BuildTests to JSON\_BuildTests [\#652](https://github.com/nlohmann/json/pull/652) ([olegendo](https://github.com/olegendo))
- Don't include \<iostream\>, use std::make\_shared [\#650](https://github.com/nlohmann/json/pull/650) ([olegendo](https://github.com/olegendo))
- Refacto/split basic json [\#643](https://github.com/nlohmann/json/pull/643) ([theodelrieu](https://github.com/theodelrieu))
- fix typo in operator\_\_notequal example [\#630](https://github.com/nlohmann/json/pull/630) ([Chocobo1](https://github.com/Chocobo1))
- Fix MSVC warning C4819 [\#629](https://github.com/nlohmann/json/pull/629) ([Chocobo1](https://github.com/Chocobo1))
- \[BugFix\] Add parentheses around std::min [\#626](https://github.com/nlohmann/json/pull/626) ([koemeet](https://github.com/koemeet))
- add pair/tuple conversions [\#624](https://github.com/nlohmann/json/pull/624) ([theodelrieu](https://github.com/theodelrieu))
- remove std::pair support [\#615](https://github.com/nlohmann/json/pull/615) ([theodelrieu](https://github.com/theodelrieu))
- Add pair support, fix CompatibleObject conversions \(fixes \#600\) [\#609](https://github.com/nlohmann/json/pull/609) ([theodelrieu](https://github.com/theodelrieu))
- \#550 Fix iterator related compiling issues for Intel icc [\#598](https://github.com/nlohmann/json/pull/598) ([HenryRLee](https://github.com/HenryRLee))
- Issue \#593 Fix the arithmetic operators in the iterator and reverse iterator [\#595](https://github.com/nlohmann/json/pull/595) ([HenryRLee](https://github.com/HenryRLee))
- fix doxygen error of basic\_json::get\(\) [\#583](https://github.com/nlohmann/json/pull/583) ([zhaohuaxishi](https://github.com/zhaohuaxishi))
- Fixing assignement for iterator wrapper second, and adding unit test [\#579](https://github.com/nlohmann/json/pull/579) ([Type1J](https://github.com/Type1J))
- Adding first and second properties to iteration\_proxy\_internal [\#578](https://github.com/nlohmann/json/pull/578) ([Type1J](https://github.com/Type1J))
- Adding support for Meson. [\#576](https://github.com/nlohmann/json/pull/576) ([Type1J](https://github.com/Type1J))
- add enum class default conversions [\#545](https://github.com/nlohmann/json/pull/545) ([theodelrieu](https://github.com/theodelrieu))
- Properly pop diagnostics [\#540](https://github.com/nlohmann/json/pull/540) ([tinloaf](https://github.com/tinloaf))
- Add Visual Studio 17 image to appveyor build matrix [\#536](https://github.com/nlohmann/json/pull/536) ([vpetrigo](https://github.com/vpetrigo))
- UTF8 encoding enhancement [\#534](https://github.com/nlohmann/json/pull/534) ([TedLyngmo](https://github.com/TedLyngmo))
- Fix typo [\#530](https://github.com/nlohmann/json/pull/530) ([berkus](https://github.com/berkus))
- Make exception base class visible in basic\_json [\#526](https://github.com/nlohmann/json/pull/526) ([ghost](https://github.com/ghost))
- :art: Namespace `uint8_t` from the C++ stdlib [\#510](https://github.com/nlohmann/json/pull/510) ([alexweej](https://github.com/alexweej))
- add to\_json method for C arrays [\#508](https://github.com/nlohmann/json/pull/508) ([theodelrieu](https://github.com/theodelrieu))
- Fix -Weffc++ warnings \(GNU 6.3.1\) [\#496](https://github.com/nlohmann/json/pull/496) ([TedLyngmo](https://github.com/TedLyngmo))

## [v2.1.1](https://github.com/nlohmann/json/releases/tag/v2.1.1) (2017-02-25)

[Full Changelog](https://github.com/nlohmann/json/compare/2.1.1...v2.1.1)

## [2.1.1](https://github.com/nlohmann/json/releases/tag/2.1.1) (2017-02-25)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.1.0...2.1.1)

- warning in the library [\#472](https://github.com/nlohmann/json/issues/472)
- How to create an array of Objects? [\#470](https://github.com/nlohmann/json/issues/470)
- \[Bug?\] Cannot get int pointer, but int64\_t works [\#468](https://github.com/nlohmann/json/issues/468)
- Illegal indirection [\#467](https://github.com/nlohmann/json/issues/467)
- in vs can't find linkageId   [\#466](https://github.com/nlohmann/json/issues/466)
- Roundtrip error while parsing "1000000000000000010E5" [\#465](https://github.com/nlohmann/json/issues/465)
- C4996 error and warning with Visual Studio [\#463](https://github.com/nlohmann/json/issues/463)
- Support startIndex for from\_cbor/from\_msgpack [\#462](https://github.com/nlohmann/json/issues/462)
- question: monospace font used in feature slideshow? [\#460](https://github.com/nlohmann/json/issues/460)
- Object.keys\(\) [\#459](https://github.com/nlohmann/json/issues/459)
- Use “, “ as delimiter for json-objects. [\#457](https://github.com/nlohmann/json/issues/457)
- Enum -\> string during serialization and vice versa [\#455](https://github.com/nlohmann/json/issues/455)
- doubles are printed as integers [\#454](https://github.com/nlohmann/json/issues/454)
- Warnings with Visual Studio c++ \(VS2015 Update 3\) [\#453](https://github.com/nlohmann/json/issues/453)
- Heap-buffer-overflow \(OSS-Fuzz issue 585\) [\#452](https://github.com/nlohmann/json/issues/452)
- use of undeclared identifier 'UINT8\_MAX' [\#451](https://github.com/nlohmann/json/issues/451)
- Question on the lifetime managment of objects at the lower levels [\#449](https://github.com/nlohmann/json/issues/449)
- Json should not be constructible with 'json\*' [\#448](https://github.com/nlohmann/json/issues/448)
- Move value\_t to namespace scope [\#447](https://github.com/nlohmann/json/issues/447)
- Typo in README.md [\#446](https://github.com/nlohmann/json/issues/446)
- make check compilation is unneccesarily slow [\#445](https://github.com/nlohmann/json/issues/445)
- Problem in dump\(\) in json.h caused by ss.imbue [\#444](https://github.com/nlohmann/json/issues/444)
- I want to create Windows Application in Visual Studio 2015 c++, and i have a problem [\#443](https://github.com/nlohmann/json/issues/443)
- Implicit conversion issues [\#442](https://github.com/nlohmann/json/issues/442)
- Parsing of floats locale dependent [\#302](https://github.com/nlohmann/json/issues/302)

- Speedup CI builds using cotire [\#461](https://github.com/nlohmann/json/pull/461) ([tusharpm](https://github.com/tusharpm))
- TurpentineDistillery feature/locale independent str to num [\#450](https://github.com/nlohmann/json/pull/450) ([nlohmann](https://github.com/nlohmann))
- README: adjust boost::optional example [\#439](https://github.com/nlohmann/json/pull/439) ([jaredgrubb](https://github.com/jaredgrubb))
- fix \#414 - comparing to 0 literal [\#415](https://github.com/nlohmann/json/pull/415) ([stanmihai4](https://github.com/stanmihai4))
- locale-independent num-to-str [\#378](https://github.com/nlohmann/json/pull/378) ([TurpentineDistillery](https://github.com/TurpentineDistillery))

## [v2.1.0](https://github.com/nlohmann/json/releases/tag/v2.1.0) (2017-01-28)

[Full Changelog](https://github.com/nlohmann/json/compare/2.1.0...v2.1.0)

## [2.1.0](https://github.com/nlohmann/json/releases/tag/2.1.0) (2017-01-28)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.10...2.1.0)

- Parsing multiple JSON objects from a string or stream [\#438](https://github.com/nlohmann/json/issues/438)
- Use-of-uninitialized-value \(OSS-Fuzz issue 477\) [\#437](https://github.com/nlohmann/json/issues/437)
- add `reserve` function for array to reserve memory before adding json values into it [\#436](https://github.com/nlohmann/json/issues/436)
- Typo in examples page [\#434](https://github.com/nlohmann/json/issues/434)
- avoid malformed json [\#433](https://github.com/nlohmann/json/issues/433)
- How to add json objects to a map? [\#432](https://github.com/nlohmann/json/issues/432)
- create json instance from raw json \(unsigned char\*\) [\#431](https://github.com/nlohmann/json/issues/431)
- Getting std::invalid\_argument: stream error when following example [\#429](https://github.com/nlohmann/json/issues/429)
- Forward declare-only header? [\#427](https://github.com/nlohmann/json/issues/427)
- Implicit conversion from array to object [\#425](https://github.com/nlohmann/json/issues/425)
- error C4996: 'strerror' when reading file [\#422](https://github.com/nlohmann/json/issues/422)
- Get an error - JSON pointer must be empty or begin with '/' [\#421](https://github.com/nlohmann/json/issues/421)
- size parameter for parse\(\) [\#419](https://github.com/nlohmann/json/issues/419)
- json.hpp forcibly defines GCC\_VERSION [\#417](https://github.com/nlohmann/json/issues/417)
- Use-of-uninitialized-value \(OSS-Fuzz issue 377\) [\#416](https://github.com/nlohmann/json/issues/416)
- comparing to 0 literal [\#414](https://github.com/nlohmann/json/issues/414)
- Single char converted to ASCII code instead of string [\#413](https://github.com/nlohmann/json/issues/413)
- How to know if a string  was parsed as utf-8? [\#406](https://github.com/nlohmann/json/issues/406)
- Overloaded += to add objects to an array makes no sense? [\#404](https://github.com/nlohmann/json/issues/404)
- Finding a value in an array [\#399](https://github.com/nlohmann/json/issues/399)
- add release information in static function [\#397](https://github.com/nlohmann/json/issues/397)
- Optimize memory usage of json objects in combination with binary serialization [\#373](https://github.com/nlohmann/json/issues/373)
- Conversion operators not considered [\#369](https://github.com/nlohmann/json/issues/369)
- Append ".0" to serialized floating\_point values that are digits-only. [\#362](https://github.com/nlohmann/json/issues/362)
- Add a customization point for user-defined types [\#328](https://github.com/nlohmann/json/issues/328)
- Conformance report for reference [\#307](https://github.com/nlohmann/json/issues/307)
- Document the best way to serialize/deserialize user defined types to json [\#298](https://github.com/nlohmann/json/issues/298)
- Add StringView template typename to basic\_json [\#297](https://github.com/nlohmann/json/issues/297)
- \[Improvement\] Add option to remove exceptions [\#296](https://github.com/nlohmann/json/issues/296)
- Performance in miloyip/nativejson-benchmark [\#202](https://github.com/nlohmann/json/issues/202)

- conversion from/to user-defined types [\#435](https://github.com/nlohmann/json/pull/435) ([nlohmann](https://github.com/nlohmann))
- Fix documentation error [\#430](https://github.com/nlohmann/json/pull/430) ([vjon](https://github.com/vjon))

## [v2.0.10](https://github.com/nlohmann/json/releases/tag/v2.0.10) (2017-01-02)

[Full Changelog](https://github.com/nlohmann/json/compare/2.0.10...v2.0.10)

## [2.0.10](https://github.com/nlohmann/json/releases/tag/2.0.10) (2017-01-02)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.9...2.0.10)

- Heap-buffer-overflow \(OSS-Fuzz issue 367\) [\#412](https://github.com/nlohmann/json/issues/412)
- Heap-buffer-overflow \(OSS-Fuzz issue 366\) [\#411](https://github.com/nlohmann/json/issues/411)
- Use-of-uninitialized-value \(OSS-Fuzz issue 347\) [\#409](https://github.com/nlohmann/json/issues/409)
- Heap-buffer-overflow \(OSS-Fuzz issue 344\) [\#408](https://github.com/nlohmann/json/issues/408)
- Heap-buffer-overflow \(OSS-Fuzz issue 343\) [\#407](https://github.com/nlohmann/json/issues/407)
- Heap-buffer-overflow \(OSS-Fuzz issue 342\) [\#405](https://github.com/nlohmann/json/issues/405)
- strerror throwing error in compiler VS2015 [\#403](https://github.com/nlohmann/json/issues/403)
- json::parse of std::string being underlined by Visual Studio [\#402](https://github.com/nlohmann/json/issues/402)
- Explicitly getting string without .dump\(\)  [\#401](https://github.com/nlohmann/json/issues/401)
- Possible to speed up json::parse? [\#398](https://github.com/nlohmann/json/issues/398)
- the alphabetic order in the code influence console\_output. [\#396](https://github.com/nlohmann/json/issues/396)
- Execute tests with clang sanitizers [\#394](https://github.com/nlohmann/json/issues/394)
- Check if library can be used with ETL [\#361](https://github.com/nlohmann/json/issues/361)

- Feature/clang sanitize [\#410](https://github.com/nlohmann/json/pull/410) ([Daniel599](https://github.com/Daniel599))
- Add Doozer build badge [\#400](https://github.com/nlohmann/json/pull/400) ([andoma](https://github.com/andoma))

## [v2.0.9](https://github.com/nlohmann/json/releases/tag/v2.0.9) (2016-12-16)

[Full Changelog](https://github.com/nlohmann/json/compare/2.0.9...v2.0.9)

## [2.0.9](https://github.com/nlohmann/json/releases/tag/2.0.9) (2016-12-16)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.8...2.0.9)

- \#pragma GCC diagnostic ignored "-Wdocumentation" [\#393](https://github.com/nlohmann/json/issues/393)
- How to parse this json file and write separate sub object as json files? [\#392](https://github.com/nlohmann/json/issues/392)
- Integer-overflow \(OSS-Fuzz issue 267\) [\#389](https://github.com/nlohmann/json/issues/389)
- Implement indefinite-length types from RFC 7049 [\#387](https://github.com/nlohmann/json/issues/387)
- template parameter "T" is not used in declaring the parameter types of function template [\#386](https://github.com/nlohmann/json/issues/386)
- Serializing json instances containing already serialized string values without escaping [\#385](https://github.com/nlohmann/json/issues/385)
- Add test cases from RFC 7049 [\#384](https://github.com/nlohmann/json/issues/384)
- Add a table of contents to the README file [\#383](https://github.com/nlohmann/json/issues/383)
- Update FAQ section in the guidelines for contributing [\#382](https://github.com/nlohmann/json/issues/382)
- Allow for forward declaring nlohmann::json [\#381](https://github.com/nlohmann/json/issues/381)
- Bug in overflow detection when parsing integers [\#380](https://github.com/nlohmann/json/issues/380)
- A unique name to mention the library? [\#377](https://github.com/nlohmann/json/issues/377)
- Non-unique keys in objects. [\#375](https://github.com/nlohmann/json/issues/375)
- Request: binary serialization/deserialization [\#358](https://github.com/nlohmann/json/issues/358)

- Replace class iterator and const\_iterator by using a single template class to reduce code. [\#395](https://github.com/nlohmann/json/pull/395) ([Bosswestfalen](https://github.com/Bosswestfalen))
- Clang: quiet a warning [\#391](https://github.com/nlohmann/json/pull/391) ([jaredgrubb](https://github.com/jaredgrubb))
- Fix issue \#380: Signed integer overflow check [\#390](https://github.com/nlohmann/json/pull/390) ([qwename](https://github.com/qwename))

## [v2.0.8](https://github.com/nlohmann/json/releases/tag/v2.0.8) (2016-12-02)

[Full Changelog](https://github.com/nlohmann/json/compare/2.0.8...v2.0.8)

## [2.0.8](https://github.com/nlohmann/json/releases/tag/2.0.8) (2016-12-02)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.7...2.0.8)

- Reading from file [\#374](https://github.com/nlohmann/json/issues/374)
- Compiler warnings? [\#372](https://github.com/nlohmann/json/issues/372)
- docs: how to release a json object in memory? [\#371](https://github.com/nlohmann/json/issues/371)
- crash in dump [\#370](https://github.com/nlohmann/json/issues/370)
- Coverity issue \(FORWARD\_NULL\) in lexer\(std::istream& s\) [\#368](https://github.com/nlohmann/json/issues/368)
- json::parse on failed stream gets stuck [\#366](https://github.com/nlohmann/json/issues/366)
- Performance improvements [\#365](https://github.com/nlohmann/json/issues/365)
- 'to\_string' is not a member of 'std'  [\#364](https://github.com/nlohmann/json/issues/364)
- Crash in dump\(\) from a static object [\#359](https://github.com/nlohmann/json/issues/359)
- json::parse\(...\) vs json j; j.parse\(...\) [\#357](https://github.com/nlohmann/json/issues/357)
- Hi, is there any method to dump  json to string with the insert order rather than alphabets [\#356](https://github.com/nlohmann/json/issues/356)
- Provide an example of reading from an json with only a key that has an array of strings. [\#354](https://github.com/nlohmann/json/issues/354)
- Request: access with default value. [\#353](https://github.com/nlohmann/json/issues/353)
- {} and \[\] causes parser error. [\#352](https://github.com/nlohmann/json/issues/352)
- Reading a JSON file into a JSON object [\#351](https://github.com/nlohmann/json/issues/351)
- Request: 'emplace\_back' [\#349](https://github.com/nlohmann/json/issues/349)
- Is it possible to stream data through the json parser without storing everything in memory? [\#347](https://github.com/nlohmann/json/issues/347)
- pure virtual conversion operator [\#346](https://github.com/nlohmann/json/issues/346)
- Floating point precision lost [\#345](https://github.com/nlohmann/json/issues/345)
- unit-conversions SIGSEGV on armv7hl [\#303](https://github.com/nlohmann/json/issues/303)
- Coverity scan fails [\#299](https://github.com/nlohmann/json/issues/299)
- Using QString as string type [\#274](https://github.com/nlohmann/json/issues/274)

## [v2.0.7](https://github.com/nlohmann/json/releases/tag/v2.0.7) (2016-11-02)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.6...v2.0.7)

- JSON5 [\#348](https://github.com/nlohmann/json/issues/348)
- Check "Parsing JSON is a Minefield" [\#344](https://github.com/nlohmann/json/issues/344)
- Allow hex numbers [\#342](https://github.com/nlohmann/json/issues/342)
- Convert strings to numbers [\#341](https://github.com/nlohmann/json/issues/341)
- ""-operators ignore the length parameter [\#340](https://github.com/nlohmann/json/issues/340)
- JSON into std::tuple [\#339](https://github.com/nlohmann/json/issues/339)
- JSON into vector [\#335](https://github.com/nlohmann/json/issues/335)
- Installing with Homebrew on Mac Errors \(El Capitan\) [\#331](https://github.com/nlohmann/json/issues/331)
- g++ make check results in error [\#312](https://github.com/nlohmann/json/issues/312)
- Cannot convert from 'json' to 'char' [\#276](https://github.com/nlohmann/json/issues/276)
- Please add a Pretty-Print option for arrays to stay always in one line [\#229](https://github.com/nlohmann/json/issues/229)
- Conversion to STL map\<string, vector\<int\>\> gives error [\#220](https://github.com/nlohmann/json/issues/220)
- std::unorderd\_map cannot be used as ObjectType [\#164](https://github.com/nlohmann/json/issues/164)

- fix minor grammar/style issue in README.md [\#336](https://github.com/nlohmann/json/pull/336) ([seeekr](https://github.com/seeekr))

## [v2.0.6](https://github.com/nlohmann/json/releases/tag/v2.0.6) (2016-10-15)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.5...v2.0.6)

- How to handle json files? [\#333](https://github.com/nlohmann/json/issues/333)
- This file requires compiler and library support .... [\#332](https://github.com/nlohmann/json/issues/332)
- Segmentation fault on saving json to file [\#326](https://github.com/nlohmann/json/issues/326)
- parse error - unexpected \<uninitialized\> with 2.0.5 [\#325](https://github.com/nlohmann/json/issues/325)
- Add nested object capability to pointers [\#323](https://github.com/nlohmann/json/issues/323)
- Fix usage examples' comments for std::multiset [\#322](https://github.com/nlohmann/json/issues/322)
- json\_unit runs forever when executed in build directory [\#319](https://github.com/nlohmann/json/issues/319)
- Visual studio 2015 update3 true != TRUE [\#317](https://github.com/nlohmann/json/issues/317)
- releasing single header file in compressed format [\#316](https://github.com/nlohmann/json/issues/316)
- json object from std::ifstream [\#315](https://github.com/nlohmann/json/issues/315)

- make has\_mapped\_type struct friendly [\#324](https://github.com/nlohmann/json/pull/324) ([vpetrigo](https://github.com/vpetrigo))
- Fix usage examples' comments for std::multiset [\#321](https://github.com/nlohmann/json/pull/321) ([vasild](https://github.com/vasild))
- Include dir relocation [\#318](https://github.com/nlohmann/json/pull/318) ([ChristophJud](https://github.com/ChristophJud))
- trivial documentation fix [\#313](https://github.com/nlohmann/json/pull/313) ([5tefan](https://github.com/5tefan))

## [v2.0.5](https://github.com/nlohmann/json/releases/tag/v2.0.5) (2016-09-14)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.4...v2.0.5)

- \[feature request\]: schema validator and comments [\#311](https://github.com/nlohmann/json/issues/311)
- make json\_benchmarks no longer working in 2.0.4 [\#310](https://github.com/nlohmann/json/issues/310)
- Segmentation fault \(core dumped\) [\#309](https://github.com/nlohmann/json/issues/309)
- No matching member function for call to 'get\_impl' [\#308](https://github.com/nlohmann/json/issues/308)

## [v2.0.4](https://github.com/nlohmann/json/releases/tag/v2.0.4) (2016-09-11)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.3...v2.0.4)

- Parsing fails without space at end of file [\#306](https://github.com/nlohmann/json/issues/306)
- json schema validator [\#305](https://github.com/nlohmann/json/issues/305)
- Unused variable warning [\#304](https://github.com/nlohmann/json/issues/304)

## [v2.0.3](https://github.com/nlohmann/json/releases/tag/v2.0.3) (2016-08-31)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.2...v2.0.3)

- warning C4706: assignment within conditional expression [\#295](https://github.com/nlohmann/json/issues/295)
- Q: Is it possible to build json tree from already UTF8 encoded values? [\#293](https://github.com/nlohmann/json/issues/293)
- Equality operator results in array when assigned object [\#292](https://github.com/nlohmann/json/issues/292)
- Support for integers not from the range \[-\(2\*\*53\)+1, \(2\*\*53\)-1\] in parser [\#291](https://github.com/nlohmann/json/issues/291)
- Support for iterator-range parsing [\#290](https://github.com/nlohmann/json/issues/290)
- Horribly inconsistent behavior between const/non-const reference in operator \[\] \(\) [\#289](https://github.com/nlohmann/json/issues/289)
- Silently get numbers into smaller types [\#288](https://github.com/nlohmann/json/issues/288)
- Incorrect parsing of large int64\_t numbers [\#287](https://github.com/nlohmann/json/issues/287)
- \[question\]: macro to disable floating point support [\#284](https://github.com/nlohmann/json/issues/284)

- unit-constructor1.cpp: Fix floating point truncation warning [\#300](https://github.com/nlohmann/json/pull/300) ([t-b](https://github.com/t-b))

## [v2.0.2](https://github.com/nlohmann/json/releases/tag/v2.0.2) (2016-07-31)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.1...v2.0.2)

- can function dump\(\)  return string in the order I push in the json object ? [\#286](https://github.com/nlohmann/json/issues/286)
- Error on the Mac: Undefined symbols for architecture x86\_64 [\#285](https://github.com/nlohmann/json/issues/285)
- value\(\) does not work with \_json\_pointer types [\#283](https://github.com/nlohmann/json/issues/283)
- Build error for std::int64 [\#282](https://github.com/nlohmann/json/issues/282)
- strings can't be accessed after dump\(\)-\>parse\(\) - type is lost [\#281](https://github.com/nlohmann/json/issues/281)
- Easy serialization of classes [\#280](https://github.com/nlohmann/json/issues/280)
- recursive data structures [\#277](https://github.com/nlohmann/json/issues/277)
- hexify\(\) function emits conversion warning [\#270](https://github.com/nlohmann/json/issues/270)

- let the makefile choose the correct sed [\#279](https://github.com/nlohmann/json/pull/279) ([murinicanor](https://github.com/murinicanor))
- Update hexify to use array lookup instead of ternary \(\#270\) [\#275](https://github.com/nlohmann/json/pull/275) ([dtoma](https://github.com/dtoma))

## [v2.0.1](https://github.com/nlohmann/json/releases/tag/v2.0.1) (2016-06-28)

[Full Changelog](https://github.com/nlohmann/json/compare/v2.0.0...v2.0.1)

- Compilation error. [\#273](https://github.com/nlohmann/json/issues/273)
- dump\(\) performance degradation in v2 [\#272](https://github.com/nlohmann/json/issues/272)

- fixed a tiny typo [\#271](https://github.com/nlohmann/json/pull/271) ([feroldi](https://github.com/feroldi))

## [v2.0.0](https://github.com/nlohmann/json/releases/tag/v2.0.0) (2016-06-23)

[Full Changelog](https://github.com/nlohmann/json/compare/v1.1.0...v2.0.0)

- json::diff generates incorrect patch when removing multiple array elements. [\#269](https://github.com/nlohmann/json/issues/269)
- Docs - What does Json\[key\] return? [\#267](https://github.com/nlohmann/json/issues/267)
- Compiler Errors With JSON.hpp [\#265](https://github.com/nlohmann/json/issues/265)
- Ambiguous push\_back and operator+= overloads [\#263](https://github.com/nlohmann/json/issues/263)
- Preseving order of items in json [\#262](https://github.com/nlohmann/json/issues/262)
- '\' char problem in strings [\#261](https://github.com/nlohmann/json/issues/261)
- VS2015 compile fail [\#260](https://github.com/nlohmann/json/issues/260)
- -Wconversion warning [\#259](https://github.com/nlohmann/json/issues/259)
- Maybe a bug [\#258](https://github.com/nlohmann/json/issues/258)
- Few tests failed on Visual C++ 2015 [\#257](https://github.com/nlohmann/json/issues/257)
- Access keys when iteration with new for loop C++11 [\#256](https://github.com/nlohmann/json/issues/256)
- multiline text values [\#255](https://github.com/nlohmann/json/issues/255)
- Error when using json in g++ [\#254](https://github.com/nlohmann/json/issues/254)
- is the release 2.0? [\#253](https://github.com/nlohmann/json/issues/253)
- concatenate objects [\#252](https://github.com/nlohmann/json/issues/252)
- Encoding [\#251](https://github.com/nlohmann/json/issues/251)
- Unable to build example for constructing json object with stringstreams [\#250](https://github.com/nlohmann/json/issues/250)
- Hexadecimal support [\#249](https://github.com/nlohmann/json/issues/249)
- Update long-term goals [\#246](https://github.com/nlohmann/json/issues/246)
- Contribution To This Json Project [\#245](https://github.com/nlohmann/json/issues/245)
- Trouble using parser with initial dictionary [\#243](https://github.com/nlohmann/json/issues/243)
- Unit test fails when doing a CMake out-of-tree build [\#241](https://github.com/nlohmann/json/issues/241)
- -Wconversion warnings [\#239](https://github.com/nlohmann/json/issues/239)
- Additional integration options [\#237](https://github.com/nlohmann/json/issues/237)
- .get\<std::string\>\(\) works for non spaced string but returns as array for spaced/longer strings [\#236](https://github.com/nlohmann/json/issues/236)
- ambiguous overload for 'push\_back' and 'operator+=' [\#235](https://github.com/nlohmann/json/issues/235)
- Can't use basic\_json::iterator as a base iterator for std::move\_iterator [\#233](https://github.com/nlohmann/json/issues/233)
- json object's creation can freezes execution [\#231](https://github.com/nlohmann/json/issues/231)
- Incorrect dumping of parsed numbers with exponents, but without decimal places [\#230](https://github.com/nlohmann/json/issues/230)
- double values are serialized with commas as decimal points [\#228](https://github.com/nlohmann/json/issues/228)
- Move semantics with std::initializer\_list [\#225](https://github.com/nlohmann/json/issues/225)
- replace emplace [\#224](https://github.com/nlohmann/json/issues/224)
- abort during getline in yyfill [\#223](https://github.com/nlohmann/json/issues/223)
- free\(\): invalid pointer error in GCC 5.2.1 [\#221](https://github.com/nlohmann/json/issues/221)
- Error compile Android NDK  error: 'strtof' is not a member of 'std' [\#219](https://github.com/nlohmann/json/issues/219)
- Wrong link in the README.md [\#217](https://github.com/nlohmann/json/issues/217)
- Wide character strings not supported [\#216](https://github.com/nlohmann/json/issues/216)
- Memory allocations using range-based for loops [\#214](https://github.com/nlohmann/json/issues/214)
- would you like to support gcc 4.8.1?  [\#211](https://github.com/nlohmann/json/issues/211)
- Reading concatenated json's from an istream [\#210](https://github.com/nlohmann/json/issues/210)
- Conflicting typedef of ssize\_t on Windows 32 bit when using Boost.Python [\#204](https://github.com/nlohmann/json/issues/204)
- Inconsistency between operator\[\] and push\_back [\#203](https://github.com/nlohmann/json/issues/203)
- Small bugs in json.hpp \(get\_number\) and unit.cpp \(non-standard integer type test\) [\#199](https://github.com/nlohmann/json/issues/199)
- GCC/clang floating point parsing bug in strtod\(\) [\#195](https://github.com/nlohmann/json/issues/195)
- What is within scope? [\#192](https://github.com/nlohmann/json/issues/192)
- Bugs in miloyip/nativejson-benchmark: roundtrips [\#187](https://github.com/nlohmann/json/issues/187)
- Floating point exceptions [\#181](https://github.com/nlohmann/json/issues/181)
- Integer conversion to unsigned [\#178](https://github.com/nlohmann/json/issues/178)
- map string string fails to compile [\#176](https://github.com/nlohmann/json/issues/176)
- In basic\_json::basic\_json\(const CompatibleArrayType& val\), the requirement of CompatibleArrayType is not strict enough. [\#174](https://github.com/nlohmann/json/issues/174)
- Provide a FAQ [\#163](https://github.com/nlohmann/json/issues/163)
- Implicit assignment to std::string fails [\#144](https://github.com/nlohmann/json/issues/144)

- Fix Issue \#265 [\#266](https://github.com/nlohmann/json/pull/266) ([06needhamt](https://github.com/06needhamt))
- Define CMake/CTest tests [\#247](https://github.com/nlohmann/json/pull/247) ([robertmrk](https://github.com/robertmrk))
- Out of tree builds and a few other miscellaneous CMake cleanups. [\#242](https://github.com/nlohmann/json/pull/242) ([ChrisKitching](https://github.com/ChrisKitching))
- Implement additional integration options [\#238](https://github.com/nlohmann/json/pull/238) ([robertmrk](https://github.com/robertmrk))
- make serialization locale-independent [\#232](https://github.com/nlohmann/json/pull/232) ([nlohmann](https://github.com/nlohmann))
- fixes \#223 by updating README.md [\#227](https://github.com/nlohmann/json/pull/227) ([kevin--](https://github.com/kevin--))
- Use namespace std for int64\_t and uint64\_t [\#226](https://github.com/nlohmann/json/pull/226) ([lv-zheng](https://github.com/lv-zheng))
- Added missing cerrno header to fix ERANGE compile error on android [\#222](https://github.com/nlohmann/json/pull/222) ([Teemperor](https://github.com/Teemperor))
- Corrected readme [\#218](https://github.com/nlohmann/json/pull/218) ([Annihil](https://github.com/Annihil))
- Create PULL\_REQUEST\_TEMPLATE.md [\#213](https://github.com/nlohmann/json/pull/213) ([whackashoe](https://github.com/whackashoe))
- fixed noexcept; added constexpr [\#208](https://github.com/nlohmann/json/pull/208) ([nlohmann](https://github.com/nlohmann))
- Add support for afl-fuzz testing [\#207](https://github.com/nlohmann/json/pull/207) ([mykter](https://github.com/mykter))
- replaced ssize\_t occurrences with auto \(addresses \#204\) [\#205](https://github.com/nlohmann/json/pull/205) ([nlohmann](https://github.com/nlohmann))
- Fixed issue \#199 - Small bugs in json.hpp \(get\_number\) and unit.cpp \(non-standard integer type test\) [\#200](https://github.com/nlohmann/json/pull/200) ([twelsby](https://github.com/twelsby))
- Fix broken link [\#197](https://github.com/nlohmann/json/pull/197) ([vog](https://github.com/vog))
- Issue \#195 - update Travis to Trusty due to gcc/clang strtod\(\) bug [\#196](https://github.com/nlohmann/json/pull/196) ([twelsby](https://github.com/twelsby))
- Issue \#178 - Extending support to full uint64\_t/int64\_t range and unsigned type \(updated\) [\#193](https://github.com/nlohmann/json/pull/193) ([twelsby](https://github.com/twelsby))

## [v1.1.0](https://github.com/nlohmann/json/releases/tag/v1.1.0) (2016-01-24)

[Full Changelog](https://github.com/nlohmann/json/compare/v1.0.0...v1.1.0)

- Small error in pull \#185 [\#194](https://github.com/nlohmann/json/issues/194)
- Bugs in miloyip/nativejson-benchmark: floating-point parsing [\#186](https://github.com/nlohmann/json/issues/186)
- Floating point equality [\#185](https://github.com/nlohmann/json/issues/185)
- Unused variables in catch [\#180](https://github.com/nlohmann/json/issues/180)
- Typo in documentation [\#179](https://github.com/nlohmann/json/issues/179)
- JSON performance benchmark comparision [\#177](https://github.com/nlohmann/json/issues/177)
- Since re2c is often ignored in pull requests, it may make sense to make a contributing.md file [\#175](https://github.com/nlohmann/json/issues/175)
- Question about exceptions [\#173](https://github.com/nlohmann/json/issues/173)
- Android? [\#172](https://github.com/nlohmann/json/issues/172)
- Cannot index by key of type static constexpr const char\* [\#171](https://github.com/nlohmann/json/issues/171)
- Add assertions [\#168](https://github.com/nlohmann/json/issues/168)
- MSVC 2015 build fails when attempting to compare object\_t [\#167](https://github.com/nlohmann/json/issues/167)
- Member detector is not portable [\#166](https://github.com/nlohmann/json/issues/166)
- Unnecessary const\_cast [\#162](https://github.com/nlohmann/json/issues/162)
- Question about get\_ref\(\) [\#128](https://github.com/nlohmann/json/issues/128)
- range based for loop for objects [\#83](https://github.com/nlohmann/json/issues/83)
- Consider submitting this to the Boost Library Incubator [\#66](https://github.com/nlohmann/json/issues/66)

- Fixed Issue \#186 - add strto\(f|d|ld\) overload wrappers, "-0.0" special case and FP trailing zero [\#191](https://github.com/nlohmann/json/pull/191) ([twelsby](https://github.com/twelsby))
- Issue \#185 - remove approx\(\) and use \#pragma to kill warnings [\#190](https://github.com/nlohmann/json/pull/190) ([twelsby](https://github.com/twelsby))
- Fixed Issue \#171 - added two extra template overloads of operator\[\] for T\* arguments [\#189](https://github.com/nlohmann/json/pull/189) ([twelsby](https://github.com/twelsby))
- Fixed issue \#167 - removed operator ValueType\(\) condition for VS2015 [\#188](https://github.com/nlohmann/json/pull/188) ([twelsby](https://github.com/twelsby))
- Implementation of get\_ref\(\) [\#184](https://github.com/nlohmann/json/pull/184) ([dariomt](https://github.com/dariomt))
- Fixed some typos in CONTRIBUTING.md [\#182](https://github.com/nlohmann/json/pull/182) ([nibroc](https://github.com/nibroc))

## [v1.0.0](https://github.com/nlohmann/json/releases/tag/v1.0.0) (2015-12-27)

[Full Changelog](https://github.com/nlohmann/json/compare/v1.0.0-rc1...v1.0.0)

- add key name to exception [\#160](https://github.com/nlohmann/json/issues/160)
- Getting member discarding qualifyer [\#159](https://github.com/nlohmann/json/issues/159)
- basic\_json::iterator::value\(\) output includes quotes while basic\_json::iterator::key\(\) doesn't [\#158](https://github.com/nlohmann/json/issues/158)
- Indexing `const basic_json<>` with `const basic_string<char>` [\#157](https://github.com/nlohmann/json/issues/157)
- token\_type\_name\(token\_type t\): not all control paths return a value [\#156](https://github.com/nlohmann/json/issues/156)
- prevent json.hpp from emitting compiler warnings [\#154](https://github.com/nlohmann/json/issues/154)
- json::parse\(string\) does not check utf8 bom [\#152](https://github.com/nlohmann/json/issues/152)
- unsigned 64bit values output as signed [\#151](https://github.com/nlohmann/json/issues/151)
- Wish feature: json5 [\#150](https://github.com/nlohmann/json/issues/150)
- Unable to compile on MSVC 2015 with SDL checking enabled: This function or variable may be unsafe. [\#149](https://github.com/nlohmann/json/issues/149)
- "Json Object" type does not keep object order [\#148](https://github.com/nlohmann/json/issues/148)
- dump\(\)  convert strings encoded by utf-8 to shift-jis on windows 10.  [\#147](https://github.com/nlohmann/json/issues/147)
- Unable to get field names in a json object [\#145](https://github.com/nlohmann/json/issues/145)
- Question: Is the use of incomplete type correct? [\#138](https://github.com/nlohmann/json/issues/138)
- json.hpp:5746:32: error: 'to\_string' is not a member of 'std' [\#136](https://github.com/nlohmann/json/issues/136)
- Bug in basic\_json::operator\[\] const overload [\#135](https://github.com/nlohmann/json/issues/135)
- wrong enable\_if for const pointer \(instead of pointer-to-const\) [\#134](https://github.com/nlohmann/json/issues/134)
- overload of at\(\) with default value [\#133](https://github.com/nlohmann/json/issues/133)
- Splitting source [\#132](https://github.com/nlohmann/json/issues/132)
- Question about get\_ptr\(\) [\#127](https://github.com/nlohmann/json/issues/127)
- Visual Studio 14 Debug assertion failed [\#125](https://github.com/nlohmann/json/issues/125)
- Memory leak in face of exceptions [\#118](https://github.com/nlohmann/json/issues/118)
- Find and Count for arrays [\#117](https://github.com/nlohmann/json/issues/117)
- dynamically constructing an arbitrarily nested object [\#114](https://github.com/nlohmann/json/issues/114)
- Returning any data type [\#113](https://github.com/nlohmann/json/issues/113)
- Compile error with g++ 4.9.3 cygwin 64-bit [\#112](https://github.com/nlohmann/json/issues/112)
- insert json array issue with gcc4.8.2 [\#110](https://github.com/nlohmann/json/issues/110)
- error: unterminated raw string [\#109](https://github.com/nlohmann/json/issues/109)
- vector\<json\> copy constructor really weird [\#108](https://github.com/nlohmann/json/issues/108)
- \[clang-3.6.2\] string/sstream with number to json issue [\#107](https://github.com/nlohmann/json/issues/107)
- object field accessors [\#103](https://github.com/nlohmann/json/issues/103)
- v8pp and json [\#95](https://github.com/nlohmann/json/issues/95)
- Wishlist [\#65](https://github.com/nlohmann/json/issues/65)
- Windows/Visual Studio \(through 2013\) is unsupported [\#62](https://github.com/nlohmann/json/issues/62)

- Replace sprintf with hex function, this fixes \#149 [\#153](https://github.com/nlohmann/json/pull/153) ([whackashoe](https://github.com/whackashoe))
- Fix character skipping after a surrogate pair [\#146](https://github.com/nlohmann/json/pull/146) ([robertmrk](https://github.com/robertmrk))
- Detect correctly pointer-to-const [\#137](https://github.com/nlohmann/json/pull/137) ([dariomt](https://github.com/dariomt))
- disabled "CopyAssignable" test for MSVC in Debug mode, see \#125 [\#131](https://github.com/nlohmann/json/pull/131) ([dariomt](https://github.com/dariomt))
- removed stream operator for iterator, resolution for \#125 [\#130](https://github.com/nlohmann/json/pull/130) ([dariomt](https://github.com/dariomt))
- fixed typos in comments for examples [\#129](https://github.com/nlohmann/json/pull/129) ([dariomt](https://github.com/dariomt))
- Remove superfluous inefficiency [\#126](https://github.com/nlohmann/json/pull/126) ([d-frey](https://github.com/d-frey))
- remove invalid parameter '-stdlib=libc++' in CMakeLists.txt [\#124](https://github.com/nlohmann/json/pull/124) ([emvivre](https://github.com/emvivre))
- exception-safe object creation, fixes \#118 [\#122](https://github.com/nlohmann/json/pull/122) ([d-frey](https://github.com/d-frey))
- Fix small oversight. [\#121](https://github.com/nlohmann/json/pull/121) ([ColinH](https://github.com/ColinH))
- Overload parse\(\) to accept an rvalue reference [\#120](https://github.com/nlohmann/json/pull/120) ([silverweed](https://github.com/silverweed))
- Use the right variable name in doc string [\#115](https://github.com/nlohmann/json/pull/115) ([whoshuu](https://github.com/whoshuu))

## [v1.0.0-rc1](https://github.com/nlohmann/json/releases/tag/v1.0.0-rc1) (2015-07-26)

[Full Changelog](https://github.com/nlohmann/json/compare/4502e7e51c0569419c26e75fbdd5748170603e54...v1.0.0-rc1)

- Finish documenting the public interface in Doxygen [\#102](https://github.com/nlohmann/json/issues/102)
- Binary string causes numbers to be dumped as hex [\#101](https://github.com/nlohmann/json/issues/101)
- failed to iterator json object with reverse\_iterator [\#100](https://github.com/nlohmann/json/issues/100)
- 'noexcept' : unknown override specifier [\#99](https://github.com/nlohmann/json/issues/99)
- json float parsing problem [\#98](https://github.com/nlohmann/json/issues/98)
- Adjust wording to JSON RFC [\#97](https://github.com/nlohmann/json/issues/97)
- static analysis warnings [\#94](https://github.com/nlohmann/json/issues/94)
- reverse\_iterator operator inheritance problem [\#93](https://github.com/nlohmann/json/issues/93)
- init error [\#92](https://github.com/nlohmann/json/issues/92)
- access by \(const\) reference [\#91](https://github.com/nlohmann/json/issues/91)
- is\_integer and is\_float tests [\#90](https://github.com/nlohmann/json/issues/90)
- Nonstandard integer type [\#89](https://github.com/nlohmann/json/issues/89)
- static library build [\#84](https://github.com/nlohmann/json/issues/84)
- lexer::get\_number return NAN [\#82](https://github.com/nlohmann/json/issues/82)
- MinGW have no std::to\_string [\#80](https://github.com/nlohmann/json/issues/80)
- Incorrect behaviour of basic\_json::count method [\#78](https://github.com/nlohmann/json/issues/78)
- Invoking is\_array\(\) function creates "null" value [\#77](https://github.com/nlohmann/json/issues/77)
- dump\(\) / parse\(\) not idempotent [\#76](https://github.com/nlohmann/json/issues/76)
- Handle infinity and NaN cases [\#70](https://github.com/nlohmann/json/issues/70)
- errors in g++-4.8.1 [\#68](https://github.com/nlohmann/json/issues/68)
- Keys when iterating over objects [\#67](https://github.com/nlohmann/json/issues/67)
- Compilation results in tons of warnings [\#64](https://github.com/nlohmann/json/issues/64)
- Complete brief documentation [\#61](https://github.com/nlohmann/json/issues/61)
- Double quotation mark is not parsed correctly [\#60](https://github.com/nlohmann/json/issues/60)
- Get coverage back to 100% [\#58](https://github.com/nlohmann/json/issues/58)
- erase elements using iterators [\#57](https://github.com/nlohmann/json/issues/57)
- Removing item from array [\#56](https://github.com/nlohmann/json/issues/56)
- Serialize/Deserialize like PHP? [\#55](https://github.com/nlohmann/json/issues/55)
- Numbers as keys [\#54](https://github.com/nlohmann/json/issues/54)
- Why are elements alphabetized on key while iterating? [\#53](https://github.com/nlohmann/json/issues/53)
- Document erase, count, and iterators key and value [\#52](https://github.com/nlohmann/json/issues/52)
- Do not use std::to\_string [\#51](https://github.com/nlohmann/json/issues/51)
- Supported compilers [\#50](https://github.com/nlohmann/json/issues/50)
- Confused about iterating through json objects [\#49](https://github.com/nlohmann/json/issues/49)
- Use non-member begin/end [\#48](https://github.com/nlohmann/json/issues/48)
- Erase key [\#47](https://github.com/nlohmann/json/issues/47)
- Key iterator [\#46](https://github.com/nlohmann/json/issues/46)
- Add count member function [\#45](https://github.com/nlohmann/json/issues/45)
- Problem getting vector \(array\) of strings [\#44](https://github.com/nlohmann/json/issues/44)
- Compilation error due to assuming that private=public [\#43](https://github.com/nlohmann/json/issues/43)
- Use of deprecated implicit copy constructor [\#42](https://github.com/nlohmann/json/issues/42)
- Printing attribute names [\#39](https://github.com/nlohmann/json/issues/39)
- dumping a small number\_float just outputs 0.000000 [\#37](https://github.com/nlohmann/json/issues/37)
- find is error [\#32](https://github.com/nlohmann/json/issues/32)
- Avoid using spaces when encoding without pretty print [\#31](https://github.com/nlohmann/json/issues/31)
- Cannot encode long numbers [\#30](https://github.com/nlohmann/json/issues/30)
- segmentation fault when iterating over empty arrays/objects [\#28](https://github.com/nlohmann/json/issues/28)
- Creating an empty array [\#27](https://github.com/nlohmann/json/issues/27)
- Custom allocator support [\#25](https://github.com/nlohmann/json/issues/25)
- make the type of the used string container customizable [\#20](https://github.com/nlohmann/json/issues/20)
- Improper parsing of JSON string "\\" [\#17](https://github.com/nlohmann/json/issues/17)
- create a header-only version [\#16](https://github.com/nlohmann/json/issues/16)
- Don't return "const values" [\#15](https://github.com/nlohmann/json/issues/15)
- Add to\_string overload for indentation [\#13](https://github.com/nlohmann/json/issues/13)
- string parser does not recognize uncompliant strings [\#12](https://github.com/nlohmann/json/issues/12)
- possible double-free in find function [\#11](https://github.com/nlohmann/json/issues/11)
- UTF-8 encoding/deconding/testing [\#10](https://github.com/nlohmann/json/issues/10)
- move code into namespace [\#9](https://github.com/nlohmann/json/issues/9)
- free functions for explicit objects and arrays in initializer lists [\#8](https://github.com/nlohmann/json/issues/8)
- unique\_ptr for ownership [\#7](https://github.com/nlohmann/json/issues/7)
- Add unit tests [\#4](https://github.com/nlohmann/json/issues/4)
- Drop C++98 support [\#3](https://github.com/nlohmann/json/issues/3)
- Test case coverage [\#2](https://github.com/nlohmann/json/issues/2)
- Runtime error in Travis job [\#1](https://github.com/nlohmann/json/issues/1)

- Keyword 'inline' is useless when member functions are defined in headers [\#87](https://github.com/nlohmann/json/pull/87) ([ahamez](https://github.com/ahamez))
- Remove useless typename [\#86](https://github.com/nlohmann/json/pull/86) ([ahamez](https://github.com/ahamez))
- Avoid warning with Xcode's clang [\#85](https://github.com/nlohmann/json/pull/85) ([ahamez](https://github.com/ahamez))
-  Fix typos [\#73](https://github.com/nlohmann/json/pull/73) ([aqnouch](https://github.com/aqnouch))
- Replace `default_callback` function with `nullptr` and check for null… [\#72](https://github.com/nlohmann/json/pull/72) ([aburgh](https://github.com/aburgh))
- support enum [\#71](https://github.com/nlohmann/json/pull/71) ([likebeta](https://github.com/likebeta))
- Fix performance regression introduced with the parsing callback feature. [\#69](https://github.com/nlohmann/json/pull/69) ([aburgh](https://github.com/aburgh))
- Improve the implementations of the comparission-operators [\#63](https://github.com/nlohmann/json/pull/63) ([Florianjw](https://github.com/Florianjw))
- Fix compilation of json\_unit with GCC 5 [\#59](https://github.com/nlohmann/json/pull/59) ([dkopecek](https://github.com/dkopecek))
- Parse streams incrementally. [\#40](https://github.com/nlohmann/json/pull/40) ([aburgh](https://github.com/aburgh))
- Feature/small float serialization [\#38](https://github.com/nlohmann/json/pull/38) ([jrandall](https://github.com/jrandall))
- template version with re2c scanner [\#36](https://github.com/nlohmann/json/pull/36) ([nlohmann](https://github.com/nlohmann))
- more descriptive documentation in example [\#33](https://github.com/nlohmann/json/pull/33) ([luxe](https://github.com/luxe))
- Fix string conversion under Clang [\#26](https://github.com/nlohmann/json/pull/26) ([wancw](https://github.com/wancw))
- Fixed dumping of strings [\#24](https://github.com/nlohmann/json/pull/24) ([Teemperor](https://github.com/Teemperor))
- Added a remark to the readme that coverage is GCC only for now [\#23](https://github.com/nlohmann/json/pull/23) ([Teemperor](https://github.com/Teemperor))
- Unicode escaping [\#22](https://github.com/nlohmann/json/pull/22) ([Teemperor](https://github.com/Teemperor))
- Implemented the JSON spec for string parsing for everything but the \uXXXX escaping [\#21](https://github.com/nlohmann/json/pull/21) ([Teemperor](https://github.com/Teemperor))
- add the std iterator typedefs to iterator and const\_iterator [\#19](https://github.com/nlohmann/json/pull/19) ([kirkshoop](https://github.com/kirkshoop))
- Fixed escaped quotes [\#18](https://github.com/nlohmann/json/pull/18) ([Teemperor](https://github.com/Teemperor))
- Fix double delete on std::bad\_alloc exception [\#14](https://github.com/nlohmann/json/pull/14) ([elliotgoodrich](https://github.com/elliotgoodrich))
- Added CMake and lcov [\#6](https://github.com/nlohmann/json/pull/6) ([Teemperor](https://github.com/Teemperor))
- Version 2.0 [\#5](https://github.com/nlohmann/json/pull/5) ([nlohmann](https://github.com/nlohmann))



\* *This Changelog was automatically generated by [github_changelog_generator](https://github.com/github-changelog-generator/github-changelog-generator)*

```

`API/README.md`:

```md
[![JSON for Modern C++](docs/json.gif)](https://github.com/nlohmann/json/releases)

[![Build Status](https://ci.appveyor.com/api/projects/status/1acb366xfyg3qybk/branch/develop?svg=true)](https://ci.appveyor.com/project/nlohmann/json)
[![Ubuntu](https://github.com/nlohmann/json/workflows/Ubuntu/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3AUbuntu)
[![macOS](https://github.com/nlohmann/json/workflows/macOS/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3AmacOS)
[![Windows](https://github.com/nlohmann/json/workflows/Windows/badge.svg)](https://github.com/nlohmann/json/actions?query=workflow%3AWindows)
[![Coverage Status](https://coveralls.io/repos/github/nlohmann/json/badge.svg?branch=develop)](https://coveralls.io/github/nlohmann/json?branch=develop)
[![Coverity Scan Build Status](https://scan.coverity.com/projects/5550/badge.svg)](https://scan.coverity.com/projects/nlohmann-json)
[![Codacy Badge](https://app.codacy.com/project/badge/Grade/e0d1a9d5d6fd46fcb655c4cb930bb3e8)](https://www.codacy.com/gh/nlohmann/json/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=nlohmann/json&amp;utm_campaign=Badge_Grade)
[![Cirrus CI](https://api.cirrus-ci.com/github/nlohmann/json.svg)](https://cirrus-ci.com/github/nlohmann/json)
[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/json.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:json)
[![Try online](https://img.shields.io/badge/try-online-blue.svg)](https://wandbox.org/permlink/1mp10JbaANo6FUc7)
[![Documentation](https://img.shields.io/badge/docs-mkdocs-blue.svg)](https://json.nlohmann.me)
[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/nlohmann/json/master/LICENSE.MIT)
[![GitHub Releases](https://img.shields.io/github/release/nlohmann/json.svg)](https://github.com/nlohmann/json/releases)
[![Vcpkg Version](https://img.shields.io/vcpkg/v/nlohmann-json)](https://vcpkg.link/ports/nlohmann-json)
[![Packaging status](https://repology.org/badge/tiny-repos/nlohmann-json.svg)](https://repology.org/project/nlohmann-json/versions)
[![GitHub Downloads](https://img.shields.io/github/downloads/nlohmann/json/total)](https://github.com/nlohmann/json/releases)
[![GitHub Issues](https://img.shields.io/github/issues/nlohmann/json.svg)](https://github.com/nlohmann/json/issues)
[![Average time to resolve an issue](https://isitmaintained.com/badge/resolution/nlohmann/json.svg)](https://isitmaintained.com/project/nlohmann/json "Average time to resolve an issue")
[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/289/badge)](https://bestpractices.coreinfrastructure.org/projects/289)
[![GitHub Sponsors](https://img.shields.io/badge/GitHub-Sponsors-ff69b4)](https://github.com/sponsors/nlohmann)
[![REUSE status](https://api.reuse.software/badge/github.com/nlohmann/json)](https://api.reuse.software/info/github.com/nlohmann/json)
[![Discord](https://img.shields.io/discord/1003743314341793913)](https://discord.gg/6mrGXKvX7y)

- [Design goals](#design-goals)
- [Sponsors](#sponsors)
- [Support](#support) ([documentation](https://json.nlohmann.me), [FAQ](https://json.nlohmann.me/home/faq/), [discussions](https://github.com/nlohmann/json/discussions), [API](https://json.nlohmann.me/api/basic_json/), [bug issues](https://github.com/nlohmann/json/issues))
- [Examples](#examples)
  - [Read JSON from a file](#read-json-from-a-file)
  - [Creating `json` objects from JSON literals](#creating-json-objects-from-json-literals)
  - [JSON as first-class data type](#json-as-first-class-data-type)
  - [Serialization / Deserialization](#serialization--deserialization)
  - [STL-like access](#stl-like-access)
  - [Conversion from STL containers](#conversion-from-stl-containers)
  - [JSON Pointer and JSON Patch](#json-pointer-and-json-patch)
  - [JSON Merge Patch](#json-merge-patch)
  - [Implicit conversions](#implicit-conversions)
  - [Conversions to/from arbitrary types](#arbitrary-types-conversions)
  - [Specializing enum conversion](#specializing-enum-conversion)
  - [Binary formats (BSON, CBOR, MessagePack, UBJSON, and BJData)](#binary-formats-bson-cbor-messagepack-ubjson-and-bjdata)
- [Supported compilers](#supported-compilers)
- [Integration](#integration)
  - [CMake](#cmake)
  - [Package Managers](#package-managers)
  - [Pkg-config](#pkg-config)
- [License](#license)
- [Contact](#contact)
- [Thanks](#thanks)
- [Used third-party tools](#used-third-party-tools)
- [Projects using JSON for Modern C++](#projects-using-json-for-modern-c)
- [Notes](#notes)
- [Execute unit tests](#execute-unit-tests)

## Design goals

There are myriads of [JSON](https://json.org) libraries out there, and each may even have its reason to exist. Our class had these design goals:

- **Intuitive syntax**. In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the [examples below](#examples) and you'll know what I mean.

- **Trivial integration**. Our whole code consists of a single header file [`json.hpp`](https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp). That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings.

- **Serious testing**. Our code is heavily [unit-tested](https://github.com/nlohmann/json/tree/develop/tests/src) and covers [100%](https://coveralls.io/r/nlohmann/json) of the code, including all exceptional behavior. Furthermore, we checked with [Valgrind](https://valgrind.org) and the [Clang Sanitizers](https://clang.llvm.org/docs/index.html) that there are no memory leaks. [Google OSS-Fuzz](https://github.com/google/oss-fuzz/tree/master/projects/json) additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the [Core Infrastructure Initiative (CII) best practices](https://bestpractices.coreinfrastructure.org/projects/289).

Other aspects were not so important to us:

- **Memory efficiency**. Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: `std::string` for strings, `int64_t`, `uint64_t` or `double` for numbers, `std::map` for objects, `std::vector` for arrays, and `bool` for Booleans. However, you can template the generalized class `basic_json` to your needs.

- **Speed**. There are certainly [faster JSON libraries](https://github.com/miloyip/nativejson-benchmark#parsing-time) out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a `std::vector` or `std::map`, you are already set.

See the [contribution guidelines](https://github.com/nlohmann/json/blob/master/.github/CONTRIBUTING.md#please-dont) for more information.


## Sponsors

You can sponsor this library at [GitHub Sponsors](https://github.com/sponsors/nlohmann).

### :office: Corporate Sponsor

[![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Codacy-logo-black.svg/320px-Codacy-logo-black.svg.png)](https://github.com/codacy/About)

### :label: Named Sponsors

- [Michael Hartmann](https://github.com/reFX-Mike)
- [Stefan Hagen](https://github.com/sthagen)
- [Steve Sperandeo](https://github.com/homer6)
- [Robert Jefe Lindstädt](https://github.com/eljefedelrodeodeljefe)
- [Steve Wagner](https://github.com/ciroque)
- [Lion Yang](https://github.com/LionNatsu)

Thanks everyone!

## Support

:question: If you have a **question**, please check if it is already answered in the [**FAQ**](https://json.nlohmann.me/home/faq/) or the [**Q&A**](https://github.com/nlohmann/json/discussions/categories/q-a) section. If not, please [**ask a new question**](https://github.com/nlohmann/json/discussions/new) there.

:books: If you want to **learn more** about how to use the library, check out the rest of the [**README**](#examples), have a look at [**code examples**](https://github.com/nlohmann/json/tree/develop/docs/examples), or browse through the [**help pages**](https://json.nlohmann.me).

:construction: If you want to understand the **API** better, check out the [**API Reference**](https://json.nlohmann.me/api/basic_json/).

:bug: If you found a **bug**, please check the [**FAQ**](https://json.nlohmann.me/home/faq/) if it is a known issue or the result of a design decision. Please also have a look at the [**issue list**](https://github.com/nlohmann/json/issues) before you [**create a new issue**](https://github.com/nlohmann/json/issues/new/choose). Please provide as much information as possible to help us understand and reproduce your issue.

There is also a [**docset**](https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets/JSON_for_Modern_C%2B%2B) for the documentation browsers [Dash](https://kapeli.com/dash), [Velocity](https://velocity.silverlakesoftware.com), and [Zeal](https://zealdocs.org) that contains the full [documentation](https://json.nlohmann.me) as offline resource.

## Examples

Here are some examples to give you an idea how to use the class.

Beside the examples below, you may want to:

→ Check the [documentation](https://json.nlohmann.me/)\
→ Browse the [standalone example files](https://github.com/nlohmann/json/tree/develop/docs/examples)

Every API function (documented in the [API Documentation](https://json.nlohmann.me/api/basic_json/)) has a corresponding standalone example file. For example, the [`emplace()`](https://json.nlohmann.me/api/basic_json/emplace/) function has a matching [emplace.cpp](https://github.com/nlohmann/json/blob/develop/docs/examples/emplace.cpp) example file.

### Read JSON from a file

The `json` class provides an API for manipulating a JSON value. To create a `json` object by reading a JSON file:

```cpp
#include <fstream>
#include <nlohmann/json.hpp>
using json = nlohmann::json;

// ...

std::ifstream f("example.json");
json data = json::parse(f);
```

### Creating `json` objects from JSON literals

Assume you want to create hard-code this literal JSON value in a file, as a `json` object:

```json
{
  "pi": 3.141,
  "happy": true
}
```

There are various options:

```cpp
// Using (raw) string literals and json::parse
json ex1 = json::parse(R"(
  {
    "pi": 3.141,
    "happy": true
  }
)");

// Using user-defined (raw) string literals
using namespace nlohmann::literals;
json ex2 = R"(
  {
    "pi": 3.141,
    "happy": true
  }
)"_json;

// Using initializer lists
json ex3 = {
  {"happy", true},
  {"pi", 3.141},
};
```

### JSON as first-class data type

Here are some examples to give you an idea how to use the class.

Assume you want to create the JSON object

```json
{
  "pi": 3.141,
  "happy": true,
  "name": "Niels",
  "nothing": null,
  "answer": {
    "everything": 42
  },
  "list": [1, 0, 2],
  "object": {
    "currency": "USD",
    "value": 42.99
  }
}
```

With this library, you could write:

```cpp
// create an empty structure (null)
json j;

// add a number that is stored as double (note the implicit conversion of j to an object)
j["pi"] = 3.141;

// add a Boolean that is stored as bool
j["happy"] = true;

// add a string that is stored as std::string
j["name"] = "Niels";

// add another null object by passing nullptr
j["nothing"] = nullptr;

// add an object inside the object
j["answer"]["everything"] = 42;

// add an array that is stored as std::vector (using an initializer list)
j["list"] = { 1, 0, 2 };

// add another object (using an initializer list of pairs)
j["object"] = { {"currency", "USD"}, {"value", 42.99} };

// instead, you could also write (which looks very similar to the JSON above)
json j2 = {
  {"pi", 3.141},
  {"happy", true},
  {"name", "Niels"},
  {"nothing", nullptr},
  {"answer", {
    {"everything", 42}
  }},
  {"list", {1, 0, 2}},
  {"object", {
    {"currency", "USD"},
    {"value", 42.99}
  }}
};
```

Note that in all these cases, you never need to "tell" the compiler which JSON value type you want to use. If you want to be explicit or express some edge cases, the functions [`json::array()`](https://json.nlohmann.me/api/basic_json/array/) and [`json::object()`](https://json.nlohmann.me/api/basic_json/object/) will help:

```cpp
// a way to express the empty array []
json empty_array_explicit = json::array();

// ways to express the empty object {}
json empty_object_implicit = json({});
json empty_object_explicit = json::object();

// a way to express an _array_ of key/value pairs [["currency", "USD"], ["value", 42.99]]
json array_not_object = json::array({ {"currency", "USD"}, {"value", 42.99} });
```

### Serialization / Deserialization

#### To/from strings

You can create a JSON value (deserialization) by appending `_json` to a string literal:

```cpp
// create object from string literal
json j = "{ \"happy\": true, \"pi\": 3.141 }"_json;

// or even nicer with a raw string literal
auto j2 = R"(
  {
    "happy": true,
    "pi": 3.141
  }
)"_json;
```

Note that without appending the `_json` suffix, the passed string literal is not parsed, but just used as JSON string
value. That is, `json j = "{ \"happy\": true, \"pi\": 3.141 }"` would just store the string
`"{ "happy": true, "pi": 3.141 }"` rather than parsing the actual object.

The string literal should be brought into scope with `using namespace nlohmann::literals;`
(see [`json::parse()`](https://json.nlohmann.me/api/operator_literal_json/)).

The above example can also be expressed explicitly using [`json::parse()`](https://json.nlohmann.me/api/basic_json/parse/):

```cpp
// parse explicitly
auto j3 = json::parse(R"({"happy": true, "pi": 3.141})");
```

You can also get a string representation of a JSON value (serialize):

```cpp
// explicit conversion to string
std::string s = j.dump();    // {"happy":true,"pi":3.141}

// serialization with pretty printing
// pass in the amount of spaces to indent
std::cout << j.dump(4) << std::endl;
// {
//     "happy": true,
//     "pi": 3.141
// }
```

Note the difference between serialization and assignment:

```cpp
// store a string in a JSON value
json j_string = "this is a string";

// retrieve the string value
auto cpp_string = j_string.template get<std::string>();
// retrieve the string value (alternative when a variable already exists)
std::string cpp_string2;
j_string.get_to(cpp_string2);

// retrieve the serialized value (explicit JSON serialization)
std::string serialized_string = j_string.dump();

// output of original string
std::cout << cpp_string << " == " << cpp_string2 << " == " << j_string.template get<std::string>() << '\n';
// output of serialized value
std::cout << j_string << " == " << serialized_string << std::endl;
```

[`.dump()`](https://json.nlohmann.me/api/basic_json/dump/) returns the originally stored string value.

Note the library only supports UTF-8. When you store strings with different encodings in the library, calling [`dump()`](https://json.nlohmann.me/api/basic_json/dump/) may throw an exception unless `json::error_handler_t::replace` or `json::error_handler_t::ignore` are used as error handlers.

#### To/from streams (e.g. files, string streams)

You can also use streams to serialize and deserialize:

```cpp
// deserialize from standard input
json j;
std::cin >> j;

// serialize to standard output
std::cout << j;

// the setw manipulator was overloaded to set the indentation for pretty printing
std::cout << std::setw(4) << j << std::endl;
```

These operators work for any subclasses of `std::istream` or `std::ostream`. Here is the same example with files:

```cpp
// read a JSON file
std::ifstream i("file.json");
json j;
i >> j;

// write prettified JSON to another file
std::ofstream o("pretty.json");
o << std::setw(4) << j << std::endl;
```

Please note that setting the exception bit for `failbit` is inappropriate for this use case. It will result in program termination due to the `noexcept` specifier in use.

#### Read from iterator range

You can also parse JSON from an iterator range; that is, from any container accessible by iterators whose `value_type` is an integral type of 1, 2 or 4 bytes, which will be interpreted as UTF-8, UTF-16 and UTF-32 respectively. For instance, a `std::vector<std::uint8_t>`, or a `std::list<std::uint16_t>`:

```cpp
std::vector<std::uint8_t> v = {'t', 'r', 'u', 'e'};
json j = json::parse(v.begin(), v.end());
```

You may leave the iterators for the range [begin, end):

```cpp
std::vector<std::uint8_t> v = {'t', 'r', 'u', 'e'};
json j = json::parse(v);
```

#### Custom data source

Since the parse function accepts arbitrary iterator ranges, you can provide your own data sources by implementing the `LegacyInputIterator` concept.

```cpp
struct MyContainer {
  void advance();
  const char& get_current();
};

struct MyIterator {
    using difference_type = std::ptrdiff_t;
    using value_type = char;
    using pointer = const char*;
    using reference = const char&;
    using iterator_category = std::input_iterator_tag;

    MyIterator& operator++() {
        MyContainer.advance();
        return *this;
    }

    bool operator!=(const MyIterator& rhs) const {
        return rhs.target != target;
    }

    reference operator*() const {
        return target.get_current();
    }

    MyContainer* target = nullptr;
};

MyIterator begin(MyContainer& tgt) {
    return MyIterator{&tgt};
}

MyIterator end(const MyContainer&) {
    return {};
}

void foo() {
    MyContainer c;
    json j = json::parse(c);
}
```

#### SAX interface

The library uses a SAX-like interface with the following functions:

```cpp
// called when null is parsed
bool null();

// called when a boolean is parsed; value is passed
bool boolean(bool val);

// called when a signed or unsigned integer number is parsed; value is passed
bool number_integer(number_integer_t val);
bool number_unsigned(number_unsigned_t val);

// called when a floating-point number is parsed; value and original string is passed
bool number_float(number_float_t val, const string_t& s);

// called when a string is parsed; value is passed and can be safely moved away
bool string(string_t& val);
// called when a binary value is parsed; value is passed and can be safely moved away
bool binary(binary_t& val);

// called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known)
bool start_object(std::size_t elements);
bool end_object();
bool start_array(std::size_t elements);
bool end_array();
// called when an object key is parsed; value is passed and can be safely moved away
bool key(string_t& val);

// called when a parse error occurs; byte position, the last token, and an exception is passed
bool parse_error(std::size_t position, const std::string& last_token, const detail::exception& ex);
```

The return value of each function determines whether parsing should proceed.

To implement your own SAX handler, proceed as follows:

1. Implement the SAX interface in a class. You can use class `nlohmann::json_sax<json>` as base class, but you can also use any class where the functions described above are implemented and public.
2. Create an object of your SAX interface class, e.g. `my_sax`.
3. Call `bool json::sax_parse(input, &my_sax)`; where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface.

Note the `sax_parse` function only returns a `bool` indicating the result of the last executed SAX event. It does not return a  `json` value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your `parse_error` implementation. Internally, the SAX interface is used for the DOM parser (class `json_sax_dom_parser`) as well as the acceptor (`json_sax_acceptor`), see file [`json_sax.hpp`](https://github.com/nlohmann/json/blob/develop/include/nlohmann/detail/input/json_sax.hpp).

### STL-like access

We designed the JSON class to behave just like an STL container. In fact, it satisfies the [**ReversibleContainer**](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer) requirement.

```cpp
// create an array using push_back
json j;
j.push_back("foo");
j.push_back(1);
j.push_back(true);

// also use emplace_back
j.emplace_back(1.78);

// iterate the array
for (json::iterator it = j.begin(); it != j.end(); ++it) {
  std::cout << *it << '\n';
}

// range-based for
for (auto& element : j) {
  std::cout << element << '\n';
}

// getter/setter
const auto tmp = j[0].template get<std::string>();
j[1] = 42;
bool foo = j.at(2);

// comparison
j == R"(["foo", 1, true, 1.78])"_json;  // true

// other stuff
j.size();     // 4 entries
j.empty();    // false
j.type();     // json::value_t::array
j.clear();    // the array is empty again

// convenience type checkers
j.is_null();
j.is_boolean();
j.is_number();
j.is_object();
j.is_array();
j.is_string();

// create an object
json o;
o["foo"] = 23;
o["bar"] = false;
o["baz"] = 3.141;

// also use emplace
o.emplace("weather", "sunny");

// special iterator member functions for objects
for (json::iterator it = o.begin(); it != o.end(); ++it) {
  std::cout << it.key() << " : " << it.value() << "\n";
}

// the same code as range for
for (auto& el : o.items()) {
  std::cout << el.key() << " : " << el.value() << "\n";
}

// even easier with structured bindings (C++17)
for (auto& [key, value] : o.items()) {
  std::cout << key << " : " << value << "\n";
}

// find an entry
if (o.contains("foo")) {
  // there is an entry with key "foo"
}

// or via find and an iterator
if (o.find("foo") != o.end()) {
  // there is an entry with key "foo"
}

// or simpler using count()
int foo_present = o.count("foo"); // 1
int fob_present = o.count("fob"); // 0

// delete an entry
o.erase("foo");
```


### Conversion from STL containers

Any sequence container (`std::array`, `std::vector`, `std::deque`, `std::forward_list`, `std::list`) whose values can be used to construct JSON values (e.g., integers, floating point numbers, Booleans, string types, or again STL containers described in this section) can be used to create a JSON array. The same holds for similar associative containers (`std::set`, `std::multiset`, `std::unordered_set`, `std::unordered_multiset`), but in these cases the order of the elements of the array depends on how the elements are ordered in the respective STL container.

```cpp
std::vector<int> c_vector {1, 2, 3, 4};
json j_vec(c_vector);
// [1, 2, 3, 4]

std::deque<double> c_deque {1.2, 2.3, 3.4, 5.6};
json j_deque(c_deque);
// [1.2, 2.3, 3.4, 5.6]

std::list<bool> c_list {true, true, false, true};
json j_list(c_list);
// [true, true, false, true]

std::forward_list<int64_t> c_flist {12345678909876, 23456789098765, 34567890987654, 45678909876543};
json j_flist(c_flist);
// [12345678909876, 23456789098765, 34567890987654, 45678909876543]

std::array<unsigned long, 4> c_array {{1, 2, 3, 4}};
json j_array(c_array);
// [1, 2, 3, 4]

std::set<std::string> c_set {"one", "two", "three", "four", "one"};
json j_set(c_set); // only one entry for "one" is used
// ["four", "one", "three", "two"]

std::unordered_set<std::string> c_uset {"one", "two", "three", "four", "one"};
json j_uset(c_uset); // only one entry for "one" is used
// maybe ["two", "three", "four", "one"]

std::multiset<std::string> c_mset {"one", "two", "one", "four"};
json j_mset(c_mset); // both entries for "one" are used
// maybe ["one", "two", "one", "four"]

std::unordered_multiset<std::string> c_umset {"one", "two", "one", "four"};
json j_umset(c_umset); // both entries for "one" are used
// maybe ["one", "two", "one", "four"]
```

Likewise, any associative key-value containers (`std::map`, `std::multimap`, `std::unordered_map`, `std::unordered_multimap`) whose keys can construct an `std::string` and whose values can be used to construct JSON values (see examples above) can be used to create a JSON object. Note that in case of multimaps only one key is used in the JSON object and the value depends on the internal order of the STL container.

```cpp
std::map<std::string, int> c_map { {"one", 1}, {"two", 2}, {"three", 3} };
json j_map(c_map);
// {"one": 1, "three": 3, "two": 2 }

std::unordered_map<const char*, double> c_umap { {"one", 1.2}, {"two", 2.3}, {"three", 3.4} };
json j_umap(c_umap);
// {"one": 1.2, "two": 2.3, "three": 3.4}

std::multimap<std::string, bool> c_mmap { {"one", true}, {"two", true}, {"three", false}, {"three", true} };
json j_mmap(c_mmap); // only one entry for key "three" is used
// maybe {"one": true, "two": true, "three": true}

std::unordered_multimap<std::string, bool> c_ummap { {"one", true}, {"two", true}, {"three", false}, {"three", true} };
json j_ummap(c_ummap); // only one entry for key "three" is used
// maybe {"one": true, "two": true, "three": true}
```

### JSON Pointer and JSON Patch

The library supports **JSON Pointer** ([RFC 6901](https://tools.ietf.org/html/rfc6901)) as alternative means to address structured values. On top of this, **JSON Patch** ([RFC 6902](https://tools.ietf.org/html/rfc6902)) allows describing differences between two JSON values - effectively allowing patch and diff operations known from Unix.

```cpp
// a JSON value
json j_original = R"({
  "baz": ["one", "two", "three"],
  "foo": "bar"
})"_json;

// access members with a JSON pointer (RFC 6901)
j_original["/baz/1"_json_pointer];
// "two"

// a JSON patch (RFC 6902)
json j_patch = R"([
  { "op": "replace", "path": "/baz", "value": "boo" },
  { "op": "add", "path": "/hello", "value": ["world"] },
  { "op": "remove", "path": "/foo"}
])"_json;

// apply the patch
json j_result = j_original.patch(j_patch);
// {
//    "baz": "boo",
//    "hello": ["world"]
// }

// calculate a JSON patch from two JSON values
json::diff(j_result, j_original);
// [
//   { "op":" replace", "path": "/baz", "value": ["one", "two", "three"] },
//   { "op": "remove","path": "/hello" },
//   { "op": "add", "path": "/foo", "value": "bar" }
// ]
```

### JSON Merge Patch

The library supports **JSON Merge Patch** ([RFC 7386](https://tools.ietf.org/html/rfc7386)) as a patch format. Instead of using JSON Pointer (see above) to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified.

```cpp
// a JSON value
json j_document = R"({
  "a": "b",
  "c": {
    "d": "e",
    "f": "g"
  }
})"_json;

// a patch
json j_patch = R"({
  "a":"z",
  "c": {
    "f": null
  }
})"_json;

// apply the patch
j_document.merge_patch(j_patch);
// {
//  "a": "z",
//  "c": {
//    "d": "e"
//  }
// }
```

### Implicit conversions

Supported types can be implicitly converted to JSON values.

It is recommended to **NOT USE** implicit conversions **FROM** a JSON value.
You can find more details about this recommendation [here](https://www.github.com/nlohmann/json/issues/958).
You can switch off implicit conversions by defining `JSON_USE_IMPLICIT_CONVERSIONS` to `0` before including the `json.hpp` header. When using CMake, you can also achieve this by setting the option `JSON_ImplicitConversions` to `OFF`.

```cpp
// strings
std::string s1 = "Hello, world!";
json js = s1;
auto s2 = js.template get<std::string>();
// NOT RECOMMENDED
std::string s3 = js;
std::string s4;
s4 = js;

// Booleans
bool b1 = true;
json jb = b1;
auto b2 = jb.template get<bool>();
// NOT RECOMMENDED
bool b3 = jb;
bool b4;
b4 = jb;

// numbers
int i = 42;
json jn = i;
auto f = jn.template get<double>();
// NOT RECOMMENDED
double f2 = jb;
double f3;
f3 = jb;

// etc.
```

Note that `char` types are not automatically converted to JSON strings, but to integer numbers. A conversion to a string must be specified explicitly:

```cpp
char ch = 'A';                       // ASCII value 65
json j_default = ch;                 // stores integer number 65
json j_string = std::string(1, ch);  // stores string "A"
```

### Arbitrary types conversions

Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines:

```cpp
namespace ns {
    // a simple struct to model a person
    struct person {
        std::string name;
        std::string address;
        int age;
    };
}

ns::person p = {"Ned Flanders", "744 Evergreen Terrace", 60};

// convert to JSON: copy each value into the JSON object
json j;
j["name"] = p.name;
j["address"] = p.address;
j["age"] = p.age;

// ...

// convert from JSON: copy each value from the JSON object
ns::person p {
    j["name"].template get<std::string>(),
    j["address"].template get<std::string>(),
    j["age"].template get<int>()
};
```

It works, but that's quite a lot of boilerplate... Fortunately, there's a better way:

```cpp
// create a person
ns::person p {"Ned Flanders", "744 Evergreen Terrace", 60};

// conversion: person -> json
json j = p;

std::cout << j << std::endl;
// {"address":"744 Evergreen Terrace","age":60,"name":"Ned Flanders"}

// conversion: json -> person
auto p2 = j.template get<ns::person>();

// that's it
assert(p == p2);
```

#### Basic usage

To make this work with one of your types, you only need to provide two functions:

```cpp
using json = nlohmann::json;

namespace ns {
    void to_json(json& j, const person& p) {
        j = json{{"name", p.name}, {"address", p.address}, {"age", p.age}};
    }

    void from_json(const json& j, person& p) {
        j.at("name").get_to(p.name);
        j.at("address").get_to(p.address);
        j.at("age").get_to(p.age);
    }
} // namespace ns
```

That's all! When calling the `json` constructor with your type, your custom `to_json` method will be automatically called.
Likewise, when calling `template get<your_type>()` or `get_to(your_type&)`, the `from_json` method will be called.

Some important things:

* Those methods **MUST** be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace `ns`, where `person` is defined).
* Those methods **MUST** be available (e.g., proper headers must be included) everywhere you use these conversions. Look at [issue 1108](https://github.com/nlohmann/json/issues/1108) for errors that may occur otherwise.
* When using `template get<your_type>()`, `your_type` **MUST** be [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible). (There is a way to bypass this requirement described later.)
* In function `from_json`, use function [`at()`](https://json.nlohmann.me/api/basic_json/at/) to access the object values rather than `operator[]`. In case a key does not exist, `at` throws an exception that you can handle, whereas `operator[]` exhibits undefined behavior.
* You do not need to add serializers or deserializers for STL types like `std::vector`: the library already implements these.

#### Simplify your life with macros

If you just want to serialize/deserialize some structs, the `to_json`/`from_json` functions can be a lot of boilerplate.

There are two macros to make your life easier as long as you (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object:

- `NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(name, member1, member2, ...)` is to be defined inside the namespace of the class/struct to create code for.
- `NLOHMANN_DEFINE_TYPE_INTRUSIVE(name, member1, member2, ...)` is to be defined inside the class/struct to create code for. This macro can also access private members.

In both macros, the first parameter is the name of the class/struct, and all remaining parameters name the members.

##### Examples

The `to_json`/`from_json` functions for the `person` struct above can be created with:

```cpp
namespace ns {
    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(person, name, address, age)
}
```

Here is an example with private members, where `NLOHMANN_DEFINE_TYPE_INTRUSIVE` is needed:

```cpp
namespace ns {
    class address {
      private:
        std::string street;
        int housenumber;
        int postcode;

      public:
        NLOHMANN_DEFINE_TYPE_INTRUSIVE(address, street, housenumber, postcode)
    };
}
```

#### How do I convert third-party types?

This requires a bit more advanced technique. But first, let's see how this conversion mechanism works:

The library uses **JSON Serializers** to convert types to json.
The default serializer for `nlohmann::json` is `nlohmann::adl_serializer` (ADL means [Argument-Dependent Lookup](https://en.cppreference.com/w/cpp/language/adl)).

It is implemented like this (simplified):

```cpp
template <typename T>
struct adl_serializer {
    static void to_json(json& j, const T& value) {
        // calls the "to_json" method in T's namespace
    }

    static void from_json(const json& j, T& value) {
        // same thing, but with the "from_json" method
    }
};
```

This serializer works fine when you have control over the type's namespace. However, what about `boost::optional` or `std::filesystem::path` (C++17)? Hijacking the `boost` namespace is pretty bad, and it's illegal to add something other than template specializations to `std`...

To solve this, you need to add a specialization of `adl_serializer` to the `nlohmann` namespace, here's an example:

```cpp
// partial specialization (full specialization works too)
namespace nlohmann {
    template <typename T>
    struct adl_serializer<boost::optional<T>> {
        static void to_json(json& j, const boost::optional<T>& opt) {
            if (opt == boost::none) {
                j = nullptr;
            } else {
              j = *opt; // this will call adl_serializer<T>::to_json which will
                        // find the free function to_json in T's namespace!
            }
        }

        static void from_json(const json& j, boost::optional<T>& opt) {
            if (j.is_null()) {
                opt = boost::none;
            } else {
                opt = j.template get<T>(); // same as above, but with
                                           // adl_serializer<T>::from_json
            }
        }
    };
}
```

#### How can I use `get()` for non-default constructible/non-copyable types?

There is a way, if your type is [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible). You will need to specialize the `adl_serializer` as well, but with a special `from_json` overload:

```cpp
struct move_only_type {
    move_only_type() = delete;
    move_only_type(int ii): i(ii) {}
    move_only_type(const move_only_type&) = delete;
    move_only_type(move_only_type&&) = default;

    int i;
};

namespace nlohmann {
    template <>
    struct adl_serializer<move_only_type> {
        // note: the return type is no longer 'void', and the method only takes
        // one argument
        static move_only_type from_json(const json& j) {
            return {j.template get<int>()};
        }

        // Here's the catch! You must provide a to_json method! Otherwise, you
        // will not be able to convert move_only_type to json, since you fully
        // specialized adl_serializer on that type
        static void to_json(json& j, move_only_type t) {
            j = t.i;
        }
    };
}
```

#### Can I write my own serializer? (Advanced use)

Yes. You might want to take a look at [`unit-udt.cpp`](https://github.com/nlohmann/json/blob/develop/tests/src/unit-udt.cpp) in the test suite, to see a few examples.

If you write your own serializer, you'll need to do a few things:

- use a different `basic_json` alias than `nlohmann::json` (the last template parameter of `basic_json` is the `JSONSerializer`)
- use your `basic_json` alias (or a template parameter) in all your `to_json`/`from_json` methods
- use `nlohmann::to_json` and `nlohmann::from_json` when you need ADL

Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL.

```cpp
// You should use void as a second template argument
// if you don't need compile-time checks on T
template<typename T, typename SFINAE = typename std::enable_if<sizeof(T) <= 32>::type>
struct less_than_32_serializer {
    template <typename BasicJsonType>
    static void to_json(BasicJsonType& j, T value) {
        // we want to use ADL, and call the correct to_json overload
        using nlohmann::to_json; // this method is called by adl_serializer,
                                 // this is where the magic happens
        to_json(j, value);
    }

    template <typename BasicJsonType>
    static void from_json(const BasicJsonType& j, T& value) {
        // same thing here
        using nlohmann::from_json;
        from_json(j, value);
    }
};
```

Be **very** careful when reimplementing your serializer, you can stack overflow if you don't pay attention:

```cpp
template <typename T, void>
struct bad_serializer
{
    template <typename BasicJsonType>
    static void to_json(BasicJsonType& j, const T& value) {
      // this calls BasicJsonType::json_serializer<T>::to_json(j, value);
      // if BasicJsonType::json_serializer == bad_serializer ... oops!
      j = value;
    }

    template <typename BasicJsonType>
    static void to_json(const BasicJsonType& j, T& value) {
      // this calls BasicJsonType::json_serializer<T>::from_json(j, value);
      // if BasicJsonType::json_serializer == bad_serializer ... oops!
      value = j.template get<T>(); // oops!
    }
};
```

### Specializing enum conversion

By default, enum values are serialized to JSON as integers. In some cases this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later de-serialized JSON data may be undefined or a different enum value than was originally intended.

It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below:

```cpp
// example enum type declaration
enum TaskState {
    TS_STOPPED,
    TS_RUNNING,
    TS_COMPLETED,
    TS_INVALID=-1,
};

// map TaskState values to JSON as strings
NLOHMANN_JSON_SERIALIZE_ENUM( TaskState, {
    {TS_INVALID, nullptr},
    {TS_STOPPED, "stopped"},
    {TS_RUNNING, "running"},
    {TS_COMPLETED, "completed"},
})
```

The `NLOHMANN_JSON_SERIALIZE_ENUM()` macro declares a set of `to_json()` / `from_json()` functions for type `TaskState` while avoiding repetition and boilerplate serialization code.

**Usage:**

```cpp
// enum to JSON as string
json j = TS_STOPPED;
assert(j == "stopped");

// json string to enum
json j3 = "running";
assert(j3.template get<TaskState>() == TS_RUNNING);

// undefined json value to enum (where the first map entry above is the default)
json jPi = 3.14;
assert(jPi.template get<TaskState>() == TS_INVALID );
```

Just as in [Arbitrary Type Conversions](#arbitrary-types-conversions) above,
- `NLOHMANN_JSON_SERIALIZE_ENUM()` MUST be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it, and it will default to integer serialization.
- It MUST be available (e.g., proper headers must be included) everywhere you use the conversions.

Other Important points:
- When using `template get<ENUM_TYPE>()`, undefined JSON values will default to the first pair specified in your map. Select this default pair carefully.
- If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON.

### Binary formats (BSON, CBOR, MessagePack, UBJSON, and BJData)

Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports [BSON](https://bsonspec.org) (Binary JSON), [CBOR](https://cbor.io) (Concise Binary Object Representation), [MessagePack](https://msgpack.org), [UBJSON](https://ubjson.org) (Universal Binary JSON Specification) and [BJData](https://neurojson.org/bjdata) (Binary JData) to efficiently encode JSON values to byte vectors and to decode such vectors.

```cpp
// create a JSON value
json j = R"({"compact": true, "schema": 0})"_json;

// serialize to BSON
std::vector<std::uint8_t> v_bson = json::to_bson(j);

// 0x1B, 0x00, 0x00, 0x00, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0x00, 0x01, 0x10, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

// roundtrip
json j_from_bson = json::from_bson(v_bson);

// serialize to CBOR
std::vector<std::uint8_t> v_cbor = json::to_cbor(j);

// 0xA2, 0x67, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0xF5, 0x66, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00

// roundtrip
json j_from_cbor = json::from_cbor(v_cbor);

// serialize to MessagePack
std::vector<std::uint8_t> v_msgpack = json::to_msgpack(j);

// 0x82, 0xA7, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0xC3, 0xA6, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x00

// roundtrip
json j_from_msgpack = json::from_msgpack(v_msgpack);

// serialize to UBJSON
std::vector<std::uint8_t> v_ubjson = json::to_ubjson(j);

// 0x7B, 0x69, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x63, 0x74, 0x54, 0x69, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6D, 0x61, 0x69, 0x00, 0x7D

// roundtrip
json j_from_ubjson = json::from_ubjson(v_ubjson);
```

The library also supports binary types from BSON, CBOR (byte strings), and MessagePack (bin, ext, fixext). They are stored by default as `std::vector<std::uint8_t>` to be processed outside the library.

```cpp
// CBOR byte string with payload 0xCAFE
std::vector<std::uint8_t> v = {0x42, 0xCA, 0xFE};

// read value
json j = json::from_cbor(v);

// the JSON value has type binary
j.is_binary(); // true

// get reference to stored binary value
auto& binary = j.get_binary();

// the binary value has no subtype (CBOR has no binary subtypes)
binary.has_subtype(); // false

// access std::vector<std::uint8_t> member functions
binary.size(); // 2
binary[0]; // 0xCA
binary[1]; // 0xFE

// set subtype to 0x10
binary.set_subtype(0x10);

// serialize to MessagePack
auto cbor = json::to_msgpack(j); // 0xD5 (fixext2), 0x10, 0xCA, 0xFE
```


## Supported compilers

Though it's 2023 already, the support for C++11 is still a bit sparse. Currently, the following compilers are known to work:

- GCC 4.8 - 12.0 (and possibly later)
- Clang 3.4 - 15.0 (and possibly later)
- Apple Clang 9.1 - 13.1 (and possibly later)
- Intel C++ Compiler 17.0.2 (and possibly later)
- Nvidia CUDA Compiler 11.0.221 (and possibly later)
- Microsoft Visual C++ 2015 / Build Tools 14.0.25123.0 (and possibly later)
- Microsoft Visual C++ 2017 / Build Tools 15.5.180.51428 (and possibly later)
- Microsoft Visual C++ 2019 / Build Tools 16.3.1+1def00d3d (and possibly later)
- Microsoft Visual C++ 2022 / Build Tools 19.30.30709.0 (and possibly later)

I would be happy to learn about other compilers/versions.

Please note:

- GCC 4.8 has a bug [57824](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57824)): multiline raw strings cannot be the arguments to macros. Don't use multiline raw strings directly in macros with this compiler.
- Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your `Application.mk`. This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default.

    ```
    APP_STL := c++_shared
    NDK_TOOLCHAIN_VERSION := clang3.6
    APP_CPPFLAGS += -frtti -fexceptions
    ```

    The code compiles successfully with [Android NDK](https://developer.android.com/ndk/index.html?hl=ml), Revision 9 - 11 (and possibly later) and [CrystaX's Android NDK](https://www.crystax.net/en/android/ndk) version 10.

- For GCC running on MinGW or Android SDK, the error `'to_string' is not a member of 'std'` (or similarly, for `strtod` or `strtof`) may occur. Note this is not an issue with the code,  but rather with the compiler itself. On Android, see above to build with a newer environment.  For MinGW, please refer to [this site](https://tehsausage.com/mingw-to-string) and [this discussion](https://github.com/nlohmann/json/issues/136) for information on how to fix this bug. For Android NDK using `APP_STL := gnustl_static`, please refer to [this discussion](https://github.com/nlohmann/json/issues/219).

- Unsupported versions of GCC and Clang are rejected by `#error` directives. This can be switched off by defining `JSON_SKIP_UNSUPPORTED_COMPILER_CHECK`. Note that you can expect no support in this case.

The following compilers are currently used in continuous integration at [AppVeyor](https://ci.appveyor.com/project/nlohmann/json), [Cirrus CI](https://cirrus-ci.com/github/nlohmann/json), and [GitHub Actions](https://github.com/nlohmann/json/actions):

| Compiler                                                                                               | Operating System   | CI Provider    |
|--------------------------------------------------------------------------------------------------------|--------------------|----------------|
| Apple Clang 11.0.3 (clang-1103.0.32.62);  Xcode 11.7                                                   | macOS 11.7.1       | GitHub Actions |
| Apple Clang 12.0.0 (clang-1200.0.32.29);  Xcode 12.4                                                   | macOS 11.7.1       | GitHub Actions |
| Apple Clang 12.0.5 (clang-1205.0.22.11);  Xcode 12.5.1                                                 | macOS 11.7.1       | GitHub Actions |
| Apple Clang 13.0.0 (clang-1300.0.29.3);   Xcode 13.0                                                   | macOS 11.7.1       | GitHub Actions |
| Apple Clang 13.0.0 (clang-1300.0.29.3);   Xcode 13.1                                                   | macOS 12.6.1       | GitHub Actions |
| Apple Clang 13.0.0 (clang-1300.0.29.30);  Xcode 13.2.1                                                 | macOS 12.6.1       | GitHub Actions |
| Apple Clang 13.1.6 (clang-1316.0.21.2.3); Xcode 13.3.1                                                 | macOS 12.6.1       | GitHub Actions |
| Apple Clang 13.1.6 (clang-1316.0.21.2.5); Xcode 13.4.1                                                 | macOS 12.6.1       | GitHub Actions |
| Apple Clang 14.0.0 (clang-1400.0.29.102); Xcode 14.0                                                   | macOS 12.6.1       | GitHub Actions |
| Apple Clang 14.0.0 (clang-1400.0.29.102); Xcode 14.0.1                                                 | macOS 12.6.1       | GitHub Actions |
| Apple Clang 14.0.0 (clang-1400.0.29.202); Xcode 14.1                                                   | macOS 12.6.1       | GitHub Actions |
| Clang 3.5.2                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 3.6.2                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 3.7.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 3.8.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 3.9.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 4.0.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 5.0.2                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 6.0.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 7.0.1                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 8.0.0                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 9.0.0                                                                                            | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 10.0.0                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 10.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 11.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 11.0.0 with MSVC-like command-line                                                               | Windows-10.0.17763 | GitHub Actions |
| Clang 11.0.0                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 12.0.0                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 12.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 13.0.0                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 13.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 14.0.0                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 14.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 15.0.0 with GNU-like command-line                                                                | Windows-10.0.17763 | GitHub Actions |
| Clang 15.0.4                                                                                           | Ubuntu 20.04.3 LTS | GitHub Actions |
| Clang 16.0.0 (16.0.0-++20221031071727+500876226c60-1~exp1~20221031071831.439)                          | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 4.8.5 (Ubuntu 4.8.5-4ubuntu2)                                                                      | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 4.9.4                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 5.5.0                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 6.5.0                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 7.5.0                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 8.1.0 (i686-posix-dwarf-rev0, Built by MinGW-W64 project)                                          | Windows-10.0.17763 | GitHub Actions |
| GCC 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)                                          | Windows-10.0.17763 | GitHub Actions |
| GCC 8.5.0                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 9.5.0                                                                                              | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 10.4.0                                                                                             | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 11.1.0                                                                                             | Ubuntu (aarch64)   | Cirrus CI      |
| GCC 11.3.0                                                                                             | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 12.2.0                                                                                             | Ubuntu 20.04.3 LTS | GitHub Actions |
| GCC 13.0.0 20220605 (experimental)                                                                     | Ubuntu 20.04.3 LTS | GitHub Actions |
| Intel C++ Compiler 2021.5.0.20211109                                                                   | Ubuntu 20.04.3 LTS | GitHub Actions |
| NVCC 11.0.221                                                                                          | Ubuntu 20.04.3 LTS | GitHub Actions |
| Visual Studio 14 2015 MSVC 19.0.24241.7 (Build Engine version 14.0.25420.1)                            | Windows-6.3.9600   | AppVeyor       |
| Visual Studio 15 2017 MSVC 19.16.27035.0 (Build Engine version 15.9.21+g9802d43bc3 for .NET Framework) | Windows-10.0.14393 | AppVeyor       |
| Visual Studio 16 2019 MSVC 19.28.29912.0 (Build Engine version 16.9.0+57a23d249 for .NET Framework)    | Windows-10.0.17763 | GitHub Actions |
| Visual Studio 16 2019 MSVC 19.28.29912.0 (Build Engine version 16.9.0+57a23d249 for .NET Framework)    | Windows-10.0.17763 | AppVeyor       |
| Visual Studio 17 2022 MSVC 19.30.30709.0 (Build Engine version 17.0.31804.368 for .NET Framework)      | Windows-10.0.20348 | GitHub Actions |


## Integration

[`json.hpp`](https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp) is the single required file in `single_include/nlohmann` or [released here](https://github.com/nlohmann/json/releases). You need to add

```cpp
#include <nlohmann/json.hpp>

// for convenience
using json = nlohmann::json;
```

to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., `-std=c++11` for GCC and Clang).

You can further use file [`include/nlohmann/json_fwd.hpp`](https://github.com/nlohmann/json/blob/develop/include/nlohmann/json_fwd.hpp) for forward-declarations. The installation of json_fwd.hpp (as part of cmake's install step), can be achieved by setting `-DJSON_MultipleHeaders=ON`.

### CMake

You can also use the `nlohmann_json::nlohmann_json` interface target in CMake.  This target populates the appropriate usage requirements for `INTERFACE_INCLUDE_DIRECTORIES` to point to the appropriate include directories and `INTERFACE_COMPILE_FEATURES` for the necessary C++11 flags.

#### External

To use this library from a CMake project, you can locate it directly with `find_package()` and use the namespaced imported target from the generated package configuration:

```cmake
# CMakeLists.txt
find_package(nlohmann_json 3.2.0 REQUIRED)
...
add_library(foo ...)
...
target_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)
```

The package configuration file, `nlohmann_jsonConfig.cmake`, can be used either from an install tree or directly out of the build tree.

#### Embedded

To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call `add_subdirectory()` in your `CMakeLists.txt` file:

```cmake
# Typically you don't care so much for a third party library's tests to be
# run from your own project's code.
set(JSON_BuildTests OFF CACHE INTERNAL "")

# If you only include this third party in PRIVATE source files, you do not
# need to install it when your main project gets installed.
# set(JSON_Install OFF CACHE INTERNAL "")

# Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it
# unintended consequences that will break the build.  It's generally
# discouraged (although not necessarily well documented as such) to use
# include(...) for pulling in other CMake projects anyways.
add_subdirectory(nlohmann_json)
...
add_library(foo ...)
...
target_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)
```

##### Embedded (FetchContent)

Since CMake v3.11,
[FetchContent](https://cmake.org/cmake/help/v3.11/module/FetchContent.html) can
be used to automatically download a release as a dependency at configure time.

Example:
```cmake
include(FetchContent)

FetchContent_Declare(json URL https://github.com/nlohmann/json/releases/download/v3.11.2/json.tar.xz)
FetchContent_MakeAvailable(json)

target_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)
```

**Note**: It is recommended to use the URL approach described above which is supported as of version 3.10.0. See
<https://json.nlohmann.me/integration/cmake/#fetchcontent> for more information.

#### Supporting Both

To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following:

``` cmake
# Top level CMakeLists.txt
project(FOO)
...
option(FOO_USE_EXTERNAL_JSON "Use an external JSON library" OFF)
...
add_subdirectory(thirdparty)
...
add_library(foo ...)
...
# Note that the namespaced target will always be available regardless of the
# import method
target_link_libraries(foo PRIVATE nlohmann_json::nlohmann_json)
```
```cmake
# thirdparty/CMakeLists.txt
...
if(FOO_USE_EXTERNAL_JSON)
  find_package(nlohmann_json 3.2.0 REQUIRED)
else()
  set(JSON_BuildTests OFF CACHE INTERNAL "")
  add_subdirectory(nlohmann_json)
endif()
...
```

`thirdparty/nlohmann_json` is then a complete copy of this source tree.

### Package Managers

:beer: If you are using OS X and [Homebrew](https://brew.sh), just type `brew install nlohmann-json` and you're set. If you want the bleeding edge rather than the latest release, use `brew install nlohmann-json --HEAD`. See [nlohmann-json](https://formulae.brew.sh/formula/nlohmann-json) for more information.

If you are using the [Meson Build System](https://mesonbuild.com), add this source tree as a [meson subproject](https://mesonbuild.com/Subprojects.html#using-a-subproject). You may also use the `include.zip` published in this project's [Releases](https://github.com/nlohmann/json/releases) to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from [Meson WrapDB](https://wrapdb.mesonbuild.com/nlohmann_json), or simply use `meson wrap install nlohmann_json`. Please see the meson project for any issues regarding the packaging.

The provided `meson.build` can also be used as an alternative to CMake for installing `nlohmann_json` system-wide in which case a pkg-config file is installed. To use it, simply have your build system require the `nlohmann_json` pkg-config dependency. In Meson, it is preferred to use the [`dependency()`](https://mesonbuild.com/Reference-manual.html#dependency) object with a subproject fallback, rather than using the subproject directly.

If you are using [Bazel](https://bazel.build/) you can simply reference this repository using `http_archive` or `git_repository` and depend on `@nlohmann_json//:json`.

If you are using [Conan](https://www.conan.io/) to manage your dependencies, merely add [`nlohmann_json/x.y.z`](https://conan.io/center/nlohmann_json) to your `conanfile`'s requires, where `x.y.z` is the release version you want to use. Please file issues [here](https://github.com/conan-io/conan-center-index/issues) if you experience problems with the packages.

If you are using [Spack](https://www.spack.io/) to manage your dependencies, you can use the [`nlohmann-json` package](https://spack.readthedocs.io/en/latest/package_list.html#nlohmann-json). Please see the [spack project](https://github.com/spack/spack) for any issues regarding the packaging.

If you are using [hunter](https://github.com/cpp-pm/hunter) on your project for external dependencies, then you can use the [nlohmann_json package](https://hunter.readthedocs.io/en/latest/packages/pkg/nlohmann_json.html). Please see the hunter project for any issues regarding the packaging.

If you are using [Buckaroo](https://buckaroo.pm), you can install this library's module with `buckaroo add github.com/buckaroo-pm/nlohmann-json`. Please file issues [here](https://github.com/buckaroo-pm/nlohmann-json). There is a demo repo [here](https://github.com/njlr/buckaroo-nholmann-json-example).

If you are using [vcpkg](https://github.com/Microsoft/vcpkg/) on your project for external dependencies, then you can install the [nlohmann-json package](https://github.com/Microsoft/vcpkg/tree/master/ports/nlohmann-json) with `vcpkg install nlohmann-json` and follow the then displayed descriptions. Please see the vcpkg project for any issues regarding the packaging.

If you are using [cget](https://cget.readthedocs.io/en/latest/), you can install the latest development version with `cget install nlohmann/json`. A specific version can be installed with `cget install nlohmann/json@v3.1.0`. Also, the multiple header version can be installed by adding the `-DJSON_MultipleHeaders=ON` flag (i.e., `cget install nlohmann/json -DJSON_MultipleHeaders=ON`).

If you are using [CocoaPods](https://cocoapods.org), you can use the library by adding pod `"nlohmann_json", '~>3.1.2'` to your podfile (see [an example](https://bitbucket.org/benman/nlohmann_json-cocoapod/src/master/)). Please file issues [here](https://bitbucket.org/benman/nlohmann_json-cocoapod/issues?status=new&status=open).

If you are using [Swift Package Manager](https://swift.org/package-manager/), you can use the library by adding a package dependency to this repository. And target dependency as `.product(name: "nlohmann-json", package: "json")`.

If you are using [NuGet](https://www.nuget.org), you can use the package [nlohmann.json](https://www.nuget.org/packages/nlohmann.json/). Please check [this extensive description](https://github.com/nlohmann/json/issues/1132#issuecomment-452250255) on how to use the package. Please file issues [here](https://github.com/hnkb/nlohmann-json-nuget/issues).

If you are using [conda](https://conda.io/), you can use the package [nlohmann_json](https://github.com/conda-forge/nlohmann_json-feedstock) from [conda-forge](https://conda-forge.org) executing `conda install -c conda-forge nlohmann_json`. Please file issues [here](https://github.com/conda-forge/nlohmann_json-feedstock/issues).

If you are using [MSYS2](https://www.msys2.org/), you can use the [mingw-w64-nlohmann-json](https://packages.msys2.org/base/mingw-w64-nlohmann-json) package, just type `pacman -S mingw-w64-i686-nlohmann-json` or `pacman -S mingw-w64-x86_64-nlohmann-json` for installation. Please file issues [here](https://github.com/msys2/MINGW-packages/issues/new?title=%5Bnlohmann-json%5D) if you experience problems with the packages.

If you are using [MacPorts](https://ports.macports.org), execute `sudo port install nlohmann-json` to install the [nlohmann-json](https://ports.macports.org/port/nlohmann-json/) package.

If you are using [`build2`](https://build2.org), you can use the [`nlohmann-json`](https://cppget.org/nlohmann-json) package from the public repository https://cppget.org or directly from the [package's sources repository](https://github.com/build2-packaging/nlohmann-json). In your project's `manifest` file, just add `depends: nlohmann-json` (probably with some [version constraints](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#guide-add-remove-deps)). If you are not familiar with using dependencies in `build2`, [please read this introduction](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml).
Please file issues [here](https://github.com/build2-packaging/nlohmann-json) if you experience problems with the packages.

If you are using [`wsjcpp`](https://wsjcpp.org), you can use the command `wsjcpp install "https://github.com/nlohmann/json:develop"` to get the latest version. Note you can change the branch ":develop" to an existing tag or another branch.

If you are using [`CPM.cmake`](https://github.com/TheLartians/CPM.cmake), you can check this [`example`](https://github.com/TheLartians/CPM.cmake/tree/master/examples/json). After [adding CPM script](https://github.com/TheLartians/CPM.cmake#adding-cpm) to your project, implement the following snippet to your CMake:

```cmake
CPMAddPackage(
    NAME nlohmann_json
    GITHUB_REPOSITORY nlohmann/json
    VERSION 3.9.1)
```

### Pkg-config

If you are using bare Makefiles, you can use `pkg-config` to generate the include flags that point to where the library is installed:

```sh
pkg-config nlohmann_json --cflags
```

Users of the Meson build system will also be able to use a system-wide library, which will be found by `pkg-config`:

```meson
json = dependency('nlohmann_json', required: true)
```


## License

<img align="right" src="https://opensource.org/trademarks/opensource/OSI-Approved-License-100x137.png">

The class is licensed under the [MIT License](https://opensource.org/licenses/MIT):

Copyright &copy; 2013-2022 [Niels Lohmann](https://nlohmann.me)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

* * *

The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the [MIT License](https://opensource.org/licenses/MIT) (see above). Copyright &copy; 2008-2009 [Björn Hoehrmann](https://bjoern.hoehrmann.de/) <bjoern@hoehrmann.de>

The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the [MIT License](https://opensource.org/licenses/MIT) (see above). Copyright &copy; 2009 [Florian Loitsch](https://florian.loitsch.com/)

The class contains a copy of [Hedley](https://nemequ.github.io/hedley/) from Evan Nemerson which is licensed as [CC0-1.0](https://creativecommons.org/publicdomain/zero/1.0/).

The class contains parts of [Google Abseil](https://github.com/abseil/abseil-cpp) which is licensed under the [Apache 2.0 License](https://opensource.org/licenses/Apache-2.0).

## Contact

If you have questions regarding the library, I would like to invite you to [open an issue at GitHub](https://github.com/nlohmann/json/issues/new/choose). Please describe your request, problem, or question as detailed as possible, and also mention the version of the library you are using as well as the version of your compiler and operating system. Opening an issue at GitHub allows other users and contributors to this library to collaborate. For instance, I have little experience with MSVC, and most issues in this regard have been solved by a growing community. If you have a look at the [closed issues](https://github.com/nlohmann/json/issues?q=is%3Aissue+is%3Aclosed), you will see that we react quite timely in most cases.

Only if your request would contain confidential information, please [send me an email](mailto:mail@nlohmann.me). For encrypted messages, please use [this key](https://keybase.io/nlohmann/pgp_keys.asc).

## Security

[Commits by Niels Lohmann](https://github.com/nlohmann/json/commits) and [releases](https://github.com/nlohmann/json/releases) are signed with this [PGP Key](https://keybase.io/nlohmann/pgp_keys.asc?fingerprint=797167ae41c0a6d9232e48457f3cea63ae251b69).

## Thanks

I deeply appreciate the help of the following people.

<img src="https://raw.githubusercontent.com/nlohmann/json/develop/docs/avatars.png" align="right">

1. [Teemperor](https://github.com/Teemperor) implemented CMake support and lcov integration, realized escape and Unicode handling in the string parser, and fixed the JSON serialization.
2. [elliotgoodrich](https://github.com/elliotgoodrich) fixed an issue with double deletion in the iterator classes.
3. [kirkshoop](https://github.com/kirkshoop) made the iterators of the class composable to other libraries.
4. [wancw](https://github.com/wanwc) fixed a bug that hindered the class to compile with Clang.
5. Tomas Åblad found a bug in the iterator implementation.
6. [Joshua C. Randall](https://github.com/jrandall) fixed a bug in the floating-point serialization.
7. [Aaron Burghardt](https://github.com/aburgh) implemented code to parse streams incrementally. Furthermore, he greatly improved the parser class by allowing the definition of a filter function to discard undesired elements while parsing.
8. [Daniel Kopeček](https://github.com/dkopecek) fixed a bug in the compilation with GCC 5.0.
9. [Florian Weber](https://github.com/Florianjw) fixed a bug in and improved the performance of the comparison operators.
10. [Eric Cornelius](https://github.com/EricMCornelius) pointed out a bug in the handling with NaN and infinity values. He also improved the performance of the string escaping.
11. [易思龙](https://github.com/likebeta) implemented a conversion from anonymous enums.
12. [kepkin](https://github.com/kepkin) patiently pushed forward the support for Microsoft Visual studio.
13. [gregmarr](https://github.com/gregmarr) simplified the implementation of reverse iterators and helped with numerous hints and improvements. In particular, he pushed forward the implementation of user-defined types.
14. [Caio Luppi](https://github.com/caiovlp) fixed a bug in the Unicode handling.
15. [dariomt](https://github.com/dariomt) fixed some typos in the examples.
16. [Daniel Frey](https://github.com/d-frey) cleaned up some pointers and implemented exception-safe memory allocation.
17. [Colin Hirsch](https://github.com/ColinH) took care of a small namespace issue.
18. [Huu Nguyen](https://github.com/whoshuu) correct a variable name in the documentation.
19. [Silverweed](https://github.com/silverweed) overloaded `parse()` to accept an rvalue reference.
20. [dariomt](https://github.com/dariomt) fixed a subtlety in MSVC type support and implemented the `get_ref()` function to get a reference to stored values.
21. [ZahlGraf](https://github.com/ZahlGraf) added a workaround that allows compilation using Android NDK.
22. [whackashoe](https://github.com/whackashoe) replaced a function that was marked as unsafe by Visual Studio.
23. [406345](https://github.com/406345) fixed two small warnings.
24. [Glen Fernandes](https://github.com/glenfe) noted a potential portability problem in the `has_mapped_type` function.
25. [Corbin Hughes](https://github.com/nibroc) fixed some typos in the contribution guidelines.
26. [twelsby](https://github.com/twelsby) fixed the array subscript operator, an issue that failed the MSVC build, and floating-point parsing/dumping. He further added support for unsigned integer numbers and implemented better roundtrip support for parsed numbers.
27. [Volker Diels-Grabsch](https://github.com/vog) fixed a link in the README file.
28. [msm-](https://github.com/msm-) added support for American Fuzzy Lop.
29. [Annihil](https://github.com/Annihil) fixed an example in the README file.
30. [Themercee](https://github.com/Themercee) noted a wrong URL in the README file.
31. [Lv Zheng](https://github.com/lv-zheng) fixed a namespace issue with `int64_t` and `uint64_t`.
32. [abc100m](https://github.com/abc100m) analyzed the issues with GCC 4.8 and proposed a [partial solution](https://github.com/nlohmann/json/pull/212).
33. [zewt](https://github.com/zewt) added useful notes to the README file about Android.
34. [Róbert Márki](https://github.com/robertmrk) added a fix to use move iterators and improved the integration via CMake.
35. [Chris Kitching](https://github.com/ChrisKitching) cleaned up the CMake files.
36. [Tom Needham](https://github.com/06needhamt) fixed a subtle bug with MSVC 2015 which was also proposed by [Michael K.](https://github.com/Epidal).
37. [Mário Feroldi](https://github.com/thelostt) fixed a small typo.
38. [duncanwerner](https://github.com/duncanwerner) found a really embarrassing performance regression in the 2.0.0 release.
39. [Damien](https://github.com/dtoma) fixed one of the last conversion warnings.
40. [Thomas Braun](https://github.com/t-b) fixed a warning in a test case and adjusted MSVC calls in the CI.
41. [Théo DELRIEU](https://github.com/theodelrieu) patiently and constructively oversaw the long way toward [iterator-range parsing](https://github.com/nlohmann/json/issues/290). He also implemented the magic behind the serialization/deserialization of user-defined types and split the single header file into smaller chunks.
42. [Stefan](https://github.com/5tefan) fixed a minor issue in the documentation.
43. [Vasil Dimov](https://github.com/vasild) fixed the documentation regarding conversions from `std::multiset`.
44. [ChristophJud](https://github.com/ChristophJud) overworked the CMake files to ease project inclusion.
45. [Vladimir Petrigo](https://github.com/vpetrigo) made a SFINAE hack more readable and added Visual Studio 17 to the build matrix.
46. [Denis Andrejew](https://github.com/seeekr) fixed a grammar issue in the README file.
47. [Pierre-Antoine Lacaze](https://github.com/palacaze) found a subtle bug in the `dump()` function.
48. [TurpentineDistillery](https://github.com/TurpentineDistillery) pointed to [`std::locale::classic()`](https://en.cppreference.com/w/cpp/locale/locale/classic) to avoid too much locale joggling, found some nice performance improvements in the parser, improved the benchmarking code, and realized locale-independent number parsing and printing.
49. [cgzones](https://github.com/cgzones) had an idea how to fix the Coverity scan.
50. [Jared Grubb](https://github.com/jaredgrubb) silenced a nasty documentation warning.
51. [Yixin Zhang](https://github.com/qwename) fixed an integer overflow check.
52. [Bosswestfalen](https://github.com/Bosswestfalen) merged two iterator classes into a smaller one.
53. [Daniel599](https://github.com/Daniel599) helped to get Travis execute the tests with Clang's sanitizers.
54. [Jonathan Lee](https://github.com/vjon) fixed an example in the README file.
55. [gnzlbg](https://github.com/gnzlbg) supported the implementation of user-defined types.
56. [Alexej Harm](https://github.com/qis) helped to get the user-defined types working with Visual Studio.
57. [Jared Grubb](https://github.com/jaredgrubb) supported the implementation of user-defined types.
58. [EnricoBilla](https://github.com/EnricoBilla) noted a typo in an example.
59. [Martin Hořeňovský](https://github.com/horenmar) found a way for a 2x speedup for the compilation time of the test suite.
60. [ukhegg](https://github.com/ukhegg) found proposed an improvement for the examples section.
61. [rswanson-ihi](https://github.com/rswanson-ihi) noted a typo in the README.
62. [Mihai Stan](https://github.com/stanmihai4) fixed a bug in the comparison with `nullptr`s.
63. [Tushar Maheshwari](https://github.com/tusharpm) added [cotire](https://github.com/sakra/cotire) support to speed up the compilation.
64. [TedLyngmo](https://github.com/TedLyngmo) noted a typo in the README, removed unnecessary bit arithmetic, and fixed some `-Weffc++` warnings.
65. [Krzysztof Woś](https://github.com/krzysztofwos) made exceptions more visible.
66. [ftillier](https://github.com/ftillier) fixed a compiler warning.
67. [tinloaf](https://github.com/tinloaf) made sure all pushed warnings are properly popped.
68. [Fytch](https://github.com/Fytch) found a bug in the documentation.
69. [Jay Sistar](https://github.com/Type1J) implemented a Meson build description.
70. [Henry Lee](https://github.com/HenryRLee) fixed a warning in ICC and improved the iterator implementation.
71. [Vincent Thiery](https://github.com/vthiery) maintains a package for the Conan package manager.
72. [Steffen](https://github.com/koemeet) fixed a potential issue with MSVC and `std::min`.
73. [Mike Tzou](https://github.com/Chocobo1) fixed some typos.
74. [amrcode](https://github.com/amrcode) noted a misleading documentation about comparison of floats.
75. [Oleg Endo](https://github.com/olegendo) reduced the memory consumption by replacing `<iostream>` with `<iosfwd>`.
76. [dan-42](https://github.com/dan-42) cleaned up the CMake files to simplify including/reusing of the library.
77. [Nikita Ofitserov](https://github.com/himikof) allowed for moving values from initializer lists.
78. [Greg Hurrell](https://github.com/wincent) fixed a typo.
79. [Dmitry Kukovinets](https://github.com/DmitryKuk) fixed a typo.
80. [kbthomp1](https://github.com/kbthomp1) fixed an issue related to the Intel OSX compiler.
81. [Markus Werle](https://github.com/daixtrose) fixed a typo.
82. [WebProdPP](https://github.com/WebProdPP) fixed a subtle error in a precondition check.
83. [Alex](https://github.com/leha-bot) noted an error in a code sample.
84. [Tom de Geus](https://github.com/tdegeus) reported some warnings with ICC and helped to fix them.
85. [Perry Kundert](https://github.com/pjkundert) simplified reading from input streams.
86. [Sonu Lohani](https://github.com/sonulohani) fixed a small compilation error.
87. [Jamie Seward](https://github.com/jseward) fixed all MSVC warnings.
88. [Nate Vargas](https://github.com/eld00d) added a Doxygen tag file.
89. [pvleuven](https://github.com/pvleuven) helped to fix a warning in ICC.
90. [Pavel](https://github.com/crea7or) helped to fix some warnings in MSVC.
91. [Jamie Seward](https://github.com/jseward) avoided unnecessary string copies in `find()` and `count()`.
92. [Mitja](https://github.com/Itja) fixed some typos.
93. [Jorrit Wronski](https://github.com/jowr) updated the Hunter package links.
94. [Matthias Möller](https://github.com/TinyTinni) added a `.natvis` for the MSVC debug view.
95. [bogemic](https://github.com/bogemic) fixed some C++17 deprecation warnings.
96. [Eren Okka](https://github.com/erengy) fixed some MSVC warnings.
97. [abolz](https://github.com/abolz) integrated the Grisu2 algorithm for proper floating-point formatting, allowing more roundtrip checks to succeed.
98. [Vadim Evard](https://github.com/Pipeliner) fixed a Markdown issue in the README.
99. [zerodefect](https://github.com/zerodefect) fixed a compiler warning.
100. [Kert](https://github.com/kaidokert) allowed to template the string type in the serialization and added the possibility to override the exceptional behavior.
101. [mark-99](https://github.com/mark-99) helped fixing an ICC error.
102. [Patrik Huber](https://github.com/patrikhuber) fixed links in the README file.
103. [johnfb](https://github.com/johnfb) found a bug in the implementation of CBOR's indefinite length strings.
104. [Paul Fultz II](https://github.com/pfultz2) added a note on the cget package manager.
105. [Wilson Lin](https://github.com/wla80) made the integration section of the README more concise.
106. [RalfBielig](https://github.com/ralfbielig) detected and fixed a memory leak in the parser callback.
107. [agrianius](https://github.com/agrianius) allowed to dump JSON to an alternative string type.
108. [Kevin Tonon](https://github.com/ktonon) overworked the C++11 compiler checks in CMake.
109. [Axel Huebl](https://github.com/ax3l) simplified a CMake check and added support for the [Spack package manager](https://spack.io).
110. [Carlos O'Ryan](https://github.com/coryan) fixed a typo.
111. [James Upjohn](https://github.com/jammehcow) fixed a version number in the compilers section.
112. [Chuck Atkins](https://github.com/chuckatkins) adjusted the CMake files to the CMake packaging guidelines and provided documentation for the CMake integration.
113. [Jan Schöppach](https://github.com/dns13) fixed a typo.
114. [martin-mfg](https://github.com/martin-mfg) fixed a typo.
115. [Matthias Möller](https://github.com/TinyTinni) removed the dependency from `std::stringstream`.
116. [agrianius](https://github.com/agrianius) added code to use alternative string implementations.
117. [Daniel599](https://github.com/Daniel599) allowed to use more algorithms with the `items()` function.
118. [Julius Rakow](https://github.com/jrakow) fixed the Meson include directory and fixed the links to [cppreference.com](cppreference.com).
119. [Sonu Lohani](https://github.com/sonulohani) fixed the compilation with MSVC 2015 in debug mode.
120. [grembo](https://github.com/grembo) fixed the test suite and re-enabled several test cases.
121. [Hyeon Kim](https://github.com/simnalamburt) introduced the macro `JSON_INTERNAL_CATCH` to control the exception handling inside the library.
122. [thyu](https://github.com/thyu) fixed a compiler warning.
123. [David Guthrie](https://github.com/LEgregius) fixed a subtle compilation error with Clang 3.4.2.
124. [Dennis Fischer](https://github.com/dennisfischer) allowed to call `find_package` without installing the library.
125. [Hyeon Kim](https://github.com/simnalamburt) fixed an issue with a double macro definition.
126. [Ben Berman](https://github.com/rivertam) made some error messages more understandable.
127. [zakalibit](https://github.com/zakalibit) fixed a compilation problem with the Intel C++ compiler.
128. [mandreyel](https://github.com/mandreyel) fixed a compilation problem.
129. [Kostiantyn Ponomarenko](https://github.com/koponomarenko) added version and license information to the Meson build file.
130. [Henry Schreiner](https://github.com/henryiii) added support for GCC 4.8.
131. [knilch](https://github.com/knilch0r) made sure the test suite does not stall when run in the wrong directory.
132. [Antonio Borondo](https://github.com/antonioborondo) fixed an MSVC 2017 warning.
133. [Dan Gendreau](https://github.com/dgendreau) implemented the `NLOHMANN_JSON_SERIALIZE_ENUM` macro to quickly define an enum/JSON mapping.
134. [efp](https://github.com/efp) added line and column information to parse errors.
135. [julian-becker](https://github.com/julian-becker) added BSON support.
136. [Pratik Chowdhury](https://github.com/pratikpc) added support for structured bindings.
137. [David Avedissian](https://github.com/davedissian) added support for Clang 5.0.1 (PS4 version).
138. [Jonathan Dumaresq](https://github.com/dumarjo) implemented an input adapter to read from `FILE*`.
139. [kjpus](https://github.com/kjpus) fixed a link in the documentation.
140. [Manvendra Singh](https://github.com/manu-chroma) fixed a typo in the documentation.
141. [ziggurat29](https://github.com/ziggurat29) fixed an MSVC warning.
142. [Sylvain Corlay](https://github.com/SylvainCorlay) added code to avoid an issue with MSVC.
143. [mefyl](https://github.com/mefyl) fixed a bug when JSON was parsed from an input stream.
144. [Millian Poquet](https://github.com/mpoquet) allowed to install the library via Meson.
145. [Michael Behrns-Miller](https://github.com/moodboom) found an issue with a missing namespace.
146. [Nasztanovics Ferenc](https://github.com/naszta) fixed a compilation issue with libc 2.12.
147. [Andreas Schwab](https://github.com/andreas-schwab) fixed the endian conversion.
148. [Mark-Dunning](https://github.com/Mark-Dunning) fixed a warning in MSVC.
149. [Gareth Sylvester-Bradley](https://github.com/garethsb-sony) added `operator/` for JSON Pointers.
150. [John-Mark](https://github.com/johnmarkwayve) noted a missing header.
151. [Vitaly Zaitsev](https://github.com/xvitaly) fixed compilation with GCC 9.0.
152. [Laurent Stacul](https://github.com/stac47) fixed compilation with GCC 9.0.
153. [Ivor Wanders](https://github.com/iwanders) helped to reduce the CMake requirement to version 3.1.
154. [njlr](https://github.com/njlr) updated the Buckaroo instructions.
155. [Lion](https://github.com/lieff) fixed a compilation issue with GCC 7 on CentOS.
156. [Isaac Nickaein](https://github.com/nickaein) improved the integer serialization performance and  implemented the `contains()` function.
157. [past-due](https://github.com/past-due) suppressed an unfixable warning.
158. [Elvis Oric](https://github.com/elvisoric) improved Meson support.
159. [Matěj Plch](https://github.com/Afforix) fixed an example in the README.
160. [Mark Beckwith](https://github.com/wythe) fixed a typo.
161. [scinart](https://github.com/scinart) fixed bug in the serializer.
162. [Patrick Boettcher](https://github.com/pboettch) implemented `push_back()` and `pop_back()` for JSON Pointers.
163. [Bruno Oliveira](https://github.com/nicoddemus) added support for Conda.
164. [Michele Caini](https://github.com/skypjack) fixed links in the README.
165. [Hani](https://github.com/hnkb) documented how to install the library with NuGet.
166. [Mark Beckwith](https://github.com/wythe) fixed a typo.
167. [yann-morin-1998](https://github.com/yann-morin-1998) helped to reduce the CMake requirement to version 3.1.
168. [Konstantin Podsvirov](https://github.com/podsvirov) maintains a package for the MSYS2 software distro.
169. [remyabel](https://github.com/remyabel) added GNUInstallDirs to the CMake files.
170. [Taylor Howard](https://github.com/taylorhoward92) fixed a unit test.
171. [Gabe Ron](https://github.com/Macr0Nerd) implemented the `to_string` method.
172. [Watal M. Iwasaki](https://github.com/heavywatal) fixed a Clang warning.
173. [Viktor Kirilov](https://github.com/onqtam) switched the unit tests from [Catch](https://github.com/philsquared/Catch) to [doctest](https://github.com/onqtam/doctest)
174. [Juncheng E](https://github.com/ejcjason) fixed a typo.
175. [tete17](https://github.com/tete17) fixed a bug in the `contains` function.
176. [Xav83](https://github.com/Xav83) fixed some cppcheck warnings.
177. [0xflotus](https://github.com/0xflotus) fixed some typos.
178. [Christian Deneke](https://github.com/chris0x44) added a const version of `json_pointer::back`.
179. [Julien Hamaide](https://github.com/crazyjul) made the `items()` function work with custom string types.
180. [Evan Nemerson](https://github.com/nemequ) updated fixed a bug in Hedley and updated this library accordingly.
181. [Florian Pigorsch](https://github.com/flopp) fixed a lot of typos.
182. [Camille Bégué](https://github.com/cbegue) fixed an issue in the conversion from  `std::pair` and `std::tuple` to `json`.
183. [Anthony VH](https://github.com/AnthonyVH) fixed a compile error in an enum deserialization.
184. [Yuriy Vountesmery](https://github.com/ua-code-dragon) noted a subtle bug in a preprocessor check.
185. [Chen](https://github.com/dota17) fixed numerous issues in the library.
186. [Antony Kellermann](https://github.com/aokellermann) added a CI step for GCC 10.1.
187. [Alex](https://github.com/gistrec) fixed an MSVC warning.
188. [Rainer](https://github.com/rvjr) proposed an improvement in the floating-point serialization in CBOR.
189. [Francois Chabot](https://github.com/FrancoisChabot) made performance improvements in the input adapters.
190. [Arthur Sonzogni](https://github.com/ArthurSonzogni) documented how the library can be included via `FetchContent`.
191. [Rimas Misevičius](https://github.com/rmisev) fixed an error message.
192. [Alexander Myasnikov](https://github.com/alexandermyasnikov) fixed some examples and a link in the README.
193. [Hubert Chathi](https://github.com/uhoreg) made CMake's version config file architecture-independent.
194. [OmnipotentEntity](https://github.com/OmnipotentEntity) implemented the binary values for CBOR, MessagePack, BSON, and UBJSON.
195. [ArtemSarmini](https://github.com/ArtemSarmini) fixed a compilation issue with GCC 10 and fixed a leak.
196. [Evgenii Sopov](https://github.com/sea-kg) integrated the library to the wsjcpp package manager.
197. [Sergey Linev](https://github.com/linev) fixed a compiler warning.
198. [Miguel Magalhães](https://github.com/magamig) fixed the year in the copyright.
199. [Gareth Sylvester-Bradley](https://github.com/garethsb-sony) fixed a compilation issue with MSVC.
200. [Alexander “weej” Jones](https://github.com/alex-weej) fixed an example in the README.
201. [Antoine Cœur](https://github.com/Coeur) fixed some typos in the documentation.
202. [jothepro](https://github.com/jothepro) updated links to the Hunter package.
203. [Dave Lee](https://github.com/kastiglione) fixed link in the README.
204. [Joël Lamotte](https://github.com/Klaim) added instruction for using Build2's package manager.
205. [Paul Jurczak](https://github.com/pauljurczak) fixed an example in the README.
206. [Sonu Lohani](https://github.com/sonulohani) fixed a warning.
207. [Carlos Gomes Martinho](https://github.com/gocarlos) updated the Conan package source.
208. [Konstantin Podsvirov](https://github.com/podsvirov) fixed the MSYS2 package documentation.
209. [Tridacnid](https://github.com/Tridacnid) improved the CMake tests.
210. [Michael](https://github.com/MBalszun) fixed MSVC warnings.
211. [Quentin Barbarat](https://github.com/quentin-dev) fixed an example in the documentation.
212. [XyFreak](https://github.com/XyFreak) fixed a compiler warning.
213. [TotalCaesar659](https://github.com/TotalCaesar659) fixed links in the README.
214. [Tanuj Garg](https://github.com/tanuj208) improved the fuzzer coverage for UBSAN input.
215. [AODQ](https://github.com/AODQ) fixed a compiler warning.
216. [jwittbrodt](https://github.com/jwittbrodt) made `NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE` inline.
217. [pfeatherstone](https://github.com/pfeatherstone) improved the upper bound of arguments of the `NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE`/`NLOHMANN_DEFINE_TYPE_INTRUSIVE` macros.
218. [Jan Procházka](https://github.com/jprochazk) fixed a bug in the CBOR parser for binary and string values.
219. [T0b1-iOS](https://github.com/T0b1-iOS) fixed a bug in the new hash implementation.
220. [Matthew Bauer](https://github.com/matthewbauer) adjusted the CBOR writer to create tags for binary subtypes.
221. [gatopeich](https://github.com/gatopeich) implemented an ordered map container for `nlohmann::ordered_json`.
222. [Érico Nogueira Rolim](https://github.com/ericonr) added support for pkg-config.
223. [KonanM](https://github.com/KonanM) proposed an implementation for the `NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE`/`NLOHMANN_DEFINE_TYPE_INTRUSIVE` macros.
224. [Guillaume Racicot](https://github.com/gracicot) implemented `string_view` support and allowed C++20 support.
225. [Alex Reinking](https://github.com/alexreinking) improved CMake support for `FetchContent`.
226. [Hannes Domani](https://github.com/ssbssa) provided a GDB pretty printer.
227. Lars Wirzenius reviewed the README file.
228. [Jun Jie](https://github.com/ongjunjie) fixed a compiler path in the CMake scripts.
229. [Ronak Buch](https://github.com/rbuch) fixed typos in the documentation.
230. [Alexander Karzhenkov](https://github.com/karzhenkov) fixed a move constructor and the Travis builds.
231. [Leonardo Lima](https://github.com/leozz37) added CPM.Cmake support.
232. [Joseph Blackman](https://github.com/jbzdarkid) fixed a warning.
233. [Yaroslav](https://github.com/YarikTH) updated doctest and implemented unit tests.
234. [Martin Stump](https://github.com/globberwops) fixed a bug in the CMake files.
235. [Jaakko Moisio](https://github.com/jasujm) fixed a bug in the input adapters.
236. [bl-ue](https://github.com/bl-ue) fixed some Markdown issues in the README file.
237. [William A. Wieselquist](https://github.com/wawiesel) fixed an example from the README.
238. [abbaswasim](https://github.com/abbaswasim) fixed an example from the README.
239. [Remy Jette](https://github.com/remyjette) fixed a warning.
240. [Fraser](https://github.com/frasermarlow) fixed the documentation.
241. [Ben Beasley](https://github.com/musicinmybrain) updated doctest.
242. [Doron Behar](https://github.com/doronbehar) fixed pkg-config.pc.
243. [raduteo](https://github.com/raduteo) fixed a warning.
244. [David Pfahler](https://github.com/theShmoo) added the possibility to compile the library without I/O support.
245. [Morten Fyhn Amundsen](https://github.com/mortenfyhn) fixed a typo.
246. [jpl-mac](https://github.com/jpl-mac) allowed to treat the library as a system header in CMake.
247. [Jason Dsouza](https://github.com/jasmcaus) fixed the indentation of the CMake file.
248. [offa](https://github.com/offa) added a link to Conan Center to the documentation.
249. [TotalCaesar659](https://github.com/TotalCaesar659) updated the links in the documentation to use HTTPS.
250. [Rafail Giavrimis](https://github.com/grafail) fixed the Google Benchmark default branch.
251. [Louis Dionne](https://github.com/ldionne) fixed a conversion operator.
252. [justanotheranonymoususer](https://github.com/justanotheranonymoususer) made the examples in the README more consistent.
253. [Finkman](https://github.com/Finkman) suppressed some `-Wfloat-equal` warnings.
254. [Ferry Huberts](https://github.com/fhuberts) fixed `-Wswitch-enum` warnings.
255. [Arseniy Terekhin](https://github.com/senyai) made the GDB pretty-printer robust against unset variable names.
256. [Amir Masoud Abdol](https://github.com/amirmasoudabdol) updated the Homebrew command as nlohmann/json is now in homebrew-core.
257. [Hallot](https://github.com/Hallot) fixed some `-Wextra-semi-stmt warnings`.
258. [Giovanni Cerretani](https://github.com/gcerretani) fixed `-Wunused` warnings on `JSON_DIAGNOSTICS`.
259. [Bogdan Popescu](https://github.com/Kapeli) hosts the [docset](https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets/JSON_for_Modern_C%2B%2B) for offline documentation viewers.
260. [Carl Smedstad](https://github.com/carlsmedstad) fixed an assertion error when using `JSON_DIAGNOSTICS`.
261. [miikka75](https://github.com/miikka75) provided an important fix to compile C++17 code with Clang 9.
262. [Maarten Becker](https://github.com/kernie) fixed a warning for shadowed variables.
263. [Cristi Vîjdea](https://github.com/axnsan12) fixed typos in the `operator[]` documentation.
264. [Alex Beregszaszi](https://github.com/axic) fixed spelling mistakes in comments.
265. [Dirk Stolle](https://github.com/striezel) fixed typos in documentation.
266. [Daniel Albuschat](https://github.com/daniel-kun) corrected the parameter name in the `parse` documentation.
267. [Prince Mendiratta](https://github.com/Prince-Mendiratta) fixed a link to the FAQ.
268. [Florian Albrechtskirchinger](https://github.com/falbrechtskirchinger) implemented `std::string_view` support for object keys and made dozens of other improvements.
269. [Qianqian Fang](https://github.com/fangq) implemented the Binary JData (BJData) format.
270. [pketelsen](https://github.com/pketelsen) added macros `NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT` and `NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT`.
271. [DarkZeros](https://github.com/DarkZeros) adjusted to code to not clash with Arduino defines.
272. [flagarde](https://github.com/flagarde) fixed the output of `meta()` for MSVC.
273. [Giovanni Cerretani](https://github.com/gcerretani) fixed a check for `std::filesystem`.
274. [Dimitris Apostolou](https://github.com/rex4539) fixed a typo.
275. [Ferry Huberts](https://github.com/fhuberts) fixed a typo.
276. [Michael Nosthoff](https://github.com/heinemml) fixed a typo.
277. [JungHoon Lee](https://github.com/jhnlee) fixed a typo.
278. [Faruk D.](https://github.com/fdiblen) fixed the CITATION.CFF file.
279. [Andrea Cocito](https://github.com/puffetto) added a clarification on macro usage to the documentation.
280. [Krzysiek Karbowiak](https://github.com/kkarbowiak) refactored the tests to use `CHECK_THROWS_WITH_AS`.
281. [Chaoqi Zhang](https://github.com/prncoprs) fixed a typo.
282. [ivanovmp](https://github.com/ivanovmp) fixed a whitespace error.
283. [KsaNL](https://github.com/KsaNL) fixed a build error when including `<windows.h>`.
284. [Andrea Pappacoda](https://github.com/Tachi107) moved `.pc` and `.cmake` files to `share` directory.
285. [Wolf Vollprecht](https://github.com/wolfv) added the `patch_inplace` function.
286. [Jake Zimmerman](https://github.com/jez) highlighted common usage patterns in the README file.
287. [NN](https://github.com/NN---) added the Visual Studio output directory to `.gitignore`.
288. [Romain Reignier](https://github.com/romainreignier) improved the performance the vector output adapter.
289. [Mike](https://github.com/Mike-Leo-Smith) fixed the `std::iterator_traits`.
290. [Richard Hozák](https://github.com/zxey) added macro `JSON_NO_ENUM` to disable default enum conversions.
291. [vakokako](https://github.com/vakokako) fixed tests when compiling with C++20.
292. [Alexander “weej” Jones](https://github.com/alexweej) fixed an example in the README.
293. [Eli Schwartz](https://github.com/eli-schwartz) added more files to the `include.zip` archive.
294. [Kevin Lu](https://github.com/kevinlul) fixed a compilation issue when typedefs with certain names were present.
295. [Trevor Hickey](https://github.com/luxe) improved the description of an example.
296. [Jef LeCompte](https://github.com/jef) updated the year in the README file.
297. [Alexandre Hamez](https://github.com/ahamez) fixed a warning.
298. [Maninderpal Badhan](https://github.com/mbadhan) fixed a typo.
299. [kevin--](https://github.com/kevin--) added a note to an example in the README file.
300. [I](https://github.com/wx257osn2) fixed a typo.
301. [Gregorio Litenstein](https://github.com/Lord-Kamina) fixed the Clang detection.
302. [Andreas Smas](https://github.com/andoma) added a Doozer badge.
303. [WanCW](https://github.com/wancw) fixed the string conversion with Clang.
304. [zhaohuaxishi](https://github.com/zhaohuaxishi) fixed a Doxygen error.
305. [emvivre](https://github.com/emvivre) removed an invalid parameter from CMake.
306. [Tobias Hermann](https://github.com/Dobiasd) fixed a link in the README file.
307. [Michael](https://github.com/traits) fixed a warning.
308. [Ryan Mulder](https://github.com/ryanjmulder) added `ensure_ascii` to the `dump` function.
309. [Muri Nicanor](https://github.com/murinicanor) fixed the `sed` discovery in the Makefile.
310. [David Avedissian](https://github.com/dgavedissian) implemented SFINAE-friendly `iterator_traits`.
311. [AQNOUCH Mohammed](https://github.com/aqnouch) fixed a typo in the README.
312. [Gareth Sylvester-Bradley](https://github.com/garethsb) added `operator/=` and `operator/` to construct JSON pointers.
313. [Michael Macnair](https://github.com/mykter) added support for afl-fuzz testing.
314. [Berkus Decker](https://github.com/berkus) fixed a typo in the README.
315. [Illia Polishchuk](https://github.com/effolkronium) improved the CMake testing.
316. [Ikko Ashimine](https://github.com/eltociear) fixed a typo.

Thanks a lot for helping out! Please [let me know](mailto:mail@nlohmann.me) if I forgot someone.


## Used third-party tools

The library itself consists of a single header file licensed under the MIT license. However, it is built, tested, documented, and whatnot using a lot of third-party tools and services. Thanks a lot!

- [**amalgamate.py - Amalgamate C source and header files**](https://github.com/edlund/amalgamate) to create a single header file
- [**American fuzzy lop**](https://lcamtuf.coredump.cx/afl/) for fuzz testing
- [**AppVeyor**](https://www.appveyor.com) for [continuous integration](https://ci.appveyor.com/project/nlohmann/json) on Windows
- [**Artistic Style**](http://astyle.sourceforge.net) for automatic source code indentation
- [**Clang**](https://clang.llvm.org) for compilation with code sanitizers
- [**CMake**](https://cmake.org) for build automation
- [**Codacy**](https://www.codacy.com) for further [code analysis](https://www.codacy.com/app/nlohmann/json)
- [**Coveralls**](https://coveralls.io) to measure [code coverage](https://coveralls.io/github/nlohmann/json)
- [**Coverity Scan**](https://scan.coverity.com) for [static analysis](https://scan.coverity.com/projects/nlohmann-json)
- [**cppcheck**](http://cppcheck.sourceforge.net) for static analysis
- [**doctest**](https://github.com/onqtam/doctest) for the unit tests
- [**git-update-ghpages**](https://github.com/rstacruz/git-update-ghpages) to upload the documentation to gh-pages
- [**GitHub Changelog Generator**](https://github.com/skywinder/github-changelog-generator) to generate the [ChangeLog](https://github.com/nlohmann/json/blob/develop/ChangeLog.md)
- [**Google Benchmark**](https://github.com/google/benchmark) to implement the benchmarks
- [**Hedley**](https://nemequ.github.io/hedley/) to avoid re-inventing several compiler-agnostic feature macros
- [**lcov**](http://ltp.sourceforge.net/coverage/lcov.php) to process coverage information and create an HTML view
- [**libFuzzer**](https://llvm.org/docs/LibFuzzer.html) to implement fuzz testing for OSS-Fuzz
- [**Material for MkDocs**](https://squidfunk.github.io/mkdocs-material/) for the style of the documentation site
- [**MkDocs**](https://www.mkdocs.org) for the documentation site
- [**OSS-Fuzz**](https://github.com/google/oss-fuzz) for continuous fuzz testing of the library ([project repository](https://github.com/google/oss-fuzz/tree/master/projects/json))
- [**Probot**](https://probot.github.io) for automating maintainer tasks such as closing stale issues, requesting missing information, or detecting toxic comments.
- [**Valgrind**](https://valgrind.org) to check for correct memory management


## Projects using JSON for Modern C++

The library is currently used in Apple macOS Sierra-Monterey and iOS 10-15. I am not sure what they are using the library for, but I am happy that it runs on so many devices.


## Notes

### Character encoding

The library supports **Unicode input** as follows:

- Only **UTF-8** encoded input is supported which is the default encoding for JSON according to [RFC 8259](https://tools.ietf.org/html/rfc8259.html#section-8.1).
- `std::u16string` and `std::u32string` can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers.
- Other encodings such as Latin-1 or ISO 8859-1 are **not** supported and will yield parse or serialization errors.
- [Unicode noncharacters](https://www.unicode.org/faq/private_use.html#nonchar1) will not be replaced by the library.
- Invalid surrogates (e.g., incomplete pairs such as `\uDEAD`) will yield parse errors.
- The strings stored in the library are UTF-8 encoded. When using the default string type (`std::string`), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs.
- When you store strings with different encodings in the library, calling [`dump()`](https://json.nlohmann.me/api/basic_json/dump/) may throw an exception unless `json::error_handler_t::replace` or `json::error_handler_t::ignore` are used as error handlers.
- To store wide strings (e.g., `std::wstring`), you need to convert them to a UTF-8 encoded `std::string` before, see [an example](https://json.nlohmann.me/home/faq/#wide-string-handling).

### Comments in JSON

This library does not support comments by default. It does so for three reasons:

1. Comments are not part of the [JSON specification](https://tools.ietf.org/html/rfc8259). You may argue that `//` or `/* */` are allowed in JavaScript, but JSON is not JavaScript.
2. This was not an oversight: Douglas Crockford [wrote on this](https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr) in May 2012:

	> I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.  I know that the lack of comments makes some people sad, but it shouldn't.

	> Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser.

3. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check [The Harmful Consequences of the Robustness Principle](https://tools.ietf.org/html/draft-iab-protocol-maintenance-01) on this.

However, you can pass set parameter `ignore_comments` to true in the `parse` function to ignore `//` or `/* */` comments. Comments will then be treated as whitespace.

### Order of object keys

By default, the library does not preserve the **insertion order of object elements**. This is standards-compliant, as the [JSON standard](https://tools.ietf.org/html/rfc8259.html) defines objects as "an unordered collection of zero or more name/value pairs".

If you do want to preserve the insertion order, you can try the type [`nlohmann::ordered_json`](https://github.com/nlohmann/json/issues/2179). Alternatively, you can use a more sophisticated ordered map like [`tsl::ordered_map`](https://github.com/Tessil/ordered-map) ([integration](https://github.com/nlohmann/json/issues/546#issuecomment-304447518)) or [`nlohmann::fifo_map`](https://github.com/nlohmann/fifo_map) ([integration](https://github.com/nlohmann/json/issues/485#issuecomment-333652309)).

### Memory Release

We checked with Valgrind and the Address Sanitizer (ASAN) that there are no memory leaks.

If you find that a parsing program with this library does not release memory, please consider the following case, and it may be unrelated to this library.

**Your program is compiled with glibc.** There is a tunable threshold that glibc uses to decide whether to actually return memory to the system or whether to cache it for later reuse. If in your program you make lots of small allocations and those small allocations are not a contiguous block and are presumably below the threshold, then they will not get returned to the OS.
Here is a related issue [#1924](https://github.com/nlohmann/json/issues/1924).

### Further notes

- The code contains numerous debug **assertions** which can be switched off by defining the preprocessor macro `NDEBUG`, see the [documentation of `assert`](https://en.cppreference.com/w/cpp/error/assert). In particular, note [`operator[]`](https://json.nlohmann.me/api/basic_json/operator%5B%5D/) implements **unchecked access** for const objects: If the given key is not present, the behavior is undefined (think of a dereferenced null pointer) and yields an [assertion failure](https://github.com/nlohmann/json/issues/289) if assertions are switched on. If you are not sure whether an element in an object exists, use checked access with the [`at()` function](https://json.nlohmann.me/api/basic_json/at/). Furthermore, you can define `JSON_ASSERT(x)` to replace calls to `assert(x)`.
- As the exact number type is not defined in the [JSON specification](https://tools.ietf.org/html/rfc8259.html), this library tries to choose the best fitting C++ number type automatically. As a result, the type `double` may be used to store numbers which may yield [**floating-point exceptions**](https://github.com/nlohmann/json/issues/181) in certain rare situations if floating-point exceptions have been unmasked in the calling code. These exceptions are not caused by the library and need to be fixed in the calling code, such as by re-masking the exceptions prior to calling library functions.
- The code can be compiled without C++ **runtime type identification** features; that is, you can use the `-fno-rtti` compiler flag.
- **Exceptions** are used widely within the library. They can, however, be switched off with either using the compiler flag `-fno-exceptions` or by defining the symbol `JSON_NOEXCEPTION`. In this case, exceptions are replaced by `abort()` calls. You can further control this behavior by defining `JSON_THROW_USER` (overriding `throw`), `JSON_TRY_USER` (overriding `try`), and `JSON_CATCH_USER` (overriding `catch`). Note that `JSON_THROW_USER` should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. Note the explanatory [`what()`](https://en.cppreference.com/w/cpp/error/exception/what) string of exceptions is not available for MSVC if exceptions are disabled, see [#2824](https://github.com/nlohmann/json/discussions/2824).

## Execute unit tests

To compile and run the tests, you need to execute

```sh
$ mkdir build
$ cd build
$ cmake .. -DJSON_BuildTests=On
$ cmake --build .
$ ctest --output-on-failure
```

Note that during the `ctest` stage, several JSON test files are downloaded from an [external repository](https://github.com/nlohmann/json_test_data). If policies forbid downloading artifacts during testing, you can download the files yourself and pass the directory with the test files via `-DJSON_TestDataDirectory=path` to CMake. Then, no Internet connectivity is required. See [issue #2189](https://github.com/nlohmann/json/issues/2189) for more information.

If the test suite is not found, several test suites will fail like this:

```
===============================================================================
json/tests/src/make_test_data_available.hpp:21:
TEST CASE:  check test suite is downloaded

json/tests/src/make_test_data_available.hpp:23: FATAL ERROR: REQUIRE( utils::check_testsuite_downloaded() ) is NOT correct!
  values: REQUIRE( false )
  logged: Test data not found in 'json/cmake-build-debug/json_test_data'.
          Please execute target 'download_test_data' before running this test suite.
          See <https://github.com/nlohmann/json#execute-unit-tests> for more information.

===============================================================================
```

In case you have downloaded the library rather than checked out the code via Git, test `cmake_fetch_content_configure` will fail. Please execute `ctest -LE git_required` to skip these tests. See [issue #2189](https://github.com/nlohmann/json/issues/2189) for more information.

Some tests change the installed files and hence make the whole process not reproducible. Please execute `ctest -LE not_reproducible` to skip these tests. See [issue #2324](https://github.com/nlohmann/json/issues/2324) for more information.

Note you need to call `cmake -LE "not_reproducible|git_required"` to exclude both labels. See [issue #2596](https://github.com/nlohmann/json/issues/2596) for more information.

As Intel compilers use unsafe floating point optimization by default, the unit tests may fail. Use flag [`/fp:precise`](https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/compiler-options/compiler-option-details/floating-point-options/fp-model-fp.html) then.

```

`API/include/nlohmann/LICENSES/Apache-2.0.txt`:

```txt
Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:

     (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and

     (b) You must cause any modified files to carry prominent notices stating that You changed the files; and

     (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and

     (d) If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.

     You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets "[]" replaced with your own identifying information. (Don't include the brackets!)  The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same "printed page" as the copyright notice for easier identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

```

`API/include/nlohmann/LICENSES/BSD-3-Clause.txt`:

```txt
Copyright (c) <year> <owner>. 

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`API/include/nlohmann/LICENSES/GPL-3.0-only.txt`:

```txt
GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/>

Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.

Preamble

The GNU General Public License is a free, copyleft license for software and other kinds of works.

The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.

For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.

Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.

Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and modification follow.

TERMS AND CONDITIONS

0. Definitions.

“This License” refers to version 3 of the GNU General Public License.

“Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.

“The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations.

To “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work.

A “covered work” means either the unmodified Program or a work based on the Program.

To “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.

To “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.

An interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.

1. Source Code.
The “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work.

A “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.

The “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.

The “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.

The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same work.

2. Basic Permissions.
All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.

3. Protecting Users' Legal Rights From Anti-Circumvention Law.
No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.

When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.

4. Conveying Verbatim Copies.
You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.

5. Conveying Modified Source Versions.
You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:

     a) The work must carry prominent notices stating that you modified it, and giving a relevant date.

     b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.

     c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.

     d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.

A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.

6. Conveying Non-Source Forms.
You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:

     a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.

     b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.

     c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.

     d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.

     e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.

A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.

A “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.

“Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.

If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).

The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.

7. Additional Terms.
“Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:

     a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or

     b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or

     c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or

     d) Limiting the use for publicity purposes of names of licensors or authors of the material; or

     e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or

     f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.

All other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.

8. Termination.
You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).

However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.

9. Acceptance Not Required for Having Copies.
You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.

10. Automatic Licensing of Downstream Recipients.
Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.

An “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.

11. Patents.
A “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's “contributor version”.

A contributor's “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.

In the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.

If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.

A patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.

12. No Surrender of Others' Freedom.
If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.

13. Use with the GNU Affero General Public License.
Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.

14. Revised Versions of this License.
The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.

If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.

Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.

15. Disclaimer of Warranty.
THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

16. Limitation of Liability.
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

17. Interpretation of Sections 15 and 16.
If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the “copyright” line and a pointer to where the full notice is found.

     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>

     This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:

     <program>  Copyright (C) <year>  <name of author>
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an “about box”.

You should also get your employer (if you work as a programmer) or school, if any, to sign a “copyright disclaimer” for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see <http://www.gnu.org/licenses/>.

The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`API/include/nlohmann/LICENSES/MIT.txt`:

```txt
MIT License

Copyright (c) <year> <copyright holders>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`API/include/nlohmann/adl_serializer.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <utility>

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/conversions/from_json.hpp>
#include <nlohmann/detail/conversions/to_json.hpp>
#include <nlohmann/detail/meta/identity_tag.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/// @sa https://json.nlohmann.me/api/adl_serializer/
template<typename ValueType, typename>
struct adl_serializer
{
    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j) noexcept(
    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
    {
        return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
    }

    /// @brief convert any value type to a JSON value
    /// @sa https://json.nlohmann.me/api/adl_serializer/to_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<TargetType>(val));
    }
};

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/byte_container_with_subtype.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint> // uint8_t, uint64_t
#include <tuple> // tie
#include <utility> // move

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief an internal type for a backed binary type
/// @sa https://json.nlohmann.me/api/byte_container_with_subtype/
template<typename BinaryType>
class byte_container_with_subtype : public BinaryType
{
  public:
    using container_type = BinaryType;
    using subtype_type = std::uint64_t;

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype() noexcept(noexcept(container_type()))
        : container_type()
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
        : container_type(b)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
        : container_type(b)
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    bool operator==(const byte_container_with_subtype& rhs) const
    {
        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
    }

    bool operator!=(const byte_container_with_subtype& rhs) const
    {
        return !(rhs == *this);
    }

    /// @brief sets the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/set_subtype/
    void set_subtype(subtype_type subtype_) noexcept
    {
        m_subtype = subtype_;
        m_has_subtype = true;
    }

    /// @brief return the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/subtype/
    constexpr subtype_type subtype() const noexcept
    {
        return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);
    }

    /// @brief return whether the value has a subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/has_subtype/
    constexpr bool has_subtype() const noexcept
    {
        return m_has_subtype;
    }

    /// @brief clears the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/clear_subtype/
    void clear_subtype() noexcept
    {
        m_subtype = 0;
        m_has_subtype = false;
    }

  private:
    subtype_type m_subtype = 0;
    bool m_has_subtype = false;
};

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/abi_macros.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

// This file contains all macro definitions affecting or depending on the ABI

#ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
    #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
        #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 11 || NLOHMANN_JSON_VERSION_PATCH != 2
            #warning "Already included a different version of the library!"
        #endif
    #endif
#endif

#define NLOHMANN_JSON_VERSION_MAJOR 3   // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_MINOR 11  // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_PATCH 2   // NOLINT(modernize-macro-to-enum)

#ifndef JSON_DIAGNOSTICS
    #define JSON_DIAGNOSTICS 0
#endif

#ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
#endif

#if JSON_DIAGNOSTICS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
#endif

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
#else
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
    #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
#endif

// Construct the namespace ABI tags component
#define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b) json_abi ## a ## b
#define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b) \
    NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b)

#define NLOHMANN_JSON_ABI_TAGS                                       \
    NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
            NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON)

// Construct the namespace version component
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
    _v ## major ## _ ## minor ## _ ## patch
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)

#if NLOHMANN_JSON_NAMESPACE_NO_VERSION
#define NLOHMANN_JSON_NAMESPACE_VERSION
#else
#define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
                                           NLOHMANN_JSON_VERSION_MINOR, \
                                           NLOHMANN_JSON_VERSION_PATCH)
#endif

// Combine namespace components
#define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
#define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
    NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)

#ifndef NLOHMANN_JSON_NAMESPACE
#define NLOHMANN_JSON_NAMESPACE               \
    nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
            NLOHMANN_JSON_ABI_TAGS,           \
            NLOHMANN_JSON_NAMESPACE_VERSION)
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
#define NLOHMANN_JSON_NAMESPACE_BEGIN                \
    namespace nlohmann                               \
    {                                                \
    inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
                NLOHMANN_JSON_ABI_TAGS,              \
                NLOHMANN_JSON_NAMESPACE_VERSION)     \
    {
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_END
#define NLOHMANN_JSON_NAMESPACE_END                                     \
    }  /* namespace (inline namespace) NOLINT(readability/namespace) */ \
    }  // namespace nlohmann
#endif

```

`API/include/nlohmann/detail/conversions/from_json.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // transform
#include <array> // array
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/identity_tag.hpp>
#include <nlohmann/detail/meta/std_fs.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
    {
        JSON_THROW(type_error::create(302, concat("type must be null, but is ", j.type_name()), &j));
    }
    n = nullptr;
}

// overloads for basic_json template parameters
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                         int > = 0 >
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::boolean:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, concat("type must be boolean, but is ", j.type_name()), &j));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename StringType,
    enable_if_t <
        std::is_assignable<StringType&, const typename BasicJsonType::string_t>::value
        && is_detected_exact<typename BasicJsonType::string_t::value_type, value_type_t, StringType>::value
        && !std::is_same<typename BasicJsonType::string_t, StringType>::value
        && !is_json_ref<StringType>::value, int > = 0 >
inline void from_json(const BasicJsonType& j, StringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.resize(j.size());
    std::transform(j.begin(), j.end(), std::begin(l),
                   [](const BasicJsonType & elem)
    {
        return elem.template get<T>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType>
inline void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
inline void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                                 priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template < typename BasicJsonType, typename ConstructibleArrayType,
           enable_if_t <
               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
               !is_basic_json<ConstructibleArrayType>::value,
               int > = 0 >
auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template < typename BasicJsonType, typename T, std::size_t... Idx >
std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
        identity_tag<std::array<T, sizeof...(Idx)>> /*unused*/, index_sequence<Idx...> /*unused*/)
{
    return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
}

template < typename BasicJsonType, typename T, std::size_t N >
auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
-> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
    {
        JSON_THROW(type_error::create(302, concat("type must be binary, but is ", j.type_name()), &j));
    }

    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
    {
        JSON_THROW(type_error::create(302, concat("type must be object, but is ", j.type_name()), &j));
    }

    ConstructibleObjectType ret;
    const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc..); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t <
               std::is_arithmetic<ArithmeticType>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
               int > = 0 >
inline void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType, typename... Args, std::size_t... Idx>
std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> /*unused*/)
{
    return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);
}

template < typename BasicJsonType, class A1, class A2 >
std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> /*unused*/, priority_tag<0> /*unused*/)
{
    return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
            std::forward<BasicJsonType>(j).at(1).template get<A2>()};
}

template<typename BasicJsonType, typename A1, typename A2>
inline void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> /*unused*/)
{
    p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
}

template<typename BasicJsonType, typename... Args>
std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> /*unused*/, priority_tag<2> /*unused*/)
{
    return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename... Args>
inline void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> /*unused*/)
{
    t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename TupleRelated>
auto from_json(BasicJsonType&& j, TupleRelated&& t)
-> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
}

template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, std_fs::path& p)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    p = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}
#endif

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T&& val) const
    noexcept(noexcept(from_json(j, std::forward<T>(val))))
    -> decltype(from_json(j, std::forward<T>(val)))
    {
        return from_json(j, std::forward<T>(val));
    }
};

}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& from_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::from_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/conversions/to_chars.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <array> // array
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template<typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        JSON_ASSERT(x.e == y.e);
        JSON_ASSERT(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        JSON_ASSERT(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        JSON_ASSERT(delta >= 0);
        JSON_ASSERT(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template<typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor if v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 && E > 1;
    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
                          : diyfp(2 * v.f - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    JSON_ASSERT(e >= -1500);
    JSON_ASSERT(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = (f * 78913) / (1 << 18) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    JSON_ASSERT(index >= 0);
    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    JSON_ASSERT(kAlpha <= cached.e + e + 64);
    JSON_ASSERT(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }

    pow10 = 1;
    return 1;
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    JSON_ASSERT(len >= 1);
    JSON_ASSERT(dist <= delta);
    JSON_ASSERT(rest <= delta);
    JSON_ASSERT(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            && delta - rest >= ten_k
            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
    {
        JSON_ASSERT(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    JSON_ASSERT(M_plus.e >= kAlpha);
    JSON_ASSERT(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    JSON_ASSERT(p1 > 0);

    std::uint32_t pow10{};
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead look if the buffer could be
            // decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    JSON_ASSERT(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    JSON_ASSERT(m_plus.e == m_minus.e);
    JSON_ASSERT(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes floats to doubles, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0 // NOLINT(readability-avoid-unconditional-preprocessor-if)
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    JSON_ASSERT(e > -1000);
    JSON_ASSERT(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + k / 100);
        k %= 100;
        *buf++ = static_cast<char>('0' + k / 10);
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    JSON_ASSERT(min_exp < 0);
    JSON_ASSERT(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n && n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (static_cast<size_t>(n) + 2);
    }

    if (0 < n && n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        JSON_ASSERT(k > n);

        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
        buf[n] = '.';
        return buf + (static_cast<size_t>(k) + 1U);
    }

    if (min_exp < n && n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
        buf[1] = '.';
        buf += 1 + static_cast<size_t>(k);
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

}  // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    JSON_ASSERT(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e. the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    JSON_ASSERT(last - first >= kMaxExp + 2);
    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/conversions/to_json.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // copy
#include <iterator> // begin, end
#include <string> // string
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

#include <nlohmann/detail/iterators/iteration_proxy.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/std_fs.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////
// constructors //
//////////////////

/*
 * Note all external_constructor<>::construct functions need to call
 * j.m_data.m_value.destroy(j.m_data.m_type) to avoid a memory leak in case j contains an
 * allocated value (e.g., a string). See bug issue
 * https://github.com/nlohmann/json/issues/2865 for more information.
 */

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::boolean;
        j.m_data.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = std::move(s);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleStringType,
               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::binary>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(b);
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(std::move(b));
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_float;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_unsigned;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_integer;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = arr;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = std::move(arr);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleArrayType,
               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_data.m_value.array->push_back(x);
            j.set_parent(j.m_data.m_value.array->back());
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->resize(arr.size());
        if (arr.size() > 0)
        {
            std::copy(std::begin(arr), std::end(arr), j.m_data.m_value.array->begin());
        }
        j.set_parents();
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = obj;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = std::move(obj);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleObjectType,
               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.set_parents();
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
inline void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template < typename BasicJsonType, typename BoolRef,
           enable_if_t <
               ((std::is_same<std::vector<bool>::reference, BoolRef>::value
                 && !std::is_same <std::vector<bool>::reference, typename BasicJsonType::boolean_t&>::value)
                || (std::is_same<std::vector<bool>::const_reference, BoolRef>::value
                    && !std::is_same <detail::uncvref_t<std::vector<bool>::const_reference>,
                                      typename BasicJsonType::boolean_t >::value))
               && std::is_convertible<const BoolRef&, typename BasicJsonType::boolean_t>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const BoolRef& b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, static_cast<typename BasicJsonType::boolean_t>(b));
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
inline void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
inline void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template < typename BasicJsonType, typename CompatibleArrayType,
           enable_if_t < is_compatible_array_type<BasicJsonType,
                         CompatibleArrayType>::value&&
                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
                         !is_basic_json<CompatibleArrayType>::value,
                         int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
{
    external_constructor<value_t::binary>::construct(j, bin);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
inline void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template < typename BasicJsonType, typename CompatibleObjectType,
           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
                  const T(&)[N]>::value, // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
                  int > = 0 >
inline void to_json(BasicJsonType& j, const T(&arr)[N]) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
inline void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
inline void to_json(BasicJsonType& j, const T& t)
{
    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std_fs::path& p)
{
    j = p.string();
}
#endif

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `to_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& to_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::to_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/exceptions.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef> // nullptr_t
#include <exception> // exception
#if JSON_DIAGNOSTICS
    #include <numeric> // accumulate
#endif
#include <stdexcept> // runtime_error
#include <string> // to_string
#include <vector> // vector

#include <nlohmann/detail/value_t.hpp>
#include <nlohmann/detail/string_escape.hpp>
#include <nlohmann/detail/input/position_t.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/string_concat.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

////////////////
// exceptions //
////////////////

/// @brief general exception of the @ref basic_json class
/// @sa https://json.nlohmann.me/api/basic_json/exception/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} // NOLINT(bugprone-throw-keyword-missing)

    static std::string name(const std::string& ename, int id_)
    {
        return concat("[json.exception.", ename, '.', std::to_string(id_), "] ");
    }

    static std::string diagnostics(std::nullptr_t /*leaf_element*/)
    {
        return "";
    }

    template<typename BasicJsonType>
    static std::string diagnostics(const BasicJsonType* leaf_element)
    {
#if JSON_DIAGNOSTICS
        std::vector<std::string> tokens;
        for (const auto* current = leaf_element; current != nullptr && current->m_parent != nullptr; current = current->m_parent)
        {
            switch (current->m_parent->type())
            {
                case value_t::array:
                {
                    for (std::size_t i = 0; i < current->m_parent->m_data.m_value.array->size(); ++i)
                    {
                        if (&current->m_parent->m_data.m_value.array->operator[](i) == current)
                        {
                            tokens.emplace_back(std::to_string(i));
                            break;
                        }
                    }
                    break;
                }

                case value_t::object:
                {
                    for (const auto& element : *current->m_parent->m_data.m_value.object)
                    {
                        if (&element.second == current)
                        {
                            tokens.emplace_back(element.first.c_str());
                            break;
                        }
                    }
                    break;
                }

                case value_t::null: // LCOV_EXCL_LINE
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:   // LCOV_EXCL_LINE
                    break; // LCOV_EXCL_LINE
            }
        }

        if (tokens.empty())
        {
            return "";
        }

        auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
                                   [](const std::string & a, const std::string & b)
        {
            return concat(a, '/', detail::escape(b));
        });
        return concat('(', str, ") ");
#else
        static_cast<void>(leaf_element);
        return "";
#endif
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
};

/// @brief exception indicating a parse error
/// @sa https://json.nlohmann.me/api/basic_json/parse_error/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     position_string(pos), ": ", exception::diagnostics(context), what_arg);
        return {id_, pos.chars_read_total, w.c_str()};
    }

    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     (byte_ != 0 ? (concat(" at byte ", std::to_string(byte_))) : ""),
                                     ": ", exception::diagnostics(context), what_arg);
        return {id_, byte_, w.c_str()};
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return concat(" at line ", std::to_string(pos.lines_read + 1),
                      ", column ", std::to_string(pos.chars_read_current_line));
    }
};

/// @brief exception indicating errors with iterators
/// @sa https://json.nlohmann.me/api/basic_json/invalid_iterator/
class invalid_iterator : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static invalid_iterator create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("invalid_iterator", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/// @brief exception indicating executing a member function with a wrong type
/// @sa https://json.nlohmann.me/api/basic_json/type_error/
class type_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static type_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("type_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating access out of the defined range
/// @sa https://json.nlohmann.me/api/basic_json/out_of_range/
class out_of_range : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static out_of_range create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("out_of_range", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating other library errors
/// @sa https://json.nlohmann.me/api/basic_json/other_error/
class other_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static other_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("other_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/hash.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint> // uint8_t
#include <cstddef> // size_t
#include <functional> // hash

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// boost::hash_combine
inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
{
    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
    return seed;
}

/*!
@brief hash a JSON value

The hash function tries to rely on std::hash where possible. Furthermore, the
type of the JSON value is taken into account to have different hash values for
null, 0, 0U, and false, etc.

@tparam BasicJsonType basic_json specialization
@param j JSON value to hash
@return hash value of j
*/
template<typename BasicJsonType>
std::size_t hash(const BasicJsonType& j)
{
    using string_t = typename BasicJsonType::string_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

    const auto type = static_cast<std::size_t>(j.type());
    switch (j.type())
    {
        case BasicJsonType::value_t::null:
        case BasicJsonType::value_t::discarded:
        {
            return combine(type, 0);
        }

        case BasicJsonType::value_t::object:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j.items())
            {
                const auto h = std::hash<string_t> {}(element.key());
                seed = combine(seed, h);
                seed = combine(seed, hash(element.value()));
            }
            return seed;
        }

        case BasicJsonType::value_t::array:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j)
            {
                seed = combine(seed, hash(element));
            }
            return seed;
        }

        case BasicJsonType::value_t::string:
        {
            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::boolean:
        {
            const auto h = std::hash<bool> {}(j.template get<bool>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_integer:
        {
            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_unsigned:
        {
            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_float:
        {
            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::binary:
        {
            auto seed = combine(type, j.get_binary().size());
            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
            seed = combine(seed, h);
            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
            for (const auto byte : j.get_binary())
            {
                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
            }
            return seed;
        }

        default:                   // LCOV_EXCL_LINE
            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            return 0;              // LCOV_EXCL_LINE
    }
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/binary_reader.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // generate_n
#include <array> // array
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move
#include <vector> // vector

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/input/input_adapters.hpp>
#include <nlohmann/detail/input/json_sax.hpp>
#include <nlohmann/detail/input/lexer.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/is_sax.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// how to treat CBOR tags
enum class cbor_tag_handler_t
{
    error,   ///< throw a parse_error exception in case of a tag
    ignore,  ///< ignore tags
    store    ///< store tags as binary type
};

/*!
@brief determine system byte order

@return true if and only if system's byte order is little endian

@note from https://stackoverflow.com/a/1001328/266378
*/
static inline bool little_endianness(int num = 1) noexcept
{
    return *reinterpret_cast<char*>(&num) == 1;
}

///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using json_sax_t = SAX;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(InputAdapterType&& adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed
    @param[in] tag_handler  how to treat CBOR tags

    @return whether parsing was successful
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true,
                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal(true, tag_handler);
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
            case input_format_t::bjdata:
                result = parse_ubjson_internal();
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result && strict)
        {
            if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
                                        exception_message(input_format, concat("expected end of input; last byte: 0x", get_token_string()), "value"), nullptr));
            }
        }

        return result;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<typename string_t::value_type>(current);
        }
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("string length must be at least 1, is ", std::to_string(len)), "string"), nullptr));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
    }

    /*!
    @brief Parses a byte array input of length @a len from the BSON input.
    @param[in] len  The length of the byte array to be read.
    @param[in,out] result  A reference to the binary variable where the read
                            array is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 0
    @return `true` if the byte array was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_binary(const NumberType len, binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 0))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("byte array length cannot be negative, is ", std::to_string(len)), "binary"), nullptr));
        }

        // All BSON binary values have a subtype
        std::uint8_t subtype{};
        get_number<std::uint8_t>(input_format_t::bson, subtype);
        result.set_subtype(subtype);

        return get_binary(input_format_t::bson, len, result);
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const char_int_type element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number{};
                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len{};
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x05: // binary
            {
                std::int32_t len{};
                binary_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value{};
                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value{};
                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            default: // anything else not supported (yet)
            {
                std::array<char, 3> cr{{}};
                static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                const std::string cr_str{cr.data()};
                return sax->parse_error(element_type_parse_position, cr_str,
                                        parse_error::create(114, element_type_parse_position, concat("Unsupported BSON record type 0x", cr_str), nullptr));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;

        while (auto element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
            {
                return false;
            }

            if (!is_array && !sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true) or whether the last read character should
                         be considered instead (false)
    @param[in] tag_handler how CBOR tags should be treated

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char,
                             const cbor_tag_handler_t tag_handler)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58: // Binary data (one-byte uint8_t for n follows)
            case 0x59: // Binary data (two-byte uint16_t for n follow)
            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            case 0x5F: // Binary data (indefinite length)
            {
                binary_t b;
                return get_cbor_binary(b) && sax->binary(b);
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) && sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(
                           conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(static_cast<std::size_t>(-1), tag_handler);

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(static_cast<std::size_t>(-1), tag_handler);

            case 0xC6: // tagged item
            case 0xC7:
            case 0xC8:
            case 0xC9:
            case 0xCA:
            case 0xCB:
            case 0xCC:
            case 0xCD:
            case 0xCE:
            case 0xCF:
            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3:
            case 0xD4:
            case 0xD8: // tagged item (1 bytes follow)
            case 0xD9: // tagged item (2 bytes follow)
            case 0xDA: // tagged item (4 bytes follow)
            case 0xDB: // tagged item (8 bytes follow)
            {
                switch (tag_handler)
                {
                    case cbor_tag_handler_t::error:
                    {
                        auto last_token = get_token_string();
                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                                exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
                    }

                    case cbor_tag_handler_t::ignore:
                    {
                        // ignore binary subtype
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            default:
                                break;
                        }
                        return parse_cbor_internal(true, tag_handler);
                    }

                    case cbor_tag_handler_t::store:
                    {
                        binary_t b;
                        // use binary subtype and store in binary container
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            default:
                                return parse_cbor_internal(true, tag_handler);
                        }
                        get();
                        return get_cbor_binary(b) && sax->binary(b);
                    }

                    default:                 // LCOV_EXCL_LINE
                        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                        return false;        // LCOV_EXCL_LINE
                }
            }

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (!get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into the byte array.
    Additionally, CBOR's byte arrays with indefinite lengths are supported.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_cbor_binary(binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
        {
            return false;
        }

        switch (current)
        {
            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            {
                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x58: // Binary data (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x59: // Binary data (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5F: // Binary data (indefinite length)
            {
                while (get() != 0xFF)
                {
                    binary_t chunk;
                    if (!get_cbor_binary(chunk))
                    {
                        return false;
                    }
                    result.insert(result.end(), chunk.begin(), chunk.end());
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x", last_token), "binary"), nullptr));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or static_cast<std::size_t>(-1) for an
                    array of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len,
                        const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        if (len != static_cast<std::size_t>(-1))
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or static_cast<std::size_t>(-1) for an
                    object of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len,
                         const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        if (len != 0)
        {
            string_t key;
            if (len != static_cast<std::size_t>(-1))
            {
                for (std::size_t i = 0; i < len; ++i)
                {
                    get();
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                while (get() != 0xFF)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case std::char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) && sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xC4: // bin 8
            case 0xC5: // bin 16
            case 0xC6: // bin 32
            case 0xC7: // ext 8
            case 0xC8: // ext 16
            case 0xC9: // ext 32
            case 0xD4: // fixext 1
            case 0xD5: // fixext 2
            case 0xD6: // fixext 4
            case 0xD7: // fixext 8
            case 0xD8: // fixext 16
            {
                binary_t b;
                return get_msgpack_binary(b) && sax->binary(b);
            }

            case 0xCA: // float 32
            {
                float number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(conditional_static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(conditional_static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::msgpack, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::msgpack, concat("expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into a byte array.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_msgpack_binary(binary_t& result)
    {
        // helper function to set the subtype
        auto assign_and_return_true = [&result](std::int8_t subtype)
        {
            result.set_subtype(static_cast<std::uint8_t>(subtype));
            return true;
        };

        switch (current)
        {
            case 0xC4: // bin 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC5: // bin 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC6: // bin 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC7: // ext 8
            {
                std::uint8_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC8: // ext 16
            {
                std::uint16_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC9: // ext 32
            {
                std::uint32_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD4: // fixext 1
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 1, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD5: // fixext 2
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 2, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD6: // fixext 4
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 4, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD7: // fixext 8
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 8, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD8: // fixext 16
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 16, result) &&
                       assign_and_return_true(subtype);
            }

            default:           // LCOV_EXCL_LINE
                return false;  // LCOV_EXCL_LINE
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'i':
            {
                std::int8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'I':
            {
                std::int16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'l':
            {
                std::int32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'L':
            {
                std::int64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "string"), nullptr));
    }

    /*!
    @param[out] dim  an integer vector storing the ND array dimensions
    @return whether reading ND array size vector is successful
    */
    bool get_ubjson_ndarray_size(std::vector<size_t>& dim)
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        size_t dimlen = 0;
        bool no_ndarray = true;

        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
        {
            return false;
        }

        if (size_and_type.first != npos)
        {
            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
                        {
                            return false;
                        }
                        dim.push_back(dimlen);
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
                    {
                        return false;
                    }
                    dim.push_back(dimlen);
                }
            }
        }
        else
        {
            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
                {
                    return false;
                }
                dim.push_back(dimlen);
                get_ignore_noop();
            }
        }
        return true;
    }

    /*!
    @param[out] result  determined size
    @param[in,out] is_ndarray  for input, `true` means already inside an ndarray vector
                               or ndarray dimension is not allowed; `false` means ndarray
                               is allowed; for output, `true` means an ndarray is found;
                               is_ndarray can only return `true` when its initial value
                               is `false`
    @param[in] prefix  type marker if already read, otherwise set to 0

    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result, bool& is_ndarray, char_int_type prefix = 0)
    {
        if (prefix == 0)
        {
            prefix = get_ignore_noop();
        }

        switch (prefix)
        {
            case 'U':
            {
                std::uint8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number); // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char
                return true;
            }

            case 'I':
            {
                std::int16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = conditional_static_cast<std::size_t>(number);
                return true;
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = detail::conditional_static_cast<std::size_t>(number);
                return true;
            }

            case '[':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                if (is_ndarray) // ndarray dimensional vector can only contain integers, and can not embed another array
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, "ndarray dimensional vector is not allowed", "size"), nullptr));
                }
                std::vector<size_t> dim;
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
                {
                    return false;
                }
                if (dim.size() == 1 || (dim.size() == 2 && dim.at(0) == 1)) // return normal array size if 1D row vector
                {
                    result = dim.at(dim.size() - 1);
                    return true;
                }
                if (!dim.empty())  // if ndarray, convert to an object in JData annotated array format
                {
                    for (auto i : dim) // test if any dimension in an ndarray is 0, if so, return a 1D empty container
                    {
                        if ( i == 0 )
                        {
                            result = 0;
                            return true;
                        }
                    }

                    string_t key = "_ArraySize_";
                    if (JSON_HEDLEY_UNLIKELY(!sax->start_object(3) || !sax->key(key) || !sax->start_array(dim.size())))
                    {
                        return false;
                    }
                    result = 1;
                    for (auto i : dim)
                    {
                        result *= i;
                        if (result == 0 || result == npos) // because dim elements shall not have zeros, result = 0 means overflow happened; it also can't be npos as it is used to initialize size in get_ubjson_size_type()
                        {
                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(static_cast<number_unsigned_t>(i))))
                        {
                            return false;
                        }
                    }
                    is_ndarray = true;
                    return sax->end_array();
                }
                result = 0;
                return true;
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L) after '#'; last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "size"), nullptr));
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type
    @param[in] inside_ndarray  whether the parser is parsing an ND array dimensional vector

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result, bool inside_ndarray = false)
    {
        result.first = npos; // size
        result.second = 0; // type
        bool is_ndarray = false;

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (input_format == input_format_t::bjdata
                    && JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("marker 0x", last_token, " is not a permitted optimized array type"), "type"), nullptr));
            }

            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("expected '#' after type information; last byte: 0x", last_token), "size"), nullptr));
            }

            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                if (inside_ndarray)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                            exception_message(input_format, "ndarray can not be recursive", "size"), nullptr));
                }
                result.second |= (1 << 8); // use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters
            }
            return is_error;
        }

        if (current == '#')
        {
            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                        exception_message(input_format, "ndarray requires both type and size", "size"), nullptr));
            }
            return is_error;
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const char_int_type prefix)
    {
        switch (prefix)
        {
            case std::char_traits<char_type>::eof():  // EOF
                return unexpect_eof(input_format, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'U':
            {
                std::uint8_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'h':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte2 << 8u) + byte1);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 'd':
            {
                float number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'H':
            {
                return get_ubjson_high_precision_number();
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                            exception_message(input_format, concat("byte after 'C' must be in range 0x00..0x7F; last byte: 0x", last_token), "char"), nullptr));
                }
                string_t s(1, static_cast<typename string_t::value_type>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) && sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
                break;
        }
        auto last_token = get_token_string();
        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, "invalid byte: 0x" + last_token, "value"), nullptr));
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // if bit-8 of size_and_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):
        // {"_ArrayType_" : "typeid", "_ArraySize_" : [n1, n2, ...], "_ArrayData_" : [v1, v2, ...]}

        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            size_and_type.second &= ~(static_cast<char_int_type>(1) << 8);  // use bit 8 to indicate ndarray, here we remove the bit to restore the type marker
            auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type & p, char_int_type t)
            {
                return p.first < t;
            });
            string_t key = "_ArrayType_";
            if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it->first != size_and_type.second))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, "invalid byte: 0x" + last_token, "type"), nullptr));
            }

            string_t type = it->second; // sax->string() takes a reference
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->string(type)))
            {
                return false;
            }

            if (size_and_type.second == 'C')
            {
                size_and_type.second = 'U';
            }

            key = "_ArrayData_";
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->start_array(size_and_type.first) ))
            {
                return false;
            }

            for (std::size_t i = 0; i < size_and_type.first; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                {
                    return false;
                }
            }

            return (sax->end_array() && sax->end_object());
        }

        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // do not accept ND-array size in objects in BJData
        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format, "BJData object does not support ND-array size in optimized format", "object"), nullptr));
        }

        string_t key;
        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    // Note, no reader for UBJSON binary types is implemented because they do
    // not exist

    bool get_ubjson_high_precision_number()
    {
        // get size of following number string
        std::size_t size{};
        bool no_ndarray = true;
        auto res = get_ubjson_size_value(size, no_ndarray);
        if (JSON_HEDLEY_UNLIKELY(!res))
        {
            return res;
        }

        // get number string
        std::vector<char> number_vector;
        for (std::size_t i = 0; i < size; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
            {
                return false;
            }
            number_vector.push_back(static_cast<char>(current));
        }

        // parse number string
        using ia_type = decltype(detail::input_adapter(number_vector));
        auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
        const auto result_number = number_lexer.scan();
        const auto number_string = number_lexer.get_token_string();
        const auto result_remainder = number_lexer.scan();

        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;

        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
        {
            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                    exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }

        switch (result_number)
        {
            case token_type::value_integer:
                return sax->number_integer(number_lexer.get_number_integer());
            case token_type::value_unsigned:
                return sax->number_unsigned(number_lexer.get_number_unsigned());
            case token_type::value_float:
                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
            case token_type::uninitialized:
            case token_type::literal_true:
            case token_type::literal_false:
            case token_type::literal_null:
            case token_type::value_string:
            case token_type::begin_array:
            case token_type::begin_object:
            case token_type::end_array:
            case token_type::end_object:
            case token_type::name_separator:
            case token_type::value_separator:
            case token_type::parse_error:
            case token_type::end_of_input:
            case token_type::literal_or_value:
            default:
                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                        exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `std::char_traits<char_type>::eof()` in that case.

    @return character read from the input
    */
    char_int_type get()
    {
        ++chars_read;
        return current = ia.get_character();
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    char_int_type get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianness, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // step 1: read input into array with system's byte order
        std::array<std::uint8_t, sizeof(NumberType)> vec{};
        for (std::size_t i = 0; i < sizeof(NumberType); ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "number")))
            {
                return false;
            }

            // reverse byte order prior to conversion if necessary
            if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
            {
                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
            }
            else
            {
                vec[i] = static_cast<std::uint8_t>(current); // LCOV_EXCL_LINE
            }
        }

        // step 2: convert array into number of type T and return
        std::memcpy(&result, vec.data(), sizeof(NumberType));
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename string_t::value_type>(current));
        }
        return success;
    }

    /*!
    @brief create a byte array by reading bytes from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of bytes to read
    @param[out] result byte array created by reading @a len bytes

    @return whether byte array creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of memory.
    */
    template<typename NumberType>
    bool get_binary(const input_format_t format,
                    const NumberType len,
                    binary_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<std::uint8_t>(current));
        }
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further context information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            case input_format_t::bjdata:
                error_msg += "BJData";
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        return concat(error_msg, ' ', context, ": ", detail);
    }

  private:
    static JSON_INLINE_VARIABLE constexpr std::size_t npos = static_cast<std::size_t>(-1);

    /// input adapter
    InputAdapterType ia;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// input format
    const input_format_t input_format = input_format_t::json;

    /// the SAX parser
    json_sax_t* sax = nullptr;

    // excluded markers in bjdata optimized type
#define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
    make_array<char_int_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '{')

#define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
    make_array<bjd_type>(                      \
    bjd_type{'C', "char"},                     \
    bjd_type{'D', "double"},                   \
    bjd_type{'I', "int16"},                    \
    bjd_type{'L', "int64"},                    \
    bjd_type{'M', "uint64"},                   \
    bjd_type{'U', "uint8"},                    \
    bjd_type{'d', "single"},                   \
    bjd_type{'i', "int8"},                     \
    bjd_type{'l', "int32"},                    \
    bjd_type{'m', "uint32"},                   \
    bjd_type{'u', "uint16"})

  JSON_PRIVATE_UNLESS_TESTED:
    // lookup tables
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
        JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;

    using bjd_type = std::pair<char_int_type, string_t>;
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
        JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;

#undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
#undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
};

#ifndef JSON_HAS_CPP_17
    template<typename BasicJsonType, typename InputAdapterType, typename SAX>
    constexpr std::size_t binary_reader<BasicJsonType, InputAdapterType, SAX>::npos;
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/input_adapters.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <array> // array
#include <cstddef> // size_t
#include <cstring> // strlen
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

#ifndef JSON_NO_IO
    #include <cstdio>   // FILE *
    #include <istream>  // istream
#endif                  // JSON_NO_IO

#include <nlohmann/detail/iterators/iterator_traits.hpp>
#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };

////////////////////
// input adapters //
////////////////////

#ifndef JSON_NO_IO
/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter
{
  public:
    using char_type = char;

    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f) noexcept
        : m_file(f)
    {
        JSON_ASSERT(m_file != nullptr);
    }

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) noexcept = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = delete;
    ~file_input_adapter() = default;

    std::char_traits<char>::int_type get_character() noexcept
    {
        return std::fgetc(m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};

/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter
{
  public:
    using char_type = char;

    ~input_stream_adapter()
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        if (is != nullptr)
        {
            is->clear(is->rdstate() & std::ios::eofbit);
        }
    }

    explicit input_stream_adapter(std::istream& i)
        : is(&i), sb(i.rdbuf())
    {}

    // delete because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;

    input_stream_adapter(input_stream_adapter&& rhs) noexcept
        : is(rhs.is), sb(rhs.sb)
    {
        rhs.is = nullptr;
        rhs.sb = nullptr;
    }

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, e.g. 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character()
    {
        auto res = sb->sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream* is = nullptr;
    std::streambuf* sb = nullptr;
};
#endif  // JSON_NO_IO

// General-purpose iterator-based adapter. It might not be as fast as
// theoretically possible for some containers, but it is extremely versatile.
template<typename IteratorType>
class iterator_input_adapter
{
  public:
    using char_type = typename std::iterator_traits<IteratorType>::value_type;

    iterator_input_adapter(IteratorType first, IteratorType last)
        : current(std::move(first)), end(std::move(last))
    {}

    typename std::char_traits<char_type>::int_type get_character()
    {
        if (JSON_HEDLEY_LIKELY(current != end))
        {
            auto result = std::char_traits<char_type>::to_int_type(*current);
            std::advance(current, 1);
            return result;
        }

        return std::char_traits<char_type>::eof();
    }

  private:
    IteratorType current;
    IteratorType end;

    template<typename BaseInputAdapter, size_t T>
    friend struct wide_string_input_helper;

    bool empty() const
    {
        return current == end;
    }
};

template<typename BaseInputAdapter, size_t T>
struct wide_string_input_helper;

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 4>
{
    // UTF-32
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 2>
{
    // UTF-16
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc || wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
                {
                    const auto wc2 = static_cast<unsigned int>(input.get_character());
                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

// Wraps another input adapter to convert wide character types into individual bytes.
template<typename BaseInputAdapter, typename WideCharType>
class wide_string_input_adapter
{
  public:
    using char_type = char;

    wide_string_input_adapter(BaseInputAdapter base)
        : base_adapter(base) {}

    typename std::char_traits<char>::int_type get_character() noexcept
    {
        // check if buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(WideCharType)>();

            JSON_ASSERT(utf8_bytes_filled > 0);
            JSON_ASSERT(utf8_bytes_index == 0);
        }

        // use buffer
        JSON_ASSERT(utf8_bytes_filled > 0);
        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

  private:
    BaseInputAdapter base_adapter;

    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};

template<typename IteratorType, typename Enable = void>
struct iterator_input_adapter_factory
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using adapter_type = iterator_input_adapter<iterator_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(std::move(first), std::move(last));
    }
};

template<typename T>
struct is_iterator_of_multibyte
{
    using value_type = typename std::iterator_traits<T>::value_type;
    enum
    {
        value = sizeof(value_type) > 1
    };
};

template<typename IteratorType>
struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using base_adapter_type = iterator_input_adapter<iterator_type>;
    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
    }
};

// General purpose iterator-based input
template<typename IteratorType>
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
{
    using factory_type = iterator_input_adapter_factory<IteratorType>;
    return factory_type::create(first, last);
}

// Convenience shorthand from container to iterator
// Enables ADL on begin(container) and end(container)
// Encloses the using declarations in namespace for not to leak them to outside scope

namespace container_input_adapter_factory_impl
{

using std::begin;
using std::end;

template<typename ContainerType, typename Enable = void>
struct container_input_adapter_factory {};

template<typename ContainerType>
struct container_input_adapter_factory< ContainerType,
       void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
       {
           using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));

           static adapter_type create(const ContainerType& container)
{
    return input_adapter(begin(container), end(container));
}
       };

}  // namespace container_input_adapter_factory_impl

template<typename ContainerType>
typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
{
    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
}

#ifndef JSON_NO_IO
// Special cases with fast paths
inline file_input_adapter input_adapter(std::FILE* file)
{
    return file_input_adapter(file);
}

inline input_stream_adapter input_adapter(std::istream& stream)
{
    return input_stream_adapter(stream);
}

inline input_stream_adapter input_adapter(std::istream&& stream)
{
    return input_stream_adapter(stream);
}
#endif  // JSON_NO_IO

using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));

// Null-delimited strings, and the like.
template < typename CharT,
           typename std::enable_if <
               std::is_pointer<CharT>::value&&
               !std::is_array<CharT>::value&&
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
               sizeof(typename std::remove_pointer<CharT>::type) == 1,
               int >::type = 0 >
contiguous_bytes_input_adapter input_adapter(CharT b)
{
    auto length = std::strlen(reinterpret_cast<const char*>(b));
    const auto* ptr = reinterpret_cast<const char*>(b);
    return input_adapter(ptr, ptr + length);
}

template<typename T, std::size_t N>
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    return input_adapter(array, array + N);
}

// This class only handles inputs of input_buffer_adapter type.
// It's required so that expressions like {ptr, len} can be implicitly cast
// to the correct adapter.
class span_input_adapter
{
  public:
    template < typename CharT,
               typename std::enable_if <
                   std::is_pointer<CharT>::value&&
                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
                   int >::type = 0 >
    span_input_adapter(CharT b, std::size_t l)
        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}

    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    span_input_adapter(IteratorType first, IteratorType last)
        : ia(input_adapter(first, last)) {}

    contiguous_bytes_input_adapter&& get()
    {
        return std::move(ia); // NOLINT(hicpp-move-const-arg,performance-move-const-arg)
    }

  private:
    contiguous_bytes_input_adapter ia;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/json_sax.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef>
#include <string> // string
#include <utility> // move
#include <vector> // vector

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/string_concat.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief a floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string value was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string value.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief a binary value was read
    @param[in] val  binary value
    @return whether parsing should proceed
    @note It is safe to move the passed binary value.
    */
    virtual bool binary(binary_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    json_sax() = default;
    json_sax(const json_sax&) = default;
    json_sax(json_sax&&) noexcept = default;
    json_sax& operator=(const json_sax&) = default;
    json_sax& operator=(json_sax&&) noexcept = default;
    virtual ~json_sax() = default;
};

namespace detail
{
/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @param[in,out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
        : root(r), allow_exceptions(allow_exceptions_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool key(string_t& val)
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

        // add null at given key and store the reference for later
        object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

        if (JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool end_array()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_array());

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));
            return &root;
        }

        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::forward<Value>(v));
            return &(ref_stack.back()->m_data.m_value.array->back());
        }

        JSON_ASSERT(ref_stack.back()->is_object());
        JSON_ASSERT(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));
        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

template<typename BasicJsonType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 const parser_callback_t cb,
                                 const bool allow_exceptions_ = true)
        : root(r), callback(cb), allow_exceptions(allow_exceptions_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        // check object limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at given key and store the reference for later
        if (keep && ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back())
        {
            if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
            {
                // discard object
                *ref_stack.back() = discarded;
            }
            else
            {
                ref_stack.back()->set_parents();
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        // check array limit
        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != static_cast<std::size_t>(-1) && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (keep)
            {
                ref_stack.back()->set_parents();
            }
            else
            {
                // discard array
                *ref_stack.back() = discarded;
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->pop_back();
        }

        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:
    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        JSON_ASSERT(!keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (!keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

        // check callback
        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (!keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, & root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (!ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::move(value));
            return {true, & (ref_stack.back()->m_data.m_value.array->back())};
        }

        // object
        JSON_ASSERT(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        JSON_ASSERT(!key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (!store_element)
        {
            return {false, nullptr};
        }

        JSON_ASSERT(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {};
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool binary(binary_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t /*unused*/ = static_cast<std::size_t>(-1))
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t /*unused*/ = static_cast<std::size_t>(-1))
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/lexer.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

#include <nlohmann/detail/input/input_adapters.hpp>
#include <nlohmann/detail/input/position_t.hpp>
#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////
// lexer //
///////////

template<typename BasicJsonType>
class lexer_base
{
  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case token_type::value_unsigned:
            case token_type::value_integer:
            case token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }
};
/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType, typename InputAdapterType>
class lexer : public lexer_base<BasicJsonType>
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename std::char_traits<char_type>::int_type;

  public:
    using token_type = typename lexer_base<BasicJsonType>::token_type;

    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
        : ia(std::move(adapter))
        , ignore_comments(ignore_comments_)
        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
    {}

    // delete because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto* loc = localeconv();
        JSON_ASSERT(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        JSON_ASSERT(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' && current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' && current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' && current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
    {
        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range))) // NOLINT(bugprone-inc-dec-in-conditions)
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 8259. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        JSON_ASSERT(current == '\"');

        while (true)
        {
            // get next character
            switch (get())
            {
                // end of file while parsing string
                case std::char_traits<char_type>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00 and 0x10000 noise
                                                        // in the result, so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // result of the above calculation yields a proper codepoint
                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(static_cast<char_int_type>(codepoint));
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    /*!
     * @brief scan a comment
     * @return whether comment could be scanned successfully
     */
    bool scan_comment()
    {
        switch (get())
        {
            // single-line comments skip input until a newline or EOF is read
            case '/':
            {
                while (true)
                {
                    switch (get())
                    {
                        case '\n':
                        case '\r':
                        case std::char_traits<char_type>::eof():
                        case '\0':
                            return true;

                        default:
                            break;
                    }
                }
            }

            // multi-line comments skip input until */ is read
            case '*':
            {
                while (true)
                {
                    switch (get())
                    {
                        case std::char_traits<char_type>::eof():
                        case '\0':
                        {
                            error_message = "invalid comment; missing closing '*/'";
                            return false;
                        }

                        case '*':
                        {
                            switch (get())
                            {
                                case '/':
                                    return true;

                                default:
                                {
                                    unget();
                                    continue;
                                }
                            }
                        }

                        default:
                            continue;
                    }
                }
            }

            // unexpected character after reading '/'
            default:
            {
                error_message = "invalid comment; expecting '/' or '*' after '/'";
                return false;
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 8259.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 8259. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto]
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno == 0)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char_type* literal_text, const std::size_t length,
                            token_type return_type)
    {
        JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        token_string.push_back(std::char_traits<char_type>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `std::char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    char_int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // just reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia.get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            token_string.push_back(std::char_traits<char_type>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))
        {
            JSON_ASSERT(!token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(char_int_type c)
    {
        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if (static_cast<unsigned char>(c) <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                static_cast<void>((std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(static_cast<std::string::value_type>(c));
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB && get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    void skip_whitespace()
    {
        do
        {
            get();
        }
        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 && !skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read next character and ignore whitespace
        skip_whitespace();

        // ignore comments
        while (ignore_comments && current == '/')
        {
            if (!scan_comment())
            {
                return token_type::parse_error;
            }

            // skip following whitespace
            skip_whitespace();
        }

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
            {
                std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};
                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
            }
            case 'f':
            {
                std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};
                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
            }
            case 'n':
            {
                std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};
                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
            }

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case std::char_traits<char_type>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// whether comments should be ignored (true) or signaled as errors (false)
    const bool ignore_comments = false;

    /// the current character
    char_int_type current = std::char_traits<char_type>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char_type> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char_int_type decimal_point_char = '.';
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/parser.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/input/input_adapters.hpp>
#include <nlohmann/detail/input/json_sax.hpp>
#include <nlohmann/detail/input/lexer.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/is_sax.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
////////////
// parser //
////////////

enum class parse_event_t : std::uint8_t
{
    /// the parser read `{` and started to process a JSON object
    object_start,
    /// the parser read `}` and finished processing a JSON object
    object_end,
    /// the parser read `[` and started to process a JSON array
    array_start,
    /// the parser read `]` and finished processing a JSON array
    array_end,
    /// the parser read a key of a value in an object
    key,
    /// the parser finished reading a JSON value
    value
};

template<typename BasicJsonType>
using parser_callback_t =
    std::function<bool(int /*depth*/, parse_event_t /*event*/, BasicJsonType& /*parsed*/)>;

/*!
@brief syntax analysis

This class implements a recursive descent parser.
*/
template<typename BasicJsonType, typename InputAdapterType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
    using token_type = typename lexer_t::token_type;

  public:
    /// a parser reading from an input adapter
    explicit parser(InputAdapterType&& adapter,
                    const parser_callback_t<BasicJsonType> cb = nullptr,
                    const bool allow_exceptions_ = true,
                    const bool skip_comments = false)
        : callback(cb)
        , m_lexer(std::move(adapter), skip_comments)
        , allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }

        result.assert_invariant();
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result && strict && (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
        }

        return result;
    }

  private:
    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (!skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(static_cast<std::size_t>(-1))))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(static_cast<std::size_t>(-1))))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
                        }

                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
                    }
                    case token_type::end_of_input:
                    {
                        if (JSON_HEDLEY_UNLIKELY(m_lexer.get_position().chars_read_total == 1))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
                        }

                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                    case token_type::uninitialized:
                    case token_type::end_array:
                    case token_type::end_object:
                    case token_type::name_separator:
                    case token_type::value_separator:
                    case token_type::literal_or_value:
                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
            }

            // states.back() is false -> object

            // comma -> next value
            if (get_token() == token_type::value_separator)
            {
                // parse key
                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
                {
                    return sax->parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                }

                if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                {
                    return false;
                }

                // parse separator (:)
                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                {
                    return sax->parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                }

                // parse values
                get_token();
                continue;
            }

            // closing }
            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
            {
                if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                {
                    return false;
                }

                // We are done with this object. Before we can parse a
                // new value, we need to evaluate the new state first.
                // By setting skip_to_state_evaluation to false, we
                // are effectively jumping to the beginning of this if.
                JSON_ASSERT(!states.empty());
                states.pop_back();
                skip_to_state_evaluation = true;
                continue;
            }

            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (!context.empty())
        {
            error_msg += concat("while parsing ", context, ' ');
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += concat(m_lexer.get_error_message(), "; last read: '",
                                m_lexer.get_token_string(), '\'');
        }
        else
        {
            error_msg += concat("unexpected ", lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += concat("; expected ", lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t<BasicJsonType> callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/input/position_t.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef> // size_t

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/iterators/internal_iterator.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/iterators/primitive_iterator.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/iterators/iter_impl.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/iterators/internal_iterator.hpp>
#include <nlohmann/detail/iterators/primitive_iterator.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// forward declare, to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
{
    /// the iterator with BasicJsonType of different const-ness
    using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    /// allow basic_json to access private members
    friend other_iter_impl;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");
    // superficial check for the LegacyBidirectionalIterator named requirement
    static_assert(std::is_base_of<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>::value
                  &&  std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<typename array_t::iterator>::iterator_category>::value,
                  "basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.");

  public:
    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    iter_impl() = default;
    ~iter_impl() = default;
    iter_impl(iter_impl&&) noexcept = default;
    iter_impl& operator=(iter_impl&&) noexcept = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constructor had to be defined explicitly to circumvent a bug
          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        if (&other != this)
        {
            m_object = other.m_object;
            m_it = other.m_it;
        }
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept // NOLINT(cert-oop54-cpp)
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->end();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return &*m_it.array_iterator;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief comparison: equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator==(const IterImpl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: not equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator!=(const IterImpl& other) const
    {
        return !operator==(other);
    }

    /*!
    @brief comparison: smaller
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", m_object));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: less than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator<=(const iter_impl& other) const
    {
        return !other.operator < (*this);
    }

    /*!
    @brief comparison: greater than
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>(const iter_impl& other) const
    {
        return !operator<=(other);
    }

    /*!
    @brief comparison: greater than or equal
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    bool operator>=(const iter_impl& other) const
    {
        return !operator<(other);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", m_object));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        JSON_ASSERT(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", m_object));
    }

    /*!
    @brief return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/iterators/iteration_proxy.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef> // size_t
#include <iterator> // input_iterator_tag
#include <string> // string, to_string
#include <tuple> // tuple_size, get, tuple_element
#include <utility> // move

#if JSON_HAS_RANGES
    #include <ranges> // enable_borrowed_range
#endif

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename string_type>
void int_to_string( string_type& target, std::size_t value )
{
    // For ADL
    using std::to_string;
    target = to_string(value);
}
template<typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type *;
    using reference = value_type &;
    using iterator_category = std::input_iterator_tag;
    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;

  private:
    /// the iterator
    IteratorType anchor{};
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable string_type array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    string_type empty_str{};

  public:
    explicit iteration_proxy_value() = default;
    explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_default_constructible<string_type>::value)
        : anchor(std::move(it))
        , array_index(array_index_)
    {}

    iteration_proxy_value(iteration_proxy_value const&) = default;
    iteration_proxy_value& operator=(iteration_proxy_value const&) = default;
    // older GCCs are a bit fussy and require explicit noexcept specifiers on defaulted functions
    iteration_proxy_value(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_move_constructible<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    iteration_proxy_value& operator=(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_assignable<IteratorType>::value
             && std::is_nothrow_move_assignable<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    ~iteration_proxy_value() = default;

    /// dereference operator (needed for range-based for)
    const iteration_proxy_value& operator*() const
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    iteration_proxy_value operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto tmp = iteration_proxy_value(anchor, array_index);
        ++anchor;
        ++array_index;
        return tmp;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const string_type& key() const
    {
        JSON_ASSERT(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    int_to_string( array_index_str, array_index );
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::pointer container = nullptr;

  public:
    explicit iteration_proxy() = default;

    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(&cont) {}

    iteration_proxy(iteration_proxy const&) = default;
    iteration_proxy& operator=(iteration_proxy const&) = default;
    iteration_proxy(iteration_proxy&&) noexcept = default;
    iteration_proxy& operator=(iteration_proxy&&) noexcept = default;
    ~iteration_proxy() = default;

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->end());
    }
};

// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{

#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template<typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>> // NOLINT(cert-dcl58-cpp)
            : public std::integral_constant<std::size_t, 2> {};

template<std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >> // NOLINT(cert-dcl58-cpp)
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

}  // namespace std

#if JSON_HAS_RANGES
    template <typename IteratorType>
    inline constexpr bool ::std::ranges::enable_borrowed_range<::nlohmann::detail::iteration_proxy<IteratorType>> = true;
#endif

```

`API/include/nlohmann/detail/iterators/iterator_traits.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <iterator> // random_access_iterator_tag

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/meta/void_t.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename It, typename = void>
struct iterator_types {};

template<typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template<typename T, typename = void>
struct iterator_traits
{
};

template<typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
            : iterator_types<T>
{
};

template<typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/iterators/json_reverse_iterator.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/iterators/primitive_iterator.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). It's only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin,
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

  JSON_PRIVATE_UNLESS_TESTED:
    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t operator++(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t operator--(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/json_custom_base_class.hpp`:

```hpp
#pragma once

#include <type_traits> // conditional, is_same

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief Default base class of the @ref basic_json class.

So that the correct implementations of the copy / move ctors / assign operators
of @ref basic_json do not require complex case distinctions
(no base class / custom base class used as customization point),
@ref basic_json always has a base class.
By default, this class is used because it is empty and thus has no effect
on the behavior of @ref basic_json.
*/
struct json_default_base {};

template<class T>
using json_base_class = typename std::conditional <
                        std::is_same<T, void>::value,
                        json_default_base,
                        T
                        >::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/json_pointer.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // all_of
#include <cctype> // isdigit
#include <cerrno> // errno, ERANGE
#include <cstdlib> // strtoull
#ifndef JSON_NO_IO
    #include <iosfwd> // ostream
#endif  // JSON_NO_IO
#include <limits> // max
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/string_escape.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
/// @sa https://json.nlohmann.me/api/json_pointer/
template<typename RefStringType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

    template<typename>
    friend class json_pointer;

    template<typename T>
    struct string_t_helper
    {
        using type = T;
    };

    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    struct string_t_helper<NLOHMANN_BASIC_JSON_TPL>
    {
        using type = StringType;
    };

  public:
    // for backwards compatibility accept BasicJsonType
    using string_t = typename string_t_helper<RefStringType>::type;

    /// @brief create JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/json_pointer/
    explicit json_pointer(const string_t& s = "")
        : reference_tokens(split(s))
    {}

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/to_string/
    string_t to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               string_t{},
                               [](const string_t& a, const string_t& b)
        {
            return detail::concat(a, '/', detail::escape(b));
        });
    }

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_string/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
    operator string_t() const
    {
        return to_string();
    }

#ifndef JSON_NO_IO
    /// @brief write string representation of the JSON pointer to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const json_pointer& ptr)
    {
        o << ptr.to_string();
        return o;
    }
#endif

    /// @brief append another JSON pointer at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /// @brief append an unescaped reference token at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(string_t token)
    {
        push_back(std::move(token));
        return *this;
    }

    /// @brief append an array index at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(std::size_t array_idx)
    {
        return *this /= std::to_string(array_idx);
    }

    /// @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /// @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, string_t token) // NOLINT(performance-unnecessary-value-param)
    {
        return json_pointer(lhs) /= std::move(token);
    }

    /// @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)
    {
        return json_pointer(lhs) /= array_idx;
    }

    /// @brief returns the parent of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/parent_pointer/
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /// @brief remove last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/pop_back/
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        reference_tokens.pop_back();
    }

    /// @brief return last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/back/
    const string_t& back() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        return reference_tokens.back();
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(const string_t& token)
    {
        reference_tokens.push_back(token);
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(string_t&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /// @brief return whether pointer points to the root document
    /// @sa https://json.nlohmann.me/api/json_pointer/empty/
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw parse_error.106  if an array index begins with '0'
    @throw parse_error.109  if an array index begins not with a digit
    @throw out_of_range.404 if string @a s could not be converted to an integer
    @throw out_of_range.410 if an array index exceeds size_type
    */
    template<typename BasicJsonType>
    static typename BasicJsonType::size_type array_index(const string_t& s)
    {
        using size_type = typename BasicJsonType::size_type;

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
        {
            JSON_THROW(detail::parse_error::create(106, 0, detail::concat("array index '", s, "' must not begin with '0'"), nullptr));
        }

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
        {
            JSON_THROW(detail::parse_error::create(109, 0, detail::concat("array index '", s, "' is not a number"), nullptr));
        }

        const char* p = s.c_str();
        char* p_end = nullptr;
        errno = 0; // strtoull doesn't reset errno
        const unsigned long long res = std::strtoull(p, &p_end, 10); // NOLINT(runtime/int)
        if (p == p_end // invalid input or empty string
                || errno == ERANGE // out of range
                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) // incomplete read
        {
            JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", s, "'"), nullptr));
        }

        // only triggered on special platforms (like 32bit), see also
        // https://github.com/nlohmann/json/pull/2203
        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  // NOLINT(runtime/int)
        {
            JSON_THROW(detail::out_of_range::create(410, detail::concat("array index ", s, " exceeds size_type"), nullptr));   // LCOV_EXCL_LINE
        }

        return static_cast<size_type>(res);
    }

  JSON_PRIVATE_UNLESS_TESTED:
    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

  private:
    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    template<typename BasicJsonType>
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        auto* result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    result = &result->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                single value; that is, with an empty list of reference tokens.
                */
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", &j));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to array for numbers or "-" or to object otherwise
                *ptr = (nums || reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_data.m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    }
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402, detail::concat("array index '-' (", std::to_string(ptr->m_data.m_value.array->size()), ") is out of range"), ptr));
                    }

                    // use unchecked array access
                    ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    template<typename BasicJsonType>
    bool contains(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (!ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
                    {
                        // invalid char
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
                    {
                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
                        {
                            // first char should be between '1' and '9'
                            return false;
                        }
                        for (std::size_t i = 1; i < reference_token.size(); i++)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
                            {
                                // other char should be between '0' and '9'
                                return false;
                            }
                        }
                    }

                    const auto idx = array_index<BasicJsonType>(reference_token);
                    if (idx >= ptr->size())
                    {
                        // index out of range
                        return false;
                    }

                    ptr = &ptr->operator[](idx);
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<string_t> split(const string_t& reference_string)
    {
        std::vector<string_t> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1, detail::concat("JSON pointer must be empty or begin with '/' - was: '", reference_string, "'"), nullptr));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == string_t::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == string_t::npos)
            start = (slash == string_t::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != string_t::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                JSON_ASSERT(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
                                         (reference_token[pos + 1] != '0' &&
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", nullptr));
                }
            }

            // finally, store the reference token
            detail::unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

  private:
    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    template<typename BasicJsonType>
    static void flatten(const string_t& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_data.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as reference string
                    for (std::size_t i = 0; i < value.m_data.m_value.array->size(); ++i)
                    {
                        flatten(detail::concat(reference_string, '/', std::to_string(i)),
                                value.m_data.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_data.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_data.m_value.object)
                    {
                        flatten(detail::concat(reference_string, '/', detail::escape(element.first)), element.second, result);
                    }
                }
                break;
            }

            case detail::value_t::null:
            case detail::value_t::string:
            case detail::value_t::boolean:
            case detail::value_t::number_integer:
            case detail::value_t::number_unsigned:
            case detail::value_t::number_float:
            case detail::value_t::binary:
            case detail::value_t::discarded:
            default:
            {
                // add primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    template<typename BasicJsonType>
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", &value));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_data.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive", &element.second));
            }

            // assign value to reference pointed to by JSON pointer; Note that if
            // the JSON pointer is "" (i.e., points to the whole value), function
            // get_and_create returns a reference to result itself. An assignment
            // will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    // can't use conversion operator because of ambiguity
    json_pointer<string_t> convert() const&
    {
        json_pointer<string_t> result;
        result.reference_tokens = reference_tokens;
        return result;
    }

    json_pointer<string_t> convert()&&
    {
        json_pointer<string_t> result;
        result.reference_tokens = std::move(reference_tokens);
        return result;
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs>
    bool operator==(const json_pointer<RefStringTypeRhs>& rhs) const noexcept
    {
        return reference_tokens == rhs.reference_tokens;
    }

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
    bool operator==(const string_t& rhs) const
    {
        return *this == json_pointer(rhs);
    }

    /// @brief 3-way compares two JSON pointers
    template<typename RefStringTypeRhs>
    std::strong_ordering operator<=>(const json_pointer<RefStringTypeRhs>& rhs) const noexcept // *NOPAD*
    {
        return  reference_tokens <=> rhs.reference_tokens; // *NOPAD*
    }
#else
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointers for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointer for less-than
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                          const json_pointer<RefStringTypeRhs>& rhs) noexcept;
#endif

  private:
    /// the reference tokens
    std::vector<string_t> reference_tokens;
};

#if !JSON_HAS_THREE_WAY_COMPARISON
// functions cannot be defined inside class due to ODR violations
template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens == rhs.reference_tokens;
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return lhs == json_pointer<RefStringTypeLhs>(rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return json_pointer<RefStringTypeRhs>(lhs) == rhs;
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                      const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens < rhs.reference_tokens;
}
#endif

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/json_ref.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <initializer_list>
#include <utility>

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value))
    {}

    json_ref(const value_type& value)
        : value_ref(&value)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...)
    {}

    // class should be movable only
    json_ref(json_ref&&) noexcept = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (value_ref == nullptr)
        {
            return std::move(owned_value);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return value_ref ? *value_ref : owned_value;
    }

    value_type const* operator->() const
    {
        return &** this;
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type const* value_ref = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/macro_scope.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <utility> // declval, pair
#include <nlohmann/detail/meta/detected.hpp>
#include <nlohmann/thirdparty/hedley/hedley.hpp>

// This file contains all internal macro definitions (except those affecting ABI)
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

#include <nlohmann/detail/abi_macros.hpp>

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
// if the user manually specified the used c++ version this is skipped
#if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
    #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
        #define JSON_HAS_CPP_14
    #endif
    // the cpp 11 flag is always specified because it is the minimal required version
    #define JSON_HAS_CPP_11
#endif

#ifdef __has_include
    #if __has_include(<version>)
        #include <version>
    #endif
#endif

#if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
    #ifdef JSON_HAS_CPP_17
        #if defined(__cpp_lib_filesystem)
            #define JSON_HAS_FILESYSTEM 1
        #elif defined(__cpp_lib_experimental_filesystem)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif !defined(__has_include)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif __has_include(<filesystem>)
            #define JSON_HAS_FILESYSTEM 1
        #elif __has_include(<experimental/filesystem>)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #endif

        // std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-w64/bugs/737/
        #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__clang_major__) && __clang_major__ < 7
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(_MSC_VER) && _MSC_VER < 1914
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before iOS 13
        #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before macOS Catalina
        #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif
    #endif
#endif

#ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
#endif

#ifndef JSON_HAS_FILESYSTEM
    #define JSON_HAS_FILESYSTEM 0
#endif

#ifndef JSON_HAS_THREE_WAY_COMPARISON
    #if defined(__cpp_impl_three_way_comparison) && __cpp_impl_three_way_comparison >= 201907L \
        && defined(__cpp_lib_three_way_comparison) && __cpp_lib_three_way_comparison >= 201907L
        #define JSON_HAS_THREE_WAY_COMPARISON 1
    #else
        #define JSON_HAS_THREE_WAY_COMPARISON 0
    #endif
#endif

#ifndef JSON_HAS_RANGES
    // ranges header shipping in GCC 11.1.0 (released 2021-04-27) has syntax error
    #if defined(__GLIBCXX__) && __GLIBCXX__ == 20210427
        #define JSON_HAS_RANGES 0
    #elif defined(__cpp_lib_ranges)
        #define JSON_HAS_RANGES 1
    #else
        #define JSON_HAS_RANGES 0
    #endif
#endif

#ifndef JSON_HAS_STATIC_RTTI
    #if !defined(_HAS_STATIC_RTTI) || _HAS_STATIC_RTTI != 0
        #define JSON_HAS_STATIC_RTTI 1
    #else
        #define JSON_HAS_STATIC_RTTI 0
    #endif
#endif

#ifdef JSON_HAS_CPP_17
    #define JSON_INLINE_VARIABLE inline
#else
    #define JSON_INLINE_VARIABLE
#endif

#if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
    #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
#else
    #define JSON_NO_UNIQUE_ADDRESS
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wdocumentation"
    #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
#endif

// allow disabling exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// allow overriding assert
#if !defined(JSON_ASSERT)
    #include <cassert> // assert
    #define JSON_ASSERT(x) assert(x)
#endif

// allow to access some private functions (needed by the test suite)
#if defined(JSON_TESTS_PRIVATE)
    #define JSON_PRIVATE_UNLESS_TESTED public
#else
    #define JSON_PRIVATE_UNLESS_TESTED private
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
    template<typename BasicJsonType>                                                            \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
        {                                                                                       \
            return ej_pair.first == e;                                                          \
        });                                                                                     \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
    }                                                                                           \
    template<typename BasicJsonType>                                                            \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
    {                                                                                           \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                       \
            return ej_pair.second == j;                                                         \
        });                                                                                     \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer,     \
             class BinaryType,                                             \
             class CustomBaseClass>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer, BinaryType, CustomBaseClass>

// Macros to simplify conversion from/to types

#define NLOHMANN_JSON_EXPAND( x ) x
#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
        NLOHMANN_JSON_PASTE64, \
        NLOHMANN_JSON_PASTE63, \
        NLOHMANN_JSON_PASTE62, \
        NLOHMANN_JSON_PASTE61, \
        NLOHMANN_JSON_PASTE60, \
        NLOHMANN_JSON_PASTE59, \
        NLOHMANN_JSON_PASTE58, \
        NLOHMANN_JSON_PASTE57, \
        NLOHMANN_JSON_PASTE56, \
        NLOHMANN_JSON_PASTE55, \
        NLOHMANN_JSON_PASTE54, \
        NLOHMANN_JSON_PASTE53, \
        NLOHMANN_JSON_PASTE52, \
        NLOHMANN_JSON_PASTE51, \
        NLOHMANN_JSON_PASTE50, \
        NLOHMANN_JSON_PASTE49, \
        NLOHMANN_JSON_PASTE48, \
        NLOHMANN_JSON_PASTE47, \
        NLOHMANN_JSON_PASTE46, \
        NLOHMANN_JSON_PASTE45, \
        NLOHMANN_JSON_PASTE44, \
        NLOHMANN_JSON_PASTE43, \
        NLOHMANN_JSON_PASTE42, \
        NLOHMANN_JSON_PASTE41, \
        NLOHMANN_JSON_PASTE40, \
        NLOHMANN_JSON_PASTE39, \
        NLOHMANN_JSON_PASTE38, \
        NLOHMANN_JSON_PASTE37, \
        NLOHMANN_JSON_PASTE36, \
        NLOHMANN_JSON_PASTE35, \
        NLOHMANN_JSON_PASTE34, \
        NLOHMANN_JSON_PASTE33, \
        NLOHMANN_JSON_PASTE32, \
        NLOHMANN_JSON_PASTE31, \
        NLOHMANN_JSON_PASTE30, \
        NLOHMANN_JSON_PASTE29, \
        NLOHMANN_JSON_PASTE28, \
        NLOHMANN_JSON_PASTE27, \
        NLOHMANN_JSON_PASTE26, \
        NLOHMANN_JSON_PASTE25, \
        NLOHMANN_JSON_PASTE24, \
        NLOHMANN_JSON_PASTE23, \
        NLOHMANN_JSON_PASTE22, \
        NLOHMANN_JSON_PASTE21, \
        NLOHMANN_JSON_PASTE20, \
        NLOHMANN_JSON_PASTE19, \
        NLOHMANN_JSON_PASTE18, \
        NLOHMANN_JSON_PASTE17, \
        NLOHMANN_JSON_PASTE16, \
        NLOHMANN_JSON_PASTE15, \
        NLOHMANN_JSON_PASTE14, \
        NLOHMANN_JSON_PASTE13, \
        NLOHMANN_JSON_PASTE12, \
        NLOHMANN_JSON_PASTE11, \
        NLOHMANN_JSON_PASTE10, \
        NLOHMANN_JSON_PASTE9, \
        NLOHMANN_JSON_PASTE8, \
        NLOHMANN_JSON_PASTE7, \
        NLOHMANN_JSON_PASTE6, \
        NLOHMANN_JSON_PASTE5, \
        NLOHMANN_JSON_PASTE4, \
        NLOHMANN_JSON_PASTE3, \
        NLOHMANN_JSON_PASTE2, \
        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)

#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
#define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1);

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
@since version 3.9.0
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

// inspired from https://stackoverflow.com/a/26745591
// allows to call any std function as if (e.g. with begin):
// using std::begin; begin(x);
//
// it allows using the detected idiom to retrieve the return type
// of such an expression
#define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
    namespace detail {                                                            \
    using std::std_name;                                                          \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    }                                                                             \
    \
    namespace detail2 {                                                           \
    struct std_name##_tag                                                         \
    {                                                                             \
    };                                                                            \
    \
    template<typename... T>                                                       \
    std_name##_tag std_name(T&&...);                                              \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name                                              \
    {                                                                             \
        static constexpr auto const value = ::nlohmann::detail::                  \
                                            is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \
    };                                                                            \
    } /* namespace detail2 */ \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \
    {                                                                             \
    }

#ifndef JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif

#if JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_EXPLICIT
#else
    #define JSON_EXPLICIT explicit
#endif

#ifndef JSON_DISABLE_ENUM_SERIALIZATION
    #define JSON_DISABLE_ENUM_SERIALIZATION 0
#endif

#ifndef JSON_USE_GLOBAL_UDLS
    #define JSON_USE_GLOBAL_UDLS 1
#endif

```

`API/include/nlohmann/detail/macro_unscope.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

// restore clang diagnostic settings
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

// clean up
#undef JSON_ASSERT
#undef JSON_INTERNAL_CATCH
#undef JSON_THROW
#undef JSON_PRIVATE_UNLESS_TESTED
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL
#undef JSON_EXPLICIT
#undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
#undef JSON_INLINE_VARIABLE
#undef JSON_NO_UNIQUE_ADDRESS
#undef JSON_DISABLE_ENUM_SERIALIZATION
#undef JSON_USE_GLOBAL_UDLS

#ifndef JSON_TEST_KEEP_MACROS
    #undef JSON_CATCH
    #undef JSON_TRY
    #undef JSON_HAS_CPP_11
    #undef JSON_HAS_CPP_14
    #undef JSON_HAS_CPP_17
    #undef JSON_HAS_CPP_20
    #undef JSON_HAS_FILESYSTEM
    #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #undef JSON_HAS_THREE_WAY_COMPARISON
    #undef JSON_HAS_RANGES
    #undef JSON_HAS_STATIC_RTTI
    #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

#include <nlohmann/thirdparty/hedley/hedley_undef.hpp>

```

`API/include/nlohmann/detail/meta/call_std/begin.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/call_std/end.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/cpp_future.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2018 The Abseil Authors
// SPDX-License-Identifier: MIT

#pragma once

#include <array> // array
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type
#include <utility> // index_sequence, make_index_sequence, index_sequence_for

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

#ifdef JSON_HAS_CPP_14

// the following utilities are natively available in C++14
using std::enable_if_t;
using std::index_sequence;
using std::make_index_sequence;
using std::index_sequence_for;

#else

// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

// The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h
// which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.

//// START OF CODE FROM GOOGLE ABSEIL

// integer_sequence
//
// Class template representing a compile-time integer sequence. An instantiation
// of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its
// type through its template arguments (which is a common need when
// working with C++11 variadic templates). `absl::integer_sequence` is designed
// to be a drop-in replacement for C++14's `std::integer_sequence`.
//
// Example:
//
//   template< class T, T... Ints >
//   void user_function(integer_sequence<T, Ints...>);
//
//   int main()
//   {
//     // user_function's `T` will be deduced to `int` and `Ints...`
//     // will be deduced to `0, 1, 2, 3, 4`.
//     user_function(make_integer_sequence<int, 5>());
//   }
template <typename T, T... Ints>
struct integer_sequence
{
    using value_type = T;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

// index_sequence
//
// A helper template for an `integer_sequence` of `size_t`,
// `absl::index_sequence` is designed to be a drop-in replacement for C++14's
// `std::index_sequence`.
template <size_t... Ints>
using index_sequence = integer_sequence<size_t, Ints...>;

namespace utility_internal
{

template <typename Seq, size_t SeqSize, size_t Rem>
struct Extend;

// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.
template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
};

template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
};

// Recursion helper for 'make_integer_sequence<T, N>'.
// 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.
template <typename T, size_t N>
struct Gen
{
    using type =
        typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
};

template <typename T>
struct Gen<T, 0>
{
    using type = integer_sequence<T>;
};

}  // namespace utility_internal

// Compile-time sequences of integers

// make_integer_sequence
//
// This template alias is equivalent to
// `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in
// replacement for C++14's `std::make_integer_sequence`.
template <typename T, T N>
using make_integer_sequence = typename utility_internal::Gen<T, N>::type;

// make_index_sequence
//
// This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,
// and is designed to be a drop-in replacement for C++14's
// `std::make_index_sequence`.
template <size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;

// index_sequence_for
//
// Converts a typename pack into an index sequence of the same length, and
// is designed to be a drop-in replacement for C++14's
// `std::index_sequence_for()`
template <typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

//// END OF CODE FROM GOOGLE ABSEIL

#endif

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static JSON_INLINE_VARIABLE constexpr T value{};
};

#ifndef JSON_HAS_CPP_17
    template<typename T>
    constexpr T static_const<T>::value;
#endif

template<typename T, typename... Args>
inline constexpr std::array<T, sizeof...(Args)> make_array(Args&& ... args)
{
    return std::array<T, sizeof...(Args)> {{static_cast<T>(std::forward<Args>(args))...}};
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/detected.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <type_traits>

#include <nlohmann/detail/meta/void_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// https://en.cppreference.com/w/cpp/experimental/is_detected
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template<class Default,
         class AlwaysVoid,
         template<class...> class Op,
         class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template<class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template<template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template<template<class...> class Op, class... Args>
struct is_detected_lazy : is_detected<Op, Args...> { };

template<template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template<class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template<class Default, template<class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template<class Expected, template<class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template<class To, template<class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/identity_tag.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// dispatching helper struct
template <class T> struct identity_tag {};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/is_sax.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

#include <nlohmann/detail/abi_macros.hpp>
#include <nlohmann/detail/meta/detected.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using null_function_t = decltype(std::declval<T&>().null());

template<typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template<typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template<typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template<typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template<typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template<typename T, typename Binary>
using binary_function_t =
    decltype(std::declval<T&>().binary(std::declval<Binary&>()));

template<typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template<typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template<typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template<typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template<typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template<typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template<typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template<typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
        "Missing/invalid function: bool binary(binary_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/std_fs.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/macro_scope.hpp>

#if JSON_HAS_EXPERIMENTAL_FILESYSTEM
#include <experimental/filesystem>
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::experimental::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#elif JSON_HAS_FILESYSTEM
#include <filesystem>
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#endif

```

`API/include/nlohmann/detail/meta/type_traits.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval
#include <tuple> // tuple

#include <nlohmann/detail/iterators/iterator_traits.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/call_std/begin.hpp>
#include <nlohmann/detail/meta/call_std/end.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/detected.hpp>
#include <nlohmann/json_fwd.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{

/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e. those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g. to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

// used by exceptions create() member functions
// true_type for pointer to possibly cv-qualified basic_json or std::nullptr_t
// false_type otherwise
template<typename BasicJsonContext>
struct is_basic_json_context :
    std::integral_constant < bool,
    is_basic_json<typename std::remove_cv<typename std::remove_pointer<BasicJsonContext>::type>::type>::value
    || std::is_same<BasicJsonContext, std::nullptr_t>::value >
{};

//////////////////////
// json_ref helpers //
//////////////////////

template<typename>
class json_ref;

template<typename>
struct is_json_ref : std::false_type {};

template<typename T>
struct is_json_ref<json_ref<T>> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template<typename T>
using mapped_type_t = typename T::mapped_type;

template<typename T>
using key_type_t = typename T::key_type;

template<typename T>
using value_type_t = typename T::value_type;

template<typename T>
using difference_type_t = typename T::difference_type;

template<typename T>
using pointer_t = typename T::pointer;

template<typename T>
using reference_t = typename T::reference;

template<typename T>
using iterator_category_t = typename T::iterator_category;

template<typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template<typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template<typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

// trait checking if j.get<T> is valid
// use this trait instead of std::is_constructible or std::is_convertible,
// both rely on, or make use of implicit conversions, and thus fail when T
// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
template <typename BasicJsonType, typename T>
struct is_getable
{
    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
};

template<typename BasicJsonType, typename T>
struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template<typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};

template<typename T>
using detect_key_compare = typename T::key_compare;

template<typename T>
struct has_key_compare : std::integral_constant<bool, is_detected<detect_key_compare, T>::value> {};

// obtains the actual object key comparator
template<typename BasicJsonType>
struct actual_object_comparator
{
    using object_t = typename BasicJsonType::object_t;
    using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
    using type = typename std::conditional < has_key_compare<object_t>::value,
          typename object_t::key_compare, object_comparator_t>::type;
};

template<typename BasicJsonType>
using actual_object_comparator_t = typename actual_object_comparator<BasicJsonType>::type;

///////////////////
// is_ functions //
///////////////////

// https://en.cppreference.com/w/cpp/types/conjunction
template<class...> struct conjunction : std::true_type { };
template<class B> struct conjunction<B> : B { };
template<class B, class... Bn>
struct conjunction<B, Bn...>
: std::conditional<static_cast<bool>(B::value), conjunction<Bn...>, B>::type {};

// https://en.cppreference.com/w/cpp/types/negation
template<class B> struct negation : std::integral_constant < bool, !B::value > { };

// Reimplementation of is_constructible and is_default_constructible, due to them being broken for
// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).
// This causes compile errors in e.g. clang 3.5 or gcc 4.9.
template <typename T>
struct is_default_constructible : std::is_default_constructible<T> {};

template <typename T1, typename T2>
struct is_default_constructible<std::pair<T1, T2>>
            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename T1, typename T2>
struct is_default_constructible<const std::pair<T1, T2>>
            : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename... Ts>
struct is_default_constructible<std::tuple<Ts...>>
            : conjunction<is_default_constructible<Ts>...> {};

template <typename... Ts>
struct is_default_constructible<const std::tuple<Ts...>>
            : conjunction<is_default_constructible<Ts>...> {};

template <typename T, typename... Args>
struct is_constructible : std::is_constructible<T, Args...> {};

template <typename T1, typename T2>
struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};

template <typename T1, typename T2>
struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};

template <typename... Ts>
struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};

template <typename... Ts>
struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};

template<typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template<typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

template<typename T>
struct is_range
{
  private:
    using t_ref = typename std::add_lvalue_reference<T>::type;

    using iterator = detected_t<result_of_begin, t_ref>;
    using sentinel = detected_t<result_of_end, t_ref>;

    // to be 100% correct, it should use https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator
    // and https://en.cppreference.com/w/cpp/iterator/sentinel_for
    // but reimplementing these would be too much work, as a lot of other concepts are used underneath
    static constexpr auto is_iterator_begin =
        is_iterator_traits<iterator_traits<iterator>>::value;

  public:
    static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;
};

template<typename R>
using iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;

template<typename T>
using range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;

// The following implementation of is_complete_type is taken from
// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/
// and is written by Xiang Fan who agreed to using it in this library.

template<typename T, typename = void>
struct is_complete_type : std::false_type {};

template<typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template<typename BasicJsonType, typename CompatibleObjectType,
         typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
    is_detected<key_type_t, CompatibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value &&
        is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template<typename BasicJsonType, typename ConstructibleObjectType,
         typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (is_default_constructible<ConstructibleObjectType>::value &&
         (std::is_move_assignable<ConstructibleObjectType>::value ||
          std::is_copy_assignable<ConstructibleObjectType>::value) &&
         (is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value &&
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) ||
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value ||
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template<typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type
{
    static constexpr auto value =
        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
{
    // launder type through decltype() to fix compilation failure on ICPC
#ifdef __INTEL_COMPILER
    using laundered_type = decltype(std::declval<ConstructibleStringType>());
#else
    using laundered_type = ConstructibleStringType;
#endif

    static constexpr auto value =
        conjunction <
        is_constructible<laundered_type, typename BasicJsonType::string_t>,
        is_detected_exact<typename BasicJsonType::string_t::value_type,
        value_type_t, laundered_type >>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t <
    is_detected<iterator_t, CompatibleArrayType>::value&&
    is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
    !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>
{
    static constexpr bool value =
        is_constructible<BasicJsonType,
        range_value_t<CompatibleArrayType>>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t < !std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value&&
    !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
    is_default_constructible<ConstructibleArrayType>::value&&
(std::is_move_assignable<ConstructibleArrayType>::value ||
 std::is_copy_assignable<ConstructibleArrayType>::value)&&
is_detected<iterator_t, ConstructibleArrayType>::value&&
is_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&
is_detected<range_value_t, ConstructibleArrayType>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
!std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&
        is_complete_type <
        detected_t<range_value_t, ConstructibleArrayType >>::value >>
{
    using value_type = range_value_t<ConstructibleArrayType>;

    static constexpr bool value =
        std::is_same<value_type,
        typename BasicJsonType::array_t::value_type>::value ||
        has_from_json<BasicJsonType,
        value_type>::value ||
        has_non_default_from_json <
        BasicJsonType,
        value_type >::value;
};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType,
         typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t < std::is_integral<RealIntegerType>::value&&
    std::is_integral<CompatibleNumberIntegerType>::value&&
    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value &&
        CompatibleLimits::is_integer &&
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template<typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};

template<typename T1, typename T2>
struct is_constructible_tuple : std::false_type {};

template<typename T1, typename... Args>
struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};

template<typename BasicJsonType, typename T>
struct is_json_iterator_of : std::false_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::iterator> : std::true_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::const_iterator> : std::true_type
{};

// checks if a given type T is a template specialization of Primary
template<template <typename...> class Primary, typename T>
struct is_specialization_of : std::false_type {};

template<template <typename...> class Primary, typename... Args>
struct is_specialization_of<Primary, Primary<Args...>> : std::true_type {};

template<typename T>
using is_json_pointer = is_specialization_of<::nlohmann::json_pointer, uncvref_t<T>>;

// checks if A and B are comparable using Compare functor
template<typename Compare, typename A, typename B, typename = void>
struct is_comparable : std::false_type {};

template<typename Compare, typename A, typename B>
struct is_comparable<Compare, A, B, void_t<
decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>())),
decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))
>> : std::true_type {};

template<typename T>
using detect_is_transparent = typename T::is_transparent;

// type trait to check if KeyType can be used as object key (without a BasicJsonType)
// see is_usable_as_basic_json_key_type below
template<typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_key_type = typename std::conditional <
                              is_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value
                              && !(ExcludeObjectKeyType && std::is_same<KeyType,
                                   ObjectKeyType>::value)
                              && (!RequireTransparentComparator
                                  || is_detected <detect_is_transparent, Comparator>::value)
                              && !is_json_pointer<KeyType>::value,
                              std::true_type,
                              std::false_type >::type;

// type trait to check if KeyType can be used as object key
// true if:
//   - KeyType is comparable with BasicJsonType::object_t::key_type
//   - if ExcludeObjectKeyType is true, KeyType is not BasicJsonType::object_t::key_type
//   - the comparator is transparent or RequireTransparentComparator is false
//   - KeyType is not a JSON iterator or json_pointer
template<typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_basic_json_key_type = typename std::conditional <
        is_usable_as_key_type<typename BasicJsonType::object_comparator_t,
        typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
        RequireTransparentComparator, ExcludeObjectKeyType>::value
        && !is_json_iterator_of<BasicJsonType, KeyType>::value,
        std::true_type,
        std::false_type >::type;

template<typename ObjectType, typename KeyType>
using detect_erase_with_key_type = decltype(std::declval<ObjectType&>().erase(std::declval<KeyType>()));

// type trait to check if object_t has an erase() member functions accepting KeyType
template<typename BasicJsonType, typename KeyType>
using has_erase_with_key_type = typename std::conditional <
                                is_detected <
                                detect_erase_with_key_type,
                                typename BasicJsonType::object_t, KeyType >::value,
                                std::true_type,
                                std::false_type >::type;

// a naive helper to check if a type is an ordered_map (exploits the fact that
// ordered_map inherits capacity() from std::vector)
template <typename T>
struct is_ordered_map
{
    using one = char;

    struct two
    {
        char x[2]; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    };

    template <typename C> static one test( decltype(&C::capacity) ) ;
    template <typename C> static two test(...);

    enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
};

// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)
template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
T conditional_static_cast(U value)
{
    return static_cast<T>(value);
}

template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
T conditional_static_cast(U value)
{
    return value;
}

template<typename... Types>
using all_integral = conjunction<std::is_integral<Types>...>;

template<typename... Types>
using all_signed = conjunction<std::is_signed<Types>...>;

template<typename... Types>
using all_unsigned = conjunction<std::is_unsigned<Types>...>;

// there's a disjunction trait in another PR; replace when merged
template<typename... Types>
using same_sign = std::integral_constant < bool,
      all_signed<Types...>::value || all_unsigned<Types...>::value >;

template<typename OfType, typename T>
using never_out_of_range = std::integral_constant < bool,
      (std::is_signed<OfType>::value && (sizeof(T) < sizeof(OfType)))
      || (same_sign<OfType, T>::value && sizeof(OfType) == sizeof(T)) >;

template<typename OfType, typename T,
         bool OfTypeSigned = std::is_signed<OfType>::value,
         bool TSigned = std::is_signed<T>::value>
struct value_in_range_of_impl2;

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return val >= 0 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) >= static_cast<CommonType>((std::numeric_limits<OfType>::min)())
               && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T,
         bool NeverOutOfRange = never_out_of_range<OfType, T>::value,
         typename = detail::enable_if_t<all_integral<OfType, T>::value>>
struct value_in_range_of_impl1;

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, false>
{
    static constexpr bool test(T val)
    {
        return value_in_range_of_impl2<OfType, T>::test(val);
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, true>
{
    static constexpr bool test(T /*val*/)
    {
        return true;
    }
};

template<typename OfType, typename T>
inline constexpr bool value_in_range_of(T val)
{
    return value_in_range_of_impl1<OfType, T>::test(val);
}

template<bool Value>
using bool_constant = std::integral_constant<bool, Value>;

///////////////////////////////////////////////////////////////////////////////
// is_c_string
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
inline constexpr bool is_c_string()
{
    using TUnExt = typename std::remove_extent<T>::type;
    using TUnCVExt = typename std::remove_cv<TUnExt>::type;
    using TUnPtr = typename std::remove_pointer<T>::type;
    using TUnCVPtr = typename std::remove_cv<TUnPtr>::type;
    return
        (std::is_array<T>::value && std::is_same<TUnCVExt, char>::value)
        || (std::is_pointer<T>::value && std::is_same<TUnCVPtr, char>::value);
}

}  // namespace impl

// checks whether T is a [cv] char */[cv] char[] C string
template<typename T>
struct is_c_string : bool_constant<impl::is_c_string<T>()> {};

template<typename T>
using is_c_string_uncvref = is_c_string<uncvref_t<T>>;

///////////////////////////////////////////////////////////////////////////////
// is_transparent
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
inline constexpr bool is_transparent()
{
    return is_detected<detect_is_transparent, T>::value;
}

}  // namespace impl

// checks whether T has a member named is_transparent
template<typename T>
struct is_transparent : bool_constant<impl::is_transparent<T>()> {};

///////////////////////////////////////////////////////////////////////////////

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/meta/void_t.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename ...Ts> struct make_void
{
    using type = void;
};
template<typename ...Ts> using void_t = typename make_void<Ts...>::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/output/binary_writer.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // reverse
#include <array> // array
#include <map> // map
#include <cmath> // isnan, isinf
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string
#include <utility> // move
#include <vector> // vector

#include <nlohmann/detail/input/binary_reader.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/output/output_adapters.hpp>
#include <nlohmann/detail/string_concat.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
    {
        JSON_ASSERT(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_data.m_value.object);
                break;
            }

            case value_t::null:
            case value_t::array:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                JSON_THROW(type_error::create(317, concat("to serialize to BSON, top-level type must be object, but is ", j.type_name()), &j));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_data.m_value.number_integer;
                    if (j.m_data.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                if (std::isnan(j.m_data.m_value.number_float))
                {
                    // NaN is 0xf97e00 in CBOR
                    oa->write_character(to_char_type(0xF9));
                    oa->write_character(to_char_type(0x7E));
                    oa->write_character(to_char_type(0x00));
                }
                else if (std::isinf(j.m_data.m_value.number_float))
                {
                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
                    oa->write_character(to_char_type(0xf9));
                    oa->write_character(j.m_data.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
                    oa->write_character(to_char_type(0x00));
                }
                else
                {
                    write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::cbor);
                }
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::binary:
            {
                if (j.m_data.m_value.binary->has_subtype())
                {
                    if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd8));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd9));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xda));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xdb));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.binary->subtype()));
                    }
                }

                // step 1: write control byte and the binary array size
                const auto N = j.m_data.m_value.binary->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x40 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x58));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x59));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x5A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x5B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_data.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_data.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::msgpack);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::binary:
            {
                // step 0: determine if the binary type has a set subtype to
                // determine whether or not to use the ext or fixext types
                const bool use_ext = j.m_data.m_value.binary->has_subtype();

                // step 1: write control byte and the byte string length
                const auto N = j.m_data.m_value.binary->size();
                if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    std::uint8_t output_type{};
                    bool fixed = true;
                    if (use_ext)
                    {
                        switch (N)
                        {
                            case 1:
                                output_type = 0xD4; // fixext 1
                                break;
                            case 2:
                                output_type = 0xD5; // fixext 2
                                break;
                            case 4:
                                output_type = 0xD6; // fixext 4
                                break;
                            case 8:
                                output_type = 0xD7; // fixext 8
                                break;
                            case 16:
                                output_type = 0xD8; // fixext 16
                                break;
                            default:
                                output_type = 0xC7; // ext 8
                                fixed = false;
                                break;
                        }

                    }
                    else
                    {
                        output_type = 0xC4; // bin 8
                        fixed = false;
                    }

                    oa->write_character(to_char_type(output_type));
                    if (!fixed)
                    {
                        write_number(static_cast<std::uint8_t>(N));
                    }
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC8 // ext 16
                                                     : 0xC5; // bin 16

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC9 // ext 32
                                                     : 0xC6; // bin 32

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 1.5: if this is an ext type, write the subtype
                if (use_ext)
                {
                    write_number(static_cast<std::int8_t>(j.m_data.m_value.binary->subtype()));
                }

                // step 2: write the byte string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    @param[in] use_bjdata  whether write in BJData format, default is false
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true,
                      const bool use_bjdata = false)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_data.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_integer, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_unsigned, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_float, add_prefix, use_bjdata);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_data.m_value.string->size(), true, use_bjdata);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.array->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.array->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required, use_bjdata);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::binary:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                if (use_type && !j.m_data.m_value.binary->empty())
                {
                    JSON_ASSERT(use_count);
                    oa->write_character(to_char_type('$'));
                    oa->write_character('U');
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.binary->size(), true, use_bjdata);
                }

                if (use_type)
                {
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                        j.m_data.m_value.binary->size());
                }
                else
                {
                    for (size_t i = 0; i < j.m_data.m_value.binary->size(); ++i)
                    {
                        oa->write_character(to_char_type('U'));
                        oa->write_character(j.m_data.m_value.binary->data()[i]);
                    }
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (use_bjdata && j.m_data.m_value.object->size() == 3 && j.m_data.m_value.object->find("_ArrayType_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArraySize_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArrayData_") != j.m_data.m_value.object->end())
                {
                    if (!write_bjdata_ndarray(*j.m_data.m_value.object, use_count, use_type))  // decode bjdata ndarray in the JData format (https://github.com/NeuroJSON/jdata)
                    {
                        break;
                    }
                }

                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.object->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.object->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409, concat("BSON key cannot contain code point U+0000 (at byte ", std::to_string(it), ")"), &j));
            static_cast<void>(j);
        }

        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double>(value, true);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size() + 1ul), true);
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t>(static_cast<std::int32_t>(value), true);
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t>(static_cast<std::int64_t>(value), true);
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const BasicJsonType& j)
    {
        if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t>(static_cast<std::int32_t>(j.m_data.m_value.number_unsigned), true);
        }
        else if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t>(static_cast<std::int64_t>(j.m_data.m_value.number_unsigned), true);
        }
        else
        {
            JSON_THROW(out_of_range::create(407, concat("integer number ", std::to_string(j.m_data.m_value.number_unsigned), " cannot be represented by BSON as it does not fit int64"), &j));
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t array_index = 0ul;

        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast<std::size_t>(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
        {
            return result + calc_bson_element_size(std::to_string(array_index++), el);
        });

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @return The size of the BSON-encoded binary array @a value
    */
    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_array_size(value)), true);

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and binary value @a value
    */
    void write_bson_binary(const string_t& name,
                           const binary_t& value)
    {
        write_bson_entry_header(name, 0x05);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size()), true);
        write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : static_cast<std::uint8_t>(0x00));

        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name, j);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_data.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_data.m_value.array);

            case value_t::binary:
                return header_size + calc_bson_binary_size(*j.m_data.m_value.binary);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_data.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_data.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_data.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_data.m_value.array);

            case value_t::binary:
                return write_bson_binary(name, *j.m_data.m_value.binary);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_data.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_data.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j);

            case value_t::string:
                return write_bson_string(name, *j.m_data.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),
                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_object_size(value)), true);

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n, use_bjdata);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<std::uint16_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<std::uint32_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= (std::numeric_limits<uint64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('M'));  // uint64 - bjdata only
            }
            write_number(static_cast<std::uint64_t>(n), use_bjdata);
        }
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
    }

    // UBJSON: write number (signed integer)
    template < typename NumberType, typename std::enable_if <
                   std::is_signed<NumberType>::value&&
                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n), use_bjdata);
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<uint16_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<uint32_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        // LCOV_EXCL_START
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values
    */
    CharType ubjson_prefix(const BasicJsonType& j, const bool use_bjdata) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_data.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                {
                    return 'L';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
                {
                    return 'L';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    return 'M';
                }
                // anything else is treated as high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_data.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array: // fallthrough
            case value_t::binary:
                return '[';

            case value_t::object:
                return '{';

            case value_t::discarded:
            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    /*!
    @return false if the object is successfully converted to a bjdata ndarray, true if the type or size is invalid
    */
    bool write_bjdata_ndarray(const typename BasicJsonType::object_t& value, const bool use_count, const bool use_type)
    {
        std::map<string_t, CharType> bjdtype = {{"uint8", 'U'},  {"int8", 'i'},  {"uint16", 'u'}, {"int16", 'I'},
            {"uint32", 'm'}, {"int32", 'l'}, {"uint64", 'M'}, {"int64", 'L'}, {"single", 'd'}, {"double", 'D'}, {"char", 'C'}
        };

        string_t key = "_ArrayType_";
        auto it = bjdtype.find(static_cast<string_t>(value.at(key)));
        if (it == bjdtype.end())
        {
            return true;
        }
        CharType dtype = it->second;

        key = "_ArraySize_";
        std::size_t len = (value.at(key).empty() ? 0 : 1);
        for (const auto& el : value.at(key))
        {
            len *= static_cast<std::size_t>(el.m_data.m_value.number_unsigned);
        }

        key = "_ArrayData_";
        if (value.at(key).size() != len)
        {
            return true;
        }

        oa->write_character('[');
        oa->write_character('$');
        oa->write_character(dtype);
        oa->write_character('#');

        key = "_ArraySize_";
        write_ubjson(value.at(key), use_count, use_type, true,  true);

        key = "_ArrayData_";
        if (dtype == 'U' || dtype == 'C')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint8_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'i')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int8_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'u')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint16_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'I')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int16_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'm')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint32_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'l')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int32_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'M')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint64_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'L')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int64_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'd')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<float>(el.m_data.m_value.number_float), true);
            }
        }
        else if (dtype == 'D')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<double>(el.m_data.m_value.number_float), true);
            }
        }
        return false;
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @param[in] OutputIsLittleEndian Set to true if output data is
                                 required to be little endian
    @tparam NumberType the type of the number

    @note This function needs to respect the system's endianness, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType>
    void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
    {
        // step 1: write number to array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec{};
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

    void write_compact_float(const number_float_t n, detail::input_format_t format)
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
                static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
                static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(static_cast<float>(n))
                                : get_msgpack_float_prefix(static_cast<float>(n)));
            write_number(static_cast<float>(n));
        }
        else
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(n)
                                : get_msgpack_float_prefix(n));
            write_number(n);
        }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value &&
                   std::is_signed<char>::value &&
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/output/output_adapters.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // copy
#include <cstddef> // size_t
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <string> // basic_string
#include <vector> // vector

#ifndef JSON_NO_IO
    #include <ios>      // streamsize
    #include <ostream>  // basic_ostream
#endif  // JSON_NO_IO

#include <nlohmann/detail/macro_scope.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;

    output_adapter_protocol() = default;
    output_adapter_protocol(const output_adapter_protocol&) = default;
    output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
    output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
    output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType, typename AllocatorType = std::allocator<CharType>>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        v.insert(v.end(), s, s + length);
    }

  private:
    std::vector<CharType, AllocatorType>& v;
};

#ifndef JSON_NO_IO
/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};
#endif  // JSON_NO_IO

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    template<typename AllocatorType = std::allocator<CharType>>
    output_adapter(std::vector<CharType, AllocatorType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}

#ifndef JSON_NO_IO
    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
#endif  // JSON_NO_IO

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/output/serializer.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2008-2009 Björn Hoehrmann <bjoern@hoehrmann.de>
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string, char_traits
#include <iomanip> // setfill, setw
#include <type_traits> // is_same
#include <utility> // move

#include <nlohmann/detail/conversions/to_chars.hpp>
#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/output/binary_writer.hpp>
#include <nlohmann/detail/output/output_adapters.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/value_t.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using binary_char_t = typename BasicJsonType::binary_t::value_type;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // delete because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format
    - binary values are serialized as objects containing the subtype and the
      byte array

    @param[in] val               value to serialize
    @param[in] pretty_print      whether the output shall be pretty-printed
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] indent_step       the indent level
    @param[in] current_indent    the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val,
              const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_data.m_type)
        {
            case value_t::object:
            {
                if (val.m_data.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_data.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_data.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    dump(val.m_data.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_data.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::binary:
            {
                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"bytes\": [", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_characters(", ", 2);
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\n", 3);
                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"subtype\": ", 11);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                    }
                    else
                    {
                        o->write_characters("null", 4);
                    }
                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_characters("{\"bytes\":[", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_character(',');
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\"subtype\":", 12);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                        o->write_character('}');
                    }
                    else
                    {
                        o->write_characters("null}", 5);
                    }
                }
                return;
            }

            case value_t::boolean:
            {
                if (val.m_data.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_data.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_data.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_data.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint{};
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<std::uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                                      static_cast<std::uint16_t>(codepoint)));
                                    bytes += 6;
                                }
                                else
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                                      static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                                      static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu))));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            JSON_THROW(type_error::create(316, concat("invalid UTF-8 byte at index ", std::to_string(i), ": 0x", hex_bytes(byte | 0)), nullptr));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multi-byte code point
                {
                    if (!ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    JSON_THROW(type_error::create(316, concat("incomplete UTF-8 string; last byte: 0x", hex_bytes(static_cast<std::uint8_t>(s.back() | 0))), nullptr));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        }
    }

  private:
    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    inline unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
     * @brief convert a byte to a uppercase hex representation
     * @param[in] byte byte to represent
     * @return representation ("00".."FF")
     */
    static std::string hex_bytes(std::uint8_t byte)
    {
        std::string result = "FF";
        constexpr const char* nibble_to_hex = "0123456789ABCDEF";
        result[0] = nibble_to_hex[byte / 16];
        result[1] = nibble_to_hex[byte % 16];
        return result;
    }

    // templates to avoid warnings about useless casts
    template <typename NumberType, enable_if_t<std::is_signed<NumberType>::value, int> = 0>
    bool is_negative_number(NumberType x)
    {
        return x < 0;
    }

    template < typename NumberType, enable_if_t <std::is_unsigned<NumberType>::value, int > = 0 >
    bool is_negative_number(NumberType /*unused*/)
    {
        return false;
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template < typename NumberType, detail::enable_if_t <
                   std::is_integral<NumberType>::value ||
                   std::is_same<NumberType, number_unsigned_t>::value ||
                   std::is_same<NumberType, number_integer_t>::value ||
                   std::is_same<NumberType, binary_char_t>::value,
                   int > = 0 >
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin(); // NOLINT(llvm-qualified-auto,readability-qualified-auto,cppcoreguidelines-pro-type-vararg,hicpp-vararg)

        number_unsigned_t abs_value;

        unsigned int n_chars{};

        if (is_negative_number(x))
        {
            *buffer_ptr = '-';
            abs_value = remove_sign(static_cast<number_integer_t>(x));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        JSON_ASSERT(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward,
        // so we later avoid reversing the result
        buffer_ptr += n_chars;

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (!std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        auto* begin = number_buffer.data();
        auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        JSON_ASSERT(len > 0);
        // check if buffer was large enough
        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separator
        if (thousands_sep != '\0')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::remove returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            JSON_ASSERT((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' && decimal_point != '.')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::find returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if we need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' || c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        JSON_ASSERT(byte < utf8d.size());
        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        const std::size_t index = 256u + static_cast<size_t>(state) * 16u + static_cast<size_t>(type);
        JSON_ASSERT(index < utf8d.size());
        state = utf8d[index];
        return state;
    }

    /*
     * Overload to make the compiler happy while it is instantiating
     * dump_integer for number_unsigned_t.
     * Must never be called.
     */
    number_unsigned_t remove_sign(number_unsigned_t x)
    {
        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        return x; // LCOV_EXCL_LINE
    }

    /*
     * Helper function for dump_integer
     *
     * This function takes a negative signed integer and returns its absolute
     * value as unsigned integer. The plus/minus shuffling is necessary as we can
     * not directly remove the sign of an arbitrary signed integer as the
     * absolute values of INT_MIN and INT_MAX are usually not the same. See
     * #1708 for details.
     */
    inline number_unsigned_t remove_sign(number_integer_t x) noexcept
    {
        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); // NOLINT(misc-redundant-expression)
        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/string_concat.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <cstring> // strlen
#include <string> // string
#include <utility> // forward

#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/detected.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

inline std::size_t concat_length()
{
    return 0;
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest);

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest);

template<typename... Args>
inline std::size_t concat_length(const char /*c*/, const Args& ... rest)
{
    return 1 + concat_length(rest...);
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest)
{
    // cppcheck-suppress ignoredReturnValue
    return ::strlen(cstr) + concat_length(rest...);
}

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest)
{
    return str.size() + concat_length(rest...);
}

template<typename OutStringType>
inline void concat_into(OutStringType& /*out*/)
{}

template<typename StringType, typename Arg>
using string_can_append = decltype(std::declval<StringType&>().append(std::declval < Arg && > ()));

template<typename StringType, typename Arg>
using detect_string_can_append = is_detected<string_can_append, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_op = decltype(std::declval<StringType&>() += std::declval < Arg && > ());

template<typename StringType, typename Arg>
using detect_string_can_append_op = is_detected<string_can_append_op, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_iter = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().begin(), std::declval<const Arg&>().end()));

template<typename StringType, typename Arg>
using detect_string_can_append_iter = is_detected<string_can_append_iter, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_data = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().data(), std::declval<const Arg&>().size()));

template<typename StringType, typename Arg>
using detect_string_can_append_data = is_detected<string_can_append_data, StringType, Arg>;

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template<typename OutStringType, typename Arg, typename... Args,
         enable_if_t<detect_string_can_append<OutStringType, Arg>::value, int> = 0>
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest)
{
    out.append(std::forward<Arg>(arg));
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, Arg&& arg, Args&& ... rest)
{
    out += std::forward<Arg>(arg);
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.begin(), arg.end());
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.data(), arg.size());
    concat_into(out, std::forward<Args>(rest)...);
}

template<typename OutStringType = std::string, typename... Args>
inline OutStringType concat(Args && ... args)
{
    OutStringType str;
    str.reserve(concat_length(args...));
    concat_into(str, std::forward<Args>(args)...);
    return str;
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/string_escape.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <nlohmann/detail/abi_macros.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief replace all occurrences of a substring by another string

@param[in,out] s  the string to manipulate; changed so that all
               occurrences of @a f are replaced with @a t
@param[in]     f  the substring to replace with @a t
@param[in]     t  the string to replace @a f

@pre The search string @a f must not be empty. **This precondition is
enforced with an assertion.**

@since version 2.0.0
*/
template<typename StringType>
inline void replace_substring(StringType& s, const StringType& f,
                              const StringType& t)
{
    JSON_ASSERT(!f.empty());
    for (auto pos = s.find(f);                // find first occurrence of f
            pos != StringType::npos;          // make sure f was found
            s.replace(pos, f.size(), t),      // replace with t, and
            pos = s.find(f, pos + t.size()))  // find next occurrence of f
    {}
}

/*!
 * @brief string escaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to escape
 * @return    escaped string
 *
 * Note the order of escaping "~" to "~0" and "/" to "~1" is important.
 */
template<typename StringType>
inline StringType escape(StringType s)
{
    replace_substring(s, StringType{"~"}, StringType{"~0"});
    replace_substring(s, StringType{"/"}, StringType{"~1"});
    return s;
}

/*!
 * @brief string unescaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to unescape
 * @return    unescaped string
 *
 * Note the order of escaping "~1" to "/" and "~0" to "~" is important.
 */
template<typename StringType>
static void unescape(StringType& s)
{
    replace_substring(s, StringType{"~1"}, StringType{"/"});
    replace_substring(s, StringType{"~0"}, StringType{"~"});
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/detail/value_t.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <array> // array
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

#include <nlohmann/detail/macro_scope.hpp>
#if JSON_HAS_THREE_WAY_COMPARISON
    #include <compare> // partial_ordering
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa see @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    binary,           ///< binary array (ordered collection of bytes)
    discarded         ///< discarded by the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string < binary
- furthermore, each type is not smaller than itself
- discarded values are not comparable
- binary is represented as a b"" string in python and directly comparable to a
  string; however, making a binary array directly comparable with a string would
  be surprising behavior in a JSON file.

@since version 1.0.0
*/
#if JSON_HAS_THREE_WAY_COMPARISON
    inline std::partial_ordering operator<=>(const value_t lhs, const value_t rhs) noexcept // *NOPAD*
#else
    inline bool operator<(const value_t lhs, const value_t rhs) noexcept
#endif
{
    static constexpr std::array<std::uint8_t, 9> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
            6 /* binary */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
#if JSON_HAS_THREE_WAY_COMPARISON
    if (l_index < order.size() && r_index < order.size())
    {
        return order[l_index] <=> order[r_index]; // *NOPAD*
    }
    return std::partial_ordering::unordered;
#else
    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
#endif
}

// GCC selects the built-in operator< over an operator rewritten from
// a user-defined spaceship operator
// Clang, MSVC, and ICC select the rewritten candidate
// (see GCC bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105200)
#if JSON_HAS_THREE_WAY_COMPARISON && defined(__GNUC__)
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    return std::is_lt(lhs <=> rhs); // *NOPAD*
}
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/json.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

/****************************************************************************\
 * Note on documentation: The source files contain links to the online      *
 * documentation of the public API at https://json.nlohmann.me. This URL    *
 * contains the most recent documentation and should also be applicable to  *
 * previous versions; documentation for deprecated functions is not         *
 * removed, but marked deprecated. See "Generate documentation" section in  *
 * file docs/README.md.                                                     *
\****************************************************************************/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#include <algorithm> // all_of, find, for_each
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#ifndef JSON_NO_IO
    #include <iosfwd> // istream, ostream
#endif  // JSON_NO_IO
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

#include <nlohmann/adl_serializer.hpp>
#include <nlohmann/byte_container_with_subtype.hpp>
#include <nlohmann/detail/conversions/from_json.hpp>
#include <nlohmann/detail/conversions/to_json.hpp>
#include <nlohmann/detail/exceptions.hpp>
#include <nlohmann/detail/hash.hpp>
#include <nlohmann/detail/input/binary_reader.hpp>
#include <nlohmann/detail/input/input_adapters.hpp>
#include <nlohmann/detail/input/lexer.hpp>
#include <nlohmann/detail/input/parser.hpp>
#include <nlohmann/detail/iterators/internal_iterator.hpp>
#include <nlohmann/detail/iterators/iter_impl.hpp>
#include <nlohmann/detail/iterators/iteration_proxy.hpp>
#include <nlohmann/detail/iterators/json_reverse_iterator.hpp>
#include <nlohmann/detail/iterators/primitive_iterator.hpp>
#include <nlohmann/detail/json_custom_base_class.hpp>
#include <nlohmann/detail/json_pointer.hpp>
#include <nlohmann/detail/json_ref.hpp>
#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/string_concat.hpp>
#include <nlohmann/detail/string_escape.hpp>
#include <nlohmann/detail/meta/cpp_future.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>
#include <nlohmann/detail/output/binary_writer.hpp>
#include <nlohmann/detail/output/output_adapters.hpp>
#include <nlohmann/detail/output/serializer.hpp>
#include <nlohmann/detail/value_t.hpp>
#include <nlohmann/json_fwd.hpp>
#include <nlohmann/ordered_map.hpp>

#if defined(JSON_HAS_CPP_17)
    #if JSON_HAS_STATIC_RTTI
        #include <any>
    #endif
    #include <string_view>
#endif

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief a class to store JSON values

@internal
@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@note ObjectType trick from https://stackoverflow.com/a/9860911
@endinternal

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
    : public ::nlohmann::detail::json_base_class<CustomBaseClass>
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;

    template<typename>
    friend class ::nlohmann::json_pointer;
    // can be restored when json_pointer backwards compatibility is removed
    // friend ::nlohmann::json_pointer<StringType>;

    template<typename BasicJsonType, typename InputType>
    friend class ::nlohmann::detail::parser;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename InputType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;
    friend class ::nlohmann::detail::exception;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
    using json_base_class_t = ::nlohmann::detail::json_base_class<CustomBaseClass>;

  JSON_PRIVATE_UNLESS_TESTED:
    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer_base<basic_json>;

    template<typename InputAdapterType>
    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
        InputAdapterType adapter,
        detail::parser_callback_t<basic_json>cb = nullptr,
        const bool allow_exceptions = true,
        const bool ignore_comments = false
    )
    {
        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
                std::move(cb), allow_exceptions, ignore_comments);
    }

  private:
    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    template<typename InputType>
    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

  JSON_PRIVATE_UNLESS_TESTED:
    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<StringType>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// how to treat CBOR tags
    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    using exception = detail::exception;
    using parse_error = detail::parse_error;
    using invalid_iterator = detail::invalid_iterator;
    using type_error = detail::type_error;
    using out_of_range = detail::out_of_range;
    using other_error = detail::other_error;

    /// @}

    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}

    /// @brief returns the allocator associated with the container
    /// @sa https://json.nlohmann.me/api/basic_json/get_allocator/
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /// @brief returns version information on the library
    /// @sa https://json.nlohmann.me/api/basic_json/meta/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2022 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", detail::concat(
                    std::to_string(__GNUC__), '.',
                    std::to_string(__GNUC_MINOR__), '.',
                    std::to_string(__GNUC_PATCHLEVEL__))
            }
        };
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#if defined(_MSVC_LANG)
        result["compiler"]["c++"] = std::to_string(_MSVC_LANG);
#elif defined(__cplusplus)
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }

    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

    /// @brief default object key comparator type
    /// The actual object key comparator type (@ref object_comparator_t) may be
    /// different.
    /// @sa https://json.nlohmann.me/api/basic_json/default_object_comparator_t/
#if defined(JSON_HAS_CPP_14)
    // use of transparent comparator avoids unnecessary repeated construction of temporaries
    // in functions involving lookup by key with types other than object_t::key_type (aka. StringType)
    using default_object_comparator_t = std::less<>;
#else
    using default_object_comparator_t = std::less<StringType>;
#endif

    /// @brief a type for an object
    /// @sa https://json.nlohmann.me/api/basic_json/object_t/
    using object_t = ObjectType<StringType,
          basic_json,
          default_object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /// @brief a type for an array
    /// @sa https://json.nlohmann.me/api/basic_json/array_t/
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /// @brief a type for a string
    /// @sa https://json.nlohmann.me/api/basic_json/string_t/
    using string_t = StringType;

    /// @brief a type for a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/boolean_t/
    using boolean_t = BooleanType;

    /// @brief a type for a number (integer)
    /// @sa https://json.nlohmann.me/api/basic_json/number_integer_t/
    using number_integer_t = NumberIntegerType;

    /// @brief a type for a number (unsigned)
    /// @sa https://json.nlohmann.me/api/basic_json/number_unsigned_t/
    using number_unsigned_t = NumberUnsignedType;

    /// @brief a type for a number (floating-point)
    /// @sa https://json.nlohmann.me/api/basic_json/number_float_t/
    using number_float_t = NumberFloatType;

    /// @brief a type for a packed binary type
    /// @sa https://json.nlohmann.me/api/basic_json/binary_t/
    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;

    /// @brief object key comparator type
    /// @sa https://json.nlohmann.me/api/basic_json/object_comparator_t/
    using object_comparator_t = detail::actual_object_comparator_t<basic_json>;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * obj)
        {
            AllocatorTraits::deallocate(alloc, obj, 1);
        };
        std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
        JSON_ASSERT(obj != nullptr);
        return obj.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    binary    | binary          | pointer to @ref binary_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// binary (stored with pointer to save storage)
        binary_t* binary;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::binary:
                {
                    binary = create<binary_t>();
                    break;
                }

                case value_t::boolean:
                {
                    boolean = static_cast<boolean_t>(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = static_cast<number_integer_t>(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = static_cast<number_unsigned_t>(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = static_cast<number_float_t>(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                case value_t::discarded:
                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.2", nullptr)); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value) : string(create<string_t>(value)) {}

        /// constructor for rvalue strings
        json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}

        /// constructor for objects
        json_value(const object_t& value) : object(create<object_t>(value)) {}

        /// constructor for rvalue objects
        json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}

        /// constructor for arrays
        json_value(const array_t& value) : array(create<array_t>(value)) {}

        /// constructor for rvalue arrays
        json_value(array_t&& value) : array(create<array_t>(std::move(value))) {}

        /// constructor for binary arrays
        json_value(const typename binary_t::container_type& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays
        json_value(typename binary_t::container_type&& value) : binary(create<binary_t>(std::move(value))) {}

        /// constructor for binary arrays (internal type)
        json_value(const binary_t& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays (internal type)
        json_value(binary_t&& value) : binary(create<binary_t>(std::move(value))) {}

        void destroy(value_t t)
        {
            if (
                (t == value_t::object && object == nullptr) ||
                (t == value_t::array && array == nullptr) ||
                (t == value_t::string && string == nullptr) ||
                (t == value_t::binary && binary == nullptr)
            )
            {
                //not initialized (e.g. due to exception in the ctor)
                return;
            }
            if (t == value_t::array || t == value_t::object)
            {
                // flatten the current json_value to a heap-allocated stack
                std::vector<basic_json> stack;

                // move the top-level items to stack
                if (t == value_t::array)
                {
                    stack.reserve(array->size());
                    std::move(array->begin(), array->end(), std::back_inserter(stack));
                }
                else
                {
                    stack.reserve(object->size());
                    for (auto&& it : *object)
                    {
                        stack.push_back(std::move(it.second));
                    }
                }

                while (!stack.empty())
                {
                    // move the last item to local variable to be processed
                    basic_json current_item(std::move(stack.back()));
                    stack.pop_back();

                    // if current_item is array/object, move
                    // its children to the stack to be processed later
                    if (current_item.is_array())
                    {
                        std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));

                        current_item.m_data.m_value.array->clear();
                    }
                    else if (current_item.is_object())
                    {
                        for (auto&& it : *current_item.m_data.m_value.object)
                        {
                            stack.push_back(std::move(it.second));
                        }

                        current_item.m_data.m_value.object->clear();
                    }

                    // it's now safe that current_item get destructed
                    // since it doesn't have any children
                }
            }

            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                case value_t::binary:
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
                    break;
                }

                case value_t::null:
                case value_t::boolean:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                case value_t::discarded:
                default:
                {
                    break;
                }
            }
        }
    };

  private:
    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.

    Furthermore, the parent relation is checked for arrays and objects: If
    @a check_parents true and the value is an array or object, then the
    container's elements must have the current value as parent.

    @param[in] check_parents  whether the parent relation should be checked.
               The value is true by default and should only be set to false
               during destruction of objects when the invariant does not
               need to hold.
    */
    void assert_invariant(bool check_parents = true) const noexcept
    {
        JSON_ASSERT(m_data.m_type != value_t::object || m_data.m_value.object != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::array || m_data.m_value.array != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::string || m_data.m_value.string != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::binary || m_data.m_value.binary != nullptr);

#if JSON_DIAGNOSTICS
        JSON_TRY
        {
            // cppcheck-suppress assertWithSideEffect
            JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
            {
                return j.m_parent == this;
            }));
        }
        JSON_CATCH(...) {} // LCOV_EXCL_LINE
#endif
        static_cast<void>(check_parents);
    }

    void set_parents()
    {
#if JSON_DIAGNOSTICS
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                for (auto& element : *m_data.m_value.array)
                {
                    element.m_parent = this;
                }
                break;
            }

            case value_t::object:
            {
                for (auto& element : *m_data.m_value.object)
                {
                    element.second.m_parent = this;
                }
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }
#endif
    }

    iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
    {
#if JSON_DIAGNOSTICS
        for (typename iterator::difference_type i = 0; i < count_set_parents; ++i)
        {
            (it + i)->m_parent = this;
        }
#else
        static_cast<void>(count_set_parents);
#endif
        return it;
    }

    reference set_parent(reference j, std::size_t old_capacity = static_cast<std::size_t>(-1))
    {
#if JSON_DIAGNOSTICS
        if (old_capacity != static_cast<std::size_t>(-1))
        {
            // see https://github.com/nlohmann/json/issues/2838
            JSON_ASSERT(type() == value_t::array);
            if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
            {
                // capacity has changed: update all parents
                set_parents();
                return j;
            }
        }

        // ordered_json uses a vector internally, so pointers could have
        // been invalidated; see https://github.com/nlohmann/json/issues/2962
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning(push )
#pragma warning(disable : 4127) // ignore warning to replace if with if constexpr
#endif
        if (detail::is_ordered_map<object_t>::value)
        {
            set_parents();
            return j;
        }
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning( pop )
#endif

        j.m_parent = this;
#else
        static_cast<void>(j);
        static_cast<void>(old_capacity);
#endif
        return j;
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /// @brief parser event types
    /// @sa https://json.nlohmann.me/api/basic_json/parse_event_t/
    using parse_event_t = detail::parse_event_t;

    /// @brief per-element parser callback type
    /// @sa https://json.nlohmann.me/api/basic_json/parser_callback_t/
    using parser_callback_t = detail::parser_callback_t<basic_json>;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /// @brief create an empty value with a given type
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const value_t v)
        : m_data(v)
    {
        assert_invariant();
    }

    /// @brief create a null object
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(std::nullptr_t = nullptr) noexcept // NOLINT(bugprone-exception-escape)
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /// @brief create a JSON value from compatible types
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename CompatibleType,
               typename U = detail::uncvref_t<CompatibleType>,
               detail::enable_if_t <
                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
    basic_json(CompatibleType && val) noexcept(noexcept( // NOLINT(bugprone-forwarding-reference-overload,bugprone-exception-escape)
                JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                           std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        set_parents();
        assert_invariant();
    }

    /// @brief create a JSON value from an existing one
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
    basic_json(const BasicJsonType& val)
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;
        using other_binary_t = typename BasicJsonType::binary_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::binary:
                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_data.m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
        JSON_ASSERT(m_data.m_type == val.type());
        set_parents();
        assert_invariant();
    }

    /// @brief create a container (array or object) from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            // The cast is to ensure op[size_type] is called, bearing in mind size_type may not be int;
            // (many string types can be constructed from 0 via its null-pointer guise, so we get a
            // broken call to op[key_type], the wrong semantics and a 4804 warning on Windows)
            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[static_cast<size_type>(0)].is_string();
        });

        // adjust type if type deduction is not wanted
        if (!type_deduction)
        {
            // if array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list", nullptr));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create object
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;

            for (auto& element_ref : init)
            {
                auto element = element_ref.moved_or_copied();
                m_data.m_value.object->emplace(
                    std::move(*((*element.m_data.m_value.array)[0].m_data.m_value.string)),
                    std::move((*element.m_data.m_value.array)[1]));
            }
        }
        else
        {
            // the initializer list describes an array -> create array
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>(init.begin(), init.end());
        }

        set_parents();
        assert_invariant();
    }

    /// @brief explicitly create a binary array (without subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = init;
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(init, subtype);
        return res;
    }

    /// @brief explicitly create a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = std::move(init);
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(std::move(init), subtype);
        return res;
    }

    /// @brief explicitly create an array from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/array/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /// @brief explicitly create an object from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/object/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /// @brief construct an array with count copies of given value
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(size_type cnt, const basic_json& val):
        m_data{cnt, val}
    {
        set_parents();
        assert_invariant();
    }

    /// @brief construct a JSON container given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < class InputIT, typename std::enable_if <
                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
    basic_json(InputIT first, InputIT last)
    {
        JSON_ASSERT(first.m_object != nullptr);
        JSON_ASSERT(last.m_object != nullptr);

        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", nullptr));
        }

        // copy type from first iterator
        m_data.m_type = first.m_object->m_data.m_type;

        // check if iterator range is complete for primitive values
        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
                                         || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", first.m_object));
                }
                break;
            }

            case value_t::null:
            case value_t::object:
            case value_t::array:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }

        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = first.m_object->m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = first.m_object->m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = first.m_object->m_data.m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = first.m_object->m_data.m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *first.m_object->m_data.m_value.string;
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object = create<object_t>(first.m_it.object_iterator,
                                        last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array = create<array_t>(first.m_it.array_iterator,
                                                       last.m_it.array_iterator);
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *first.m_object->m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(invalid_iterator::create(206, detail::concat("cannot construct with iterators from ", first.m_object->type_name()), first.m_object));
        }

        set_parents();
        assert_invariant();
    }

    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    template<typename JsonRef,
             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}

    /// @brief copy constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const basic_json& other)
        : json_base_class_t(other)
    {
        m_data.m_type = other.m_data.m_type;
        // check of passed value is valid
        other.assert_invariant();

        switch (m_data.m_type)
        {
            case value_t::object:
            {
                m_data.m_value = *other.m_data.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_data.m_value = *other.m_data.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *other.m_data.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value = other.m_data.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_data.m_value = other.m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value = other.m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value = other.m_data.m_value.number_float;
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *other.m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }

        set_parents();
        assert_invariant();
    }

    /// @brief move constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(basic_json&& other) noexcept
        : json_base_class_t(std::forward<json_base_class_t>(other)),
          m_data(std::move(other.m_data))
    {
        // check that passed value is valid
        other.assert_invariant(false);

        // invalidate payload
        other.m_data.m_type = value_t::null;
        other.m_data.m_value = {};

        set_parents();
        assert_invariant();
    }

    /// @brief copy assignment
    /// @sa https://json.nlohmann.me/api/basic_json/operator=/
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value&&
        std::is_nothrow_move_assignable<json_base_class_t>::value
    )
    {
        // check that passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_data.m_type, other.m_data.m_type);
        swap(m_data.m_value, other.m_data.m_value);
        json_base_class_t::operator=(std::move(other));

        set_parents();
        assert_invariant();
        return *this;
    }

    /// @brief destructor
    /// @sa https://json.nlohmann.me/api/basic_json/~basic_json/
    ~basic_json() noexcept
    {
        assert_invariant(false);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /// @brief serialization
    /// @sa https://json.nlohmann.me/api/basic_json/dump/
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /// @brief return the type of the JSON value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/type/
    constexpr value_t type() const noexcept
    {
        return m_data.m_type;
    }

    /// @brief return whether type is primitive
    /// @sa https://json.nlohmann.me/api/basic_json/is_primitive/
    constexpr bool is_primitive() const noexcept
    {
        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
    }

    /// @brief return whether type is structured
    /// @sa https://json.nlohmann.me/api/basic_json/is_structured/
    constexpr bool is_structured() const noexcept
    {
        return is_array() || is_object();
    }

    /// @brief return whether value is null
    /// @sa https://json.nlohmann.me/api/basic_json/is_null/
    constexpr bool is_null() const noexcept
    {
        return m_data.m_type == value_t::null;
    }

    /// @brief return whether value is a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/is_boolean/
    constexpr bool is_boolean() const noexcept
    {
        return m_data.m_type == value_t::boolean;
    }

    /// @brief return whether value is a number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number/
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() || is_number_float();
    }

    /// @brief return whether value is an integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_integer/
    constexpr bool is_number_integer() const noexcept
    {
        return m_data.m_type == value_t::number_integer || m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is an unsigned integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_unsigned/
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is a floating-point number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_float/
    constexpr bool is_number_float() const noexcept
    {
        return m_data.m_type == value_t::number_float;
    }

    /// @brief return whether value is an object
    /// @sa https://json.nlohmann.me/api/basic_json/is_object/
    constexpr bool is_object() const noexcept
    {
        return m_data.m_type == value_t::object;
    }

    /// @brief return whether value is an array
    /// @sa https://json.nlohmann.me/api/basic_json/is_array/
    constexpr bool is_array() const noexcept
    {
        return m_data.m_type == value_t::array;
    }

    /// @brief return whether value is a string
    /// @sa https://json.nlohmann.me/api/basic_json/is_string/
    constexpr bool is_string() const noexcept
    {
        return m_data.m_type == value_t::string;
    }

    /// @brief return whether value is a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/is_binary/
    constexpr bool is_binary() const noexcept
    {
        return m_data.m_type == value_t::binary;
    }

    /// @brief return whether value is discarded
    /// @sa https://json.nlohmann.me/api/basic_json/is_discarded/
    constexpr bool is_discarded() const noexcept
    {
        return m_data.m_type == value_t::discarded;
    }

    /// @brief return the type of the JSON value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/operator_value_t/
    constexpr operator value_t() const noexcept
    {
        return m_data.m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_data.m_value.boolean;
        }

        JSON_THROW(type_error::create(302, detail::concat("type must be boolean, but is ", type_name()), this));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return is_number_integer() ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return is_number_integer() ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (binary)
    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /// get a pointer to the value (binary)
    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, detail::concat("incompatible ReferenceType for get_ref, actual type is ", obj.type_name()), &obj));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template < typename PointerType, typename std::enable_if <
                   std::is_pointer<PointerType>::value&&
                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

  private:
    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::is_default_constructible<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<0> /*unused*/) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        auto ret = ValueType();
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueType>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<1> /*unused*/) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
    {
        return JSONSerializer<ValueType>::from_json(*this);
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @a BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value,
                   int > = 0 >
    BasicJsonType get_impl(detail::priority_tag<2> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType,
             detail::enable_if_t<
                 std::is_same<BasicJsonType, basic_json_t>::value,
                 int> = 0>
    basic_json get_impl(detail::priority_tag<3> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType,
             detail::enable_if_t<
                 std::is_pointer<PointerType>::value,
                 int> = 0>
    constexpr auto get_impl(detail::priority_tag<4> /*unused*/) const noexcept
    -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

  public:
    /*!
    @brief get a (pointer) value (explicit)

    Performs explicit type conversion between the JSON value and a compatible value if required.

    - If the requested type is a pointer to the internally stored JSON value that pointer is returned.
    No copies are made.

    - If the requested type is the current @ref basic_json, or a different @ref basic_json convertible
    from the current @ref basic_json.

    - Otherwise the value is converted by calling the @ref json_serializer<ValueType> `from_json()`
    method.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @tparam ValueType if necessary

    @throw what @ref json_serializer<ValueType> `from_json()` method throws if conversion is required

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
#if defined(JSON_HAS_CPP_14)
    constexpr
#endif
    auto get() const noexcept(
    noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
    -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return get_impl<ValueType>(detail::priority_tag<4> {});
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa see @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /// @brief get a value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_to/
    template < typename ValueType,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
                JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    // specialization to allow calling get_to with a basic_json value
    // see https://github.com/nlohmann/json/issues/2175
    template<typename ValueType,
             detail::enable_if_t <
                 detail::is_basic_json<ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const
    {
        v = *this;
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N], // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template < typename ReferenceType, typename std::enable_if <
                   std::is_reference<ReferenceType>::value&&
                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   detail::conjunction <
                       detail::negation<std::is_pointer<ValueType>>,
                       detail::negation<std::is_same<ValueType, std::nullptr_t>>,
                       detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
                                        detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
                                        detail::negation<detail::is_basic_json<ValueType>>,
                                        detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
                                                detail::negation<std::is_same<ValueType, std::string_view>>,
#endif
#if defined(JSON_HAS_CPP_17) && JSON_HAS_STATIC_RTTI
                                                detail::negation<std::is_same<ValueType, std::any>>,
#endif
                                                detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
                                                >::value, int >::type = 0 >
                                        JSON_EXPLICIT operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    binary_t& get_binary()
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<binary_t*>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    const binary_t& get_binary() const
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<const binary_t*>();
    }

    /// @}

    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return set_parent(m_data.m_value.array->at(idx));
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_data.m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            }
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    reference at(KeyType && key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_reference at(KeyType && key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](size_type idx)
    {
        // implicitly convert null value to an empty array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up array with null values if given idx is outside range
            if (idx >= m_data.m_value.array->size())
            {
#if JSON_DIAGNOSTICS
                // remember array size & capacity before resizing
                const auto old_size = m_data.m_value.array->size();
                const auto old_capacity = m_data.m_value.array->capacity();
#endif
                m_data.m_value.array->resize(idx + 1);

#if JSON_DIAGNOSTICS
                if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
                {
                    // capacity has changed: update all parents
                    set_parents();
                }
                else
                {
                    // set parent for values added above
                    set_parents(begin() + static_cast<typename iterator::difference_type>(old_size), static_cast<typename iterator::difference_type>(idx + 1 - old_size));
                }
#endif
                assert_invariant();
            }

            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](typename object_t::key_type key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::move(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(key);
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    // these two functions resolve a (const) char * ambiguity affecting Clang and MSVC
    // (they seemingly cannot be constrained to resolve the ambiguity)
    template<typename T>
    reference operator[](T* key)
    {
        return operator[](typename object_t::key_type(key));
    }

    template<typename T>
    const_reference operator[](T* key) const
    {
        return operator[](typename object_t::key_type(key));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    reference operator[](KeyType && key)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::forward<KeyType>(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    const_reference operator[](KeyType && key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

  private:
    template<typename KeyType>
    using is_comparable_with_object_key = detail::is_comparable <
        object_comparator_t, const typename object_t::key_type&, KeyType >;

    template<typename ValueType>
    using value_return_type = std::conditional <
        detail::is_c_string_uncvref<ValueType>::value,
        string_t, typename std::decay<ValueType>::type >;

  public:
    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const typename object_t::key_type& key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(KeyType && key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(KeyType && key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if key is found, return value and given default value otherwise
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ValueType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const json_pointer& ptr, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // if pointer resolves a value, return it or use default value
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ReturnType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return std::forward<ValueType>(default_value);
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    template < class ValueType, class BasicJsonType, detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ValueType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, const ValueType& default_value) const
    {
        return value(ptr.convert(), default_value);
    }

    template < class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ReturnType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, ValueType && default_value) const
    {
        return value(ptr.convert(), std::forward<ValueType>(default_value));
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    reference front()
    {
        return *begin();
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    const_reference front() const
    {
        return *cbegin();
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /// @brief remove element given an iterator
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType pos)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

    /// @brief remove elements given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType first, IteratorType last)
    {
        // make sure iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
                                       || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

  private:
    template < typename KeyType, detail::enable_if_t <
                   detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return m_data.m_value.object->erase(std::forward<KeyType>(key));
    }

    template < typename KeyType, detail::enable_if_t <
                   !detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        const auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it != m_data.m_value.object->end())
        {
            m_data.m_value.object->erase(it);
            return 1;
        }
        return 0;
    }

  public:

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    size_type erase(const typename object_t::key_type& key)
    {
        // the indirection via erase_internal() is added to avoid making this
        // function a template and thus de-rank it during overload resolution
        return erase_internal(key);
    }

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type erase(KeyType && key)
    {
        return erase_internal(std::forward<KeyType>(key));
    }

    /// @brief remove element from a JSON array given an index
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            }

            m_data.m_value.array->erase(m_data.m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }
    }

    /// @}

    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    iterator find(const typename object_t::key_type& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    const_iterator find(const typename object_t::key_type& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    iterator find(KeyType && key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_iterator find(KeyType && key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    size_type count(const typename object_t::key_type& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(key) : 0;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(std::forward<KeyType>(key)) : 0;
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const typename object_t::key_type& key) const
    {
        return is_object() && m_data.m_value.object->find(key) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    bool contains(KeyType && key) const
    {
        return is_object() && m_data.m_value.object->find(std::forward<KeyType>(key)) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object given a JSON pointer
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    bool contains(const typename ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}

    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /// @brief returns a const iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/cbegin/
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    const_iterator end() const noexcept
    {
        return cend();
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/cend/
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /// @brief returns a const reverse iterator to the last element
    /// @sa https://json.nlohmann.me/api/basic_json/crbegin/
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /// @brief returns a const reverse iterator to one before the first
    /// @sa https://json.nlohmann.me/api/basic_json/crend/
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///             version 4.0.0 of the library. Please use @ref items() instead;
    ///             that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///         version 4.0.0 of the library. Please use @ref items() instead;
    ///         that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}

    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /// @brief checks whether the container is empty.
    /// @sa https://json.nlohmann.me/api/basic_json/empty/
    bool empty() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_data.m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_data.m_value.object->empty();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /// @brief returns the number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/size/
    size_type size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_data.m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_data.m_value.object->size();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /// @brief returns the maximum possible number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/max_size/
    size_type max_size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_data.m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_data.m_value.object->max_size();
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}

    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /// @brief clears the contents
    /// @sa https://json.nlohmann.me/api/basic_json/clear/
    void clear() noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_data.m_value.string->clear();
                break;
            }

            case value_t::binary:
            {
                m_data.m_value.binary->clear();
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object->clear();
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (move semantics)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(std::move(val));
        set_parent(m_data.m_value.array->back(), old_capacity);
        // if val is moved from, basic_json move constructor marks it null, so we do not call the destructor
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add element to array
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(val);
        set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add element to object
        auto res = m_data.m_value.object->insert(val);
        set_parent(res.first->second);
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(initializer_list_t init)
    {
        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/emplace_back/
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace_back() with ", type_name()), this));
        }

        // transform null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->emplace_back(std::forward<Args>(args)...);
        return set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an object if key does not exist
    /// @sa https://json.nlohmann.me/api/basic_json/emplace/
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace() with ", type_name()), this));
        }

        // transform null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add element to array (perfect forwarding)
        auto res = m_data.m_value.object->emplace(std::forward<Args>(args)...);
        set_parent(res.first->second);

        // create result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args)
    {
        iterator result(this);
        JSON_ASSERT(m_data.m_value.array != nullptr);

        auto insert_pos = std::distance(m_data.m_value.array->begin(), pos.m_it.array_iterator);
        m_data.m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_data.m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_data.m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        set_parents();
        return result;
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, basic_json&& val)
    {
        return insert(pos, val);
    }

    /// @brief inserts copies of element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts range of elements into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const_iterator first, const_iterator last)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /// @brief inserts elements from initializer list into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, initializer_list_t ilist)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /// @brief inserts range of elements into object
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    void insert(const_iterator first, const_iterator last)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", this));
        }

        m_data.m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_reference j, bool merge_objects = false)
    {
        update(j.begin(), j.end(), merge_objects);
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_iterator first, const_iterator last, bool merge_objects = false)
    {
        // implicitly convert null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", first.m_object->type_name()), first.m_object));
        }

        for (auto it = first; it != last; ++it)
        {
            if (merge_objects && it.value().is_object())
            {
                auto it2 = m_data.m_value.object->find(it.key());
                if (it2 != m_data.m_value.object->end())
                {
                    it2->second.update(it.value(), true);
                    continue;
                }
            }
            m_data.m_value.object->operator[](it.key()) = it.value();
#if JSON_DIAGNOSTICS
            m_data.m_value.object->operator[](it.key()).m_parent = this;
#endif
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_data.m_type, other.m_data.m_type);
        std::swap(m_data.m_value, other.m_data.m_value);

        set_parents();
        other.set_parents();
        assert_invariant();
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    friend void swap(reference left, reference right) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        left.swap(right);
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(array_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            using std::swap;
            swap(*(m_data.m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(array_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(object_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            using std::swap;
            swap(*(m_data.m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(object_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(string_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            using std::swap;
            swap(*(m_data.m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(string_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(binary_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(typename binary_t::container_type& other) // NOLINT(bugprone-exception-escape)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t::container_type&) with ", type_name()), this));
        }
    }

    /// @}

    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    // note parentheses around operands are necessary; see
    // https://github.com/nlohmann/json/issues/1530
#define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
    const auto lhs_type = lhs.type();                                                                    \
    const auto rhs_type = rhs.type();                                                                    \
    \
    if (lhs_type == rhs_type) /* NOLINT(readability/braces) */                                           \
    {                                                                                                    \
        switch (lhs_type)                                                                                \
        {                                                                                                \
            case value_t::array:                                                                         \
                return (*lhs.m_data.m_value.array) op (*rhs.m_data.m_value.array);                                     \
                \
            case value_t::object:                                                                        \
                return (*lhs.m_data.m_value.object) op (*rhs.m_data.m_value.object);                                   \
                \
            case value_t::null:                                                                          \
                return (null_result);                                                                    \
                \
            case value_t::string:                                                                        \
                return (*lhs.m_data.m_value.string) op (*rhs.m_data.m_value.string);                                   \
                \
            case value_t::boolean:                                                                       \
                return (lhs.m_data.m_value.boolean) op (rhs.m_data.m_value.boolean);                                   \
                \
            case value_t::number_integer:                                                                \
                return (lhs.m_data.m_value.number_integer) op (rhs.m_data.m_value.number_integer);                     \
                \
            case value_t::number_unsigned:                                                               \
                return (lhs.m_data.m_value.number_unsigned) op (rhs.m_data.m_value.number_unsigned);                   \
                \
            case value_t::number_float:                                                                  \
                return (lhs.m_data.m_value.number_float) op (rhs.m_data.m_value.number_float);                         \
                \
            case value_t::binary:                                                                        \
                return (*lhs.m_data.m_value.binary) op (*rhs.m_data.m_value.binary);                                   \
                \
            case value_t::discarded:                                                                     \
            default:                                                                                     \
                return (unordered_result);                                                               \
        }                                                                                                \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)                   \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_integer) op rhs.m_data.m_value.number_float;      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)                   \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_integer);      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)                  \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_float;     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)                  \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_unsigned);     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)                \
    {                                                                                                    \
        return static_cast<number_integer_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_integer; \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)                \
    {                                                                                                    \
        return lhs.m_data.m_value.number_integer op static_cast<number_integer_t>(rhs.m_data.m_value.number_unsigned); \
    }                                                                                                    \
    else if(compares_unordered(lhs, rhs))\
    {\
        return (unordered_result);\
    }\
    \
    return (default_result);

  JSON_PRIVATE_UNLESS_TESTED:
    // returns true if:
    // - any operand is NaN and the other operand is of number type
    // - any operand is discarded
    // in legacy mode, discarded values are considered ordered if
    // an operation is computed as an odd number of inverses of others
    static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
    {
        if ((lhs.is_number_float() && std::isnan(lhs.m_data.m_value.number_float) && rhs.is_number())
                || (rhs.is_number_float() && std::isnan(rhs.m_data.m_value.number_float) && lhs.is_number()))
        {
            return true;
        }
#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
        return (lhs.is_discarded() || rhs.is_discarded()) && !inverse;
#else
        static_cast<void>(inverse);
        return lhs.is_discarded() || rhs.is_discarded();
#endif
    }

  private:
    bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
    {
        return compares_unordered(*this, rhs, inverse);
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    bool operator==(const_reference rhs) const noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        const_reference lhs = *this;
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator==(ScalarType rhs) const noexcept
    {
        return *this == basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    bool operator!=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !operator==(rhs);
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    std::partial_ordering operator<=>(const_reference rhs) const noexcept // *NOPAD*
    {
        const_reference lhs = *this;
        // default_result is used if we cannot compare values. In that case,
        // we compare types.
        JSON_IMPLEMENT_OPERATOR(<=>, // *NOPAD*
                                std::partial_ordering::equivalent,
                                std::partial_ordering::unordered,
                                lhs_type <=> rhs_type) // *NOPAD*
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    std::partial_ordering operator<=>(ScalarType rhs) const noexcept // *NOPAD*
    {
        return *this <=> basic_json(rhs); // *NOPAD*
    }

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    // all operators that are computed as an odd number of inverses of others
    // need to be overloaded to emulate the legacy comparison behavior

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator<=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(rhs < *this);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator<=(ScalarType rhs) const noexcept
    {
        return *this <= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator>=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(*this < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator>=(ScalarType rhs) const noexcept
    {
        return *this >= basic_json(rhs);
    }
#endif
#else
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs == rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        // default_result is used if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        JSON_IMPLEMENT_OPERATOR( <, false, false, operator<(lhs_type, rhs_type))
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(rhs < lhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        // double inverse
        if (compares_unordered(lhs, rhs))
        {
            return false;
        }
        return !(lhs <= rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }
#endif

#undef JSON_IMPLEMENT_OPERATOR

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{
#ifndef JSON_NO_IO
    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    /// @deprecated This function is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator<<(std::ostream&, const basic_json&) instead; that is,
    ///             replace calls like `j >> o;` with `o << j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }
#endif  // JSON_NO_IO
    /// @}

    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /// @brief deserialize from a compatible input
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(InputType&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /// @brief deserialize from a pair of character iterators
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(IteratorType first,
                            IteratorType last,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
    static basic_json parse(detail::span_input_adapter&& i,
                            const parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(i.get(), cb, allow_exceptions, ignore_comments).parse(true, result);
        return result;
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename InputType>
    static bool accept(InputType&& i,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename IteratorType>
    static bool accept(IteratorType first, IteratorType last,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
    static bool accept(detail::span_input_adapter&& i,
                       const bool ignore_comments = false)
    {
        return parser(i.get(), nullptr, false, ignore_comments).accept(true);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template <typename InputType, typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(InputType&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template<class IteratorType, class SAX>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    /// @deprecated This function is deprecated since 3.8.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             sax_parse(ptr, ptr + len) instead.
    template <typename SAX>
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = i.get();
        return format == input_format_t::json
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }
#ifndef JSON_NO_IO
    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    /// @deprecated This stream operator is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator>>(std::istream&, basic_json&) instead; that is,
    ///             replace calls like `j << i;` with `i >> j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }
#endif  // JSON_NO_IO
    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /// @brief return the type as string
    /// @sa https://json.nlohmann.me/api/basic_json/type_name/
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
                return "null";
            case value_t::object:
                return "object";
            case value_t::array:
                return "array";
            case value_t::string:
                return "string";
            case value_t::boolean:
                return "boolean";
            case value_t::binary:
                return "binary";
            case value_t::discarded:
                return "discarded";
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            default:
                return "number";
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    //////////////////////
    // member variables //
    //////////////////////

    struct data
    {
        /// the type of the current element
        value_t m_type = value_t::null;

        /// the value of the current element
        json_value m_value = {};

        data(const value_t v)
            : m_type(v), m_value(v)
        {
        }

        data(size_type cnt, const basic_json& val)
            : m_type(value_t::array)
        {
            m_value.array = create<array_t>(cnt, val);
        }

        data() noexcept = default;
        data(data&&) noexcept = default;
        data(const data&) noexcept = delete;
        data& operator=(data&&) noexcept = delete;
        data& operator=(const data&) noexcept = delete;

        ~data() noexcept
        {
            m_value.destroy(m_type);
        }
    };

    data m_data = {};

#if JSON_DIAGNOSTICS
    /// a pointer to a parent value (for debugging purposes)
    basic_json* m_parent = nullptr;
#endif

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static std::vector<std::uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_cbor(j);
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_msgpack(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false)
    {
        std::vector<std::uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static std::vector<std::uint8_t> to_bjdata(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false)
    {
        std::vector<std::uint8_t> result;
        to_bjdata(j, result, use_size, use_type);
        return result;
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type, true, true);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type, true, true);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static std::vector<std::uint8_t> to_bson(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_bson(j);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(InputType&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(IteratorType first, IteratorType last,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(const T* ptr, std::size_t len,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(detail::span_input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(const T* ptr, std::size_t len,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(detail::span_input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        return from_bson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
        auto ia = i.get();
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict);
        return res ? result : basic_json(value_t::discarded);
    }
    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_checked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_checked(this);
    }

    /// @brief return flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/flatten/
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /// @brief unflatten a previously flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/unflatten/
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /// @brief applies a JSON patch in-place without copying the object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    void patch_inplace(const basic_json& json_patch)
    {
        basic_json& result = *this;
        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const std::string & op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, basic_json val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer const top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            // parent must exist when performing patch add per RFC6902 specs
            basic_json& parent = result.at(ptr);

            switch (parent.m_data.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::template array_index<basic_json_t>(last_path);
                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), &parent));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent it cannot be primitive
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [this, & result](json_pointer & ptr)
        {
            // get reference to parent of JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, detail::concat("key '", last_path, "' not found"), this));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(json_pointer::template array_index<basic_json_t>(last_path));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &json_patch));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const std::string & op,
                                          const std::string & member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_data.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : detail::concat("operation '", op, '\'');

                // check if desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_data.m_value.object->end()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have member '", member, "'"), &val));
                }

                // check if result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have string member '", member, "'"), &val));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &val));
            }

            // collect mandatory members
            const auto op = get_value("op", "op", true).template get<std::string>();
            const auto path = get_value(op, "path", true).template get<std::string>();
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const auto from_path = get_value("move", "from", true).template get<std::string>();
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const auto from_path = get_value("copy", "from", true).template get<std::string>();
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if test fails
                    if (JSON_HEDLEY_UNLIKELY(!success))
                    {
                        JSON_THROW(other_error::create(501, detail::concat("unsuccessful: ", val.dump()), &val));
                    }

                    break;
                }

                case patch_operations::invalid:
                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, detail::concat("operation value '", op, "' is invalid"), &val));
                }
            }
        }
    }

    /// @brief applies a JSON patch to a copy of the current object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    basic_json patch(const basic_json& json_patch) const
    {
        basic_json result = *this;
        result.patch_inplace(json_patch);
        return result;
    }

    /// @brief creates a diff as a JSON patch
    /// @sa https://json.nlohmann.me/api/basic_json/diff/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const std::string& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() && i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], detail::concat(path, '/', std::to_string(i)));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // We now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", detail::concat(path, '/', std::to_string(i))}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", detail::concat(path, "/-")},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto path_key = detail::concat(path, '/', detail::escape(it.key()));

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path_key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path_key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto path_key = detail::concat(path, '/', detail::escape(it.key()));
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path_key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // both primitive type: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }
    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /// @brief applies a JSON Merge Patch
    /// @sa https://json.nlohmann.me/api/basic_json/merge_patch/
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (!is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/// @brief user-defined to_string function for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/to_string/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}

inline namespace literals
{
inline namespace json_literals
{

/// @brief user-defined string literal for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json operator ""_json(const char* s, std::size_t n)
#else
    inline nlohmann::json operator "" _json(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::parse(s, s + n);
}

/// @brief user-defined string literal for JSON pointer
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json_pointer/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json::json_pointer operator ""_json_pointer(const char* s, std::size_t n)
#else
    inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

}  // namespace json_literals
}  // namespace literals
NLOHMANN_JSON_NAMESPACE_END

///////////////////////
// nonmember support //
///////////////////////

namespace std // NOLINT(cert-dcl58-cpp)
{

/// @brief hash value for JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_hash/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct hash<nlohmann::NLOHMANN_BASIC_JSON_TPL> // NOLINT(cert-dcl58-cpp)
{
    std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL& j) const
    {
        return nlohmann::detail::hash(j);
    }
};

// specialization for std::less<value_t>
template<>
struct less< ::nlohmann::detail::value_t> // do not remove the space after '<', see https://github.com/nlohmann/json/pull/679
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(::nlohmann::detail::value_t lhs,
                    ::nlohmann::detail::value_t rhs) const noexcept
    {
#if JSON_HAS_THREE_WAY_COMPARISON
        return std::is_lt(lhs <=> rhs); // *NOPAD*
#else
        return ::nlohmann::detail::operator<(lhs, rhs);
#endif
    }
};

// C++20 prohibit function specialization in the std namespace.
#ifndef JSON_HAS_CPP_20

/// @brief exchanges the values of two JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_swap/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL& j1, nlohmann::NLOHMANN_BASIC_JSON_TPL& j2) noexcept(  // NOLINT(readability-inconsistent-declaration-parameter-name, cert-dcl58-cpp)
    is_nothrow_move_constructible<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value&&                          // NOLINT(misc-redundant-expression,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    is_nothrow_move_assignable<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value)
{
    j1.swap(j2);
}

#endif

}  // namespace std

#if JSON_USE_GLOBAL_UDLS
    #if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
        using nlohmann::literals::json_literals::operator ""_json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator ""_json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #else
        using nlohmann::literals::json_literals::operator "" _json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator "" _json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #endif
#endif

#include <nlohmann/detail/macro_unscope.hpp>

#endif  // INCLUDE_NLOHMANN_JSON_HPP_

```

`API/include/nlohmann/json_fwd.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

#include <nlohmann/detail/abi_macros.hpp>

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

/// a class to store JSON values
/// @sa https://json.nlohmann.me/api/basic_json/
template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer,
         class BinaryType = std::vector<std::uint8_t>, // cppcheck-suppress syntaxError
         class CustomBaseClass = void>
class basic_json;

/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
/// @sa https://json.nlohmann.me/api/json_pointer/
template<typename RefStringType>
class json_pointer;

/*!
@brief default specialization
@sa https://json.nlohmann.me/api/json/
*/
using json = basic_json<>;

/// @brief a minimal map-like container that preserves insertion order
/// @sa https://json.nlohmann.me/api/ordered_map/
template<class Key, class T, class IgnoredLess, class Allocator>
struct ordered_map;

/// @brief specialization that maintains the insertion order of object keys
/// @sa https://json.nlohmann.me/api/ordered_json/
using ordered_json = basic_json<nlohmann::ordered_map>;

NLOHMANN_JSON_NAMESPACE_END

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_

```

`API/include/nlohmann/ordered_map.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#include <functional> // equal_to, less
#include <initializer_list> // initializer_list
#include <iterator> // input_iterator_tag, iterator_traits
#include <memory> // allocator
#include <stdexcept> // for out_of_range
#include <type_traits> // enable_if, is_convertible
#include <utility> // pair
#include <vector> // vector

#include <nlohmann/detail/macro_scope.hpp>
#include <nlohmann/detail/meta/type_traits.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/// ordered_map: a minimal map-like container that preserves insertion order
/// for use within nlohmann::basic_json<ordered_map>
template <class Key, class T, class IgnoredLess = std::less<Key>,
          class Allocator = std::allocator<std::pair<const Key, T>>>
                  struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
{
    using key_type = Key;
    using mapped_type = T;
    using Container = std::vector<std::pair<const Key, T>, Allocator>;
    using iterator = typename Container::iterator;
    using const_iterator = typename Container::const_iterator;
    using size_type = typename Container::size_type;
    using value_type = typename Container::value_type;
#ifdef JSON_HAS_CPP_14
    using key_compare = std::equal_to<>;
#else
    using key_compare = std::equal_to<Key>;
#endif

    // Explicit constructors instead of `using Container::Container`
    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
    ordered_map() noexcept(noexcept(Container())) : Container{} {}
    explicit ordered_map(const Allocator& alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
    template <class It>
    ordered_map(It first, It last, const Allocator& alloc = Allocator())
        : Container{first, last, alloc} {}
    ordered_map(std::initializer_list<value_type> init, const Allocator& alloc = Allocator() )
        : Container{init, alloc} {}

    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(key, std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    std::pair<iterator, bool> emplace(KeyType && key, T && t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(std::forward<KeyType>(key), std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    T& operator[](const key_type& key)
    {
        return emplace(key, T{}).first->second;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & operator[](KeyType && key)
    {
        return emplace(std::forward<KeyType>(key), T{}).first->second;
    }

    const T& operator[](const key_type& key) const
    {
        return at(key);
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & operator[](KeyType && key) const
    {
        return at(std::forward<KeyType>(key));
    }

    T& at(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & at(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    const T& at(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & at(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    size_type erase(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type erase(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        return erase(pos, std::next(pos));
    }

    iterator erase(iterator first, iterator last)
    {
        if (first == last)
        {
            return first;
        }

        const auto elements_affected = std::distance(first, last);
        const auto offset = std::distance(Container::begin(), first);

        // This is the start situation. We need to delete elements_affected
        // elements (3 in this example: e, f, g), and need to return an
        // iterator past the last deleted element (h in this example).
        // Note that offset is the distance from the start of the vector
        // to first. We will need this later.

        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //             first    last

        // Since we cannot move const Keys, we re-construct them in place.
        // We start at first and re-construct (viz. copy) the elements from
        // the back of the vector. Example for first iteration:

        //               ,--------.
        //               v        |   destroy e and re-construct with h
        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //               it       it + elements_affected

        for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
        {
            it->~value_type(); // destroy but keep allocation
            new (&*it) value_type{std::move(*std::next(it, elements_affected))}; // "move" next element to it
        }

        // [ a, b, c, d, h, i, j, h, i, j ]
        //               ^        ^
        //             first    last

        // remove the unneeded elements at the end of the vector
        Container::resize(this->size() - static_cast<size_type>(elements_affected));

        // [ a, b, c, d, h, i, j ]
        //               ^        ^
        //             first    last

        // first is now pointing past the last deleted element, but we cannot
        // use this iterator, because it may have been invalidated by the
        // resize call. Instead, we can return begin() + offset.
        return Container::begin() + offset;
    }

    size_type count(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    iterator find(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    iterator find(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    const_iterator find(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    std::pair<iterator, bool> insert( value_type&& value )
    {
        return emplace(value.first, std::move(value.second));
    }

    std::pair<iterator, bool> insert( const value_type& value )
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, value.first))
            {
                return {it, false};
            }
        }
        Container::push_back(value);
        return {--this->end(), true};
    }

    template<typename InputIt>
    using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
            std::input_iterator_tag>::value>::type;

    template<typename InputIt, typename = require_input_iter<InputIt>>
    void insert(InputIt first, InputIt last)
    {
        for (auto it = first; it != last; ++it)
        {
            insert(*it);
        }
    }

private:
    JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
};

NLOHMANN_JSON_NAMESPACE_END

```

`API/include/nlohmann/thirdparty/hedley/hedley.hpp`:

```hpp
#pragma once

//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2016-2021 Evan Nemerson <evan@nemerson.com>
// SPDX-License-Identifier: MIT

/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 15

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_CONCAT3_EX)
    #undef JSON_HEDLEY_CONCAT3_EX
#endif
#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c

#if defined(JSON_HEDLEY_CONCAT3)
    #undef JSON_HEDLEY_CONCAT3
#endif
#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(JSON_HEDLEY_MSVC_VERSION)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #undef JSON_HEDLEY_INTEL_CL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
    #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if \
    defined(__TI_COMPILER_VERSION__) && \
    ( \
      defined(__TMS470__) || defined(__TI_ARM__) || \
      defined(__MSP430__) || \
      defined(__TMS320C2000__) \
    )
#if (__TI_COMPILER_VERSION__ >= 16000000)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #undef JSON_HEDLEY_TI_CL2000_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #undef JSON_HEDLEY_TI_CL430_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #undef JSON_HEDLEY_TI_CL6X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #undef JSON_HEDLEY_TI_CL7X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #undef JSON_HEDLEY_MCST_LCC_VERSION
#endif
#if defined(__LCC__) && defined(__LCC_MINOR__)
    #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
    #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_CRAY_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
    !defined(__COMPCERT__) && \
    !defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if \
  defined(__has_attribute) && \
  ( \
    (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
  )
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if \
    defined(__has_cpp_attribute) && \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#endif
#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#elif \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_IAR_VERSION) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
#      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      else
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      endif
#    else
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    endif
#  endif
#endif
#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
    ((T) (expr)) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("diag_suppress=Pe137") \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
#  endif
#else
#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif \
    (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
#elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_NO_ESCAPE)
    #undef JSON_HEDLEY_NO_ESCAPE
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
#else
    #define JSON_HEDLEY_NO_ESCAPE
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif defined(JSON_HEDLEY_ASSUME)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif
#if !defined(JSON_HEDLEY_ASSUME)
    #if defined(JSON_HEDLEY_UNREACHABLE)
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
    #else
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
    #endif
#endif
#if defined(JSON_HEDLEY_UNREACHABLE)
    #if  \
        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
    #else
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
    #endif
#else
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif

JSON_HEDLEY_DIAGNOSTIC_PUSH
#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
    #pragma clang diagnostic ignored "-Wpedantic"
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
#endif
#if \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
#elif \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
    )
#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
#  define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#elif \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
  JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
    )
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
#  define JSON_HEDLEY_PRIVATE
#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
#  if \
    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    ( \
      defined(__TI_EABI__) && \
      ( \
        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
      ) \
    ) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
#  else
#    define JSON_HEDLEY_PRIVATE
#    define JSON_HEDLEY_PUBLIC
#  endif
#  define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
#elif defined(__fallthrough) /* SAL */
    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
#else
    #define JSON_HEDLEY_FALL_THROUGH
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* JSON_HEDLEY_IS_CONSTEXPR_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #undef JSON_HEDLEY_IS_CONSTEXPR_
#endif
#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       ( \
          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
          !defined(JSON_HEDLEY_PGI_VERSION) && \
          !defined(JSON_HEDLEY_IAR_VERSION)) || \
       (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_NULL)
    #undef JSON_HEDLEY_NULL
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
    #elif defined(NULL)
        #define JSON_HEDLEY_NULL NULL
    #else
        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
    #endif
#elif defined(NULL)
    #define JSON_HEDLEY_NULL NULL
#else
    #define JSON_HEDLEY_NULL ((void*) 0)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE(expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE(expr)
#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
#endif

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#else
    #define JSON_HEDLEY_FLAGS
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

#if defined(JSON_HEDLEY_EMPTY_BASES)
    #undef JSON_HEDLEY_EMPTY_BASES
#endif
#if \
    (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
#else
    #define JSON_HEDLEY_EMPTY_BASES
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */

```

`API/include/nlohmann/thirdparty/hedley/hedley_undef.hpp`:

```hpp
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.11.2
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2022 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#pragma once

#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT3
#undef JSON_HEDLEY_CONCAT3_EX
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMPTY_BASES
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_CL_VERSION
#undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_IS_CONSTEXPR_
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MCST_LCC_VERSION
#undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_ESCAPE
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_NULL
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_ARMCL_VERSION
#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL2000_VERSION
#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL430_VERSION
#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL6X_VERSION
#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL7X_VERSION
#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CLPRU_VERSION
#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT
#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#undef JSON_HEDLEY_FALL_THROUGH

```

`HPCS2.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32106.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HPCS2", "HPCS2\HPCS2.vcxproj", "{9A02F163-AEBD-431B-8E0E-53C246BC27A8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x64.ActiveCfg = Debug|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x64.Build.0 = Debug|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x86.ActiveCfg = Debug|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x86.Build.0 = Debug|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x64.ActiveCfg = Release|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x64.Build.0 = Release|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x86.ActiveCfg = Release|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BC3F94B4-62FD-46DF-891E-E98FB39ADFF2}
	EndGlobalSection
EndGlobal

```

`HPCS2/HPCS2.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource2.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文 (簡體，中華人民共和國) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource2.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // 中文 (簡體，中華人民共和國) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// 中文 (繁體，台灣) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHT)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL
#pragma code_page(950)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "hpcs2logo.ico"

#endif    // 中文 (繁體，台灣) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`HPCS2/HPCS2.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32106.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HPCS2", "HPCS2\HPCS2.vcxproj", "{9A02F163-AEBD-431B-8E0E-53C246BC27A8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x64.ActiveCfg = Debug|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x64.Build.0 = Debug|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x86.ActiveCfg = Debug|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Debug|x86.Build.0 = Debug|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x64.ActiveCfg = Release|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x64.Build.0 = Release|x64
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x86.ActiveCfg = Release|Win32
		{9A02F163-AEBD-431B-8E0E-53C246BC27A8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BC3F94B4-62FD-46DF-891E-E98FB39ADFF2}
	EndGlobalSection
EndGlobal

```

`HPCS2/HPCS2.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9a02f163-aebd-431b-8e0e-53c246bc27a8}</ProjectGuid>
    <RootNamespace>HPCS2</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>..\API\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>..\API\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="api\ini.h" />
    <ClInclude Include="handle_hijack.hpp" />
    <ClInclude Include="memory.hpp" />
    <ClInclude Include="offset\animationsystem.dll.hpp" />
    <ClInclude Include="offset\client.dll.hpp" />
    <ClInclude Include="offset\engine2.dll.hpp" />
    <ClInclude Include="offset\host.dll.hpp" />
    <ClInclude Include="offset\interfaces.hpp" />
    <ClInclude Include="offset\materialsystem2.dll.hpp" />
    <ClInclude Include="offset\networksystem.dll.hpp" />
    <ClInclude Include="offset\offsets.hpp" />
    <ClInclude Include="offset\particles.dll.hpp" />
    <ClInclude Include="offset\pulse_system.dll.hpp" />
    <ClInclude Include="offset\rendersystemdx11.dll.hpp" />
    <ClInclude Include="offset\resourcesystem.dll.hpp" />
    <ClInclude Include="offset\scenesystem.dll.hpp" />
    <ClInclude Include="offset\schemasystem.dll.hpp" />
    <ClInclude Include="offset\server.dll.hpp" />
    <ClInclude Include="offset\soundsystem.dll.hpp" />
    <ClInclude Include="offset\vphysics2.dll.hpp" />
    <ClInclude Include="offset\worldrenderer.dll.hpp" />
    <ClInclude Include="resource2.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HPCS2.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="hpcs2logo.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HPCS2/HPCS2.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="來源檔案">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="標頭檔">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="資源檔">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>資源檔</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>來源檔案</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="offset\animationsystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\client.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\engine2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\host.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\interfaces.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\materialsystem2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\networksystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\offsets.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\particles.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\pulse_system.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\rendersystemdx11.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\resourcesystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\scenesystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\schemasystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\server.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\soundsystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\vphysics2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\worldrenderer.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="handle_hijack.hpp">
      <Filter>來源檔案</Filter>
    </ClInclude>
    <ClInclude Include="memory.hpp">
      <Filter>來源檔案</Filter>
    </ClInclude>
    <ClInclude Include="api\ini.h">
      <Filter>來源檔案</Filter>
    </ClInclude>
    <ClInclude Include="resource2.h">
      <Filter>標頭檔</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HPCS2.rc">
      <Filter>資源檔</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="hpcs2logo.ico">
      <Filter>資源檔</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`HPCS2/HPCS2.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`HPCS2/HPCS2/HPCS2.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9a02f163-aebd-431b-8e0e-53c246bc27a8}</ProjectGuid>
    <RootNamespace>HPCS2</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="memory.cpp" />
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="handle_hijack.hpp" />
    <ClInclude Include="memory.hpp" />
    <ClInclude Include="offset\animationsystem.dll.hpp" />
    <ClInclude Include="offset\client.dll.hpp" />
    <ClInclude Include="offset\engine2.dll.hpp" />
    <ClInclude Include="offset\host.dll.hpp" />
    <ClInclude Include="offset\interfaces.hpp" />
    <ClInclude Include="offset\materialsystem2.dll.hpp" />
    <ClInclude Include="offset\networksystem.dll.hpp" />
    <ClInclude Include="offset\offsets.hpp" />
    <ClInclude Include="offset\particles.dll.hpp" />
    <ClInclude Include="offset\pulse_system.dll.hpp" />
    <ClInclude Include="offset\rendersystemdx11.dll.hpp" />
    <ClInclude Include="offset\resourcesystem.dll.hpp" />
    <ClInclude Include="offset\scenesystem.dll.hpp" />
    <ClInclude Include="offset\schemasystem.dll.hpp" />
    <ClInclude Include="offset\server.dll.hpp" />
    <ClInclude Include="offset\soundsystem.dll.hpp" />
    <ClInclude Include="offset\vphysics2.dll.hpp" />
    <ClInclude Include="offset\worldrenderer.dll.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HPCS2/HPCS2/HPCS2.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="來源檔案">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="標頭檔">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="資源檔">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>資源檔</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>來源檔案</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="offset\animationsystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\client.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\engine2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\host.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\interfaces.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\materialsystem2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\networksystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\offsets.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\particles.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\pulse_system.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\rendersystemdx11.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\resourcesystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\scenesystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\schemasystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\server.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\soundsystem.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\vphysics2.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="offset\worldrenderer.dll.hpp">
      <Filter>標頭檔</Filter>
    </ClInclude>
    <ClInclude Include="handle_hijack.hpp">
      <Filter>來源檔案</Filter>
    </ClInclude>
    <ClInclude Include="memory.hpp">
      <Filter>來源檔案</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HPCS2/HPCS2/HPCS2.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`HPCS2/HPCS2/Source.cpp`:

```cpp

#include "offset/offsets.hpp"
#include "offset/client.dll.hpp"
#include <comdef.h>
#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h> 
#include <iostream> 
#include <thread>
#include <cmath>
#include <wtypes.h>
#include <numbers>
#include "memory.hpp"
#define render_distance -1
#define show_extra true 
#define flag_render_distance 200
#define TextSize 15
#define BonesColor RGB(200, 200, 200)
#define FOV 40//2
HANDLE cs2_process_handle;
ProcessModule cs2_module_client;
ProcessModule base_engine;

std::shared_ptr<pProcess> process;
struct C_UTL_VECTOR
{
    DWORD_PTR count = 0;
    DWORD_PTR data = 0;
};
namespace render
{
    void DrawBorderBox(HDC hdc, int x, int y, int w, int h, COLORREF borderColor)
    {
        HBRUSH hBorderBrush = CreateSolidBrush(borderColor);
        HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBorderBrush);

        RECT rect = { x, y, x + w, y + h };
        FrameRect(hdc, &rect, hBorderBrush);

        SelectObject(hdc, hOldBrush); // Restore the original brush
        DeleteObject(hBorderBrush);	  // Delete the temporary brush
    }

    void DrawFilledBox(HDC hdc, int x, int y, int width, int height, COLORREF color)
    {
        HBRUSH hBrush = CreateSolidBrush(color);
        RECT rect = { x, y, x + width, y + height };
        FillRect(hdc, &rect, hBrush);
        DeleteObject(hBrush);
    }



    void SetTextSize(HDC hdc, int textSize)
    {
        LOGFONT lf;
        HFONT hFont, hOldFont;

        // Initialize the LOGFONT structure
        ZeroMemory(&lf, sizeof(LOGFONT));
        lf.lfHeight = -textSize;			// Set the desired text height (negative for height)
        lf.lfWeight = FW_NORMAL;			// Set the font weight (e.g., FW_NORMAL for normal)
        lf.lfQuality = ANTIALIASED_QUALITY; // Enable anti-aliasing

        // Create a new font based on the LOGFONT structure
        hFont = CreateFontIndirect(&lf);

        // Select the new font into the device context and save the old font
        hOldFont = (HFONT)SelectObject(hdc, hFont);

        // Clean up the old font (when done using it)
        DeleteObject(hOldFont);
    }

    void RenderLine(HDC hdc,float p1x,float p1y,float p2x,float p2y, COLORREF borderColor)
    {
        HPEN hPen = CreatePen(PS_DASH, 2, borderColor); // 使用红色、宽度为1像素，实线样式的画笔
        SelectObject(hdc, hPen);
        MoveToEx(hdc, (int)p1x, (int)p1y, (LPPOINT)NULL);
        LineTo(hdc, (int)p2x, (int)p2y);
        DeleteObject(hPen);
    }

    void RenderText(HDC hdc, int x, int y, const char* text, COLORREF textColor, int textSize)
    {
        SetTextSize(hdc, textSize);
        SetTextColor(hdc, textColor);

        int len = MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
        wchar_t* wide_text = new wchar_t[len];
        MultiByteToWideChar(CP_UTF8, 0, text, -1, wide_text, len);

        TextOutW(hdc, x, y, wide_text, len - 1);

        delete[] wide_text;
    }
}
namespace g {
    inline HDC hdcBuffer = NULL;
    inline HBITMAP hbmBuffer = NULL;

    RECT gameBounds;
}
enum bones : int {
    head = 6,
    neck = 5,
    chest = 4,
    shoulderRight = 8,
    shoulderLeft = 13,
    elbowRight = 9,
    elbowLeft = 14,
    handRight = 11,
    handLeft = 16,
    crotch = 0,
    kneeRight = 23,
    kneeLeft = 26,
    ankleRight = 24,
    ankleLeft = 27,
};


inline namespace boneGroups {
    inline std::vector<int> mid = { bones::head,bones::neck,bones::chest,bones::crotch };
    inline std::vector<int> leftArm = { bones::neck,bones::shoulderLeft,bones::elbowLeft,bones::handLeft };
    inline std::vector<int> righttArm = { bones::neck,bones::shoulderRight,bones::elbowRight,bones::handRight };
    inline std::vector<int> leftLeg = { bones::crotch,bones::kneeLeft,bones::ankleLeft };
    inline std::vector<int> rightLeg = { bones::crotch,bones::kneeRight,bones::ankleRight };
    inline std::vector<std::vector<int>> allGroups = { mid,leftArm,righttArm,leftLeg,rightLeg };
}
void loop();

void FunctionT();

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
    {
        g::hdcBuffer = CreateCompatibleDC(NULL);
        g::hbmBuffer = CreateCompatibleBitmap(GetDC(hWnd), g::gameBounds.right, g::gameBounds.bottom);
        SelectObject(g::hdcBuffer, g::hbmBuffer);

        SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_LAYERED);

        SetLayeredWindowAttributes(hWnd, RGB(255, 255, 255), 0, LWA_COLORKEY);

        //std::cout << "[overlay] Window created successfully" << std::endl;
        Beep(500, 100);
        break;
    }
    case WM_ERASEBKGND: // We handle this message to avoid flickering
        return TRUE;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        //DOUBLE BUFFERING
        FillRect(g::hdcBuffer, &ps.rcPaint, (HBRUSH)GetStockObject(WHITE_BRUSH));


        if (GetForegroundWindow() == process->hwnd_) {
            //render::RenderText(g::hdcBuffer, 10, 10, "cs2 | ESP", RGB(75, 175, 175), 15);
            loop();
        }

        BitBlt(hdc, 0, 0, g::gameBounds.right, g::gameBounds.bottom, g::hdcBuffer, 0, 0, SRCCOPY);

        EndPaint(hWnd, &ps);
        InvalidateRect(hWnd, NULL, TRUE);
        break;
    }
    case WM_DESTROY:
        DeleteDC(g::hdcBuffer);
        DeleteObject(g::hbmBuffer);

        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


struct view_matrix_t {
    float* operator[ ](int index) {
        return matrix[index];
    }

    float matrix[4][4];
};


struct Vector3
{
    // constructor
    constexpr Vector3(
        const float x = 0.f,
        const float y = 0.f,
        const float z = 0.f) noexcept :
        x(x), y(y), z(z) { }

    // operator overloads
    constexpr const Vector3& operator-(const Vector3& other) const noexcept
    {
        return Vector3{ x - other.x, y - other.y, z - other.z };
    }

    constexpr const Vector3& operator+(const Vector3& other) const noexcept
    {
        return Vector3{ x + other.x, y + other.y, z + other.z };
    }

    constexpr const Vector3& operator/(const float factor) const noexcept
    {
        return Vector3{ x / factor, y / factor, z / factor };
    }

    constexpr const Vector3& operator*(const float factor) const noexcept
    {
        return Vector3{ x * factor, y * factor, z * factor };
    }

    constexpr const bool operator>(const Vector3& other) const noexcept {
        return x > other.x && y > other.y && z > other.z;
    }

    constexpr const bool operator>=(const Vector3& other) const noexcept {
        return x >= other.x && y >= other.y && z >= other.z;
    }

    constexpr const bool operator<(const Vector3& other) const noexcept {
        return x < other.x&& y < other.y&& z < other.z;
    }

    constexpr const bool operator<=(const Vector3& other) const noexcept {
        return x <= other.x && y <= other.y && z <= other.z;
    }

    constexpr const Vector3& ToAngle() const noexcept
    {
        return Vector3{
            std::atan2(-z, std::hypot(x, y)) * (180.0f / std::numbers::pi_v<float>),
            std::atan2(y, x) * (180.0f / std::numbers::pi_v<float>),
            0.0f
        };
    }

    void Print()
    {
        std::cout << "\n x : " << x << "   y :" << y << "z :" << z;
        return;
    }

    constexpr const bool IsZero() const noexcept
    {
        return x == 0.f && y == 0.f && z == 0.f;
    }

    float length() const {
        return std::sqrt(x * x + y * y + z * z);
    }

    float length2d() const {
        return std::sqrt(x * x + y * y);
    }



    Vector3 world_to_screen(view_matrix_t matrix) const {
        float _x = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z + matrix[0][3];
        float _y = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z + matrix[1][3];
        float w = matrix[3][0] * x + matrix[3][1] * y + matrix[3][2] * z + matrix[3][3];
    
    
        float inv_w = 1.f / w;
        _x *= inv_w;
        _y *= inv_w;
    
        float x = g::gameBounds.right * .5f;
        float y = g::gameBounds.bottom * .5f;
    
        x += 0.5f * _x * g::gameBounds.right + 0.5f;
        y -= 0.5f * _y * g::gameBounds.bottom + 0.5f;
    
        return { x, y, w };
    }


    float calculate_distance(const Vector3& point) const {
        float dx = point.x - x;
        float dy = point.y - y;
        float dz = point.z - z;

        return std::sqrt(dx * dx + dy * dy + dz * dz);
    }


    // struct data
    float x, y, z;
};

inline constexpr Vector3 CalculateAngle(
    const Vector3& localPosition,
    const Vector3& enemyPosition,
    const Vector3& viewAngles) noexcept
{
    return ((enemyPosition - localPosition).ToAngle() - viewAngles);
};


inline Vector3 clampAngles(Vector3 angles) {
    if (angles.x > 89.0f && angles.x <= 180.0f) {
        angles.x = 89.0f;
    }

    if (angles.x > 180.0f) {
        angles.x -= 360.0f;
    }

    if (angles.x < -89.0f) {
        angles.x = -89.0f;
    }

    if (angles.y > 180.0f) {
        angles.y -= 360.0f;
    }

    if (angles.y < -180.0f) {
        angles.y += 360.0f;
    }
    angles.z = 0;

    return angles;
};


inline Vector3 normalizeAngles(Vector3 angle) {
    while (angle.x > 180.f)
        angle.x -= 360.0f;

    while (angle.x < -180.0f)
        angle.x += 360.0f;

    while (angle.y > 180.0f)
        angle.y -= 360.0f;

    while (angle.y < -180.0f)
        angle.y += 360.0f;

    return angle;
};



inline Vector3 calculateBestAngle(Vector3 angle,float& configFov) {
    Vector3 newAngle;

    float fov = std::hypot(angle.x, angle.y);

    if (fov < configFov) {
        configFov = fov;
        newAngle = angle;
    }
    return newAngle;
}


void aimBot(C_UTL_VECTOR aimPunchCache, int getShotsFired,Vector3& cameraPos,Vector3& viewAngles,float& fov, bool isHot,Vector3 baseViewAngles, DWORD_PTR baseViewAnglesAddy, uintptr_t boneArray) {
    Vector3 aimPos;
    Vector3 newAngle;

    aimPos = process->read<Vector3>(boneArray + 6/*head*/* 32);
//    aimPos.Print();
    const Vector3 angle = CalculateAngle(cameraPos, aimPos, viewAngles );
    newAngle = calculateBestAngle(angle, fov/*fov*/);
    newAngle = clampAngles(newAngle);

    newAngle.x = newAngle.x / 1.f;//smoothing
    newAngle.y = newAngle.y / 1.f;//smoothing

    if (newAngle.IsZero()) {
        return;
    }

    if (isHot) {
        if (GetAsyncKeyState(VK_SHIFT)&0x8000) {

            Vector3 aimPunchAngle = process->read<Vector3>(aimPunchCache.data + (aimPunchCache.count - 1) * sizeof(Vector3));

            if (getShotsFired > 1) {
                newAngle.x = newAngle.x - aimPunchAngle.x * 2.f;
                newAngle.y = newAngle.y - aimPunchAngle.y * 2.f;
                //newAngle = clampAngles(newAngle);

                process->write<Vector3>(baseViewAnglesAddy, newAngle + baseViewAngles);
            }
            else
                process->write<Vector3>(baseViewAnglesAddy, baseViewAngles + newAngle);
        }
    }
    else {
        process->write<Vector3>(baseViewAnglesAddy, baseViewAngles + newAngle);
    }
}

void recoilControl(Vector3& ViewAngle, C_UTL_VECTOR aimPunchCache,int getShotsFired , DWORD_PTR baseViewAnglesAddy) {
    static Vector3 oldPunch;
    Vector3 aimPunchAngle = process->read<Vector3>(aimPunchCache.data + (aimPunchCache.count - 1) * sizeof(Vector3));
    
    if (getShotsFired > 1) {
        Vector3 recoilVector = {
            ViewAngle.x + oldPunch.x  - aimPunchAngle.x * 2.f,
            ViewAngle.y + oldPunch.y  - aimPunchAngle.y * 2.f
        };
        recoilVector = clampAngles(recoilVector);
        
        process->write<Vector3>(baseViewAnglesAddy, recoilVector);


    }

    oldPunch.x = aimPunchAngle.x * 2.f;
    oldPunch.y = aimPunchAngle.y * 2.f;
}

int main(int argc, char* argv[])
{
    SetConsoleTitleW(L"cs2-HalfPeople-esp");

    process = std::make_shared<pProcess>();


    while (!process->AttachProcessHj("cs2.exe"))
        std::this_thread::sleep_for(std::chrono::seconds(1));


    do {
        cs2_module_client = process->GetModule("client.dll");
        base_engine = process->GetModule("engine2.dll");
        if (cs2_module_client.base == 0 || base_engine.base == 0) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            std::cout << " Failed to find module client.dll/engine2.dll, waiting for the game to load it..." << std::endl;
        }
    } while (cs2_module_client.base == 0 || base_engine.base == 0);

    const uintptr_t buildNumber = process->read<uintptr_t>(base_engine.base + engine2_dll::dwBuildNumber);
    std::cout << "\n build number : " << buildNumber;

    std::cout << " Make sure your game is in \"Full Screen Windowed\"" << std::endl;
    while (GetForegroundWindow() != process->hwnd_) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        process->UpdateHWND();
        ShowWindow(process->hwnd_, TRUE);
    }
    std::cout << "Creating window overlay" << std::endl;

    WNDCLASSEXA wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEXA);
    wc.lpfnWndProc = WndProc;
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.hbrBackground = WHITE_BRUSH;
    wc.hInstance = reinterpret_cast<HINSTANCE>(GetWindowLongA(process->hwnd_, (-6))); // GWL_HINSTANCE));
    wc.lpszMenuName = " ";
    wc.lpszClassName = " ";

    RegisterClassExA(&wc);

    GetClientRect(process->hwnd_, &g::gameBounds);

    // Create the window
    HINSTANCE hInstance = NULL;
    HWND hWnd = CreateWindowExA(WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW, " ", "cs2-HalfPeople-esp", WS_POPUP,
        g::gameBounds.left, g::gameBounds.top, g::gameBounds.right - g::gameBounds.left, g::gameBounds.bottom + g::gameBounds.left, NULL, NULL, hInstance, NULL); // NULL, NULL);

    if (hWnd == NULL)
        return 0;

    SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    ShowWindow(hWnd, TRUE);
    //SetActiveWindow(hack::process->hwnd_);

    // Message loop
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        std::thread T(FunctionT);
        if (GetAsyncKeyState(VK_END) & 0x8000) break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);

        T.join();
        //std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }


    DeleteDC(g::hdcBuffer);
    DeleteObject(g::hbmBuffer);

    DestroyWindow(hWnd);

    process->Close();


    system("pause");

    return 0;
}
uintptr_t localPlayer;
int localTeam;
uintptr_t entity_list;
void loop()
{
    render::RenderText(g::hdcBuffer, 50, 50, "HalfPeople CSGO 2 GameHack Test", RGB(200, 200,200), 30);

    const view_matrix_t view_matrix = process->read<view_matrix_t>(cs2_module_client.base + client_dll::dwViewMatrix);
    entity_list = process->read<uintptr_t>( cs2_module_client.base + client_dll::dwEntityList);

    localPlayer = process->read<uintptr_t>( cs2_module_client.base + client_dll::dwLocalPlayerPawn);
    if (!localPlayer)
        return ;

    localTeam = process->read<int>( localPlayer + C_BaseEntity::m_iTeamNum);

    int playerIndex = 0;
    uintptr_t list_entry;


    //Vector3 cameraPos = process->read<Vector3>( localPlayer + C_CSPlayerPawnBase::m_vecLastClipCameraPos);

    //Vector3 viewAngles = process->read<Vector3>( localPlayer + C_CSPlayerPawnBase::m_angEyeAngles);

    //Vector3 baseViewAngles = process->read<Vector3>( cs2_module_client.base + client_dll::dwViewAngles);

    //float fov = 15;

    const uintptr_t localList_entry2 = process->read<uintptr_t>(entity_list + 0x8 * ((localPlayer & 0x7FFF) >> 9) + 16);
    const uintptr_t localpCSPlayerPawn = process->read<uintptr_t>(localList_entry2 + 120 * (localPlayer & 0x1FF));
    if (!localpCSPlayerPawn)
        return;
    const uintptr_t localCGameSceneNode = process->read<uintptr_t>(localPlayer + C_BaseEntity::m_pGameSceneNode);
    const Vector3 localOrigin = process->read<Vector3>(localCGameSceneNode + CGameSceneNode::m_vecOrigin);
    bool c4IsPlanted = process->read<bool>(cs2_module_client.base +client_dll::dwPlantedC4 - 0x8);
    if (c4IsPlanted)
    {
        const uintptr_t planted_c4 = process->read<uintptr_t>(process->read<uintptr_t>(cs2_module_client.base + client_dll::dwPlantedC4));

        const uintptr_t c4Node = process->read<uintptr_t>(planted_c4 + C_BaseEntity::m_pGameSceneNode);

        const Vector3 c4Origin = process->read<Vector3>(c4Node + CGameSceneNode::m_vecAbsOrigin);

        const Vector3 c4ScreenPos = c4Origin.world_to_screen(view_matrix);

        if (c4ScreenPos.z >= 0.01f) {
            float c4Distance = localOrigin.calculate_distance(c4Origin);
            float c4RoundedDistance = std::round(c4Distance / 500.f);

            float height = 50 - c4RoundedDistance;
            float width = height * 1.4f;

            render::RenderLine(g::hdcBuffer, 0, 0, c4ScreenPos.x, c4ScreenPos.y, RGB(175, 75, 75));

            render::DrawFilledBox(
                g::hdcBuffer,
                c4ScreenPos.x - (width / 2),
                c4ScreenPos.y - (height / 2),
                width,
                height,
                RGB(175, 75, 75)
            );

            render::RenderText(
                g::hdcBuffer,
                c4ScreenPos.x + (width / 2 + 5),
                c4ScreenPos.y,
                "C4",
                RGB(75, 75, 175),
                TextSize
            );
        }
    }
    while (true)
    {
        playerIndex++;
        list_entry = process->read<uintptr_t>( entity_list + (8 * (playerIndex & 0x7FFF) >> 9) + 16);
        if (!list_entry)
            break;

        const uintptr_t player = process->read<uintptr_t>( list_entry + 120 * (playerIndex & 0x1FF));
        if (!player)
            continue;

        const int playerTeam = process->read<int>( player + C_BaseEntity::m_iTeamNum);
            

        const std::uint32_t playerPawn = process->read<std::uint32_t>( player + CCSPlayerController::m_hPlayerPawn);

        const uintptr_t list_entry2 = process->read<uintptr_t>( entity_list + 0x8 * ((playerPawn & 0x7FFF) >> 9) + 16);
        if (!list_entry2)
            continue;

        const uintptr_t pCSPlayerPawn = process->read<uintptr_t>( list_entry2 + 120 * (playerPawn & 0x1FF));
       
        const int playerArmor = process->read<int>(pCSPlayerPawn + C_CSPlayerPawnBase::m_ArmorValue);
        const int playerHealth = process->read<int>( pCSPlayerPawn + C_BaseEntity::m_iHealth);
        if (playerHealth <= 0 || playerHealth > 100)
            continue;

        if (pCSPlayerPawn == localPlayer)
            continue;

        std::string playerName = "Invalid Name";
        const DWORD64 playerNameAddress = process->read<DWORD64>(player + CCSPlayerController::m_sSanitizedPlayerName);
        if (playerNameAddress) {
            char buf[256];
            process->read_raw(playerNameAddress, buf, sizeof(buf));
            playerName = std::string(buf);
        }

        const uintptr_t CGameSceneNode = process->read<uintptr_t>(pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
        const Vector3 origin = process->read<Vector3>(CGameSceneNode + CGameSceneNode::m_vecOrigin);
        const Vector3 head = { origin.x, origin.y, origin.z + 75.f };

        if (render_distance != -1 && (localOrigin - origin).length2d() > render_distance)
            continue;

        const Vector3 screenPos = origin.world_to_screen(view_matrix);
        if(screenPos.z < 0)
            continue;
        const Vector3 screenHead = head.world_to_screen(view_matrix);



        if (screenPos.z >= 0.01f) {
            render::RenderLine(g::hdcBuffer, screenHead.x, screenHead.y, g::gameBounds.right / 2, g::gameBounds.bottom * 0.8, (localTeam == playerTeam ? RGB(75, 175, 75) : RGB(175, 75, 75)));
            const float height = screenPos.y - screenHead.y;
            const float width = height / 2.4f;
            const float head_height = (screenPos.y - screenHead.y) / 8;
            const float head_width = (height / 2.4f) / 4;

            float distance = localOrigin.calculate_distance(origin);
            int roundedDistance = std::round(distance / 10.f);

            render::DrawBorderBox(
                g::hdcBuffer,
                screenHead.x - width / 2,
                screenHead.y,
                width,
                height,
                (localTeam == playerTeam ? RGB(75, 175, 75) : RGB(175, 75, 75))
            );

            render::DrawBorderBox(
                g::hdcBuffer,
                screenHead.x - (width / 2 + 10),
                screenHead.y + (height * (100 - playerArmor) / 100),
                2,
                height - (height * (100 - playerArmor) / 100),
                RGB(0, 185, 255)
            );

            render::DrawBorderBox(
                g::hdcBuffer,
                screenHead.x - (width / 2 + 5),
                screenHead.y + (height * (100 - playerHealth) / 100),
                2,
                height - (height * (100 - playerHealth) / 100),
                RGB(
                    (255 - playerHealth),
                    (55 + playerHealth * 2),
                    75
                )
            );

            render::RenderText(
                g::hdcBuffer,
                screenHead.x + (width / 2 + 5),
                screenHead.y,
                playerName.c_str(),
                RGB(75, 75, 175),
                TextSize
            );

            /**
            * I know is not the best way but a simple way to not saturate the screen with a ton of information
            */
            if (roundedDistance > flag_render_distance)
                continue;

            render::RenderText(
                g::hdcBuffer,
                screenHead.x + (width / 2 + 5),
                screenHead.y + TextSize,
                (std::to_string(playerHealth) + "hp").c_str(),
                RGB(
                    (255 - playerHealth),
                    (55 + playerHealth * 2),
                    75
                ),
                TextSize
            );

            render::RenderText(
                g::hdcBuffer,
                screenHead.x + (width / 2 + 5),
                screenHead.y + TextSize*2,
                (std::to_string(playerArmor) + "armor").c_str(),
                RGB(
                    (255 - playerArmor),
                    (55 + playerArmor * 2),
                    75
                ),
                TextSize
            );

            render::RenderText(
                g::hdcBuffer,
                screenHead.x + (width / 2 + 5),
                screenHead.y + TextSize * 8,
                (std::to_string((int)distance) + "cm").c_str(),
                RGB(
                    (255 - playerArmor),
                    (55 + playerArmor * 2),
                    75
                ),
                TextSize
            );

            if (show_extra)
            {
                /*
                * Reading values for extra flags is now seperated from the other reads
                * This removes unnecessary memory reads, improving performance when not showing extra flags
                */
                const bool isDefusing = process->read<bool>(pCSPlayerPawn + C_CSPlayerPawnBase::m_bIsDefusing);
                const uintptr_t playerMoneyServices = process->read<uintptr_t>(player + CCSPlayerController::m_pInGameMoneyServices);
                const int32_t money = process->read<int32_t>(playerMoneyServices + CCSPlayerController_InGameMoneyServices::m_iAccount);
                const float flashAlpha = process->read<float>(pCSPlayerPawn + C_CSPlayerPawnBase::m_flFlashOverlayAlpha);

                const auto clippingWeapon = process->read<std::uint64_t>(pCSPlayerPawn + C_CSPlayerPawnBase::m_pClippingWeapon);
                const auto weaponData = process->read<std::uint64_t>(clippingWeapon + 0x360);
                const auto weaponNameAddress = process->read<std::uint64_t>(weaponData + CCSWeaponBaseVData::m_szName);
                std::string weaponName = "Invalid Weapon Name";

                if (!weaponNameAddress) {
                    weaponName = "Invalid Weapon Name";
                }
                else {
                    char buf[32];
                    process->read_raw(weaponNameAddress, buf, sizeof(buf));
                    weaponName = std::string(buf);
                    if (weaponName.compare(0, 7, "weapon_") == 0)
                        weaponName = weaponName.substr(7, weaponName.length()); // Remove weapon_ prefix
                }

                render::RenderText(
                    g::hdcBuffer,
                    screenHead.x + (width / 2 + 5),
                    screenHead.y + TextSize*3,
                    weaponName.c_str(),
                    RGB(75, 75, 175),
                    TextSize
                );

                render::RenderText(
                    g::hdcBuffer,
                    screenHead.x + (width / 2 + 5),
                    screenHead.y + TextSize*4,
                    (std::to_string(roundedDistance) + "m away").c_str(),
                    RGB(75, 75, 175),
                    TextSize
                );

                render::RenderText(
                    g::hdcBuffer,
                    screenHead.x + (width / 2 + 5),
                    screenHead.y + TextSize*5,
                    ("$" + std::to_string(money)).c_str(),
                    RGB(0, 125, 0),
                    TextSize
                );

                if (flashAlpha > 100)
                {
                    render::RenderText(
                        g::hdcBuffer,
                        screenHead.x + (width / 2 + 5),
                        screenHead.y + TextSize*6,
                        "Player is flashed",
                        RGB(75, 75, 175),
                        TextSize
                    );
                }

                if (isDefusing)
                {
                    const std::string defuText = "Player is defusing";
                    render::RenderText(
                        g::hdcBuffer,
                        screenHead.x + (width / 2 + 5),
                        screenHead.y + 60,
                        defuText.c_str(),
                        RGB(75, 75, 175),
                        TextSize
                    );
                }
            }


            if (distance > 1000)
            {
                continue;
            }

           // const uintptr_t CGameSceneNode = process->read<uintptr_t>( pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
            const uintptr_t boneArray = process->read<uintptr_t>( CGameSceneNode + CSkeletonInstance::m_modelState + CGameSceneNode::m_vecOrigin);

            Vector3 head_ =       process->read<Vector3>(boneArray + 6 * 32);
            Vector3 cou =        process->read<Vector3>(boneArray + 5 * 32);
            Vector3 shoulderR =  process->read<Vector3>(boneArray + 8 * 32);
            Vector3 shoulderL =  process->read<Vector3>(boneArray + 13 * 32);
            Vector3 brasR =      process->read<Vector3>(boneArray + 9 * 32);
            Vector3 brasL =      process->read<Vector3>(boneArray + 14 * 32);
            Vector3 handR =      process->read<Vector3>(boneArray + 11 * 32);
            Vector3 handL =      process->read<Vector3>(boneArray + 16 * 32);
            Vector3 cock =       process->read<Vector3>(boneArray + 0 * 32);
            Vector3 kneesR =     process->read<Vector3>(boneArray + 23 * 32);
            Vector3 kneesL =     process->read<Vector3>(boneArray + 26 * 32);
            Vector3 feetR =      process->read<Vector3>(boneArray + 24 * 32);
            Vector3 feetL =      process->read<Vector3>(boneArray + 27 * 32);
            
            Vector3 Ahead;
            Vector3 Acou;
            Vector3 AshoulderR;
            Vector3 AshoulderL;
            Vector3 AbrasR;
            Vector3 AbrasL;
            Vector3 AhandR;
            Vector3 AhandL;
            Vector3 Acock;
            Vector3 AkneesR;
            Vector3 AkneesL;
            Vector3 AfeetR;
            Vector3 AfeetL;
            
            
            Ahead  = head     .world_to_screen(view_matrix)  ;
            if (Ahead.z < 0)
                   continue;
            Acou   = cou      .world_to_screen(view_matrix)  ;
            if (Acou.z < 0)
                   continue;
            AshoulderR= shoulderR.world_to_screen(view_matrix)  ;
            if (AshoulderR.z < 0)
                continue;
            AshoulderL= shoulderL.world_to_screen(view_matrix)  ;
            if (AshoulderL.z < 0)
                continue;
              AbrasR  = brasR   .world_to_screen( view_matrix)  ;
              if (AbrasR.z < 0)
                  continue;
              AbrasL  = brasL   .world_to_screen( view_matrix)  ;
              if (AbrasL.z < 0)
                  continue;
              AhandL  = handL   .world_to_screen( view_matrix)  ;
              if (AhandL.z < 0)
                  continue;
              AhandR  = handR   .world_to_screen( view_matrix)  ;
              if (AhandR.z < 0)
                  continue;
              Acock   = cock   .world_to_screen( view_matrix)  ;
              if (Acock.z < 0)
                  continue;
              AkneesR = kneesR  .world_to_screen( view_matrix)  ;
              if (AkneesR.z < 0)
                  continue;
              AkneesL = kneesL  .world_to_screen( view_matrix)  ;
              if (AkneesL.z < 0)
                  continue;
              AfeetR  = feetR   .world_to_screen( view_matrix)  ;
              if (AfeetR.z < 0)
                  continue;
              AfeetL  = feetL   .world_to_screen( view_matrix)  ;
              if (AfeetL.z < 0)
                  continue;
            
              render::RenderLine(g::hdcBuffer, Ahead.x, Ahead.y, Acou.x, Acou.y, BonesColor);
              render::RenderLine(g::hdcBuffer,Acou.x, Acou.y, AshoulderR.x, AshoulderR.y,     BonesColor);
              render::RenderLine(g::hdcBuffer,Acou.x, Acou.y, AshoulderL.x, AshoulderL.y,     BonesColor);
              render::RenderLine(g::hdcBuffer,AbrasL.x, AbrasL.y, AshoulderL.x, AshoulderL.y, BonesColor);
              render::RenderLine(g::hdcBuffer,AbrasR.x, AbrasR.y, AshoulderR.x, AshoulderR.y, BonesColor);
              render::RenderLine(g::hdcBuffer,AbrasR.x, AbrasR.y, AhandR.x, AhandR.y,         BonesColor);
              render::RenderLine(g::hdcBuffer,AbrasL.x, AbrasL.y, AhandL.x, AhandL.y,         BonesColor);
              render::RenderLine(g::hdcBuffer,Acou.x, Acou.y, Acock.x, Acock.y,               BonesColor);
              render::RenderLine(g::hdcBuffer,AkneesR.x, AkneesR.y, Acock.x, Acock.y,         BonesColor);
              render::RenderLine(g::hdcBuffer,AkneesL.x, AkneesL.y, Acock.x, Acock.y,         BonesColor);
              render::RenderLine(g::hdcBuffer,AkneesL.x, AkneesL.y, AfeetL.x, AfeetL.y,       BonesColor);
              render::RenderLine(g::hdcBuffer,AkneesR.x, AkneesR.y, AfeetR.x, AfeetR.y,       BonesColor);


           // Vector3 previous, current;
           //
           //
           // for (std::vector<int> currentGroup : boneGroups::allGroups) {
           //     previous = { 0,0,0 };
           //
           //     for (int currentBone : currentGroup) {
           //         current = process->read<Vector3>(boneArray + currentBone * 32);
           //
           //         if (previous.IsZero()) {
           //             previous = current;
           //             continue;
           //         }
           //
           //         Vector3 currentScreenPos = current.world_to_screen(view_matrix);
           //         Vector3 previousScreenPos = previous.world_to_screen(view_matrix);
           //
           //
           //        render::RenderLine(g::hdcBuffer, previousScreenPos.x, previousScreenPos.y, currentScreenPos.x, currentScreenPos.y, BonesColor);
           //
           //         previous = current;
           //     }
           // }

        }





    }
}

void FunctionT()
{

        int playerIndex = 0;
        uintptr_t list_entry;


        Vector3 cameraPos = process->read<Vector3>(localPlayer + C_CSPlayerPawnBase::m_vecLastClipCameraPos);

        Vector3 viewAngles = process->read<Vector3>(localPlayer + C_CSPlayerPawnBase::m_angEyeAngles);

        Vector3 baseViewAngles = process->read<Vector3>(cs2_module_client.base + client_dll::dwViewAngles);


        const uintptr_t localList_entry2 = process->read<uintptr_t>(entity_list + 0x8 * ((localPlayer & 0x7FFF) >> 9) + 16);
        const uintptr_t localpCSPlayerPawn = process->read<uintptr_t>(localList_entry2 + 120 * (localPlayer & 0x1FF));
        if (!localpCSPlayerPawn)
            return;

        uintptr_t baseViewAnglesAddy = cs2_module_client.base + client_dll::dwViewAngles;

        C_UTL_VECTOR aimPunchCache = process->read<C_UTL_VECTOR>(localPlayer + C_CSPlayerPawn::m_aimPunchCache);

        int shotsFired = process->read<int>(localPlayer + C_CSPlayerPawnBase::m_iShotsFired);
        
        float fov = FOV;
        while (true)
        {
            playerIndex++;
            list_entry = process->read<uintptr_t>(entity_list + (8 * (playerIndex & 0x7FFF) >> 9) + 16);
            if (!list_entry)
                break;

            const uintptr_t player = process->read<uintptr_t>(list_entry + 120 * (playerIndex & 0x1FF));
            if (!player)
                continue;

            const int playerTeam = process->read<int>(player + C_BaseEntity::m_iTeamNum);
            if (playerTeam == localTeam)
            {
                continue;
            }



            const std::uint32_t playerPawn = process->read<std::uint32_t>(player + CCSPlayerController::m_hPlayerPawn);

            const uintptr_t list_entry2 = process->read<uintptr_t>(entity_list + 0x8 * ((playerPawn & 0x7FFF) >> 9) + 16);
            if (!list_entry2)
                continue;

            const uintptr_t pCSPlayerPawn = process->read<uintptr_t>(list_entry2 + 120 * (playerPawn & 0x1FF));
            if (pCSPlayerPawn == localPlayer)
                continue;

            const int playerArmor = process->read<int>(pCSPlayerPawn + C_CSPlayerPawnBase::m_ArmorValue);
            const int playerHealth = process->read<int>(pCSPlayerPawn + C_BaseEntity::m_iHealth);
            if (playerHealth <= 0 || playerHealth > 100)
                continue;

            const uintptr_t CGameSceneNode = process->read<uintptr_t>(pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
            const uintptr_t boneArray = process->read<uintptr_t>(CGameSceneNode + CSkeletonInstance::m_modelState + CGameSceneNode::m_vecOrigin);

            aimBot(aimPunchCache,shotsFired,cameraPos, viewAngles, fov, true, baseViewAngles, baseViewAnglesAddy, boneArray);
            //recoilControl(viewAngles, aimPunchCache, shotsFired, baseViewAnglesAddy);
        }
}

```

`HPCS2/HPCS2/handle_hijack.hpp`:

```hpp

/*
	Credits to: https://github.com/Apxaey/Handle-Hijacking-Anti-Cheat-Bypass for the source and public sharing!

	Its a little bit messy as i tried to make it asap. All comments below this are from the original creator!
*/

/*
	This is a stand alone bypass made by Apxaey. Feel free to use this in your cheats but credit me for the bypass as i put alot of time into this.
	If you have some brain cells you will be able to incorporate this into your cheats and remain undetected by user-mode anticheats.
	Obviously standard cheat 'recommendations' still apply:
	1.) Use self-written or not signatured code
	2.) Dont write impossible values
	3.) If your going internal use a manual map injector

	If you follow the guidelines above and use this bypass you will be safe from usermode anticheats like VAC.
	Obviously you can build and adapt upon my code to suit your needs.
	If I was to make a cheat for myself i would put this bypass into something i call an 'external internal' cheat.
	Whereby you make a cheat and inject into a legitimate program like discord and add a check to the this bypass to only hijack a handle from the process you inject into, giving the appearence that nothing is out of the ordinary
	However you can implement this bypass into any form of cheat, its your decision.
	If you need want some more info i recommend you watch my YT video on this bypass.
	Anyways if you want to see more of my stuff feel free to join my discord server discord.gg/********. Here's my YT as well https://www.youtube.com/channel/UCPN6OOLxn1OaBP5jPThIiog.
*/

#include <Windows.h> 
#include <iostream>
#include <TlHelp32.h>
#include <string>

// macros we use.Some can be found in wintrnl.h
#define SeDebugPriv 20
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004)
#define NtCurrentProcess ( (HANDLE)(LONG_PTR) -1 ) 
#define ProcessHandleType 0x7
#define SystemHandleInformation 16 

/*
STRUCTURES NEEDED FOR NTOPENPROCESS:
*/
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWCH   Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

/*
STRUCTURES NEEDED FOR HANDLE INFORMATION:
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE; //i shortened it to SYSTEM_HANDLE for the sake of typing

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

/*
FUNCTION PROTOTYPES:
*/
typedef NTSTATUS(NTAPI* _NtDuplicateObject)(
	HANDLE SourceProcessHandle,
	HANDLE SourceHandle,
	HANDLE TargetProcessHandle,
	PHANDLE TargetHandle,
	ACCESS_MASK DesiredAccess,
	ULONG Attributes,
	ULONG Options
	);

typedef NTSTATUS(NTAPI* _RtlAdjustPrivilege)(
	ULONG Privilege,
	BOOLEAN Enable,
	BOOLEAN CurrentThread,
	PBOOLEAN Enabled
	);

typedef NTSYSAPI NTSTATUS(NTAPI* _NtOpenProcess)(
	PHANDLE            ProcessHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PCLIENT_ID         ClientId
	);

typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
	ULONG SystemInformationClass, //your supposed to supply the whole class but microsoft kept the enum mostly empty so I just passed 16 instead for handle info. Thats why you get a warning in your code btw
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

SYSTEM_HANDLE_INFORMATION* hInfo; //holds the handle information

//the handles we will need to use later on

namespace hj {
	HANDLE procHandle = NULL;
	HANDLE hProcess = NULL;
	HANDLE HijackedHandle = NULL;

	// simple function i made that will just initialize our Object_Attributes structure as NtOpenProcess will fail otherwise
	OBJECT_ATTRIBUTES InitObjectAttributes(PUNICODE_STRING name, ULONG attributes, HANDLE hRoot, PSECURITY_DESCRIPTOR security)
	{
		OBJECT_ATTRIBUTES object;

		object.Length = sizeof(OBJECT_ATTRIBUTES);
		object.ObjectName = name;
		object.Attributes = attributes;
		object.RootDirectory = hRoot;
		object.SecurityDescriptor = security;

		return object;
	}

	bool IsHandleValid(HANDLE handle) // i made this to simply check if a handle is valid rather than repeating the if statments
	{
		if (handle && handle != INVALID_HANDLE_VALUE)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	HANDLE HijackExistingHandle(DWORD dwTargetProcessId)
	{
		HMODULE Ntdll = GetModuleHandleA("ntdll"); // get the base address of ntdll.dll

		//get the address of RtlAdjustPrivilege in ntdll.dll so we can grant our process the highest permission possible
		_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(Ntdll, "RtlAdjustPrivilege");

		boolean OldPriv; //store the old privileges

		// Give our program SeDeugPrivileges whcih allows us to get a handle to every process, even the highest privileged SYSTEM level processes.
		RtlAdjustPrivilege(SeDebugPriv, TRUE, FALSE, &OldPriv);

		//get the address of NtQuerySystemInformation in ntdll.dll so we can find all the open handles on our system
		_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(Ntdll, "NtQuerySystemInformation");

		//get the address of NtDuplicateObject in ntdll.dll so we can duplicate an existing handle into our cheat, basically performing the hijacking
		_NtDuplicateObject NtDuplicateObject = (_NtDuplicateObject)GetProcAddress(Ntdll, "NtDuplicateObject");

		//get the address of NtOpenProcess in ntdll.dll so wecan create a Duplicate handle
		_NtOpenProcess NtOpenProcess = (_NtOpenProcess)GetProcAddress(Ntdll, "NtOpenProcess");


		//initialize the Object Attributes structure, you can just set each member to NULL rather than create a function like i did
		OBJECT_ATTRIBUTES Obj_Attribute = InitObjectAttributes(NULL, NULL, NULL, NULL);

		//clientID is a PDWORD or DWORD* of the process id to create a handle to
		CLIENT_ID clientID = { 0 };


		//the size variable is the amount of bytes allocated to store all the open handles
		DWORD size = sizeof(SYSTEM_HANDLE_INFORMATION);

		//we allocate the memory to store all the handles on the heap rather than the stack becuase of the large amount of data
		hInfo = (SYSTEM_HANDLE_INFORMATION*) new byte[size];

		//zero the memory handle info
		ZeroMemory(hInfo, size);

		//we use this for checking if the Native functions succeed
		NTSTATUS NtRet = NULL;

		do
		{
			// delete the previously allocated memory on the heap because it wasn't large enough to store all the handles
			delete[] hInfo;

			//increase the amount of memory allocated by 50%
			size *= 1.5;
			try
			{
				//set and allocate the larger size on the heap
				hInfo = (PSYSTEM_HANDLE_INFORMATION) new byte[size];
			}
			catch (std::bad_alloc) //catch a bad heap allocation.
			{
				procHandle ? CloseHandle(procHandle) : 0;
			}
			Sleep(1); //sleep for the cpu

			//we continue this loop until all the handles have been stored
		} while ((NtRet = NtQuerySystemInformation(SystemHandleInformation, hInfo, size, NULL)) == STATUS_INFO_LENGTH_MISMATCH);

		//check if we got all the open handles on our system
		if (!NT_SUCCESS(NtRet))
		{
			procHandle ? CloseHandle(procHandle) : 0;
		}


		//loop through each handle on our system, and filter out handles that are invalid or cant be hijacked
		for (unsigned int i = 0; i < hInfo->HandleCount; ++i)
		{
			//a variable to store the number of handles OUR cheat has open.
			static DWORD NumOfOpenHandles;

			//get the amount of outgoing handles OUR cheat has open
			GetProcessHandleCount(GetCurrentProcess(), &NumOfOpenHandles);

			//you can do a higher number if this is triggering false positives. Its just to make sure we dont fuck up and create thousands of handles
			if (NumOfOpenHandles > 50)
			{
				procHandle ? CloseHandle(procHandle) : 0;
			}

			//check if the current handle is valid, otherwise increment i and check the next handle
			if (!IsHandleValid((HANDLE)hInfo->Handles[i].Handle))
			{
				continue;
			}

			//check the handle type is 0x7 meaning a process handle so we dont hijack a file handle for example
			if (hInfo->Handles[i].ObjectTypeNumber != ProcessHandleType)
			{
				continue;
			}


			//set clientID to a pointer to the process with the handle to out target
			clientID.UniqueProcess = (DWORD*)hInfo->Handles[i].ProcessId;

			//if procHandle is open, close it
			procHandle ? CloseHandle(procHandle) : 0;

			//create a a handle with duplicate only permissions to the process with a handle to our target. NOT OUR TARGET.
			NtRet = NtOpenProcess(&procHandle, PROCESS_DUP_HANDLE, &Obj_Attribute, &clientID);
			if (!IsHandleValid(procHandle) || !NT_SUCCESS(NtRet)) //check is the funcions succeeded and check the handle is valid
			{
				continue;
			}


			//we duplicate the handle another process has to our target into our cheat with whatever permissions we want. I did all access.
			NtRet = NtDuplicateObject(procHandle, (HANDLE)hInfo->Handles[i].Handle, NtCurrentProcess, &HijackedHandle, PROCESS_ALL_ACCESS, 0, 0);
			if (!IsHandleValid(HijackedHandle) || !NT_SUCCESS(NtRet))//check is the funcions succeeded and check the handle is valid
			{

				continue;
			}

			//get the process id of the handle we duplicated and check its to our target
			if (GetProcessId(HijackedHandle) != dwTargetProcessId) {
				CloseHandle(HijackedHandle);
				continue;
			}



			hProcess = HijackedHandle;

			break;
		}

		procHandle ? CloseHandle(procHandle) : 0;

		return hProcess;
	}
}
```

`HPCS2/HPCS2/memory.cpp`:

```cpp
#include "memory.hpp"
#include <tlhelp32.h>
#include "handle_hijack.hpp"

uint32_t pProcess::FindProcessIdByProcessName(const char* ProcessName)
{
	std::wstring wideProcessName;
	int wideCharLength = MultiByteToWideChar(CP_UTF8, 0, ProcessName, -1, nullptr, 0);
	if (wideCharLength > 0)
	{
		wideProcessName.resize(wideCharLength);
		MultiByteToWideChar(CP_UTF8, 0, ProcessName, -1, &wideProcessName[0], wideCharLength);
	}

	HANDLE hPID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	PROCESSENTRY32W process_entry_{ };
	process_entry_.dwSize = sizeof(PROCESSENTRY32W);

	DWORD pid = 0;
	if (Process32FirstW(hPID, &process_entry_))
	{
		do
		{
			if (!wcscmp(process_entry_.szExeFile, wideProcessName.c_str()))
			{
				pid = process_entry_.th32ProcessID;
				break;
			}
		} while (Process32NextW(hPID, &process_entry_));
	}
	CloseHandle(hPID);
	return pid;
}

uint32_t pProcess::FindProcessIdByWindowName(const char* WindowName)
{
	DWORD process_id = 0;
	HWND windowHandle = FindWindowA(nullptr, WindowName);
	if (windowHandle)
		GetWindowThreadProcessId(windowHandle, &process_id);
	return process_id;
}

HWND pProcess::GetWindowHandleFromProcessId(DWORD ProcessId) {
	HWND hwnd = NULL;
	do {
		hwnd = FindWindowEx(NULL, hwnd, NULL, NULL);
		DWORD pid = 0;
		GetWindowThreadProcessId(hwnd, &pid);
		if (pid == ProcessId) {
			TCHAR windowTitle[MAX_PATH];
			GetWindowText(hwnd, windowTitle, MAX_PATH);
			if (IsWindowVisible(hwnd) && windowTitle[0] != '\0') {
				return hwnd;
			}
		}
	} while (hwnd != NULL);
	return NULL; // No main window found for the given process ID
}

bool pProcess::AttachProcess(const char* ProcessName)
{
	this->pid_ = this->FindProcessIdByProcessName(ProcessName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;

		handle_ = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid_);

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}

	return false;
}

bool pProcess::AttachProcessHj(const char* ProcessName)
{
	this->pid_ = this->FindProcessIdByProcessName(ProcessName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;


		// Using Apxaey's handle hijack function to safely open a handle
		handle_ = hj::HijackExistingHandle(pid_);

		if (!hj::IsHandleValid(handle_))
		{
			std::cout << "[cheat] Handle Hijack failed, falling back to OpenProcess method." << std::endl;
			return pProcess::AttachProcess(ProcessName); // Handle hijacking failed, so we fall back to the normal OpenProcess method
		}

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}

	return false;
}


bool pProcess::AttachWindow(const char* WindowName)
{
	this->pid_ = this->FindProcessIdByWindowName(WindowName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;

		handle_ = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid_);

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}
	return false;
}

bool pProcess::UpdateHWND()
{
	hwnd_ = this->GetWindowHandleFromProcessId(pid_);
	return hwnd_ == nullptr;
}

ProcessModule pProcess::GetModule(const char* lModule)
{
	std::wstring wideModule;
	int wideCharLength = MultiByteToWideChar(CP_UTF8, 0, lModule, -1, nullptr, 0);
	if (wideCharLength > 0)
	{
		wideModule.resize(wideCharLength);
		MultiByteToWideChar(CP_UTF8, 0, lModule, -1, &wideModule[0], wideCharLength);
	}

	HANDLE handle_module = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid_);
	MODULEENTRY32W module_entry_{};
	module_entry_.dwSize = sizeof(MODULEENTRY32W);

	do
	{
		if (!wcscmp(module_entry_.szModule, wideModule.c_str()))
		{
			CloseHandle(handle_module);
			return { (DWORD_PTR)module_entry_.modBaseAddr, module_entry_.dwSize };
		}
	} while (Module32NextW(handle_module, &module_entry_));

	CloseHandle(handle_module);
	return { 0, 0 };
}

LPVOID pProcess::Allocate(size_t size_in_bytes)
{
	return VirtualAllocEx(this->handle_, NULL, size_in_bytes, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

uintptr_t pProcess::FindSignature(std::vector<uint8_t> signature)
{
	std::unique_ptr<uint8_t[]> data;
	data = std::make_unique<uint8_t[]>(this->base_client_.size);

	if (!ReadProcessMemory(this->handle_, (void*)(this->base_client_.base), data.get(), this->base_client_.size, NULL)) {
		return 0x0;
	}

	for (uintptr_t i = 0; i < this->base_client_.size; i++)
	{
		for (uintptr_t j = 0; j < signature.size(); j++)
		{
			if (signature.at(j) == 0x00)
				continue;

			if (*reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(&data[i + j])) == signature.at(j))
			{
				if (j == signature.size() - 1)
					return this->base_client_.base + i;
				continue;
			}
			break;
		}
	}
	return 0x0;
}

uintptr_t pProcess::FindSignature(ProcessModule target_module, std::vector<uint8_t> signature)
{
	std::unique_ptr<uint8_t[]> data;
	data = std::make_unique<uint8_t[]>(0xFFFFFFF);

	if (!ReadProcessMemory(this->handle_, (void*)(target_module.base), data.get(), 0xFFFFFFF, NULL)) {
		return NULL;
	}

	for (uintptr_t i = 0; i < 0xFFFFFFF; i++)
	{
		for (uintptr_t j = 0; j < signature.size(); j++)
		{
			if (signature.at(j) == 0x00)
				continue;

			if (*reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(&data[i + j])) == signature.at(j))
			{
				if (j == signature.size() - 1)
					return this->base_client_.base + i;
				continue;
			}
			break;
		}
	}
	return 0x0;
}

uintptr_t pProcess::FindCodeCave(uint32_t length_in_bytes)
{
	std::vector<uint8_t> cave_pattern = {};

	for (uint32_t i = 0; i < length_in_bytes; i++) {
		cave_pattern.push_back(0x00);
	}

	return FindSignature(cave_pattern);
}

void pProcess::Close()
{
	CloseHandle(handle_);
}
```

`HPCS2/HPCS2/memory.hpp`:

```hpp
#ifndef _PPROCESS_HPP_
#define _PPROCESS_HPP_

#include <vector>
#include <math.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#include <iostream>
#include <Psapi.h> 

typedef NTSTATUS(WINAPI* pNtReadVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesRead);
typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten);

class pMemory {

public:
	pMemory() {
		pfnNtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtReadVirtualMemory");
		pfnNtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");
	}

	pNtReadVirtualMemory pfnNtReadVirtualMemory;
	pNtWriteVirtualMemory pfnNtWriteVirtualMemory;
};

struct ProcessModule
{
	uintptr_t base, size;
};

class pProcess
{
public:
	DWORD		  pid_; // process id
	HANDLE		  handle_; // handle to process
	HWND		  hwnd_; // window handle
	ProcessModule base_client_;

public:
	bool AttachProcess(const char* process_name);
	bool AttachProcessHj(const char* process_name);
	bool AttachWindow(const char* window_name);
	bool UpdateHWND();
	void Close();

public:
	ProcessModule GetModule(const char* module_name);
	LPVOID		  Allocate(size_t size_in_bytes);
	uintptr_t	  FindCodeCave(uint32_t length_in_bytes);
	uintptr_t     FindSignature(std::vector<uint8_t> signature);
	uintptr_t     FindSignature(ProcessModule target_module, std::vector<uint8_t> signature);

	template<class T>
	uintptr_t ReadOffsetFromSignature(std::vector<uint8_t> signature, uint8_t offset) // offset example: "FF 05 ->22628B01<-" offset is 2
	{
		uintptr_t pattern_address = this->FindSignature(signature);
		if (!pattern_address)
			return 0x0;

		T offset_value = this->read<T>(pattern_address + offset);
		return pattern_address + offset_value + offset + sizeof(T);
	}

	bool read_raw(uintptr_t address, void* buffer, size_t size)
	{
		SIZE_T bytesRead;
		pMemory cMemory;

		if (cMemory.pfnNtReadVirtualMemory(this->handle_, (PVOID)(address), buffer, static_cast<ULONG>(size), (PULONG)&bytesRead))
		{
			return bytesRead == size;
		}
		return false;
	}

	template<class T>
	void write(uintptr_t address, T value)
	{
		pMemory cMemory;
		cMemory.pfnNtWriteVirtualMemory(handle_, (void*)address, &value, sizeof(T), 0);
	}

	template<class T>
	T read(uintptr_t address)
	{
		T buffer{};
		pMemory cMemory;

		cMemory.pfnNtReadVirtualMemory(handle_, (void*)address, &buffer, sizeof(T), 0);
		return buffer;
	}

	void write_bytes(uintptr_t addr, std::vector<uint8_t> patch)
	{
		pMemory cMemory;
		cMemory.pfnNtWriteVirtualMemory(handle_, (void*)addr, &patch[0], patch.size(), 0);
	}

	uintptr_t read_multi_address(uintptr_t ptr, std::vector<uintptr_t> offsets)
	{
		uintptr_t buffer = ptr;
		for (int i = 0; i < offsets.size(); i++)
			buffer = this->read<uintptr_t>(buffer + offsets[i]);

		return buffer;
	}

	template <typename T>
	T read_multi(uintptr_t base, std::vector<uintptr_t> offsets) {
		uintptr_t buffer = base;
		for (int i = 0; i < offsets.size() - 1; i++)
		{
			buffer = this->read<uintptr_t>(buffer + offsets[i]);
		}
		return this->read<T>(buffer + offsets.back());
	}

private:
	uint32_t FindProcessIdByProcessName(const char* process_name);
	uint32_t FindProcessIdByWindowName(const char* window_name);
	HWND GetWindowHandleFromProcessId(DWORD ProcessId);
};
#endif
```

`HPCS2/HPCS2/offset/animationsystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace AimMatrixOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_poseCacheHandles = 0x90; // CPoseHandle[10]
    constexpr std::ptrdiff_t m_eBlendMode = 0xB8; // AimMatrixBlendMode
    constexpr std::ptrdiff_t m_fAngleIncrement = 0xBC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nBoneMaskIndex = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xC8; // bool
}

namespace AnimComponentID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeOutputID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimParamID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimScriptHandle {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimStateID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimTagID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimationDecodeDebugDumpElement_t {
    constexpr std::ptrdiff_t m_nEntityIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_poseParams = 0x10; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodeOps = 0x28; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_internalOps = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodedAnims = 0x58; // CUtlVector<CUtlString>
}

namespace AnimationDecodeDebugDump_t {
    constexpr std::ptrdiff_t m_processingType = 0x0; // AnimationProcessingType_t
    constexpr std::ptrdiff_t m_elems = 0x8; // CUtlVector<AnimationDecodeDebugDumpElement_t>
}

namespace AnimationSnapshotBase_t {
    constexpr std::ptrdiff_t m_flRealTime = 0x0; // float
    constexpr std::ptrdiff_t m_rootToWorld = 0x10; // matrix3x4a_t
    constexpr std::ptrdiff_t m_bBonesInWorldSpace = 0x40; // bool
    constexpr std::ptrdiff_t m_boneSetupMask = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneTransforms = 0x60; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_flexControllers = 0x78; // CUtlVector<float>
    constexpr std::ptrdiff_t m_SnapshotType = 0x90; // AnimationSnapshotType_t
    constexpr std::ptrdiff_t m_bHasDecodeDump = 0x94; // bool
    constexpr std::ptrdiff_t m_DecodeDump = 0x98; // AnimationDecodeDebugDumpElement_t
}

namespace AnimationSnapshot_t { // AnimationSnapshotBase_t
    constexpr std::ptrdiff_t m_nEntIndex = 0x110; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x118; // CUtlString
}

namespace AttachmentHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint8_t
}

namespace BlendItem_t {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pChild = 0x18; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hSequence = 0x28; // HSequence
    constexpr std::ptrdiff_t m_vPos = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_flDuration = 0x34; // float
    constexpr std::ptrdiff_t m_bUseCustomDuration = 0x38; // bool
}

namespace BoneDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flChainLength = 0x8; // float
}

namespace CActionComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_actions = 0x30; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
}

namespace CAddUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CAimConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_qAimOffset = 0x70; // Quaternion
    constexpr std::ptrdiff_t m_nUpType = 0x80; // uint32_t
}

namespace CAimMatrixUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // AimMatrixOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x148; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x14C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSequence = 0x150; // HSequence
    constexpr std::ptrdiff_t m_bResetChild = 0x154; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x155; // bool
}

namespace CAnimActionUpdater {
}

namespace CAnimActivity {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nActivity = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nWeight = 0x18; // int32_t
}

namespace CAnimAttachment {
    constexpr std::ptrdiff_t m_influenceRotations = 0x0; // Quaternion[3]
    constexpr std::ptrdiff_t m_influenceOffsets = 0x30; // VectorAligned[3]
    constexpr std::ptrdiff_t m_influenceIndices = 0x60; // int32_t[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x6C; // float[3]
    constexpr std::ptrdiff_t m_numInfluences = 0x78; // uint8_t
}

namespace CAnimBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // int32_t
    constexpr std::ptrdiff_t m_pos = 0x14; // Vector
    constexpr std::ptrdiff_t m_quat = 0x20; // QuaternionStorage
    constexpr std::ptrdiff_t m_scale = 0x30; // float
    constexpr std::ptrdiff_t m_qAlignment = 0x34; // QuaternionStorage
    constexpr std::ptrdiff_t m_flags = 0x44; // int32_t
}

namespace CAnimBoneDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_posError = 0x20; // Vector
    constexpr std::ptrdiff_t m_bHasRotation = 0x2C; // bool
    constexpr std::ptrdiff_t m_bHasMovement = 0x2D; // bool
}

namespace CAnimComponentUpdater {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimComponentID
    constexpr std::ptrdiff_t m_networkMode = 0x24; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_bStartEnabled = 0x28; // bool
}

namespace CAnimCycle { // CCycleBase
}

namespace CAnimData {
    constexpr std::ptrdiff_t m_name = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_animArray = 0x20; // CUtlVector<CAnimDesc>
    constexpr std::ptrdiff_t m_decoderArray = 0x38; // CUtlVector<CAnimDecoder>
    constexpr std::ptrdiff_t m_nMaxUniqueFrameIndex = 0x50; // int32_t
    constexpr std::ptrdiff_t m_segmentArray = 0x58; // CUtlVector<CAnimFrameSegment>
}

namespace CAnimDataChannelDesc {
    constexpr std::ptrdiff_t m_szChannelClass = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_szVariableName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x24; // int32_t
    constexpr std::ptrdiff_t m_szGrouping = 0x28; // CBufferString
    constexpr std::ptrdiff_t m_szDescription = 0x38; // CBufferString
    constexpr std::ptrdiff_t m_szElementNameArray = 0x48; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nElementIndexArray = 0x60; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nElementMaskArray = 0x78; // CUtlVector<uint32_t>
}

namespace CAnimDecoder {
    constexpr std::ptrdiff_t m_szName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nVersion = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x14; // int32_t
}

namespace CAnimDemoCaptureSettings {
    constexpr std::ptrdiff_t m_rangeBoneChainLength = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_rangeMaxSplineErrorRotation = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_flMaxSplineErrorTranslation = 0x10; // float
    constexpr std::ptrdiff_t m_flMaxSplineErrorScale = 0x14; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxSplineError = 0x18; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxSplineError = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorRotation = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorTranslation = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorScale = 0x28; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxQuantizationError = 0x2C; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxQuantizationError = 0x30; // float
    constexpr std::ptrdiff_t m_baseSequence = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_nBaseSequenceFrame = 0x40; // int32_t
    constexpr std::ptrdiff_t m_boneSelectionMode = 0x44; // EDemoBoneSelectionMode
    constexpr std::ptrdiff_t m_bones = 0x48; // CUtlVector<BoneDemoCaptureSettings_t>
    constexpr std::ptrdiff_t m_ikChains = 0x60; // CUtlVector<IKDemoCaptureSettings_t>
}

namespace CAnimDesc {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CAnimDesc_Flag
    constexpr std::ptrdiff_t fps = 0x18; // float
    constexpr std::ptrdiff_t m_Data = 0x20; // CAnimEncodedFrames
    constexpr std::ptrdiff_t m_movementArray = 0xF8; // CUtlVector<CAnimMovement>
    constexpr std::ptrdiff_t m_eventArray = 0x110; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x128; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_hierarchyArray = 0x140; // CUtlVector<CAnimLocalHierarchy>
    constexpr std::ptrdiff_t framestalltime = 0x158; // float
    constexpr std::ptrdiff_t m_vecRootMin = 0x15C; // Vector
    constexpr std::ptrdiff_t m_vecRootMax = 0x168; // Vector
    constexpr std::ptrdiff_t m_vecBoneWorldMin = 0x178; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vecBoneWorldMax = 0x190; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_sequenceParams = 0x1A8; // CAnimSequenceParams
}

namespace CAnimDesc_Flag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bAllZeros = 0x1; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x2; // bool
    constexpr std::ptrdiff_t m_bDelta = 0x3; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x4; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0x5; // bool
    constexpr std::ptrdiff_t m_bImplicitSeqIgnoreDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bAnimGraphAdditive = 0x7; // bool
}

namespace CAnimEncodeDifference {
    constexpr std::ptrdiff_t m_boneArray = 0x0; // CUtlVector<CAnimBoneDifference>
    constexpr std::ptrdiff_t m_morphArray = 0x18; // CUtlVector<CAnimMorphDifference>
    constexpr std::ptrdiff_t m_userArray = 0x30; // CUtlVector<CAnimUserDifference>
    constexpr std::ptrdiff_t m_bHasRotationBitArray = 0x48; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMovementBitArray = 0x60; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMorphBitArray = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasUserBitArray = 0x90; // CUtlVector<uint8_t>
}

namespace CAnimEncodedFrames {
    constexpr std::ptrdiff_t m_fileName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nFrames = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFramesPerBlock = 0x14; // int32_t
    constexpr std::ptrdiff_t m_frameblockArray = 0x18; // CUtlVector<CAnimFrameBlockAnim>
    constexpr std::ptrdiff_t m_usageDifferences = 0x30; // CAnimEncodeDifference
}

namespace CAnimEnum {
    constexpr std::ptrdiff_t m_value = 0x0; // uint8_t
}

namespace CAnimEventDefinition {
    constexpr std::ptrdiff_t m_nFrame = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xC; // float
    constexpr std::ptrdiff_t m_EventData = 0x10; // KeyValues3
    constexpr std::ptrdiff_t m_sLegacyOptions = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_sEventName = 0x30; // CGlobalSymbol
}

namespace CAnimFoot {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x8; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_ankleBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_toeBoneIndex = 0x24; // int32_t
}

namespace CAnimFrameBlockAnim {
    constexpr std::ptrdiff_t m_nStartFrame = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x4; // int32_t
    constexpr std::ptrdiff_t m_segmentIndexArray = 0x8; // CUtlVector<int32_t>
}

namespace CAnimFrameSegment {
    constexpr std::ptrdiff_t m_nUniqueFrameIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nLocalElementMasks = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nLocalChannel = 0x8; // int32_t
    constexpr std::ptrdiff_t m_container = 0x10; // CUtlBinaryBlock
}

namespace CAnimGraphDebugReplay {
    constexpr std::ptrdiff_t m_animGraphFileName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_frameList = 0x48; // CUtlVector<CSmartPtr<CAnimReplayFrame>>
    constexpr std::ptrdiff_t m_startIndex = 0x60; // int32_t
    constexpr std::ptrdiff_t m_writeIndex = 0x64; // int32_t
    constexpr std::ptrdiff_t m_frameCount = 0x68; // int32_t
}

namespace CAnimGraphModelBinding {
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_pSharedData = 0x10; // CSmartPtr<CAnimUpdateSharedData>
}

namespace CAnimGraphNetworkSettings { // CAnimGraphSettingsGroup
    constexpr std::ptrdiff_t m_bNetworkingEnabled = 0x20; // bool
}

namespace CAnimGraphSettingsGroup {
}

namespace CAnimGraphSettingsManager {
    constexpr std::ptrdiff_t m_settingsGroups = 0x18; // CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>
}

namespace CAnimInputDamping {
    constexpr std::ptrdiff_t m_speedFunction = 0x8; // DampingSpeedFunction
    constexpr std::ptrdiff_t m_fSpeedScale = 0xC; // float
}

namespace CAnimKeyData {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_boneArray = 0x10; // CUtlVector<CAnimBone>
    constexpr std::ptrdiff_t m_userArray = 0x28; // CUtlVector<CAnimUser>
    constexpr std::ptrdiff_t m_morphArray = 0x40; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nChannelElements = 0x58; // int32_t
    constexpr std::ptrdiff_t m_dataChannelArray = 0x60; // CUtlVector<CAnimDataChannelDesc>
}

namespace CAnimLocalHierarchy {
    constexpr std::ptrdiff_t m_sBone = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sNewParent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nStartFrame = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nPeakFrame = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nTailFrame = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x2C; // int32_t
}

namespace CAnimMorphDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
}

namespace CAnimMotorUpdaterBase {
    constexpr std::ptrdiff_t m_name = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDefault = 0x18; // bool
}

namespace CAnimMovement {
    constexpr std::ptrdiff_t endframe = 0x0; // int32_t
    constexpr std::ptrdiff_t motionflags = 0x4; // int32_t
    constexpr std::ptrdiff_t v0 = 0x8; // float
    constexpr std::ptrdiff_t v1 = 0xC; // float
    constexpr std::ptrdiff_t angle = 0x10; // float
    constexpr std::ptrdiff_t vector = 0x14; // Vector
    constexpr std::ptrdiff_t position = 0x20; // Vector
}

namespace CAnimNodePath {
    constexpr std::ptrdiff_t m_path = 0x0; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nCount = 0x2C; // int32_t
}

namespace CAnimParamHandle {
    constexpr std::ptrdiff_t m_type = 0x0; // AnimParamType_t
    constexpr std::ptrdiff_t m_index = 0x1; // uint8_t
}

namespace CAnimParamHandleMap {
    constexpr std::ptrdiff_t m_list = 0x0; // CUtlHashtable<uint16_t,int16_t>
}

namespace CAnimParameterBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x28; // AnimParamID
    constexpr std::ptrdiff_t m_componentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_bNetworkingRequested = 0x4C; // bool
    constexpr std::ptrdiff_t m_bIsReferenced = 0x4D; // bool
}

namespace CAnimParameterManagerUpdater {
    constexpr std::ptrdiff_t m_parameters = 0x18; // CUtlVector<CSmartPtr<CAnimParameterBase>>
    constexpr std::ptrdiff_t m_idToIndexMap = 0x30; // CUtlHashtable<AnimParamID,int32_t>
    constexpr std::ptrdiff_t m_nameToIndexMap = 0x50; // CUtlHashtable<CUtlString,int32_t>
    constexpr std::ptrdiff_t m_indexToHandle = 0x70; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_autoResetParams = 0x88; // CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    constexpr std::ptrdiff_t m_autoResetMap = 0xA0; // CUtlHashtable<CAnimParamHandle,int16_t>
}

namespace CAnimReplayFrame {
    constexpr std::ptrdiff_t m_inputDataBlocks = 0x10; // CUtlVector<CUtlBinaryBlock>
    constexpr std::ptrdiff_t m_instanceData = 0x28; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_startingLocalToWorldTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_localToWorldTransform = 0x60; // CTransform
    constexpr std::ptrdiff_t m_timeStamp = 0x80; // float
}

namespace CAnimScriptComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_hScript = 0x30; // AnimScriptHandle
}

namespace CAnimScriptManager {
    constexpr std::ptrdiff_t m_scriptInfo = 0x10; // CUtlVector<ScriptInfo_t>
}

namespace CAnimSequenceParams {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CAnimSkeleton {
    constexpr std::ptrdiff_t m_localSpaceTransforms = 0x10; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_modelSpaceTransforms = 0x28; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_boneNames = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_parents = 0x70; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_feet = 0x88; // CUtlVector<CAnimFoot>
    constexpr std::ptrdiff_t m_morphNames = 0xA0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_lodBoneCounts = 0xB8; // CUtlVector<int32_t>
}

namespace CAnimStateMachineUpdater {
    constexpr std::ptrdiff_t m_states = 0x8; // CUtlVector<CStateUpdateData>
    constexpr std::ptrdiff_t m_transitions = 0x20; // CUtlVector<CTransitionUpdateData>
    constexpr std::ptrdiff_t m_startStateIndex = 0x50; // int32_t
}

namespace CAnimTagBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CGlobalSymbol
    constexpr std::ptrdiff_t m_tagID = 0x28; // AnimTagID
    constexpr std::ptrdiff_t m_bIsReferenced = 0x2C; // bool
}

namespace CAnimTagManagerUpdater {
    constexpr std::ptrdiff_t m_tags = 0x18; // CUtlVector<CSmartPtr<CAnimTagBase>>
}

namespace CAnimUpdateNodeBase {
    constexpr std::ptrdiff_t m_nodePath = 0x18; // CAnimNodePath
    constexpr std::ptrdiff_t m_networkMode = 0x48; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_name = 0x50; // CUtlString
}

namespace CAnimUpdateNodeRef {
    constexpr std::ptrdiff_t m_nodeIndex = 0x8; // int32_t
}

namespace CAnimUpdateSharedData {
    constexpr std::ptrdiff_t m_nodes = 0x10; // CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    constexpr std::ptrdiff_t m_nodeIndexMap = 0x28; // CUtlHashtable<CAnimNodePath,int32_t>
    constexpr std::ptrdiff_t m_components = 0x48; // CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    constexpr std::ptrdiff_t m_pParamListUpdater = 0x60; // CSmartPtr<CAnimParameterManagerUpdater>
    constexpr std::ptrdiff_t m_pTagManagerUpdater = 0x68; // CSmartPtr<CAnimTagManagerUpdater>
    constexpr std::ptrdiff_t m_scriptManager = 0x70; // CSmartPtr<CAnimScriptManager>
    constexpr std::ptrdiff_t m_settings = 0x78; // CAnimGraphSettingsManager
    constexpr std::ptrdiff_t m_pStaticPoseCache = 0xA8; // CSmartPtr<CStaticPoseCacheBuilder>
    constexpr std::ptrdiff_t m_pSkeleton = 0xB0; // CSmartPtr<CAnimSkeleton>
    constexpr std::ptrdiff_t m_rootNodePath = 0xB8; // CAnimNodePath
}

namespace CAnimUser {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimUserDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimationGraphVisualizerAxis { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_xWsTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_flAxisSize = 0x60; // float
}

namespace CAnimationGraphVisualizerLine { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPositionStart = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsPositionEnd = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x60; // Color
}

namespace CAnimationGraphVisualizerPie { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsCenter = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsStart = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_vWsEnd = 0x60; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x70; // Color
}

namespace CAnimationGraphVisualizerPrimitiveBase {
    constexpr std::ptrdiff_t m_Type = 0x8; // CAnimationGraphVisualizerPrimitiveType
    constexpr std::ptrdiff_t m_OwningAnimNodePaths = 0xC; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nOwningAnimNodePathCount = 0x38; // int32_t
}

namespace CAnimationGraphVisualizerSphere { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_flRadius = 0x50; // float
    constexpr std::ptrdiff_t m_Color = 0x54; // Color
}

namespace CAnimationGraphVisualizerText { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x50; // Color
    constexpr std::ptrdiff_t m_Text = 0x58; // CUtlString
}

namespace CAnimationGroup {
    constexpr std::ptrdiff_t m_nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CBufferString
    constexpr std::ptrdiff_t m_localHAnimArray_Handle = 0x60; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    constexpr std::ptrdiff_t m_includedGroupArray_Handle = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_directHSeqGroup_Handle = 0x90; // CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    constexpr std::ptrdiff_t m_decodeKey = 0x98; // CAnimKeyData
    constexpr std::ptrdiff_t m_szScripts = 0x110; // CUtlVector<CBufferString>
}

namespace CAttachment {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_influenceNames = 0x8; // CUtlString[3]
    constexpr std::ptrdiff_t m_vInfluenceRotations = 0x20; // Quaternion[3]
    constexpr std::ptrdiff_t m_vInfluenceOffsets = 0x50; // Vector[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x74; // float[3]
    constexpr std::ptrdiff_t m_bInfluenceRootTransform = 0x80; // bool[3]
    constexpr std::ptrdiff_t m_nInfluences = 0x83; // uint8_t
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x84; // bool
}

namespace CAudioAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_clipName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_attachmentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flVolume = 0x48; // float
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x4C; // bool
    constexpr std::ptrdiff_t m_bStopWhenGraphEnds = 0x4D; // bool
    constexpr std::ptrdiff_t m_bPlayOnServer = 0x4E; // bool
    constexpr std::ptrdiff_t m_bPlayOnClient = 0x4F; // bool
}

namespace CBaseConstraint { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_name = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vUpVector = 0x30; // Vector
    constexpr std::ptrdiff_t m_slaves = 0x40; // CUtlVector<CConstraintSlave>
    constexpr std::ptrdiff_t m_targets = 0x58; // CUtlVector<CConstraintTarget>
}

namespace CBinaryUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_pChild1 = 0x58; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_pChild2 = 0x68; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_timingBehavior = 0x78; // BinaryNodeTiming
    constexpr std::ptrdiff_t m_flTimingBlend = 0x7C; // float
    constexpr std::ptrdiff_t m_bResetChild1 = 0x80; // bool
    constexpr std::ptrdiff_t m_bResetChild2 = 0x81; // bool
}

namespace CBindPoseUpdateNode { // CLeafUpdateNode
}

namespace CBlend2DUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_items = 0x60; // CUtlVector<BlendItem_t>
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_paramSpans = 0x90; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_nodeItemIndices = 0xA8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_damping = 0xC0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSourceX = 0xD0; // AnimValueSource
    constexpr std::ptrdiff_t m_paramX = 0xD4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_blendSourceY = 0xD8; // AnimValueSource
    constexpr std::ptrdiff_t m_paramY = 0xDC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eBlendMode = 0xE0; // Blend2DMode
    constexpr std::ptrdiff_t m_playbackSpeed = 0xE4; // float
    constexpr std::ptrdiff_t m_bLoop = 0xE8; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xE9; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xEA; // bool
    constexpr std::ptrdiff_t m_bAnimEventsAndTagsOnMostWeightedOnly = 0xEB; // bool
}

namespace CBlendCurve {
    constexpr std::ptrdiff_t m_flControlPoint1 = 0x0; // float
    constexpr std::ptrdiff_t m_flControlPoint2 = 0x4; // float
}

namespace CBlendUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x60; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_sortedOrder = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_targetValues = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendValueSource = 0xAC; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0xB0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_damping = 0xB8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendKeyType = 0xC8; // BlendKeyType
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xCC; // bool
    constexpr std::ptrdiff_t m_bSyncCycles = 0xCD; // bool
    constexpr std::ptrdiff_t m_bLoop = 0xCE; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xCF; // bool
}

namespace CBlockSelectionMetricEvaluator { // CMotionMetricEvaluator
}

namespace CBodyGroupAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_nPriority = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bodyGroupSettings = 0x40; // CUtlVector<CBodyGroupSetting>
}

namespace CBodyGroupSetting {
    constexpr std::ptrdiff_t m_BodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nBodyGroupOption = 0x8; // int32_t
}

namespace CBoneConstraintBase {
}

namespace CBoneConstraintDotToMorph { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sTargetBoneName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_sMorphChannelName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_flRemap = 0x40; // float[4]
}

namespace CBoneConstraintPoseSpaceBone { // CBaseConstraint
    constexpr std::ptrdiff_t m_inputList = 0x70; // CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>
}

namespace CBoneConstraintPoseSpaceBone_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputTransformList = 0x10; // CUtlVector<CTransform>
}

namespace CBoneConstraintPoseSpaceMorph { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sAttachmentName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outputMorph = 0x38; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_inputList = 0x50; // CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    constexpr std::ptrdiff_t m_bClamp = 0x68; // bool
}

namespace CBoneConstraintPoseSpaceMorph_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputWeightList = 0x10; // CUtlVector<float>
}

namespace CBoneMaskUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_flRootMotionBlend = 0x90; // float
    constexpr std::ptrdiff_t m_blendSpace = 0x94; // BoneMaskBlendSpace
    constexpr std::ptrdiff_t m_footMotionTiming = 0x98; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bUseBlendScale = 0x9C; // bool
    constexpr std::ptrdiff_t m_blendValueSource = 0xA0; // AnimValueSource
    constexpr std::ptrdiff_t m_hBlendParameter = 0xA4; // CAnimParamHandle
}

namespace CBonePositionMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoneVelocityMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoolAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_bDefaultValue = 0x60; // bool
}

namespace CCPPScriptComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_scriptsToRun = 0x30; // CUtlVector<CGlobalSymbol>
}

namespace CCachedPose {
    constexpr std::ptrdiff_t m_transforms = 0x8; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_morphWeights = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_hSequence = 0x38; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x3C; // float
}

namespace CChoiceUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_weights = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendTimes = 0x88; // CUtlVector<float>
    constexpr std::ptrdiff_t m_choiceMethod = 0xA0; // ChoiceMethod
    constexpr std::ptrdiff_t m_choiceChangeMethod = 0xA4; // ChoiceChangeMethod
    constexpr std::ptrdiff_t m_blendMethod = 0xA8; // ChoiceBlendMethod
    constexpr std::ptrdiff_t m_blendTime = 0xAC; // float
    constexpr std::ptrdiff_t m_bCrossFade = 0xB0; // bool
    constexpr std::ptrdiff_t m_bResetChosen = 0xB1; // bool
    constexpr std::ptrdiff_t m_bDontResetSameSelection = 0xB2; // bool
}

namespace CChoreoUpdateNode { // CUnaryUpdateNode
}

namespace CClothSettingsAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_flStiffness = 0x38; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x3C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x40; // float
    constexpr std::ptrdiff_t m_nVertexSet = 0x48; // CUtlString
}

namespace CCompressorGroup {
    constexpr std::ptrdiff_t m_nTotalElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_szChannelClass = 0x8; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_szVariableName = 0x20; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_nType = 0x38; // CUtlVector<fieldtype_t>
    constexpr std::ptrdiff_t m_nFlags = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szGrouping = 0x68; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nCompressorIndex = 0x80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szElementNames = 0x98; // CUtlVector<CUtlVector<char*>>
    constexpr std::ptrdiff_t m_nElementUniqueID = 0xB0; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_nElementMask = 0xC8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_vectorCompressor = 0xF8; // CUtlVector<CCompressor<Vector>*>
    constexpr std::ptrdiff_t m_quaternionCompressor = 0x110; // CUtlVector<CCompressor<QuaternionStorage>*>
    constexpr std::ptrdiff_t m_intCompressor = 0x128; // CUtlVector<CCompressor<int32_t>*>
    constexpr std::ptrdiff_t m_boolCompressor = 0x140; // CUtlVector<CCompressor<bool>*>
    constexpr std::ptrdiff_t m_colorCompressor = 0x158; // CUtlVector<CCompressor<Color>*>
    constexpr std::ptrdiff_t m_vector2DCompressor = 0x170; // CUtlVector<CCompressor<Vector2D>*>
    constexpr std::ptrdiff_t m_vector4DCompressor = 0x188; // CUtlVector<CCompressor<Vector4D>*>
}

namespace CConcreteAnimParameter { // CAnimParameterBase
    constexpr std::ptrdiff_t m_previewButton = 0x50; // AnimParamButton_t
    constexpr std::ptrdiff_t m_eNetworkSetting = 0x54; // AnimParamNetworkSetting
    constexpr std::ptrdiff_t m_bUseMostRecentValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bAutoReset = 0x59; // bool
    constexpr std::ptrdiff_t m_bGameWritable = 0x5A; // bool
    constexpr std::ptrdiff_t m_bGraphWritable = 0x5B; // bool
}

namespace CConstraintSlave {
    constexpr std::ptrdiff_t m_qBaseOrientation = 0x0; // Quaternion
    constexpr std::ptrdiff_t m_vBasePosition = 0x10; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x1C; // uint32_t
    constexpr std::ptrdiff_t m_flWeight = 0x20; // float
    constexpr std::ptrdiff_t m_sName = 0x28; // CUtlString
}

namespace CConstraintTarget {
    constexpr std::ptrdiff_t m_qOffset = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_vOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_sName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_bIsAttachment = 0x59; // bool
}

namespace CCurrentRotationVelocityMetricEvaluator { // CMotionMetricEvaluator
}

namespace CCurrentVelocityMetricEvaluator { // CMotionMetricEvaluator
}

namespace CCycleBase {
    constexpr std::ptrdiff_t m_flCycle = 0x0; // float
}

namespace CCycleControlClipUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_tags = 0x60; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x7C; // HSequence
    constexpr std::ptrdiff_t m_duration = 0x80; // float
    constexpr std::ptrdiff_t m_valueSource = 0x84; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x88; // CAnimParamHandle
}

namespace CCycleControlUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_valueSource = 0x68; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x6C; // CAnimParamHandle
}

namespace CDampedPathAnimMotorUpdater { // CPathAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_flAnticipationTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flMinSpeedScale = 0x30; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flSpringConstant = 0x38; // float
    constexpr std::ptrdiff_t m_flMinSpringTension = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxSpringTension = 0x40; // float
}

namespace CDampedValueComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_items = 0x30; // CUtlVector<CDampedValueUpdateItem>
}

namespace CDampedValueUpdateItem {
    constexpr std::ptrdiff_t m_damping = 0x0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_hParamIn = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hParamOut = 0x1A; // CAnimParamHandle
}

namespace CDemoSettingsComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_settings = 0x30; // CAnimDemoCaptureSettings
}

namespace CDirectPlaybackTagData {
    constexpr std::ptrdiff_t m_sequenceName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_tags = 0x8; // CUtlVector<TagSpan_t>
}

namespace CDirectPlaybackUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_bFinishEarly = 0x6C; // bool
    constexpr std::ptrdiff_t m_bResetOnFinish = 0x6D; // bool
    constexpr std::ptrdiff_t m_allTags = 0x70; // CUtlVector<CDirectPlaybackTagData>
}

namespace CDirectionalBlendUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_hSequences = 0x5C; // HSequence[8]
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendValueSource = 0x90; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x94; // CAnimParamHandle
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xA1; // bool
}

namespace CDistanceRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flMaxDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flMinDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flStartGoalFilterDistance = 0x58; // float
    constexpr std::ptrdiff_t m_flMaxGoalOvershootScale = 0x5C; // float
    constexpr std::ptrdiff_t m_bFilterFixedMinDistance = 0x60; // bool
    constexpr std::ptrdiff_t m_bFilterGoalDistance = 0x61; // bool
    constexpr std::ptrdiff_t m_bFilterGoalOvershoot = 0x62; // bool
}

namespace CDrawCullingData {
    constexpr std::ptrdiff_t m_vConeApex = 0x0; // Vector
    constexpr std::ptrdiff_t m_ConeAxis = 0xC; // int8_t[3]
    constexpr std::ptrdiff_t m_ConeCutoff = 0xF; // int8_t
}

namespace CEditableMotionGraph { // CMotionGraph
}

namespace CEmitTagActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_nTagIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bIsZeroDuration = 0x1C; // bool
}

namespace CEnumAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x68; // uint8_t
    constexpr std::ptrdiff_t m_enumOptions = 0x70; // CUtlVector<CUtlString>
}

namespace CExpressionActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_hScript = 0x1C; // AnimScriptHandle
}

namespace CFingerBone {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hingeAxis = 0x8; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x14; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x20; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x30; // float
    constexpr std::ptrdiff_t m_flRadius = 0x34; // float
}

namespace CFingerChain {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<CFingerSource>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<CFingerBone>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_tipParentBoneName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_vTipOffset = 0x40; // Vector
    constexpr std::ptrdiff_t m_metacarpalBoneName = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x58; // Vector
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x64; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x68; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x6C; // float
}

namespace CFingerSource {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace CFlexController {
    constexpr std::ptrdiff_t m_szName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_szType = 0x8; // CUtlString
    constexpr std::ptrdiff_t min = 0x10; // float
    constexpr std::ptrdiff_t max = 0x14; // float
}

namespace CFlexDesc {
    constexpr std::ptrdiff_t m_szFacs = 0x0; // CUtlString
}

namespace CFlexOp {
    constexpr std::ptrdiff_t m_OpCode = 0x0; // FlexOpCode_t
    constexpr std::ptrdiff_t m_Data = 0x4; // int32_t
}

namespace CFlexRule {
    constexpr std::ptrdiff_t m_nFlex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_FlexOps = 0x8; // CUtlVector<CFlexOp>
}

namespace CFloatAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_fDefaultValue = 0x60; // float
    constexpr std::ptrdiff_t m_fMinValue = 0x64; // float
    constexpr std::ptrdiff_t m_fMaxValue = 0x68; // float
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CFollowAttachmentUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // FollowAttachmentSettings_t
}

namespace CFollowPathUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flBlendOutTime = 0x6C; // float
    constexpr std::ptrdiff_t m_bBlockNonPathMovement = 0x70; // bool
    constexpr std::ptrdiff_t m_bStopFeetAtGoal = 0x71; // bool
    constexpr std::ptrdiff_t m_bScaleSpeed = 0x72; // bool
    constexpr std::ptrdiff_t m_flScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinAngle = 0x78; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x7C; // float
    constexpr std::ptrdiff_t m_flSpeedScaleBlending = 0x80; // float
    constexpr std::ptrdiff_t m_turnDamping = 0x88; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x98; // AnimValueSource
    constexpr std::ptrdiff_t m_hParam = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0xA0; // float
    constexpr std::ptrdiff_t m_bTurnToFace = 0xA4; // bool
}

namespace CFootAdjustmentUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_clips = 0x70; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hBasePoseCacheHandle = 0x88; // CPoseHandle
    constexpr std::ptrdiff_t m_facingTarget = 0x8C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnTimeMin = 0x90; // float
    constexpr std::ptrdiff_t m_flTurnTimeMax = 0x94; // float
    constexpr std::ptrdiff_t m_flStepHeightMax = 0x98; // float
    constexpr std::ptrdiff_t m_flStepHeightMaxAngle = 0x9C; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xA0; // bool
    constexpr std::ptrdiff_t m_bAnimationDriven = 0xA1; // bool
}

namespace CFootCycle { // CCycleBase
}

namespace CFootCycleDefinition {
    constexpr std::ptrdiff_t m_vStancePositionMS = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMidpointPositionMS = 0xC; // Vector
    constexpr std::ptrdiff_t m_flStanceDirectionMS = 0x18; // float
    constexpr std::ptrdiff_t m_vToStrideStartPos = 0x1C; // Vector
    constexpr std::ptrdiff_t m_stanceCycle = 0x28; // CAnimCycle
    constexpr std::ptrdiff_t m_footLiftCycle = 0x2C; // CFootCycle
    constexpr std::ptrdiff_t m_footOffCycle = 0x30; // CFootCycle
    constexpr std::ptrdiff_t m_footStrikeCycle = 0x34; // CFootCycle
    constexpr std::ptrdiff_t m_footLandCycle = 0x38; // CFootCycle
}

namespace CFootCycleMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
}

namespace CFootDefinition {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ankleBoneName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_toeBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x18; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x24; // Vector
    constexpr std::ptrdiff_t m_flFootLength = 0x30; // float
    constexpr std::ptrdiff_t m_flBindPoseDirectionMS = 0x34; // float
    constexpr std::ptrdiff_t m_flTraceHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x3C; // float
}

namespace CFootFallAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_foot = 0x38; // FootFallTagFoot_t
}

namespace CFootLockUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // FootLockPoseOpFixedSettings
    constexpr std::ptrdiff_t m_footSettings = 0xD0; // CUtlVector<FootFixedSettings>
    constexpr std::ptrdiff_t m_hipShiftDamping = 0xE8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_rootHeightDamping = 0xF8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flStrideCurveScale = 0x108; // float
    constexpr std::ptrdiff_t m_flStrideCurveLimitScale = 0x10C; // float
    constexpr std::ptrdiff_t m_flStepHeightIncreaseScale = 0x110; // float
    constexpr std::ptrdiff_t m_flStepHeightDecreaseScale = 0x114; // float
    constexpr std::ptrdiff_t m_flHipShiftScale = 0x118; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0x11C; // float
    constexpr std::ptrdiff_t m_flMaxRootHeightOffset = 0x120; // float
    constexpr std::ptrdiff_t m_flMinRootHeightOffset = 0x124; // float
    constexpr std::ptrdiff_t m_flTiltPlanePitchSpringStrength = 0x128; // float
    constexpr std::ptrdiff_t m_flTiltPlaneRollSpringStrength = 0x12C; // float
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x130; // bool
    constexpr std::ptrdiff_t m_bApplyHipShift = 0x131; // bool
    constexpr std::ptrdiff_t m_bModulateStepHeight = 0x132; // bool
    constexpr std::ptrdiff_t m_bResetChild = 0x133; // bool
    constexpr std::ptrdiff_t m_bEnableVerticalCurvedPaths = 0x134; // bool
    constexpr std::ptrdiff_t m_bEnableRootHeightDamping = 0x135; // bool
}

namespace CFootMotion {
    constexpr std::ptrdiff_t m_strides = 0x0; // CUtlVector<CFootStride>
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bAdditive = 0x20; // bool
}

namespace CFootPinningUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_poseOpFixedData = 0x70; // FootPinningPoseOpFixedData_t
    constexpr std::ptrdiff_t m_eTimingSource = 0xA0; // FootPinningTimingSource
    constexpr std::ptrdiff_t m_params = 0xA8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_bResetChild = 0xC0; // bool
}

namespace CFootPositionMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bIgnoreSlope = 0x68; // bool
}

namespace CFootStepTriggerUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_triggers = 0x68; // CUtlVector<FootStepTrigger>
    constexpr std::ptrdiff_t m_flTolerance = 0x84; // float
}

namespace CFootStride {
    constexpr std::ptrdiff_t m_definition = 0x0; // CFootCycleDefinition
    constexpr std::ptrdiff_t m_trajectories = 0x40; // CFootTrajectories
}

namespace CFootTrajectories {
    constexpr std::ptrdiff_t m_trajectories = 0x0; // CUtlVector<CFootTrajectory>
}

namespace CFootTrajectory {
    constexpr std::ptrdiff_t m_vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRotationOffset = 0xC; // float
    constexpr std::ptrdiff_t m_flProgression = 0x10; // float
}

namespace CFootstepLandedAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_FootstepType = 0x38; // FootstepLandedFootSoundType_t
    constexpr std::ptrdiff_t m_OverrideSoundName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DebugAnimSourceString = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_BoneName = 0x50; // CUtlString
}

namespace CFutureFacingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flTime = 0x54; // float
}

namespace CFutureVelocityMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flStoppingDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x58; // float
    constexpr std::ptrdiff_t m_eMode = 0x5C; // VelocityMetricMode
}

namespace CHitBox {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_sBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vMinBounds = 0x18; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x24; // Vector
    constexpr std::ptrdiff_t m_flShapeRadius = 0x30; // float
    constexpr std::ptrdiff_t m_nBoneNameHash = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_nGroupId = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nShapeType = 0x3C; // uint8_t
    constexpr std::ptrdiff_t m_bTranslationOnly = 0x3D; // bool
    constexpr std::ptrdiff_t m_CRC = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_cRenderColor = 0x44; // Color
    constexpr std::ptrdiff_t m_nHitBoxIndex = 0x48; // uint16_t
}

namespace CHitBoxSet {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_HitBoxes = 0x10; // CUtlVector<CHitBox>
    constexpr std::ptrdiff_t m_SourceFilename = 0x28; // CUtlString
}

namespace CHitBoxSetList {
    constexpr std::ptrdiff_t m_HitBoxSets = 0x0; // CUtlVector<CHitBoxSet>
}

namespace CHitReactUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // HitReactFixedSettings_t
    constexpr std::ptrdiff_t m_triggerParam = 0xB4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitBoneParam = 0xB6; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitOffsetParam = 0xB8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitDirectionParam = 0xBA; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitStrengthParam = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flMinDelayBetweenHits = 0xC0; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xC4; // bool
}

namespace CInputStreamUpdateNode { // CLeafUpdateNode
}

namespace CIntAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // int32_t
    constexpr std::ptrdiff_t m_minValue = 0x64; // int32_t
    constexpr std::ptrdiff_t m_maxValue = 0x68; // int32_t
}

namespace CJiggleBoneUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x68; // JiggleBoneSettingsList_t
}

namespace CJumpHelperUpdateNode { // CSequenceUpdateNode
    constexpr std::ptrdiff_t m_hTargetParam = 0xA8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flOriginalJumpMovement = 0xAC; // Vector
    constexpr std::ptrdiff_t m_flOriginalJumpDuration = 0xB8; // float
    constexpr std::ptrdiff_t m_flJumpStartCycle = 0xBC; // float
    constexpr std::ptrdiff_t m_flJumpEndCycle = 0xC0; // float
    constexpr std::ptrdiff_t m_eCorrectionMethod = 0xC4; // JumpCorrectionMethod
    constexpr std::ptrdiff_t m_bTranslationAxis = 0xC8; // bool[3]
    constexpr std::ptrdiff_t m_bScaleSpeed = 0xCB; // bool
}

namespace CLODComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_nServerLOD = 0x30; // int32_t
}

namespace CLeafUpdateNode { // CAnimUpdateNodeBase
}

namespace CLeanMatrixUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_frameCorners = 0x5C; // int32_t[3][3]
    constexpr std::ptrdiff_t m_poses = 0x80; // CPoseHandle[9]
    constexpr std::ptrdiff_t m_damping = 0xA8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSource = 0xB8; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_verticalAxis = 0xC0; // Vector
    constexpr std::ptrdiff_t m_horizontalAxis = 0xCC; // Vector
    constexpr std::ptrdiff_t m_hSequence = 0xD8; // HSequence
    constexpr std::ptrdiff_t m_flMaxValue = 0xDC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xE0; // int32_t
}

namespace CLookAtUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // LookAtOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x138; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x13C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_weightParamIndex = 0x13E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bResetChild = 0x140; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x141; // bool
}

namespace CLookComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_hLookHeading = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookHeadingVelocity = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookPitch = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDistance = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDirection = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTarget = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTargetWorldSpace = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bNetworkLookTarget = 0x42; // bool
}

namespace CMaterialAttributeAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_AttributeName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_AttributeType = 0x40; // MatterialAttributeTagType_t
    constexpr std::ptrdiff_t m_flValue = 0x44; // float
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CMaterialDrawDescriptor {
    constexpr std::ptrdiff_t m_nPrimitiveType = 0x0; // RenderPrimitiveType_t
    constexpr std::ptrdiff_t m_nBaseVertex = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nVertexCount = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStartIndex = 0xC; // int32_t
    constexpr std::ptrdiff_t m_nIndexCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_flUvDensity = 0x14; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x18; // Vector
    constexpr std::ptrdiff_t m_flAlpha = 0x24; // float
    constexpr std::ptrdiff_t m_nFirstMeshlet = 0x2C; // uint32_t
    constexpr std::ptrdiff_t m_nNumMeshlets = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_indexBuffer = 0xB8; // CRenderBufferBinding
    constexpr std::ptrdiff_t m_material = 0xE0; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CMeshletDescriptor {
    constexpr std::ptrdiff_t m_PackedAABB = 0x0; // PackedAABB_t
    constexpr std::ptrdiff_t m_CullingData = 0x8; // CDrawCullingData
}

namespace CModelConfig {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_Elements = 0x8; // CUtlVector<CModelConfigElement*>
    constexpr std::ptrdiff_t m_bTopLevel = 0x20; // bool
}

namespace CModelConfigElement {
    constexpr std::ptrdiff_t m_ElementName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_NestedElements = 0x10; // CUtlVector<CModelConfigElement*>
}

namespace CModelConfigElement_AttachedModel { // CModelConfigElement
    constexpr std::ptrdiff_t m_InstanceName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_EntityClass = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_hModel = 0x58; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_vOffset = 0x60; // Vector
    constexpr std::ptrdiff_t m_aAngOffset = 0x6C; // QAngle
    constexpr std::ptrdiff_t m_AttachmentName = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_LocalAttachmentOffsetName = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_AttachmentType = 0x88; // ModelConfigAttachmentType_t
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x8C; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedColor = 0x8D; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedMaterialGroup = 0x8E; // bool
    constexpr std::ptrdiff_t m_bAcceptParentMaterialDrivenDecals = 0x8F; // bool
    constexpr std::ptrdiff_t m_BodygroupOnOtherModels = 0x90; // CUtlString
    constexpr std::ptrdiff_t m_MaterialGroupOnOtherModels = 0x98; // CUtlString
}

namespace CModelConfigElement_Command { // CModelConfigElement
    constexpr std::ptrdiff_t m_Command = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_Args = 0x50; // KeyValues3
}

namespace CModelConfigElement_RandomColor { // CModelConfigElement
    constexpr std::ptrdiff_t m_Gradient = 0x48; // CColorGradient
}

namespace CModelConfigElement_RandomPick { // CModelConfigElement
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_ChoiceWeights = 0x60; // CUtlVector<float>
}

namespace CModelConfigElement_SetBodygroup { // CModelConfigElement
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetBodygroupOnAttachedModels { // CModelConfigElement
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetMaterialGroup { // CModelConfigElement
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetMaterialGroupOnAttachedModels { // CModelConfigElement
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetRenderColor { // CModelConfigElement
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CModelConfigElement_UserPick { // CModelConfigElement
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
}

namespace CModelConfigList {
    constexpr std::ptrdiff_t m_bHideMaterialGroupInTools = 0x0; // bool
    constexpr std::ptrdiff_t m_bHideRenderColorInTools = 0x1; // bool
    constexpr std::ptrdiff_t m_Configs = 0x8; // CUtlVector<CModelConfig*>
}

namespace CMoodVData {
    constexpr std::ptrdiff_t m_sModelName = 0x0; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_nMoodType = 0xE0; // MoodType_t
    constexpr std::ptrdiff_t m_animationLayers = 0xE8; // CUtlVector<MoodAnimationLayer_t>
}

namespace CMorphBundleData {
    constexpr std::ptrdiff_t m_flULeftSrc = 0x0; // float
    constexpr std::ptrdiff_t m_flVTopSrc = 0x4; // float
    constexpr std::ptrdiff_t m_offsets = 0x8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_ranges = 0x20; // CUtlVector<float>
}

namespace CMorphConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_sTargetMorph = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_nSlaveChannel = 0x78; // int32_t
    constexpr std::ptrdiff_t m_flMin = 0x7C; // float
    constexpr std::ptrdiff_t m_flMax = 0x80; // float
}

namespace CMorphData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_morphRectDatas = 0x8; // CUtlVector<CMorphRectData>
}

namespace CMorphRectData {
    constexpr std::ptrdiff_t m_nXLeftDst = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nYTopDst = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flUWidthSrc = 0x4; // float
    constexpr std::ptrdiff_t m_flVHeightSrc = 0x8; // float
    constexpr std::ptrdiff_t m_bundleDatas = 0x10; // CUtlVector<CMorphBundleData>
}

namespace CMorphSetData {
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_bundleTypes = 0x18; // CUtlVector<MorphBundleType_t>
    constexpr std::ptrdiff_t m_morphDatas = 0x30; // CUtlVector<CMorphData>
    constexpr std::ptrdiff_t m_pTextureAtlas = 0x48; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_FlexDesc = 0x50; // CUtlVector<CFlexDesc>
    constexpr std::ptrdiff_t m_FlexControllers = 0x68; // CUtlVector<CFlexController>
    constexpr std::ptrdiff_t m_FlexRules = 0x80; // CUtlVector<CFlexRule>
}

namespace CMotionDataSet {
    constexpr std::ptrdiff_t m_groups = 0x0; // CUtlVector<CMotionGraphGroup>
    constexpr std::ptrdiff_t m_nDimensionCount = 0x18; // int32_t
}

namespace CMotionGraph {
    constexpr std::ptrdiff_t m_paramSpans = 0x10; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pRootNode = 0x40; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_nParameterCount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nConfigStartIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nConfigCount = 0x50; // int32_t
    constexpr std::ptrdiff_t m_bLoop = 0x54; // bool
}

namespace CMotionGraphConfig {
    constexpr std::ptrdiff_t m_paramValues = 0x0; // float[4]
    constexpr std::ptrdiff_t m_flDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nMotionIndex = 0x14; // MotionIndex
    constexpr std::ptrdiff_t m_nSampleStart = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nSampleCount = 0x1C; // int32_t
}

namespace CMotionGraphGroup {
    constexpr std::ptrdiff_t m_searchDB = 0x0; // CMotionSearchDB
    constexpr std::ptrdiff_t m_motionGraphs = 0xB8; // CUtlVector<CSmartPtr<CMotionGraph>>
    constexpr std::ptrdiff_t m_motionGraphConfigs = 0xD0; // CUtlVector<CMotionGraphConfig>
    constexpr std::ptrdiff_t m_sampleToConfig = 0xE8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hIsActiveScript = 0x100; // AnimScriptHandle
}

namespace CMotionGraphUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_pMotionGraph = 0x58; // CSmartPtr<CMotionGraph>
}

namespace CMotionMatchingUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_dataSet = 0x58; // CMotionDataSet
    constexpr std::ptrdiff_t m_metrics = 0x78; // CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    constexpr std::ptrdiff_t m_weights = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_bSearchEveryTick = 0xE0; // bool
    constexpr std::ptrdiff_t m_flSearchInterval = 0xE4; // float
    constexpr std::ptrdiff_t m_bSearchWhenClipEnds = 0xE8; // bool
    constexpr std::ptrdiff_t m_bSearchWhenGoalChanges = 0xE9; // bool
    constexpr std::ptrdiff_t m_blendCurve = 0xEC; // CBlendCurve
    constexpr std::ptrdiff_t m_flSampleRate = 0xF4; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0xF8; // float
    constexpr std::ptrdiff_t m_bLockClipWhenWaning = 0xFC; // bool
    constexpr std::ptrdiff_t m_flSelectionThreshold = 0x100; // float
    constexpr std::ptrdiff_t m_flReselectionTimeWindow = 0x104; // float
    constexpr std::ptrdiff_t m_bEnableRotationCorrection = 0x108; // bool
    constexpr std::ptrdiff_t m_bGoalAssist = 0x109; // bool
    constexpr std::ptrdiff_t m_flGoalAssistDistance = 0x10C; // float
    constexpr std::ptrdiff_t m_flGoalAssistTolerance = 0x110; // float
    constexpr std::ptrdiff_t m_distanceScale_Damping = 0x118; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flDistanceScale_OuterRadius = 0x128; // float
    constexpr std::ptrdiff_t m_flDistanceScale_InnerRadius = 0x12C; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MaxScale = 0x130; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MinScale = 0x134; // float
    constexpr std::ptrdiff_t m_bEnableDistanceScaling = 0x138; // bool
}

namespace CMotionMetricEvaluator {
    constexpr std::ptrdiff_t m_means = 0x18; // CUtlVector<float>
    constexpr std::ptrdiff_t m_standardDeviations = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_nDimensionStartIndex = 0x4C; // int32_t
}

namespace CMotionNode {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimNodeID
}

namespace CMotionNodeBlend1D { // CMotionNode
    constexpr std::ptrdiff_t m_blendItems = 0x28; // CUtlVector<MotionBlendItem>
    constexpr std::ptrdiff_t m_nParamIndex = 0x40; // int32_t
}

namespace CMotionNodeSequence { // CMotionNode
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x40; // HSequence
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x44; // float
}

namespace CMotionSearchDB {
    constexpr std::ptrdiff_t m_rootNode = 0x0; // CMotionSearchNode
    constexpr std::ptrdiff_t m_residualQuantizer = 0x80; // CProductQuantizer
    constexpr std::ptrdiff_t m_codeIndices = 0xA0; // CUtlVector<MotionDBIndex>
}

namespace CMotionSearchNode {
    constexpr std::ptrdiff_t m_children = 0x0; // CUtlVector<CMotionSearchNode*>
    constexpr std::ptrdiff_t m_quantizer = 0x18; // CVectorQuantizer
    constexpr std::ptrdiff_t m_sampleCodes = 0x38; // CUtlVector<CUtlVector<SampleCode>>
    constexpr std::ptrdiff_t m_sampleIndices = 0x50; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_selectableSamples = 0x68; // CUtlVector<int32_t>
}

namespace CMovementComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_movementModes = 0x30; // CUtlVector<CMovementMode>
    constexpr std::ptrdiff_t m_motors = 0x48; // CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    constexpr std::ptrdiff_t m_facingDamping = 0x60; // CAnimInputDamping
    constexpr std::ptrdiff_t m_eDefaultFacingMode = 0x70; // FacingMode
    constexpr std::ptrdiff_t m_nDefaultMotorIndex = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_bMoveVarsDisabled = 0x80; // bool
    constexpr std::ptrdiff_t m_bNetworkPath = 0x81; // bool
    constexpr std::ptrdiff_t m_bNetworkFacing = 0x82; // bool
    constexpr std::ptrdiff_t m_paramHandles = 0x83; // CAnimParamHandle[30]
}

namespace CMovementMode {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flSpeed = 0x8; // float
}

namespace CMoverUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_damping = 0x70; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x80; // AnimValueSource
    constexpr std::ptrdiff_t m_hMoveVecParam = 0x84; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hMoveHeadingParam = 0x86; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hTurnToFaceParam = 0x88; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0x8C; // float
    constexpr std::ptrdiff_t m_flTurnToFaceLimit = 0x90; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x94; // bool
    constexpr std::ptrdiff_t m_bApplyMovement = 0x95; // bool
    constexpr std::ptrdiff_t m_bOrientMovement = 0x96; // bool
    constexpr std::ptrdiff_t m_bApplyRotation = 0x97; // bool
    constexpr std::ptrdiff_t m_bLimitOnly = 0x98; // bool
}

namespace COrientConstraint { // CBaseConstraint
}

namespace CParamSpanUpdater {
    constexpr std::ptrdiff_t m_spans = 0x0; // CUtlVector<ParamSpan_t>
}

namespace CParentConstraint { // CBaseConstraint
}

namespace CParticleAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_hParticleSystem = 0x38; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_particleSystemName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_configName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_bDetachFromOwner = 0x50; // bool
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x51; // bool
    constexpr std::ptrdiff_t m_bTagEndStopIsInstant = 0x52; // bool
    constexpr std::ptrdiff_t m_attachmentName = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_attachmentType = 0x60; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentCP1Name = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_attachmentCP1Type = 0x70; // ParticleAttachment_t
}

namespace CPathAnimMotorUpdater { // CPathAnimMotorUpdaterBase
}

namespace CPathAnimMotorUpdaterBase { // CAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_bLockToPath = 0x20; // bool
}

namespace CPathHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flStoppingRadius = 0x68; // float
    constexpr std::ptrdiff_t m_flStoppingSpeedScale = 0x6C; // float
}

namespace CPathMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_pathTimeSamples = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDistance = 0x68; // float
    constexpr std::ptrdiff_t m_bExtrapolateMovement = 0x6C; // bool
    constexpr std::ptrdiff_t m_flMinExtrapolationSpeed = 0x70; // float
}

namespace CPhysSurfaceProperties {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_baseNameHash = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_bHidden = 0x18; // bool
    constexpr std::ptrdiff_t m_description = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_physics = 0x28; // CPhysSurfacePropertiesPhysics
    constexpr std::ptrdiff_t m_audioSounds = 0x48; // CPhysSurfacePropertiesSoundNames
    constexpr std::ptrdiff_t m_audioParams = 0x88; // CPhysSurfacePropertiesAudio
}

namespace CPhysSurfacePropertiesAudio {
    constexpr std::ptrdiff_t m_reflectivity = 0x0; // float
    constexpr std::ptrdiff_t m_hardnessFactor = 0x4; // float
    constexpr std::ptrdiff_t m_roughnessFactor = 0x8; // float
    constexpr std::ptrdiff_t m_roughThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_hardThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_hardVelocityThreshold = 0x14; // float
    constexpr std::ptrdiff_t m_flStaticImpactVolume = 0x18; // float
    constexpr std::ptrdiff_t m_flOcclusionFactor = 0x1C; // float
}

namespace CPhysSurfacePropertiesPhysics {
    constexpr std::ptrdiff_t m_friction = 0x0; // float
    constexpr std::ptrdiff_t m_elasticity = 0x4; // float
    constexpr std::ptrdiff_t m_density = 0x8; // float
    constexpr std::ptrdiff_t m_thickness = 0xC; // float
    constexpr std::ptrdiff_t m_softContactFrequency = 0x10; // float
    constexpr std::ptrdiff_t m_softContactDampingRatio = 0x14; // float
    constexpr std::ptrdiff_t m_wheelDrag = 0x18; // float
}

namespace CPhysSurfacePropertiesSoundNames {
    constexpr std::ptrdiff_t m_impactSoft = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_impactHard = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_scrapeSmooth = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_scrapeRough = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bulletImpact = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_rolling = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_break = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_strain = 0x38; // CUtlString
}

namespace CPlayerInputAnimMotorUpdater { // CAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_sampleTimes = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flSpringConstant = 0x3C; // float
    constexpr std::ptrdiff_t m_flAnticipationDistance = 0x40; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x44; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x46; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bUseAcceleration = 0x48; // bool
}

namespace CPointConstraint { // CBaseConstraint
}

namespace CPoseHandle {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_eType = 0x2; // PoseType_t
}

namespace CProductQuantizer {
    constexpr std::ptrdiff_t m_subQuantizers = 0x0; // CUtlVector<CVectorQuantizer>
    constexpr std::ptrdiff_t m_nDimensions = 0x18; // int32_t
}

namespace CQuaternionAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Quaternion
    constexpr std::ptrdiff_t m_bInterpolate = 0x70; // bool
}

namespace CRagdollAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_nPoseControl = 0x38; // AnimPoseControl
    constexpr std::ptrdiff_t m_flFrequency = 0x3C; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x40; // float
    constexpr std::ptrdiff_t m_flDecayDuration = 0x44; // float
    constexpr std::ptrdiff_t m_flDecayBias = 0x48; // float
    constexpr std::ptrdiff_t m_bDestroy = 0x4C; // bool
}

namespace CRagdollComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_ragdollNodePaths = 0x30; // CUtlVector<CAnimNodePath>
    constexpr std::ptrdiff_t m_boneIndices = 0x48; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x60; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_weightLists = 0x78; // CUtlVector<WeightList>
    constexpr std::ptrdiff_t m_flSpringFrequencyMin = 0x90; // float
    constexpr std::ptrdiff_t m_flSpringFrequencyMax = 0x94; // float
    constexpr std::ptrdiff_t m_flMaxStretch = 0x98; // float
}

namespace CRagdollUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t m_poseControlMethod = 0x6C; // RagdollPoseControl
}

namespace CRenderBufferBinding {
    constexpr std::ptrdiff_t m_hBuffer = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nBindOffsetBytes = 0x10; // uint32_t
}

namespace CRenderMesh {
    constexpr std::ptrdiff_t m_sceneObjects = 0x10; // CUtlVectorFixedGrowable<CSceneObjectData>
    constexpr std::ptrdiff_t m_constraints = 0xA0; // CUtlVector<CBaseConstraint*>
    constexpr std::ptrdiff_t m_skeleton = 0xB8; // CRenderSkeleton
}

namespace CRenderSkeleton {
    constexpr std::ptrdiff_t m_bones = 0x0; // CUtlVector<RenderSkeletonBone_t>
    constexpr std::ptrdiff_t m_boneParents = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nBoneWeightCount = 0x48; // int32_t
}

namespace CRootUpdateNode { // CUnaryUpdateNode
}

namespace CSceneObjectData {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
    constexpr std::ptrdiff_t m_drawCalls = 0x18; // CUtlVector<CMaterialDrawDescriptor>
    constexpr std::ptrdiff_t m_drawBounds = 0x30; // CUtlVector<AABB_t>
    constexpr std::ptrdiff_t m_meshlets = 0x48; // CUtlVector<CMeshletDescriptor>
    constexpr std::ptrdiff_t m_vTintColor = 0x60; // Vector4D
}

namespace CSelectorUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_tags = 0x70; // CUtlVector<int8_t>
    constexpr std::ptrdiff_t m_blendCurve = 0x8C; // CBlendCurve
    constexpr std::ptrdiff_t m_flBlendTime = 0x94; // CAnimValue<float>
    constexpr std::ptrdiff_t m_hParameter = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eTagBehavior = 0xA0; // SelectorTagBehavior_t
    constexpr std::ptrdiff_t m_bResetOnChange = 0xA4; // bool
    constexpr std::ptrdiff_t m_bSyncCyclesOnChange = 0xA5; // bool
}

namespace CSeqAutoLayer {
    constexpr std::ptrdiff_t m_nLocalReference = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalPose = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flags = 0x4; // CSeqAutoLayerFlag
    constexpr std::ptrdiff_t m_start = 0xC; // float
    constexpr std::ptrdiff_t m_peak = 0x10; // float
    constexpr std::ptrdiff_t m_tail = 0x14; // float
    constexpr std::ptrdiff_t m_end = 0x18; // float
}

namespace CSeqAutoLayerFlag {
    constexpr std::ptrdiff_t m_bPost = 0x0; // bool
    constexpr std::ptrdiff_t m_bSpline = 0x1; // bool
    constexpr std::ptrdiff_t m_bXFade = 0x2; // bool
    constexpr std::ptrdiff_t m_bNoBlend = 0x3; // bool
    constexpr std::ptrdiff_t m_bLocal = 0x4; // bool
    constexpr std::ptrdiff_t m_bPose = 0x5; // bool
    constexpr std::ptrdiff_t m_bFetchFrame = 0x6; // bool
    constexpr std::ptrdiff_t m_bSubtract = 0x7; // bool
}

namespace CSeqBoneMaskList {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x10; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneWeightArray = 0x28; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDefaultMorphCtrlWeight = 0x40; // float
    constexpr std::ptrdiff_t m_morphCtrlWeightArray = 0x48; // CUtlVector<CUtlPair<CBufferString,float>>
}

namespace CSeqCmdLayer {
    constexpr std::ptrdiff_t m_cmd = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalReference = 0x2; // int16_t
    constexpr std::ptrdiff_t m_nLocalBonemask = 0x4; // int16_t
    constexpr std::ptrdiff_t m_nDstResult = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nSrcResult = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bSpline = 0xA; // bool
    constexpr std::ptrdiff_t m_flVar1 = 0xC; // float
    constexpr std::ptrdiff_t m_flVar2 = 0x10; // float
    constexpr std::ptrdiff_t m_nLineNumber = 0x14; // int16_t
}

namespace CSeqCmdSeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nFrameRangeSequence = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x26; // int16_t
    constexpr std::ptrdiff_t m_flFPS = 0x28; // float
    constexpr std::ptrdiff_t m_nSubCycles = 0x2C; // int16_t
    constexpr std::ptrdiff_t m_numLocalResults = 0x2E; // int16_t
    constexpr std::ptrdiff_t m_cmdLayerArray = 0x30; // CUtlVector<CSeqCmdLayer>
    constexpr std::ptrdiff_t m_eventArray = 0x48; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x60; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_poseSettingArray = 0x78; // CUtlVector<CSeqPoseSetting>
}

namespace CSeqIKLock {
    constexpr std::ptrdiff_t m_flPosWeight = 0x0; // float
    constexpr std::ptrdiff_t m_flAngleWeight = 0x4; // float
    constexpr std::ptrdiff_t m_nLocalBone = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bBonesOrientedAlongPositiveX = 0xA; // bool
}

namespace CSeqMultiFetch {
    constexpr std::ptrdiff_t m_flags = 0x0; // CSeqMultiFetchFlag
    constexpr std::ptrdiff_t m_localReferenceArray = 0x8; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_nGroupSize = 0x20; // int32_t[2]
    constexpr std::ptrdiff_t m_nLocalPose = 0x28; // int32_t[2]
    constexpr std::ptrdiff_t m_poseKeyArray0 = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_poseKeyArray1 = 0x48; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nLocalCyclePoseParameter = 0x60; // int32_t
    constexpr std::ptrdiff_t m_bCalculatePoseParameters = 0x64; // bool
}

namespace CSeqMultiFetchFlag {
    constexpr std::ptrdiff_t m_bRealtime = 0x0; // bool
    constexpr std::ptrdiff_t m_bCylepose = 0x1; // bool
    constexpr std::ptrdiff_t m_b0D = 0x2; // bool
    constexpr std::ptrdiff_t m_b1D = 0x3; // bool
    constexpr std::ptrdiff_t m_b2D = 0x4; // bool
    constexpr std::ptrdiff_t m_b2D_TRI = 0x5; // bool
}

namespace CSeqPoseParamDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flStart = 0x10; // float
    constexpr std::ptrdiff_t m_flEnd = 0x14; // float
    constexpr std::ptrdiff_t m_flLoop = 0x18; // float
    constexpr std::ptrdiff_t m_bLooping = 0x1C; // bool
}

namespace CSeqPoseSetting {
    constexpr std::ptrdiff_t m_sPoseParameter = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sAttachment = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_sReferenceSequence = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_flValue = 0x30; // float
    constexpr std::ptrdiff_t m_bX = 0x34; // bool
    constexpr std::ptrdiff_t m_bY = 0x35; // bool
    constexpr std::ptrdiff_t m_bZ = 0x36; // bool
    constexpr std::ptrdiff_t m_eType = 0x38; // int32_t
}

namespace CSeqS1SeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_fetch = 0x20; // CSeqMultiFetch
    constexpr std::ptrdiff_t m_nLocalWeightlist = 0x88; // int32_t
    constexpr std::ptrdiff_t m_autoLayerArray = 0x90; // CUtlVector<CSeqAutoLayer>
    constexpr std::ptrdiff_t m_IKLockArray = 0xA8; // CUtlVector<CSeqIKLock>
    constexpr std::ptrdiff_t m_transition = 0xC0; // CSeqTransition
    constexpr std::ptrdiff_t m_SequenceKeys = 0xC8; // KeyValues3
    constexpr std::ptrdiff_t m_LegacyKeyValueText = 0xD8; // CBufferString
    constexpr std::ptrdiff_t m_activityArray = 0xE8; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_footMotion = 0x100; // CUtlVector<CFootMotion>
}

namespace CSeqScaleSet {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_bRootOffset = 0x10; // bool
    constexpr std::ptrdiff_t m_vRootOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x20; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneScaleArray = 0x38; // CUtlVector<float>
}

namespace CSeqSeqDescFlag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bSnap = 0x1; // bool
    constexpr std::ptrdiff_t m_bAutoplay = 0x2; // bool
    constexpr std::ptrdiff_t m_bPost = 0x3; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x4; // bool
    constexpr std::ptrdiff_t m_bMulti = 0x5; // bool
    constexpr std::ptrdiff_t m_bLegacyDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x7; // bool
    constexpr std::ptrdiff_t m_bLegacyCyclepose = 0x8; // bool
    constexpr std::ptrdiff_t m_bLegacyRealtime = 0x9; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0xA; // bool
}

namespace CSeqSynthAnimDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nLocalBaseReference = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nLocalBoneMask = 0x26; // int16_t
    constexpr std::ptrdiff_t m_activityArray = 0x28; // CUtlVector<CAnimActivity>
}

namespace CSeqTransition {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CSequenceFinishedAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_sequenceName = 0x38; // CUtlString
}

namespace CSequenceGroupData {
    constexpr std::ptrdiff_t m_sName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_localSequenceNameArray = 0x28; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localS1SeqDescArray = 0x40; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localMultiSeqDescArray = 0x58; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localSynthAnimDescArray = 0x70; // CUtlVector<CSeqSynthAnimDesc>
    constexpr std::ptrdiff_t m_localCmdSeqDescArray = 0x88; // CUtlVector<CSeqCmdSeqDesc>
    constexpr std::ptrdiff_t m_localBoneMaskArray = 0xA0; // CUtlVector<CSeqBoneMaskList>
    constexpr std::ptrdiff_t m_localScaleSetArray = 0xB8; // CUtlVector<CSeqScaleSet>
    constexpr std::ptrdiff_t m_localBoneNameArray = 0xD0; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localNodeName = 0xE8; // CBufferString
    constexpr std::ptrdiff_t m_localPoseParamArray = 0xF8; // CUtlVector<CSeqPoseParamDesc>
    constexpr std::ptrdiff_t m_keyValues = 0x110; // KeyValues3
    constexpr std::ptrdiff_t m_localIKAutoplayLockArray = 0x120; // CUtlVector<CSeqIKLock>
}

namespace CSequenceUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_paramSpans = 0x60; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x94; // HSequence
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
}

namespace CSetFacingUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_facingMode = 0x68; // FacingMode
    constexpr std::ptrdiff_t m_bResetChild = 0x6C; // bool
}

namespace CSetParameterActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_value = 0x1A; // CAnimVariant
}

namespace CSingleFrameUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_actions = 0x58; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
    constexpr std::ptrdiff_t m_hPoseCacheHandle = 0x70; // CPoseHandle
    constexpr std::ptrdiff_t m_hSequence = 0x74; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x78; // float
}

namespace CSkeletalInputUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_fixedOpData = 0x58; // SkeletalInputOpFixedSettings_t
}

namespace CSlopeComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_flTraceDistance = 0x34; // float
    constexpr std::ptrdiff_t m_hSlopeAngle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleFront = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleSide = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeHeading = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal_WorldSpace = 0x42; // CAnimParamHandle
}

namespace CSlowDownOnSlopesUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flSlowDownStrength = 0x68; // float
}

namespace CSolveIKChainUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_targetHandles = 0x68; // CUtlVector<CSolveIKTargetHandle_t>
    constexpr std::ptrdiff_t m_opFixedData = 0x80; // SolveIKChainPoseOpFixedSettings_t
}

namespace CSolveIKTargetHandle_t {
    constexpr std::ptrdiff_t m_positionHandle = 0x0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_orientationHandle = 0x2; // CAnimParamHandle
}

namespace CSpeedScaleUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_paramIndex = 0x68; // CAnimParamHandle
}

namespace CStanceOverrideUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_footStanceInfo = 0x68; // CUtlVector<StanceInfo_t>
    constexpr std::ptrdiff_t m_pStanceSourceNode = 0x80; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hParameter = 0x90; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eMode = 0x94; // StanceOverrideMode
}

namespace CStanceScaleUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_hParam = 0x68; // CAnimParamHandle
}

namespace CStateActionUpdater {
    constexpr std::ptrdiff_t m_pAction = 0x0; // CSmartPtr<CAnimActionUpdater>
    constexpr std::ptrdiff_t m_eBehavior = 0x8; // StateActionBehavior
}

namespace CStateMachineComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_stateMachine = 0x30; // CAnimStateMachineUpdater
}

namespace CStateMachineUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_stateMachine = 0x68; // CAnimStateMachineUpdater
    constexpr std::ptrdiff_t m_stateData = 0xC0; // CUtlVector<CStateNodeStateData>
    constexpr std::ptrdiff_t m_transitionData = 0xD8; // CUtlVector<CStateNodeTransitionData>
    constexpr std::ptrdiff_t m_bBlockWaningTags = 0xF4; // bool
    constexpr std::ptrdiff_t m_bLockStateWhenWaning = 0xF5; // bool
}

namespace CStateNodeStateData {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_bExclusiveRootMotion = 0x0; // bitfield:1
}

namespace CStateNodeTransitionData {
    constexpr std::ptrdiff_t m_curve = 0x0; // CBlendCurve
    constexpr std::ptrdiff_t m_blendDuration = 0x8; // CAnimValue<float>
    constexpr std::ptrdiff_t m_resetCycleValue = 0x10; // CAnimValue<float>
    constexpr std::ptrdiff_t m_bReset = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_resetCycleOption = 0x0; // bitfield:3
}

namespace CStateUpdateData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hScript = 0x8; // AnimScriptHandle
    constexpr std::ptrdiff_t m_transitionIndices = 0x10; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_actions = 0x28; // CUtlVector<CStateActionUpdater>
    constexpr std::ptrdiff_t m_stateID = 0x40; // AnimStateID
    constexpr std::ptrdiff_t m_bIsStartState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsEndState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsPassthrough = 0x0; // bitfield:1
}

namespace CStaticPoseCache {
    constexpr std::ptrdiff_t m_poses = 0x10; // CUtlVector<CCachedPose>
    constexpr std::ptrdiff_t m_nBoneCount = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nMorphCount = 0x2C; // int32_t
}

namespace CStaticPoseCacheBuilder { // CStaticPoseCache
}

namespace CStepsRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_flMinStepsRemaining = 0x68; // float
}

namespace CStopAtGoalUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flOuterRadius = 0x6C; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70; // float
    constexpr std::ptrdiff_t m_flMaxScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinScale = 0x78; // float
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
}

namespace CStringAnimTag { // CAnimTagBase
}

namespace CSubtractUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CTaskStatusAnimTag { // CAnimTagBase
}

namespace CTiltTwistConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_nTargetAxis = 0x70; // int32_t
    constexpr std::ptrdiff_t m_nSlaveAxis = 0x74; // int32_t
}

namespace CTimeRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_bMatchByTimeRemaining = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxTimeRemaining = 0x54; // float
    constexpr std::ptrdiff_t m_bFilterByTimeRemaining = 0x58; // bool
    constexpr std::ptrdiff_t m_flMinTimeRemaining = 0x5C; // float
}

namespace CToggleComponentActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_componentID = 0x18; // AnimComponentID
    constexpr std::ptrdiff_t m_bSetEnabled = 0x1C; // bool
}

namespace CTransitionUpdateData {
    constexpr std::ptrdiff_t m_srcStateIndex = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_destStateIndex = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_bDisabled = 0x0; // bitfield:1
}

namespace CTurnHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_facingTarget = 0x6C; // AnimValueSource
    constexpr std::ptrdiff_t m_turnStartTimeOffset = 0x70; // float
    constexpr std::ptrdiff_t m_turnDuration = 0x74; // float
    constexpr std::ptrdiff_t m_bMatchChildDuration = 0x78; // bool
    constexpr std::ptrdiff_t m_manualTurnOffset = 0x7C; // float
    constexpr std::ptrdiff_t m_bUseManualTurnOffset = 0x80; // bool
}

namespace CTwistConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_bInverse = 0x70; // bool
    constexpr std::ptrdiff_t m_qParentBindRotation = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qChildBindRotation = 0x90; // Quaternion
}

namespace CTwoBoneIKUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // TwoBoneIKSettings_t
}

namespace CUnaryUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_pChildNode = 0x58; // CAnimUpdateNodeRef
}

namespace CVPhysXSurfacePropertiesList {
    constexpr std::ptrdiff_t m_surfacePropertiesList = 0x0; // CUtlVector<CPhysSurfaceProperties*>
}

namespace CVRInputComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_FingerCurl_Thumb = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Index = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Middle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Ring = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Pinky = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Thumb_Index = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Index_Middle = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Middle_Ring = 0x42; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Ring_Pinky = 0x44; // CAnimParamHandle
}

namespace CVectorAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Vector
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CVectorQuantizer {
    constexpr std::ptrdiff_t m_centroidVectors = 0x0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nCentroids = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nDimensions = 0x1C; // int32_t
}

namespace CVirtualAnimParameter { // CAnimParameterBase
    constexpr std::ptrdiff_t m_expressionString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_eParamType = 0x58; // AnimParamType_t
}

namespace CVrSkeletalInputSettings {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<CWristBone>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<CFingerChain>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_eHand = 0x48; // AnimVRHand_t
}

namespace CWayPointHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flStartCycle = 0x6C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x70; // float
    constexpr std::ptrdiff_t m_bOnlyGoals = 0x74; // bool
    constexpr std::ptrdiff_t m_bPreventOvershoot = 0x75; // bool
    constexpr std::ptrdiff_t m_bPreventUndershoot = 0x76; // bool
}

namespace CWristBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vForwardLS = 0x8; // Vector
    constexpr std::ptrdiff_t m_vUpLS = 0x14; // Vector
    constexpr std::ptrdiff_t m_vOffset = 0x20; // Vector
}

namespace CZeroPoseUpdateNode { // CLeafUpdateNode
}

namespace ChainToSolveData_t {
    constexpr std::ptrdiff_t m_nChainIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_SolverSettings = 0x4; // IKSolverSettings_t
    constexpr std::ptrdiff_t m_TargetSettings = 0x10; // IKTargetSettings_t
    constexpr std::ptrdiff_t m_DebugSetting = 0x38; // SolveIKChainAnimNodeDebugSetting
    constexpr std::ptrdiff_t m_flDebugNormalizedValue = 0x3C; // float
    constexpr std::ptrdiff_t m_vDebugOffset = 0x40; // VectorAligned
}

namespace ConfigIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nConfig = 0x2; // uint16_t
}

namespace FingerBone_t {
    constexpr std::ptrdiff_t m_boneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_hingeAxis = 0x4; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x10; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x30; // float
}

namespace FingerChain_t {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<FingerSource_t>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<FingerBone_t>
    constexpr std::ptrdiff_t m_vTipOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x3C; // Vector
    constexpr std::ptrdiff_t m_tipParentBoneIndex = 0x48; // int32_t
    constexpr std::ptrdiff_t m_metacarpalBoneIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x50; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x54; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x58; // float
}

namespace FingerSource_t {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace FollowAttachmentSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_boneIndex = 0x80; // int32_t
    constexpr std::ptrdiff_t m_bMatchTranslation = 0x84; // bool
    constexpr std::ptrdiff_t m_bMatchRotation = 0x85; // bool
}

namespace FootFixedData_t {
    constexpr std::ptrdiff_t m_vToeOffset = 0x0; // VectorAligned
    constexpr std::ptrdiff_t m_vHeelOffset = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_nTargetBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nAnkleBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nIKAnchorBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikChainIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_flMaxIKLength = 0x30; // float
    constexpr std::ptrdiff_t m_nFootIndex = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x40; // float
}

namespace FootFixedSettings {
    constexpr std::ptrdiff_t m_traceSettings = 0x0; // TraceSettings_t
    constexpr std::ptrdiff_t m_vFootBaseBindPosePositionMS = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_flFootBaseLength = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x28; // float
    constexpr std::ptrdiff_t m_footstepLandedTagIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_bEnableTracing = 0x30; // bool
    constexpr std::ptrdiff_t m_flTraceAngleBlend = 0x34; // float
    constexpr std::ptrdiff_t m_nDisableTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nFootIndex = 0x3C; // int32_t
}

namespace FootLockPoseOpFixedSettings {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_hipDampingSettings = 0x18; // CAnimInputDamping
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikSolverType = 0x2C; // IKSolverType
    constexpr std::ptrdiff_t m_bApplyTilt = 0x30; // bool
    constexpr std::ptrdiff_t m_bApplyHipDrop = 0x31; // bool
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x32; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x33; // bool
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x34; // bool
    constexpr std::ptrdiff_t m_flMaxFootHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flExtensionScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x40; // float
    constexpr std::ptrdiff_t m_bEnableLockBreaking = 0x44; // bool
    constexpr std::ptrdiff_t m_flLockBreakTolerance = 0x48; // float
    constexpr std::ptrdiff_t m_flLockBlendTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEnableStretching = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxStretchAmount = 0x54; // float
    constexpr std::ptrdiff_t m_flStretchExtensionScale = 0x58; // float
}

namespace FootPinningPoseOpFixedData_t {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_flBlendTime = 0x18; // float
    constexpr std::ptrdiff_t m_flLockBreakDistance = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x20; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x28; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x29; // bool
}

namespace FootStepTrigger {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nFootIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_triggerPhase = 0x1C; // StepPhase
}

namespace HSequence {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace HitReactFixedSettings_t {
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEffectedBoneCount = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flMaxImpactForce = 0x8; // float
    constexpr std::ptrdiff_t m_flMinImpactForce = 0xC; // float
    constexpr std::ptrdiff_t m_flWhipImpactScale = 0x10; // float
    constexpr std::ptrdiff_t m_flCounterRotationScale = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceFadeScale = 0x18; // float
    constexpr std::ptrdiff_t m_flPropagationScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flWhipDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flSpringStrength = 0x24; // float
    constexpr std::ptrdiff_t m_flWhipSpringStrength = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngleRadians = 0x2C; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x30; // int32_t
    constexpr std::ptrdiff_t m_flHipBoneTranslationScale = 0x34; // float
    constexpr std::ptrdiff_t m_flHipDipSpringStrength = 0x38; // float
    constexpr std::ptrdiff_t m_flHipDipImpactScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flHipDipDelay = 0x40; // float
}

namespace IKBoneNameAndIndex_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
}

namespace IKDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_parentBoneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_eMode = 0x8; // IKChannelMode
    constexpr std::ptrdiff_t m_ikChainName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneStart = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneEnd = 0x20; // CUtlString
}

namespace IKSolverSettings_t {
    constexpr std::ptrdiff_t m_SolverType = 0x0; // IKSolverType
    constexpr std::ptrdiff_t m_nNumIterations = 0x4; // int32_t
}

namespace IKTargetSettings_t {
    constexpr std::ptrdiff_t m_TargetSource = 0x0; // IKTargetSource
    constexpr std::ptrdiff_t m_Bone = 0x8; // IKBoneNameAndIndex_t
    constexpr std::ptrdiff_t m_AnimgraphParameterNamePosition = 0x18; // AnimParamID
    constexpr std::ptrdiff_t m_AnimgraphParameterNameOrientation = 0x1C; // AnimParamID
    constexpr std::ptrdiff_t m_TargetCoordSystem = 0x20; // IKTargetCoordinateSystem
}

namespace JiggleBoneSettingsList_t {
    constexpr std::ptrdiff_t m_boneSettings = 0x0; // CUtlVector<JiggleBoneSettings_t>
}

namespace JiggleBoneSettings_t {
    constexpr std::ptrdiff_t m_nBoneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flSpringStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flMaxTimeStep = 0x8; // float
    constexpr std::ptrdiff_t m_flDamping = 0xC; // float
    constexpr std::ptrdiff_t m_vBoundsMaxLS = 0x10; // Vector
    constexpr std::ptrdiff_t m_vBoundsMinLS = 0x1C; // Vector
    constexpr std::ptrdiff_t m_eSimSpace = 0x28; // JiggleBoneSimSpace
}

namespace LookAtBone_t {
    constexpr std::ptrdiff_t m_index = 0x0; // int32_t
    constexpr std::ptrdiff_t m_weight = 0x4; // float
}

namespace LookAtOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_bones = 0x90; // CUtlVector<LookAtBone_t>
    constexpr std::ptrdiff_t m_flYawLimit = 0xA8; // float
    constexpr std::ptrdiff_t m_flPitchLimit = 0xAC; // float
    constexpr std::ptrdiff_t m_flHysteresisInnerAngle = 0xB0; // float
    constexpr std::ptrdiff_t m_flHysteresisOuterAngle = 0xB4; // float
    constexpr std::ptrdiff_t m_bRotateYawForward = 0xB8; // bool
    constexpr std::ptrdiff_t m_bMaintainUpDirection = 0xB9; // bool
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xBA; // bool
    constexpr std::ptrdiff_t m_bUseHysteresis = 0xBB; // bool
}

namespace MaterialGroup_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_materials = 0x8; // CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>
}

namespace ModelBoneFlexDriverControl_t {
    constexpr std::ptrdiff_t m_nBoneComponent = 0x0; // ModelBoneFlexComponent_t
    constexpr std::ptrdiff_t m_flexController = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_flexControllerToken = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_flMin = 0x14; // float
    constexpr std::ptrdiff_t m_flMax = 0x18; // float
}

namespace ModelBoneFlexDriver_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_boneNameToken = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_controls = 0x10; // CUtlVector<ModelBoneFlexDriverControl_t>
}

namespace ModelSkeletonData_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nParent = 0x18; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_boneSphere = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlag = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_bonePosParent = 0x60; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_boneRotParent = 0x78; // CUtlVector<QuaternionStorage>
    constexpr std::ptrdiff_t m_boneScaleParent = 0x90; // CUtlVector<float>
}

namespace MoodAnimationLayer_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bActiveListening = 0x8; // bool
    constexpr std::ptrdiff_t m_bActiveTalking = 0x9; // bool
    constexpr std::ptrdiff_t m_layerAnimations = 0x10; // CUtlVector<MoodAnimation_t>
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // CRangeFloat
    constexpr std::ptrdiff_t m_flDurationScale = 0x30; // CRangeFloat
    constexpr std::ptrdiff_t m_bScaleWithInts = 0x38; // bool
    constexpr std::ptrdiff_t m_flNextStart = 0x3C; // CRangeFloat
    constexpr std::ptrdiff_t m_flStartOffset = 0x44; // CRangeFloat
    constexpr std::ptrdiff_t m_flEndOffset = 0x4C; // CRangeFloat
    constexpr std::ptrdiff_t m_flFadeIn = 0x54; // float
    constexpr std::ptrdiff_t m_flFadeOut = 0x58; // float
}

namespace MoodAnimation_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace MotionBlendItem {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_flKeyValue = 0x8; // float
}

namespace MotionDBIndex {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint32_t
}

namespace MotionIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nMotion = 0x2; // uint16_t
}

namespace ParamSpanSample_t {
    constexpr std::ptrdiff_t m_value = 0x0; // CAnimVariant
    constexpr std::ptrdiff_t m_flCycle = 0x14; // float
}

namespace ParamSpan_t {
    constexpr std::ptrdiff_t m_samples = 0x0; // CUtlVector<ParamSpanSample_t>
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_flStartCycle = 0x1C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x20; // float
}

namespace PermModelDataAnimatedMaterialAttribute_t {
    constexpr std::ptrdiff_t m_AttributeName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNumChannels = 0x8; // int32_t
}

namespace PermModelData_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modelInfo = 0x8; // PermModelInfo_t
    constexpr std::ptrdiff_t m_ExtParts = 0x60; // CUtlVector<PermModelExtPart_t>
    constexpr std::ptrdiff_t m_refMeshes = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    constexpr std::ptrdiff_t m_refMeshGroupMasks = 0x90; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refPhysGroupMasks = 0xA8; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refLODGroupMasks = 0xC0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_lodGroupSwitchDistances = 0xD8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_refPhysicsData = 0xF0; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refPhysicsHitboxData = 0x108; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refAnimGroups = 0x120; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_refSequenceGroups = 0x138; // CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    constexpr std::ptrdiff_t m_meshGroups = 0x150; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_materialGroups = 0x168; // CUtlVector<MaterialGroup_t>
    constexpr std::ptrdiff_t m_nDefaultMeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_modelSkeleton = 0x188; // ModelSkeletonData_t
    constexpr std::ptrdiff_t m_remappingTable = 0x230; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_remappingTableStarts = 0x248; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_boneFlexDrivers = 0x260; // CUtlVector<ModelBoneFlexDriver_t>
    constexpr std::ptrdiff_t m_pModelConfigList = 0x278; // CModelConfigList*
    constexpr std::ptrdiff_t m_BodyGroupsHiddenInTools = 0x280; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_refAnimIncludeModels = 0x298; // CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_AnimatedMaterialAttributes = 0x2B0; // CUtlVector<PermModelDataAnimatedMaterialAttribute_t>
}

namespace PermModelExtPart_t {
    constexpr std::ptrdiff_t m_Transform = 0x0; // CTransform
    constexpr std::ptrdiff_t m_Name = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_nParent = 0x28; // int32_t
    constexpr std::ptrdiff_t m_refModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace PermModelInfo_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vHullMin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vHullMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_vViewMin = 0x1C; // Vector
    constexpr std::ptrdiff_t m_vViewMax = 0x28; // Vector
    constexpr std::ptrdiff_t m_flMass = 0x34; // float
    constexpr std::ptrdiff_t m_vEyePosition = 0x38; // Vector
    constexpr std::ptrdiff_t m_flMaxEyeDeflection = 0x44; // float
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_keyValueText = 0x50; // CUtlString
}

namespace PhysSoftbodyDesc_t {
    constexpr std::ptrdiff_t m_ParticleBoneHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Particles = 0x18; // CUtlVector<RnSoftbodyParticle_t>
    constexpr std::ptrdiff_t m_Springs = 0x30; // CUtlVector<RnSoftbodySpring_t>
    constexpr std::ptrdiff_t m_Capsules = 0x48; // CUtlVector<RnSoftbodyCapsule_t>
    constexpr std::ptrdiff_t m_InitPose = 0x60; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_ParticleBoneName = 0x78; // CUtlVector<CUtlString>
}

namespace RenderSkeletonBone_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_parentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_invBindPose = 0x10; // matrix3x4_t
    constexpr std::ptrdiff_t m_bbox = 0x40; // SkeletonBoneBounds_t
    constexpr std::ptrdiff_t m_flSphereRadius = 0x58; // float
}

namespace SampleCode {
    constexpr std::ptrdiff_t m_subCode = 0x0; // uint8_t[8]
}

namespace ScriptInfo_t {
    constexpr std::ptrdiff_t m_code = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_paramsModified = 0x8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_proxyReadParams = 0x20; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_proxyWriteParams = 0x38; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_eScriptType = 0x50; // AnimScriptType
}

namespace SkeletalInputOpFixedSettings_t {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<WristBone_t>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<FingerChain_t>
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x30; // int32_t
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x34; // int32_t
    constexpr std::ptrdiff_t m_eHand = 0x38; // AnimVRHand_t
    constexpr std::ptrdiff_t m_eMotionRange = 0x3C; // AnimVRHandMotionRange_t
    constexpr std::ptrdiff_t m_eTransformSource = 0x40; // AnimVrBoneTransformSource_t
    constexpr std::ptrdiff_t m_bEnableIK = 0x44; // bool
    constexpr std::ptrdiff_t m_bEnableCollision = 0x45; // bool
}

namespace SkeletonBoneBounds_t {
    constexpr std::ptrdiff_t m_vecCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_vecSize = 0xC; // Vector
}

namespace SolveIKChainPoseOpFixedSettings_t {
    constexpr std::ptrdiff_t m_ChainsToSolveData = 0x0; // CUtlVector<ChainToSolveData_t>
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x18; // bool
}

namespace StanceInfo_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_flDirection = 0xC; // float
}

namespace TagSpan_t {
    constexpr std::ptrdiff_t m_tagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_startCycle = 0x4; // float
    constexpr std::ptrdiff_t m_endCycle = 0x8; // float
}

namespace TraceSettings_t {
    constexpr std::ptrdiff_t m_flTraceHeight = 0x0; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x4; // float
}

namespace TwoBoneIKSettings_t {
    constexpr std::ptrdiff_t m_endEffectorType = 0x0; // IkEndEffectorType
    constexpr std::ptrdiff_t m_endEffectorAttachment = 0x10; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetType = 0x90; // IkTargetType
    constexpr std::ptrdiff_t m_targetAttachment = 0xA0; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetBoneIndex = 0x120; // int32_t
    constexpr std::ptrdiff_t m_hPositionParam = 0x124; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hRotationParam = 0x126; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x128; // bool
    constexpr std::ptrdiff_t m_vLsFallbackHingeAxis = 0x130; // VectorAligned
    constexpr std::ptrdiff_t m_nFixedBoneIndex = 0x140; // int32_t
    constexpr std::ptrdiff_t m_nMiddleBoneIndex = 0x144; // int32_t
    constexpr std::ptrdiff_t m_nEndBoneIndex = 0x148; // int32_t
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x14C; // bool
    constexpr std::ptrdiff_t m_bConstrainTwist = 0x14D; // bool
    constexpr std::ptrdiff_t m_flMaxTwist = 0x150; // float
}

namespace VPhysXAggregateData_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nRefCounter = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_bonesHash = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x20; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_indexNames = 0x38; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_indexHash = 0x50; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_bindPose = 0x68; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_parts = 0x80; // CUtlVector<VPhysXBodyPart_t>
    constexpr std::ptrdiff_t m_constraints2 = 0x98; // CUtlVector<VPhysXConstraint2_t>
    constexpr std::ptrdiff_t m_joints = 0xB0; // CUtlVector<VPhysXJoint_t>
    constexpr std::ptrdiff_t m_pFeModel = 0xC8; // PhysFeModelDesc_t*
    constexpr std::ptrdiff_t m_boneParents = 0xD0; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_surfacePropertyHashes = 0xE8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_collisionAttributes = 0x100; // CUtlVector<VPhysXCollisionAttributes_t>
    constexpr std::ptrdiff_t m_debugPartNames = 0x118; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_embeddedKeyvalues = 0x130; // CUtlString
}

namespace VPhysXBodyPart_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flMass = 0x4; // float
    constexpr std::ptrdiff_t m_rnShape = 0x8; // VPhysics2ShapeDef_t
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x80; // uint16_t
    constexpr std::ptrdiff_t m_nReserved = 0x82; // uint16_t
    constexpr std::ptrdiff_t m_flInertiaScale = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x8C; // float
    constexpr std::ptrdiff_t m_bOverrideMassCenter = 0x90; // bool
    constexpr std::ptrdiff_t m_vMassCenterOverride = 0x94; // Vector
}

namespace VPhysXCollisionAttributes_t {
    constexpr std::ptrdiff_t m_CollisionGroup = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_InteractAs = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractWith = 0x20; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractExclude = 0x38; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CollisionGroupString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_InteractAsStrings = 0x58; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractWithStrings = 0x70; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractExcludeStrings = 0x88; // CUtlVector<CUtlString>
}

namespace VPhysXConstraint2_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nParent = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nChild = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_params = 0x8; // VPhysXConstraintParams_t
}

namespace VPhysXConstraintParams_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // int8_t
    constexpr std::ptrdiff_t m_nTranslateMotion = 0x1; // int8_t
    constexpr std::ptrdiff_t m_nRotateMotion = 0x2; // int8_t
    constexpr std::ptrdiff_t m_nFlags = 0x3; // int8_t
    constexpr std::ptrdiff_t m_anchor = 0x4; // Vector[2]
    constexpr std::ptrdiff_t m_axes = 0x1C; // QuaternionStorage[2]
    constexpr std::ptrdiff_t m_maxForce = 0x3C; // float
    constexpr std::ptrdiff_t m_maxTorque = 0x40; // float
    constexpr std::ptrdiff_t m_linearLimitValue = 0x44; // float
    constexpr std::ptrdiff_t m_linearLimitRestitution = 0x48; // float
    constexpr std::ptrdiff_t m_linearLimitSpring = 0x4C; // float
    constexpr std::ptrdiff_t m_linearLimitDamping = 0x50; // float
    constexpr std::ptrdiff_t m_twistLowLimitValue = 0x54; // float
    constexpr std::ptrdiff_t m_twistLowLimitRestitution = 0x58; // float
    constexpr std::ptrdiff_t m_twistLowLimitSpring = 0x5C; // float
    constexpr std::ptrdiff_t m_twistLowLimitDamping = 0x60; // float
    constexpr std::ptrdiff_t m_twistHighLimitValue = 0x64; // float
    constexpr std::ptrdiff_t m_twistHighLimitRestitution = 0x68; // float
    constexpr std::ptrdiff_t m_twistHighLimitSpring = 0x6C; // float
    constexpr std::ptrdiff_t m_twistHighLimitDamping = 0x70; // float
    constexpr std::ptrdiff_t m_swing1LimitValue = 0x74; // float
    constexpr std::ptrdiff_t m_swing1LimitRestitution = 0x78; // float
    constexpr std::ptrdiff_t m_swing1LimitSpring = 0x7C; // float
    constexpr std::ptrdiff_t m_swing1LimitDamping = 0x80; // float
    constexpr std::ptrdiff_t m_swing2LimitValue = 0x84; // float
    constexpr std::ptrdiff_t m_swing2LimitRestitution = 0x88; // float
    constexpr std::ptrdiff_t m_swing2LimitSpring = 0x8C; // float
    constexpr std::ptrdiff_t m_swing2LimitDamping = 0x90; // float
    constexpr std::ptrdiff_t m_goalPosition = 0x94; // Vector
    constexpr std::ptrdiff_t m_goalOrientation = 0xA0; // QuaternionStorage
    constexpr std::ptrdiff_t m_goalAngularVelocity = 0xB0; // Vector
    constexpr std::ptrdiff_t m_driveSpringX = 0xBC; // float
    constexpr std::ptrdiff_t m_driveSpringY = 0xC0; // float
    constexpr std::ptrdiff_t m_driveSpringZ = 0xC4; // float
    constexpr std::ptrdiff_t m_driveDampingX = 0xC8; // float
    constexpr std::ptrdiff_t m_driveDampingY = 0xCC; // float
    constexpr std::ptrdiff_t m_driveDampingZ = 0xD0; // float
    constexpr std::ptrdiff_t m_driveSpringTwist = 0xD4; // float
    constexpr std::ptrdiff_t m_driveSpringSwing = 0xD8; // float
    constexpr std::ptrdiff_t m_driveSpringSlerp = 0xDC; // float
    constexpr std::ptrdiff_t m_driveDampingTwist = 0xE0; // float
    constexpr std::ptrdiff_t m_driveDampingSwing = 0xE4; // float
    constexpr std::ptrdiff_t m_driveDampingSlerp = 0xE8; // float
    constexpr std::ptrdiff_t m_solverIterationCount = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_projectionLinearTolerance = 0xF0; // float
    constexpr std::ptrdiff_t m_projectionAngularTolerance = 0xF4; // float
}

namespace VPhysXJoint_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nBody1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBody2 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_Frame1 = 0x10; // CTransform
    constexpr std::ptrdiff_t m_Frame2 = 0x30; // CTransform
    constexpr std::ptrdiff_t m_bEnableCollision = 0x50; // bool
    constexpr std::ptrdiff_t m_bEnableLinearLimit = 0x51; // bool
    constexpr std::ptrdiff_t m_LinearLimit = 0x54; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableLinearMotor = 0x5C; // bool
    constexpr std::ptrdiff_t m_vLinearTargetVelocity = 0x60; // Vector
    constexpr std::ptrdiff_t m_flMaxForce = 0x6C; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x70; // bool
    constexpr std::ptrdiff_t m_SwingLimit = 0x74; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x7C; // bool
    constexpr std::ptrdiff_t m_TwistLimit = 0x80; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableAngularMotor = 0x88; // bool
    constexpr std::ptrdiff_t m_vAngularTargetVelocity = 0x8C; // Vector
    constexpr std::ptrdiff_t m_flMaxTorque = 0x98; // float
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x9C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0xA0; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0xA4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0xA8; // float
    constexpr std::ptrdiff_t m_flFriction = 0xAC; // float
}

namespace VPhysXRange_t {
    constexpr std::ptrdiff_t m_flMin = 0x0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4; // float
}

namespace VPhysics2ShapeDef_t {
    constexpr std::ptrdiff_t m_spheres = 0x0; // CUtlVector<RnSphereDesc_t>
    constexpr std::ptrdiff_t m_capsules = 0x18; // CUtlVector<RnCapsuleDesc_t>
    constexpr std::ptrdiff_t m_hulls = 0x30; // CUtlVector<RnHullDesc_t>
    constexpr std::ptrdiff_t m_meshes = 0x48; // CUtlVector<RnMeshDesc_t>
    constexpr std::ptrdiff_t m_CollisionAttributeIndices = 0x60; // CUtlVector<uint16_t>
}

namespace WeightList {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_weights = 0x8; // CUtlVector<float>
}

namespace WristBone_t {
    constexpr std::ptrdiff_t m_xOffsetTransformMS = 0x0; // CTransform
    constexpr std::ptrdiff_t m_boneIndex = 0x20; // int32_t
}
```

`HPCS2/HPCS2/offset/client.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:22 +0000
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBaseAnimGraph { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0xCC1; // bool
    constexpr std::ptrdiff_t m_bSuppressAnimEventSounds = 0xCC3; // bool
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0xCD4; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vecForce = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_pClientsideRagdoll = 0xCF8; // CBaseAnimGraph*
    constexpr std::ptrdiff_t m_bBuiltRagdoll = 0xD00; // bool
    constexpr std::ptrdiff_t m_pRagdollPose = 0xD18; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0xD20; // bool
    constexpr std::ptrdiff_t m_bHasAnimatedMaterialAttributes = 0xD30; // bool
}

namespace CBaseAnimGraphController { // CSkeletonAnimationController
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x1320; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x1324; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x1328; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x132C; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x1334; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x1338; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x1339; // bool
    constexpr std::ptrdiff_t m_nPrevNewSequenceParity = 0x133A; // uint8_t
    constexpr std::ptrdiff_t m_nPrevResetEventsParity = 0x133B; // uint8_t
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x133C; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x1344; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x13E4; // AnimationUpdateListHandle_t
    constexpr std::ptrdiff_t m_hLastAnimEventSequence = 0x13E8; // HSequence
}

namespace CBasePlayerController { // C_BaseEntity
    constexpr std::ptrdiff_t m_nFinalPredictedTick = 0x548; // int32_t
    constexpr std::ptrdiff_t m_CommandContext = 0x550; // C_CommandContext
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x5D0; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x5D8; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x5DC; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_hPredictedPawn = 0x5E0; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x5E4; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x5E8; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x5F0; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x608; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x60C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x610; // char[128]
    constexpr std::ptrdiff_t m_steamID = 0x698; // uint64_t
    constexpr std::ptrdiff_t m_bIsLocalPlayerController = 0x6A0; // bool
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x6A4; // uint32_t
}

namespace CBasePlayerVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeaponVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0xE80; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0xE88; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0xE8C; // matrix3x4_t
}

namespace CBodyComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x18C0; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint { // CBodyComponent
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance { // CBodyComponent
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget { // C_BaseTrigger
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0xCC8; // bool
}

namespace CBreachCharge { // C_CSWeaponBase
}

namespace CBreachChargeProjectile { // C_BaseGrenade
}

namespace CBumpMine { // C_CSWeaponBase
}

namespace CBumpMineProjectile { // C_BaseGrenade
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CCSGO_WingmanIntroCharacterPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace CCSGO_WingmanIntroCounterTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGO_WingmanIntroTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch { // CCSGameModeRules
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSGameModeRules_Noop { // CCSGameModeRules
}

namespace CCSGameModeRules_Scripted { // CCSGameModeRules
}

namespace CCSGameModeScript { // CBasePulseGraphInstance
}

namespace CCSObserver_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSObserver_MovementServices { // CPlayer_MovementServices
}

namespace CCSObserver_ObserverServices { // CPlayer_ObserverServices
    constexpr std::ptrdiff_t m_hLastObserverTarget = 0x58; // CEntityHandle
    constexpr std::ptrdiff_t m_vecObserverInterpolateOffset = 0x5C; // Vector
    constexpr std::ptrdiff_t m_vecObserverInterpStartPos = 0x68; // Vector
    constexpr std::ptrdiff_t m_flObsInterp_PathLength = 0x74; // float
    constexpr std::ptrdiff_t m_qObsInterp_OrientationStart = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qObsInterp_OrientationTravelDir = 0x90; // Quaternion
    constexpr std::ptrdiff_t m_obsInterpState = 0xA0; // ObserverInterpState_t
    constexpr std::ptrdiff_t m_bObserverInterpolationNeedsDeferredSetup = 0xA4; // bool
}

namespace CCSObserver_UseServices { // CPlayer_UseServices
}

namespace CCSObserver_ViewModelServices { // CPlayer_ViewModelServices
}

namespace CCSPlayerBase_CameraServices { // CPlayer_CameraServices
    constexpr std::ptrdiff_t m_iFOV = 0x210; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x214; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x21C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x220; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flLastShotFOV = 0x224; // float
}

namespace CCSPlayerController { // CBasePlayerController
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x6D0; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x6D8; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x6E0; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x6E8; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x6F0; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x6F4; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x6F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x700; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x704; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x708; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x70C; // bool
    constexpr std::ptrdiff_t m_flPreviousForceJoinTeamTime = 0x710; // GameTime_t
    constexpr std::ptrdiff_t m_szClan = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSanitizedPlayerName = 0x720; // CUtlString
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x728; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x730; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x738; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x740; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x744; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x748; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x750; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x754; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x758; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x75C; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x760; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x764; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x790; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x794; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x798; // uint32_t
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x79C; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x79D; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x79E; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x79F; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7A0; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7A4; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7B0; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7B1; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7B2; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7B4; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7B8; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7BC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7C0; // CHandle<C_CSObserverPawn>
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7C4; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7C8; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x7D1; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x7D2; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x7D4; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x7D8; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x7DC; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x7E0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x7E8; // C_NetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x800; // int32_t
    constexpr std::ptrdiff_t m_bIsPlayerNameDirty = 0x804; // bool
}

namespace CCSPlayerController_ActionTrackingServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x108; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x110; // uint32_t
}

namespace CCSPlayerController_DamageServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // C_UtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_iAccount = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nPreviousAccount = 0x50; // int32_t
}

namespace CCSPlayerController_InventoryServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0x70; // C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayer_ActionTrackingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x40; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x44; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x48; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0xA0; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0x40; // C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_CameraServices { // CCSPlayerBase_CameraServices
    constexpr std::ptrdiff_t m_flDeathCamTilt = 0x228; // float
}

namespace CCSPlayer_GlowServices { // CPlayerPawnComponent
}

namespace CCSPlayer_HostageServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_ItemServices { // CPlayer_ItemServices
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices { // CPlayer_MovementServices_Humanoid
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x210; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x214; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x220; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x224; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x228; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x22C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x22D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x230; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x234; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x238; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x23C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x240; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x250; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x258; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x259; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x25A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x268; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x468; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x46C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x470; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x474; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x478; // float
    constexpr std::ptrdiff_t m_vecForward = 0x47C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x488; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x494; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4A0; // Vector
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4AC; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4B0; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4B4; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4B8; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4BC; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4C0; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4CC; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4D0; // float
    constexpr std::ptrdiff_t m_bUpdatePredictedOriginAfterDataUpdate = 0x4D4; // bool
}

namespace CCSPlayer_PingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hPlayerPing = 0x40; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_UseServices { // CPlayer_UseServices
}

namespace CCSPlayer_ViewModelServices { // CPlayer_ViewModelServices
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<C_BaseViewModel>[3]
}

namespace CCSPlayer_WaterServices { // CPlayer_WaterServices
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x40; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x44; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x50; // float
}

namespace CCSPlayer_WeaponServices { // CPlayer_WeaponServices
    constexpr std::ptrdiff_t m_flNextAttack = 0xA8; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xAC; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xAD; // bool
}

namespace CCSWeaponBaseVData { // CBasePlayerWeaponVData
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CClientAlphaProperty { // IClientAlphaProperty
    constexpr std::ptrdiff_t m_nRenderFX = 0x10; // uint8_t
    constexpr std::ptrdiff_t m_nRenderMode = 0x11; // uint8_t
    constexpr std::ptrdiff_t m_bAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShadowAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nReserved = 0x0; // bitfield:6
    constexpr std::ptrdiff_t m_nAlpha = 0x13; // uint8_t
    constexpr std::ptrdiff_t m_nDesyncOffset = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nReserved2 = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeStart = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeEnd = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flFadeScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flRenderFxStartTime = 0x20; // GameTime_t
    constexpr std::ptrdiff_t m_flRenderFxDuration = 0x24; // float
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CComicBook {
    constexpr std::ptrdiff_t m_CoverImage = 0x8; // CPanoramaImageName
    constexpr std::ptrdiff_t m_XmlFile = 0x18; // CUtlString
}

namespace CCompositeMaterialEditorDoc {
    constexpr std::ptrdiff_t m_nVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Points = 0x10; // CUtlVector<CompositeMaterialEditorPoint_t>
    constexpr std::ptrdiff_t m_KVthumbnail = 0x28; // KeyValues3
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDecalInfo {
    constexpr std::ptrdiff_t m_flAnimationScale = 0x0; // float
    constexpr std::ptrdiff_t m_flAnimationLifeSpan = 0x4; // float
    constexpr std::ptrdiff_t m_flPlaceTime = 0x8; // float
    constexpr std::ptrdiff_t m_flFadeStartTime = 0xC; // float
    constexpr std::ptrdiff_t m_flFadeDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nVBSlot = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nBoneIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_pNext = 0x28; // CDecalInfo*
    constexpr std::ptrdiff_t m_pPrev = 0x30; // CDecalInfo*
    constexpr std::ptrdiff_t m_nDecalMaterialIndex = 0x90; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEntityComponent {
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CFireOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_pOwner = 0xD0; // C_FireSmoke*
    constexpr std::ptrdiff_t m_vBaseColors = 0xD8; // Vector[4]
    constexpr std::ptrdiff_t m_flScale = 0x108; // float
    constexpr std::ptrdiff_t m_nGUID = 0x10C; // int32_t
}

namespace CFlashlightEffect {
    constexpr std::ptrdiff_t m_bIsOn = 0x10; // bool
    constexpr std::ptrdiff_t m_bMuzzleFlashEnabled = 0x20; // bool
    constexpr std::ptrdiff_t m_flMuzzleFlashBrightness = 0x24; // float
    constexpr std::ptrdiff_t m_quatMuzzleFlashOrientation = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_vecMuzzleFlashOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flFov = 0x4C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x50; // float
    constexpr std::ptrdiff_t m_flLinearAtten = 0x54; // float
    constexpr std::ptrdiff_t m_bCastsShadows = 0x58; // bool
    constexpr std::ptrdiff_t m_flCurrentPullBackDist = 0x5C; // float
    constexpr std::ptrdiff_t m_FlashlightTexture = 0x60; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_MuzzleFlashTexture = 0x68; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_textureName = 0x70; // char[64]
}

namespace CFuncWater { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC0; // CBuoyancyHelper
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGlobalLightBase {
    constexpr std::ptrdiff_t m_bSpotLight = 0x10; // bool
    constexpr std::ptrdiff_t m_SpotLightOrigin = 0x14; // Vector
    constexpr std::ptrdiff_t m_SpotLightAngles = 0x20; // QAngle
    constexpr std::ptrdiff_t m_ShadowDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_AmbientDirection = 0x38; // Vector
    constexpr std::ptrdiff_t m_SpecularDirection = 0x44; // Vector
    constexpr std::ptrdiff_t m_InspectorSpecularDirection = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSpecularPower = 0x5C; // float
    constexpr std::ptrdiff_t m_flSpecularIndependence = 0x60; // float
    constexpr std::ptrdiff_t m_SpecularColor = 0x64; // Color
    constexpr std::ptrdiff_t m_bStartDisabled = 0x68; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x69; // bool
    constexpr std::ptrdiff_t m_LightColor = 0x6A; // Color
    constexpr std::ptrdiff_t m_AmbientColor1 = 0x6E; // Color
    constexpr std::ptrdiff_t m_AmbientColor2 = 0x72; // Color
    constexpr std::ptrdiff_t m_AmbientColor3 = 0x76; // Color
    constexpr std::ptrdiff_t m_flSunDistance = 0x7C; // float
    constexpr std::ptrdiff_t m_flFOV = 0x80; // float
    constexpr std::ptrdiff_t m_flNearZ = 0x84; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x88; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x8C; // bool
    constexpr std::ptrdiff_t m_bOldEnableShadows = 0x8D; // bool
    constexpr std::ptrdiff_t m_bBackgroundClearNotRequired = 0x8E; // bool
    constexpr std::ptrdiff_t m_flCloudScale = 0x90; // float
    constexpr std::ptrdiff_t m_flCloud1Speed = 0x94; // float
    constexpr std::ptrdiff_t m_flCloud1Direction = 0x98; // float
    constexpr std::ptrdiff_t m_flCloud2Speed = 0x9C; // float
    constexpr std::ptrdiff_t m_flCloud2Direction = 0xA0; // float
    constexpr std::ptrdiff_t m_flAmbientScale1 = 0xB0; // float
    constexpr std::ptrdiff_t m_flAmbientScale2 = 0xB4; // float
    constexpr std::ptrdiff_t m_flGroundScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flLightScale = 0xBC; // float
    constexpr std::ptrdiff_t m_flFoWDarkness = 0xC0; // float
    constexpr std::ptrdiff_t m_bEnableSeparateSkyboxFog = 0xC4; // bool
    constexpr std::ptrdiff_t m_vFowColor = 0xC8; // Vector
    constexpr std::ptrdiff_t m_ViewOrigin = 0xD4; // Vector
    constexpr std::ptrdiff_t m_ViewAngles = 0xE0; // QAngle
    constexpr std::ptrdiff_t m_flViewFoV = 0xEC; // float
    constexpr std::ptrdiff_t m_WorldPoints = 0xF0; // Vector[8]
    constexpr std::ptrdiff_t m_vFogOffsetLayer0 = 0x4A8; // Vector2D
    constexpr std::ptrdiff_t m_vFogOffsetLayer1 = 0x4B0; // Vector2D
    constexpr std::ptrdiff_t m_hEnvWind = 0x4B8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEnvSky = 0x4BC; // CHandle<C_BaseEntity>
}

namespace CGlowOverlay {
    constexpr std::ptrdiff_t m_vPos = 0x8; // Vector
    constexpr std::ptrdiff_t m_bDirectional = 0x14; // bool
    constexpr std::ptrdiff_t m_vDirection = 0x18; // Vector
    constexpr std::ptrdiff_t m_bInSky = 0x24; // bool
    constexpr std::ptrdiff_t m_skyObstructionScale = 0x28; // float
    constexpr std::ptrdiff_t m_Sprites = 0x30; // CGlowSprite[4]
    constexpr std::ptrdiff_t m_nSprites = 0xB0; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0xB4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flGlowObstructionScale = 0xBC; // float
    constexpr std::ptrdiff_t m_bCacheGlowObstruction = 0xC0; // bool
    constexpr std::ptrdiff_t m_bCacheSkyObstruction = 0xC1; // bool
    constexpr std::ptrdiff_t m_bActivated = 0xC2; // int16_t
    constexpr std::ptrdiff_t m_ListIndex = 0xC4; // uint16_t
    constexpr std::ptrdiff_t m_queryHandle = 0xC8; // int32_t
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGlowSprite {
    constexpr std::ptrdiff_t m_vColor = 0x0; // Vector
    constexpr std::ptrdiff_t m_flHorzSize = 0xC; // float
    constexpr std::ptrdiff_t m_flVertSize = 0x10; // float
    constexpr std::ptrdiff_t m_hMaterial = 0x18; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CGrenadeTracer { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flTracerDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_nType = 0xCE4; // GrenadeType_t
}

namespace CHitboxComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CHostageRescueZone { // CHostageRescueZoneShim
}

namespace CHostageRescueZoneShim { // C_BaseTrigger
}

namespace CInfoDynamicShadowHint { // C_PointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_flRange = 0x544; // float
    constexpr std::ptrdiff_t m_nImportance = 0x548; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x54C; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x550; // CHandle<C_BaseEntity>
}

namespace CInfoDynamicShadowHintBox { // CInfoDynamicShadowHint
    constexpr std::ptrdiff_t m_vBoxMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x564; // Vector
}

namespace CInfoOffscreenPanoramaTexture { // C_PointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x548; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x578; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x580; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0x6F8; // bool
}

namespace CInfoParticleTarget { // C_PointEntity
}

namespace CInfoTarget { // C_PointEntity
}

namespace CInfoWorldLayer { // C_BaseEntity
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x578; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x579; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x57A; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x57C; // uint32_t
    constexpr std::ptrdiff_t m_bWorldLayerActuallyVisible = 0x580; // bool
}

namespace CInterpolatedValue {
    constexpr std::ptrdiff_t m_flStartTime = 0x0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x4; // float
    constexpr std::ptrdiff_t m_flStartValue = 0x8; // float
    constexpr std::ptrdiff_t m_flEndValue = 0xC; // float
    constexpr std::ptrdiff_t m_nInterpType = 0x10; // int32_t
}

namespace CLightComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
}

namespace CLogicRelay { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTrigger = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x568; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x590; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x591; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x592; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x593; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x594; // bool
}

namespace CLogicalEntity { // C_BaseEntity
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace CPlayerSprayDecalRenderHelper {
}

namespace CPlayer_AutoaimServices { // CPlayerPawnComponent
}

namespace CPlayer_CameraServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // C_fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<C_ColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<C_TonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_CurrentFog = 0x140; // fogparams_t
    constexpr std::ptrdiff_t m_hOldFogController = 0x1A8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_bOverrideFogColor = 0x1AC; // bool[5]
    constexpr std::ptrdiff_t m_OverrideFogColor = 0x1B1; // Color[5]
    constexpr std::ptrdiff_t m_bOverrideFogStartEnd = 0x1C5; // bool[5]
    constexpr std::ptrdiff_t m_fOverrideFogStart = 0x1CC; // float[5]
    constexpr std::ptrdiff_t m_fOverrideFogEnd = 0x1E0; // float[5]
    constexpr std::ptrdiff_t m_hActivePostProcessingVolume = 0x1F4; // CHandle<C_PostProcessingVolume>
    constexpr std::ptrdiff_t m_angDemoViewAngles = 0x1F8; // QAngle
}

namespace CPlayer_FlashlightServices { // CPlayerPawnComponent
}

namespace CPlayer_ItemServices { // CPlayerPawnComponent
}

namespace CPlayer_MovementServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid { // CPlayer_MovementServices
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
}

namespace CPlayer_ObserverServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
    constexpr std::ptrdiff_t m_flObserverChaseDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flObserverChaseDistanceCalcTime = 0x54; // GameTime_t
}

namespace CPlayer_UseServices { // CPlayerPawnComponent
}

namespace CPlayer_ViewModelServices { // CPlayerPawnComponent
}

namespace CPlayer_WaterServices { // CPlayerPawnComponent
}

namespace CPlayer_WeaponServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
}

namespace CPointOffScreenIndicatorUi { // C_PointClientUIWorldPanel
    constexpr std::ptrdiff_t m_bBeenEnabled = 0xF20; // bool
    constexpr std::ptrdiff_t m_bHide = 0xF21; // bool
    constexpr std::ptrdiff_t m_flSeenTargetTime = 0xF24; // float
    constexpr std::ptrdiff_t m_pTargetPanel = 0xF28; // C_PointClientUIWorldPanel*
}

namespace CPointTemplate { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszWorldName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x558; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x55C; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x588; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x58C; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x590; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x5A8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x5C0; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x5C8; // HSCRIPT
}

namespace CPrecipitationVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CProjectedTextureBase {
    constexpr std::ptrdiff_t m_hTargetEntity = 0xC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x10; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x11; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x14; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x18; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x19; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x1A; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x1B; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x1C; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x20; // float
    constexpr std::ptrdiff_t m_LightColor = 0x24; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x2C; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x30; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x34; // bool
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x38; // float
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x3C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x40; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x48; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x4C; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x50; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x54; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x258; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x25C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x260; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x264; // float
    constexpr std::ptrdiff_t m_flRotation = 0x268; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x26C; // bool
}

namespace CRenderComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CSMatchStats_t { // CSPerRoundStats_t
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CServerOnlyModelEntity { // C_BaseModelEntity
}

namespace CSkeletonInstance { // CGameSceneNode
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkyboxReference { // C_BaseEntity
    constexpr std::ptrdiff_t m_worldGroupId = 0x540; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x544; // CHandle<C_SkyCamera>
}

namespace CTablet { // C_CSWeaponBase
}

namespace CTimeline { // IntervalTimer
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace CTripWireFire { // C_BaseCSGrenade
}

namespace CTripWireFireProjectile { // C_BaseGrenade
}

namespace CWaterSplasher { // C_BaseModelEntity
}

namespace CWeaponZoneRepulsor { // C_CSWeaponBaseGun
}

namespace C_AK47 { // C_CSWeaponBaseGun
}

namespace C_AttributeContainer { // CAttributeManager
    constexpr std::ptrdiff_t m_Item = 0x50; // C_EconItemView
    constexpr std::ptrdiff_t m_iExternalItemProviderRegisteredToken = 0x498; // int32_t
    constexpr std::ptrdiff_t m_ullRegisteredAsItemID = 0x4A0; // uint64_t
}

namespace C_BarnLight { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0xCC4; // int32_t
    constexpr std::ptrdiff_t m_Color = 0xCC8; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0xCCC; // float
    constexpr std::ptrdiff_t m_flBrightness = 0xCD0; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCD4; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0xCE4; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0xCE8; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0xCF0; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0xCF8; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0xD00; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0xD18; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0xD30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0xD48; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0xDE8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0xDF0; // float
    constexpr std::ptrdiff_t m_flSoftX = 0xDF4; // float
    constexpr std::ptrdiff_t m_flSoftY = 0xDF8; // float
    constexpr std::ptrdiff_t m_flSkirt = 0xDFC; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0xE00; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0xE04; // Vector
    constexpr std::ptrdiff_t m_flRange = 0xE10; // float
    constexpr std::ptrdiff_t m_vShear = 0xE14; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0xE20; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0xE24; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0xE30; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0xE38; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0xE3C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0xE40; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0xE44; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0xE48; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0xE4C; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0xE58; // float
    constexpr std::ptrdiff_t m_nFog = 0xE5C; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0xE60; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0xE64; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0xE68; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0xE6C; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0xE70; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0xE74; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0xE78; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0xE7C; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0xE98; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0xEA4; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0xEB0; // Vector
}

namespace C_BaseButton { // C_BaseToggle
    constexpr std::ptrdiff_t m_glowEntity = 0xCC0; // CHandle<C_BaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0xCC4; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0xCC8; // CUtlSymbolLarge
}

namespace C_BaseCSGrenade { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_bClientPredictDelete = 0x1990; // bool
    constexpr std::ptrdiff_t m_bRedraw = 0x1991; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0x1992; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0x1993; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0x1994; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0x1998; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0x199C; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0x19A0; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0x19A4; // float
    constexpr std::ptrdiff_t m_fDropTime = 0x19A8; // GameTime_t
}

namespace C_BaseCSGrenadeProjectile { // C_BaseGrenade
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x1068; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x1074; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x1078; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x1080; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x1084; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0x1090; // GameTime_t
    constexpr std::ptrdiff_t vecLastTrailLinePos = 0x1094; // Vector
    constexpr std::ptrdiff_t flNextTrailLineTime = 0x10A0; // GameTime_t
    constexpr std::ptrdiff_t m_bExplodeEffectBegan = 0x10A4; // bool
    constexpr std::ptrdiff_t m_bCanCreateGrenadeTrail = 0x10A5; // bool
    constexpr std::ptrdiff_t m_nSnapshotTrajectoryEffectIndex = 0x10A8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_hSnapshotTrajectoryParticleSnapshot = 0x10B0; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPoints = 0x10B8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPointCreationTimes = 0x10D0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flTrajectoryTrailEffectCreationTime = 0x10E8; // float
}

namespace C_BaseClientUIEntity { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0xCC8; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0xCD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0xCD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0xCE0; // CUtlSymbolLarge
}

namespace C_BaseCombatCharacter { // C_BaseFlex
    constexpr std::ptrdiff_t m_hMyWearables = 0x1018; // C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    constexpr std::ptrdiff_t m_bloodColor = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_leftFootAttachment = 0x1034; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_rightFootAttachment = 0x1035; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nWaterWakeMode = 0x1038; // C_BaseCombatCharacter::WaterWakeMode_t
    constexpr std::ptrdiff_t m_flWaterWorldZ = 0x103C; // float
    constexpr std::ptrdiff_t m_flWaterNextTraceTime = 0x1040; // float
    constexpr std::ptrdiff_t m_flFieldOfView = 0x1044; // float
}

namespace C_BaseDoor { // C_BaseToggle
    constexpr std::ptrdiff_t m_bIsUsable = 0xCC0; // bool
}

namespace C_BaseEntity { // CEntityInstance
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x308; // GameTick_t
    constexpr std::ptrdiff_t m_pGameSceneNode = 0x310; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pRenderComponent = 0x318; // CRenderComponent*
    constexpr std::ptrdiff_t m_pCollision = 0x320; // CCollisionProperty*
    constexpr std::ptrdiff_t m_iMaxHealth = 0x328; // int32_t
    constexpr std::ptrdiff_t m_iHealth = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x330; // uint8_t
    constexpr std::ptrdiff_t m_bTakesDamage = 0x331; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x334; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x338; // uint8_t
    constexpr std::ptrdiff_t m_hSceneObjectController = 0x33C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nNoInterpolationTick = 0x340; // int32_t
    constexpr std::ptrdiff_t m_nVisibilityNoInterpolationTick = 0x344; // int32_t
    constexpr std::ptrdiff_t m_flProxyRandomValue = 0x348; // float
    constexpr std::ptrdiff_t m_iEFlags = 0x34C; // int32_t
    constexpr std::ptrdiff_t m_nWaterType = 0x350; // uint8_t
    constexpr std::ptrdiff_t m_bInterpolateEvenWithNoModel = 0x351; // bool
    constexpr std::ptrdiff_t m_bPredictionEligible = 0x352; // bool
    constexpr std::ptrdiff_t m_bApplyLayerMatchIDToModel = 0x353; // bool
    constexpr std::ptrdiff_t m_tokLayerMatchID = 0x354; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSubclassID = 0x358; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSimulationTick = 0x368; // int32_t
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x36C; // int32_t
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x370; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_flAnimTime = 0x388; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x38C; // float
    constexpr std::ptrdiff_t m_nSceneObjectOverrideFlags = 0x390; // uint8_t
    constexpr std::ptrdiff_t m_bHasSuccessfullyInterpolated = 0x391; // bool
    constexpr std::ptrdiff_t m_bHasAddedVarsToInterpolation = 0x392; // bool
    constexpr std::ptrdiff_t m_bRenderEvenWhenNotSuccessfullyInterpolated = 0x393; // bool
    constexpr std::ptrdiff_t m_nInterpolationLatchDirtyFlags = 0x394; // int32_t[2]
    constexpr std::ptrdiff_t m_ListEntry = 0x39C; // uint16_t[11]
    constexpr std::ptrdiff_t m_flCreateTime = 0x3B4; // GameTime_t
    constexpr std::ptrdiff_t m_flSpeed = 0x3B8; // float
    constexpr std::ptrdiff_t m_EntClientFlags = 0x3BC; // uint16_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x3BE; // bool
    constexpr std::ptrdiff_t m_iTeamNum = 0x3BF; // uint8_t
    constexpr std::ptrdiff_t m_spawnflags = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x3C4; // GameTick_t
    constexpr std::ptrdiff_t m_fFlags = 0x3C8; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x3CC; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x3D8; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x408; // Vector
    constexpr std::ptrdiff_t m_hEffectEntity = 0x414; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x418; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_MoveCollide = 0x41C; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x41D; // MoveType_t
    constexpr std::ptrdiff_t m_flWaterLevel = 0x420; // float
    constexpr std::ptrdiff_t m_fEffects = 0x424; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x428; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x42C; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x430; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x434; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x438; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x43C; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x43D; // bool
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x440; // GameTime_t
    constexpr std::ptrdiff_t m_hThink = 0x444; // uint16_t
    constexpr std::ptrdiff_t m_fBBoxVisFlags = 0x450; // uint8_t
    constexpr std::ptrdiff_t m_bPredictable = 0x451; // bool
    constexpr std::ptrdiff_t m_bRenderWithViewModels = 0x452; // bool
    constexpr std::ptrdiff_t m_nSplitUserPlayerPredictionSlot = 0x454; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_nFirstPredictableCommand = 0x458; // int32_t
    constexpr std::ptrdiff_t m_nLastPredictableCommand = 0x45C; // int32_t
    constexpr std::ptrdiff_t m_hOldMoveParent = 0x460; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_Particles = 0x468; // CParticleProperty
    constexpr std::ptrdiff_t m_vecPredictedScriptFloats = 0x490; // CUtlVector<float>
    constexpr std::ptrdiff_t m_vecPredictedScriptFloatIDs = 0x4A8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nNextScriptVarRecordID = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x4E8; // QAngle
    constexpr std::ptrdiff_t m_DataChangeEventRef = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_dependencies = 0x4F8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_nCreationTick = 0x510; // int32_t
    constexpr std::ptrdiff_t m_bAnimTimeChanged = 0x529; // bool
    constexpr std::ptrdiff_t m_bSimulationTimeChanged = 0x52A; // bool
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x538; // CUtlString
}

namespace C_BaseFire { // C_BaseEntity
    constexpr std::ptrdiff_t m_flScale = 0x540; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x544; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x548; // float
    constexpr std::ptrdiff_t m_nFlags = 0x54C; // uint32_t
}

namespace C_BaseFlex { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_flexWeight = 0xE90; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0xEA8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0xEC0; // bool
    constexpr std::ptrdiff_t m_nLastFlexUpdateFrameCount = 0xF20; // int32_t
    constexpr std::ptrdiff_t m_CachedViewTarget = 0xF24; // Vector
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0xF30; // uint32_t
    constexpr std::ptrdiff_t m_iBlink = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_blinktime = 0xF38; // float
    constexpr std::ptrdiff_t m_prevblinktoggle = 0xF3C; // bool
    constexpr std::ptrdiff_t m_iJawOpen = 0xF40; // int32_t
    constexpr std::ptrdiff_t m_flJawOpenAmount = 0xF44; // float
    constexpr std::ptrdiff_t m_flBlinkAmount = 0xF48; // float
    constexpr std::ptrdiff_t m_iMouthAttachment = 0xF4C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xF4D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bResetFlexWeightsOnModelChange = 0xF4E; // bool
    constexpr std::ptrdiff_t m_nEyeOcclusionRendererBone = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_mEyeOcclusionRendererCameraToBoneTransform = 0xF6C; // matrix3x4_t
    constexpr std::ptrdiff_t m_vEyeOcclusionRendererHalfExtent = 0xF9C; // Vector
    constexpr std::ptrdiff_t m_PhonemeClasses = 0xFB8; // C_BaseFlex::Emphasized_Phoneme[3]
}

namespace C_BaseFlex_Emphasized_Phoneme {
    constexpr std::ptrdiff_t m_sClassName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flAmount = 0x18; // float
    constexpr std::ptrdiff_t m_bRequired = 0x1C; // bool
    constexpr std::ptrdiff_t m_bBasechecked = 0x1D; // bool
    constexpr std::ptrdiff_t m_bValid = 0x1E; // bool
}

namespace C_BaseGrenade { // C_BaseFlex
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x1018; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x1019; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x101A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x101C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x1020; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x1024; // float
    constexpr std::ptrdiff_t m_flDamage = 0x1028; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x1030; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x1038; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x1044; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x105C; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x1060; // CHandle<C_CSPlayerPawn>
}

namespace C_BaseModelEntity { // C_BaseEntity
    constexpr std::ptrdiff_t m_CRenderComponent = 0xA10; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0xA18; // CHitboxComponent
    constexpr std::ptrdiff_t m_bInitModelEffects = 0xA60; // bool
    constexpr std::ptrdiff_t m_bIsStaticProp = 0xA61; // bool
    constexpr std::ptrdiff_t m_nLastAddDecal = 0xA64; // int32_t
    constexpr std::ptrdiff_t m_nDecalsAdded = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_iOldHealth = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_nRenderMode = 0xA70; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0xA71; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0xA72; // bool
    constexpr std::ptrdiff_t m_clrRender = 0xA73; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0xA78; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0xAE0; // bool
    constexpr std::ptrdiff_t m_Collision = 0xAE8; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0xB98; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0xBF0; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0xBF4; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0xBF8; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0xBFC; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0xC00; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0xC04; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0xC0C; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0xC18; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0xC24; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0xC28; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0xC30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0xC48; // CNetworkViewOffsetVector
    constexpr std::ptrdiff_t m_pClientAlphaProperty = 0xC78; // CClientAlphaProperty*
    constexpr std::ptrdiff_t m_ClientOverrideTint = 0xC80; // Color
    constexpr std::ptrdiff_t m_bUseClientOverrideTint = 0xC84; // bool
}

namespace C_BasePlayerPawn { // C_BaseCombatCharacter
    constexpr std::ptrdiff_t m_pWeaponServices = 0x10A8; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x10B0; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x10B8; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x10C0; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x10C8; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x10D0; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0x10D8; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0x10E0; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0x10E8; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0x10F8; // C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestConsumedServerViewAngleChangeIndex = 0x1148; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0x114C; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0x1158; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0x1164; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0x1168; // sky3dparams_t
    constexpr std::ptrdiff_t m_flDeathTime = 0x11F8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPredictionError = 0x11FC; // Vector
    constexpr std::ptrdiff_t m_flPredictionErrorTime = 0x1208; // GameTime_t
    constexpr std::ptrdiff_t m_vecLastCameraSetupLocalOrigin = 0x120C; // Vector
    constexpr std::ptrdiff_t m_flLastCameraSetupTime = 0x1218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVSensitivityAdjust = 0x121C; // float
    constexpr std::ptrdiff_t m_flMouseSensitivity = 0x1220; // float
    constexpr std::ptrdiff_t m_vOldOrigin = 0x1224; // Vector
    constexpr std::ptrdiff_t m_flOldSimulationTime = 0x1230; // float
    constexpr std::ptrdiff_t m_nLastExecutedCommandNumber = 0x1234; // int32_t
    constexpr std::ptrdiff_t m_nLastExecutedCommandTick = 0x1238; // int32_t
    constexpr std::ptrdiff_t m_hController = 0x123C; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_bIsSwappingToPredictableController = 0x1240; // bool
}

namespace C_BasePlayerWeapon { // C_EconEntity
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0x1560; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0x1564; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0x1568; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0x156C; // float
    constexpr std::ptrdiff_t m_iClip1 = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0x1578; // int32_t[2]
}

namespace C_BasePropDoor { // C_DynamicProp
    constexpr std::ptrdiff_t m_eDoorState = 0x10F8; // DoorState_t
    constexpr std::ptrdiff_t m_modelChanged = 0x10FC; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x10FD; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0x1100; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0x110C; // QAngle
    constexpr std::ptrdiff_t m_hMaster = 0x1118; // CHandle<C_BasePropDoor>
    constexpr std::ptrdiff_t m_vWhereToSetLightingOrigin = 0x111C; // Vector
}

namespace C_BaseToggle { // C_BaseModelEntity
}

namespace C_BaseTrigger { // C_BaseToggle
    constexpr std::ptrdiff_t m_bDisabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0xCC1; // bool
}

namespace C_BaseViewModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_vecLastFacing = 0xE88; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xE94; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0xE9C; // float
    constexpr std::ptrdiff_t m_hWeapon = 0xEA0; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0xEB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hWeaponModel = 0xEB8; // CHandle<C_ViewmodelWeapon>
    constexpr std::ptrdiff_t m_iCameraAttachment = 0xEBC; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_vecLastCameraAngles = 0xEC0; // QAngle
    constexpr std::ptrdiff_t m_previousElapsedDuration = 0xECC; // float
    constexpr std::ptrdiff_t m_previousCycle = 0xED0; // float
    constexpr std::ptrdiff_t m_nOldAnimationParity = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0xED8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0xEDC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0xEE0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0xEE4; // CHandle<C_BaseEntity>
}

namespace C_Beam { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flFrameRate = 0xCC0; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCC4; // float
    constexpr std::ptrdiff_t m_flFireTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0xCCC; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0xCD0; // uint8_t
    constexpr std::ptrdiff_t m_queryHandleHalo = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0xCF8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0xD00; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0xD08; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0xD0C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0xD10; // CHandle<C_BaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0xD38; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0xD44; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0xD48; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0xD4C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0xD50; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0xD54; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0xD58; // float
    constexpr std::ptrdiff_t m_fSpeed = 0xD5C; // float
    constexpr std::ptrdiff_t m_flFrame = 0xD60; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0xD64; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0xD68; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0xD78; // CHandle<C_BaseEntity>
}

namespace C_Breakable { // C_BaseModelEntity
}

namespace C_BreakableProp { // CBaseProp
    constexpr std::ptrdiff_t m_OnBreak = 0xEC8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0xEF0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0xF18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xF40; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0xF44; // int32_t
    constexpr std::ptrdiff_t m_flPressureDelay = 0xF48; // float
    constexpr std::ptrdiff_t m_hBreaker = 0xF4C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0xF50; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xF54; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xF58; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xF5C; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xF60; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xF68; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xF70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0xF78; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0xF7C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0xF80; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0xF84; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0xF88; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0xF90; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0xF98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0xFA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0xFA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0xFB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0xFB8; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0xFBC; // GameTime_t
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0xFC0; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0xFC4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0xFC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_noGhostCollision = 0xFCC; // bool
}

namespace C_BulletHitModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_matLocal = 0xE80; // matrix3x4_t
    constexpr std::ptrdiff_t m_iBoneIndex = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_hPlayerParent = 0xEB4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bIsHit = 0xEB8; // bool
    constexpr std::ptrdiff_t m_flTimeCreated = 0xEBC; // float
    constexpr std::ptrdiff_t m_vecStartPos = 0xEC0; // Vector
}

namespace C_C4 { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_szScreenText = 0x1990; // char[32]
    constexpr std::ptrdiff_t m_bombdroppedlightParticleIndex = 0x19B0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_bStartedArming = 0x19B4; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0x19B8; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0x19BC; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0x19BD; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x19C0; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x19D8; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0x19DC; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0x19E3; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0x19E4; // bool
}

namespace C_CSGOViewModel { // C_PredictedViewModel
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0xF10; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0xF14; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0xF18; // uint32_t
    constexpr std::ptrdiff_t m_nLastKnownAssociatedWeaponEntIndex = 0xF1C; // CEntityIndex
    constexpr std::ptrdiff_t m_bNeedToQueueHighResComposite = 0xF20; // bool
    constexpr std::ptrdiff_t m_vLoweredWeaponOffset = 0xF64; // QAngle
}

namespace C_CSGO_CounterTerroristTeamIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_CounterTerroristWingmanIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_EndOfMatchCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_EndOfMatchCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_EndOfMatchLineupEnd { // C_CSGO_EndOfMatchLineupEndpoint
}

namespace C_CSGO_EndOfMatchLineupEndpoint { // C_BaseEntity
}

namespace C_CSGO_EndOfMatchLineupStart { // C_CSGO_EndOfMatchLineupEndpoint
}

namespace C_CSGO_MapPreviewCameraPath { // C_BaseEntity
    constexpr std::ptrdiff_t m_flZFar = 0x540; // float
    constexpr std::ptrdiff_t m_flZNear = 0x544; // float
    constexpr std::ptrdiff_t m_bLoop = 0x548; // bool
    constexpr std::ptrdiff_t m_bVerticalFOV = 0x549; // bool
    constexpr std::ptrdiff_t m_bConstantSpeed = 0x54A; // bool
    constexpr std::ptrdiff_t m_flDuration = 0x54C; // float
    constexpr std::ptrdiff_t m_flPathLength = 0x590; // float
    constexpr std::ptrdiff_t m_flPathDuration = 0x594; // float
}

namespace C_CSGO_MapPreviewCameraPathNode { // C_BaseEntity
    constexpr std::ptrdiff_t m_szParentPathUniqueID = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nPathIndex = 0x548; // int32_t
    constexpr std::ptrdiff_t m_vInTangentLocal = 0x54C; // Vector
    constexpr std::ptrdiff_t m_vOutTangentLocal = 0x558; // Vector
    constexpr std::ptrdiff_t m_flFOV = 0x564; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x568; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x56C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x570; // float
    constexpr std::ptrdiff_t m_vInTangentWorld = 0x574; // Vector
    constexpr std::ptrdiff_t m_vOutTangentWorld = 0x580; // Vector
}

namespace C_CSGO_PreviewModel { // C_BaseFlex
    constexpr std::ptrdiff_t m_animgraph = 0x1018; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x1020; // CUtlString
    constexpr std::ptrdiff_t m_defaultAnim = 0x1028; // CUtlString
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x1030; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x1034; // float
}

namespace C_CSGO_PreviewModelAlias_csgo_item_previewmodel { // C_CSGO_PreviewModel
}

namespace C_CSGO_PreviewPlayer { // C_CSPlayerPawn
    constexpr std::ptrdiff_t m_animgraph = 0x22E0; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x22E8; // CUtlString
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x22F0; // float
}

namespace C_CSGO_PreviewPlayerAlias_csgo_player_previewmodel { // C_CSGO_PreviewPlayer
}

namespace C_CSGO_TeamIntroCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_TeamIntroCounterTerroristPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace C_CSGO_TeamIntroTerroristPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace C_CSGO_TeamPreviewCamera { // C_CSGO_MapPreviewCameraPath
    constexpr std::ptrdiff_t m_nVariant = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_bDofEnabled = 0x5A4; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x5AC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x5B0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x5B8; // float
}

namespace C_CSGO_TeamPreviewCharacterPosition { // C_BaseEntity
    constexpr std::ptrdiff_t m_nVariant = 0x540; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x548; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x550; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x558; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x560; // C_EconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x9A8; // C_EconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0xDF0; // C_EconItemView
}

namespace C_CSGO_TeamPreviewModel { // C_CSGO_PreviewPlayer
}

namespace C_CSGO_TeamSelectCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_TeamSelectCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_TeamSelectCounterTerroristPosition { // C_CSGO_TeamSelectCharacterPosition
}

namespace C_CSGO_TeamSelectTerroristPosition { // C_CSGO_TeamSelectCharacterPosition
}

namespace C_CSGO_TerroristTeamIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_TerroristWingmanIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGameRules { // C_TeamplayRules
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bFreezePeriod = 0x30; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0x31; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0x40; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0x44; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x45; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0x46; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0x47; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0x48; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0x4C; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0x54; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0x58; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0x59; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0x60; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0x64; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0x68; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x6C; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x70; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x74; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x78; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x88; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x8C; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x8D; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x8E; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x8F; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x90; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x94; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x98; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x99; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x9A; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0xA4; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0xAC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x2AC; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x4AC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x6AC; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x8AC; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x8B0; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x8B8; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x8B9; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x8BA; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x8C8; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x8D8; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x8DC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x8EC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x8FC; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0x9C4; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0x9D4; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0x9D8; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0x9DC; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0x9DD; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0x9E4; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0x9E8; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0x9E9; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0x9EC; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0x9F0; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xA68; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xAE0; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xB58; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xBD8; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xC58; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xC5C; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xC68; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xC74; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xC94; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xC95; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xC98; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xCC0; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xCE8; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_bMarkClientStopRecordAtRoundEnd = 0xD10; // bool
    constexpr std::ptrdiff_t m_bMatchAbortedDueToPlayerBan = 0xD68; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0xD69; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0xD6A; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0xD6B; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0xD88; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_RetakeRules = 0xD90; // C_RetakeGameRules
    constexpr std::ptrdiff_t m_nMatchEndCount = 0xEA8; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0xEAC; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0xEB4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x4EC0; // double
}

namespace C_CSGameRulesProxy { // C_GameRulesProxy
    constexpr std::ptrdiff_t m_pGameRules = 0x540; // C_CSGameRules*
}

namespace C_CSMinimapBoundary { // C_BaseEntity
}

namespace C_CSObserverPawn { // C_CSPlayerPawnBase
    constexpr std::ptrdiff_t m_hDetectParentChange = 0x16B0; // CEntityHandle
}

namespace C_CSPlayerPawn { // C_CSPlayerPawnBase
    constexpr std::ptrdiff_t m_pBulletServices = 0x16B0; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x16B8; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x16C0; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pGlowServices = 0x16C8; // CCSPlayer_GlowServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x16D0; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x16D8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFiredWeaponTime = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x16E0; // bool
    constexpr std::ptrdiff_t m_flLandseconds = 0x16E4; // float
    constexpr std::ptrdiff_t m_flOldFallVelocity = 0x16E8; // float
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x16EC; // char[18]
    constexpr std::ptrdiff_t m_bPrevDefuser = 0x16FE; // bool
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x16FF; // bool
    constexpr std::ptrdiff_t m_nPrevArmorVal = 0x1700; // int32_t
    constexpr std::ptrdiff_t m_nPrevGrenadeAmmoCount = 0x1704; // int32_t
    constexpr std::ptrdiff_t m_unPreviousWeaponHash = 0x1708; // uint32_t
    constexpr std::ptrdiff_t m_unWeaponHash = 0x170C; // uint32_t
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1710; // bool
    constexpr std::ptrdiff_t m_bPreviouslyInBuyZone = 0x1711; // bool
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1714; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1720; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x172C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x1730; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x1738; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bInLanding = 0x1758; // bool
    constexpr std::ptrdiff_t m_flLandingTime = 0x175C; // float
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1760; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1761; // bool
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x1762; // bool
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1764; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1768; // GameTime_t
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1880; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x1884; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1888; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1889; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x188C; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1890; // loadout_slot_t
    constexpr std::ptrdiff_t m_bNeedToReApplyGloves = 0x18B0; // bool
    constexpr std::ptrdiff_t m_EconGloves = 0x18B8; // C_EconItemView
    constexpr std::ptrdiff_t m_bMustSyncRagdollState = 0x1D00; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1D04; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1D08; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1D14; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1D20; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1D60; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1D64; // Vector
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x22A8; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x22AC; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x22B0; // bool
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x22CC; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x22D8; // bool
}

namespace C_CSPlayerPawnBase { // C_BasePlayerPawn
    constexpr std::ptrdiff_t m_pPingServices = 0x1268; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0x1270; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_fRenderingClipPlane = 0x1278; // float[4]
    constexpr std::ptrdiff_t m_nLastClipPlaneSetupFrame = 0x1288; // int32_t
    constexpr std::ptrdiff_t m_vecLastClipCameraPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_vecLastClipCameraForward = 0x1298; // Vector
    constexpr std::ptrdiff_t m_bClipHitStaticWorld = 0x12A4; // bool
    constexpr std::ptrdiff_t m_bCachedPlaneIsValid = 0x12A5; // bool
    constexpr std::ptrdiff_t m_pClippingWeapon = 0x12A8; // C_CSWeaponBase*
    constexpr std::ptrdiff_t m_previousPlayerState = 0x12B0; // CSPlayerState
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x12B4; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x12B8; // float
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x12D8; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x12DC; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x12EC; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x12F8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x1304; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x131C; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x1334; // Vector[2]
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1350; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x1368; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x1378; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x1388; // Vector
    constexpr std::ptrdiff_t m_bIsScoped = 0x13A0; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0x13A1; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0x13A2; // bool
    constexpr std::ptrdiff_t m_iPlayerState = 0x13A4; // CSPlayerState
    constexpr std::ptrdiff_t m_bIsDefusing = 0x13A8; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0x13A9; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0x13AC; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_bIsRescuing = 0x13B0; // bool
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0x13B4; // GameTime_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTimeLast = 0x13B8; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0x13BC; // bool
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0x13BD; // bool
    constexpr std::ptrdiff_t m_fMolotovUseTime = 0x13C0; // float
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0x13C4; // float
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x13C8; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x13CC; // bool
    constexpr std::ptrdiff_t m_iThrowGrenadeCounter = 0x13D0; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x13D4; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0x13D8; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0x13DC; // GameTime_t
    constexpr std::ptrdiff_t m_flNextGuardianTooFarWarning = 0x13E0; // float
    constexpr std::ptrdiff_t m_bSuppressGuardianTooFarWarningAudio = 0x13E4; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x13E5; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x13E8; // int32_t
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0x13EC; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x13F0; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x13F4; // bool
    constexpr std::ptrdiff_t m_flLastSpawnTimeIndex = 0x13F8; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0x13FC; // GameTime_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1400; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1404; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x1408; // int32_t
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x140C; // int32_t
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1410; // float
    constexpr std::ptrdiff_t m_iDirection = 0x1414; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1418; // int32_t
    constexpr std::ptrdiff_t m_bNightVisionOn = 0x141C; // bool
    constexpr std::ptrdiff_t m_bHasNightVision = 0x141D; // bool
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x1420; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1424; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1428; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x142C; // int32_t
    constexpr std::ptrdiff_t m_vecIntroStartEyePosition = 0x1430; // Vector
    constexpr std::ptrdiff_t m_vecIntroStartPlayerForward = 0x143C; // Vector
    constexpr std::ptrdiff_t m_flClientDeathTime = 0x1448; // GameTime_t
    constexpr std::ptrdiff_t m_flNightVisionAlpha = 0x144C; // float
    constexpr std::ptrdiff_t m_bScreenTearFrameCaptured = 0x1450; // bool
    constexpr std::ptrdiff_t m_flFlashBangTime = 0x1454; // float
    constexpr std::ptrdiff_t m_flFlashScreenshotAlpha = 0x1458; // float
    constexpr std::ptrdiff_t m_flFlashOverlayAlpha = 0x145C; // float
    constexpr std::ptrdiff_t m_bFlashBuildUp = 0x1460; // bool
    constexpr std::ptrdiff_t m_bFlashDspHasBeenCleared = 0x1461; // bool
    constexpr std::ptrdiff_t m_bFlashScreenshotHasBeenGrabbed = 0x1462; // bool
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x1464; // float
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1468; // float
    constexpr std::ptrdiff_t m_lastStandingPos = 0x146C; // Vector
    constexpr std::ptrdiff_t m_vecLastMuzzleFlashPos = 0x1478; // Vector
    constexpr std::ptrdiff_t m_angLastMuzzleFlashAngle = 0x1484; // QAngle
    constexpr std::ptrdiff_t m_hMuzzleFlashShape = 0x1490; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iHealthBarRenderMaskIndex = 0x1494; // int32_t
    constexpr std::ptrdiff_t m_flHealthFadeValue = 0x1498; // float
    constexpr std::ptrdiff_t m_flHealthFadeAlpha = 0x149C; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x14A0; // int32_t
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x14A4; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x14A8; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x14C0; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x14CC; // Vector
    constexpr std::ptrdiff_t m_flDeathCCWeight = 0x14E0; // float
    constexpr std::ptrdiff_t m_bOldIsScoped = 0x14E4; // bool
    constexpr std::ptrdiff_t m_flPrevRoundEndTime = 0x14E8; // float
    constexpr std::ptrdiff_t m_flPrevMatchEndTime = 0x14EC; // float
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x14F0; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x14F2; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x14F4; // uint16_t
    constexpr std::ptrdiff_t m_vecThirdPersonViewPositionOverride = 0x14F8; // Vector
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0x1504; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1508; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x1510; // QAngle
    constexpr std::ptrdiff_t m_fNextThinkPushAway = 0x1528; // float
    constexpr std::ptrdiff_t m_bShouldAutobuyDMWeapons = 0x152C; // bool
    constexpr std::ptrdiff_t m_bShouldAutobuyNow = 0x152D; // bool
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x152E; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x152F; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x1530; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x1534; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1538; // int32_t
    constexpr std::ptrdiff_t m_iIDEntIndex = 0x153C; // CEntityIndex
    constexpr std::ptrdiff_t m_delayTargetIDTimer = 0x1540; // CountdownTimer
    constexpr std::ptrdiff_t m_iTargetedWeaponEntIndex = 0x1558; // CEntityIndex
    constexpr std::ptrdiff_t m_iOldIDEntIndex = 0x155C; // CEntityIndex
    constexpr std::ptrdiff_t m_holdTargetIDTimer = 0x1560; // CountdownTimer
    constexpr std::ptrdiff_t m_flCurrentMusicStartTime = 0x157C; // float
    constexpr std::ptrdiff_t m_flMusicRoundStartTime = 0x1580; // float
    constexpr std::ptrdiff_t m_bDeferStartMusicOnWarmup = 0x1584; // bool
    constexpr std::ptrdiff_t m_cycleLatch = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_serverIntendedCycle = 0x158C; // float
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1590; // uint32_t[5]
    constexpr std::ptrdiff_t m_bHideTargetID = 0x15AC; // bool
    constexpr std::ptrdiff_t m_nextTaserShakeTime = 0x15B0; // float
    constexpr std::ptrdiff_t m_firstTaserShakeTime = 0x15B4; // float
    constexpr std::ptrdiff_t m_flLastSmokeOverlayAlpha = 0x15B8; // float
    constexpr std::ptrdiff_t m_vLastSmokeOverlayColor = 0x15BC; // Vector
    constexpr std::ptrdiff_t m_nPlayerSmokedFx = 0x15C8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_flNextMagDropTime = 0x15CC; // float
    constexpr std::ptrdiff_t m_nLastMagDropAttachmentIndex = 0x15D0; // int32_t
    constexpr std::ptrdiff_t m_vecBulletHitModels = 0x15D8; // CUtlVector<C_BulletHitModel*>
    constexpr std::ptrdiff_t m_vecPickupModelSlerpers = 0x15F0; // CUtlVector<C_PickUpModelSlerper*>
    constexpr std::ptrdiff_t m_vecLastAliveLocalVelocity = 0x1608; // Vector
    constexpr std::ptrdiff_t m_entitySpottedState = 0x1630; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_bGuardianShouldSprayCustomXMark = 0x164C; // bool
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x164D; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1650; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x1654; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1660; // bool
    constexpr std::ptrdiff_t m_hOriginalController = 0x1664; // CHandle<CCSPlayerController>
}

namespace C_CSPlayerResource { // C_BaseEntity
    constexpr std::ptrdiff_t m_bHostageAlive = 0x540; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x54C; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x558; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x588; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x594; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x5A0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x5B0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x5C0; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x5D0; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x5D1; // bool
}

namespace C_CSTeam { // C_Team
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x5F8; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x7F8; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x7FC; // bool
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x800; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x804; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x808; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x80C; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x890; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x894; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x89C; // char[8]
}

namespace C_CSWeaponBase { // C_BasePlayerWeapon
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0x15D0; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0x15D4; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0x15D8; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0x15DC; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0x15E0; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0x15E4; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0x15E8; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0x15F0; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0x1608; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0x1610; // HSequence[6]
    constexpr std::ptrdiff_t m_ClientPreviousWeaponState = 0x1640; // CSWeaponState_t
    constexpr std::ptrdiff_t m_iState = 0x1644; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flCrosshairDistance = 0x1648; // float
    constexpr std::ptrdiff_t m_iAmmoLastCheck = 0x164C; // int32_t
    constexpr std::ptrdiff_t m_iAlpha = 0x1650; // int32_t
    constexpr std::ptrdiff_t m_iScopeTextureID = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_iCrosshairTextureID = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_flGunAccuracyPosition = 0x165C; // float
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x1660; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0x1664; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0x1668; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0x166C; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x1670; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0x1698; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0x169C; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0x16A0; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0x16AC; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0x16B0; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0x16B4; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0x16B8; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0x16BC; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0x16C0; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0x16C4; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0x16C8; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0x16CC; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0x16D0; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0x16D1; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0x16D4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0x16D8; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0x16D9; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0x16E0; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0x16E4; // float
    constexpr std::ptrdiff_t m_bVisualsDataSet = 0x1768; // bool
    constexpr std::ptrdiff_t m_bOldFirstPersonSpectatedState = 0x1769; // bool
    constexpr std::ptrdiff_t m_hOurPing = 0x176C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nOurPingIndex = 0x1770; // CEntityIndex
    constexpr std::ptrdiff_t m_vecOurPingPos = 0x1774; // Vector
    constexpr std::ptrdiff_t m_bGlowForPing = 0x1780; // bool
    constexpr std::ptrdiff_t m_bUIWeapon = 0x1781; // bool
    constexpr std::ptrdiff_t m_hPrevOwner = 0x1790; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0x1794; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0x17B4; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0x17B8; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0x17BC; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0x17BD; // bool
    constexpr std::ptrdiff_t m_gunHeat = 0x17C0; // float
    constexpr std::ptrdiff_t m_smokeAttachments = 0x17C4; // uint32_t
    constexpr std::ptrdiff_t m_lastSmokeTime = 0x17C8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime = 0x17CC; // float
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime_Repredict = 0x17D0; // float
    constexpr std::ptrdiff_t m_IronSightController = 0x1890; // C_IronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0x1940; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0x1950; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0x1954; // int32_t
}

namespace C_CSWeaponBaseGun { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_zoomLevel = 0x1990; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0x1994; // int32_t
    constexpr std::ptrdiff_t m_iSilencerBodygroup = 0x1998; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0x19A8; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0x19AC; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0x19AD; // bool
}

namespace C_Chicken { // C_DynamicProp
    constexpr std::ptrdiff_t m_hHolidayHatAddon = 0x10F0; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10F4; // bool
    constexpr std::ptrdiff_t m_leader = 0x10F8; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_AttributeManager = 0x1100; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x15A8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x15AC; // uint32_t
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x15B0; // bool
    constexpr std::ptrdiff_t m_hWaterWakeParticles = 0x15B4; // ParticleIndex_t
}

namespace C_ClientRagdoll { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bFadeOut = 0xE80; // bool
    constexpr std::ptrdiff_t m_bImportant = 0xE81; // bool
    constexpr std::ptrdiff_t m_flEffectTime = 0xE84; // GameTime_t
    constexpr std::ptrdiff_t m_gibDespawnTime = 0xE88; // GameTime_t
    constexpr std::ptrdiff_t m_iCurrentFriction = 0xE8C; // int32_t
    constexpr std::ptrdiff_t m_iMinFriction = 0xE90; // int32_t
    constexpr std::ptrdiff_t m_iMaxFriction = 0xE94; // int32_t
    constexpr std::ptrdiff_t m_iFrictionAnimState = 0xE98; // int32_t
    constexpr std::ptrdiff_t m_bReleaseRagdoll = 0xE9C; // bool
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xE9D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bFadingOut = 0xE9E; // bool
    constexpr std::ptrdiff_t m_flScaleEnd = 0xEA0; // float[10]
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xEC8; // GameTime_t[10]
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0xEF0; // GameTime_t[10]
}

namespace C_ColorCorrection { // C_BaseEntity
    constexpr std::ptrdiff_t m_vecOrigin = 0x540; // Vector
    constexpr std::ptrdiff_t m_MinFalloff = 0x54C; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x554; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x558; // float
    constexpr std::ptrdiff_t m_flMaxWeight = 0x55C; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x560; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x564; // char[512]
    constexpr std::ptrdiff_t m_bEnabled = 0x764; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x765; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x766; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x767; // bool
    constexpr std::ptrdiff_t m_bEnabledOnClient = 0x768; // bool[1]
    constexpr std::ptrdiff_t m_flCurWeightOnClient = 0x76C; // float[1]
    constexpr std::ptrdiff_t m_bFadingIn = 0x770; // bool[1]
    constexpr std::ptrdiff_t m_flFadeStartWeight = 0x774; // float[1]
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x778; // float[1]
    constexpr std::ptrdiff_t m_flFadeDuration = 0x77C; // float[1]
}

namespace C_ColorCorrectionVolume { // C_BaseTrigger
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xCC8; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xCCC; // float
    constexpr std::ptrdiff_t m_LastExitWeight = 0xCD0; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xCD4; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCD8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0xCDC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_Weight = 0xCE4; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0xCE8; // char[512]
}

namespace C_CommandContext {
    constexpr std::ptrdiff_t needsprocessing = 0x0; // bool
    constexpr std::ptrdiff_t command_number = 0x78; // int32_t
}

namespace C_CsmFovOverride { // C_BaseEntity
    constexpr std::ptrdiff_t m_cameraName = 0x540; // CUtlString
    constexpr std::ptrdiff_t m_flCsmFovOverrideValue = 0x548; // float
}

namespace C_DEagle { // C_CSWeaponBaseGun
}

namespace C_DecoyGrenade { // C_BaseCSGrenade
}

namespace C_DecoyProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0x10F0; // int32_t
    constexpr std::ptrdiff_t m_nClientLastKnownDecoyShotTick = 0x10F4; // int32_t
    constexpr std::ptrdiff_t m_flTimeParticleEffectSpawn = 0x1118; // GameTime_t
}

namespace C_DynamicLight { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_Flags = 0xCC0; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0xCC1; // uint8_t
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
    constexpr std::ptrdiff_t m_Exponent = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0xCCC; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0xCD0; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0xCD4; // float
}

namespace C_DynamicProp { // C_BreakableProp
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xFD1; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xFD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0x1000; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0x1028; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0x1050; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0x1078; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0x10A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x10A8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0x10AC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0x10AD; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x10AE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x10AF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0x10B0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x10B1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0x10B2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0x10B3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0x10B4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x10B8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x10BC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0x10C0; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0x10C4; // int32_t
    constexpr std::ptrdiff_t m_iCachedFrameCount = 0x10C8; // int32_t
    constexpr std::ptrdiff_t m_vecCachedRenderMins = 0x10CC; // Vector
    constexpr std::ptrdiff_t m_vecCachedRenderMaxs = 0x10D8; // Vector
}

namespace C_DynamicPropAlias_cable_dynamic { // C_DynamicProp
}

namespace C_DynamicPropAlias_dynamic_prop { // C_DynamicProp
}

namespace C_DynamicPropAlias_prop_dynamic_override { // C_DynamicProp
}

namespace C_EconEntity { // C_BaseFlex
    constexpr std::ptrdiff_t m_flFlexDelayTime = 0x1028; // float
    constexpr std::ptrdiff_t m_flFlexDelayedWeight = 0x1030; // float*
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x1038; // bool
    constexpr std::ptrdiff_t m_AttributeManager = 0x1040; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x14E8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x14EC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0x14F0; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0x14F4; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0x14F8; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0x14FC; // int32_t
    constexpr std::ptrdiff_t m_bClientside = 0x1500; // bool
    constexpr std::ptrdiff_t m_bParticleSystemsCreated = 0x1501; // bool
    constexpr std::ptrdiff_t m_vecAttachedParticles = 0x1508; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hViewmodelAttachment = 0x1520; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_iOldTeam = 0x1524; // int32_t
    constexpr std::ptrdiff_t m_bAttachmentDirty = 0x1528; // bool
    constexpr std::ptrdiff_t m_nUnloadedModelIndex = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_iNumOwnerValidationRetries = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0x1540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_vecAttachedModels = 0x1548; // CUtlVector<C_EconEntity::AttachedModelData_t>
}

namespace C_EconEntity_AttachedModelData_t {
    constexpr std::ptrdiff_t m_iModelDisplayFlags = 0x0; // int32_t
}

namespace C_EconItemView { // IEconItemInterface
    constexpr std::ptrdiff_t m_bInventoryImageRgbaRequested = 0x60; // bool
    constexpr std::ptrdiff_t m_bInventoryImageTriedCache = 0x61; // bool
    constexpr std::ptrdiff_t m_nInventoryImageRgbaWidth = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nInventoryImageRgbaHeight = 0x84; // int32_t
    constexpr std::ptrdiff_t m_szCurrentLoadCachedFileName = 0x88; // char[260]
    constexpr std::ptrdiff_t m_bRestoreCustomMaterialAfterPrecache = 0x1B8; // bool
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x1BA; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x1C0; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x1C8; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x1D0; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x1D4; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x1D8; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x1E8; // bool
    constexpr std::ptrdiff_t m_bIsStoreItem = 0x1E9; // bool
    constexpr std::ptrdiff_t m_bIsTradeItem = 0x1EA; // bool
    constexpr std::ptrdiff_t m_iEntityQuantity = 0x1EC; // int32_t
    constexpr std::ptrdiff_t m_iRarityOverride = 0x1F0; // int32_t
    constexpr std::ptrdiff_t m_iQualityOverride = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_unClientFlags = 0x1F8; // uint8_t
    constexpr std::ptrdiff_t m_unOverrideStyle = 0x1F9; // uint8_t
    constexpr std::ptrdiff_t m_AttributeList = 0x210; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0x270; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x2D0; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x371; // char[161]
    constexpr std::ptrdiff_t m_bInitializedTags = 0x440; // bool
}

namespace C_EconWearable { // C_EconEntity
    constexpr std::ptrdiff_t m_nForceSkin = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0x1564; // bool
}

namespace C_EntityDissolve { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flStartTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeInStart = 0xCCC; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0xCD0; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0xCD4; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0xCD8; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0xCDC; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0xCE0; // float
    constexpr std::ptrdiff_t m_flNextSparkTime = 0xCE4; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0xCE8; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0xCEC; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0xCF8; // uint32_t
    constexpr std::ptrdiff_t m_bCoreExplode = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bLinkedToServerEnt = 0xCFD; // bool
}

namespace C_EntityFlame { // C_BaseEntity
    constexpr std::ptrdiff_t m_hEntAttached = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOldAttached = 0x568; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x56C; // bool
}

namespace C_EnvCombinedLightProbeVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_Color = 0x1598; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x159C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x15A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x15A8; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x15B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x15B8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x15C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x15C8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x15D0; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x15DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x15E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x15EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x15F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x15F4; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x15F8; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x15FC; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1600; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1610; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1614; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1618; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x161C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1639; // bool
}

namespace C_EnvCubemap { // C_BaseEntity
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x5C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x5C8; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x5CC; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x5D0; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x5DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x5E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x5EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x5F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x5F4; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x5F8; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x5FC; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x608; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x60C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x60D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x60E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x60F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x610; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x620; // bool
}

namespace C_EnvCubemapBox { // C_EnvCubemap
}

namespace C_EnvCubemapFog { // C_BaseEntity
    constexpr std::ptrdiff_t m_flEndDistance = 0x540; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x544; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x548; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x550; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x558; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x55C; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x560; // float
    constexpr std::ptrdiff_t m_bActive = 0x564; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x565; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x568; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x570; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x580; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x588; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x589; // bool
}

namespace C_EnvDecal { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hDecalMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeight = 0xCCC; // float
    constexpr std::ptrdiff_t m_flDepth = 0xCD0; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0xCD4; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0xCD8; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0xCD9; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0xCDA; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0xCDC; // float
}

namespace C_EnvDetailController { // C_BaseEntity
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x540; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x544; // float
}

namespace C_EnvLightProbeVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1518; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1538; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x1544; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1550; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x1554; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1558; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x155C; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1568; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x156C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1581; // bool
}

namespace C_EnvParticleGlow { // C_ParticleSystem
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1270; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1274; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0x1278; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x127C; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0x1280; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_EnvProjectedTexture { // C_ModelPointEntity
}

namespace C_EnvScreenOverlay { // C_PointEntity
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x540; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x590; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x5B8; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x5BC; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x5C0; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0x5C1; // bool
    constexpr std::ptrdiff_t m_iCachedDesiredOverlay = 0x5C4; // int32_t
    constexpr std::ptrdiff_t m_iCurrentOverlay = 0x5C8; // int32_t
    constexpr std::ptrdiff_t m_flCurrentOverlayTime = 0x5CC; // GameTime_t
}

namespace C_EnvSky { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hSkyMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0xCC8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0xCD1; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0xCD5; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCDC; // float
    constexpr std::ptrdiff_t m_nFogType = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0xCE4; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0xCEC; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0xCF0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCF4; // bool
}

namespace C_EnvVolumetricFogController { // C_BaseEntity
    constexpr std::ptrdiff_t m_flScattering = 0x540; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x544; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x548; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x558; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x564; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x568; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x574; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x580; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x588; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x58C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x590; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x594; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x598; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x59C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x5A0; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x5A4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x5A8; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x5A9; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x5AA; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x5B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x5B8; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x5BC; // bool
}

namespace C_EnvVolumetricFogVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_bActive = 0x540; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x544; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x550; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x55C; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x560; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x568; // float
}

namespace C_EnvWind { // C_BaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindClientside { // C_BaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_flVariationTime = 0x70; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0x74; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0x78; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0x7C; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x80; // float
    constexpr std::ptrdiff_t m_bGusting = 0x84; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x88; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x8C; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0x90; // CEntityIndex
}

namespace C_EnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace C_EnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace C_FireCrackerBlast { // C_Inferno
}

namespace C_FireFromAboveSprite { // C_Sprite
}

namespace C_FireSmoke { // C_BaseFire
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x554; // int32_t
    constexpr std::ptrdiff_t m_flScaleRegister = 0x558; // float
    constexpr std::ptrdiff_t m_flScaleStart = 0x55C; // float
    constexpr std::ptrdiff_t m_flScaleEnd = 0x560; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x564; // GameTime_t
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0x568; // GameTime_t
    constexpr std::ptrdiff_t m_flChildFlameSpread = 0x56C; // float
    constexpr std::ptrdiff_t m_flClipPerc = 0x580; // float
    constexpr std::ptrdiff_t m_bClipTested = 0x584; // bool
    constexpr std::ptrdiff_t m_bFadingOut = 0x585; // bool
    constexpr std::ptrdiff_t m_tParticleSpawn = 0x588; // TimedEvent
    constexpr std::ptrdiff_t m_pFireOverlay = 0x590; // CFireOverlay*
}

namespace C_FireSprite { // C_Sprite
    constexpr std::ptrdiff_t m_vecMoveDir = 0xDF0; // Vector
    constexpr std::ptrdiff_t m_bFadeFromAbove = 0xDFC; // bool
}

namespace C_Fish { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_pos = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vel = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_angles = 0xE98; // QAngle
    constexpr std::ptrdiff_t m_localLifeState = 0xEA4; // int32_t
    constexpr std::ptrdiff_t m_deathDepth = 0xEA8; // float
    constexpr std::ptrdiff_t m_deathAngle = 0xEAC; // float
    constexpr std::ptrdiff_t m_buoyancy = 0xEB0; // float
    constexpr std::ptrdiff_t m_wiggleTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_wigglePhase = 0xED0; // float
    constexpr std::ptrdiff_t m_wiggleRate = 0xED4; // float
    constexpr std::ptrdiff_t m_actualPos = 0xED8; // Vector
    constexpr std::ptrdiff_t m_actualAngles = 0xEE4; // QAngle
    constexpr std::ptrdiff_t m_poolOrigin = 0xEF0; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0xEFC; // float
    constexpr std::ptrdiff_t m_gotUpdate = 0xF00; // bool
    constexpr std::ptrdiff_t m_x = 0xF04; // float
    constexpr std::ptrdiff_t m_y = 0xF08; // float
    constexpr std::ptrdiff_t m_z = 0xF0C; // float
    constexpr std::ptrdiff_t m_angle = 0xF10; // float
    constexpr std::ptrdiff_t m_errorHistory = 0xF14; // float[20]
    constexpr std::ptrdiff_t m_errorHistoryIndex = 0xF64; // int32_t
    constexpr std::ptrdiff_t m_errorHistoryCount = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_averageError = 0xF6C; // float
}

namespace C_Fists { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0x1990; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0x1994; // PlayerAnimEvent_t
}

namespace C_Flashbang { // C_BaseCSGrenade
}

namespace C_FlashbangProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_FogController { // C_BaseEntity
    constexpr std::ptrdiff_t m_fog = 0x540; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x5A8; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x5AC; // int32_t
}

namespace C_FootstepControl { // C_BaseTrigger
    constexpr std::ptrdiff_t m_source = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0xCD0; // CUtlSymbolLarge
}

namespace C_FuncBrush { // C_BaseModelEntity
}

namespace C_FuncConveyor { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0xCC8; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0xCD4; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0xCD8; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0xCE0; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0xCE8; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_flCurrentConveyorOffset = 0xD00; // float
    constexpr std::ptrdiff_t m_flCurrentConveyorSpeed = 0xD04; // float
}

namespace C_FuncElectrifiedVolume { // C_FuncBrush
    constexpr std::ptrdiff_t m_nAmbientEffect = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_EffectName = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bState = 0xCD0; // bool
}

namespace C_FuncLadder { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_vecLadderDir = 0xCC0; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0xCD0; // CUtlVector<CHandle<C_InfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0xD00; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0xD0C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0xD10; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0xD12; // bool
}

namespace C_FuncMonitor { // C_FuncBrush
    constexpr std::ptrdiff_t m_targetCamera = 0xCC0; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0xCCC; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0xCCD; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0xCD0; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0xCD8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0xCDC; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0xCDD; // bool
}

namespace C_FuncMoveLinear { // C_BaseToggle
}

namespace C_FuncRotating { // C_BaseModelEntity
}

namespace C_FuncTrackTrain { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nLongAxis = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0xCC4; // float
    constexpr std::ptrdiff_t m_flLineLength = 0xCC8; // float
}

namespace C_GameRules {
}

namespace C_GameRulesProxy { // C_BaseEntity
}

namespace C_GlobalLight { // C_BaseEntity
    constexpr std::ptrdiff_t m_WindClothForceHandle = 0xA00; // uint16_t
}

namespace C_GradientFog { // C_BaseEntity
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x540; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x548; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x550; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x554; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x558; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x55C; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x560; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x564; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x568; // float
    constexpr std::ptrdiff_t m_fogColor = 0x56C; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x570; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x574; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x578; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x579; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x57A; // bool
}

namespace C_HEGrenade { // C_BaseCSGrenade
}

namespace C_HEGrenadeProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_HandleTest { // C_BaseEntity
    constexpr std::ptrdiff_t m_Handle = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x544; // bool
}

namespace C_Hostage { // C_BaseCombatCharacter
    constexpr std::ptrdiff_t m_entitySpottedState = 0x10A8; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_leader = 0x10C0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_reuseTimer = 0x10C8; // CountdownTimer
    constexpr std::ptrdiff_t m_vel = 0x10E0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0x10EC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10ED; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0x10F0; // int32_t
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x10F4; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x10F8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x10FC; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x1100; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x110C; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x1110; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x1114; // GameTime_t
    constexpr std::ptrdiff_t m_flDeadOrRescuedTime = 0x1118; // GameTime_t
    constexpr std::ptrdiff_t m_blinkTimer = 0x1120; // CountdownTimer
    constexpr std::ptrdiff_t m_lookAt = 0x1138; // Vector
    constexpr std::ptrdiff_t m_lookAroundTimer = 0x1148; // CountdownTimer
    constexpr std::ptrdiff_t m_isInit = 0x1160; // bool
    constexpr std::ptrdiff_t m_eyeAttachment = 0x1161; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_chestAttachment = 0x1162; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0x1168; // CBasePlayerController*
    constexpr std::ptrdiff_t m_fNewestAlphaThinkTime = 0x1170; // GameTime_t
}

namespace C_HostageCarriableProp { // CBaseAnimGraph
}

namespace C_IncendiaryGrenade { // C_MolotovGrenade
}

namespace C_Inferno { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nfxFireDamageEffect = 0xD00; // ParticleIndex_t
    constexpr std::ptrdiff_t m_firePositions = 0xD04; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0x1004; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0x1304; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0x1344; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1644; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x164C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1650; // bool
    constexpr std::ptrdiff_t m_lastFireCount = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_drawableCount = 0x8260; // int32_t
    constexpr std::ptrdiff_t m_blosCheck = 0x8264; // bool
    constexpr std::ptrdiff_t m_nlosperiod = 0x8268; // int32_t
    constexpr std::ptrdiff_t m_maxFireHalfWidth = 0x826C; // float
    constexpr std::ptrdiff_t m_maxFireHeight = 0x8270; // float
    constexpr std::ptrdiff_t m_minBounds = 0x8274; // Vector
    constexpr std::ptrdiff_t m_maxBounds = 0x8280; // Vector
    constexpr std::ptrdiff_t m_flLastGrassBurnThink = 0x828C; // float
}

namespace C_InfoInstructorHintHostageRescueZone { // C_PointEntity
}

namespace C_InfoLadderDismount { // C_BaseEntity
}

namespace C_InfoVisibilityBox { // C_BaseEntity
    constexpr std::ptrdiff_t m_nMode = 0x544; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x548; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x554; // bool
}

namespace C_IronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x10; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0x14; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x18; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x1C; // float
    constexpr std::ptrdiff_t m_flIronSightAmount_Interpolated = 0x20; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained_Interpolated = 0x24; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased_Interpolated = 0x28; // float
    constexpr std::ptrdiff_t m_flInterpolationLastUpdated = 0x2C; // float
    constexpr std::ptrdiff_t m_angDeltaAverage = 0x30; // QAngle[8]
    constexpr std::ptrdiff_t m_angViewLast = 0x90; // QAngle
    constexpr std::ptrdiff_t m_vecDotCoords = 0x9C; // Vector2D
    constexpr std::ptrdiff_t m_flDotBlur = 0xA4; // float
    constexpr std::ptrdiff_t m_flSpeedRatio = 0xA8; // float
}

namespace C_Item { // C_EconEntity
    constexpr std::ptrdiff_t m_bShouldGlow = 0x1560; // bool
    constexpr std::ptrdiff_t m_pReticleHintTextName = 0x1561; // char[256]
}

namespace C_ItemDogtags { // C_Item
    constexpr std::ptrdiff_t m_OwningPlayer = 0x1668; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x166C; // CHandle<C_CSPlayerPawn>
}

namespace C_Item_Healthshot { // C_WeaponBaseItem
}

namespace C_Knife { // C_CSWeaponBase
}

namespace C_LightDirectionalEntity { // C_LightEntity
}

namespace C_LightEntity { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_CLightComponent = 0xCC0; // CLightComponent*
}

namespace C_LightEnvironmentEntity { // C_LightDirectionalEntity
}

namespace C_LightGlow { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nHorizontalSize = 0xCC0; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xCD0; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xCD4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCD8; // float
    constexpr std::ptrdiff_t m_Glow = 0xCE0; // C_LightGlowOverlay
}

namespace C_LightGlowOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_vecOrigin = 0xD0; // Vector
    constexpr std::ptrdiff_t m_vecDirection = 0xDC; // Vector
    constexpr std::ptrdiff_t m_nMinDist = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_bOneSided = 0xF4; // bool
    constexpr std::ptrdiff_t m_bModulateByDot = 0xF5; // bool
}

namespace C_LightOrthoEntity { // C_LightEntity
}

namespace C_LightSpotEntity { // C_LightEntity
}

namespace C_LocalTempEntity { // CBaseAnimGraph
    constexpr std::ptrdiff_t flags = 0xE98; // int32_t
    constexpr std::ptrdiff_t die = 0xE9C; // GameTime_t
    constexpr std::ptrdiff_t m_flFrameMax = 0xEA0; // float
    constexpr std::ptrdiff_t x = 0xEA4; // float
    constexpr std::ptrdiff_t y = 0xEA8; // float
    constexpr std::ptrdiff_t fadeSpeed = 0xEAC; // float
    constexpr std::ptrdiff_t bounceFactor = 0xEB0; // float
    constexpr std::ptrdiff_t hitSound = 0xEB4; // int32_t
    constexpr std::ptrdiff_t priority = 0xEB8; // int32_t
    constexpr std::ptrdiff_t tentOffset = 0xEBC; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAngVelocity = 0xEC8; // QAngle
    constexpr std::ptrdiff_t tempent_renderamt = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_vecNormal = 0xED8; // Vector
    constexpr std::ptrdiff_t m_flSpriteScale = 0xEE4; // float
    constexpr std::ptrdiff_t m_nFlickerFrame = 0xEE8; // int32_t
    constexpr std::ptrdiff_t m_flFrameRate = 0xEEC; // float
    constexpr std::ptrdiff_t m_flFrame = 0xEF0; // float
    constexpr std::ptrdiff_t m_pszImpactEffect = 0xEF8; // char*
    constexpr std::ptrdiff_t m_pszParticleEffect = 0xF00; // char*
    constexpr std::ptrdiff_t m_bParticleCollision = 0xF08; // bool
    constexpr std::ptrdiff_t m_iLastCollisionFrame = 0xF0C; // int32_t
    constexpr std::ptrdiff_t m_vLastCollisionOrigin = 0xF10; // Vector
    constexpr std::ptrdiff_t m_vecTempEntVelocity = 0xF1C; // Vector
    constexpr std::ptrdiff_t m_vecPrevAbsOrigin = 0xF28; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAcceleration = 0xF34; // Vector
}

namespace C_MapPreviewParticleSystem { // C_ParticleSystem
}

namespace C_MapVetoPickController { // C_BaseEntity
    constexpr std::ptrdiff_t m_nDraftType = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x558; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x658; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x674; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x774; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x874; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x974; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC74; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD74; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE7C; // int32_t
    constexpr std::ptrdiff_t m_nPostDataUpdateTick = 0xE80; // int32_t
    constexpr std::ptrdiff_t m_bDisabledHud = 0xE84; // bool
}

namespace C_Melee { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_flThrowAt = 0x1990; // GameTime_t
}

namespace C_ModelPointEntity { // C_BaseModelEntity
}

namespace C_MolotovGrenade { // C_BaseCSGrenade
}

namespace C_MolotovProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0x10F0; // bool
}

namespace C_Multimeter { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_hTargetC4 = 0xE88; // CHandle<C_PlantedC4>
}

namespace C_MultiplayRules { // C_GameRules
}

namespace C_NetTestBaseCombatCharacter { // C_BaseCombatCharacter
}

namespace C_OmniLight { // C_BarnLight
    constexpr std::ptrdiff_t m_flInnerAngle = 0xF08; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0xF0C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0xF10; // bool
}

namespace C_ParticleSystem { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0xCC0; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0xEC0; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0xEC1; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0xEC4; // float
    constexpr std::ptrdiff_t m_nStopType = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0xECC; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0xED0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0xED8; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0xEDC; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0xEE0; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0xF10; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0xF14; // CHandle<C_BaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0x1014; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0x1015; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0x1016; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0x1017; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0x1018; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0x1020; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0x1220; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0x1224; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0x1230; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0x1234; // Color
    constexpr std::ptrdiff_t m_bOldActive = 0x1258; // bool
    constexpr std::ptrdiff_t m_bOldFrozen = 0x1259; // bool
}

namespace C_PathParticleRope { // C_BaseEntity
    constexpr std::ptrdiff_t m_bStartActive = 0x540; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x544; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x550; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x568; // float
    constexpr std::ptrdiff_t m_flSlack = 0x56C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x570; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x574; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x578; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x580; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x588; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x5A0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x5B8; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x5D0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x5E8; // C_NetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x600; // C_NetworkUtlVectorBase<float>
}

namespace C_PathParticleRopeAlias_path_particle_rope_clientside { // C_PathParticleRope
}

namespace C_PhysBox { // C_Breakable
}

namespace C_PhysMagnet { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_aAttachedObjectsFromServer = 0xE80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_aAttachedObjects = 0xE98; // CUtlVector<CHandle<C_BaseEntity>>
}

namespace C_PhysPropClientside { // C_BreakableProp
    constexpr std::ptrdiff_t m_flTouchDelta = 0xFD0; // GameTime_t
    constexpr std::ptrdiff_t m_fDeathTime = 0xFD4; // GameTime_t
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xFD8; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xFDC; // float
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xFE0; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xFE4; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xFE8; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xFEC; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xFF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xFF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x1000; // int32_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x1004; // bool
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x1008; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x1014; // Vector
    constexpr std::ptrdiff_t m_nDamageType = 0x1020; // int32_t
}

namespace C_PhysicsProp { // C_BreakableProp
    constexpr std::ptrdiff_t m_bAwake = 0xFD0; // bool
}

namespace C_PhysicsPropMultiplayer { // C_PhysicsProp
}

namespace C_PickUpModelSlerper { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_hPlayerParent = 0xE80; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hItem = 0xE84; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flTimePickedUp = 0xE88; // float
    constexpr std::ptrdiff_t m_angOriginal = 0xE8C; // QAngle
    constexpr std::ptrdiff_t m_vecPosOriginal = 0xE98; // Vector
    constexpr std::ptrdiff_t m_angRandom = 0xEA8; // QAngle
}

namespace C_PlantedC4 { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bBombTicking = 0xE80; // bool
    constexpr std::ptrdiff_t m_nBombSite = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0xE88; // int32_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE90; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_flNextGlow = 0xEA8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextBeep = 0xEAC; // GameTime_t
    constexpr std::ptrdiff_t m_flC4Blow = 0xEB0; // GameTime_t
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0xEB4; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0xEB5; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0xEB8; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0xEBC; // bool
    constexpr std::ptrdiff_t m_bTriggerWarning = 0xEC0; // float
    constexpr std::ptrdiff_t m_bExplodeWarning = 0xEC4; // float
    constexpr std::ptrdiff_t m_bC4Activated = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bTenSecWarning = 0xEC9; // bool
    constexpr std::ptrdiff_t m_flDefuseLength = 0xECC; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0xED4; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0xED8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0xEDC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hDefuserMultimeter = 0xEE0; // CHandle<C_Multimeter>
    constexpr std::ptrdiff_t m_flNextRadarFlashTime = 0xEE4; // GameTime_t
    constexpr std::ptrdiff_t m_bRadarFlash = 0xEE8; // bool
    constexpr std::ptrdiff_t m_pBombDefuser = 0xEEC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0xEF0; // GameTime_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0xEF8; // CBasePlayerController*
}

namespace C_PlayerPing { // C_BaseEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x570; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x574; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x578; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x57C; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x57D; // char[18]
}

namespace C_PlayerSprayDecal { // C_ModelPointEntity
    constexpr std::ptrdiff_t m_nUniqueID = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0xCD0; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0xCDC; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0xD00; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0xD04; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0xD08; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0xD0C; // float
    constexpr std::ptrdiff_t m_nTintID = 0xD10; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0xD14; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0xD15; // uint8_t[128]
    constexpr std::ptrdiff_t m_SprayRenderHelper = 0xDA0; // CPlayerSprayDecalRenderHelper
}

namespace C_PlayerVisibility { // C_BaseEntity
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x540; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x544; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x548; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x54C; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x550; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x551; // bool
}

namespace C_PointCamera { // C_BaseEntity
    constexpr std::ptrdiff_t m_FOV = 0x540; // float
    constexpr std::ptrdiff_t m_Resolution = 0x544; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x548; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x549; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x558; // float
    constexpr std::ptrdiff_t m_bActive = 0x55C; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x55D; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x560; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x564; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x568; // float
    constexpr std::ptrdiff_t m_flZFar = 0x56C; // float
    constexpr std::ptrdiff_t m_flZNear = 0x570; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x574; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x575; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x578; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x57C; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x580; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x584; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x588; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x58C; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x590; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x594; // bool
    constexpr std::ptrdiff_t m_pNext = 0x598; // C_PointCamera*
}

namespace C_PointCameraVFOV { // C_PointCamera
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x5A0; // float
}

namespace C_PointClientUIDialog { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_hActivator = 0xCF0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0xCF4; // bool
}

namespace C_PointClientUIHUD { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xE80; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xE84; // float
    constexpr std::ptrdiff_t m_flHeight = 0xE88; // float
    constexpr std::ptrdiff_t m_flDPI = 0xE8C; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xE90; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xE94; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xE9C; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEA0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEA4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEA8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEB0; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace C_PointClientUIWorldPanel { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bMoveViewToPlayerNextThink = 0xCF9; // bool
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCFA; // bool
    constexpr std::ptrdiff_t m_anchorDeltaTransform = 0xD00; // CTransform
    constexpr std::ptrdiff_t m_pOffScreenIndicator = 0xEA0; // CPointOffScreenIndicatorUi*
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bLit = 0xEC9; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0xECA; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xECC; // float
    constexpr std::ptrdiff_t m_flHeight = 0xED0; // float
    constexpr std::ptrdiff_t m_flDPI = 0xED4; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xED8; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xEDC; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xEE0; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xEE4; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEE8; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEEC; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEF0; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEF8; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0xF10; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0xF11; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0xF12; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0xF13; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0xF14; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0xF15; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0xF16; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0xF17; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0xF18; // int32_t
}

namespace C_PointClientUIWorldTextPanel { // C_PointClientUIWorldPanel
    constexpr std::ptrdiff_t m_messageText = 0xF20; // char[512]
}

namespace C_PointCommentaryNode { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bActive = 0xE88; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0xE89; // bool
    constexpr std::ptrdiff_t m_flEndTime = 0xE8C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTime = 0xE90; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0xE94; // float
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0xE98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTitle = 0xEA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0xEB8; // bool
    constexpr std::ptrdiff_t m_hViewPosition = 0xEC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bRestartAfterRestore = 0xECC; // bool
}

namespace C_PointEntity { // C_BaseEntity
}

namespace C_PointValueRemapper { // C_BaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bDisabledOld = 0x541; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x542; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x544; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x548; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x54C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x550; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x554; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x558; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x55C; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x560; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_hOutputEntities = 0x568; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x580; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x584; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x588; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x58C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x590; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x594; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x598; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x59C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x5A0; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x5A1; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x5A4; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x5A8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x5AC; // Vector
}

namespace C_PointWorldText { // C_ModelPointEntity
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCC8; // bool
    constexpr std::ptrdiff_t m_messageText = 0xCD8; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0xED8; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0xF18; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0xF19; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0xF1C; // float
    constexpr std::ptrdiff_t m_flFontSize = 0xF20; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xF24; // float
    constexpr std::ptrdiff_t m_Color = 0xF28; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0xF2C; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0xF30; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0xF34; // PointWorldTextReorientMode_t
}

namespace C_PostProcessingVolume { // C_BaseTrigger
    constexpr std::ptrdiff_t m_hPostSettings = 0xCD8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0xCE4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0xCE8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0xCEC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0xCF0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0xCF4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0xCF8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0xCFC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0xD00; // float
    constexpr std::ptrdiff_t m_bMaster = 0xD04; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0xD05; // bool
    constexpr std::ptrdiff_t m_flRate = 0xD08; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0xD0C; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0xD10; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0xD14; // float
}

namespace C_Precipitation { // C_BaseTrigger
    constexpr std::ptrdiff_t m_flDensity = 0xCC8; // float
    constexpr std::ptrdiff_t m_flParticleInnerDist = 0xCD8; // float
    constexpr std::ptrdiff_t m_pParticleDef = 0xCE0; // char*
    constexpr std::ptrdiff_t m_tParticlePrecipTraceTimer = 0xD08; // TimedEvent[1]
    constexpr std::ptrdiff_t m_bActiveParticlePrecipEmitter = 0xD10; // bool[1]
    constexpr std::ptrdiff_t m_bParticlePrecipInitialized = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSimulatedSinceLastSceneObjectUpdate = 0xD12; // bool
    constexpr std::ptrdiff_t m_nAvailableSheetSequencesMaxIndex = 0xD14; // int32_t
}

namespace C_PrecipitationBlocker { // C_BaseModelEntity
}

namespace C_PredictedViewModel { // C_BaseViewModel
    constexpr std::ptrdiff_t m_LagAnglesHistory = 0xEE8; // QAngle
    constexpr std::ptrdiff_t m_vPredictedOffset = 0xF00; // Vector
}

namespace C_RagdollManager { // C_BaseEntity
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x540; // int8_t
}

namespace C_RagdollProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_ragPos = 0xE88; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0xEA0; // C_NetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_flBlendWeight = 0xEB8; // float
    constexpr std::ptrdiff_t m_hRagdollSource = 0xEBC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xEC0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flBlendWeightCurrent = 0xEC4; // float
    constexpr std::ptrdiff_t m_parentPhysicsBoneIndices = 0xEC8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldSpaceBoneComputationOrder = 0xEE0; // CUtlVector<int32_t>
}

namespace C_RagdollPropAttached { // C_RagdollProp
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xEF8; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xEFC; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xF00; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xF0C; // Vector
    constexpr std::ptrdiff_t m_vecOffset = 0xF18; // Vector
    constexpr std::ptrdiff_t m_parentTime = 0xF24; // float
    constexpr std::ptrdiff_t m_bHasParent = 0xF28; // bool
}

namespace C_RectLight { // C_BarnLight
    constexpr std::ptrdiff_t m_bShowLight = 0xF08; // bool
}

namespace C_RetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace C_RopeKeyframe { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_LinksTouchingSomething = 0xCC8; // CBitVec<10>
    constexpr std::ptrdiff_t m_nLinksTouchingSomething = 0xCCC; // int32_t
    constexpr std::ptrdiff_t m_bApplyWind = 0xCD0; // bool
    constexpr std::ptrdiff_t m_fPrevLockedPoints = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_iForcePointMoveCounter = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_bPrevEndPointPos = 0xCDC; // bool[2]
    constexpr std::ptrdiff_t m_vPrevEndPointPos = 0xCE0; // Vector[2]
    constexpr std::ptrdiff_t m_flCurScroll = 0xCF8; // float
    constexpr std::ptrdiff_t m_flScrollSpeed = 0xCFC; // float
    constexpr std::ptrdiff_t m_RopeFlags = 0xD00; // uint16_t
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0xD08; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_LightValues = 0xF80; // Vector[10]
    constexpr std::ptrdiff_t m_nSegments = 0xFF8; // uint8_t
    constexpr std::ptrdiff_t m_hStartPoint = 0xFFC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x1000; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x1004; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x1005; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_Subdiv = 0x1006; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x1008; // int16_t
    constexpr std::ptrdiff_t m_Slack = 0x100A; // int16_t
    constexpr std::ptrdiff_t m_TextureScale = 0x100C; // float
    constexpr std::ptrdiff_t m_fLockedPoints = 0x1010; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x1011; // uint8_t
    constexpr std::ptrdiff_t m_Width = 0x1014; // float
    constexpr std::ptrdiff_t m_PhysicsDelegate = 0x1018; // C_RopeKeyframe::CPhysicsDelegate
    constexpr std::ptrdiff_t m_hMaterial = 0x1028; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_TextureHeight = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_vecImpulse = 0x1034; // Vector
    constexpr std::ptrdiff_t m_vecPreviousImpulse = 0x1040; // Vector
    constexpr std::ptrdiff_t m_flCurrentGustTimer = 0x104C; // float
    constexpr std::ptrdiff_t m_flCurrentGustLifetime = 0x1050; // float
    constexpr std::ptrdiff_t m_flTimeToNextGust = 0x1054; // float
    constexpr std::ptrdiff_t m_vWindDir = 0x1058; // Vector
    constexpr std::ptrdiff_t m_vColorMod = 0x1064; // Vector
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentPos = 0x1070; // Vector[2]
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentAngle = 0x1088; // QAngle[2]
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x10A0; // bool
    constexpr std::ptrdiff_t m_bEndPointAttachmentPositionsDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bEndPointAttachmentAnglesDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNewDataThisFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bPhysicsInitted = 0x0; // bitfield:1
}

namespace C_RopeKeyframe_CPhysicsDelegate {
    constexpr std::ptrdiff_t m_pKeyframe = 0x8; // C_RopeKeyframe*
}

namespace C_SceneEntity { // C_PointEntity
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x548; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x549; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x54A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x54B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x54C; // float
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x550; // uint16_t
    constexpr std::ptrdiff_t m_bClientOnly = 0x552; // bool
    constexpr std::ptrdiff_t m_hOwner = 0x554; // CHandle<C_BaseFlex>
    constexpr std::ptrdiff_t m_hActorList = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    constexpr std::ptrdiff_t m_bWasPlaying = 0x570; // bool
    constexpr std::ptrdiff_t m_QueuedEvents = 0x580; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    constexpr std::ptrdiff_t m_flCurrentTime = 0x598; // float
}

namespace C_SceneEntity_QueuedEvents_t {
    constexpr std::ptrdiff_t starttime = 0x0; // float
}

namespace C_SensorGrenade { // C_BaseCSGrenade
}

namespace C_SensorGrenadeProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_ShatterGlassShardPhysics { // C_PhysicsProp
    constexpr std::ptrdiff_t m_ShardDesc = 0xFE0; // shard_model_desc_t
}

namespace C_SingleplayRules { // C_GameRules
}

namespace C_SkyCamera { // C_BaseEntity
    constexpr std::ptrdiff_t m_skyboxData = 0x540; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x5D0; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x5D4; // bool
    constexpr std::ptrdiff_t m_pNext = 0x5D8; // C_SkyCamera*
}

namespace C_SmokeGrenade { // C_BaseCSGrenade
}

namespace C_SmokeGrenadeProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0x10F8; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0x10FC; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1100; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0x1104; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0x1110; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0x1120; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bSmokeVolumeDataReceived = 0x1138; // bool
    constexpr std::ptrdiff_t m_bSmokeEffectSpawned = 0x1139; // bool
}

namespace C_SoundAreaEntityBase { // C_BaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bWasEnabled = 0x548; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x558; // Vector
}

namespace C_SoundAreaEntityOrientedBox { // C_SoundAreaEntityBase
    constexpr std::ptrdiff_t m_vMin = 0x568; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x574; // Vector
}

namespace C_SoundAreaEntitySphere { // C_SoundAreaEntityBase
    constexpr std::ptrdiff_t m_flRadius = 0x568; // float
}

namespace C_SoundOpvarSetAABBEntity { // C_SoundOpvarSetPointEntity
}

namespace C_SoundOpvarSetOBBEntity { // C_SoundOpvarSetAABBEntity
}

namespace C_SoundOpvarSetOBBWindEntity { // C_SoundOpvarSetPointBase
}

namespace C_SoundOpvarSetPathCornerEntity { // C_SoundOpvarSetPointEntity
}

namespace C_SoundOpvarSetPointBase { // C_BaseEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x55C; // bool
}

namespace C_SoundOpvarSetPointEntity { // C_SoundOpvarSetPointBase
}

namespace C_SpotlightEnd { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flLightScale = 0xCC0; // float
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
}

namespace C_Sprite { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0xCD8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0xCE0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0xCE4; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFrame = 0xCEC; // float
    constexpr std::ptrdiff_t m_flDieTime = 0xCF0; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0xD00; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0xD04; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0xD08; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0xD0C; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0xD10; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xD14; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD18; // float
    constexpr std::ptrdiff_t m_flLastTime = 0xD1C; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0xD20; // float
    constexpr std::ptrdiff_t m_flStartScale = 0xD24; // float
    constexpr std::ptrdiff_t m_flDestScale = 0xD28; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0xD34; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_hOldSpriteMaterial = 0xD40; // CWeakHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nSpriteWidth = 0xDE8; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0xDEC; // int32_t
}

namespace C_SpriteOriented { // C_Sprite
}

namespace C_Sun { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_fxSSSunFlareEffectIndex = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fxSunFlareEffectIndex = 0xCC4; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fdistNormalize = 0xCC8; // float
    constexpr std::ptrdiff_t m_vSunPos = 0xCCC; // Vector
    constexpr std::ptrdiff_t m_vDirection = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_iszEffectName = 0xCE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0xCF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_clrOverlay = 0xCF8; // Color
    constexpr std::ptrdiff_t m_bOn = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0xCFD; // bool
    constexpr std::ptrdiff_t m_flSize = 0xD00; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0xD04; // float
    constexpr std::ptrdiff_t m_flRotation = 0xD08; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD0C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0xD10; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0xD14; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0xD18; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0xD1C; // float
}

namespace C_SunGlowOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_bModulateByDot = 0xD0; // bool
}

namespace C_Team { // C_BaseEntity
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x540; // C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x570; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x574; // char[129]
}

namespace C_TeamRoundTimer { // C_BaseEntity
    constexpr std::ptrdiff_t m_bTimerPaused = 0x540; // bool
    constexpr std::ptrdiff_t m_flTimeRemaining = 0x544; // float
    constexpr std::ptrdiff_t m_flTimerEndTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDisabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_bShowInHUD = 0x54D; // bool
    constexpr std::ptrdiff_t m_nTimerLength = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTimerInitialLength = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTimerMaxLength = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bAutoCountdown = 0x55C; // bool
    constexpr std::ptrdiff_t m_nSetupTimeLength = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nState = 0x564; // int32_t
    constexpr std::ptrdiff_t m_bStartPaused = 0x568; // bool
    constexpr std::ptrdiff_t m_bInCaptureWatchState = 0x569; // bool
    constexpr std::ptrdiff_t m_flTotalTime = 0x56C; // float
    constexpr std::ptrdiff_t m_bStopWatchTimer = 0x570; // bool
    constexpr std::ptrdiff_t m_bFireFinished = 0x571; // bool
    constexpr std::ptrdiff_t m_bFire5MinRemain = 0x572; // bool
    constexpr std::ptrdiff_t m_bFire4MinRemain = 0x573; // bool
    constexpr std::ptrdiff_t m_bFire3MinRemain = 0x574; // bool
    constexpr std::ptrdiff_t m_bFire2MinRemain = 0x575; // bool
    constexpr std::ptrdiff_t m_bFire1MinRemain = 0x576; // bool
    constexpr std::ptrdiff_t m_bFire30SecRemain = 0x577; // bool
    constexpr std::ptrdiff_t m_bFire10SecRemain = 0x578; // bool
    constexpr std::ptrdiff_t m_bFire5SecRemain = 0x579; // bool
    constexpr std::ptrdiff_t m_bFire4SecRemain = 0x57A; // bool
    constexpr std::ptrdiff_t m_bFire3SecRemain = 0x57B; // bool
    constexpr std::ptrdiff_t m_bFire2SecRemain = 0x57C; // bool
    constexpr std::ptrdiff_t m_bFire1SecRemain = 0x57D; // bool
    constexpr std::ptrdiff_t m_nOldTimerLength = 0x580; // int32_t
    constexpr std::ptrdiff_t m_nOldTimerState = 0x584; // int32_t
}

namespace C_TeamplayRules { // C_MultiplayRules
}

namespace C_TextureBasedAnimatable { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bLoop = 0xCC0; // bool
    constexpr std::ptrdiff_t m_flFPS = 0xCC4; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0xCC8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0xCD0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0xCE4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0xCF0; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0xCF4; // float
}

namespace C_TintController { // C_BaseEntity
}

namespace C_TonemapController2 { // C_BaseEntity
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x540; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x544; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x548; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x54C; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x550; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x554; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x558; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x55C; // float
}

namespace C_TonemapController2Alias_env_tonemap_controller2 { // C_TonemapController2
}

namespace C_TriggerBuoyancy { // C_BaseTrigger
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0xCE8; // float
}

namespace C_TriggerLerpObject { // C_BaseTrigger
}

namespace C_TriggerMultiple { // C_BaseTrigger
}

namespace C_TriggerVolume { // C_BaseModelEntity
}

namespace C_ViewmodelAttachmentModel { // CBaseAnimGraph
}

namespace C_ViewmodelWeapon { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_worldModel = 0xE80; // char*
}

namespace C_VoteController { // C_BaseEntity
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x558; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bVotesDirty = 0x570; // bool
    constexpr std::ptrdiff_t m_bTypeDirty = 0x571; // bool
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x572; // bool
}

namespace C_WaterBullet { // CBaseAnimGraph
}

namespace C_WeaponAWP { // C_CSWeaponBaseGun
}

namespace C_WeaponAug { // C_CSWeaponBaseGun
}

namespace C_WeaponBaseItem { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0x1990; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0x19A8; // bool
}

namespace C_WeaponBizon { // C_CSWeaponBaseGun
}

namespace C_WeaponCZ75a { // C_CSWeaponBaseGun
}

namespace C_WeaponElite { // C_CSWeaponBaseGun
}

namespace C_WeaponFamas { // C_CSWeaponBaseGun
}

namespace C_WeaponFiveSeven { // C_CSWeaponBaseGun
}

namespace C_WeaponG3SG1 { // C_CSWeaponBaseGun
}

namespace C_WeaponGalilAR { // C_CSWeaponBaseGun
}

namespace C_WeaponGlock { // C_CSWeaponBaseGun
}

namespace C_WeaponHKP2000 { // C_CSWeaponBaseGun
}

namespace C_WeaponM249 { // C_CSWeaponBaseGun
}

namespace C_WeaponM4A1 { // C_CSWeaponBaseGun
}

namespace C_WeaponM4A1Silencer { // C_CSWeaponBaseGun
}

namespace C_WeaponMAC10 { // C_CSWeaponBaseGun
}

namespace C_WeaponMP5SD { // C_CSWeaponBaseGun
}

namespace C_WeaponMP7 { // C_CSWeaponBaseGun
}

namespace C_WeaponMP9 { // C_CSWeaponBaseGun
}

namespace C_WeaponMag7 { // C_CSWeaponBaseGun
}

namespace C_WeaponNOVA { // C_CSWeaponBase
}

namespace C_WeaponNegev { // C_CSWeaponBaseGun
}

namespace C_WeaponP250 { // C_CSWeaponBaseGun
}

namespace C_WeaponP90 { // C_CSWeaponBaseGun
}

namespace C_WeaponRevolver { // C_CSWeaponBaseGun
}

namespace C_WeaponSCAR20 { // C_CSWeaponBaseGun
}

namespace C_WeaponSG556 { // C_CSWeaponBaseGun
}

namespace C_WeaponSSG08 { // C_CSWeaponBaseGun
}

namespace C_WeaponSawedoff { // C_CSWeaponBase
}

namespace C_WeaponShield { // C_CSWeaponBaseGun
    constexpr std::ptrdiff_t m_flDisplayHealth = 0x19B0; // float
}

namespace C_WeaponTaser { // C_CSWeaponBaseGun
    constexpr std::ptrdiff_t m_fFireTime = 0x19B0; // GameTime_t
}

namespace C_WeaponTec9 { // C_CSWeaponBaseGun
}

namespace C_WeaponUMP45 { // C_CSWeaponBaseGun
}

namespace C_WeaponUSPSilencer { // C_CSWeaponBaseGun
}

namespace C_WeaponXM1014 { // C_CSWeaponBase
}

namespace C_World { // C_BaseModelEntity
}

namespace C_WorldModelGloves { // CBaseAnimGraph
}

namespace C_WorldModelNametag { // CBaseAnimGraph
}

namespace C_WorldModelStattrak { // CBaseAnimGraph
}

namespace C_fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace CompMatMutatorCondition_t {
    constexpr std::ptrdiff_t m_nMutatorCondition = 0x0; // CompMatPropertyMutatorConditionType_t
    constexpr std::ptrdiff_t m_strMutatorConditionContainerName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarValue = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x20; // bool
}

namespace CompMatPropertyMutator_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nMutatorCommandType = 0x4; // CompMatPropertyMutatorType_t
    constexpr std::ptrdiff_t m_strInitWith_Container = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerSrc = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerProperty = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_TargetProperty = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strRandomRollInputVars_SeedInputVar = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecRandomRollInputVars_InputVarsToRoll = 0x30; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_strCopyMatchingKeys_InputContainerSrc = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_InputContainerSrc = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_FindSuffix = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_ReplaceSuffix = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_nSetValue_Value = 0x68; // CompositeMaterialInputLooseVariable_t
    constexpr std::ptrdiff_t m_strGenerateTexture_TargetParam = 0x2D8; // CUtlString
    constexpr std::ptrdiff_t m_strGenerateTexture_InitialContainer = 0x2E0; // CUtlString
    constexpr std::ptrdiff_t m_nResolution = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_bIsScratchTarget = 0x2EC; // bool
    constexpr std::ptrdiff_t m_bSplatDebugInfo = 0x2ED; // bool
    constexpr std::ptrdiff_t m_bCaptureInRenderDoc = 0x2EE; // bool
    constexpr std::ptrdiff_t m_vecTexGenInstructions = 0x2F0; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_vecConditionalMutators = 0x308; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_strPopInputQueue_Container = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerSrc = 0x328; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerProperty = 0x330; // CUtlString
    constexpr std::ptrdiff_t m_vecDrawText_Position = 0x338; // Vector2D
    constexpr std::ptrdiff_t m_colDrawText_Color = 0x340; // Color
    constexpr std::ptrdiff_t m_strDrawText_Font = 0x348; // CUtlString
    constexpr std::ptrdiff_t m_vecConditions = 0x350; // CUtlVector<CompMatMutatorCondition_t>
}

namespace CompositeMaterialAssemblyProcedure_t {
    constexpr std::ptrdiff_t m_vecCompMatIncludes = 0x0; // CUtlVector<CResourceName>
    constexpr std::ptrdiff_t m_vecMatchFilters = 0x18; // CUtlVector<CompositeMaterialMatchFilter_t>
    constexpr std::ptrdiff_t m_vecCompositeInputContainers = 0x30; // CUtlVector<CompositeMaterialInputContainer_t>
    constexpr std::ptrdiff_t m_vecPropertyMutators = 0x48; // CUtlVector<CompMatPropertyMutator_t>
}

namespace CompositeMaterialEditorPoint_t {
    constexpr std::ptrdiff_t m_ModelName = 0x0; // CResourceName
    constexpr std::ptrdiff_t m_nSequenceIndex = 0xE0; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xE4; // float
    constexpr std::ptrdiff_t m_KVModelStateChoices = 0xE8; // KeyValues3
    constexpr std::ptrdiff_t m_bEnableChildModel = 0xF8; // bool
    constexpr std::ptrdiff_t m_ChildModelName = 0x100; // CResourceName
    constexpr std::ptrdiff_t m_vecCompositeMaterialAssemblyProcedures = 0x1E0; // CUtlVector<CompositeMaterialAssemblyProcedure_t>
    constexpr std::ptrdiff_t m_vecCompositeMaterials = 0x1F8; // CUtlVector<CompositeMaterial_t>
}

namespace CompositeMaterialInputContainer_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nCompositeMaterialInputContainerSourceType = 0x4; // CompositeMaterialInputContainerSourceType_t
    constexpr std::ptrdiff_t m_strSpecificContainerMaterial = 0x8; // CResourceName
    constexpr std::ptrdiff_t m_strAttrName = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_strAlias = 0xF0; // CUtlString
    constexpr std::ptrdiff_t m_vecLooseVariables = 0xF8; // CUtlVector<CompositeMaterialInputLooseVariable_t>
    constexpr std::ptrdiff_t m_strAttrNameForVar = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x118; // bool
}

namespace CompositeMaterialInputLooseVariable_t {
    constexpr std::ptrdiff_t m_strName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x8; // bool
    constexpr std::ptrdiff_t m_strExposedFriendlyName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strExposedFriendlyGroupName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bExposedVariableIsFixedRange = 0x20; // bool
    constexpr std::ptrdiff_t m_strExposedVisibleWhenTrue = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strExposedHiddenWhenTrue = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_nVariableType = 0x38; // CompositeMaterialInputLooseVariableType_t
    constexpr std::ptrdiff_t m_bValueBoolean = 0x3C; // bool
    constexpr std::ptrdiff_t m_nValueIntX = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nValueIntY = 0x44; // int32_t
    constexpr std::ptrdiff_t m_nValueIntZ = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nValueIntW = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_bHasFloatBounds = 0x50; // bool
    constexpr std::ptrdiff_t m_flValueFloatX = 0x54; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Min = 0x58; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Max = 0x5C; // float
    constexpr std::ptrdiff_t m_flValueFloatY = 0x60; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Min = 0x64; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Max = 0x68; // float
    constexpr std::ptrdiff_t m_flValueFloatZ = 0x6C; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Min = 0x70; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Max = 0x74; // float
    constexpr std::ptrdiff_t m_flValueFloatW = 0x78; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Min = 0x7C; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Max = 0x80; // float
    constexpr std::ptrdiff_t m_cValueColor4 = 0x84; // Color
    constexpr std::ptrdiff_t m_nValueSystemVar = 0x88; // CompositeMaterialVarSystemVar_t
    constexpr std::ptrdiff_t m_strResourceMaterial = 0x90; // CResourceName
    constexpr std::ptrdiff_t m_strTextureContentAssetPath = 0x170; // CUtlString
    constexpr std::ptrdiff_t m_strTextureRuntimeResourcePath = 0x178; // CResourceName
    constexpr std::ptrdiff_t m_strTextureCompilationVtexTemplate = 0x258; // CUtlString
    constexpr std::ptrdiff_t m_nTextureType = 0x260; // CompositeMaterialInputTextureType_t
    constexpr std::ptrdiff_t m_strString = 0x268; // CUtlString
}

namespace CompositeMaterialMatchFilter_t {
    constexpr std::ptrdiff_t m_nCompositeMaterialMatchFilterType = 0x0; // CompositeMaterialMatchFilterType_t
    constexpr std::ptrdiff_t m_strMatchFilter = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMatchValue = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x18; // bool
}

namespace CompositeMaterial_t {
    constexpr std::ptrdiff_t m_TargetKVs = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_PreGenerationKVs = 0x18; // KeyValues3
    constexpr std::ptrdiff_t m_FinalKVs = 0x28; // KeyValues3
    constexpr std::ptrdiff_t m_vecGeneratedTextures = 0x40; // CUtlVector<GeneratedTextureHandle_t>
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace GeneratedTextureHandle_t {
    constexpr std::ptrdiff_t m_strBitmapName = 0x0; // CUtlString
}

namespace IClientAlphaProperty {
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // C_NetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bDirty = 0x68; // bool
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace TimedEvent {
    constexpr std::ptrdiff_t m_TimeBetweenEvents = 0x0; // float
    constexpr std::ptrdiff_t m_fNextEvent = 0x4; // float
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // C_NetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}
```

`HPCS2/HPCS2/offset/engine2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CEmptyEntityInstance {
}

namespace CEntityComponent {
}

namespace CEntityComponentHelper {
    constexpr std::ptrdiff_t m_flags = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pInfo = 0x10; // EntComponentInfo_t*
    constexpr std::ptrdiff_t m_nPriority = 0x18; // int32_t
    constexpr std::ptrdiff_t m_pNext = 0x20; // CEntityComponentHelper*
}

namespace CEntityIOOutput {
    constexpr std::ptrdiff_t m_Value = 0x18; // CVariantBase<CVariantDefaultAllocator>
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CNetworkVarChainer {
    constexpr std::ptrdiff_t m_PathIndex = 0x20; // ChangeAccessorFieldPathIndex_t
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CVariantDefaultAllocator {
}

namespace EngineLoopState_t {
    constexpr std::ptrdiff_t m_nPlatWindowWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nPlatWindowHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nRenderWidth = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nRenderHeight = 0x24; // int32_t
}

namespace EntComponentInfo_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char*
    constexpr std::ptrdiff_t m_pCPPClassname = 0x8; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedDescription = 0x10; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedPtrPropDescription = 0x18; // char*
    constexpr std::ptrdiff_t m_nRuntimeIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_pBaseClassComponentHelper = 0x60; // CEntityComponentHelper*
}

namespace EntInput_t {
}

namespace EntOutput_t {
}

namespace EventAdvanceTick_t { // EventSimulate_t
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventAppShutdown_t {
    constexpr std::ptrdiff_t m_nDummy0 = 0x0; // int32_t
}

namespace EventClientAdvanceTick_t { // EventAdvanceTick_t
}

namespace EventClientFrameSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // float
    constexpr std::ptrdiff_t m_flRealTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x30; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x34; // bool
}

namespace EventClientPauseSimulate_t { // EventSimulate_t
}

namespace EventClientPollInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientPollNetworking_t {
    constexpr std::ptrdiff_t m_nTickCount = 0x0; // int32_t
}

namespace EventClientPostAdvanceTick_t { // EventPostAdvanceTick_t
}

namespace EventClientPostOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x34; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x38; // bool
}

namespace EventClientPostSimulate_t { // EventSimulate_t
}

namespace EventClientPreOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x38; // double
    constexpr std::ptrdiff_t m_flRealTime = 0x40; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x44; // bool
}

namespace EventClientPreSimulate_t { // EventSimulate_t
}

namespace EventClientPredictionPostNetupdate_t {
}

namespace EventClientProcessGameInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientProcessInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientProcessNetworking_t {
}

namespace EventClientSceneSystemThreadStateChange_t {
    constexpr std::ptrdiff_t m_bThreadsActive = 0x0; // bool
}

namespace EventClientSendInput_t {
    constexpr std::ptrdiff_t m_bFinalClientCommandTick = 0x0; // bool
    constexpr std::ptrdiff_t m_nAdditionalClientCommandsToCreate = 0x4; // int32_t
}

namespace EventClientSimulate_t { // EventSimulate_t
}

namespace EventFrameBoundary_t {
    constexpr std::ptrdiff_t m_flFrameTime = 0x0; // float
}

namespace EventModInitialized_t {
}

namespace EventPostAdvanceTick_t { // EventSimulate_t
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventPostDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventPreDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventProfileStorageAvailable_t {
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x0; // CSplitScreenSlot
}

namespace EventServerAdvanceTick_t { // EventAdvanceTick_t
}

namespace EventServerPollNetworking_t { // EventSimulate_t
}

namespace EventServerPostAdvanceTick_t { // EventPostAdvanceTick_t
}

namespace EventServerPostSimulate_t { // EventSimulate_t
}

namespace EventServerProcessNetworking_t { // EventSimulate_t
}

namespace EventServerSimulate_t { // EventSimulate_t
}

namespace EventSetTime_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_nClientOutputFrames = 0x28; // int32_t
    constexpr std::ptrdiff_t m_flRealTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderTime = 0x38; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x40; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x48; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnscaled = 0x50; // double
    constexpr std::ptrdiff_t m_flTickRemainder = 0x58; // double
}

namespace EventSimpleLoopFrameUpdate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_bFirstTick = 0x28; // bool
    constexpr std::ptrdiff_t m_bLastTick = 0x29; // bool
}

namespace EventSplitScreenStateChanged_t {
}
```

`HPCS2/HPCS2/offset/host.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:22 +0000
 */

#pragma once

#include <cstddef>

namespace CAnimScriptBase {
    constexpr std::ptrdiff_t m_bIsValid = 0x8; // bool
}

namespace EmptyTestScript { // CAnimScriptBase
    constexpr std::ptrdiff_t m_hTest = 0x10; // CAnimScriptParam<float>
}
```

`HPCS2/HPCS2/offset/interfaces.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:23 +0000
 */

#pragma once

#include <cstddef>

namespace animationsystem_dll { // animationsystem.dll
    constexpr std::ptrdiff_t AnimationSystemUtils_001 = 0x64670;
    constexpr std::ptrdiff_t AnimationSystem_001 = 0x5F1D0;
}

namespace client_dll { // client.dll
    constexpr std::ptrdiff_t LegacyGameUI001 = 0x899820;
    constexpr std::ptrdiff_t Source2ClientUI001 = 0x888530;
    constexpr std::ptrdiff_t Source2ClientPrediction001 = 0x7A1860;
    constexpr std::ptrdiff_t ClientToolsInfo_001 = 0x72DAA0;
    constexpr std::ptrdiff_t Source2Client002 = 0x72DAC0;
    constexpr std::ptrdiff_t GameClientExports001 = 0x72DAB0;
    constexpr std::ptrdiff_t EmptyWorldService001_Client = 0x48DEF0;
    constexpr std::ptrdiff_t Source2ClientConfig001 = 0x474F00;
}

namespace engine2_dll { // engine2.dll
    constexpr std::ptrdiff_t SimpleEngineLoopService_001 = 0x1E3370;
    constexpr std::ptrdiff_t ClientServerEngineLoopService_001 = 0x1D9040;
    constexpr std::ptrdiff_t KeyValueCache001 = 0x1D5680;
    constexpr std::ptrdiff_t HostStateMgr001 = 0x1D2E80;
    constexpr std::ptrdiff_t GameEventSystemServerV001 = 0x1CE520;
    constexpr std::ptrdiff_t GameEventSystemClientV001 = 0x1CE510;
    constexpr std::ptrdiff_t EngineServiceMgr001 = 0x1CA200;
    constexpr std::ptrdiff_t VProfService_001 = 0x1B7C90;
    constexpr std::ptrdiff_t ToolService_001 = 0x1B69E0;
    constexpr std::ptrdiff_t StatsService_001 = 0x1B1C60;
    constexpr std::ptrdiff_t SplitScreenService_001 = 0x1AEED0;
    constexpr std::ptrdiff_t SoundService_001 = 0x1A9A10;
    constexpr std::ptrdiff_t ScreenshotService001 = 0x1A58E0;
    constexpr std::ptrdiff_t RenderService_001 = 0x1A2C40;
    constexpr std::ptrdiff_t NetworkService_001 = 0x1A2750;
    constexpr std::ptrdiff_t NetworkServerService_001 = 0x19D7F0;
    constexpr std::ptrdiff_t NetworkP2PService_001 = 0x199200;
    constexpr std::ptrdiff_t NetworkClientService_001 = 0x192E30;
    constexpr std::ptrdiff_t MapListService_001 = 0x18BE00;
    constexpr std::ptrdiff_t InputService_001 = 0x179C80;
    constexpr std::ptrdiff_t GameUIService_001 = 0x1744A0;
    constexpr std::ptrdiff_t GameResourceServiceServerV001 = 0x172200;
    constexpr std::ptrdiff_t GameResourceServiceClientV001 = 0x1721F0;
    constexpr std::ptrdiff_t BugService001 = 0x16B220;
    constexpr std::ptrdiff_t BenchmarkService001 = 0x1699F0;
    constexpr std::ptrdiff_t VENGINE_GAMEUIFUNCS_VERSION005 = 0x116F70;
    constexpr std::ptrdiff_t EngineGameUI001 = 0x116300;
    constexpr std::ptrdiff_t INETSUPPORT_001 = 0xE6510;
    constexpr std::ptrdiff_t Source2EngineToServerStringTable001 = 0xA14C0;
    constexpr std::ptrdiff_t Source2EngineToServer001 = 0x8B300;
    constexpr std::ptrdiff_t Source2EngineToClientStringTable001 = 0x84020;
    constexpr std::ptrdiff_t Source2EngineToClient001 = 0x5AA60;
}

namespace filesystem_stdio_dll { // filesystem_stdio.dll
    constexpr std::ptrdiff_t VAsyncFileSystem2_001 = 0x66D30;
    constexpr std::ptrdiff_t VFileSystem017 = 0x66D20;
}

namespace host_dll { // host.dll
    constexpr std::ptrdiff_t Source2Host001 = 0x18E10;
    constexpr std::ptrdiff_t SinglePlayerSharedMemory001 = 0x18A90;
    constexpr std::ptrdiff_t SaveRestoreDataVersion001 = 0x18A80;
    constexpr std::ptrdiff_t PredictionDiffManager001 = 0x16E20;
    constexpr std::ptrdiff_t HostUtils001 = 0x12550;
    constexpr std::ptrdiff_t GameSystem2HostHook = 0x11DA0;
    constexpr std::ptrdiff_t GameModelInfo001 = 0x11CC0;
    constexpr std::ptrdiff_t DebugDrawQueueManager001 = 0x11710;
}

namespace imemanager_dll { // imemanager.dll
    constexpr std::ptrdiff_t IMEManager001 = 0xC470;
}

namespace inputsystem_dll { // inputsystem.dll
    constexpr std::ptrdiff_t InputSystemVersion001 = 0x28D0;
    constexpr std::ptrdiff_t InputStackSystemVersion001 = 0x16F0;
}

namespace localize_dll { // localize.dll
    constexpr std::ptrdiff_t Localize_001 = 0x3830;
}

namespace matchmaking_dll { // matchmaking.dll
    constexpr std::ptrdiff_t GameTypes001 = 0x50270;
    constexpr std::ptrdiff_t MATCHFRAMEWORK_001 = 0x101030;
}

namespace materialsystem2_dll { // materialsystem2.dll
    constexpr std::ptrdiff_t MaterialUtils_001 = 0x4DB90;
    constexpr std::ptrdiff_t TextLayout_001 = 0x4A2E0;
    constexpr std::ptrdiff_t PostProcessingSystem_001 = 0x42A60;
    constexpr std::ptrdiff_t FontManager_001 = 0x37900;
    constexpr std::ptrdiff_t VMaterialSystem2_001 = 0x25EC0;
}

namespace meshsystem_dll { // meshsystem.dll
    constexpr std::ptrdiff_t MeshSystem001 = 0x7270;
}

namespace navsystem_dll { // navsystem.dll
    constexpr std::ptrdiff_t NavSystem001 = 0x76F0;
}

namespace networksystem_dll { // networksystem.dll
    constexpr std::ptrdiff_t SerializedEntitiesVersion001 = 0xD1AD0;
    constexpr std::ptrdiff_t NetworkSystemVersion001 = 0xBBF90;
    constexpr std::ptrdiff_t NetworkMessagesVersion001 = 0x9C030;
    constexpr std::ptrdiff_t FlattenedSerializersVersion001 = 0x7B8A0;
}

namespace panorama_dll { // panorama.dll
    constexpr std::ptrdiff_t PanoramaUIEngine001 = 0x57EE0;
}

namespace panorama_text_pango_dll { // panorama_text_pango.dll
    constexpr std::ptrdiff_t PanoramaTextServices001 = 0x4CBD0;
}

namespace panoramauiclient_dll { // panoramauiclient.dll
    constexpr std::ptrdiff_t PanoramaUIClient001 = 0x12780;
}

namespace particles_dll { // particles.dll
    constexpr std::ptrdiff_t ParticleSystemMgr003 = 0x52D20;
}

namespace pulse_system_dll { // pulse_system.dll
    constexpr std::ptrdiff_t IPulseSystem_001 = 0x5B80;
}

namespace rendersystemdx11_dll { // rendersystemdx11.dll
    constexpr std::ptrdiff_t RenderUtils_001 = 0x52FD0;
    constexpr std::ptrdiff_t VRenderDeviceMgrBackdoor001 = 0x4A4F0;
    constexpr std::ptrdiff_t RenderDeviceMgr001 = 0x4A4E0;
}

namespace resourcesystem_dll { // resourcesystem.dll
    constexpr std::ptrdiff_t ResourceSystem013 = 0x10650;
}

namespace scenefilecache_dll { // scenefilecache.dll
    constexpr std::ptrdiff_t SceneFileCache002 = 0x68E0;
    constexpr std::ptrdiff_t ResponseRulesCache001 = 0x3190;
}

namespace scenesystem_dll { // scenesystem.dll
    constexpr std::ptrdiff_t SceneUtils_001 = 0x13C370;
    constexpr std::ptrdiff_t SceneSystem_002 = 0xCA160;
    constexpr std::ptrdiff_t RenderingPipelines_001 = 0x8E420;
}

namespace schemasystem_dll { // schemasystem.dll
    constexpr std::ptrdiff_t SchemaSystem_001 = 0xA930;
}

namespace server_dll { // server.dll
    constexpr std::ptrdiff_t NavGameTest001 = 0xA35420;
    constexpr std::ptrdiff_t ServerToolsInfo_001 = 0x838790;
    constexpr std::ptrdiff_t Source2GameClients001 = 0x8387A0;
    constexpr std::ptrdiff_t Source2GameEntities001 = 0x8387B0;
    constexpr std::ptrdiff_t Source2Server001 = 0x8387C0;
    constexpr std::ptrdiff_t EmptyWorldService001_Server = 0x58D750;
    constexpr std::ptrdiff_t Source2ServerConfig001 = 0x56D760;
    constexpr std::ptrdiff_t EntitySubclassUtilsV001 = 0x2CD4C0;
    constexpr std::ptrdiff_t customnavsystem001 = 0x24A3F0;
    constexpr std::ptrdiff_t Source2GameDirector001 = 0x151EC0;
}

namespace soundsystem_dll { // soundsystem.dll
    constexpr std::ptrdiff_t SoundOpSystem001 = 0x1567E0;
    constexpr std::ptrdiff_t SoundOpSystemEdit001 = 0x8BBC0;
    constexpr std::ptrdiff_t VMixEditTool001 = 0x71740;
    constexpr std::ptrdiff_t SoundSystem001 = 0x46540;
}

namespace steamaudio_dll { // steamaudio.dll
    constexpr std::ptrdiff_t SteamAudio001 = 0x12EE0;
}

namespace steamclient64_dll { // steamclient64.dll
    constexpr std::ptrdiff_t IVALIDATE001 = 0x83A900;
    constexpr std::ptrdiff_t CLIENTENGINE_INTERFACE_VERSION005 = 0x8367B0;
    constexpr std::ptrdiff_t SteamClient020 = 0x631440;
    constexpr std::ptrdiff_t SteamClient019 = 0x631430;
    constexpr std::ptrdiff_t SteamClient018 = 0x631420;
    constexpr std::ptrdiff_t SteamClient017 = 0x631410;
    constexpr std::ptrdiff_t SteamClient016 = 0x631400;
    constexpr std::ptrdiff_t SteamClient015 = 0x6313F0;
    constexpr std::ptrdiff_t SteamClient014 = 0x6313E0;
    constexpr std::ptrdiff_t SteamClient013 = 0x6313D0;
    constexpr std::ptrdiff_t SteamClient012 = 0x6313C0;
    constexpr std::ptrdiff_t SteamClient011 = 0x6313B0;
    constexpr std::ptrdiff_t SteamClient010 = 0x6313A0;
    constexpr std::ptrdiff_t SteamClient009 = 0x631390;
    constexpr std::ptrdiff_t SteamClient008 = 0x631380;
    constexpr std::ptrdiff_t SteamClient007 = 0x631370;
    constexpr std::ptrdiff_t SteamClient006 = 0x631360;
    constexpr std::ptrdiff_t p2pvoice002 = 0xD93D0;
    constexpr std::ptrdiff_t p2pvoicesingleton002 = 0xD5D70;
}

namespace tier0_dll { // tier0.dll
    constexpr std::ptrdiff_t VStringTokenSystem001 = 0x18C100;
    constexpr std::ptrdiff_t TestScriptMgr001 = 0x13F460;
    constexpr std::ptrdiff_t VProcessUtils002 = 0x12F5E0;
    constexpr std::ptrdiff_t VEngineCvar007 = 0x61920;
}

namespace v8system_dll { // v8system.dll
    constexpr std::ptrdiff_t Source2V8System001 = 0x1670;
}

namespace valve_avi_dll { // valve_avi.dll
    constexpr std::ptrdiff_t VAvi001 = 0x2F90;
}

namespace valve_wmf_dll { // valve_wmf.dll
    constexpr std::ptrdiff_t VMediaFoundation001 = 0x12D0;
}

namespace vphysics2_dll { // vphysics2.dll
    constexpr std::ptrdiff_t VPhysics2_Handle_Interface_001 = 0x61120;
    constexpr std::ptrdiff_t VPhysics2_Interface_001 = 0x5C740;
}

namespace vscript_dll { // vscript.dll
    constexpr std::ptrdiff_t VScriptManager010 = 0x31DA0;
}

namespace vstdlib_s64_dll { // vstdlib_s64.dll
    constexpr std::ptrdiff_t IVALIDATE001 = 0x24FF0;
    constexpr std::ptrdiff_t VEngineCvar002 = 0x5750;
}

namespace worldrenderer_dll { // worldrenderer.dll
    constexpr std::ptrdiff_t WorldRendererMgr001 = 0x21650;
}
```

`HPCS2/HPCS2/offset/materialsystem2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace MaterialParamBuffer_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlBinaryBlock
}

namespace MaterialParamFloat_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_flValue = 0x8; // float
}

namespace MaterialParamInt_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace MaterialParamString_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlString
}

namespace MaterialParamTexture_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_pValue = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace MaterialParamVector_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // Vector4D
}

namespace MaterialParam_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace MaterialResourceData_t {
    constexpr std::ptrdiff_t m_materialName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_shaderName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_intParams = 0x10; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatParams = 0x28; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorParams = 0x40; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureParams = 0x58; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_dynamicParams = 0x70; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_dynamicTextureParams = 0x88; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_intAttributes = 0xA0; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatAttributes = 0xB8; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorAttributes = 0xD0; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureAttributes = 0xE8; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_stringAttributes = 0x100; // CUtlVector<MaterialParamString_t>
    constexpr std::ptrdiff_t m_renderAttributesUsed = 0x118; // CUtlVector<CUtlString>
}

namespace PostProcessingBloomParameters_t {
    constexpr std::ptrdiff_t m_blendMode = 0x0; // BloomBlendMode_t
    constexpr std::ptrdiff_t m_flBloomStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flScreenBloomStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flBlurBloomStrength = 0xC; // float
    constexpr std::ptrdiff_t m_flBloomThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_flBloomThresholdWidth = 0x14; // float
    constexpr std::ptrdiff_t m_flSkyboxBloomStrength = 0x18; // float
    constexpr std::ptrdiff_t m_flBloomStartValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flBlurWeight = 0x20; // float[5]
    constexpr std::ptrdiff_t m_vBlurTint = 0x34; // Vector[5]
}

namespace PostProcessingLocalContrastParameters_t {
    constexpr std::ptrdiff_t m_flLocalContrastStrength = 0x0; // float
    constexpr std::ptrdiff_t m_flLocalContrastEdgeStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteStart = 0x8; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteEnd = 0xC; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteBlur = 0x10; // float
}

namespace PostProcessingResource_t {
    constexpr std::ptrdiff_t m_bHasTonemapParams = 0x0; // bool
    constexpr std::ptrdiff_t m_toneMapParams = 0x4; // PostProcessingTonemapParameters_t
    constexpr std::ptrdiff_t m_bHasBloomParams = 0x40; // bool
    constexpr std::ptrdiff_t m_bloomParams = 0x44; // PostProcessingBloomParameters_t
    constexpr std::ptrdiff_t m_bHasVignetteParams = 0xB4; // bool
    constexpr std::ptrdiff_t m_vignetteParams = 0xB8; // PostProcessingVignetteParameters_t
    constexpr std::ptrdiff_t m_bHasLocalContrastParams = 0xDC; // bool
    constexpr std::ptrdiff_t m_localConstrastParams = 0xE0; // PostProcessingLocalContrastParameters_t
    constexpr std::ptrdiff_t m_nColorCorrectionVolumeDim = 0xF4; // int32_t
    constexpr std::ptrdiff_t m_colorCorrectionVolumeData = 0xF8; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_bHasColorCorrection = 0x110; // bool
}

namespace PostProcessingTonemapParameters_t {
    constexpr std::ptrdiff_t m_flExposureBias = 0x0; // float
    constexpr std::ptrdiff_t m_flShoulderStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLinearStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flLinearAngle = 0xC; // float
    constexpr std::ptrdiff_t m_flToeStrength = 0x10; // float
    constexpr std::ptrdiff_t m_flToeNum = 0x14; // float
    constexpr std::ptrdiff_t m_flToeDenom = 0x18; // float
    constexpr std::ptrdiff_t m_flWhitePoint = 0x1C; // float
    constexpr std::ptrdiff_t m_flLuminanceSource = 0x20; // float
    constexpr std::ptrdiff_t m_flExposureBiasShadows = 0x24; // float
    constexpr std::ptrdiff_t m_flExposureBiasHighlights = 0x28; // float
    constexpr std::ptrdiff_t m_flMinShadowLum = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxShadowLum = 0x30; // float
    constexpr std::ptrdiff_t m_flMinHighlightLum = 0x34; // float
    constexpr std::ptrdiff_t m_flMaxHighlightLum = 0x38; // float
}

namespace PostProcessingVignetteParameters_t {
    constexpr std::ptrdiff_t m_flVignetteStrength = 0x0; // float
    constexpr std::ptrdiff_t m_vCenter = 0x4; // Vector2D
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
    constexpr std::ptrdiff_t m_flRoundness = 0x10; // float
    constexpr std::ptrdiff_t m_flFeather = 0x14; // float
    constexpr std::ptrdiff_t m_vColorTint = 0x18; // Vector
}
```

`HPCS2/HPCS2/offset/networksystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace ChangeAccessorFieldPathIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}
```

`HPCS2/HPCS2/offset/offsets.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:24 +0000
 */

#pragma once

#include <cstddef>

namespace client_dll { // client.dll
    constexpr std::ptrdiff_t dwBaseEntityModel_setModel = 0x581530;
    constexpr std::ptrdiff_t dwEntityList = 0x17AB958;
    constexpr std::ptrdiff_t dwForceAttack = 0x16B02B0;
    constexpr std::ptrdiff_t dwForceAttack2 = 0x16B0340;
    constexpr std::ptrdiff_t dwForceBackward = 0x16B0580;
    constexpr std::ptrdiff_t dwForceCrouch = 0x16B0850;
    constexpr std::ptrdiff_t dwForceForward = 0x16B04F0;
    constexpr std::ptrdiff_t dwForceJump = 0x16B07C0;
    constexpr std::ptrdiff_t dwForceLeft = 0x16B0610;
    constexpr std::ptrdiff_t dwForceRight = 0x16B06A0;
    constexpr std::ptrdiff_t dwGameEntitySystem = 0x18D51A8;
    constexpr std::ptrdiff_t dwGameEntitySystem_getBaseEntity = 0x604B40;
    constexpr std::ptrdiff_t dwGameEntitySystem_getHighestEntityIndex = 0x5F6830;
    constexpr std::ptrdiff_t dwGameRules = 0x1807FA8;
    constexpr std::ptrdiff_t dwGlobalVars = 0x16AC100;
    constexpr std::ptrdiff_t dwGlowManager = 0x1807708;
    constexpr std::ptrdiff_t dwInterfaceLinkList = 0x1902EB8;
    constexpr std::ptrdiff_t dwLocalPlayerController = 0x17FAC68;
    constexpr std::ptrdiff_t dwLocalPlayerPawn = 0x16B7340;
    constexpr std::ptrdiff_t dwPlantedC4 = 0x180EB48;
    constexpr std::ptrdiff_t dwPrediction = 0x16B7210;
    constexpr std::ptrdiff_t dwViewAngles = 0x18690D8;
    constexpr std::ptrdiff_t dwViewMatrix = 0x180A0D0;
    constexpr std::ptrdiff_t dwViewRender = 0x180A090;
}

namespace engine2_dll { // engine2.dll
    constexpr std::ptrdiff_t dwBuildNumber = 0x488514;
    constexpr std::ptrdiff_t dwNetworkGameClient = 0x487AB0;
    constexpr std::ptrdiff_t dwNetworkGameClient_getLocalPlayer = 0xF0;
    constexpr std::ptrdiff_t dwNetworkGameClient_maxClients = 0x250;
    constexpr std::ptrdiff_t dwNetworkGameClient_signOnState = 0x240;
    constexpr std::ptrdiff_t dwWindowHeight = 0x5397DC;
    constexpr std::ptrdiff_t dwWindowWidth = 0x5397D8;
}

namespace inputsystem_dll { // inputsystem.dll
    constexpr std::ptrdiff_t dwInputSystem = 0x35770;
}
```

`HPCS2/HPCS2/offset/particles.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CBaseRendererSource2 { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x608; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x610; // CParticleCollectionRendererVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xC68; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nShaderType = 0xC6C; // SpriteCardShaderType_t
    constexpr std::ptrdiff_t m_strShaderOverride = 0xC70; // CUtlString
    constexpr std::ptrdiff_t m_flCenterXOffset = 0xC78; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flCenterYOffset = 0xDD0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flBumpStrength = 0xF28; // float
    constexpr std::ptrdiff_t m_nCropTextureOverride = 0xF2C; // ParticleSequenceCropOverride_t
    constexpr std::ptrdiff_t m_vecTexturesInput = 0xF30; // CUtlVector<TextureGroup_t>
    constexpr std::ptrdiff_t m_flAnimationRate = 0xF48; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0xF4C; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0xF50; // bool
    constexpr std::ptrdiff_t m_flSelfIllumAmount = 0xF58; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDiffuseAmount = 0x10B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nLightingControlPoint = 0x1208; // int32_t
    constexpr std::ptrdiff_t m_nSelfIllumPerParticle = 0x120C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nOutputBlendMode = 0x1210; // ParticleOutputBlendMode_t
    constexpr std::ptrdiff_t m_bGammaCorrectVertexColors = 0x1214; // bool
    constexpr std::ptrdiff_t m_bSaturateColorPreAlphaBlend = 0x1215; // bool
    constexpr std::ptrdiff_t m_flAddSelfAmount = 0x1218; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDesaturation = 0x1370; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flOverbrightFactor = 0x14C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_nFogType = 0x1624; // ParticleFogType_t
    constexpr std::ptrdiff_t m_flFogAmount = 0x1628; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bTintByFOW = 0x1780; // bool
    constexpr std::ptrdiff_t m_bTintByGlobalLight = 0x1781; // bool
    constexpr std::ptrdiff_t m_nPerParticleAlphaReference = 0x1784; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleAlphaRefWindow = 0x1788; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nAlphaReferenceType = 0x178C; // ParticleAlphaReferenceType_t
    constexpr std::ptrdiff_t m_flAlphaReferenceSoftness = 0x1790; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToZero = 0x18E8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToOne = 0x1A40; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRefract = 0x1B98; // bool
    constexpr std::ptrdiff_t m_bRefractSolid = 0x1B99; // bool
    constexpr std::ptrdiff_t m_flRefractAmount = 0x1BA0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nRefractBlurRadius = 0x1CF8; // int32_t
    constexpr std::ptrdiff_t m_nRefractBlurType = 0x1CFC; // BlurFilterType_t
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x1D00; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x1D01; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x1D02; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x1D03; // bool
    constexpr std::ptrdiff_t m_stencilTestID = 0x1D04; // char[128]
    constexpr std::ptrdiff_t m_bStencilTestExclude = 0x1D84; // bool
    constexpr std::ptrdiff_t m_stencilWriteID = 0x1D85; // char[128]
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthPass = 0x1E05; // bool
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthFail = 0x1E06; // bool
    constexpr std::ptrdiff_t m_bReverseZBuffering = 0x1E07; // bool
    constexpr std::ptrdiff_t m_bDisableZBuffering = 0x1E08; // bool
    constexpr std::ptrdiff_t m_nFeatheringMode = 0x1E0C; // ParticleDepthFeatheringMode_t
    constexpr std::ptrdiff_t m_flFeatheringMinDist = 0x1E10; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringMaxDist = 0x1F68; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringFilter = 0x20C0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDepthBias = 0x2218; // float
    constexpr std::ptrdiff_t m_nSortMethod = 0x221C; // ParticleSortingChoiceList_t
    constexpr std::ptrdiff_t m_bBlendFramesSeq0 = 0x2220; // bool
    constexpr std::ptrdiff_t m_bMaxLuminanceBlendingSequence0 = 0x2221; // bool
}

namespace CBaseTrailRenderer { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_nOrientationType = 0x2470; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x2474; // int32_t
    constexpr std::ptrdiff_t m_flMinSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x2480; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x25D8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bClampV = 0x2730; // bool
}

namespace CGeneralRandomRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDegrees = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDegreesMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDegreesMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flRotationRandExponent = 0x1D0; // float
    constexpr std::ptrdiff_t m_bRandomlyFlipDirection = 0x1D4; // bool
}

namespace CGeneralSpin { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSpinRateDegrees = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSpinRateMinDegrees = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_fSpinRateStopTime = 0x1CC; // float
}

namespace CNewParticleEffect { // IParticleEffect
    constexpr std::ptrdiff_t m_pNext = 0x10; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pPrev = 0x18; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pParticles = 0x20; // IParticleCollection*
    constexpr std::ptrdiff_t m_pDebugName = 0x28; // char*
    constexpr std::ptrdiff_t m_bDontRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNeedsBBoxUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsFirstFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAutoUpdateBBox = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAllocated = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bSimulate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldPerformCullCheck = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bForceNoDraw = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSave = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDisableAggregation = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSimulateDuringGamePaused = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldCheckFoW = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_vSortOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flScale = 0x4C; // float
    constexpr std::ptrdiff_t m_hOwner = 0x50; // PARTICLE_EHANDLE__*
    constexpr std::ptrdiff_t m_pOwningParticleProperty = 0x58; // CParticleProperty*
    constexpr std::ptrdiff_t m_flFreezeTransitionStart = 0x70; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x74; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionOverride = 0x78; // float
    constexpr std::ptrdiff_t m_bFreezeTransitionActive = 0x7C; // bool
    constexpr std::ptrdiff_t m_bFreezeTargetState = 0x7D; // bool
    constexpr std::ptrdiff_t m_bCanFreeze = 0x7E; // bool
    constexpr std::ptrdiff_t m_LastMin = 0x80; // Vector
    constexpr std::ptrdiff_t m_LastMax = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nSplitScreenUser = 0x98; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_vecAggregationCenter = 0x9C; // Vector
    constexpr std::ptrdiff_t m_RefCount = 0xC0; // int32_t
}

namespace CParticleBindingRealPulse { // CParticleCollectionBindingInstance
}

namespace CParticleCollectionBindingInstance { // CBasePulseGraphInstance
}

namespace CParticleCollectionFloatInput { // CParticleFloatInput
}

namespace CParticleCollectionRendererFloatInput { // CParticleCollectionFloatInput
}

namespace CParticleCollectionRendererVecInput { // CParticleCollectionVecInput
}

namespace CParticleCollectionVecInput { // CParticleVecInput
}

namespace CParticleFloatInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleFloatType_t
    constexpr std::ptrdiff_t m_nMapType = 0x14; // ParticleFloatMapType_t
    constexpr std::ptrdiff_t m_flLiteralValue = 0x18; // float
    constexpr std::ptrdiff_t m_NamedValue = 0x20; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nScalarAttribute = 0x64; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x68; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorComponent = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_flRandomMin = 0x70; // float
    constexpr std::ptrdiff_t m_flRandomMax = 0x74; // float
    constexpr std::ptrdiff_t m_bHasRandomSignFlip = 0x78; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRandomMode = 0x80; // ParticleFloatRandomMode_t
    constexpr std::ptrdiff_t m_flLOD0 = 0x88; // float
    constexpr std::ptrdiff_t m_flLOD1 = 0x8C; // float
    constexpr std::ptrdiff_t m_flLOD2 = 0x90; // float
    constexpr std::ptrdiff_t m_flLOD3 = 0x94; // float
    constexpr std::ptrdiff_t m_nNoiseInputVectorAttribute = 0x98; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flNoiseOutputMin = 0x9C; // float
    constexpr std::ptrdiff_t m_flNoiseOutputMax = 0xA0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0xA4; // float
    constexpr std::ptrdiff_t m_vecNoiseOffsetRate = 0xA8; // Vector
    constexpr std::ptrdiff_t m_flNoiseOffset = 0xB4; // float
    constexpr std::ptrdiff_t m_nNoiseOctaves = 0xB8; // int32_t
    constexpr std::ptrdiff_t m_nNoiseTurbulence = 0xBC; // PFNoiseTurbulence_t
    constexpr std::ptrdiff_t m_nNoiseType = 0xC0; // PFNoiseType_t
    constexpr std::ptrdiff_t m_nNoiseModifier = 0xC4; // PFNoiseModifier_t
    constexpr std::ptrdiff_t m_flNoiseTurbulenceScale = 0xC8; // float
    constexpr std::ptrdiff_t m_flNoiseTurbulenceMix = 0xCC; // float
    constexpr std::ptrdiff_t m_flNoiseImgPreviewScale = 0xD0; // float
    constexpr std::ptrdiff_t m_bNoiseImgPreviewLive = 0xD4; // bool
    constexpr std::ptrdiff_t m_flNoCameraFallback = 0xE0; // float
    constexpr std::ptrdiff_t m_bUseBoundsCenter = 0xE4; // bool
    constexpr std::ptrdiff_t m_nInputMode = 0xE8; // ParticleFloatInputMode_t
    constexpr std::ptrdiff_t m_flMultFactor = 0xEC; // float
    constexpr std::ptrdiff_t m_flInput0 = 0xF0; // float
    constexpr std::ptrdiff_t m_flInput1 = 0xF4; // float
    constexpr std::ptrdiff_t m_flOutput0 = 0xF8; // float
    constexpr std::ptrdiff_t m_flOutput1 = 0xFC; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMin = 0x100; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMax = 0x104; // float
    constexpr std::ptrdiff_t m_flNotchedOutputOutside = 0x108; // float
    constexpr std::ptrdiff_t m_flNotchedOutputInside = 0x10C; // float
    constexpr std::ptrdiff_t m_nBiasType = 0x110; // ParticleFloatBiasType_t
    constexpr std::ptrdiff_t m_flBiasParameter = 0x114; // float
    constexpr std::ptrdiff_t m_Curve = 0x118; // CPiecewiseCurve
}

namespace CParticleFunction {
    constexpr std::ptrdiff_t m_flOpStrength = 0x8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOpEndCapState = 0x160; // ParticleEndcapMode_t
    constexpr std::ptrdiff_t m_flOpStartFadeInTime = 0x164; // float
    constexpr std::ptrdiff_t m_flOpEndFadeInTime = 0x168; // float
    constexpr std::ptrdiff_t m_flOpStartFadeOutTime = 0x16C; // float
    constexpr std::ptrdiff_t m_flOpEndFadeOutTime = 0x170; // float
    constexpr std::ptrdiff_t m_flOpFadeOscillatePeriod = 0x174; // float
    constexpr std::ptrdiff_t m_bNormalizeToStopTime = 0x178; // bool
    constexpr std::ptrdiff_t m_flOpTimeOffsetMin = 0x17C; // float
    constexpr std::ptrdiff_t m_flOpTimeOffsetMax = 0x180; // float
    constexpr std::ptrdiff_t m_nOpTimeOffsetSeed = 0x184; // int32_t
    constexpr std::ptrdiff_t m_nOpTimeScaleSeed = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flOpTimeScaleMin = 0x18C; // float
    constexpr std::ptrdiff_t m_flOpTimeScaleMax = 0x190; // float
    constexpr std::ptrdiff_t m_bDisableOperator = 0x196; // bool
    constexpr std::ptrdiff_t m_Notes = 0x198; // CUtlString
}

namespace CParticleFunctionConstraint { // CParticleFunction
}

namespace CParticleFunctionEmitter { // CParticleFunction
    constexpr std::ptrdiff_t m_nEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionForce { // CParticleFunction
}

namespace CParticleFunctionInitializer { // CParticleFunction
    constexpr std::ptrdiff_t m_nAssociatedEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionOperator { // CParticleFunction
}

namespace CParticleFunctionPreEmission { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bRunOnce = 0x1C0; // bool
}

namespace CParticleFunctionRenderer { // CParticleFunction
    constexpr std::ptrdiff_t VisibilityInputs = 0x1B8; // CParticleVisibilityInputs
    constexpr std::ptrdiff_t m_bCannotBeRefracted = 0x1FC; // bool
    constexpr std::ptrdiff_t m_bSkipRenderingOnMobile = 0x1FD; // bool
}

namespace CParticleInput {
}

namespace CParticleModelInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleModelType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x58; // int32_t
}

namespace CParticleProperty {
}

namespace CParticleRemapFloatInput { // CParticleFloatInput
}

namespace CParticleSystemDefinition { // IParticleSystemDefinition
    constexpr std::ptrdiff_t m_nBehaviorVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_PreEmissionOperators = 0x10; // CUtlVector<CParticleFunctionPreEmission*>
    constexpr std::ptrdiff_t m_Emitters = 0x28; // CUtlVector<CParticleFunctionEmitter*>
    constexpr std::ptrdiff_t m_Initializers = 0x40; // CUtlVector<CParticleFunctionInitializer*>
    constexpr std::ptrdiff_t m_Operators = 0x58; // CUtlVector<CParticleFunctionOperator*>
    constexpr std::ptrdiff_t m_ForceGenerators = 0x70; // CUtlVector<CParticleFunctionForce*>
    constexpr std::ptrdiff_t m_Constraints = 0x88; // CUtlVector<CParticleFunctionConstraint*>
    constexpr std::ptrdiff_t m_Renderers = 0xA0; // CUtlVector<CParticleFunctionRenderer*>
    constexpr std::ptrdiff_t m_Children = 0xB8; // CUtlVector<ParticleChildrenInfo_t>
    constexpr std::ptrdiff_t m_nFirstMultipleOverride_BackwardCompat = 0x178; // int32_t
    constexpr std::ptrdiff_t m_nInitialParticles = 0x210; // int32_t
    constexpr std::ptrdiff_t m_nMaxParticles = 0x214; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x218; // int32_t
    constexpr std::ptrdiff_t m_BoundingBoxMin = 0x21C; // Vector
    constexpr std::ptrdiff_t m_BoundingBoxMax = 0x228; // Vector
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x234; // float
    constexpr std::ptrdiff_t m_nSortOverridePositionCP = 0x238; // int32_t
    constexpr std::ptrdiff_t m_bInfiniteBounds = 0x23C; // bool
    constexpr std::ptrdiff_t m_bEnableNamedValues = 0x23D; // bool
    constexpr std::ptrdiff_t m_NamedValueDomain = 0x240; // CUtlString
    constexpr std::ptrdiff_t m_NamedValueLocals = 0x248; // CUtlVector<ParticleNamedValueSource_t*>
    constexpr std::ptrdiff_t m_ConstantColor = 0x260; // Color
    constexpr std::ptrdiff_t m_ConstantNormal = 0x264; // Vector
    constexpr std::ptrdiff_t m_flConstantRadius = 0x270; // float
    constexpr std::ptrdiff_t m_flConstantRotation = 0x274; // float
    constexpr std::ptrdiff_t m_flConstantRotationSpeed = 0x278; // float
    constexpr std::ptrdiff_t m_flConstantLifespan = 0x27C; // float
    constexpr std::ptrdiff_t m_nConstantSequenceNumber = 0x280; // int32_t
    constexpr std::ptrdiff_t m_nConstantSequenceNumber1 = 0x284; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x288; // int32_t
    constexpr std::ptrdiff_t m_hSnapshot = 0x290; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_pszCullReplacementName = 0x298; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flCullRadius = 0x2A0; // float
    constexpr std::ptrdiff_t m_flCullFillCost = 0x2A4; // float
    constexpr std::ptrdiff_t m_nCullControlPoint = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_hFallback = 0x2B0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nFallbackMaxCount = 0x2B8; // int32_t
    constexpr std::ptrdiff_t m_hLowViolenceDef = 0x2C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_hReferenceReplacement = 0x2C8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flPreSimulationTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_flStopSimulationAfterTime = 0x2D4; // float
    constexpr std::ptrdiff_t m_flMaximumTimeStep = 0x2D8; // float
    constexpr std::ptrdiff_t m_flMaximumSimTime = 0x2DC; // float
    constexpr std::ptrdiff_t m_flMinimumSimTime = 0x2E0; // float
    constexpr std::ptrdiff_t m_flMinimumTimeStep = 0x2E4; // float
    constexpr std::ptrdiff_t m_nMinimumFrames = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_nMinCPULevel = 0x2EC; // int32_t
    constexpr std::ptrdiff_t m_nMinGPULevel = 0x2F0; // int32_t
    constexpr std::ptrdiff_t m_flNoDrawTimeToGoToSleep = 0x2F4; // float
    constexpr std::ptrdiff_t m_flMaxDrawDistance = 0x2F8; // float
    constexpr std::ptrdiff_t m_flStartFadeDistance = 0x2FC; // float
    constexpr std::ptrdiff_t m_flMaxCreationDistance = 0x300; // float
    constexpr std::ptrdiff_t m_nAggregationMinAvailableParticles = 0x304; // int32_t
    constexpr std::ptrdiff_t m_flAggregateRadius = 0x308; // float
    constexpr std::ptrdiff_t m_bShouldBatch = 0x30C; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToRenderBounds = 0x30D; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToSnapshot = 0x30E; // bool
    constexpr std::ptrdiff_t m_nViewModelEffect = 0x310; // InheritableBoolType_t
    constexpr std::ptrdiff_t m_bScreenSpaceEffect = 0x314; // bool
    constexpr std::ptrdiff_t m_pszTargetLayerID = 0x318; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSkipRenderControlPoint = 0x320; // int32_t
    constexpr std::ptrdiff_t m_nAllowRenderControlPoint = 0x324; // int32_t
    constexpr std::ptrdiff_t m_bShouldSort = 0x328; // bool
    constexpr std::ptrdiff_t m_controlPointConfigurations = 0x370; // CUtlVector<ParticleControlPointConfiguration_t>
}

namespace CParticleTransformInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleTransformType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bSupportsDisabled = 0x59; // bool
    constexpr std::ptrdiff_t m_bUseOrientation = 0x5A; // bool
    constexpr std::ptrdiff_t m_nControlPoint = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nControlPointRangeMax = 0x60; // int32_t
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0x64; // float
}

namespace CParticleVariableRef {
    constexpr std::ptrdiff_t m_variableName = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_variableType = 0x38; // PulseValueType_t
}

namespace CParticleVecInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleVecType_t
    constexpr std::ptrdiff_t m_vLiteralValue = 0x14; // Vector
    constexpr std::ptrdiff_t m_LiteralColor = 0x20; // Color
    constexpr std::ptrdiff_t m_NamedValue = 0x28; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x68; // bool
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x6C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vVectorAttributeScale = 0x70; // Vector
    constexpr std::ptrdiff_t m_nControlPoint = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nDeltaControlPoint = 0x80; // int32_t
    constexpr std::ptrdiff_t m_vCPValueScale = 0x84; // Vector
    constexpr std::ptrdiff_t m_vCPRelativePosition = 0x90; // Vector
    constexpr std::ptrdiff_t m_vCPRelativeDir = 0x9C; // Vector
    constexpr std::ptrdiff_t m_FloatComponentX = 0xA8; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentY = 0x200; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentZ = 0x358; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatInterp = 0x4B0; // CParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpInput0 = 0x608; // float
    constexpr std::ptrdiff_t m_flInterpInput1 = 0x60C; // float
    constexpr std::ptrdiff_t m_vInterpOutput0 = 0x610; // Vector
    constexpr std::ptrdiff_t m_vInterpOutput1 = 0x61C; // Vector
    constexpr std::ptrdiff_t m_Gradient = 0x628; // CColorGradient
    constexpr std::ptrdiff_t m_vRandomMin = 0x640; // Vector
    constexpr std::ptrdiff_t m_vRandomMax = 0x64C; // Vector
}

namespace CParticleVisibilityInputs {
    constexpr std::ptrdiff_t m_flCameraBias = 0x0; // float
    constexpr std::ptrdiff_t m_nCPin = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0x8; // float
    constexpr std::ptrdiff_t m_flInputMin = 0xC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x10; // float
    constexpr std::ptrdiff_t m_flNoPixelVisibilityFallback = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceInputMin = 0x18; // float
    constexpr std::ptrdiff_t m_flDistanceInputMax = 0x1C; // float
    constexpr std::ptrdiff_t m_flDotInputMin = 0x20; // float
    constexpr std::ptrdiff_t m_flDotInputMax = 0x24; // float
    constexpr std::ptrdiff_t m_bDotCPAngles = 0x28; // bool
    constexpr std::ptrdiff_t m_bDotCameraAngles = 0x29; // bool
    constexpr std::ptrdiff_t m_flAlphaScaleMin = 0x2C; // float
    constexpr std::ptrdiff_t m_flAlphaScaleMax = 0x30; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMin = 0x34; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMax = 0x38; // float
    constexpr std::ptrdiff_t m_flRadiusScaleFOVBase = 0x3C; // float
    constexpr std::ptrdiff_t m_bRightEye = 0x40; // bool
}

namespace CPathParameters {
    constexpr std::ptrdiff_t m_nStartControlPointNumber = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nBulgeControl = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flBulge = 0xC; // float
    constexpr std::ptrdiff_t m_flMidPoint = 0x10; // float
    constexpr std::ptrdiff_t m_vStartPointOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_vMidPointOffset = 0x20; // Vector
    constexpr std::ptrdiff_t m_vEndOffset = 0x2C; // Vector
}

namespace CPerParticleFloatInput { // CParticleFloatInput
}

namespace CPerParticleVecInput { // CParticleVecInput
}

namespace CRandomNumberGeneratorParameters {
    constexpr std::ptrdiff_t m_bDistributeEvenly = 0x0; // bool
    constexpr std::ptrdiff_t m_nSeed = 0x4; // int32_t
}

namespace CSpinUpdateBase { // CParticleFunctionOperator
}

namespace C_INIT_AddVectorToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vOffsetMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vOffsetMax = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1EC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_AgeNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C1; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C4; // float
    constexpr std::ptrdiff_t m_flAgeMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flAgeMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D4; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // Vector
}

namespace C_INIT_ChaoticAttractor { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flAParm = 0x1C0; // float
    constexpr std::ptrdiff_t m_flBParm = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCParm = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDParm = 0x1CC; // float
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSpeedMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nBaseCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bUniformSpeed = 0x1E0; // bool
}

namespace C_INIT_ColorLitPerParticle { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ColorMin = 0x1D8; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E4; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1E8; // float
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1EC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x1F0; // float
}

namespace C_INIT_CreateAlongPath { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_bUseRandomCPs = 0x210; // bool
    constexpr std::ptrdiff_t m_vEndOffset = 0x214; // Vector
    constexpr std::ptrdiff_t m_bSaveOffset = 0x220; // bool
}

namespace C_INIT_CreateFromCPs { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nIncrement = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMinCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMaxCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDynamicCPCount = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateFromParentParticles { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1C4; // float
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSubFrame = 0x1D0; // bool
}

namespace C_INIT_CreateFromPlaneCache { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecOffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecOffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseNormal = 0x1D9; // bool
}

namespace C_INIT_CreateInEpitrochoid { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nComponent1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nComponent2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticleDensity = 0x230; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x388; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius1 = 0x4E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius2 = 0x638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseCount = 0x790; // bool
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x791; // bool
    constexpr std::ptrdiff_t m_bOffsetExistingPos = 0x792; // bool
}

namespace C_INIT_CreateOnGrid { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nXCount = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYCount = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZCount = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nXSpacing = 0x5C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYSpacing = 0x720; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZSpacing = 0x878; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x9D0; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D4; // bool
    constexpr std::ptrdiff_t m_bCenter = 0x9D5; // bool
    constexpr std::ptrdiff_t m_bHollow = 0x9D6; // bool
}

namespace C_INIT_CreateOnModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nForceInModel = 0x288; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x28C; // int32_t
    constexpr std::ptrdiff_t m_nHitboxValueFromControlPointIndex = 0x290; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x298; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x8F0; // float
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x8F4; // float
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x8F8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xF50; // char[128]
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0xFD1; // bool
    constexpr std::ptrdiff_t m_flShellSize = 0xFD8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateOnModelAtHeight { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bUseBones = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForceZ = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nHeightCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseWaterHeight = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flDesiredHeight = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x328; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x980; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nBiasType = 0xFD8; // ParticleHitboxBiasType_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFDC; // bool
    constexpr std::ptrdiff_t m_bPreferMovingBoxes = 0xFDD; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0xFDE; // char[128]
    constexpr std::ptrdiff_t m_flHitboxVelocityScale = 0x1060; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x11B8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateParticleImpulse { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputRadius = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_InputMagnitude = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFalloffFunction = 0x470; // ParticleFalloffFunction_t
    constexpr std::ptrdiff_t m_InputFalloffExp = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nImpulseType = 0x5D0; // ParticleImpulseType_t
}

namespace C_INIT_CreatePhyllotaxis { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_fRadCentCore = 0x1CC; // float
    constexpr std::ptrdiff_t m_fRadPerPoint = 0x1D0; // float
    constexpr std::ptrdiff_t m_fRadPerPointTo = 0x1D4; // float
    constexpr std::ptrdiff_t m_fpointAngle = 0x1D8; // float
    constexpr std::ptrdiff_t m_fsizeOverall = 0x1DC; // float
    constexpr std::ptrdiff_t m_fRadBias = 0x1E0; // float
    constexpr std::ptrdiff_t m_fMinRad = 0x1E4; // float
    constexpr std::ptrdiff_t m_fDistBias = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x1EC; // bool
    constexpr std::ptrdiff_t m_bUseWithContEmit = 0x1ED; // bool
    constexpr std::ptrdiff_t m_bUseOrigRadius = 0x1EE; // bool
}

namespace C_INIT_CreateSequentialPath { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C9; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x1CA; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_INIT_CreateSequentialPathV2 { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNumToAssign = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLoop = 0x470; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x471; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x472; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x480; // CPathParameters
}

namespace C_INIT_CreateSpiralSphere { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDensity = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInitialRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D8; // bool
}

namespace C_INIT_CreateWithinBox { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xE78; // CRandomNumberGeneratorParameters
}

namespace C_INIT_CreateWithinSphereTransform { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fRadiusMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fRadiusMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecDistanceBias = 0x470; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecDistanceBiasAbs = 0xAC8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0xAD8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fSpeedMin = 0xB40; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0xC98; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedRandExp = 0xDF0; // float
    constexpr std::ptrdiff_t m_bLocalCoords = 0xDF4; // bool
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0xDF8; // float
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0xE00; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0x1458; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1AB0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldVelocity = 0x1AB4; // ParticleAttributeIndex_t
}

namespace C_INIT_CreationNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C5; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D8; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1E8; // float
}

namespace C_INIT_DistanceCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_DistanceToCPInit { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nStartCP = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bLOS = 0x72C; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x72D; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x7B0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7B8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLOSScale = 0x910; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x914; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x918; // bool
    constexpr std::ptrdiff_t m_vecDistanceScale = 0x91C; // Vector
    constexpr std::ptrdiff_t m_flRemapBias = 0x928; // float
}

namespace C_INIT_DistanceToNeighborCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flDistance = 0x1C0; // CPerParticleFloatInput
}

namespace C_INIT_GlobalScale { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bScaleRadius = 0x1CC; // bool
    constexpr std::ptrdiff_t m_bScalePosition = 0x1CD; // bool
    constexpr std::ptrdiff_t m_bScaleVelocity = 0x1CE; // bool
}

namespace C_INIT_InheritFromParentParticles { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D0; // int32_t
}

namespace C_INIT_InheritVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C4; // float
}

namespace C_INIT_InitFloat { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_InputStrength = 0x320; // CPerParticleFloatInput
}

namespace C_INIT_InitFloatCollection { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromCPSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nManualSnapshotIndex = 0x330; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nRandomSeed = 0x488; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpaceAngles = 0x48C; // bool
}

namespace C_INIT_InitFromParentKilled { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nAttributeToCopy = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromVectorFieldSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nWeightUpdateCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseVerticalVelocity = 0x1CC; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x1D0; // CPerParticleVecInput
}

namespace C_INIT_InitSkinnedPositionFromCPSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRigid = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1D2; // bool
    constexpr std::ptrdiff_t m_flMinNormalVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_flMaxNormalVelocity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1DC; // float
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x1E8; // float
    constexpr std::ptrdiff_t m_flBoneVelocityMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bCopyColor = 0x1F0; // bool
    constexpr std::ptrdiff_t m_bCopyAlpha = 0x1F1; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1F2; // bool
}

namespace C_INIT_InitVec { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x820; // bool
    constexpr std::ptrdiff_t m_bWritePreviousPosition = 0x821; // bool
}

namespace C_INIT_InitVecCollection { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
}

namespace C_INIT_InitialRepulsionVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x240; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x244; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x250; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x260; // bool
    constexpr std::ptrdiff_t m_bTranslate = 0x261; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x262; // bool
    constexpr std::ptrdiff_t m_flTraceLength = 0x264; // float
    constexpr std::ptrdiff_t m_bPerParticleTR = 0x268; // bool
    constexpr std::ptrdiff_t m_bInherit = 0x269; // bool
    constexpr std::ptrdiff_t m_nChildCP = 0x26C; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x270; // int32_t
}

namespace C_INIT_InitialSequenceFromModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_INIT_InitialVelocityFromHitbox { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flVelocityMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flVelocityMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1CC; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x24C; // bool
}

namespace C_INIT_InitialVelocityNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecAbsVal = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecAbsValInv = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOffset = 0x830; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecOutputMin = 0x988; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0xFE0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1790; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x18E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1950; // bool
}

namespace C_INIT_LifespanFromVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1D0; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x1D4; // float
    constexpr std::ptrdiff_t m_nMaxPlanes = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1E0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x260; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x270; // bool
}

namespace C_INIT_ModelCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_INIT_MoveBetweenPoints { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSpeedMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndSpread = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndOffset = 0x720; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x878; // int32_t
    constexpr std::ptrdiff_t m_bTrailBias = 0x87C; // bool
}

namespace C_INIT_NormalAlignToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_transformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nControlPointAxis = 0x228; // ParticleControlPointAxis_t
}

namespace C_INIT_NormalOffset { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_OffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bNormalize = 0x1DD; // bool
}

namespace C_INIT_OffsetVectorToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1E0; // CRandomNumberGeneratorParameters
}

namespace C_INIT_Orient2DRelToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C8; // float
}

namespace C_INIT_PlaneCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_PointList { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_INIT_PositionOffset { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_OffsetMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_TransformInput = 0xE70; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalCoords = 0xED8; // bool
    constexpr std::ptrdiff_t m_bProportional = 0xED9; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xEDC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_PositionOffsetToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumberStart = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumberEnd = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1C8; // bool
}

namespace C_INIT_PositionPlaceOnGround { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x470; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x4F0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x500; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x504; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x505; // bool
    constexpr std::ptrdiff_t m_bSetPXYZOnly = 0x506; // bool
    constexpr std::ptrdiff_t m_bTraceAlongNormal = 0x507; // bool
    constexpr std::ptrdiff_t m_bOffsetonColOnly = 0x508; // bool
    constexpr std::ptrdiff_t m_flOffsetByRadiusFactor = 0x50C; // float
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x510; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x514; // int32_t
}

namespace C_INIT_PositionWarp { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecWarpMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nRadiusComponent = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flWarpTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flWarpStartTime = 0xE80; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0xE84; // float
    constexpr std::ptrdiff_t m_bInvertWarp = 0xE88; // bool
    constexpr std::ptrdiff_t m_bUseCount = 0xE89; // bool
}

namespace C_INIT_PositionWarpScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecWarpMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_InputValue = 0x1D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x330; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x334; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x338; // int32_t
}

namespace C_INIT_QuantizeFloat { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_RadiusFromCPObject { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
}

namespace C_INIT_RandomAlpha { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nAlphaMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flAlphaRandExponent = 0x1D4; // float
}

namespace C_INIT_RandomAlphaWindowThreshold { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
}

namespace C_INIT_RandomColor { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ColorMin = 0x1DC; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E4; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E8; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1EC; // float
    constexpr std::ptrdiff_t m_flUpdateThreshold = 0x1F0; // float
    constexpr std::ptrdiff_t m_nTintCP = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1FC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x200; // float
}

namespace C_INIT_RandomLifeTime { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fLifetimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fLifetimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_fLifetimeRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomModelSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ActivityName = 0x1C0; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x2C0; // char[256]
    constexpr std::ptrdiff_t m_hModel = 0x3C0; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace C_INIT_RandomNamedModelBodyPart { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomNamedModelElement { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bShuffle = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x1E2; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E4; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomNamedModelMeshGroup { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomNamedModelSequence { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomRadius { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flRadiusMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flRadiusMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomRotation { // CGeneralRandomRotation
}

namespace C_INIT_RandomRotationSpeed { // CGeneralRandomRotation
}

namespace C_INIT_RandomScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomSecondSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
}

namespace C_INIT_RandomSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bShuffle = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1C9; // bool
    constexpr std::ptrdiff_t m_WeightedList = 0x1D0; // CUtlVector<SequenceWeightedList_t>
}

namespace C_INIT_RandomTrailLength { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMinLength = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLengthRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1DC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_RandomVectorComponent { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_INIT_RandomYaw { // CGeneralRandomRotation
}

namespace C_INIT_RandomYawFlip { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flPercent = 0x1C0; // float
}

namespace C_INIT_RemapCPtoScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapInitialDirectionToTransformToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x22C; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x230; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x234; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x240; // bool
}

namespace C_INIT_RemapInitialTransformDirectionToRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x22C; // float
    constexpr std::ptrdiff_t m_nComponent = 0x230; // int32_t
}

namespace C_INIT_RemapInitialVisibilityScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_INIT_RemapNamedModelBodyPartToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapNamedModelElementToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_values = 0x1E0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFieldInput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1FC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x200; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x204; // bool
}

namespace C_INIT_RemapNamedModelMeshGroupToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapNamedModelSequenceToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapParticleCountToNamedModelBodyPartScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToNamedModelElementScalar { // C_INIT_RemapParticleCountToScalar
    constexpr std::ptrdiff_t m_hModel = 0x1F0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_outputMinName = 0x1F8; // CUtlString
    constexpr std::ptrdiff_t m_outputMaxName = 0x200; // CUtlString
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x208; // bool
}

namespace C_INIT_RemapParticleCountToNamedModelMeshGroupScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToNamedModelSequenceScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bInvert = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bWrap = 0x1E2; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E4; // float
}

namespace C_INIT_RemapQAnglesToRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_INIT_RemapScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1D8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapScalarToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1E8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1F0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1F8; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1FC; // float
}

namespace C_INIT_RemapSpeedToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flStartTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x1E4; // bool
}

namespace C_INIT_RemapTransformOrientationToRotations { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_INIT_RemapTransformToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0x1F8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_LocalSpaceTransform = 0x260; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime = 0x2C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x2CC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x2D0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x2D4; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x2D5; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x2D8; // float
}

namespace C_INIT_RingWave { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticlesPerOrbit = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitialRadius = 0x380; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0x4D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x630; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x788; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRoll = 0x8E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPitch = 0xA38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flYaw = 0xB90; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bEvenDistribution = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bXYVelocityOnly = 0xCE9; // bool
}

namespace C_INIT_RtEnvCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseVelocity = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D9; // bool
    constexpr std::ptrdiff_t m_bLifeAdjust = 0x1DA; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DB; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_INIT_ScaleVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // CParticleCollectionVecInput
}

namespace C_INIT_SequenceFromCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bKillUnused = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // Vector
}

namespace C_INIT_SequenceLifeTime { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flFramerate = 0x1C0; // float
}

namespace C_INIT_SetHitboxToClosest { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0x820; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x8A0; // bool
    constexpr std::ptrdiff_t m_bUseClosestPointOnHitbox = 0x8A1; // bool
    constexpr std::ptrdiff_t m_nTestType = 0x8A4; // ClosestPointTestType_t
    constexpr std::ptrdiff_t m_flHybridRatio = 0x8A8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bUpdatePosition = 0xA00; // bool
}

namespace C_INIT_SetHitboxToModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nForceInModel = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x828; // Vector
    constexpr std::ptrdiff_t m_bMaintainHitbox = 0x834; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x835; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x836; // char[128]
    constexpr std::ptrdiff_t m_flShellSize = 0x8B8; // CParticleCollectionFloatInput
}

namespace C_INIT_SetRigidAttachment { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1CC; // bool
}

namespace C_INIT_SetVectorAttributeToVectorExpression { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_INIT_StatusEffect { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nDetail2Combo = 0x1C0; // Detail2Combo_t
    constexpr std::ptrdiff_t m_flDetail2Rotation = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDetail2Scale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDetail2BlendFactor = 0x1CC; // float
    constexpr std::ptrdiff_t m_flColorWarpIntensity = 0x1D0; // float
    constexpr std::ptrdiff_t m_flDiffuseWarpBlendToFull = 0x1D4; // float
    constexpr std::ptrdiff_t m_flEnvMapIntensity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flAmbientScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_specularColor = 0x1E0; // Color
    constexpr std::ptrdiff_t m_flSpecularScale = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSpecularExponent = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSpecularExponentBlendToFull = 0x1EC; // float
    constexpr std::ptrdiff_t m_flSpecularBlendToFull = 0x1F0; // float
    constexpr std::ptrdiff_t m_rimLightColor = 0x1F4; // Color
    constexpr std::ptrdiff_t m_flRimLightScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flReflectionsTintByBaseBlendToNone = 0x1FC; // float
    constexpr std::ptrdiff_t m_flMetalnessBlendToFull = 0x200; // float
    constexpr std::ptrdiff_t m_flSelfIllumBlendToFull = 0x204; // float
}

namespace C_INIT_StatusEffectCitadel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flSFXColorWarpAmount = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSFXNormalAmount = 0x1C4; // float
    constexpr std::ptrdiff_t m_flSFXMetalnessAmount = 0x1C8; // float
    constexpr std::ptrdiff_t m_flSFXRoughnessAmount = 0x1CC; // float
    constexpr std::ptrdiff_t m_flSFXSelfIllumAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSFXSScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSFXSScrollX = 0x1D8; // float
    constexpr std::ptrdiff_t m_flSFXSScrollY = 0x1DC; // float
    constexpr std::ptrdiff_t m_flSFXSScrollZ = 0x1E0; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetX = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetY = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetZ = 0x1EC; // float
    constexpr std::ptrdiff_t m_nDetailCombo = 0x1F0; // DetailCombo_t
    constexpr std::ptrdiff_t m_flSFXSDetailAmount = 0x1F4; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollX = 0x1FC; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollY = 0x200; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollZ = 0x204; // float
    constexpr std::ptrdiff_t m_flSFXSUseModelUVs = 0x208; // float
}

namespace C_INIT_VelocityFromCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_velocityInput = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x818; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flVelocityScale = 0x880; // float
    constexpr std::ptrdiff_t m_bDirectionOnly = 0x884; // bool
}

namespace C_INIT_VelocityFromNormal { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1C8; // bool
}

namespace C_INIT_VelocityRadialRandom { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecLocalCoordinateSystemSpeedScale = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D9; // bool
}

namespace C_INIT_VelocityRandom { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0x478; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0xAD0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1128; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0x112C; // CRandomNumberGeneratorParameters
}

namespace C_OP_AlphaDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinAlpha = 0x1C0; // float
}

namespace C_OP_AttractToControlPoint { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fForceAmount = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fFalloffPower = 0x338; // float
    constexpr std::ptrdiff_t m_TransformInput = 0x340; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fForceAmountMin = 0x3A8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bApplyMinForce = 0x500; // bool
}

namespace C_OP_BasicMovement { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_BoxConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nCP = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_bAccountForRadius = 0xE75; // bool
}

namespace C_OP_CPOffsetToPercentageBetweenCPs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInputMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputBias = 0x1C8; // float
    constexpr std::ptrdiff_t m_nStartCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOffsetCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOuputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nInputCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bRadialCheck = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_vecOffset = 0x1E4; // Vector
}

namespace C_OP_CPVelocityForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CPerParticleFloatInput
}

namespace C_OP_CalculateVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vStartValue = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldInput1 = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale1 = 0x1D0; // float
    constexpr std::ptrdiff_t m_nFieldInput2 = 0x1D4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_nControlPointInput1 = 0x1DC; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale1 = 0x1F0; // float
    constexpr std::ptrdiff_t m_nControlPointInput2 = 0x1F4; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale2 = 0x208; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vFinalOutputScale = 0x210; // Vector
}

namespace C_OP_Callback { // CParticleFunctionRenderer
}

namespace C_OP_ChladniWave { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecWaveLength = 0x728; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecHarmonics = 0xD80; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nLocalSpaceControlPoint = 0x13DC; // int32_t
    constexpr std::ptrdiff_t m_b3D = 0x13E0; // bool
}

namespace C_OP_ChooseRandomChildrenInGroup { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flNumberOfChildren = 0x1D8; // CParticleCollectionFloatInput
}

namespace C_OP_ClampScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x320; // CPerParticleFloatInput
}

namespace C_OP_ClampVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0x820; // CPerParticleVecInput
}

namespace C_OP_CollideWithParentParticles { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flParentRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusScale = 0x318; // CPerParticleFloatInput
}

namespace C_OP_CollideWithSelf { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinimumSpeed = 0x318; // CPerParticleFloatInput
}

namespace C_OP_ColorAdjustHSL { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flHueAdjust = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSaturationAdjust = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLightnessAdjust = 0x470; // CPerParticleFloatInput
}

namespace C_OP_ColorInterpolate { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_ColorFade = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bUseNewCode = 0x1DD; // bool
}

namespace C_OP_ColorInterpolateRandom { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_ColorFadeMin = 0x1C0; // Color
    constexpr std::ptrdiff_t m_ColorFadeMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1F0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1F8; // bool
}

namespace C_OP_ConnectParentParticleToNearest { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSecondControlPoint = 0x1C4; // int32_t
}

namespace C_OP_ConstrainDistance { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_fMaxDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x470; // int32_t
    constexpr std::ptrdiff_t m_CenterOffset = 0x474; // Vector
    constexpr std::ptrdiff_t m_bGlobalCenter = 0x480; // bool
}

namespace C_OP_ConstrainDistanceToPath { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance0 = 0x1C4; // float
    constexpr std::ptrdiff_t m_flMaxDistanceMid = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxDistance1 = 0x1CC; // float
    constexpr std::ptrdiff_t m_PathParameters = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_flTravelTime = 0x210; // float
    constexpr std::ptrdiff_t m_nFieldScale = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualTField = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_ConstrainDistanceToUserSpecifiedPath { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bLoopedPath = 0x1CC; // bool
    constexpr std::ptrdiff_t m_pointList = 0x1D0; // CUtlVector<PointDefinitionWithTimeValues_t>
}

namespace C_OP_ConstrainLineLength { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
}

namespace C_OP_ContinuousEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmitRate = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flScalePerParentParticle = 0x5CC; // float
    constexpr std::ptrdiff_t m_bInitFromKilledParentParticles = 0x5D0; // bool
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
    constexpr std::ptrdiff_t m_nLimitPerUpdate = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_bForceEmitOnFirstUpdate = 0x5DC; // bool
    constexpr std::ptrdiff_t m_bForceEmitOnLastUpdate = 0x5DD; // bool
}

namespace C_OP_ControlPointToRadialScreenSpace { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPIn = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nCPOut = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutField = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_nCPSSPosOut = 0x1E8; // int32_t
}

namespace C_OP_ControlpointLight { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nControlPoint1 = 0x650; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint2 = 0x654; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint3 = 0x658; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint4 = 0x65C; // int32_t
    constexpr std::ptrdiff_t m_vecCPOffset1 = 0x660; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset2 = 0x66C; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset3 = 0x678; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset4 = 0x684; // Vector
    constexpr std::ptrdiff_t m_LightFiftyDist1 = 0x690; // float
    constexpr std::ptrdiff_t m_LightZeroDist1 = 0x694; // float
    constexpr std::ptrdiff_t m_LightFiftyDist2 = 0x698; // float
    constexpr std::ptrdiff_t m_LightZeroDist2 = 0x69C; // float
    constexpr std::ptrdiff_t m_LightFiftyDist3 = 0x6A0; // float
    constexpr std::ptrdiff_t m_LightZeroDist3 = 0x6A4; // float
    constexpr std::ptrdiff_t m_LightFiftyDist4 = 0x6A8; // float
    constexpr std::ptrdiff_t m_LightZeroDist4 = 0x6AC; // float
    constexpr std::ptrdiff_t m_LightColor1 = 0x6B0; // Color
    constexpr std::ptrdiff_t m_LightColor2 = 0x6B4; // Color
    constexpr std::ptrdiff_t m_LightColor3 = 0x6B8; // Color
    constexpr std::ptrdiff_t m_LightColor4 = 0x6BC; // Color
    constexpr std::ptrdiff_t m_bLightType1 = 0x6C0; // bool
    constexpr std::ptrdiff_t m_bLightType2 = 0x6C1; // bool
    constexpr std::ptrdiff_t m_bLightType3 = 0x6C2; // bool
    constexpr std::ptrdiff_t m_bLightType4 = 0x6C3; // bool
    constexpr std::ptrdiff_t m_bLightDynamic1 = 0x6C4; // bool
    constexpr std::ptrdiff_t m_bLightDynamic2 = 0x6C5; // bool
    constexpr std::ptrdiff_t m_bLightDynamic3 = 0x6C6; // bool
    constexpr std::ptrdiff_t m_bLightDynamic4 = 0x6C7; // bool
    constexpr std::ptrdiff_t m_bUseNormal = 0x6C8; // bool
    constexpr std::ptrdiff_t m_bUseHLambert = 0x6C9; // bool
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x6CE; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x6CF; // bool
}

namespace C_OP_Cull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flCullPerc = 0x1C0; // float
    constexpr std::ptrdiff_t m_flCullStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCullEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCullExp = 0x1CC; // float
}

namespace C_OP_CurlNoiseForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nNoiseType = 0x1D0; // ParticleDirectionNoiseType_t
    constexpr std::ptrdiff_t m_vecNoiseFreq = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecNoiseScale = 0x830; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffset = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffsetRate = 0x14E0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flWorleySeed = 0x1B38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flWorleyJitter = 0x1C90; // CPerParticleFloatInput
}

namespace C_OP_CycleScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nDestField = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStartValue = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCycleTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_bDoNotRepeatCycle = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSynchronizeParticles = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCPScale = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMin = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMax = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
}

namespace C_OP_CylindricalDistanceToTransform { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x790; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x7F8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x7FC; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x7FD; // bool
    constexpr std::ptrdiff_t m_bCapsule = 0x7FE; // bool
}

namespace C_OP_DampenToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flRange = 0x1C4; // float
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
}

namespace C_OP_Decay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bRopeDecay = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1C1; // bool
}

namespace C_OP_DecayClampCount { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCount = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DecayMaintainCount { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDecayDelay = 0x1C4; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bLifespanDecay = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bKillNewest = 0x328; // bool
}

namespace C_OP_DecayOffscreen { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flOffscreenTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DensityForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flForceScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flTargetDensity = 0x1D8; // float
}

namespace C_OP_DifferencePreviousParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bSetPreviousParticle = 0x1DD; // bool
}

namespace C_OP_Diffusion { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1C8; // int32_t
}

namespace C_OP_DirectionBetweenVecsToVec { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
}

namespace C_OP_DistanceBetweenCPsToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nStartCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputCPField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOnce = 0x1E0; // bool
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1F4; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_bLOS = 0x1FC; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1FD; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x280; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nSetParent = 0x284; // ParticleParentSetMode_t
}

namespace C_OP_DistanceBetweenTransforms { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_TransformStart = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x230; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flInputMin = 0x298; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x3F0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x548; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x6A0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7F8; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x7FC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x800; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x880; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bLOS = 0x884; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x888; // ParticleSetMethod_t
}

namespace C_OP_DistanceBetweenVecs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flInputMin = 0xE78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0xFD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x1128; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x1280; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bDeltaTime = 0x13DC; // bool
}

namespace C_OP_DistanceCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPointOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0x1D0; // float
    constexpr std::ptrdiff_t m_bCullInside = 0x1D4; // bool
}

namespace C_OP_DistanceToTransform { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLOS = 0x790; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x791; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x814; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x818; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x81C; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x820; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x824; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x825; // bool
    constexpr std::ptrdiff_t m_vecComponentScale = 0x828; // CPerParticleVecInput
}

namespace C_OP_DragRelativeToPlane { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDragAtPlane = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFalloff = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDirectional = 0x470; // bool
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x478; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xAD0; // int32_t
}

namespace C_OP_DriveCPFromGlobalSoundFloat { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_StackName = 0x1E8; // CUtlString
    constexpr std::ptrdiff_t m_OperatorName = 0x1F0; // CUtlString
    constexpr std::ptrdiff_t m_FieldName = 0x1F8; // CUtlString
}

namespace C_OP_EnableChildrenFromParentParticleCount { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nFirstChild = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDisableChildren = 0x330; // bool
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x331; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x332; // bool
}

namespace C_OP_EndCapDecay { // CParticleFunctionOperator
}

namespace C_OP_EndCapTimedDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDecayTime = 0x1C0; // float
}

namespace C_OP_EndCapTimedFreeze { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFreezeTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_ExternalGameImpulseForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bRopes = 0x328; // bool
    constexpr std::ptrdiff_t m_bRopesZOnly = 0x329; // bool
    constexpr std::ptrdiff_t m_bExplosions = 0x32A; // bool
    constexpr std::ptrdiff_t m_bParticles = 0x32B; // bool
}

namespace C_OP_ExternalWindForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vecSamplePosition = 0x1D0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecScale = 0x828; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bSampleWind = 0xE80; // bool
    constexpr std::ptrdiff_t m_bSampleWater = 0xE81; // bool
    constexpr std::ptrdiff_t m_bDampenNearWaterPlane = 0xE82; // bool
    constexpr std::ptrdiff_t m_bSampleGravity = 0xE83; // bool
    constexpr std::ptrdiff_t m_vecGravityForce = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bUseBasicMovementGravity = 0x14E0; // bool
    constexpr std::ptrdiff_t m_flLocalGravityScale = 0x14E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLocalBuoyancyScale = 0x1640; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecBuoyancyForce = 0x1798; // CPerParticleVecInput
}

namespace C_OP_FadeAndKill { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1D8; // bool
}

namespace C_OP_FadeAndKillForTracers { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
}

namespace C_OP_FadeIn { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeInTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeInTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeInTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_bProportional = 0x1CC; // bool
}

namespace C_OP_FadeInSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_FadeOut { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeOutTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_flFadeBias = 0x1CC; // float
    constexpr std::ptrdiff_t m_bProportional = 0x200; // bool
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x201; // bool
}

namespace C_OP_FadeOutSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_ForceBasedOnDistanceToPlane { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flMinDist = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecForceAtMinDist = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flMaxDist = 0x1E0; // float
    constexpr std::ptrdiff_t m_vecForceAtMaxDist = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_flExponent = 0x200; // float
}

namespace C_OP_ForceControlPointStub { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_ControlPoint = 0x1D0; // int32_t
}

namespace C_OP_GlobalLight { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x1C5; // bool
}

namespace C_OP_HSVShiftToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nColorCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nColorGemEnableCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_DefaultHSVColor = 0x1DC; // Color
}

namespace C_OP_InheritFromParentParticles { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
}

namespace C_OP_InheritFromParentParticlesV2 { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nMissingParentBehavior = 0x1D0; // MissingParentInheritBehavior_t
}

namespace C_OP_InheritFromPeerSystem { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x1CC; // int32_t
}

namespace C_OP_InstantaneousEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_nParticlesToEmit = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitFromKilledParentParticles = 0x470; // float
    constexpr std::ptrdiff_t m_flParentParticleScale = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxEmittedPerFrame = 0x5D0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
}

namespace C_OP_InterpolateRadius { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flBias = 0x1D4; // float
}

namespace C_OP_LagCompensation { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nDesiredVelocityCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDesiredVelocityCPField = 0x1CC; // int32_t
}

namespace C_OP_LerpEndCapScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLerpTime = 0x1C8; // float
}

namespace C_OP_LerpEndCapVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flLerpTime = 0x1D0; // float
}

namespace C_OP_LerpScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x320; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x324; // float
}

namespace C_OP_LerpToInitialPosition { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nCacheField = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x480; // CParticleCollectionVecInput
}

namespace C_OP_LerpToOtherAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFieldInputFrom = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x320; // ParticleAttributeIndex_t
}

namespace C_OP_LerpVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_LightningSnapshotGenerator { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPSnapshot = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPStartPnt = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPEndPnt = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flSegments = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffsetDecay = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRecalcRate = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVScale = 0x740; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVOffset = 0x898; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flSplitRate = 0x9F0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBranchTwist = 0xB48; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBranchBehavior = 0xCA0; // ParticleLightnintBranchBehavior_t
    constexpr std::ptrdiff_t m_flRadiusStart = 0xCA8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusEnd = 0xE00; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flDedicatedPool = 0xF58; // CParticleCollectionFloatInput
}

namespace C_OP_LocalAccelerationForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecAccel = 0x1D8; // CParticleCollectionVecInput
}

namespace C_OP_LockPoints { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nMinCol = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCol = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMinRow = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxRow = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flBlendValue = 0x1D4; // float
}

namespace C_OP_LockToBone { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x288; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x28C; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bRigid = 0x318; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x319; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nRotationSetType = 0x324; // ParticleRotationLockType_t
    constexpr std::ptrdiff_t m_bRigidRotationLock = 0x328; // bool
    constexpr std::ptrdiff_t m_vecRotation = 0x330; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flRotLerp = 0x988; // CPerParticleFloatInput
}

namespace C_OP_LockToPointList { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_OP_LockToSavedSequentialPath { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1CC; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_LockToSavedSequentialPathV2 { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C4; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C8; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_MaintainEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // float
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionRate = 0x478; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bEmitInstantaneously = 0x480; // bool
    constexpr std::ptrdiff_t m_bFinalEmitOnStop = 0x481; // bool
    constexpr std::ptrdiff_t m_flScale = 0x488; // CParticleCollectionFloatInput
}

namespace C_OP_MaintainSequentialPath { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCohesionStrength = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1CC; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D1; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1E0; // CPathParameters
}

namespace C_OP_MaxVelocity { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMaxVelocity = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C4; // float
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCPField = 0x1CC; // int32_t
}

namespace C_OP_ModelCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_OP_ModelDampenMovement { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
    constexpr std::ptrdiff_t m_vecPosOffset = 0x248; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x8A0; // float
}

namespace C_OP_MoveToHitbox { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeLerpStart = 0x28C; // float
    constexpr std::ptrdiff_t m_flLifeTimeLerpEnd = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x318; // bool
    constexpr std::ptrdiff_t m_nLerpType = 0x31C; // HitboxLerpType_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x320; // CPerParticleFloatInput
}

namespace C_OP_MovementLoopInsideSphere { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x320; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nDistSqrAttr = 0x978; // ParticleAttributeIndex_t
}

namespace C_OP_MovementMaintainOffset { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecOffset = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1D0; // bool
}

namespace C_OP_MovementMoveAlongSkinnedCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1C9; // bool
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flTValue = 0x328; // CPerParticleFloatInput
}

namespace C_OP_MovementPlaceOnGround { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x31C; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x320; // float
    constexpr std::ptrdiff_t m_flLerpRate = 0x324; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x328; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3A8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nRefCP1 = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_nRefCP2 = 0x3B0; // int32_t
    constexpr std::ptrdiff_t m_nLerpCP = 0x3B4; // int32_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x3C0; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeShotHull = 0x3C4; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3C5; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x3C8; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x3C9; // bool
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x3CC; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x3D0; // int32_t
}

namespace C_OP_MovementRigidAttachToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nScaleCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D4; // bool
}

namespace C_OP_MovementRotateParticleAroundAxis { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x970; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D8; // bool
}

namespace C_OP_MovementSkinnedPositionFromCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1D1; // bool
    constexpr std::ptrdiff_t m_flIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x5E0; // CPerParticleFloatInput
}

namespace C_OP_Noise { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1D4; // float
}

namespace C_OP_NoiseEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEmissionScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nWorldNoisePoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1D9; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1E8; // float
    constexpr std::ptrdiff_t m_flWorldNoiseScale = 0x1EC; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1FC; // float
}

namespace C_OP_NormalLock { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
}

namespace C_OP_NormalizeVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
}

namespace C_OP_Orient2DRelToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_OP_OrientTo2dDirection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
}

namespace C_OP_OscillateScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_nField = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1D4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1D5; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1E0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1EC; // float
}

namespace C_OP_OscillateScalarSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_Frequency = 0x1C4; // float
    constexpr std::ptrdiff_t m_nField = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1D0; // float
}

namespace C_OP_OscillateVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_RateMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1F4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1F5; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1F6; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1F8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x200; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x204; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x208; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOscAdd = 0x360; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRateScale = 0x4B8; // CPerParticleFloatInput
}

namespace C_OP_OscillateVectorSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_Frequency = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1E0; // float
    constexpr std::ptrdiff_t m_bOffset = 0x1E4; // bool
}

namespace C_OP_ParentVortices { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecTwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bFlipBasedOnYaw = 0x1E0; // bool
}

namespace C_OP_ParticlePhysics { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_PerParticleForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vForce = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
}

namespace C_OP_PercentageBetweenTransformLerpCPs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x238; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nOutputStartCP = 0x2A0; // int32_t
    constexpr std::ptrdiff_t m_nOutputStartField = 0x2A4; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndCP = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndField = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2B4; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2B5; // bool
}

namespace C_OP_PercentageBetweenTransforms { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x240; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2A8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2AC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2AD; // bool
}

namespace C_OP_PercentageBetweenTransformsVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_TransformStart = 0x1E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x250; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2BC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2BD; // bool
}

namespace C_OP_PinParticleToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x820; // bool
    constexpr std::ptrdiff_t m_nParticleSelection = 0x824; // ParticleSelection_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nPinBreakType = 0x980; // ParticlePinDistance_t
    constexpr std::ptrdiff_t m_flBreakDistance = 0x988; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBreakSpeed = 0xAE0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAge = 0xC38; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBreakControlPointNumber = 0xD90; // int32_t
    constexpr std::ptrdiff_t m_nBreakControlPointNumber2 = 0xD94; // int32_t
    constexpr std::ptrdiff_t m_flBreakValue = 0xD98; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0xEF0; // CPerParticleFloatInput
}

namespace C_OP_PlanarConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_PointOnPlane = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_PlaneNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bGlobalOrigin = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bGlobalNormal = 0x1DD; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaximumDistanceToCP = 0x338; // CParticleCollectionFloatInput
}

namespace C_OP_PlaneCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nPlaneControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPlaneDirection = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x1D4; // float
}

namespace C_OP_PlayEndCapWhenFinished { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bFireOnEmissionEnd = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bIncludeChildren = 0x1D1; // bool
}

namespace C_OP_PointVectorAtNextParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
}

namespace C_OP_PositionLock { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime_min = 0x228; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x22C; // float
    constexpr std::ptrdiff_t m_flStartTime_exp = 0x230; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x234; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x238; // float
    constexpr std::ptrdiff_t m_flEndTime_exp = 0x23C; // float
    constexpr std::ptrdiff_t m_flRange = 0x240; // float
    constexpr std::ptrdiff_t m_flRangeBias = 0x248; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x3A0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x3A4; // float
    constexpr std::ptrdiff_t m_bLockRot = 0x3A8; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x3B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xA08; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0xA0C; // ParticleAttributeIndex_t
}

namespace C_OP_QuantizeCPComponent { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flInputValue = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCPOutput = 0x328; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_flQuantizeValue = 0x330; // CParticleCollectionFloatInput
}

namespace C_OP_QuantizeFloat { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_OP_RadiusDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinRadius = 0x1C0; // float
}

namespace C_OP_RampCPLinearRandom { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecRateMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vecRateMax = 0x1E0; // Vector
}

namespace C_OP_RampScalarLinear { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
}

namespace C_OP_RampScalarLinearSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
}

namespace C_OP_RampScalarSpline { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_flBias = 0x1D8; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
    constexpr std::ptrdiff_t m_bEaseOut = 0x205; // bool
}

namespace C_OP_RampScalarSplineSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseOut = 0x1F4; // bool
}

namespace C_OP_RandomForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_MinForce = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_MaxForce = 0x1DC; // Vector
}

namespace C_OP_ReadFromNeighboringParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_DistanceCheck = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x328; // CPerParticleFloatInput
}

namespace C_OP_ReinitializeScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
}

namespace C_OP_RemapAverageHitboxSpeedtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nHitboxDataType = 0x1DC; // ParticleHitboxDataSelection_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nHeightControlPointNumber = 0x740; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x748; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xDA0; // char[128]
}

namespace C_OP_RemapAverageScalarValuetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
}

namespace C_OP_RemapBoundingVolumetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E0; // float
}

namespace C_OP_RemapCPVelocityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1CC; // bool
}

namespace C_OP_RemapCPtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nInputField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bDerivative = 0x1F0; // bool
    constexpr std::ptrdiff_t m_flInterpRate = 0x1F4; // float
}

namespace C_OP_RemapCPtoScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x1E4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E8; // ParticleSetMethod_t
}

namespace C_OP_RemapCPtoVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x200; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x204; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x208; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x20C; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x20D; // bool
}

namespace C_OP_RemapControlPointDirectionToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapControlPointOrientationToRotation { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1C8; // float
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_OP_RemapCrossProductOfTwoVectorsToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputVec1 = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_InputVec2 = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xE70; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNormalize = 0xE74; // bool
}

namespace C_OP_RemapDensityGradientToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDensityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDensityMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDensityMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_bUseParentDensity = 0x1E8; // bool
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1EC; // int32_t
}

namespace C_OP_RemapDirectionToCPToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nFieldStrength = 0x1E0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDistanceToLineSegmentBase { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP0 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCP1 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flMinInputValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxInputValue = 0x1CC; // float
    constexpr std::ptrdiff_t m_bInfiniteLine = 0x1D0; // bool
}

namespace C_OP_RemapDistanceToLineSegmentToScalar { // C_OP_RemapDistanceToLineSegmentBase
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinOutputValue = 0x1E4; // float
    constexpr std::ptrdiff_t m_flMaxOutputValue = 0x1E8; // float
}

namespace C_OP_RemapDistanceToLineSegmentToVector { // C_OP_RemapDistanceToLineSegmentBase
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vMinOutputValue = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vMaxOutputValue = 0x1F0; // Vector
}

namespace C_OP_RemapDotProductToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
}

namespace C_OP_RemapDotProductToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_bUseParticleVelocity = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bUseParticleNormal = 0x1E5; // bool
}

namespace C_OP_RemapExternalWindToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecScale = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bSetMagnitude = 0x830; // bool
    constexpr std::ptrdiff_t m_nOutVectorField = 0x834; // int32_t
}

namespace C_OP_RemapModelVolumetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nBBoxType = 0x1D0; // BBoxVolumeType_t
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointMaxNumber = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
}

namespace C_OP_RemapNamedModelBodyPartEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelBodyPartOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapNamedModelElementEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_RemapNamedModelElementOnceTimed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x211; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRemapTime = 0x21C; // float
}

namespace C_OP_RemapNamedModelMeshGroupEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelMeshGroupOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapNamedModelSequenceEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelSequenceOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapParticleCountOnScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_bBackwards = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_RemapParticleCountToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nInputMax = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bActiveRange = 0x728; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x72C; // ParticleSetMethod_t
}

namespace C_OP_RemapSDFDistanceToScalarAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueBelowMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMin = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMax = 0x728; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAboveMax = 0x880; // CParticleCollectionFloatInput
}

namespace C_OP_RemapSDFDistanceToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nVectorFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vValueBelowMin = 0x478; // Vector
    constexpr std::ptrdiff_t m_vValueAtMin = 0x484; // Vector
    constexpr std::ptrdiff_t m_vValueAtMax = 0x490; // Vector
    constexpr std::ptrdiff_t m_vValueAboveMax = 0x49C; // Vector
}

namespace C_OP_RemapSDFGradientToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bOldCode = 0x1D8; // bool
}

namespace C_OP_RemapScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_OP_RemapScalarOnceTimed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bProportional = 0x1C0; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flRemapTime = 0x1DC; // float
}

namespace C_OP_RemapSpeed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D8; // bool
}

namespace C_OP_RemapSpeedtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseDeltaV = 0x1EC; // bool
}

namespace C_OP_RemapTransformOrientationToRotations { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_OP_RemapTransformOrientationToYaw { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x22C; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x230; // float
}

namespace C_OP_RemapTransformToVelocity { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_OP_RemapTransformVisibilityToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x23C; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x240; // float
    constexpr std::ptrdiff_t m_flRadius = 0x244; // float
}

namespace C_OP_RemapTransformVisibilityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x23C; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x248; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x254; // float
}

namespace C_OP_RemapVectorComponentToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
}

namespace C_OP_RemapVectortoCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapVelocityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1C8; // bool
}

namespace C_OP_RemapVisibilityScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D8; // float
}

namespace C_OP_RenderAsModels { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_ModelList = 0x200; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_flModelScale = 0x21C; // float
    constexpr std::ptrdiff_t m_bFitToModelSize = 0x220; // bool
    constexpr std::ptrdiff_t m_bNonUniformScaling = 0x221; // bool
    constexpr std::ptrdiff_t m_nXAxisScalingAttribute = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nYAxisScalingAttribute = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nZAxisScalingAttribute = 0x22C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x230; // int32_t
}

namespace C_OP_RenderBlobs { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_cubeWidth = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_cutoffRadius = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_renderRadius = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x608; // int32_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x610; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hMaterial = 0x640; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderCables { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x4B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB08; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_hMaterial = 0xB10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nTextureRepetitionMode = 0xB18; // TextureRepetitionMode_t
    constexpr std::ptrdiff_t m_flTextureRepeatsPerSegment = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flTextureRepeatsCircumference = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetV = 0xDD0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetU = 0xF28; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetV = 0x1080; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetU = 0x11D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDrawCableCaps = 0x1330; // bool
    constexpr std::ptrdiff_t m_flCapRoundness = 0x1334; // float
    constexpr std::ptrdiff_t m_flCapOffsetAmount = 0x1338; // float
    constexpr std::ptrdiff_t m_flTessScale = 0x133C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x1344; // int32_t
    constexpr std::ptrdiff_t m_nRoundness = 0x1348; // int32_t
    constexpr std::ptrdiff_t m_LightingTransform = 0x1350; // CParticleTransformInput
    constexpr std::ptrdiff_t m_MaterialFloatVars = 0x13B8; // CUtlVector<FloatInputMaterialVariable_t>
    constexpr std::ptrdiff_t m_MaterialVecVars = 0x13E8; // CUtlVector<VecInputMaterialVariable_t>
}

namespace C_OP_RenderClothForce { // CParticleFunctionRenderer
}

namespace C_OP_RenderDeferredLight { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bUseAlphaTestWindow = 0x200; // bool
    constexpr std::ptrdiff_t m_bUseTexture = 0x201; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x208; // float
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x210; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x868; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flLightDistance = 0x86C; // float
    constexpr std::ptrdiff_t m_flStartFalloff = 0x870; // float
    constexpr std::ptrdiff_t m_flDistanceFalloff = 0x874; // float
    constexpr std::ptrdiff_t m_flSpotFoV = 0x878; // float
    constexpr std::ptrdiff_t m_nAlphaTestPointField = 0x87C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestRangeField = 0x880; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestSharpnessField = 0x884; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_hTexture = 0x888; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x890; // int32_t
}

namespace C_OP_RenderFlattenGrass { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flFlattenStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadiusScale = 0x208; // float
}

namespace C_OP_RenderGpuImplicit { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bUsePerParticleRadius = 0x200; // bool
    constexpr std::ptrdiff_t m_fGridSize = 0x208; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fRadiusScale = 0x360; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fIsosurfaceThreshold = 0x4B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x610; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x618; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderLightBeam { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_vColorBlend = 0x200; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x858; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flBrightnessLumensPerMeter = 0x860; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9B8; // bool
    constexpr std::ptrdiff_t m_flSkirt = 0x9C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xB18; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0xC70; // CParticleCollectionFloatInput
}

namespace C_OP_RenderLights { // C_OP_RenderPoints
    constexpr std::ptrdiff_t m_flAnimationRate = 0x210; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0x214; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0x218; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x21C; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x220; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x224; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x228; // float
}

namespace C_OP_RenderMaterialProxy { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nMaterialControlPoint = 0x200; // int32_t
    constexpr std::ptrdiff_t m_nProxyType = 0x204; // MaterialProxyType_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x208; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x220; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flMaterialOverrideEnabled = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x380; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flAlpha = 0x9D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB30; // ParticleColorBlendType_t
}

namespace C_OP_RenderModels { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x200; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x201; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x202; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x203; // bool
    constexpr std::ptrdiff_t m_ModelList = 0x208; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_nBodyGroupField = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSubModelField = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bIgnoreNormal = 0x22C; // bool
    constexpr std::ptrdiff_t m_bOrientZ = 0x22D; // bool
    constexpr std::ptrdiff_t m_bCenterOffset = 0x22E; // bool
    constexpr std::ptrdiff_t m_vecLocalOffset = 0x230; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecLocalRotation = 0x888; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreRadius = 0xEE0; // bool
    constexpr std::ptrdiff_t m_nModelScaleCP = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_vecComponentScale = 0xEE8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bLocalScale = 0x1540; // bool
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x1544; // int32_t
    constexpr std::ptrdiff_t m_bAnimated = 0x1548; // bool
    constexpr std::ptrdiff_t m_flAnimationRate = 0x154C; // float
    constexpr std::ptrdiff_t m_bScaleAnimationRate = 0x1550; // bool
    constexpr std::ptrdiff_t m_bForceLoopingAnimation = 0x1551; // bool
    constexpr std::ptrdiff_t m_bResetAnimOnStop = 0x1552; // bool
    constexpr std::ptrdiff_t m_bManualAnimFrame = 0x1553; // bool
    constexpr std::ptrdiff_t m_nAnimationScaleField = 0x1554; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAnimationField = 0x1558; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualFrameField = 0x155C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_ActivityName = 0x1560; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x1660; // char[256]
    constexpr std::ptrdiff_t m_bEnableClothSimulation = 0x1760; // bool
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x1768; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bOverrideTranslucentMaterials = 0x1770; // bool
    constexpr std::ptrdiff_t m_nSkin = 0x1778; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_MaterialVars = 0x18D0; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_modelInput = 0x18E8; // CParticleModelInput
    constexpr std::ptrdiff_t m_nLOD = 0x1948; // int32_t
    constexpr std::ptrdiff_t m_EconSlotName = 0x194C; // char[256]
    constexpr std::ptrdiff_t m_bOriginalModel = 0x1A4C; // bool
    constexpr std::ptrdiff_t m_bSuppressTint = 0x1A4D; // bool
    constexpr std::ptrdiff_t m_bUseRawMeshGroup = 0x1A4E; // bool
    constexpr std::ptrdiff_t m_bDisableShadows = 0x1A4F; // bool
    constexpr std::ptrdiff_t m_bAcceptsDecals = 0x1A50; // bool
    constexpr std::ptrdiff_t m_bForceDrawInterlevedWithSiblings = 0x1A51; // bool
    constexpr std::ptrdiff_t m_bDoNotDrawInParticlePass = 0x1A52; // bool
    constexpr std::ptrdiff_t m_szRenderAttribute = 0x1A53; // char[260]
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1B58; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1CB0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x1E08; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x1F60; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x1F68; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x25C0; // ParticleColorBlendType_t
}

namespace C_OP_RenderOmni2Light { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleOmni2LightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vColorBlend = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nBrightnessUnit = 0x864; // ParticleLightUnitChoiceList_t
    constexpr std::ptrdiff_t m_flBrightnessLumens = 0x868; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBrightnessCandelas = 0x9C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0xB18; // bool
    constexpr std::ptrdiff_t m_flLuminaireRadius = 0xB20; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSkirt = 0xC78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xDD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInnerConeAngle = 0xF28; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOuterConeAngle = 0x1080; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hLightCookie = 0x11D8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bSphericalCookie = 0x11E0; // bool
}

namespace C_OP_RenderPoints { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_hMaterial = 0x200; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderPostProcessing { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flPostProcessStrength = 0x200; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hPostTexture = 0x358; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_nPriority = 0x360; // ParticlePostProcessPriorityGroup_t
}

namespace C_OP_RenderProjected { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bProjectCharacter = 0x200; // bool
    constexpr std::ptrdiff_t m_bProjectWorld = 0x201; // bool
    constexpr std::ptrdiff_t m_bProjectWater = 0x202; // bool
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x203; // bool
    constexpr std::ptrdiff_t m_bEnableProjectedDepthControls = 0x204; // bool
    constexpr std::ptrdiff_t m_flMinProjectionDepth = 0x208; // float
    constexpr std::ptrdiff_t m_flMaxProjectionDepth = 0x20C; // float
    constexpr std::ptrdiff_t m_hProjectedMaterial = 0x210; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flAnimationTimeScale = 0x218; // float
    constexpr std::ptrdiff_t m_bOrientToNormal = 0x21C; // bool
    constexpr std::ptrdiff_t m_MaterialVars = 0x220; // CUtlVector<MaterialVariable_t>
}

namespace C_OP_RenderRopes { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2470; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x2474; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2480; // float
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2484; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2488; // float
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x248C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x2490; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x2494; // int32_t
    constexpr std::ptrdiff_t m_flTessScale = 0x2498; // float
    constexpr std::ptrdiff_t m_flTextureVWorldSize = 0x24A0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVScrollRate = 0x25F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVOffset = 0x2750; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nTextureVParamsCP = 0x28A8; // int32_t
    constexpr std::ptrdiff_t m_bClampV = 0x28AC; // bool
    constexpr std::ptrdiff_t m_nScaleCP1 = 0x28B0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP2 = 0x28B4; // int32_t
    constexpr std::ptrdiff_t m_flScaleVSizeByControlPointDistance = 0x28B8; // float
    constexpr std::ptrdiff_t m_flScaleVScrollByControlPointDistance = 0x28BC; // float
    constexpr std::ptrdiff_t m_flScaleVOffsetByControlPointDistance = 0x28C0; // float
    constexpr std::ptrdiff_t m_bUseScalarForTextureCoordinate = 0x28C5; // bool
    constexpr std::ptrdiff_t m_nScalarFieldForTextureCoordinate = 0x28C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScalarAttributeTextureCoordScale = 0x28CC; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x28D0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x28D1; // bool
    constexpr std::ptrdiff_t m_nOrientationType = 0x28D4; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nVectorFieldForOrientation = 0x28D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bDrawAsOpaque = 0x28DC; // bool
    constexpr std::ptrdiff_t m_bGenerateNormals = 0x28DD; // bool
}

namespace C_OP_RenderScreenShake { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flFrequencyScale = 0x208; // float
    constexpr std::ptrdiff_t m_flAmplitudeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nRadiusField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFrequencyField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAmplitudeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFilterCP = 0x220; // int32_t
}

namespace C_OP_RenderScreenVelocityRotate { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRotateRateDegrees = 0x200; // float
    constexpr std::ptrdiff_t m_flForwardDegrees = 0x204; // float
}

namespace C_OP_RenderSound { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flSndLvlScale = 0x204; // float
    constexpr std::ptrdiff_t m_flPitchScale = 0x208; // float
    constexpr std::ptrdiff_t m_flVolumeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nSndLvlField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nPitchField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVolumeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nChannel = 0x220; // int32_t
    constexpr std::ptrdiff_t m_nCPReference = 0x224; // int32_t
    constexpr std::ptrdiff_t m_pszSoundName = 0x228; // char[256]
    constexpr std::ptrdiff_t m_bSuppressStopSoundEvent = 0x328; // bool
}

namespace C_OP_RenderSprites { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x2470; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nOrientationType = 0x25C8; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x25CC; // int32_t
    constexpr std::ptrdiff_t m_bUseYawWithNormalAligned = 0x25D0; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x25D4; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x25D8; // float
    constexpr std::ptrdiff_t m_flAlphaAdjustWithSizeAdjust = 0x25DC; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x25E0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2738; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2890; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2894; // float
    constexpr std::ptrdiff_t m_bDistanceAlpha = 0x2898; // bool
    constexpr std::ptrdiff_t m_bSoftEdges = 0x2899; // bool
    constexpr std::ptrdiff_t m_flEdgeSoftnessStart = 0x289C; // float
    constexpr std::ptrdiff_t m_flEdgeSoftnessEnd = 0x28A0; // float
    constexpr std::ptrdiff_t m_bOutline = 0x28A4; // bool
    constexpr std::ptrdiff_t m_OutlineColor = 0x28A5; // Color
    constexpr std::ptrdiff_t m_nOutlineAlpha = 0x28AC; // int32_t
    constexpr std::ptrdiff_t m_flOutlineStart0 = 0x28B0; // float
    constexpr std::ptrdiff_t m_flOutlineStart1 = 0x28B4; // float
    constexpr std::ptrdiff_t m_flOutlineEnd0 = 0x28B8; // float
    constexpr std::ptrdiff_t m_flOutlineEnd1 = 0x28BC; // float
    constexpr std::ptrdiff_t m_nLightingMode = 0x28C0; // ParticleLightingQuality_t
    constexpr std::ptrdiff_t m_flLightingTessellation = 0x28C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flLightingDirectionality = 0x2A20; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bParticleShadows = 0x2B78; // bool
    constexpr std::ptrdiff_t m_flShadowDensity = 0x2B7C; // float
}

namespace C_OP_RenderStandardLight { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleLightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flIntensity = 0x868; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9C0; // bool
    constexpr std::ptrdiff_t m_flTheta = 0x9C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flPhi = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusMultiplier = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAttenuationStyle = 0xDD0; // StandardLightingAttenuationStyle_t
    constexpr std::ptrdiff_t m_flFalloffLinearity = 0xDD8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFiftyPercentFalloff = 0xF30; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flZeroPercentFalloff = 0x1088; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0x11E0; // bool
    constexpr std::ptrdiff_t m_bRenderSpecular = 0x11E1; // bool
    constexpr std::ptrdiff_t m_lightCookie = 0x11E8; // CUtlString
    constexpr std::ptrdiff_t m_nPriority = 0x11F0; // int32_t
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x11F4; // ParticleLightFogLightingMode_t
    constexpr std::ptrdiff_t m_flFogContribution = 0x11F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nCapsuleLightBehavior = 0x1350; // ParticleLightBehaviorChoiceList_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1354; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x1358; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1359; // bool
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x135C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x1360; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x1364; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1368; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x136C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x1370; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x1374; // float
}

namespace C_OP_RenderStatusEffect { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail2 = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDiffuseWarp = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelColorWarp = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelWarp = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSpecularWarp = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureEnvMap = 0x230; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderStatusEffectCitadel { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureNormal = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureMetalness = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureRoughness = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSelfIllum = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderText { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_OutlineColor = 0x200; // Color
    constexpr std::ptrdiff_t m_DefaultText = 0x208; // CUtlString
}

namespace C_OP_RenderTonemapController { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flTonemapLevel = 0x200; // float
    constexpr std::ptrdiff_t m_flTonemapWeight = 0x204; // float
    constexpr std::ptrdiff_t m_nTonemapLevelField = 0x208; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTonemapWeightField = 0x20C; // ParticleAttributeIndex_t
}

namespace C_OP_RenderTrails { // CBaseTrailRenderer
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2740; // bool
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2744; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2748; // float
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x274C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x2750; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x2754; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x2758; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x275C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x2760; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x2764; // float
    constexpr std::ptrdiff_t m_flRadiusHeadTaper = 0x2768; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecHeadColorScale = 0x28C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flHeadAlphaScale = 0x2F18; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x3070; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecTailColorScale = 0x31C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flTailAlphaScale = 0x3820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nHorizCropField = 0x3978; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVertCropField = 0x397C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flForwardShift = 0x3980; // float
    constexpr std::ptrdiff_t m_bFlipUVBasedOnPitchYaw = 0x3984; // bool
}

namespace C_OP_RenderTreeShake { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flPeakStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nPeakStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadius = 0x208; // float
    constexpr std::ptrdiff_t m_nRadiusFieldOverride = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flShakeDuration = 0x210; // float
    constexpr std::ptrdiff_t m_flTransitionTime = 0x214; // float
    constexpr std::ptrdiff_t m_flTwistAmount = 0x218; // float
    constexpr std::ptrdiff_t m_flRadialAmount = 0x21C; // float
    constexpr std::ptrdiff_t m_flControlPointOrientationAmount = 0x220; // float
    constexpr std::ptrdiff_t m_nControlPointForLinearDirection = 0x224; // int32_t
}

namespace C_OP_RenderVRHapticEvent { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nHand = 0x200; // ParticleVRHandChoiceList_t
    constexpr std::ptrdiff_t m_nOutputHandCP = 0x204; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x208; // int32_t
    constexpr std::ptrdiff_t m_flAmplitude = 0x210; // CPerParticleFloatInput
}

namespace C_OP_RepeatedTriggerChildGroup { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flClusterRefireTime = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterSize = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterCooldown = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLimitChildCount = 0x5E0; // bool
}

namespace C_OP_RestartAfterDuration { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDurationMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flDurationMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bOnlyChildren = 0x1D4; // bool
}

namespace C_OP_RopeSpringConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAdjustmentScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flInitialRestingLength = 0x5D0; // CParticleCollectionFloatInput
}

namespace C_OP_RotateVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecRotAxisMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecRotAxisMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_flRotRateMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flRotRateMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1E8; // CPerParticleFloatInput
}

namespace C_OP_RtEnvCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bStickInsteadOfCull = 0x1D9; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DA; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_OP_SDFConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flMinDist = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDist = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxIterations = 0x470; // int32_t
}

namespace C_OP_SDFForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
}

namespace C_OP_SDFLighting { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vLightingDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vTint_0 = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vTint_1 = 0x1D8; // Vector
}

namespace C_OP_SelectivelyEnableChildren { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstChild = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x480; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x5D8; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x5D9; // bool
}

namespace C_OP_SequenceFromModel { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_OP_SetAttributeToScalarExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x478; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x47C; // ParticleSetMethod_t
}

namespace C_OP_SetCPOrientationToDirection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1C4; // int32_t
}

namespace C_OP_SetCPOrientationToGroundNormal { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInterpRate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1D0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x250; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nInputCP = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x258; // int32_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x268; // bool
}

namespace C_OP_SetCPOrientationToPointAtCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_b2DOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bAvoidSingularity = 0x331; // bool
    constexpr std::ptrdiff_t m_bPointAway = 0x332; // bool
}

namespace C_OP_SetCPtoVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_SetChildControlPoints { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bReverse = 0x328; // bool
    constexpr std::ptrdiff_t m_bSetOrientation = 0x329; // bool
}

namespace C_OP_SetControlPointFieldFromVectorExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vecInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE88; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0xFE0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0xFE4; // int32_t
}

namespace C_OP_SetControlPointFieldToScalarExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0x488; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0x5E0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x5E4; // int32_t
}

namespace C_OP_SetControlPointFieldToWater { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1D8; // int32_t
}

namespace C_OP_SetControlPointFromObjectScale { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointOrientation { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bRandomize = 0x1D2; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D3; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_vecRotation = 0x1DC; // QAngle
    constexpr std::ptrdiff_t m_vecRotationB = 0x1E8; // QAngle
    constexpr std::ptrdiff_t m_flInterpolation = 0x1F8; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointOrientationToCPVelocity { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointPositionToRandomActiveCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMin = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMax = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flResetRate = 0x1E0; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointPositionToTimeOfDayValue { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_pszTimeOfDayParameter = 0x1D4; // char[128]
    constexpr std::ptrdiff_t m_vecDefaultValue = 0x254; // Vector
}

namespace C_OP_SetControlPointPositions { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D2; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCP2 = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCP3 = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCP4 = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecCP2Pos = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_vecCP3Pos = 0x1FC; // Vector
    constexpr std::ptrdiff_t m_vecCP4Pos = 0x208; // Vector
    constexpr std::ptrdiff_t m_nHeadLocation = 0x214; // int32_t
}

namespace C_OP_SetControlPointRotation { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
    constexpr std::ptrdiff_t m_nLocalCP = 0x984; // int32_t
}

namespace C_OP_SetControlPointToCPVelocity { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutputVel = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bNormalize = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCPOutputMag = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x1E8; // CParticleCollectionVecInput
}

namespace C_OP_SetControlPointToCenter { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nSetParent = 0x1E0; // ParticleParentSetMode_t
}

namespace C_OP_SetControlPointToHMD { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToHMD = 0x1E0; // bool
}

namespace C_OP_SetControlPointToHand { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHand = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_bOrientToHand = 0x1E4; // bool
}

namespace C_OP_SetControlPointToImpactPoint { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPOut = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPIn = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flUpdateRate = 0x1D8; // float
    constexpr std::ptrdiff_t m_flTraceLength = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x338; // float
    constexpr std::ptrdiff_t m_flOffset = 0x33C; // float
    constexpr std::ptrdiff_t m_vecTraceDir = 0x340; // Vector
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x34C; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3CC; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bSetToEndpoint = 0x3D0; // bool
    constexpr std::ptrdiff_t m_bTraceToClosestSurface = 0x3D1; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3D2; // bool
}

namespace C_OP_SetControlPointToPlayer { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToEyes = 0x1E0; // bool
}

namespace C_OP_SetControlPointToVectorExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE88; // bool
}

namespace C_OP_SetControlPointToWaterSurface { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nFlowCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nActiveCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nActiveCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flRetestRate = 0x1E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bAdaptiveThreshold = 0x340; // bool
}

namespace C_OP_SetControlPointsToModelParticles { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_AttachmentName = 0x240; // char[128]
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x2C0; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x2C4; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x2C8; // int32_t
    constexpr std::ptrdiff_t m_bSkin = 0x2CC; // bool
    constexpr std::ptrdiff_t m_bAttachment = 0x2CD; // bool
}

namespace C_OP_SetControlPointsToParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nOrientationMode = 0x1D4; // ParticleOrientationSetMode_t
    constexpr std::ptrdiff_t m_nSetParent = 0x1D8; // ParticleParentSetMode_t
}

namespace C_OP_SetFloat { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseNewCode = 0x478; // bool
}

namespace C_OP_SetFloatAttributeToVectorExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE78; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0xFD0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xFD4; // ParticleSetMethod_t
}

namespace C_OP_SetFloatCollection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CParticleCollectionFloatInput
}

namespace C_OP_SetFromCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x488; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bSubSample = 0x5E0; // bool
}

namespace C_OP_SetGravityToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bSetZDown = 0x331; // bool
}

namespace C_OP_SetParentControlPointsToChildCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nChildControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1E0; // bool
}

namespace C_OP_SetPerChildControlPoint { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x480; // bool
    constexpr std::ptrdiff_t m_nOrientationField = 0x484; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x488; // bool
}

namespace C_OP_SetPerChildControlPointFromAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nCPField = 0x1DC; // int32_t
}

namespace C_OP_SetRandomControlPointPosition { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flReRandomRate = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecCPMinPos = 0x338; // Vector
    constexpr std::ptrdiff_t m_vecCPMaxPos = 0x344; // Vector
    constexpr std::ptrdiff_t m_flInterpolation = 0x350; // CParticleCollectionFloatInput
}

namespace C_OP_SetSimulationRate { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flSimulationScale = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_OP_SetSingleControlPointPosition { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x830; // CParticleTransformInput
}

namespace C_OP_SetToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D0; // bool
}

namespace C_OP_SetVariable { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_variableReference = 0x1D0; // CParticleVariableRef
    constexpr std::ptrdiff_t m_transformInput = 0x210; // CParticleTransformInput
    constexpr std::ptrdiff_t m_positionOffset = 0x278; // Vector
    constexpr std::ptrdiff_t m_rotationOffset = 0x284; // QAngle
    constexpr std::ptrdiff_t m_vecInput = 0x290; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_floatInput = 0x8E8; // CParticleCollectionFloatInput
}

namespace C_OP_SetVec { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x978; // bool
}

namespace C_OP_SetVectorAttributeToVectorExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_OP_ShapeMatchingConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flShapeRestorationTime = 0x1C0; // float
}

namespace C_OP_SnapshotRigidSkinToBones { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
}

namespace C_OP_SnapshotSkinToBones { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x1C8; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x1CC; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x1D4; // float
}

namespace C_OP_Spin { // CGeneralSpin
}

namespace C_OP_SpinUpdate { // CSpinUpdateBase
}

namespace C_OP_SpinYaw { // CGeneralSpin
}

namespace C_OP_SpringToVectorConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRestingLength = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecAnchorVector = 0x720; // CPerParticleVecInput
}

namespace C_OP_StopAfterCPDuration { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flDuration = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x328; // bool
    constexpr std::ptrdiff_t m_bPlayEndCap = 0x329; // bool
}

namespace C_OP_TeleportBeam { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPPosition = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCPVelocity = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nCPMisc = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPColor = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nCPInvalidColor = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPExtraArcData = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vGravity = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_flArcMaxDuration = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSegmentBreak = 0x1E8; // float
    constexpr std::ptrdiff_t m_flArcSpeed = 0x1EC; // float
    constexpr std::ptrdiff_t m_flAlpha = 0x1F0; // float
}

namespace C_OP_TimeVaryingForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flStartLerpTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_StartingForce = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flEndLerpTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_EndingForce = 0x1E4; // Vector
}

namespace C_OP_TurbulenceForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flNoiseCoordScale0 = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale1 = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale3 = 0x1DC; // float
    constexpr std::ptrdiff_t m_vecNoiseAmount0 = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount1 = 0x1EC; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount2 = 0x1F8; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount3 = 0x204; // Vector
}

namespace C_OP_TwistAroundAxis { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_fForceAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_TwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1E0; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1E4; // int32_t
}

namespace C_OP_UpdateLightSource { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vColorTint = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMinimumLightingRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaximumLightingRadius = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPositionDampingConstant = 0x1D4; // float
}

namespace C_OP_VectorFieldSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flBoundaryDampening = 0x980; // float
    constexpr std::ptrdiff_t m_bSetVelocity = 0x984; // bool
    constexpr std::ptrdiff_t m_bLockToSurface = 0x985; // bool
    constexpr std::ptrdiff_t m_flGridSpacing = 0x988; // float
}

namespace C_OP_VectorNoise { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1E4; // float
}

namespace C_OP_VelocityDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C0; // float
}

namespace C_OP_VelocityMatchingForce { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDirScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpdScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCPBroadcast = 0x1C8; // int32_t
}

namespace C_OP_WindForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vForce = 0x1D0; // Vector
}

namespace C_OP_WorldCollideConstraint { // CParticleFunctionConstraint
}

namespace C_OP_WorldTraceConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecCpOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_nCollisionMode = 0x1D0; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nCollisionModeMin = 0x1D4; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nTraceSet = 0x1D8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1DC; // char[128]
    constexpr std::ptrdiff_t m_bWorldOnly = 0x25C; // bool
    constexpr std::ptrdiff_t m_bBrushOnly = 0x25D; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x25E; // bool
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x260; // int32_t
    constexpr std::ptrdiff_t m_flCpMovementTolerance = 0x264; // float
    constexpr std::ptrdiff_t m_flRetestRate = 0x268; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x26C; // float
    constexpr std::ptrdiff_t m_flCollisionConfirmationSpeed = 0x270; // float
    constexpr std::ptrdiff_t m_nMaxTracesPerFrame = 0x274; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x278; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBounceAmount = 0x3D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSlideAmount = 0x528; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRandomDirScale = 0x680; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bDecayBounce = 0x7D8; // bool
    constexpr std::ptrdiff_t m_bKillonContact = 0x7D9; // bool
    constexpr std::ptrdiff_t m_flMinSpeed = 0x7DC; // float
    constexpr std::ptrdiff_t m_bSetNormal = 0x7E0; // bool
    constexpr std::ptrdiff_t m_nStickOnCollisionField = 0x7E4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStopSpeed = 0x7E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEntityStickDataField = 0x940; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nEntityStickNormalField = 0x944; // ParticleAttributeIndex_t
}

namespace CollisionGroupContext_t {
    constexpr std::ptrdiff_t m_nCollisionGroupNumber = 0x0; // int32_t
}

namespace ControlPointReference_t {
    constexpr std::ptrdiff_t m_controlPointNameString = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOffsetFromControlPoint = 0x4; // Vector
    constexpr std::ptrdiff_t m_bOffsetInLocalSpace = 0x10; // bool
}

namespace FloatInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flInput = 0x8; // CParticleCollectionFloatInput
}

namespace IControlPointEditorData {
}

namespace IParticleCollection {
}

namespace IParticleEffect {
}

namespace IParticleSystemDefinition {
}

namespace MaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nVariableField = 0x8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0xC; // float
}

namespace ModelReference_t {
    constexpr std::ptrdiff_t m_model = 0x0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_flRelativeProbabilityOfSpawn = 0x8; // float
}

namespace PARTICLE_EHANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace PARTICLE_WORLD_HANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace ParticleAttributeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace ParticleChildrenInfo_t {
    constexpr std::ptrdiff_t m_ChildRef = 0x0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flDelay = 0x8; // float
    constexpr std::ptrdiff_t m_bEndCap = 0xC; // bool
    constexpr std::ptrdiff_t m_bDisableChild = 0xD; // bool
    constexpr std::ptrdiff_t m_nDetailLevel = 0x10; // ParticleDetailLevel_t
}

namespace ParticleControlPointConfiguration_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_drivers = 0x8; // CUtlVector<ParticleControlPointDriver_t>
    constexpr std::ptrdiff_t m_previewState = 0x20; // ParticlePreviewState_t
}

namespace ParticleControlPointDriver_t {
    constexpr std::ptrdiff_t m_iControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iAttachType = 0x4; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_vecOffset = 0x10; // Vector
    constexpr std::ptrdiff_t m_angOffset = 0x1C; // QAngle
    constexpr std::ptrdiff_t m_entityName = 0x28; // CUtlString
}

namespace ParticleNamedValueConfiguration_t {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ConfigValue = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_iAttachType = 0x18; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_BoundEntityPath = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strEntityScope = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strAttachmentName = 0x30; // CUtlString
}

namespace ParticleNamedValueSource_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_IsPublic = 0x8; // bool
    constexpr std::ptrdiff_t m_ValueType = 0xC; // PulseValueType_t
    constexpr std::ptrdiff_t m_DefaultConfig = 0x10; // ParticleNamedValueConfiguration_t
    constexpr std::ptrdiff_t m_NamedConfigs = 0x48; // CUtlVector<ParticleNamedValueConfiguration_t>
}

namespace ParticlePreviewBodyGroup_t {
    constexpr std::ptrdiff_t m_bodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace ParticlePreviewState_t {
    constexpr std::ptrdiff_t m_previewModel = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nModSpecificData = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_groundType = 0xC; // PetGroundType_t
    constexpr std::ptrdiff_t m_sequenceName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nFireParticleOnSequenceFrame = 0x18; // int32_t
    constexpr std::ptrdiff_t m_hitboxSetName = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_materialGroupName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecBodyGroups = 0x30; // CUtlVector<ParticlePreviewBodyGroup_t>
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x48; // float
    constexpr std::ptrdiff_t m_flParticleSimulationRate = 0x4C; // float
    constexpr std::ptrdiff_t m_bShouldDrawHitboxes = 0x50; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachments = 0x51; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachmentNames = 0x52; // bool
    constexpr std::ptrdiff_t m_bShouldDrawControlPointAxes = 0x53; // bool
    constexpr std::ptrdiff_t m_bAnimationNonLooping = 0x54; // bool
    constexpr std::ptrdiff_t m_vecPreviewGravity = 0x58; // Vector
}

namespace PointDefinitionWithTimeValues_t { // PointDefinition_t
    constexpr std::ptrdiff_t m_flTimeDuration = 0x14; // float
}

namespace PointDefinition_t {
    constexpr std::ptrdiff_t m_nControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x4; // bool
    constexpr std::ptrdiff_t m_vOffset = 0x8; // Vector
}

namespace SequenceWeightedList_t {
    constexpr std::ptrdiff_t m_nSequence = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flRelativeWeight = 0x4; // float
}

namespace TextureControls_t {
    constexpr std::ptrdiff_t m_flFinalTextureScaleU = 0x0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureScaleV = 0x158; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetU = 0x2B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetV = 0x408; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureUVRotation = 0x560; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flZoomScale = 0x6B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDistortion = 0x810; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRandomizeOffsets = 0x968; // bool
    constexpr std::ptrdiff_t m_bClampUVs = 0x969; // bool
    constexpr std::ptrdiff_t m_nPerParticleBlend = 0x96C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleScale = 0x970; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetU = 0x974; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetV = 0x978; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleRotation = 0x97C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleZoom = 0x980; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleDistortion = 0x984; // SpriteCardPerParticleScale_t
}

namespace TextureGroup_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bReplaceTextureWithGradient = 0x1; // bool
    constexpr std::ptrdiff_t m_hTexture = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_Gradient = 0x10; // CColorGradient
    constexpr std::ptrdiff_t m_nTextureType = 0x28; // SpriteCardTextureType_t
    constexpr std::ptrdiff_t m_nTextureChannels = 0x2C; // SpriteCardTextureChannel_t
    constexpr std::ptrdiff_t m_nTextureBlendMode = 0x30; // ParticleTextureLayerBlendType_t
    constexpr std::ptrdiff_t m_flTextureBlend = 0x38; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_TextureControls = 0x190; // TextureControls_t
}

namespace VecInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vecInput = 0x8; // CParticleCollectionVecInput
}
```

`HPCS2/HPCS2/offset/pulse_system.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CBasePulseGraphInstance {
}

namespace CPulseCell_Base {
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
}

namespace CPulseCell_BaseFlow { // CPulseCell_Base
}

namespace CPulseCell_BaseValue { // CPulseCell_Base
}

namespace CPulseCell_BaseYieldingInflow { // CPulseCell_BaseFlow
}

namespace CPulseCell_Inflow_BaseEntrypoint { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_EntryChunk = 0x48; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x50; // PulseRegisterMap_t
}

namespace CPulseCell_Inflow_EntOutputHandler { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_SourceEntity = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SourceOutput = 0x78; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x80; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedParamType = 0x88; // CPulseValueFullType
}

namespace CPulseCell_Inflow_EventHandler { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_EventName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_GraphHook { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_HookName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_Method { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_MethodName = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_bIsPublic = 0x80; // bool
    constexpr std::ptrdiff_t m_ReturnType = 0x88; // CPulseValueFullType
    constexpr std::ptrdiff_t m_Args = 0x98; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Inflow_Wait { // CPulseCell_BaseYieldingInflow
    constexpr std::ptrdiff_t m_WakeResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Inflow_Yield { // CPulseCell_BaseYieldingInflow
    constexpr std::ptrdiff_t m_UnyieldResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Outflow_CycleOrdered { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleOrdered_InstanceState_t {
    constexpr std::ptrdiff_t m_nNextIndex = 0x0; // int32_t
}

namespace CPulseCell_Outflow_CycleRandom { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled_InstanceState_t {
    constexpr std::ptrdiff_t m_Shuffle = 0x0; // CUtlVectorFixedGrowable<uint8_t>
    constexpr std::ptrdiff_t m_nNextShuffle = 0x20; // int32_t
}

namespace CPulseCell_Outflow_IntSwitch { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_SimultaneousParallel { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_StringSwitch { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_TestExplicitYesNo { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Outflow_TestRandomYesNo { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Step_CallExternalMethod { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_MethodName = 0x48; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedArgs = 0x50; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Step_DebugLog { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_PublicOutput { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_OutputIndex = 0x48; // PulseRuntimeOutputIndex_t
}

namespace CPulseCell_Step_TestDomainCreateFakeEntity { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_TestDomainDestroyFakeEntity { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_TestDomainEntFire { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseCell_Step_TestDomainTracepoint { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_MultiInflow_NoDefault { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_MultiInflow_WithDefault { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_NoInflow { // CPulseCell_BaseFlow
}

namespace CPulseCell_Val_TestDomainFindEntityByName { // CPulseCell_BaseValue
}

namespace CPulseCell_Val_TestDomainGetEntityName { // CPulseCell_BaseValue
}

namespace CPulseCell_Value_RandomInt { // CPulseCell_BaseValue
}

namespace CPulseCell_Value_TestValue50 { // CPulseCell_BaseValue
}

namespace CPulseExecCursor {
}

namespace CPulseGraphDef {
    constexpr std::ptrdiff_t m_DomainIdentifier = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ParentMapName = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Chunks = 0x18; // CUtlVector<CPulse_Chunk*>
    constexpr std::ptrdiff_t m_Cells = 0x30; // CUtlVector<CPulseCell_Base*>
    constexpr std::ptrdiff_t m_Vars = 0x48; // CUtlVector<CPulse_Variable>
    constexpr std::ptrdiff_t m_PublicOutputs = 0x60; // CUtlVector<CPulse_PublicOutput>
    constexpr std::ptrdiff_t m_InvokeBindings = 0x78; // CUtlVector<CPulse_InvokeBinding*>
    constexpr std::ptrdiff_t m_CallInfos = 0x90; // CUtlVector<CPulse_CallInfo*>
    constexpr std::ptrdiff_t m_OutputConnections = 0xA8; // CUtlVector<CPulse_OutputConnection*>
}

namespace CPulseGraphInstance_TestDomain { // CBasePulseGraphInstance
    constexpr std::ptrdiff_t m_bIsRunningUnitTests = 0xD0; // bool
    constexpr std::ptrdiff_t m_bExplicitTimeStepping = 0xD1; // bool
    constexpr std::ptrdiff_t m_bExpectingToDestroyWithYieldedCursors = 0xD2; // bool
    constexpr std::ptrdiff_t m_nNextValidateIndex = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_Tracepoints = 0xD8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bTestYesOrNoPath = 0xF0; // bool
}

namespace CPulseGraphInstance_TestDomain_Derived { // CPulseGraphInstance_TestDomain
    constexpr std::ptrdiff_t m_nInstanceValueX = 0xF8; // int32_t
}

namespace CPulseGraphInstance_TurtleGraphics { // CBasePulseGraphInstance
}

namespace CPulseMathlib {
}

namespace CPulseRuntimeMethodArg {
    constexpr std::ptrdiff_t m_Name = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_Description = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x40; // CPulseValueFullType
}

namespace CPulseTestFuncs_DerivedDomain {
}

namespace CPulseTestFuncs_LibraryA {
}

namespace CPulseTestScriptLib {
}

namespace CPulseTurtleGraphicsCursor { // CPulseExecCursor
    constexpr std::ptrdiff_t m_Color = 0x188; // Color
    constexpr std::ptrdiff_t m_vPos = 0x18C; // Vector2D
    constexpr std::ptrdiff_t m_flHeadingDeg = 0x194; // float
    constexpr std::ptrdiff_t m_bPenUp = 0x198; // bool
}

namespace CPulse_CallInfo {
    constexpr std::ptrdiff_t m_PortName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x10; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_CallMethodID = 0x30; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_nSrcChunk = 0x34; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x38; // int32_t
}

namespace CPulse_Chunk {
    constexpr std::ptrdiff_t m_Instructions = 0x0; // CUtlLeanVector<PGDInstruction_t>
    constexpr std::ptrdiff_t m_Registers = 0x10; // CUtlLeanVector<CPulse_RegisterInfo>
    constexpr std::ptrdiff_t m_InstructionEditorIDs = 0x20; // CUtlLeanVector<PulseDocNodeID_t>
}

namespace CPulse_InvokeBinding {
    constexpr std::ptrdiff_t m_RegisterMap = 0x0; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_FuncName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nCellIndex = 0x28; // PulseRuntimeCellIndex_t
    constexpr std::ptrdiff_t m_InstanceType = 0x30; // CPulseValueFullType
    constexpr std::ptrdiff_t m_nSrcChunk = 0x40; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x44; // int32_t
}

namespace CPulse_OutflowConnection {
    constexpr std::ptrdiff_t m_SourceOutflowName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDestChunk = 0x8; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nInstruction = 0xC; // int32_t
}

namespace CPulse_OutputConnection {
    constexpr std::ptrdiff_t m_SourceOutput = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntity = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Param = 0x18; // CUtlSymbolLarge
}

namespace CPulse_PublicOutput {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ParamType = 0x10; // CPulseValueFullType
}

namespace CPulse_RegisterInfo {
    constexpr std::ptrdiff_t m_nReg = 0x0; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_Type = 0x8; // CPulseValueFullType
    constexpr std::ptrdiff_t m_OriginName = 0x18; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_nWrittenByInstruction = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nLastReadByInstruction = 0x54; // int32_t
}

namespace CPulse_ResumePoint { // CPulse_OutflowConnection
}

namespace CPulse_Variable {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x10; // CPulseValueFullType
    constexpr std::ptrdiff_t m_DefaultValue = 0x20; // KeyValues3
    constexpr std::ptrdiff_t m_bIsPublic = 0x32; // bool
}

namespace CTestDomainDerived_Cursor { // CPulseExecCursor
    constexpr std::ptrdiff_t m_nCursorValueA = 0x188; // int32_t
    constexpr std::ptrdiff_t m_nCursorValueB = 0x18C; // int32_t
}

namespace FakeEntity_t {
    constexpr std::ptrdiff_t m_nHandle = 0x0; // PulseTestEHandle_t
    constexpr std::ptrdiff_t m_Name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Class = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDestroyed = 0x18; // bool
    constexpr std::ptrdiff_t m_pAssociatedGraphInstance = 0x20; // CPulseGraphInstance_TestDomain*
    constexpr std::ptrdiff_t m_bFuncWasCalled = 0x28; // bool
    constexpr std::ptrdiff_t m_fValue = 0x2C; // float
}

namespace PGDInstruction_t {
    constexpr std::ptrdiff_t m_nCode = 0x0; // PulseInstructionCode_t
    constexpr std::ptrdiff_t m_nVar = 0x4; // PulseRuntimeVarIndex_t
    constexpr std::ptrdiff_t m_nReg0 = 0x8; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg1 = 0xA; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg2 = 0xC; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nInvokeBindingIndex = 0x10; // PulseRuntimeInvokeIndex_t
    constexpr std::ptrdiff_t m_nChunk = 0x14; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nDestInstruction = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nCallInfoIndex = 0x1C; // PulseRuntimeCallInfoIndex_t
    constexpr std::ptrdiff_t m_Arg0Name = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Arg1Name = 0x28; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLiteralBool = 0x30; // bool
    constexpr std::ptrdiff_t m_nLiteralInt = 0x34; // int32_t
    constexpr std::ptrdiff_t m_flLiteralFloat = 0x38; // float
    constexpr std::ptrdiff_t m_LiteralString = 0x40; // CBufferString
    constexpr std::ptrdiff_t m_vLiteralVec3 = 0x50; // Vector
}

namespace PulseDocNodeID_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRegisterMap_t {
    constexpr std::ptrdiff_t m_Inparams = 0x0; // KeyValues3
    constexpr std::ptrdiff_t m_Outparams = 0x10; // KeyValues3
}

namespace PulseRuntimeCallInfoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeCellIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeChunkIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeEntrypointIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeInvokeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeOutputIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeRegisterIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}

namespace PulseRuntimeStateOffset_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace PulseRuntimeVarIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseTestEHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}
```

`HPCS2/HPCS2/offset/rendersystemdx11.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace RenderInputLayoutField_t {
    constexpr std::ptrdiff_t m_pSemanticName = 0x0; // uint8_t[32]
    constexpr std::ptrdiff_t m_nSemanticIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_Format = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nOffset = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nSlot = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_nSlotType = 0x30; // RenderSlotType_t
    constexpr std::ptrdiff_t m_nInstanceStepRate = 0x34; // int32_t
}

namespace VsInputSignatureElement_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char[64]
    constexpr std::ptrdiff_t m_pSemantic = 0x40; // char[64]
    constexpr std::ptrdiff_t m_pD3DSemanticName = 0x80; // char[64]
    constexpr std::ptrdiff_t m_nD3DSemanticIndex = 0xC0; // int32_t
}

namespace VsInputSignature_t {
    constexpr std::ptrdiff_t m_elems = 0x0; // CUtlVector<VsInputSignatureElement_t>
}
```

`HPCS2/HPCS2/offset/resourcesystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace AABB_t {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
}

namespace CFuseProgram {
    constexpr std::ptrdiff_t m_programBuffer = 0x0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_variablesRead = 0x18; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_variablesWritten = 0x30; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_nMaxTempVarsUsed = 0x48; // int32_t
}

namespace CFuseSymbolTable {
    constexpr std::ptrdiff_t m_constants = 0x0; // CUtlVector<ConstantInfo_t>
    constexpr std::ptrdiff_t m_variables = 0x18; // CUtlVector<VariableInfo_t>
    constexpr std::ptrdiff_t m_functions = 0x30; // CUtlVector<FunctionInfo_t>
    constexpr std::ptrdiff_t m_constantMap = 0x48; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_variableMap = 0x68; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_functionMap = 0x88; // CUtlHashtable<CUtlStringToken,int32_t>
}

namespace ConstantInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_flValue = 0xC; // float
}

namespace FourQuaternions {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
    constexpr std::ptrdiff_t z = 0x20; // fltx4
    constexpr std::ptrdiff_t w = 0x30; // fltx4
}

namespace FunctionInfo_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nParamCount = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nIndex = 0x18; // FuseFunctionIndex_t
    constexpr std::ptrdiff_t m_bIsPure = 0x1A; // bool
}

namespace FuseFunctionIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace FuseVariableIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace InfoForResourceTypeCAnimData {
}

namespace InfoForResourceTypeCAnimationGroup {
}

namespace InfoForResourceTypeCCSGOEconItem {
}

namespace InfoForResourceTypeCChoreoSceneFileData {
}

namespace InfoForResourceTypeCCompositeMaterialKit {
}

namespace InfoForResourceTypeCDACGameDefsData {
}

namespace InfoForResourceTypeCDOTANovelsList {
}

namespace InfoForResourceTypeCDOTAPatchNotesList {
}

namespace InfoForResourceTypeCDotaItemDefinitionResource {
}

namespace InfoForResourceTypeCEntityLump {
}

namespace InfoForResourceTypeCJavaScriptResource {
}

namespace InfoForResourceTypeCModel {
}

namespace InfoForResourceTypeCMorphSetData {
}

namespace InfoForResourceTypeCNmClip {
}

namespace InfoForResourceTypeCNmSkeleton {
}

namespace InfoForResourceTypeCPanoramaDynamicImages {
}

namespace InfoForResourceTypeCPanoramaLayout {
}

namespace InfoForResourceTypeCPanoramaStyle {
}

namespace InfoForResourceTypeCPhysAggregateData {
}

namespace InfoForResourceTypeCPostProcessingResource {
}

namespace InfoForResourceTypeCRenderMesh {
}

namespace InfoForResourceTypeCResponseRulesList {
}

namespace InfoForResourceTypeCSequenceGroupData {
}

namespace InfoForResourceTypeCSmartProp {
}

namespace InfoForResourceTypeCTextureBase {
}

namespace InfoForResourceTypeCTypeScriptResource {
}

namespace InfoForResourceTypeCVDataResource {
}

namespace InfoForResourceTypeCVMixListResource {
}

namespace InfoForResourceTypeCVPhysXSurfacePropertiesList {
}

namespace InfoForResourceTypeCVSoundEventScriptList {
}

namespace InfoForResourceTypeCVSoundStackScriptList {
}

namespace InfoForResourceTypeCVoxelVisibility {
}

namespace InfoForResourceTypeCWorldNode {
}

namespace InfoForResourceTypeIAnimGraphModelBinding {
}

namespace InfoForResourceTypeIMaterial2 {
}

namespace InfoForResourceTypeIParticleSnapshot {
}

namespace InfoForResourceTypeIParticleSystemDefinition {
}

namespace InfoForResourceTypeIPulseGraphDef {
}

namespace InfoForResourceTypeIVectorGraphic {
}

namespace InfoForResourceTypeManifestTestResource_t {
}

namespace InfoForResourceTypeProceduralTestResource_t {
}

namespace InfoForResourceTypeTestResource_t {
}

namespace InfoForResourceTypeVSound_t {
}

namespace InfoForResourceTypeWorld_t {
}

namespace ManifestTestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_child = 0x8; // CStrongHandle<InfoForResourceTypeManifestTestResource_t>
}

namespace PackedAABB_t {
    constexpr std::ptrdiff_t m_nPackedMin = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nPackedMax = 0x4; // uint32_t
}

namespace TestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace VariableInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nIndex = 0xC; // FuseVariableIndex_t
    constexpr std::ptrdiff_t m_nNumComponents = 0xE; // uint8_t
    constexpr std::ptrdiff_t m_eVarType = 0xF; // FuseVariableType_t
    constexpr std::ptrdiff_t m_eAccess = 0x10; // FuseVariableAccess_t
}
```

`HPCS2/HPCS2/offset/scenesystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CSSDSEndFrameViewInfo {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_ViewName = 0x8; // CUtlString
}

namespace CSSDSMsg_EndFrame {
    constexpr std::ptrdiff_t m_Views = 0x0; // CUtlVector<CSSDSEndFrameViewInfo>
}

namespace CSSDSMsg_LayerBase {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nLayerIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nLayerId = 0x20; // uint64_t
    constexpr std::ptrdiff_t m_LayerName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_displayText = 0x30; // CUtlString
}

namespace CSSDSMsg_PostLayer { // CSSDSMsg_LayerBase
}

namespace CSSDSMsg_PreLayer { // CSSDSMsg_LayerBase
}

namespace CSSDSMsg_ViewRender {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
}

namespace CSSDSMsg_ViewTarget {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_TextureId = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nRequestedWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nRequestedHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nNumMipLevels = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nDepth = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nMultisampleNumSamples = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nFormat = 0x2C; // int32_t
}

namespace CSSDSMsg_ViewTargetList {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_Targets = 0x18; // CUtlVector<CSSDSMsg_ViewTarget>
}

namespace SceneViewId_t {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x8; // uint64_t
}
```

`HPCS2/HPCS2/offset/schemasystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CExampleSchemaVData_Monomorphic {
    constexpr std::ptrdiff_t m_nExample1 = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nExample2 = 0x4; // int32_t
}

namespace CExampleSchemaVData_PolymorphicBase {
    constexpr std::ptrdiff_t m_nBase = 0x8; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedA { // CExampleSchemaVData_PolymorphicBase
    constexpr std::ptrdiff_t m_nDerivedA = 0x10; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedB { // CExampleSchemaVData_PolymorphicBase
    constexpr std::ptrdiff_t m_nDerivedB = 0x10; // int32_t
}

namespace CSchemaSystemInternalRegistration {
    constexpr std::ptrdiff_t m_Vector2D = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_Vector = 0x8; // Vector
    constexpr std::ptrdiff_t m_VectorAligned = 0x20; // VectorAligned
    constexpr std::ptrdiff_t m_Quaternion = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_QAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_RotationVector = 0x4C; // RotationVector
    constexpr std::ptrdiff_t m_RadianEuler = 0x58; // RadianEuler
    constexpr std::ptrdiff_t m_DegreeEuler = 0x64; // DegreeEuler
    constexpr std::ptrdiff_t m_QuaternionStorage = 0x70; // QuaternionStorage
    constexpr std::ptrdiff_t m_matrix3x4_t = 0x80; // matrix3x4_t
    constexpr std::ptrdiff_t m_matrix3x4a_t = 0xB0; // matrix3x4a_t
    constexpr std::ptrdiff_t m_Color = 0xE0; // Color
    constexpr std::ptrdiff_t m_Vector4D = 0xE4; // Vector4D
    constexpr std::ptrdiff_t m_CTransform = 0x100; // CTransform
    constexpr std::ptrdiff_t m_pKeyValues = 0x120; // KeyValues*
    constexpr std::ptrdiff_t m_CUtlBinaryBlock = 0x128; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_CUtlString = 0x140; // CUtlString
    constexpr std::ptrdiff_t m_CUtlSymbol = 0x148; // CUtlSymbol
    constexpr std::ptrdiff_t m_stringToken = 0x14C; // CUtlStringToken
    constexpr std::ptrdiff_t m_stringTokenWithStorage = 0x150; // CUtlStringTokenWithStorage
    constexpr std::ptrdiff_t m_ResourceTypes = 0x168; // CResourceArray<CResourcePointer<CResourceString>>
    constexpr std::ptrdiff_t m_KV3 = 0x170; // KeyValues3
}

namespace InfoForResourceTypeCResourceManifestInternal {
}

namespace ResourceId_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint64_t
}
```

`HPCS2/HPCS2/offset/server.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:21 +0000
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // CNetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace AmmoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int8_t
}

namespace AmmoTypeInfo_t {
    constexpr std::ptrdiff_t m_nMaxCarry = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nSplashSize = 0x1C; // CRangeInt
    constexpr std::ptrdiff_t m_nFlags = 0x24; // AmmoFlags_t
    constexpr std::ptrdiff_t m_flMass = 0x28; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x2C; // CRangeFloat
}

namespace AnimationUpdateListHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace CAISound { // CPointEntity
    constexpr std::ptrdiff_t m_iSoundType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iSoundContext = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_iVolume = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_iSoundIndex = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszProxyEntityName = 0x4C8; // CUtlSymbolLarge
}

namespace CAI_ChangeHintGroup { // CBaseEntity
    constexpr std::ptrdiff_t m_iSearchType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_strSearchName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strNewHintGroup = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
}

namespace CAI_ChangeTarget { // CBaseEntity
    constexpr std::ptrdiff_t m_iszNewTarget = 0x4B0; // CUtlSymbolLarge
}

namespace CAI_Expresser {
    constexpr std::ptrdiff_t m_flStopTalkTime = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_flStopTalkTimeWithoutDelay = 0x3C; // GameTime_t
    constexpr std::ptrdiff_t m_flBlockedTalkTime = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_voicePitch = 0x44; // int32_t
    constexpr std::ptrdiff_t m_flLastTimeAcceptedSpeak = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_bAllowSpeakingInterrupts = 0x4C; // bool
    constexpr std::ptrdiff_t m_bConsiderSceneInvolvementAsSpeech = 0x4D; // bool
    constexpr std::ptrdiff_t m_nLastSpokenPriority = 0x50; // int32_t
    constexpr std::ptrdiff_t m_pOuter = 0x58; // CBaseFlex*
}

namespace CAI_ExpresserWithFollowup { // CAI_Expresser
    constexpr std::ptrdiff_t m_pPostponedFollowup = 0x60; // ResponseFollowup*
}

namespace CAK47 { // CCSWeaponBaseGun
}

namespace CAmbientGeneric { // CPointEntity
    constexpr std::ptrdiff_t m_radius = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMaxRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iSoundLevel = 0x4B8; // soundlevel_t
    constexpr std::ptrdiff_t m_dpv = 0x4BC; // dynpitchvol_t
    constexpr std::ptrdiff_t m_fActive = 0x520; // bool
    constexpr std::ptrdiff_t m_fLooping = 0x521; // bool
    constexpr std::ptrdiff_t m_iszSound = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSourceEntName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSoundSource = 0x538; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundSourceEntIndex = 0x53C; // CEntityIndex
}

namespace CAnimEventListener { // CAnimEventListenerBase
}

namespace CAnimEventListenerBase {
}

namespace CAnimEventQueueListener { // CAnimEventListenerBase
}

namespace CAnimGraphControllerBase {
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAnimGraphTagRef {
    constexpr std::ptrdiff_t m_nTagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_tagName = 0x10; // CGlobalSymbol
}

namespace CAttributeContainer { // CAttributeManager
    constexpr std::ptrdiff_t m_Item = 0x50; // CEconItemView
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBarnLight { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0x704; // int32_t
    constexpr std::ptrdiff_t m_Color = 0x708; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0x70C; // float
    constexpr std::ptrdiff_t m_flBrightness = 0x710; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0x718; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0x724; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0x728; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x738; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0x740; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0x758; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0x770; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0x788; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0x848; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0x850; // float
    constexpr std::ptrdiff_t m_flSoftX = 0x854; // float
    constexpr std::ptrdiff_t m_flSoftY = 0x858; // float
    constexpr std::ptrdiff_t m_flSkirt = 0x85C; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0x860; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0x864; // Vector
    constexpr std::ptrdiff_t m_flRange = 0x870; // float
    constexpr std::ptrdiff_t m_vShear = 0x874; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0x880; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0x884; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0x890; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0x894; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0x898; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0x89C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0x8A4; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x8A8; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0x8B8; // float
    constexpr std::ptrdiff_t m_nFog = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0x8C0; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0x8C8; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0x8D0; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0x8D4; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0x8D8; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x8DC; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x8E0; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x8EC; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x904; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x910; // Vector
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x91C; // bool
}

namespace CBaseAnimGraph { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0x700; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0x701; // bool
    constexpr std::ptrdiff_t m_pChoreoServices = 0x708; // IChoreoServices*
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0x710; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0x714; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0x718; // Vector
    constexpr std::ptrdiff_t m_bAnimGraphDirty = 0x724; // bool
    constexpr std::ptrdiff_t m_vecForce = 0x728; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0x734; // int32_t
    constexpr std::ptrdiff_t m_pRagdollPose = 0x748; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0x750; // bool
}

namespace CBaseAnimGraphController { // CSkeletonAnimationController
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x218; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x21C; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x220; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x224; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x22C; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x230; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x231; // bool
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x234; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x238; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x23C; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x2DC; // AnimationUpdateListHandle_t
}

namespace CBaseButton { // CBaseToggle
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x780; // QAngle
    constexpr std::ptrdiff_t m_fStayPushed = 0x78C; // bool
    constexpr std::ptrdiff_t m_fRotating = 0x78D; // bool
    constexpr std::ptrdiff_t m_ls = 0x790; // locksound_t
    constexpr std::ptrdiff_t m_sUseSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sLockedSound = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sUnlockedSound = 0x7C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLocked = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x7C9; // bool
    constexpr std::ptrdiff_t m_flUseLockedTime = 0x7CC; // GameTime_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x7D0; // bool
    constexpr std::ptrdiff_t m_OnDamaged = 0x7D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPressed = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUseLocked = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnIn = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOut = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nState = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_hConstraint = 0x8A4; // CEntityHandle
    constexpr std::ptrdiff_t m_hConstraintParent = 0x8A8; // CEntityHandle
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x8AC; // bool
    constexpr std::ptrdiff_t m_sGlowEntity = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_glowEntity = 0x8B8; // CHandle<CBaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0x8BC; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0x8C0; // CUtlSymbolLarge
}

namespace CBaseCSGrenade { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bRedraw = 0xE18; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0xE19; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0xE1A; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0xE1B; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0xE1C; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0xE20; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0xE24; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0xE28; // float
    constexpr std::ptrdiff_t m_fDropTime = 0xE2C; // GameTime_t
}

namespace CBaseCSGrenadeProjectile { // CBaseGrenade
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x9C8; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x9D4; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x9D8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x9E4; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0x9F0; // GameTime_t
    constexpr std::ptrdiff_t m_unOGSExtraFlags = 0x9F4; // uint8_t
    constexpr std::ptrdiff_t m_bDetonationRecorded = 0x9F5; // bool
    constexpr std::ptrdiff_t m_flDetonateTime = 0x9F8; // GameTime_t
    constexpr std::ptrdiff_t m_nItemIndex = 0x9FC; // uint16_t
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0xA00; // Vector
    constexpr std::ptrdiff_t m_flLastBounceSoundTime = 0xA0C; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrenadeSpin = 0xA10; // RotationVector
    constexpr std::ptrdiff_t m_vecLastHitSurfaceNormal = 0xA1C; // Vector
    constexpr std::ptrdiff_t m_nTicksAtZeroVelocity = 0xA28; // int32_t
}

namespace CBaseClientUIEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_CustomOutput0 = 0x720; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput1 = 0x748; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput2 = 0x770; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput3 = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput4 = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput5 = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput6 = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput7 = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput8 = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput9 = 0x888; // CEntityIOOutput
}

namespace CBaseCombatCharacter { // CBaseFlex
    constexpr std::ptrdiff_t m_bForceServerRagdoll = 0x920; // bool
    constexpr std::ptrdiff_t m_hMyWearables = 0x928; // CNetworkUtlVectorBase<CHandle<CEconWearable>>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x940; // float
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x944; // float
    constexpr std::ptrdiff_t m_LastHitGroup = 0x948; // HitGroup_t
    constexpr std::ptrdiff_t m_bApplyStressDamage = 0x94C; // bool
    constexpr std::ptrdiff_t m_bloodColor = 0x950; // int32_t
    constexpr std::ptrdiff_t m_navMeshID = 0x9B0; // int32_t
    constexpr std::ptrdiff_t m_iDamageCount = 0x9B4; // int32_t
    constexpr std::ptrdiff_t m_pVecRelationships = 0x9B8; // CUtlVector<RelationshipOverride_t>*
    constexpr std::ptrdiff_t m_strRelationships = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_eHull = 0x9C8; // Hull_t
    constexpr std::ptrdiff_t m_nNavHullIdx = 0x9CC; // uint32_t
}

namespace CBaseDMStart { // CPointEntity
    constexpr std::ptrdiff_t m_Master = 0x4B0; // CUtlSymbolLarge
}

namespace CBaseDoor { // CBaseToggle
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x790; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x79C; // Vector
    constexpr std::ptrdiff_t m_ls = 0x7A8; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDoorGroup = 0x7C9; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x7CA; // bool
    constexpr std::ptrdiff_t m_bIgnoreDebris = 0x7CB; // bool
    constexpr std::ptrdiff_t m_eSpawnPosition = 0x7CC; // FuncDoorSpawnPos_t
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7D0; // float
    constexpr std::ptrdiff_t m_NoiseMoving = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseMovingClosed = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrivedClosed = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ChainTarget = 0x7F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bLoopMoveSound = 0x968; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x980; // bool
    constexpr std::ptrdiff_t m_isChaining = 0x981; // bool
    constexpr std::ptrdiff_t m_bIsUsable = 0x982; // bool
}

namespace CBaseEntity { // CEntityInstance
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x228; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x240; // int32_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x244; // GameTick_t
    constexpr std::ptrdiff_t m_isSteadyState = 0x250; // CBitVec<64>
    constexpr std::ptrdiff_t m_lastNetworkChange = 0x258; // float
    constexpr std::ptrdiff_t m_ResponseContexts = 0x268; // CUtlVector<ResponseContext_t>
    constexpr std::ptrdiff_t m_iszResponseContext = 0x280; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iHealth = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_iMaxHealth = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x2B0; // uint8_t
    constexpr std::ptrdiff_t m_flDamageAccumulator = 0x2B4; // float
    constexpr std::ptrdiff_t m_bTakesDamage = 0x2B8; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x2BC; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_MoveCollide = 0x2C1; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x2C2; // MoveType_t
    constexpr std::ptrdiff_t m_nWaterTouch = 0x2C3; // uint8_t
    constexpr std::ptrdiff_t m_nSlimeTouch = 0x2C4; // uint8_t
    constexpr std::ptrdiff_t m_bRestoreInHierarchy = 0x2C5; // bool
    constexpr std::ptrdiff_t m_target = 0x2C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveDoneTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_hDamageFilter = 0x2D4; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iszDamageFilterName = 0x2D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSubclassID = 0x2E0; // CUtlStringToken
    constexpr std::ptrdiff_t m_flAnimTime = 0x2F0; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x2F4; // float
    constexpr std::ptrdiff_t m_flCreateTime = 0x2F8; // GameTime_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x2FC; // bool
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x2FD; // uint8_t
    constexpr std::ptrdiff_t m_vPrevVPhysicsUpdatePos = 0x300; // Vector
    constexpr std::ptrdiff_t m_iTeamNum = 0x30C; // uint8_t
    constexpr std::ptrdiff_t m_iGlobalname = 0x310; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iSentToClients = 0x318; // int32_t
    constexpr std::ptrdiff_t m_flSpeed = 0x31C; // float
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_spawnflags = 0x328; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x32C; // GameTick_t
    constexpr std::ptrdiff_t m_nSimulationTick = 0x330; // int32_t
    constexpr std::ptrdiff_t m_OnKilled = 0x338; // CEntityIOOutput
    constexpr std::ptrdiff_t m_fFlags = 0x360; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x364; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x370; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x3A0; // Vector
    constexpr std::ptrdiff_t m_nPushEnumCount = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_pCollision = 0x3B0; // CCollisionProperty*
    constexpr std::ptrdiff_t m_hEffectEntity = 0x3B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x3BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_fEffects = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x3C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x3C8; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x3CC; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x3D0; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x3D4; // float
    constexpr std::ptrdiff_t m_flWaterLevel = 0x3D8; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x3DC; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x3DD; // bool
    constexpr std::ptrdiff_t m_bDisableLowViolence = 0x3DE; // bool
    constexpr std::ptrdiff_t m_nWaterType = 0x3DF; // uint8_t
    constexpr std::ptrdiff_t m_iEFlags = 0x3E0; // int32_t
    constexpr std::ptrdiff_t m_OnUser1 = 0x3E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser2 = 0x410; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser3 = 0x438; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser4 = 0x460; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInitialTeamNum = 0x488; // int32_t
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x48C; // GameTime_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x490; // QAngle
    constexpr std::ptrdiff_t m_bNetworkQuantizeOriginAndAngles = 0x49C; // bool
    constexpr std::ptrdiff_t m_bLagCompensate = 0x49D; // bool
    constexpr std::ptrdiff_t m_flOverriddenFriction = 0x4A0; // float
    constexpr std::ptrdiff_t m_pBlocker = 0x4A4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLocalTime = 0x4A8; // float
    constexpr std::ptrdiff_t m_flVPhysicsUpdateLocalTime = 0x4AC; // float
}

namespace CBaseFilter { // CLogicalEntity
    constexpr std::ptrdiff_t m_bNegated = 0x4B0; // bool
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFail = 0x4E0; // CEntityIOOutput
}

namespace CBaseFire { // CBaseEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x4B4; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_nFlags = 0x4BC; // uint32_t
}

namespace CBaseFlex { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_flexWeight = 0x890; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0x8B4; // bool
    constexpr std::ptrdiff_t m_flAllowResponsesEndTime = 0x908; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFlexAnimationTime = 0x90C; // GameTime_t
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0x910; // uint32_t
    constexpr std::ptrdiff_t m_bUpdateLayerPriorities = 0x914; // bool
}

namespace CBaseFlexAlias_funCBaseFlex { // CBaseFlex
}

namespace CBaseGrenade { // CBaseFlex
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x928; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExplode = 0x950; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x978; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x979; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x97A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x97C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x980; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x984; // float
    constexpr std::ptrdiff_t m_flDamage = 0x988; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x998; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x9A4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x9BC; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x9C0; // CHandle<CCSPlayerPawn>
}

namespace CBaseIssue {
    constexpr std::ptrdiff_t m_szTypeString = 0x20; // char[64]
    constexpr std::ptrdiff_t m_szDetailsString = 0x60; // char[260]
    constexpr std::ptrdiff_t m_iNumYesVotes = 0x164; // int32_t
    constexpr std::ptrdiff_t m_iNumNoVotes = 0x168; // int32_t
    constexpr std::ptrdiff_t m_iNumPotentialVotes = 0x16C; // int32_t
    constexpr std::ptrdiff_t m_pVoteController = 0x170; // CVoteController*
}

namespace CBaseModelEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_CRenderComponent = 0x4B0; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0x4B8; // CHitboxComponent
    constexpr std::ptrdiff_t m_flDissolveStartTime = 0x4E0; // GameTime_t
    constexpr std::ptrdiff_t m_OnIgnite = 0x4E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nRenderMode = 0x510; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0x511; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0x512; // bool
    constexpr std::ptrdiff_t m_clrRender = 0x513; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0x518; // CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x568; // bool
    constexpr std::ptrdiff_t m_Collision = 0x570; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0x620; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0x678; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0x67C; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0x680; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0x684; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0x688; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0x68C; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0x690; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0x694; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0x6A0; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0x6AC; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0x6B0; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0x6B8; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0x6D0; // CNetworkViewOffsetVector
}

namespace CBaseMoveBehavior { // CPathKeyFrame
    constexpr std::ptrdiff_t m_iPositionInterpolator = 0x510; // int32_t
    constexpr std::ptrdiff_t m_iRotationInterpolator = 0x514; // int32_t
    constexpr std::ptrdiff_t m_flAnimStartTime = 0x518; // float
    constexpr std::ptrdiff_t m_flAnimEndTime = 0x51C; // float
    constexpr std::ptrdiff_t m_flAverageSpeedAcrossFrame = 0x520; // float
    constexpr std::ptrdiff_t m_pCurrentKeyFrame = 0x528; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pTargetKeyFrame = 0x530; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPreKeyFrame = 0x538; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPostKeyFrame = 0x540; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flTimeIntoFrame = 0x548; // float
    constexpr std::ptrdiff_t m_iDirection = 0x54C; // int32_t
}

namespace CBasePlatTrain { // CBaseToggle
    constexpr std::ptrdiff_t m_NoiseMoving = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_volume = 0x798; // float
    constexpr std::ptrdiff_t m_flTWidth = 0x79C; // float
    constexpr std::ptrdiff_t m_flTLength = 0x7A0; // float
}

namespace CBasePlayerController { // CBaseEntity
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x4B8; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x4C0; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x4F0; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x4F4; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x4F8; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x500; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x518; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x51C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // char[128]
    constexpr std::ptrdiff_t m_szNetworkIDString = 0x5A0; // CUtlString
    constexpr std::ptrdiff_t m_fLerpTime = 0x5A8; // float
    constexpr std::ptrdiff_t m_bLagCompensation = 0x5AC; // bool
    constexpr std::ptrdiff_t m_bPredict = 0x5AD; // bool
    constexpr std::ptrdiff_t m_bAutoKickDisabled = 0x5AE; // bool
    constexpr std::ptrdiff_t m_bIsLowViolence = 0x5AF; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x5B0; // bool
    constexpr std::ptrdiff_t m_nUsecTimestampLastUserCmdReceived = 0x640; // int64_t
    constexpr std::ptrdiff_t m_iIgnoreGlobalChat = 0x658; // ChatIgnoreType_t
    constexpr std::ptrdiff_t m_flLastPlayerTalkTime = 0x65C; // float
    constexpr std::ptrdiff_t m_flLastEntitySteadyState = 0x660; // float
    constexpr std::ptrdiff_t m_nAvailableEntitySteadyState = 0x664; // int32_t
    constexpr std::ptrdiff_t m_bHasAnySteadyStateEnts = 0x668; // bool
    constexpr std::ptrdiff_t m_steamID = 0x678; // uint64_t
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x680; // uint32_t
}

namespace CBasePlayerPawn { // CBaseCombatCharacter
    constexpr std::ptrdiff_t m_pWeaponServices = 0x9D0; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x9D8; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x9E0; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x9E8; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x9F0; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x9F8; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0xA00; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0xA08; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0xA10; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0xA20; // CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestGeneratedServerViewAngleChangeIndex = 0xA70; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0xA74; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0xA80; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0xA8C; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0xA90; // sky3dparams_t
    constexpr std::ptrdiff_t m_fTimeLastHurt = 0xB20; // GameTime_t
    constexpr std::ptrdiff_t m_flDeathTime = 0xB24; // GameTime_t
    constexpr std::ptrdiff_t m_fNextSuicideTime = 0xB28; // GameTime_t
    constexpr std::ptrdiff_t m_fInitHUD = 0xB2C; // bool
    constexpr std::ptrdiff_t m_pExpresser = 0xB30; // CAI_Expresser*
    constexpr std::ptrdiff_t m_hController = 0xB38; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_fHltvReplayDelay = 0xB40; // float
    constexpr std::ptrdiff_t m_fHltvReplayEnd = 0xB44; // float
    constexpr std::ptrdiff_t m_iHltvReplayEntity = 0xB48; // CEntityIndex
}

namespace CBasePlayerVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeapon { // CEconEntity
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0xC18; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0xC1C; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0xC20; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0xC24; // float
    constexpr std::ptrdiff_t m_iClip1 = 0xC28; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0xC30; // int32_t[2]
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xC38; // CEntityIOOutput
}

namespace CBasePlayerWeaponVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0x890; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0x894; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0x898; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0x89C; // matrix3x4_t
}

namespace CBasePropDoor { // CDynamicProp
    constexpr std::ptrdiff_t m_flAutoReturnDelay = 0xB18; // float
    constexpr std::ptrdiff_t m_hDoorList = 0xB20; // CUtlVector<CHandle<CBasePropDoor>>
    constexpr std::ptrdiff_t m_nHardwareType = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_bNeedsHardware = 0xB3C; // bool
    constexpr std::ptrdiff_t m_eDoorState = 0xB40; // DoorState_t
    constexpr std::ptrdiff_t m_bLocked = 0xB44; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0xB48; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0xB54; // QAngle
    constexpr std::ptrdiff_t m_hBlocker = 0xB60; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFirstBlocked = 0xB64; // bool
    constexpr std::ptrdiff_t m_ls = 0xB68; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0xB88; // bool
    constexpr std::ptrdiff_t m_vecLatchWorldPosition = 0xB8C; // Vector
    constexpr std::ptrdiff_t m_hActivator = 0xB98; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_SoundMoving = 0xBA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundOpen = 0xBB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundClose = 0xBB8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLock = 0xBC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundUnlock = 0xBC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLatch = 0xBD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundPound = 0xBD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundJiggle = 0xBE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLockedAnim = 0xBE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_numCloseAttempts = 0xBF0; // int32_t
    constexpr std::ptrdiff_t m_nPhysicsMaterial = 0xBF4; // CUtlStringToken
    constexpr std::ptrdiff_t m_SlaveName = 0xBF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMaster = 0xC00; // CHandle<CBasePropDoor>
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0xC08; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0xC30; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0xC58; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0xC80; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0xCA8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0xCD0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0xCF8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0xD20; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0xD48; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAjarOpen = 0xD70; // CEntityIOOutput
}

namespace CBaseToggle { // CBaseModelEntity
    constexpr std::ptrdiff_t m_toggle_state = 0x700; // TOGGLE_STATE
    constexpr std::ptrdiff_t m_flMoveDistance = 0x704; // float
    constexpr std::ptrdiff_t m_flWait = 0x708; // float
    constexpr std::ptrdiff_t m_flLip = 0x70C; // float
    constexpr std::ptrdiff_t m_bAlwaysFireBlockedOutputs = 0x710; // bool
    constexpr std::ptrdiff_t m_vecPosition1 = 0x714; // Vector
    constexpr std::ptrdiff_t m_vecPosition2 = 0x720; // Vector
    constexpr std::ptrdiff_t m_vecMoveAng = 0x72C; // QAngle
    constexpr std::ptrdiff_t m_vecAngle1 = 0x738; // QAngle
    constexpr std::ptrdiff_t m_vecAngle2 = 0x744; // QAngle
    constexpr std::ptrdiff_t m_flHeight = 0x750; // float
    constexpr std::ptrdiff_t m_hActivator = 0x754; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecFinalDest = 0x758; // Vector
    constexpr std::ptrdiff_t m_vecFinalAngle = 0x764; // QAngle
    constexpr std::ptrdiff_t m_movementType = 0x770; // int32_t
    constexpr std::ptrdiff_t m_sMaster = 0x778; // CUtlSymbolLarge
}

namespace CBaseTrigger { // CBaseToggle
    constexpr std::ptrdiff_t m_bDisabled = 0x780; // bool
    constexpr std::ptrdiff_t m_iFilterName = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x790; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnStartTouch = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouchAll = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouchAll = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTouching = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotTouching = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hTouchingEntities = 0x888; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0x8A0; // bool
}

namespace CBaseViewModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_vecLastFacing = 0x898; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x8A4; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0x8A8; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0x8AC; // float
    constexpr std::ptrdiff_t m_hWeapon = 0x8B0; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0x8C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0x8C8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0x8D0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0x8D4; // CHandle<CBaseEntity>
}

namespace CBeam { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flFrameRate = 0x700; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x704; // float
    constexpr std::ptrdiff_t m_flFireTime = 0x708; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0x70C; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0x710; // uint8_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0x728; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0x72C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0x730; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0x758; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0x764; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0x768; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0x76C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0x770; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0x774; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0x778; // float
    constexpr std::ptrdiff_t m_fSpeed = 0x77C; // float
    constexpr std::ptrdiff_t m_flFrame = 0x780; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0x784; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0x788; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0x78C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0x798; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nDissolveType = 0x79C; // int32_t
}

namespace CBlood { // CPointEntity
    constexpr std::ptrdiff_t m_vecSprayAngles = 0x4B0; // QAngle
    constexpr std::ptrdiff_t m_vecSprayDir = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_flAmount = 0x4C8; // float
    constexpr std::ptrdiff_t m_Color = 0x4CC; // int32_t
}

namespace CBodyComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x760; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint { // CBodyComponent
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance { // CBodyComponent
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnBombExplode = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombPlanted = 0x8D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsBombSiteB = 0x920; // bool
    constexpr std::ptrdiff_t m_bIsHeistBombTarget = 0x921; // bool
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0x922; // bool
    constexpr std::ptrdiff_t m_szMountTarget = 0x928; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hInstructorHint = 0x930; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nBombSiteDesignation = 0x934; // int32_t
}

namespace CBot {
    constexpr std::ptrdiff_t m_pController = 0x10; // CCSPlayerController*
    constexpr std::ptrdiff_t m_pPlayer = 0x18; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_bHasSpawned = 0x20; // bool
    constexpr std::ptrdiff_t m_id = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_isRunning = 0xB0; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xB1; // bool
    constexpr std::ptrdiff_t m_forwardSpeed = 0xB4; // float
    constexpr std::ptrdiff_t m_leftSpeed = 0xB8; // float
    constexpr std::ptrdiff_t m_verticalSpeed = 0xBC; // float
    constexpr std::ptrdiff_t m_buttonFlags = 0xC0; // uint64_t
    constexpr std::ptrdiff_t m_jumpTimestamp = 0xC8; // float
    constexpr std::ptrdiff_t m_viewForward = 0xCC; // Vector
    constexpr std::ptrdiff_t m_postureStackIndex = 0xE8; // int32_t
}

namespace CBreachCharge { // CCSWeaponBase
}

namespace CBreachChargeProjectile { // CBaseGrenade
}

namespace CBreakable { // CBaseModelEntity
    constexpr std::ptrdiff_t m_Material = 0x710; // Materials
    constexpr std::ptrdiff_t m_hBreaker = 0x714; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Explosion = 0x718; // Explosions
    constexpr std::ptrdiff_t m_iszSpawnObject = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPressureDelay = 0x728; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_iszPropData = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x738; // float
    constexpr std::ptrdiff_t m_nOverrideBlockLOS = 0x73C; // EOverrideBlockLOS_t
    constexpr std::ptrdiff_t m_OnBreak = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x768; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x790; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x794; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x798; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x79C; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x7B0; // int32_t
    constexpr std::ptrdiff_t m_PerformanceMode = 0x7B4; // PerformanceMode_t
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x7B8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x7BC; // GameTime_t
}

namespace CBreakableProp { // CBaseProp
    constexpr std::ptrdiff_t m_OnBreak = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x908; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x958; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_preferredCarryAngles = 0x960; // QAngle
    constexpr std::ptrdiff_t m_flPressureDelay = 0x96C; // float
    constexpr std::ptrdiff_t m_hBreaker = 0x970; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0x974; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x978; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x97C; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x980; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x984; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x988; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x998; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0x99C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x9A0; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0x9A4; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0x9A8; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0x9B0; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x9D8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x9DC; // GameTime_t
    constexpr std::ptrdiff_t m_bOriginalBlockLOS = 0x9E0; // bool
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x9E4; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0x9E8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0x9EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bUsePuntSound = 0x9F0; // bool
    constexpr std::ptrdiff_t m_iszPuntSound = 0x9F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_noGhostCollision = 0xA00; // bool
}

namespace CBreakableStageHelper {
    constexpr std::ptrdiff_t m_nCurrentStage = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStageCount = 0xC; // int32_t
}

namespace CBtActionAim { // CBtNode
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szAimReadyKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_flZoomCooldownTimestamp = 0x88; // float
    constexpr std::ptrdiff_t m_bDoneAiming = 0x8C; // bool
    constexpr std::ptrdiff_t m_flLerpStartTime = 0x90; // float
    constexpr std::ptrdiff_t m_flNextLookTargetLerpTime = 0x94; // float
    constexpr std::ptrdiff_t m_flPenaltyReductionRatio = 0x98; // float
    constexpr std::ptrdiff_t m_NextLookTarget = 0x9C; // QAngle
    constexpr std::ptrdiff_t m_AimTimer = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_SniperHoldTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_FocusIntervalTimer = 0xD8; // CountdownTimer
    constexpr std::ptrdiff_t m_bAcquired = 0xF0; // bool
}

namespace CBtActionCombatPositioning { // CBtNode
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szIsAttackingKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_ActionTimer = 0x88; // CountdownTimer
    constexpr std::ptrdiff_t m_bCrouching = 0xA0; // bool
}

namespace CBtActionMoveTo { // CBtNode
    constexpr std::ptrdiff_t m_szDestinationInputKey = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_szHidingSpotInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szThreatInputKey = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_vecDestination = 0x78; // Vector
    constexpr std::ptrdiff_t m_bAutoLookAdjust = 0x84; // bool
    constexpr std::ptrdiff_t m_bComputePath = 0x85; // bool
    constexpr std::ptrdiff_t m_flDamagingAreasPenaltyCost = 0x88; // float
    constexpr std::ptrdiff_t m_CheckApproximateCornersTimer = 0x90; // CountdownTimer
    constexpr std::ptrdiff_t m_CheckHighPriorityItem = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_RepathTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_flArrivalEpsilon = 0xD8; // float
    constexpr std::ptrdiff_t m_flAdditionalArrivalEpsilon2D = 0xDC; // float
    constexpr std::ptrdiff_t m_flHidingSpotCheckDistanceThreshold = 0xE0; // float
    constexpr std::ptrdiff_t m_flNearestAreaDistanceThreshold = 0xE4; // float
}

namespace CBtActionParachutePositioning { // CBtNode
    constexpr std::ptrdiff_t m_ActionTimer = 0x58; // CountdownTimer
}

namespace CBtNode {
}

namespace CBtNodeComposite { // CBtNode
}

namespace CBtNodeCondition { // CBtNodeDecorator
    constexpr std::ptrdiff_t m_bNegated = 0x58; // bool
}

namespace CBtNodeConditionInactive { // CBtNodeCondition
    constexpr std::ptrdiff_t m_flRoundStartThresholdSeconds = 0x78; // float
    constexpr std::ptrdiff_t m_flSensorInactivityThresholdSeconds = 0x7C; // float
    constexpr std::ptrdiff_t m_SensorInactivityTimer = 0x80; // CountdownTimer
}

namespace CBtNodeDecorator { // CBtNode
}

namespace CBubbling { // CBaseModelEntity
    constexpr std::ptrdiff_t m_density = 0x700; // int32_t
    constexpr std::ptrdiff_t m_frequency = 0x704; // int32_t
    constexpr std::ptrdiff_t m_state = 0x708; // int32_t
}

namespace CBumpMine { // CCSWeaponBase
}

namespace CBumpMineProjectile { // CBaseGrenade
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CBuyZone { // CBaseTrigger
    constexpr std::ptrdiff_t m_LegacyTeamNum = 0x8A8; // int32_t
}

namespace CC4 { // CCSWeaponBase
    constexpr std::ptrdiff_t m_vecLastValidPlayerHeldPosition = 0xE18; // Vector
    constexpr std::ptrdiff_t m_vecLastValidDroppedPosition = 0xE24; // Vector
    constexpr std::ptrdiff_t m_bDoValidDroppedPositionCheck = 0xE30; // bool
    constexpr std::ptrdiff_t m_bStartedArming = 0xE31; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0xE34; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0xE38; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0xE39; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE40; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xE58; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0xE5C; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0xE63; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0xE64; // bool
}

namespace CCSBot { // CBot
    constexpr std::ptrdiff_t m_lastCoopSpawnPoint = 0xF0; // CHandle<SpawnPointCoopEnemy>
    constexpr std::ptrdiff_t m_eyePosition = 0x100; // Vector
    constexpr std::ptrdiff_t m_name = 0x10C; // char[64]
    constexpr std::ptrdiff_t m_combatRange = 0x14C; // float
    constexpr std::ptrdiff_t m_isRogue = 0x150; // bool
    constexpr std::ptrdiff_t m_rogueTimer = 0x158; // CountdownTimer
    constexpr std::ptrdiff_t m_diedLastRound = 0x174; // bool
    constexpr std::ptrdiff_t m_safeTime = 0x178; // float
    constexpr std::ptrdiff_t m_wasSafe = 0x17C; // bool
    constexpr std::ptrdiff_t m_blindFire = 0x184; // bool
    constexpr std::ptrdiff_t m_surpriseTimer = 0x188; // CountdownTimer
    constexpr std::ptrdiff_t m_bAllowActive = 0x1A0; // bool
    constexpr std::ptrdiff_t m_isFollowing = 0x1A1; // bool
    constexpr std::ptrdiff_t m_leader = 0x1A4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_followTimestamp = 0x1A8; // float
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0x1AC; // float
    constexpr std::ptrdiff_t m_hurryTimer = 0x1B0; // CountdownTimer
    constexpr std::ptrdiff_t m_alertTimer = 0x1C8; // CountdownTimer
    constexpr std::ptrdiff_t m_sneakTimer = 0x1E0; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x1F8; // CountdownTimer
    constexpr std::ptrdiff_t m_stateTimestamp = 0x4C8; // float
    constexpr std::ptrdiff_t m_isAttacking = 0x4CC; // bool
    constexpr std::ptrdiff_t m_isOpeningDoor = 0x4CD; // bool
    constexpr std::ptrdiff_t m_taskEntity = 0x4D4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_goalPosition = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_goalEntity = 0x4F0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoid = 0x4F4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoidTimestamp = 0x4F8; // float
    constexpr std::ptrdiff_t m_isStopping = 0x4FC; // bool
    constexpr std::ptrdiff_t m_hasVisitedEnemySpawn = 0x4FD; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0x500; // IntervalTimer
    constexpr std::ptrdiff_t m_bEyeAnglesUnderPathFinderControl = 0x510; // bool
    constexpr std::ptrdiff_t m_pathIndex = 0x6608; // int32_t
    constexpr std::ptrdiff_t m_areaEnteredTimestamp = 0x660C; // GameTime_t
    constexpr std::ptrdiff_t m_repathTimer = 0x6610; // CountdownTimer
    constexpr std::ptrdiff_t m_avoidFriendTimer = 0x6628; // CountdownTimer
    constexpr std::ptrdiff_t m_isFriendInTheWay = 0x6640; // bool
    constexpr std::ptrdiff_t m_politeTimer = 0x6648; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingBehindFriend = 0x6660; // bool
    constexpr std::ptrdiff_t m_pathLadderEnd = 0x668C; // float
    constexpr std::ptrdiff_t m_mustRunTimer = 0x66D8; // CountdownTimer
    constexpr std::ptrdiff_t m_waitTimer = 0x66F0; // CountdownTimer
    constexpr std::ptrdiff_t m_updateTravelDistanceTimer = 0x6708; // CountdownTimer
    constexpr std::ptrdiff_t m_playerTravelDistance = 0x6720; // float[64]
    constexpr std::ptrdiff_t m_travelDistancePhase = 0x6820; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCount = 0x69B8; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCountTimestamp = 0x69BC; // float
    constexpr std::ptrdiff_t m_desiredTeam = 0x69C0; // int32_t
    constexpr std::ptrdiff_t m_hasJoined = 0x69C4; // bool
    constexpr std::ptrdiff_t m_isWaitingForHostage = 0x69C5; // bool
    constexpr std::ptrdiff_t m_inhibitWaitingForHostageTimer = 0x69C8; // CountdownTimer
    constexpr std::ptrdiff_t m_waitForHostageTimer = 0x69E0; // CountdownTimer
    constexpr std::ptrdiff_t m_noisePosition = 0x69F8; // Vector
    constexpr std::ptrdiff_t m_noiseTravelDistance = 0x6A04; // float
    constexpr std::ptrdiff_t m_noiseTimestamp = 0x6A08; // float
    constexpr std::ptrdiff_t m_noiseSource = 0x6A10; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_noiseBendTimer = 0x6A28; // CountdownTimer
    constexpr std::ptrdiff_t m_bentNoisePosition = 0x6A40; // Vector
    constexpr std::ptrdiff_t m_bendNoisePositionValid = 0x6A4C; // bool
    constexpr std::ptrdiff_t m_lookAroundStateTimestamp = 0x6A50; // float
    constexpr std::ptrdiff_t m_lookAheadAngle = 0x6A54; // float
    constexpr std::ptrdiff_t m_forwardAngle = 0x6A58; // float
    constexpr std::ptrdiff_t m_inhibitLookAroundTimestamp = 0x6A5C; // float
    constexpr std::ptrdiff_t m_lookAtSpot = 0x6A64; // Vector
    constexpr std::ptrdiff_t m_lookAtSpotDuration = 0x6A74; // float
    constexpr std::ptrdiff_t m_lookAtSpotTimestamp = 0x6A78; // float
    constexpr std::ptrdiff_t m_lookAtSpotAngleTolerance = 0x6A7C; // float
    constexpr std::ptrdiff_t m_lookAtSpotClearIfClose = 0x6A80; // bool
    constexpr std::ptrdiff_t m_lookAtSpotAttack = 0x6A81; // bool
    constexpr std::ptrdiff_t m_lookAtDesc = 0x6A88; // char*
    constexpr std::ptrdiff_t m_peripheralTimestamp = 0x6A90; // float
    constexpr std::ptrdiff_t m_approachPointCount = 0x6C18; // uint8_t
    constexpr std::ptrdiff_t m_approachPointViewPosition = 0x6C1C; // Vector
    constexpr std::ptrdiff_t m_viewSteadyTimer = 0x6C28; // IntervalTimer
    constexpr std::ptrdiff_t m_tossGrenadeTimer = 0x6C40; // CountdownTimer
    constexpr std::ptrdiff_t m_isAvoidingGrenade = 0x6C60; // CountdownTimer
    constexpr std::ptrdiff_t m_spotCheckTimestamp = 0x6C80; // float
    constexpr std::ptrdiff_t m_checkedHidingSpotCount = 0x7088; // int32_t
    constexpr std::ptrdiff_t m_lookPitch = 0x708C; // float
    constexpr std::ptrdiff_t m_lookPitchVel = 0x7090; // float
    constexpr std::ptrdiff_t m_lookYaw = 0x7094; // float
    constexpr std::ptrdiff_t m_lookYawVel = 0x7098; // float
    constexpr std::ptrdiff_t m_targetSpot = 0x709C; // Vector
    constexpr std::ptrdiff_t m_targetSpotVelocity = 0x70A8; // Vector
    constexpr std::ptrdiff_t m_targetSpotPredicted = 0x70B4; // Vector
    constexpr std::ptrdiff_t m_aimError = 0x70C0; // QAngle
    constexpr std::ptrdiff_t m_aimGoal = 0x70CC; // QAngle
    constexpr std::ptrdiff_t m_targetSpotTime = 0x70D8; // GameTime_t
    constexpr std::ptrdiff_t m_aimFocus = 0x70DC; // float
    constexpr std::ptrdiff_t m_aimFocusInterval = 0x70E0; // float
    constexpr std::ptrdiff_t m_aimFocusNextUpdate = 0x70E4; // GameTime_t
    constexpr std::ptrdiff_t m_ignoreEnemiesTimer = 0x70F0; // CountdownTimer
    constexpr std::ptrdiff_t m_enemy = 0x7108; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_isEnemyVisible = 0x710C; // bool
    constexpr std::ptrdiff_t m_visibleEnemyParts = 0x710D; // uint8_t
    constexpr std::ptrdiff_t m_lastEnemyPosition = 0x7110; // Vector
    constexpr std::ptrdiff_t m_lastSawEnemyTimestamp = 0x711C; // float
    constexpr std::ptrdiff_t m_firstSawEnemyTimestamp = 0x7120; // float
    constexpr std::ptrdiff_t m_currentEnemyAcquireTimestamp = 0x7124; // float
    constexpr std::ptrdiff_t m_enemyDeathTimestamp = 0x7128; // float
    constexpr std::ptrdiff_t m_friendDeathTimestamp = 0x712C; // float
    constexpr std::ptrdiff_t m_isLastEnemyDead = 0x7130; // bool
    constexpr std::ptrdiff_t m_nearbyEnemyCount = 0x7134; // int32_t
    constexpr std::ptrdiff_t m_bomber = 0x7340; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nearbyFriendCount = 0x7344; // int32_t
    constexpr std::ptrdiff_t m_closestVisibleFriend = 0x7348; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_closestVisibleHumanFriend = 0x734C; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attentionInterval = 0x7350; // IntervalTimer
    constexpr std::ptrdiff_t m_attacker = 0x7360; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attackedTimestamp = 0x7364; // float
    constexpr std::ptrdiff_t m_burnedByFlamesTimer = 0x7368; // IntervalTimer
    constexpr std::ptrdiff_t m_lastVictimID = 0x7378; // int32_t
    constexpr std::ptrdiff_t m_isAimingAtEnemy = 0x737C; // bool
    constexpr std::ptrdiff_t m_isRapidFiring = 0x737D; // bool
    constexpr std::ptrdiff_t m_equipTimer = 0x7380; // IntervalTimer
    constexpr std::ptrdiff_t m_zoomTimer = 0x7390; // CountdownTimer
    constexpr std::ptrdiff_t m_fireWeaponTimestamp = 0x73A8; // GameTime_t
    constexpr std::ptrdiff_t m_lookForWeaponsOnGroundTimer = 0x73B0; // CountdownTimer
    constexpr std::ptrdiff_t m_bIsSleeping = 0x73C8; // bool
    constexpr std::ptrdiff_t m_isEnemySniperVisible = 0x73C9; // bool
    constexpr std::ptrdiff_t m_sawEnemySniperTimer = 0x73D0; // CountdownTimer
    constexpr std::ptrdiff_t m_enemyQueueIndex = 0x7488; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueCount = 0x7489; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueAttendIndex = 0x748A; // uint8_t
    constexpr std::ptrdiff_t m_isStuck = 0x748B; // bool
    constexpr std::ptrdiff_t m_stuckTimestamp = 0x748C; // GameTime_t
    constexpr std::ptrdiff_t m_stuckSpot = 0x7490; // Vector
    constexpr std::ptrdiff_t m_wiggleTimer = 0x74A0; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckJumpTimer = 0x74B8; // CountdownTimer
    constexpr std::ptrdiff_t m_nextCleanupCheckTimestamp = 0x74D0; // GameTime_t
    constexpr std::ptrdiff_t m_avgVel = 0x74D4; // float[10]
    constexpr std::ptrdiff_t m_avgVelIndex = 0x74FC; // int32_t
    constexpr std::ptrdiff_t m_avgVelCount = 0x7500; // int32_t
    constexpr std::ptrdiff_t m_lastOrigin = 0x7504; // Vector
    constexpr std::ptrdiff_t m_lastRadioRecievedTimestamp = 0x7514; // float
    constexpr std::ptrdiff_t m_lastRadioSentTimestamp = 0x7518; // float
    constexpr std::ptrdiff_t m_radioSubject = 0x751C; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_radioPosition = 0x7520; // Vector
    constexpr std::ptrdiff_t m_voiceEndTimestamp = 0x752C; // float
    constexpr std::ptrdiff_t m_lastValidReactionQueueFrame = 0x7538; // int32_t
}

namespace CCSGOPlayerAnimGraphState {
}

namespace CCSGOViewModel { // CPredictedViewModel
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0x8D8; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0x8DC; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0x8E0; // uint32_t
}

namespace CCSGO_TeamIntroCharacterPosition { // CCSGO_TeamPreviewCharacterPosition
}

namespace CCSGO_TeamIntroCounterTerroristPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_TeamIntroTerroristPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_TeamPreviewCharacterPosition { // CBaseEntity
    constexpr std::ptrdiff_t m_nVariant = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x4C0; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x4C8; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x4D0; // CEconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x748; // CEconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0x9C0; // CEconItemView
}

namespace CCSGO_TeamSelectCharacterPosition { // CCSGO_TeamPreviewCharacterPosition
}

namespace CCSGO_TeamSelectCounterTerroristPosition { // CCSGO_TeamSelectCharacterPosition
}

namespace CCSGO_TeamSelectTerroristPosition { // CCSGO_TeamSelectCharacterPosition
}

namespace CCSGO_WingmanIntroCharacterPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_WingmanIntroCounterTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGO_WingmanIntroTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch { // CCSGameModeRules
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSGameModeRules_Noop { // CCSGameModeRules
}

namespace CCSGameModeRules_Scripted { // CCSGameModeRules
}

namespace CCSGameModeScript { // CBasePulseGraphInstance
}

namespace CCSGameRules { // CTeamplayRules
    constexpr std::ptrdiff_t __m_pChainEntity = 0x98; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_coopMissionManager = 0xC0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFreezePeriod = 0xC4; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0xC5; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0xD0; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0xD8; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0xD9; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0xDA; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0xDB; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0xDC; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0xE0; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0xEC; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0xED; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0xF4; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0xF8; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0xFC; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x100; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x104; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x108; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x118; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x11C; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x120; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x121; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x122; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x123; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x124; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x128; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x12C; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x12D; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x12E; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x130; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0x134; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0x138; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0x13C; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0x140; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x340; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x540; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x740; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x940; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x944; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x948; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x94C; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x94D; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x94E; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x950; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x954; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x958; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x960; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x964; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x968; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x96C; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x970; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x980; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x990; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0xA58; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0xA70; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0xA71; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0xA74; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0xA78; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0xA7C; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0xA7D; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0xA80; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0xA84; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xAFC; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xB74; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xBEC; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xC6C; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xCF0; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xCFC; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xD08; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xD28; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xD29; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xD2C; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xD54; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xD7C; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xD80; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xD84; // int32_t
    constexpr std::ptrdiff_t m_bHasHostageBeenTouched = 0xDA0; // bool
    constexpr std::ptrdiff_t m_flIntermissionStartTime = 0xDA4; // GameTime_t
    constexpr std::ptrdiff_t m_flIntermissionEndTime = 0xDA8; // GameTime_t
    constexpr std::ptrdiff_t m_bLevelInitialized = 0xDAC; // bool
    constexpr std::ptrdiff_t m_iTotalRoundsPlayed = 0xDB0; // int32_t
    constexpr std::ptrdiff_t m_iUnBalancedRounds = 0xDB4; // int32_t
    constexpr std::ptrdiff_t m_endMatchOnRoundReset = 0xDB8; // bool
    constexpr std::ptrdiff_t m_endMatchOnThink = 0xDB9; // bool
    constexpr std::ptrdiff_t m_iFreezeTime = 0xDBC; // int32_t
    constexpr std::ptrdiff_t m_iNumTerrorist = 0xDC0; // int32_t
    constexpr std::ptrdiff_t m_iNumCT = 0xDC4; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableTerrorist = 0xDC8; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableCT = 0xDCC; // int32_t
    constexpr std::ptrdiff_t m_arrSelectedHostageSpawnIndices = 0xDD0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bFirstConnected = 0xDE8; // bool
    constexpr std::ptrdiff_t m_bCompleteReset = 0xDE9; // bool
    constexpr std::ptrdiff_t m_bPickNewTeamsOnReset = 0xDEA; // bool
    constexpr std::ptrdiff_t m_bScrambleTeamsOnRestart = 0xDEB; // bool
    constexpr std::ptrdiff_t m_bSwapTeamsOnRestart = 0xDEC; // bool
    constexpr std::ptrdiff_t m_nEndMatchTiedVotes = 0xDF8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bNeedToAskPlayersForContinueVote = 0xE14; // bool
    constexpr std::ptrdiff_t m_numQueuedMatchmakingAccounts = 0xE18; // uint32_t
    constexpr std::ptrdiff_t m_pQueuedMatchmakingReservationString = 0xE20; // char*
    constexpr std::ptrdiff_t m_numTotalTournamentDrops = 0xE28; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMax = 0xE2C; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxTV = 0xE30; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxLnk = 0xE34; // uint32_t
    constexpr std::ptrdiff_t m_bForceTeamChangeSilent = 0xE40; // bool
    constexpr std::ptrdiff_t m_bLoadingRoundBackupData = 0xE41; // bool
    constexpr std::ptrdiff_t m_nMatchInfoShowType = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flMatchInfoDecidedTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flCoopRespawnAndHealTime = 0xE98; // float
    constexpr std::ptrdiff_t m_coopBonusCoinsFound = 0xE9C; // int32_t
    constexpr std::ptrdiff_t m_coopBonusPistolsOnly = 0xEA0; // bool
    constexpr std::ptrdiff_t m_coopPlayersInDeploymentZone = 0xEA1; // bool
    constexpr std::ptrdiff_t m_coopMissionDeadPlayerRespawnEnabled = 0xEA2; // bool
    constexpr std::ptrdiff_t mTeamDMLastWinningTeamNumber = 0xEA4; // int32_t
    constexpr std::ptrdiff_t mTeamDMLastThinkTime = 0xEA8; // float
    constexpr std::ptrdiff_t m_flTeamDMLastAnnouncementTime = 0xEAC; // float
    constexpr std::ptrdiff_t m_iAccountTerrorist = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iAccountCT = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_Terrorist = 0xEB8; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_CT = 0xEBC; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumTerrorists = 0xEC0; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumCTs = 0xEC4; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonus = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonusMostRecentTeam = 0xECC; // int32_t
    constexpr std::ptrdiff_t m_tmNextPeriodicThink = 0xED0; // float
    constexpr std::ptrdiff_t m_bVoiceWonMatchBragFired = 0xED4; // bool
    constexpr std::ptrdiff_t m_fWarmupNextChatNoticeTime = 0xED8; // float
    constexpr std::ptrdiff_t m_iHostagesRescued = 0xEE0; // int32_t
    constexpr std::ptrdiff_t m_iHostagesTouched = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_flNextHostageAnnouncement = 0xEE8; // float
    constexpr std::ptrdiff_t m_bNoTerroristsKilled = 0xEEC; // bool
    constexpr std::ptrdiff_t m_bNoCTsKilled = 0xEED; // bool
    constexpr std::ptrdiff_t m_bNoEnemiesKilled = 0xEEE; // bool
    constexpr std::ptrdiff_t m_bCanDonateWeapons = 0xEEF; // bool
    constexpr std::ptrdiff_t m_firstKillTime = 0xEF4; // float
    constexpr std::ptrdiff_t m_firstBloodTime = 0xEFC; // float
    constexpr std::ptrdiff_t m_hostageWasInjured = 0xF18; // bool
    constexpr std::ptrdiff_t m_hostageWasKilled = 0xF19; // bool
    constexpr std::ptrdiff_t m_bVoteCalled = 0xF28; // bool
    constexpr std::ptrdiff_t m_bServerVoteOnReset = 0xF29; // bool
    constexpr std::ptrdiff_t m_flVoteCheckThrottle = 0xF2C; // float
    constexpr std::ptrdiff_t m_bBuyTimeEnded = 0xF30; // bool
    constexpr std::ptrdiff_t m_nLastFreezeEndBeep = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_bTargetBombed = 0xF38; // bool
    constexpr std::ptrdiff_t m_bBombDefused = 0xF39; // bool
    constexpr std::ptrdiff_t m_bMapHasBombZone = 0xF3A; // bool
    constexpr std::ptrdiff_t m_vecMainCTSpawnPos = 0xF58; // Vector
    constexpr std::ptrdiff_t m_CTSpawnPointsMasterList = 0xF68; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPointsMasterList = 0xF80; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_iNextCTSpawnPoint = 0xF98; // int32_t
    constexpr std::ptrdiff_t m_iNextTerroristSpawnPoint = 0xF9C; // int32_t
    constexpr std::ptrdiff_t m_CTSpawnPoints = 0xFA0; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPoints = 0xFB8; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_bIsUnreservedGameServer = 0xFD0; // bool
    constexpr std::ptrdiff_t m_fAutobalanceDisplayTime = 0xFD4; // float
    constexpr std::ptrdiff_t m_bAllowWeaponSwitch = 0x1240; // bool
    constexpr std::ptrdiff_t m_bRoundTimeWarningTriggered = 0x1241; // bool
    constexpr std::ptrdiff_t m_phaseChangeAnnouncementTime = 0x1244; // GameTime_t
    constexpr std::ptrdiff_t m_fNextUpdateTeamClanNamesTime = 0x1248; // float
    constexpr std::ptrdiff_t m_flLastThinkTime = 0x124C; // GameTime_t
    constexpr std::ptrdiff_t m_fAccumulatedRoundOffDamage = 0x1250; // float
    constexpr std::ptrdiff_t m_nShorthandedBonusLastEvalRound = 0x1254; // int32_t
    constexpr std::ptrdiff_t m_bMatchAbortedDueToPlayerBan = 0x14D0; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0x14D1; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0x14D2; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0x14D3; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0x14F0; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_BtGlobalBlackboard = 0x14F8; // KeyValues3
    constexpr std::ptrdiff_t m_hPlayerResource = 0x1560; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_RetakeRules = 0x1568; // CRetakeGameRules
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMax = 0x174C; // int32_t
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMin = 0x1750; // int32_t
    constexpr std::ptrdiff_t m_arrTeamUniqueKillWeaponsMatch = 0x1758; // CUtlVector<int32_t>[4]
    constexpr std::ptrdiff_t m_bTeamLastKillUsedUniqueWeaponMatch = 0x17B8; // bool[4]
    constexpr std::ptrdiff_t m_nMatchEndCount = 0x17E0; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0x17E4; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0x17E8; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0x17EC; // bool
    constexpr std::ptrdiff_t m_fTeamIntroPeriodEnd = 0x17F0; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayedTeamIntroVO = 0x17F4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x5800; // double
    constexpr std::ptrdiff_t m_bSkipNextServerPerfSample = 0x5808; // bool
}

namespace CCSGameRulesProxy { // CGameRulesProxy
    constexpr std::ptrdiff_t m_pGameRules = 0x4B0; // CCSGameRules*
}

namespace CCSMinimapBoundary { // CBaseEntity
}

namespace CCSObserverPawn { // CCSPlayerPawnBase
}

namespace CCSObserver_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSObserver_MovementServices { // CPlayer_MovementServices
}

namespace CCSObserver_ObserverServices { // CPlayer_ObserverServices
}

namespace CCSObserver_UseServices { // CPlayer_UseServices
}

namespace CCSObserver_ViewModelServices { // CPlayer_ViewModelServices
}

namespace CCSPlace { // CServerOnlyModelEntity
    constexpr std::ptrdiff_t m_name = 0x708; // CUtlSymbolLarge
}

namespace CCSPlayerBase_CameraServices { // CPlayer_CameraServices
    constexpr std::ptrdiff_t m_iFOV = 0x170; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x174; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x178; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x17C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x180; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTriggerFogList = 0x188; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_hLastFogTrigger = 0x1A0; // CHandle<CBaseEntity>
}

namespace CCSPlayerController { // CBasePlayerController
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x6B0; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x6B8; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x6C0; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x6C8; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x6D0; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x6D4; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x6D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x6E0; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x6E4; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x6E8; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x6EC; // bool
    constexpr std::ptrdiff_t m_bAttemptedToGetColor = 0x6ED; // bool
    constexpr std::ptrdiff_t m_iTeammatePreferredColor = 0x6F0; // int32_t
    constexpr std::ptrdiff_t m_bTeamChanged = 0x6F4; // bool
    constexpr std::ptrdiff_t m_bInSwitchTeam = 0x6F5; // bool
    constexpr std::ptrdiff_t m_bHasSeenJoinGame = 0x6F6; // bool
    constexpr std::ptrdiff_t m_bJustBecameSpectator = 0x6F7; // bool
    constexpr std::ptrdiff_t m_bSwitchTeamsOnNextRoundReset = 0x6F8; // bool
    constexpr std::ptrdiff_t m_bRemoveAllItemsOnNextRoundReset = 0x6F9; // bool
    constexpr std::ptrdiff_t m_szClan = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szClanName = 0x708; // char[32]
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x728; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x730; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x738; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x740; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x744; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x748; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x750; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x754; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x758; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x75C; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x760; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x764; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x790; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x794; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x798; // uint32_t
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x79C; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x79D; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x79E; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x79F; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7A0; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7A4; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7B0; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7B1; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7B2; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7B4; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7B8; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7BC; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7C0; // CHandle<CCSObserverPawn>
    constexpr std::ptrdiff_t m_DesiredObserverMode = 0x7C4; // int32_t
    constexpr std::ptrdiff_t m_hDesiredObserverTarget = 0x7C8; // CEntityHandle
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7CC; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7D0; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7D4; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x7D8; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x7D9; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x7DA; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x7DC; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x7E8; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x7EC; // int32_t
    constexpr std::ptrdiff_t m_iRoundScore = 0x7F0; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWon = 0x7F4; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x7F8; // CNetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x810; // int32_t
    constexpr std::ptrdiff_t m_nUpdateCounter = 0x814; // int32_t
    constexpr std::ptrdiff_t m_flSmoothedPing = 0x818; // float
    constexpr std::ptrdiff_t m_lastHeldVoteTimer = 0xF8C0; // IntervalTimer
    constexpr std::ptrdiff_t m_bShowHints = 0xF8D8; // bool
    constexpr std::ptrdiff_t m_iNextTimeCheck = 0xF8DC; // int32_t
    constexpr std::ptrdiff_t m_bJustDidTeamKill = 0xF8E0; // bool
    constexpr std::ptrdiff_t m_bPunishForTeamKill = 0xF8E1; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarning = 0xF8E2; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarningThisRound = 0xF8E3; // bool
    constexpr std::ptrdiff_t m_LastTeamDamageWarningTime = 0xF8E4; // GameTime_t
}

namespace CCSPlayerController_ActionTrackingServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x148; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x14C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x150; // uint32_t
}

namespace CCSPlayerController_DamageServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // CUtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_bReceivesMoneyNextRound = 0x40; // bool
    constexpr std::ptrdiff_t m_iAccountMoneyEarnedForNextRound = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iAccount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x54; // int32_t
}

namespace CCSPlayerController_InventoryServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_unEquippedPlayerSprayIDs = 0xF48; // uint32_t[1]
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0xF50; // CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayerPawn { // CCSPlayerPawnBase
    constexpr std::ptrdiff_t m_pBulletServices = 0x1550; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x1558; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x1560; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x1568; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pRadioServices = 0x1570; // CCSPlayer_RadioServices*
    constexpr std::ptrdiff_t m_pDamageReactServices = 0x1578; // CCSPlayer_DamageReactServices*
    constexpr std::ptrdiff_t m_nCharacterDefIndex = 0x1580; // uint16_t
    constexpr std::ptrdiff_t m_hPreviousModel = 0x1588; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x1590; // bool
    constexpr std::ptrdiff_t m_strVOPrefix = 0x1598; // CUtlString
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x15A0; // char[18]
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1660; // bool
    constexpr std::ptrdiff_t m_bWasInBuyZone = 0x1661; // bool
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1662; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1663; // bool
    constexpr std::ptrdiff_t m_bWasInHostageRescueZone = 0x1664; // bool
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1668; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x166C; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1670; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1671; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x1674; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1678; // loadout_slot_t
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x167C; // GameTime_t
    constexpr std::ptrdiff_t m_flLandseconds = 0x1680; // float
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1684; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1690; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x169C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x16A0; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x16A8; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x16C0; // bool
    constexpr std::ptrdiff_t m_xLastHeadBoneTransform = 0x1C30; // CTransform
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x1C50; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x1C54; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x1C58; // bool
    constexpr std::ptrdiff_t m_iPlayerLocked = 0x1C5C; // int32_t
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1C64; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1C68; // GameTime_t
    constexpr std::ptrdiff_t m_bNextSprayDecalTimeExpedited = 0x1C6C; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1C70; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1C74; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1C80; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1C8C; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1CCC; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1CD0; // Vector
    constexpr std::ptrdiff_t m_EconGloves = 0x1CE0; // CEconItemView
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x1F58; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x1F64; // bool
}

namespace CCSPlayerPawnBase { // CBasePlayerPawn
    constexpr std::ptrdiff_t m_CTouchExpansionComponent = 0xB68; // CTouchExpansionComponent
    constexpr std::ptrdiff_t m_pPingServices = 0xBB8; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0xBC0; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_iDisplayHistoryBits = 0xBC8; // uint32_t
    constexpr std::ptrdiff_t m_flLastAttackedTeammate = 0xBCC; // float
    constexpr std::ptrdiff_t m_hOriginalController = 0xBD0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_blindUntilTime = 0xBD4; // GameTime_t
    constexpr std::ptrdiff_t m_blindStartTime = 0xBD8; // GameTime_t
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0xBDC; // GameTime_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xBE0; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xBF8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerState = 0xBFC; // CSPlayerState
    constexpr std::ptrdiff_t m_chickenIdleSoundTimer = 0xC08; // CountdownTimer
    constexpr std::ptrdiff_t m_chickenJumpSoundTimer = 0xC20; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastBookmarkedPosition = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_flLastDistanceTraveledNotice = 0xCE4; // float
    constexpr std::ptrdiff_t m_flAccumulatedDistanceTraveled = 0xCE8; // float
    constexpr std::ptrdiff_t m_flLastFriendlyFireDamageReductionRatio = 0xCEC; // float
    constexpr std::ptrdiff_t m_bRespawning = 0xCF0; // bool
    constexpr std::ptrdiff_t m_nLastPickupPriority = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flLastPickupPriorityTime = 0xCF8; // float
    constexpr std::ptrdiff_t m_bIsScoped = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0xCFD; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0xCFE; // bool
    constexpr std::ptrdiff_t m_bIsDefusing = 0xCFF; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0xD00; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0xD04; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0xD08; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0xD0C; // bool
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0xD10; // float
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0xD14; // bool
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0xD15; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0xD18; // float
    constexpr std::ptrdiff_t m_flNextGuardianTooFarHurtTime = 0xD1C; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0xD20; // GameTime_t
    constexpr std::ptrdiff_t m_flDealtDamageToEnemyMostRecentTimestamp = 0xD24; // float
    constexpr std::ptrdiff_t m_flLastEquippedHelmetTime = 0xD28; // GameTime_t
    constexpr std::ptrdiff_t m_flLastEquippedArmorTime = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_bResetArmorNextSpawn = 0xD34; // bool
    constexpr std::ptrdiff_t m_flLastBumpMineBumpTime = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0xD3C; // GameTime_t
    constexpr std::ptrdiff_t m_iNumSpawns = 0xD40; // int32_t
    constexpr std::ptrdiff_t m_iShouldHaveCash = 0xD44; // int32_t
    constexpr std::ptrdiff_t m_bInvalidSteamLogonDelayed = 0xD48; // bool
    constexpr std::ptrdiff_t m_flLastAction = 0xD4C; // GameTime_t
    constexpr std::ptrdiff_t m_flNameChangeHistory = 0xD50; // float[5]
    constexpr std::ptrdiff_t m_fLastGivenDefuserTime = 0xD64; // float
    constexpr std::ptrdiff_t m_fLastGivenBombTime = 0xD68; // float
    constexpr std::ptrdiff_t m_bHasNightVision = 0xD6C; // bool
    constexpr std::ptrdiff_t m_bNightVisionOn = 0xD6D; // bool
    constexpr std::ptrdiff_t m_fNextRadarUpdateTime = 0xD70; // float
    constexpr std::ptrdiff_t m_flLastMoneyUpdateTime = 0xD74; // float
    constexpr std::ptrdiff_t m_MenuStringBuffer = 0xD78; // char[1024]
    constexpr std::ptrdiff_t m_fIntroCamTime = 0x1178; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x117C; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x1180; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x1181; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x1184; // int32_t
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x1188; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x118C; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x1190; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x119C; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x11A8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x11B4; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x11CC; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x11E4; // Vector[2]
    constexpr std::ptrdiff_t m_bDiedAirborne = 0x11FC; // bool
    constexpr std::ptrdiff_t m_iBombSiteIndex = 0x1200; // CEntityIndex
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x1204; // int32_t
    constexpr std::ptrdiff_t m_bInBombZoneTrigger = 0x1208; // bool
    constexpr std::ptrdiff_t m_bWasInBombZoneTrigger = 0x1209; // bool
    constexpr std::ptrdiff_t m_iDirection = 0x120C; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1210; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1214; // int32_t
    constexpr std::ptrdiff_t m_flFlinchStack = 0x1218; // float
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x121C; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1220; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1224; // int32_t
    constexpr std::ptrdiff_t m_iHostagesKilled = 0x1228; // int32_t
    constexpr std::ptrdiff_t m_vecTotalBulletForce = 0x122C; // Vector
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1238; // float
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x123C; // float
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1240; // float
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x1244; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x1248; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x124C; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x1250; // bool
    constexpr std::ptrdiff_t m_lastStandingPos = 0x1254; // Vector
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x1260; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x1268; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x1280; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1298; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x12A4; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x12A8; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x12AC; // Vector
    constexpr std::ptrdiff_t m_iLastWeaponFireUsercmd = 0x12C0; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x12C4; // QAngle
    constexpr std::ptrdiff_t m_bVCollisionInitted = 0x12D0; // bool
    constexpr std::ptrdiff_t m_storedSpawnPosition = 0x12D4; // Vector
    constexpr std::ptrdiff_t m_storedSpawnAngle = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_bIsSpawning = 0x12EC; // bool
    constexpr std::ptrdiff_t m_bHideTargetID = 0x12ED; // bool
    constexpr std::ptrdiff_t m_nNumDangerZoneDamageHits = 0x12F0; // int32_t
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x12F4; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x12F5; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x12F8; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1300; // int32_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1304; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1308; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x130C; // int32_t
    constexpr std::ptrdiff_t m_currentDeafnessFilter = 0x1310; // CUtlStringToken
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisSpawn = 0x1314; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisRound = 0x1318; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesAtRoundStart = 0x131C; // int32_t
    constexpr std::ptrdiff_t m_wasNotKilledNaturally = 0x1320; // bool
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1324; // uint32_t[5]
    constexpr std::ptrdiff_t m_iDeathFlags = 0x1338; // int32_t
    constexpr std::ptrdiff_t m_hPet = 0x133C; // CHandle<CChicken>
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x1508; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x150A; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x150C; // uint16_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1510; // int32_t
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x1514; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1518; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x151C; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1528; // bool
    constexpr std::ptrdiff_t m_LastHitBox = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_LastHealth = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x1534; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x1538; // float
    constexpr std::ptrdiff_t m_pBot = 0x1540; // CCSBot*
    constexpr std::ptrdiff_t m_bBotAllowActive = 0x1548; // bool
    constexpr std::ptrdiff_t m_bCommittingSuicideOnTeamChange = 0x1549; // bool
}

namespace CCSPlayerResource { // CBaseEntity
    constexpr std::ptrdiff_t m_bHostageAlive = 0x4B0; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x4BC; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x4C8; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x4F8; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x504; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x510; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x520; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x530; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x540; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x541; // bool
}

namespace CCSPlayer_ActionTrackingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x208; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x23C; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x240; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0x298; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0xC8; // CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSPlayer_DamageReactServices { // CPlayerPawnComponent
}

namespace CCSPlayer_HostageServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<CBaseEntity>
}

namespace CCSPlayer_ItemServices { // CPlayer_ItemServices
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices { // CPlayer_MovementServices_Humanoid
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x220; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x224; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x230; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x234; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x238; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x23C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x23D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x240; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x244; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x248; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x24C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x250; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x260; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x268; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x269; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x26A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x278; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x478; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x480; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x484; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x488; // float
    constexpr std::ptrdiff_t m_vecForward = 0x48C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x498; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x4A4; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_bMadeFootstepNoise = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iFootsteps = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4C4; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4CC; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4D0; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4D4; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4D8; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4E0; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4E4; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4E8; // float
}

namespace CCSPlayer_PingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_flPlayerPingTokens = 0x40; // GameTime_t[5]
    constexpr std::ptrdiff_t m_hPlayerPing = 0x54; // CHandle<CBaseEntity>
}

namespace CCSPlayer_RadioServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_flGotHostageTalkTimer = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_flDefusingTalkTimer = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flC4PlantTalkTimer = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flRadioTokenSlots = 0x4C; // GameTime_t[3]
    constexpr std::ptrdiff_t m_bIgnoreRadio = 0x58; // bool
}

namespace CCSPlayer_UseServices { // CPlayer_UseServices
    constexpr std::ptrdiff_t m_hLastKnownUseEntity = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLastUseTimeStamp = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartedHoldingUse = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeLastUsedWindow = 0x4C; // GameTime_t
}

namespace CCSPlayer_ViewModelServices { // CPlayer_ViewModelServices
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<CBaseViewModel>[3]
}

namespace CCSPlayer_WaterServices { // CPlayer_WaterServices
    constexpr std::ptrdiff_t m_NextDrownDamageTime = 0x40; // float
    constexpr std::ptrdiff_t m_nDrownDmgRate = 0x44; // int32_t
    constexpr std::ptrdiff_t m_AirFinishedTime = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x4C; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x5C; // float
}

namespace CCSPlayer_WeaponServices { // CPlayer_WeaponServices
    constexpr std::ptrdiff_t m_flNextAttack = 0xB0; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xB4; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xB5; // bool
    constexpr std::ptrdiff_t m_hSavedWeapon = 0xB8; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_nTimeToMelee = 0xBC; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSecondary = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nTimeToPrimary = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSniperRifle = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_bIsBeingGivenItem = 0xCC; // bool
    constexpr std::ptrdiff_t m_bIsPickingUpItemWithUse = 0xCD; // bool
    constexpr std::ptrdiff_t m_bPickedUpWeapon = 0xCE; // bool
}

namespace CCSPulseServerFuncs_Globals {
}

namespace CCSSprite { // CSprite
}

namespace CCSTeam { // CTeam
    constexpr std::ptrdiff_t m_nLastRecievedShorthandedRoundBonus = 0x568; // int32_t
    constexpr std::ptrdiff_t m_nShorthandedRoundBonusStartRound = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x570; // bool
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x571; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x774; // int32_t
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x778; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x780; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x784; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x808; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x80C; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x814; // char[8]
    constexpr std::ptrdiff_t m_flNextResourceTime = 0x81C; // float
    constexpr std::ptrdiff_t m_iLastUpdateSentAt = 0x820; // int32_t
}

namespace CCSWeaponBase { // CBasePlayerWeapon
    constexpr std::ptrdiff_t m_bRemoveable = 0xC88; // bool
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0xC8C; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0xC90; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0xC94; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0xC98; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0xC9C; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0xCA0; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0xCA4; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0xCA8; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0xCC0; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0xCC4; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0xCC8; // HSequence[6]
    constexpr std::ptrdiff_t m_bPlayerAmmoStockOnPickup = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bRequireUseToTouch = 0xCE9; // bool
    constexpr std::ptrdiff_t m_iState = 0xCEC; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flLastTimeInAir = 0xCF0; // GameTime_t
    constexpr std::ptrdiff_t m_flLastDeployTime = 0xCF4; // GameTime_t
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xCF8; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0xCFC; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0xD18; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0xD1C; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xD20; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0xD48; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0xD4C; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0xD50; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0xD5C; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0xD60; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0xD64; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0xD68; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0xD6C; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0xD70; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0xD74; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0xD78; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0xD7C; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0xD80; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0xD81; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0xD84; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0xD88; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0xD89; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0xD8C; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0xD90; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0xD94; // float
    constexpr std::ptrdiff_t m_bCanBePickedUp = 0xDA8; // bool
    constexpr std::ptrdiff_t m_bUseCanOverrideNextOwnerTouchTime = 0xDA9; // bool
    constexpr std::ptrdiff_t m_nextOwnerTouchTime = 0xDAC; // GameTime_t
    constexpr std::ptrdiff_t m_nextPrevOwnerTouchTime = 0xDB0; // GameTime_t
    constexpr std::ptrdiff_t m_hPrevOwner = 0xDB4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0xDB8; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0xDDC; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0xDE0; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0xDE4; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0xDE5; // bool
    constexpr std::ptrdiff_t m_bFiredOutOfAmmoEvent = 0xDE6; // bool
    constexpr std::ptrdiff_t m_numRemoveUnownedWeaponThink = 0xDE8; // int32_t
    constexpr std::ptrdiff_t m_IronSightController = 0xDF0; // CIronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0xE08; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0xE0C; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0xE10; // int32_t
}

namespace CCSWeaponBaseGun { // CCSWeaponBase
    constexpr std::ptrdiff_t m_zoomLevel = 0xE18; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0xE1C; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0xE28; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0xE2C; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0xE2D; // bool
    constexpr std::ptrdiff_t m_bSkillReloadAvailable = 0xE2E; // bool
    constexpr std::ptrdiff_t m_bSkillReloadLiftedReloadKey = 0xE2F; // bool
    constexpr std::ptrdiff_t m_bSkillBoltInterruptAvailable = 0xE30; // bool
    constexpr std::ptrdiff_t m_bSkillBoltLiftedFireKey = 0xE31; // bool
}

namespace CCSWeaponBaseVData { // CBasePlayerWeaponVData
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CChangeLevel { // CBaseTrigger
    constexpr std::ptrdiff_t m_sMapName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_sLandmarkName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_OnChangeLevel = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bTouched = 0x8E0; // bool
    constexpr std::ptrdiff_t m_bNoTouch = 0x8E1; // bool
    constexpr std::ptrdiff_t m_bNewChapter = 0x8E2; // bool
    constexpr std::ptrdiff_t m_bOnChangeLevelFired = 0x8E3; // bool
}

namespace CChicken { // CDynamicProp
    constexpr std::ptrdiff_t m_AttributeManager = 0xB28; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xDF0; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xDF4; // uint32_t
    constexpr std::ptrdiff_t m_updateTimer = 0xDF8; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckAnchor = 0xE10; // Vector
    constexpr std::ptrdiff_t m_stuckTimer = 0xE20; // CountdownTimer
    constexpr std::ptrdiff_t m_collisionStuckTimer = 0xE38; // CountdownTimer
    constexpr std::ptrdiff_t m_isOnGround = 0xE50; // bool
    constexpr std::ptrdiff_t m_vFallVelocity = 0xE54; // Vector
    constexpr std::ptrdiff_t m_activity = 0xE60; // ChickenActivity
    constexpr std::ptrdiff_t m_activityTimer = 0xE68; // CountdownTimer
    constexpr std::ptrdiff_t m_turnRate = 0xE80; // float
    constexpr std::ptrdiff_t m_fleeFrom = 0xE84; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_moveRateThrottleTimer = 0xE88; // CountdownTimer
    constexpr std::ptrdiff_t m_startleTimer = 0xEA0; // CountdownTimer
    constexpr std::ptrdiff_t m_vocalizeTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_flWhenZombified = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xED4; // bool
    constexpr std::ptrdiff_t m_leader = 0xED8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_reuseTimer = 0xEE0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xEF8; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xF00; // CountdownTimer
    constexpr std::ptrdiff_t m_flLastJumpTime = 0xF18; // float
    constexpr std::ptrdiff_t m_bInJump = 0xF1C; // bool
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xF1D; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2F28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2F40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2FD0; // CountdownTimer
    constexpr std::ptrdiff_t m_vecPathGoal = 0x2FF0; // Vector
    constexpr std::ptrdiff_t m_flActiveFollowStartTime = 0x2FFC; // GameTime_t
    constexpr std::ptrdiff_t m_followMinuteTimer = 0x3000; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastEggPoopPosition = 0x3018; // Vector
    constexpr std::ptrdiff_t m_vecEggsPooped = 0x3028; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_BlockDirectionTimer = 0x3048; // CountdownTimer
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CColorCorrection { // CBaseEntity
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flStartFadeInWeight = 0x4B8; // float
    constexpr std::ptrdiff_t m_flStartFadeOutWeight = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTimeStartFadeIn = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartFadeOut = 0x4C4; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxWeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4CD; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x4CE; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x4CF; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x4D0; // bool
    constexpr std::ptrdiff_t m_MinFalloff = 0x4D4; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x4D8; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x4DC; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x4E0; // char[512]
    constexpr std::ptrdiff_t m_lookupFilename = 0x6E0; // CUtlSymbolLarge
}

namespace CColorCorrectionVolume { // CBaseTrigger
    constexpr std::ptrdiff_t m_bEnabled = 0x8A8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0x8AC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0x8B0; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8B4; // bool
    constexpr std::ptrdiff_t m_Weight = 0x8B8; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0x8BC; // char[512]
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xABC; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xAC0; // GameTime_t
    constexpr std::ptrdiff_t m_LastExitWeight = 0xAC4; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xAC8; // GameTime_t
}

namespace CCommentaryAuto { // CBaseEntity
    constexpr std::ptrdiff_t m_OnCommentaryNewGame = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMidGame = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMultiplayerSpawn = 0x500; // CEntityIOOutput
}

namespace CCommentarySystem {
    constexpr std::ptrdiff_t m_bCommentaryConvarsChanging = 0x11; // bool
    constexpr std::ptrdiff_t m_bCommentaryEnabledMidGame = 0x12; // bool
    constexpr std::ptrdiff_t m_flNextTeleportTime = 0x14; // GameTime_t
    constexpr std::ptrdiff_t m_iTeleportStage = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bCheatState = 0x1C; // bool
    constexpr std::ptrdiff_t m_bIsFirstSpawnGroupToLoad = 0x1D; // bool
    constexpr std::ptrdiff_t m_hCurrentNode = 0x38; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hActiveCommentaryNode = 0x3C; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hLastCommentaryNode = 0x40; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_vecNodes = 0x48; // CUtlVector<CHandle<CPointCommentaryNode>>
}

namespace CCommentaryViewPosition { // CSprite
}

namespace CConstantForceController {
    constexpr std::ptrdiff_t m_linear = 0xC; // Vector
    constexpr std::ptrdiff_t m_angular = 0x18; // RotationVector
    constexpr std::ptrdiff_t m_linearSave = 0x24; // Vector
    constexpr std::ptrdiff_t m_angularSave = 0x30; // RotationVector
}

namespace CConstraintAnchor { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_massScale = 0x890; // float
}

namespace CCoopBonusCoin { // CDynamicProp
}

namespace CCopyRecipientFilter {
    constexpr std::ptrdiff_t m_Flags = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Recipients = 0x10; // CUtlVector<CPlayerSlot>
}

namespace CCredits { // CPointEntity
    constexpr std::ptrdiff_t m_OnCreditsDone = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bRolledOutroCredits = 0x4D8; // bool
    constexpr std::ptrdiff_t m_flLogoLength = 0x4DC; // float
}

namespace CDEagle { // CCSWeaponBaseGun
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDebugHistory { // CBaseEntity
    constexpr std::ptrdiff_t m_nNpcEvents = 0x44F0; // int32_t
}

namespace CDecoyGrenade { // CBaseCSGrenade
}

namespace CDecoyProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0xA38; // int32_t
    constexpr std::ptrdiff_t m_shotsRemaining = 0xA3C; // int32_t
    constexpr std::ptrdiff_t m_fExpireTime = 0xA40; // GameTime_t
    constexpr std::ptrdiff_t m_decoyWeaponDefIndex = 0xA50; // uint16_t
}

namespace CDynamicLight { // CBaseModelEntity
    constexpr std::ptrdiff_t m_ActualFlags = 0x700; // uint8_t
    constexpr std::ptrdiff_t m_Flags = 0x701; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0x702; // uint8_t
    constexpr std::ptrdiff_t m_On = 0x703; // bool
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_Exponent = 0x708; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0x70C; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0x710; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0x714; // float
}

namespace CDynamicProp { // CBreakableProp
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0xA10; // bool
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xA11; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xA12; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xA18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0xA40; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0xA68; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0xA90; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0xAB8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0xAE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0xAE8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0xAEC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0xAED; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0xAEE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0xAEF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0xAF0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xAF1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0xAF2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xAF3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xAF4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xAF8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xAFC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB00; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0xB04; // int32_t
}

namespace CDynamicPropAlias_cable_dynamic { // CDynamicProp
}

namespace CDynamicPropAlias_dynamic_prop { // CDynamicProp
}

namespace CDynamicPropAlias_prop_dynamic_override { // CDynamicProp
}

namespace CEconEntity { // CBaseFlex
    constexpr std::ptrdiff_t m_AttributeManager = 0x930; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xBF8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xBFC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0xC08; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0xC10; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iOldOwnerClass = 0xC14; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEconItemView { // IEconItemInterface
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x38; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x50; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x5C; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x68; // bool
    constexpr std::ptrdiff_t m_AttributeList = 0x70; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0xD0; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x130; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x1D1; // char[161]
}

namespace CEconWearable { // CEconEntity
    constexpr std::ptrdiff_t m_nForceSkin = 0xC18; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0xC1C; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEnableMotionFixup { // CBaseEntity
}

namespace CEntityBlocker { // CBaseModelEntity
}

namespace CEntityComponent {
}

namespace CEntityDissolve { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flFadeInStart = 0x700; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0x704; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0x708; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0x70C; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0x710; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0x714; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0x71C; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0x720; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0x72C; // uint32_t
}

namespace CEntityFlame { // CBaseEntity
    constexpr std::ptrdiff_t m_hEntAttached = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSize = 0x4B8; // float
    constexpr std::ptrdiff_t m_bUseHitboxes = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iNumHitboxFires = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flHitboxFireScale = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLifetime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_hAttacker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iDangerSound = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_flDirectDamagePerSecond = 0x4D4; // float
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x4D8; // int32_t
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CEntitySubclassVDataBase {
}

namespace CEnvBeam { // CBeam
    constexpr std::ptrdiff_t m_active = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_spriteTexture = 0x7A8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszStartEntity = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEndEntity = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_life = 0x7C0; // float
    constexpr std::ptrdiff_t m_boltWidth = 0x7C4; // float
    constexpr std::ptrdiff_t m_noiseAmplitude = 0x7C8; // float
    constexpr std::ptrdiff_t m_speed = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_restrike = 0x7D0; // float
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_frameStart = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_vEndPointWorld = 0x7E4; // Vector
    constexpr std::ptrdiff_t m_vEndPointRelative = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_radius = 0x7FC; // float
    constexpr std::ptrdiff_t m_TouchType = 0x800; // Touch_t
    constexpr std::ptrdiff_t m_iFilterName = 0x808; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x810; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszDecal = 0x818; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnTouchedByEntity = 0x820; // CEntityIOOutput
}

namespace CEnvBeverage { // CBaseEntity
    constexpr std::ptrdiff_t m_CanInDispenser = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nBeverageType = 0x4B4; // int32_t
}

namespace CEnvCombinedLightProbeVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_Color = 0x1508; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x150C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x1510; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x1518; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1538; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1540; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x154C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x155C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x1568; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x156C; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1570; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x157C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1580; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1584; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x158C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1590; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x15A9; // bool
}

namespace CEnvCubemap { // CBaseEntity
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x538; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x53C; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x540; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x54C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x568; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x578; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x57C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x57D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x57E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x57F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x580; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x590; // bool
}

namespace CEnvCubemapBox { // CEnvCubemap
}

namespace CEnvCubemapFog { // CBaseEntity
    constexpr std::ptrdiff_t m_flEndDistance = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4B8; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4BC; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x4CC; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x4D0; // float
    constexpr std::ptrdiff_t m_bActive = 0x4D4; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4D5; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D8; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x4E0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x4F0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x4F9; // bool
}

namespace CEnvDecal { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hDecalMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0x708; // float
    constexpr std::ptrdiff_t m_flHeight = 0x70C; // float
    constexpr std::ptrdiff_t m_flDepth = 0x710; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0x714; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0x718; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0x719; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0x71A; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x71C; // float
}

namespace CEnvDetailController { // CBaseEntity
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x4B4; // float
}

namespace CEnvEntityIgniter { // CBaseEntity
    constexpr std::ptrdiff_t m_flLifetime = 0x4B0; // float
}

namespace CEnvEntityMaker { // CPointEntity
    constexpr std::ptrdiff_t m_vecEntityMins = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vecEntityMaxs = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_hCurrentInstance = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCurrentBlocker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecBlockerOrigin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_angPostSpawnDirection = 0x4DC; // QAngle
    constexpr std::ptrdiff_t m_flPostSpawnDirectionVariance = 0x4E8; // float
    constexpr std::ptrdiff_t m_flPostSpawnSpeed = 0x4EC; // float
    constexpr std::ptrdiff_t m_bPostSpawnUseAngles = 0x4F0; // bool
    constexpr std::ptrdiff_t m_iszTemplate = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputOnFailedSpawn = 0x528; // CEntityIOOutput
}

namespace CEnvExplosion { // CModelPointEntity
    constexpr std::ptrdiff_t m_iMagnitude = 0x700; // int32_t
    constexpr std::ptrdiff_t m_flPlayerDamage = 0x704; // float
    constexpr std::ptrdiff_t m_iRadiusOverride = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70C; // float
    constexpr std::ptrdiff_t m_spriteScale = 0x710; // int32_t
    constexpr std::ptrdiff_t m_flDamageForce = 0x714; // float
    constexpr std::ptrdiff_t m_hInflictor = 0x718; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_iszExplosionType = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomEffectName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomSoundName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iClassIgnore = 0x740; // Class_T
    constexpr std::ptrdiff_t m_iClassIgnore2 = 0x744; // Class_T
    constexpr std::ptrdiff_t m_iszEntityIgnoreName = 0x748; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEntityIgnore = 0x750; // CHandle<CBaseEntity>
}

namespace CEnvFade { // CLogicalEntity
    constexpr std::ptrdiff_t m_fadeColor = 0x4B0; // Color
    constexpr std::ptrdiff_t m_Duration = 0x4B4; // float
    constexpr std::ptrdiff_t m_HoldDuration = 0x4B8; // float
    constexpr std::ptrdiff_t m_OnBeginFade = 0x4C0; // CEntityIOOutput
}

namespace CEnvFireSensor { // CBaseEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bHeatAtLevel = 0x4B1; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_targetLevel = 0x4B8; // float
    constexpr std::ptrdiff_t m_targetTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_levelTime = 0x4C0; // float
    constexpr std::ptrdiff_t m_OnHeatLevelStart = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeatLevelEnd = 0x4F0; // CEntityIOOutput
}

namespace CEnvFireSource { // CBaseEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_damage = 0x4B8; // float
}

namespace CEnvFunnel { // CBaseEntity
}

namespace CEnvGlobal { // CLogicalEntity
    constexpr std::ptrdiff_t m_outCounter = 0x4B0; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_globalstate = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_triggermode = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_initialstate = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_counter = 0x4E8; // int32_t
}

namespace CEnvHudHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
}

namespace CEnvInstructorHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReplace_Key = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C8; // int32_t
    constexpr std::ptrdiff_t m_iDisplayLimit = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_iszIcon_Onscreen = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszIcon_Offscreen = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCaption = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszActivatorCaption = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Color = 0x4F0; // Color
    constexpr std::ptrdiff_t m_fIconOffset = 0x4F4; // float
    constexpr std::ptrdiff_t m_fRange = 0x4F8; // float
    constexpr std::ptrdiff_t m_iPulseOption = 0x4FC; // uint8_t
    constexpr std::ptrdiff_t m_iAlphaOption = 0x4FD; // uint8_t
    constexpr std::ptrdiff_t m_iShakeOption = 0x4FE; // uint8_t
    constexpr std::ptrdiff_t m_bStatic = 0x4FF; // bool
    constexpr std::ptrdiff_t m_bNoOffscreen = 0x500; // bool
    constexpr std::ptrdiff_t m_bForceCaption = 0x501; // bool
    constexpr std::ptrdiff_t m_iInstanceType = 0x504; // int32_t
    constexpr std::ptrdiff_t m_bSuppressRest = 0x508; // bool
    constexpr std::ptrdiff_t m_iszBinding = 0x510; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAllowNoDrawTarget = 0x518; // bool
    constexpr std::ptrdiff_t m_bAutoStart = 0x519; // bool
    constexpr std::ptrdiff_t m_bLocalPlayerOnly = 0x51A; // bool
}

namespace CEnvInstructorVRHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_iszCaption = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszStartSound = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iLayoutFileType = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszCustomLayoutFile = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iAttachType = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_flHeightOffset = 0x4EC; // float
}

namespace CEnvLaser { // CBeam
    constexpr std::ptrdiff_t m_iszLaserTarget = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pSprite = 0x7A8; // CSprite*
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_firePosition = 0x7B8; // Vector
    constexpr std::ptrdiff_t m_flStartFrame = 0x7C4; // float
}

namespace CEnvLightProbeVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1488; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1490; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1498; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x14A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x14A8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x14B4; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x14C0; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x14C4; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x14C8; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x14CC; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x14D0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x14D4; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x14D8; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x14DC; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x14E0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x14E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x14F1; // bool
}

namespace CEnvMicrophone { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundMask = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_flSensitivity = 0x4BC; // float
    constexpr std::ptrdiff_t m_flSmoothFactor = 0x4C0; // float
    constexpr std::ptrdiff_t m_flMaxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_iszSpeakerName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSpeaker = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bAvoidFeedback = 0x4D4; // bool
    constexpr std::ptrdiff_t m_iSpeakerDSPPreset = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszListenFilter = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hListenFilter = 0x4E8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_SoundLevel = 0x4F0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoutedSound = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeardSound = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_szLastSound = 0x568; // char[256]
    constexpr std::ptrdiff_t m_iLastRoutedFrame = 0x668; // int32_t
}

namespace CEnvMuzzleFlash { // CPointEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_iszParentAttachment = 0x4B8; // CUtlSymbolLarge
}

namespace CEnvParticleGlow { // CParticleSystem
    constexpr std::ptrdiff_t m_flAlphaScale = 0xC78; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0xC7C; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0xC80; // float
    constexpr std::ptrdiff_t m_ColorTint = 0xC84; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0xC88; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace CEnvProjectedTexture { // CModelPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x700; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x704; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x705; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x708; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x70C; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x70D; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x70E; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x70F; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x710; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_LightColor = 0x718; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x71C; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x720; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x724; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x728; // bool
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x72C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x730; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x734; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x738; // float
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x73C; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x740; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x744; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x748; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x948; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x94C; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x950; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x954; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x958; // float
    constexpr std::ptrdiff_t m_flRotation = 0x95C; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x960; // bool
}

namespace CEnvScreenOverlay { // CPointEntity
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x4B0; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x500; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x528; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x52C; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x530; // bool
}

namespace CEnvShake { // CPointEntity
    constexpr std::ptrdiff_t m_limitToEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Amplitude = 0x4B8; // float
    constexpr std::ptrdiff_t m_Frequency = 0x4BC; // float
    constexpr std::ptrdiff_t m_Duration = 0x4C0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4C4; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_nextShake = 0x4CC; // GameTime_t
    constexpr std::ptrdiff_t m_currentAmp = 0x4D0; // float
    constexpr std::ptrdiff_t m_maxForce = 0x4D4; // Vector
    constexpr std::ptrdiff_t m_shakeCallback = 0x4E8; // CPhysicsShake
}

namespace CEnvSky { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0x710; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0x711; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0x715; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x71C; // float
    constexpr std::ptrdiff_t m_nFogType = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0x724; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0x728; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0x72C; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0x730; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x734; // bool
}

namespace CEnvSoundscape { // CServerOnlyEntity
    constexpr std::ptrdiff_t m_OnPlay = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flRadius = 0x4D8; // float
    constexpr std::ptrdiff_t m_soundscapeName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOverrideWithEvent = 0x4F0; // bool
    constexpr std::ptrdiff_t m_soundscapeIndex = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_soundscapeEntityListId = 0x4F8; // int32_t
    constexpr std::ptrdiff_t m_soundEventHash = 0x4FC; // uint32_t
    constexpr std::ptrdiff_t m_positionNames = 0x500; // CUtlSymbolLarge[8]
    constexpr std::ptrdiff_t m_hProxySoundscape = 0x540; // CHandle<CEnvSoundscape>
    constexpr std::ptrdiff_t m_bDisabled = 0x544; // bool
}

namespace CEnvSoundscapeAlias_snd_soundscape { // CEnvSoundscape
}

namespace CEnvSoundscapeProxy { // CEnvSoundscape
    constexpr std::ptrdiff_t m_MainSoundscapeName = 0x548; // CUtlSymbolLarge
}

namespace CEnvSoundscapeProxyAlias_snd_soundscape_proxy { // CEnvSoundscapeProxy
}

namespace CEnvSoundscapeTriggerable { // CEnvSoundscape
}

namespace CEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable { // CEnvSoundscapeTriggerable
}

namespace CEnvSpark { // CPointEntity
    constexpr std::ptrdiff_t m_flDelay = 0x4B0; // float
    constexpr std::ptrdiff_t m_nMagnitude = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nTrailLength = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_OnSpark = 0x4C0; // CEntityIOOutput
}

namespace CEnvSplash { // CPointEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
}

namespace CEnvTilt { // CPointEntity
    constexpr std::ptrdiff_t m_Duration = 0x4B0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_TiltTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4BC; // GameTime_t
}

namespace CEnvTracer { // CPointEntity
    constexpr std::ptrdiff_t m_vecEnd = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
}

namespace CEnvViewPunch { // CPointEntity
    constexpr std::ptrdiff_t m_flRadius = 0x4B0; // float
    constexpr std::ptrdiff_t m_angViewPunch = 0x4B4; // QAngle
}

namespace CEnvVolumetricFogController { // CBaseEntity
    constexpr std::ptrdiff_t m_flScattering = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x4C8; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x4F0; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x4F4; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x4F8; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x4FC; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x500; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x504; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x508; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x50C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x510; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x514; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x519; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x51A; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x528; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x52C; // bool
}

namespace CEnvVolumetricFogVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_bActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4C0; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x4D0; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x4D8; // float
}

namespace CEnvWind { // CBaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x4B0; // CEnvWindShared
}

namespace CEnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_OnGustStart = 0x70; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGustEnd = 0x98; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flVariationTime = 0xC0; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0xC4; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0xD0; // float
    constexpr std::ptrdiff_t m_bGusting = 0xD4; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0xD8; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0xDC; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0xE0; // CEntityIndex
}

namespace CEnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace CEnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace CFilterAttributeInt { // CBaseFilter
    constexpr std::ptrdiff_t m_sAttributeName = 0x508; // CUtlStringToken
}

namespace CFilterClass { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterClass = 0x508; // CUtlSymbolLarge
}

namespace CFilterContext { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterContext = 0x508; // CUtlSymbolLarge
}

namespace CFilterEnemy { // CBaseFilter
    constexpr std::ptrdiff_t m_iszEnemyName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x510; // float
    constexpr std::ptrdiff_t m_flOuterRadius = 0x514; // float
    constexpr std::ptrdiff_t m_nMaxSquadmatesPerEnemy = 0x518; // int32_t
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // CUtlSymbolLarge
}

namespace CFilterLOS { // CBaseFilter
}

namespace CFilterMassGreater { // CBaseFilter
    constexpr std::ptrdiff_t m_fFilterMass = 0x508; // float
}

namespace CFilterModel { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterModel = 0x508; // CUtlSymbolLarge
}

namespace CFilterMultiple { // CBaseFilter
    constexpr std::ptrdiff_t m_nFilterType = 0x508; // filter_t
    constexpr std::ptrdiff_t m_iFilterName = 0x510; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_hFilter = 0x560; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nFilterCount = 0x588; // int32_t
}

namespace CFilterName { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterName = 0x508; // CUtlSymbolLarge
}

namespace CFilterProximity { // CBaseFilter
    constexpr std::ptrdiff_t m_flRadius = 0x508; // float
}

namespace CFire { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hEffect = 0x700; // CHandle<CBaseFire>
    constexpr std::ptrdiff_t m_hOwner = 0x704; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nFireType = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flFuel = 0x70C; // float
    constexpr std::ptrdiff_t m_flDamageTime = 0x710; // GameTime_t
    constexpr std::ptrdiff_t m_lastDamage = 0x714; // GameTime_t
    constexpr std::ptrdiff_t m_flFireSize = 0x718; // float
    constexpr std::ptrdiff_t m_flLastNavUpdateTime = 0x71C; // GameTime_t
    constexpr std::ptrdiff_t m_flHeatLevel = 0x720; // float
    constexpr std::ptrdiff_t m_flHeatAbsorb = 0x724; // float
    constexpr std::ptrdiff_t m_flDamageScale = 0x728; // float
    constexpr std::ptrdiff_t m_flMaxHeat = 0x72C; // float
    constexpr std::ptrdiff_t m_flLastHeatLevel = 0x730; // float
    constexpr std::ptrdiff_t m_flAttackTime = 0x734; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x738; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x739; // bool
    constexpr std::ptrdiff_t m_bDidActivate = 0x73A; // bool
    constexpr std::ptrdiff_t m_OnIgnited = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExtinguished = 0x768; // CEntityIOOutput
}

namespace CFireCrackerBlast { // CInferno
}

namespace CFireSmoke { // CBaseFire
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x4C4; // int32_t
}

namespace CFiringModeFloat {
    constexpr std::ptrdiff_t m_flValues = 0x0; // float[2]
}

namespace CFiringModeInt {
    constexpr std::ptrdiff_t m_nValues = 0x0; // int32_t[2]
}

namespace CFish { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_pool = 0x890; // CHandle<CFishPool>
    constexpr std::ptrdiff_t m_id = 0x894; // uint32_t
    constexpr std::ptrdiff_t m_x = 0x898; // float
    constexpr std::ptrdiff_t m_y = 0x89C; // float
    constexpr std::ptrdiff_t m_z = 0x8A0; // float
    constexpr std::ptrdiff_t m_angle = 0x8A4; // float
    constexpr std::ptrdiff_t m_angleChange = 0x8A8; // float
    constexpr std::ptrdiff_t m_forward = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_perp = 0x8B8; // Vector
    constexpr std::ptrdiff_t m_poolOrigin = 0x8C4; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0x8D0; // float
    constexpr std::ptrdiff_t m_speed = 0x8D4; // float
    constexpr std::ptrdiff_t m_desiredSpeed = 0x8D8; // float
    constexpr std::ptrdiff_t m_calmSpeed = 0x8DC; // float
    constexpr std::ptrdiff_t m_panicSpeed = 0x8E0; // float
    constexpr std::ptrdiff_t m_avoidRange = 0x8E4; // float
    constexpr std::ptrdiff_t m_turnTimer = 0x8E8; // CountdownTimer
    constexpr std::ptrdiff_t m_turnClockwise = 0x900; // bool
    constexpr std::ptrdiff_t m_goTimer = 0x908; // CountdownTimer
    constexpr std::ptrdiff_t m_moveTimer = 0x920; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x938; // CountdownTimer
    constexpr std::ptrdiff_t m_disperseTimer = 0x950; // CountdownTimer
    constexpr std::ptrdiff_t m_proximityTimer = 0x968; // CountdownTimer
    constexpr std::ptrdiff_t m_visible = 0x980; // CUtlVector<CFish*>
}

namespace CFishPool { // CBaseEntity
    constexpr std::ptrdiff_t m_fishCount = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_maxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_swimDepth = 0x4C8; // float
    constexpr std::ptrdiff_t m_waterLevel = 0x4CC; // float
    constexpr std::ptrdiff_t m_isDormant = 0x4D0; // bool
    constexpr std::ptrdiff_t m_fishes = 0x4D8; // CUtlVector<CHandle<CFish>>
    constexpr std::ptrdiff_t m_visTimer = 0x4F0; // CountdownTimer
}

namespace CFists { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0xE18; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0xE1C; // PlayerAnimEvent_t
    constexpr std::ptrdiff_t m_bRestorePrevWep = 0xE20; // bool
    constexpr std::ptrdiff_t m_hWeaponBeforePrevious = 0xE24; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hWeaponPrevious = 0xE28; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bDelayedHardPunchIncoming = 0xE2C; // bool
    constexpr std::ptrdiff_t m_bDestroyAfterTaunt = 0xE2D; // bool
}

namespace CFlashbang { // CBaseCSGrenade
}

namespace CFlashbangProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_flTimeToDetonate = 0xA30; // float
    constexpr std::ptrdiff_t m_numOpponentsHit = 0xA34; // uint8_t
    constexpr std::ptrdiff_t m_numTeammatesHit = 0xA35; // uint8_t
}

namespace CFogController { // CBaseEntity
    constexpr std::ptrdiff_t m_fog = 0x4B0; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x518; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x51C; // int32_t
}

namespace CFogTrigger { // CBaseTrigger
    constexpr std::ptrdiff_t m_fog = 0x8A8; // fogparams_t
}

namespace CFogVolume { // CServerOnlyModelEntity
    constexpr std::ptrdiff_t m_fogName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_postProcessName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_colorCorrectionName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x720; // bool
    constexpr std::ptrdiff_t m_bInFogVolumesList = 0x721; // bool
}

namespace CFootstepControl { // CBaseTrigger
    constexpr std::ptrdiff_t m_source = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0x8B0; // CUtlSymbolLarge
}

namespace CFootstepTableHandle {
}

namespace CFuncBrush { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iSolidity = 0x700; // BrushSolidities_e
    constexpr std::ptrdiff_t m_iDisabled = 0x704; // int32_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x708; // bool
    constexpr std::ptrdiff_t m_iszExcludedClass = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bInvertExclusion = 0x718; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x719; // bool
}

namespace CFuncConveyor { // CBaseModelEntity
    constexpr std::ptrdiff_t m_szConveyorModels = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTransitionDurationSeconds = 0x708; // float
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x70C; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0x718; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x724; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0x728; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0x730; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0x738; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
}

namespace CFuncElectrifiedVolume { // CFuncBrush
    constexpr std::ptrdiff_t m_EffectName = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectInterpenetrateName = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectZapName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEffectSource = 0x738; // CUtlSymbolLarge
}

namespace CFuncIllusionary { // CBaseModelEntity
}

namespace CFuncInteractionLayerClip { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_iszInteractsAs = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszInteractsWith = 0x710; // CUtlSymbolLarge
}

namespace CFuncLadder { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vecLadderDir = 0x700; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0x710; // CUtlVector<CHandle<CInfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0x734; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0x740; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0x74C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x750; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0x751; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0x752; // bool
    constexpr std::ptrdiff_t m_surfacePropName = 0x758; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnPlayerGotOnLadder = 0x760; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerGotOffLadder = 0x788; // CEntityIOOutput
}

namespace CFuncLadderAlias_func_useableladder { // CFuncLadder
}

namespace CFuncMonitor { // CFuncBrush
    constexpr std::ptrdiff_t m_targetCamera = 0x720; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0x72C; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0x72D; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0x738; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0x73C; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0x73D; // bool
    constexpr std::ptrdiff_t m_bStartEnabled = 0x73E; // bool
}

namespace CFuncMoveLinear { // CBaseToggle
    constexpr std::ptrdiff_t m_authoredPosition = 0x780; // MoveLinearAuthoredPos_t
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x784; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x790; // Vector
    constexpr std::ptrdiff_t m_soundStart = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundStop = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_currentSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B8; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x7BC; // float
    constexpr std::ptrdiff_t m_flMoveDistance = 0x7C0; // float
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x7D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x7F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCreateMovableNavMesh = 0x820; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x821; // bool
}

namespace CFuncMoveLinearAlias_momentary_door { // CFuncMoveLinear
}

namespace CFuncNavBlocker { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nBlockedTeamNumber = 0x704; // int32_t
}

namespace CFuncNavObstruction { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x708; // bool
}

namespace CFuncPlat { // CBasePlatTrain
    constexpr std::ptrdiff_t m_sNoise = 0x7A8; // CUtlSymbolLarge
}

namespace CFuncPlatRot { // CFuncPlat
    constexpr std::ptrdiff_t m_end = 0x7B0; // QAngle
    constexpr std::ptrdiff_t m_start = 0x7BC; // QAngle
}

namespace CFuncPropRespawnZone { // CBaseEntity
}

namespace CFuncRotating { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vecMoveAng = 0x700; // QAngle
    constexpr std::ptrdiff_t m_flFanFriction = 0x70C; // float
    constexpr std::ptrdiff_t m_flAttenuation = 0x710; // float
    constexpr std::ptrdiff_t m_flVolume = 0x714; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x718; // float
    constexpr std::ptrdiff_t m_flMaxSpeed = 0x71C; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x720; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x724; // float
    constexpr std::ptrdiff_t m_NoiseRunning = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bReversed = 0x730; // bool
    constexpr std::ptrdiff_t m_angStart = 0x73C; // QAngle
    constexpr std::ptrdiff_t m_bStopAtStartPos = 0x748; // bool
    constexpr std::ptrdiff_t m_vecClientOrigin = 0x74C; // Vector
    constexpr std::ptrdiff_t m_vecClientAngles = 0x758; // QAngle
}

namespace CFuncShatterglass { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hGlassMaterialDamaged = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hGlassMaterialUndamaged = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFace = 0x710; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeCaps = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFins = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_matPanelTransform = 0x728; // matrix3x4_t
    constexpr std::ptrdiff_t m_matPanelTransformWsTemp = 0x758; // matrix3x4_t
    constexpr std::ptrdiff_t m_vecShatterGlassShards = 0x788; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_PanelSize = 0x7A0; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelNormalWs = 0x7A8; // Vector
    constexpr std::ptrdiff_t m_nNumShardsEverCreated = 0x7B4; // int32_t
    constexpr std::ptrdiff_t m_flLastShatterSoundEmitTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastCleanupTime = 0x7BC; // GameTime_t
    constexpr std::ptrdiff_t m_flInitAtTime = 0x7C0; // GameTime_t
    constexpr std::ptrdiff_t m_flGlassThickness = 0x7C4; // float
    constexpr std::ptrdiff_t m_flSpawnInvulnerability = 0x7C8; // float
    constexpr std::ptrdiff_t m_bBreakSilent = 0x7CC; // bool
    constexpr std::ptrdiff_t m_bBreakShardless = 0x7CD; // bool
    constexpr std::ptrdiff_t m_bBroken = 0x7CE; // bool
    constexpr std::ptrdiff_t m_bHasRateLimitedShards = 0x7CF; // bool
    constexpr std::ptrdiff_t m_bGlassNavIgnore = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bGlassInFrame = 0x7D1; // bool
    constexpr std::ptrdiff_t m_bStartBroken = 0x7D2; // bool
    constexpr std::ptrdiff_t m_iInitialDamageType = 0x7D3; // uint8_t
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName01 = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName02 = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName03 = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName04 = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vInitialDamagePositions = 0x7F8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vExtraDamagePositions = 0x810; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_OnBroken = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iSurfaceType = 0x851; // uint8_t
}

namespace CFuncTankTrain { // CFuncTrackTrain
    constexpr std::ptrdiff_t m_OnDeath = 0x850; // CEntityIOOutput
}

namespace CFuncTimescale { // CBaseEntity
    constexpr std::ptrdiff_t m_flDesiredTimescale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAcceleration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flMinBlendRate = 0x4B8; // float
    constexpr std::ptrdiff_t m_flBlendDeltaMultiplier = 0x4BC; // float
    constexpr std::ptrdiff_t m_isStarted = 0x4C0; // bool
}

namespace CFuncTrackAuto { // CFuncTrackChange
}

namespace CFuncTrackChange { // CFuncPlatRot
    constexpr std::ptrdiff_t m_trackTop = 0x7C8; // CPathTrack*
    constexpr std::ptrdiff_t m_trackBottom = 0x7D0; // CPathTrack*
    constexpr std::ptrdiff_t m_train = 0x7D8; // CFuncTrackTrain*
    constexpr std::ptrdiff_t m_trackTopName = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trackBottomName = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trainName = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_code = 0x7F8; // TRAIN_CODE
    constexpr std::ptrdiff_t m_targetState = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_use = 0x800; // int32_t
}

namespace CFuncTrackTrain { // CBaseModelEntity
    constexpr std::ptrdiff_t m_ppath = 0x700; // CHandle<CPathTrack>
    constexpr std::ptrdiff_t m_length = 0x704; // float
    constexpr std::ptrdiff_t m_vPosPrev = 0x708; // Vector
    constexpr std::ptrdiff_t m_angPrev = 0x714; // QAngle
    constexpr std::ptrdiff_t m_controlMins = 0x720; // Vector
    constexpr std::ptrdiff_t m_controlMaxs = 0x72C; // Vector
    constexpr std::ptrdiff_t m_lastBlockPos = 0x738; // Vector
    constexpr std::ptrdiff_t m_lastBlockTick = 0x744; // int32_t
    constexpr std::ptrdiff_t m_flVolume = 0x748; // float
    constexpr std::ptrdiff_t m_flBank = 0x74C; // float
    constexpr std::ptrdiff_t m_oldSpeed = 0x750; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x754; // float
    constexpr std::ptrdiff_t m_height = 0x758; // float
    constexpr std::ptrdiff_t m_maxSpeed = 0x75C; // float
    constexpr std::ptrdiff_t m_dir = 0x760; // float
    constexpr std::ptrdiff_t m_iszSoundMove = 0x768; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovePing = 0x770; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStart = 0x778; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStop = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strPathTarget = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveSoundMinDuration = 0x790; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxDuration = 0x794; // float
    constexpr std::ptrdiff_t m_flNextMoveSoundTime = 0x798; // GameTime_t
    constexpr std::ptrdiff_t m_flMoveSoundMinPitch = 0x79C; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxPitch = 0x7A0; // float
    constexpr std::ptrdiff_t m_eOrientationType = 0x7A4; // TrainOrientationType_t
    constexpr std::ptrdiff_t m_eVelocityType = 0x7A8; // TrainVelocityType_t
    constexpr std::ptrdiff_t m_OnStart = 0x7B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNext = 0x7E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnArrivedAtDestinationNode = 0x808; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bManualSpeedChanges = 0x830; // bool
    constexpr std::ptrdiff_t m_flDesiredSpeed = 0x834; // float
    constexpr std::ptrdiff_t m_flSpeedChangeTime = 0x838; // GameTime_t
    constexpr std::ptrdiff_t m_flAccelSpeed = 0x83C; // float
    constexpr std::ptrdiff_t m_flDecelSpeed = 0x840; // float
    constexpr std::ptrdiff_t m_bAccelToSpeed = 0x844; // bool
    constexpr std::ptrdiff_t m_flTimeScale = 0x848; // float
    constexpr std::ptrdiff_t m_flNextMPSoundTime = 0x84C; // GameTime_t
}

namespace CFuncTrain { // CBasePlatTrain
    constexpr std::ptrdiff_t m_hCurrentTarget = 0x7A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_activated = 0x7AC; // bool
    constexpr std::ptrdiff_t m_hEnemy = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B4; // float
    constexpr std::ptrdiff_t m_flNextBlockTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_iszLastTarget = 0x7C0; // CUtlSymbolLarge
}

namespace CFuncTrainControls { // CBaseModelEntity
}

namespace CFuncVPhysicsClip { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
}

namespace CFuncVehicleClip { // CBaseModelEntity
}

namespace CFuncWall { // CBaseModelEntity
    constexpr std::ptrdiff_t m_nState = 0x700; // int32_t
}

namespace CFuncWallToggle { // CFuncWall
}

namespace CFuncWater { // CBaseModelEntity
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x700; // CBuoyancyHelper
}

namespace CGameChoreoServices { // IChoreoServices
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_hScriptedSequence = 0xC; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_scriptState = 0x10; // IChoreoServices::ScriptState_t
    constexpr std::ptrdiff_t m_choreoState = 0x14; // IChoreoServices::ChoreoState_t
    constexpr std::ptrdiff_t m_flTimeStartedState = 0x18; // GameTime_t
}

namespace CGameEnd { // CRulePointEntity
}

namespace CGameGibManager { // CBaseEntity
    constexpr std::ptrdiff_t m_bAllowNewGibs = 0x4D0; // bool
    constexpr std::ptrdiff_t m_iCurrentMaxPieces = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_iMaxPieces = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iLastFrame = 0x4DC; // int32_t
}

namespace CGameMoney { // CRulePointEntity
    constexpr std::ptrdiff_t m_OnMoneySpent = 0x710; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMoneySpentFail = 0x738; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nMoney = 0x760; // int32_t
    constexpr std::ptrdiff_t m_strAwardText = 0x768; // CUtlString
}

namespace CGamePlayerEquip { // CRulePointEntity
}

namespace CGamePlayerZone { // CRuleBrushEntity
    constexpr std::ptrdiff_t m_OnPlayerInZone = 0x708; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerOutZone = 0x730; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayersInCount = 0x758; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_PlayersOutCount = 0x780; // CEntityOutputTemplate<int32_t>
}

namespace CGameRules {
    constexpr std::ptrdiff_t m_szQuestName = 0x8; // char[128]
    constexpr std::ptrdiff_t m_nQuestPhase = 0x88; // int32_t
}

namespace CGameRulesProxy { // CBaseEntity
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGameScriptedMoveData {
    constexpr std::ptrdiff_t m_vDest = 0x0; // Vector
    constexpr std::ptrdiff_t m_vSrc = 0xC; // Vector
    constexpr std::ptrdiff_t m_angSrc = 0x18; // QAngle
    constexpr std::ptrdiff_t m_angDst = 0x24; // QAngle
    constexpr std::ptrdiff_t m_angCurrent = 0x30; // QAngle
    constexpr std::ptrdiff_t m_flAngRate = 0x3C; // float
    constexpr std::ptrdiff_t m_flDuration = 0x40; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_nPrevMoveType = 0x48; // MoveType_t
    constexpr std::ptrdiff_t m_bActive = 0x49; // bool
    constexpr std::ptrdiff_t m_bTeleportOnEnd = 0x4A; // bool
    constexpr std::ptrdiff_t m_bEndOnDestinationReached = 0x4B; // bool
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x4C; // bool
    constexpr std::ptrdiff_t m_nType = 0x50; // ScriptedMoveType_t
    constexpr std::ptrdiff_t m_bSuccess = 0x54; // bool
    constexpr std::ptrdiff_t m_nForcedCrouchState = 0x58; // ForcedCrouchState_t
    constexpr std::ptrdiff_t m_bIgnoreCollisions = 0x5C; // bool
}

namespace CGameText { // CRulePointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_textParms = 0x718; // hudtextparms_t
}

namespace CGenericConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_nLinearMotionX = 0x510; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionY = 0x514; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionZ = 0x518; // JointMotion_t
    constexpr std::ptrdiff_t m_flLinearFrequencyX = 0x51C; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyY = 0x520; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyZ = 0x524; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioX = 0x528; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioY = 0x52C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioZ = 0x530; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseX = 0x534; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseY = 0x538; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseZ = 0x53C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeX = 0x540; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeY = 0x544; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeZ = 0x548; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeX = 0x54C; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeY = 0x550; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeZ = 0x554; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdX = 0x558; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdY = 0x55C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdZ = 0x560; // float
    constexpr std::ptrdiff_t m_flNotifyForceX = 0x564; // float
    constexpr std::ptrdiff_t m_flNotifyForceY = 0x568; // float
    constexpr std::ptrdiff_t m_flNotifyForceZ = 0x56C; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeX = 0x570; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeY = 0x574; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeZ = 0x578; // float
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeX = 0x57C; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeY = 0x580; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeZ = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_bAxisNotifiedX = 0x588; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedY = 0x589; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedZ = 0x58A; // bool
    constexpr std::ptrdiff_t m_nAngularMotionX = 0x58C; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionY = 0x590; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionZ = 0x594; // JointMotion_t
    constexpr std::ptrdiff_t m_flAngularFrequencyX = 0x598; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyY = 0x59C; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyZ = 0x5A0; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioX = 0x5A4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioY = 0x5A8; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioZ = 0x5AC; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseX = 0x5B0; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseY = 0x5B4; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseZ = 0x5B8; // float
    constexpr std::ptrdiff_t m_NotifyForceReachedX = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedY = 0x5E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedZ = 0x610; // CEntityIOOutput
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGradientFog { // CBaseEntity
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x4B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D0; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4D4; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x4D8; // float
    constexpr std::ptrdiff_t m_fogColor = 0x4DC; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x4E0; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4E4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x4EA; // bool
}

namespace CGunTarget { // CBaseToggle
    constexpr std::ptrdiff_t m_on = 0x780; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x784; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_OnDeath = 0x788; // CEntityIOOutput
}

namespace CHEGrenade { // CBaseCSGrenade
}

namespace CHEGrenadeProjectile { // CBaseCSGrenadeProjectile
}

namespace CHandleDummy { // CBaseEntity
}

namespace CHandleTest { // CBaseEntity
    constexpr std::ptrdiff_t m_Handle = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x4B4; // bool
}

namespace CHintMessage {
    constexpr std::ptrdiff_t m_hintString = 0x8; // char*
    constexpr std::ptrdiff_t m_args = 0x10; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_duration = 0x28; // float
}

namespace CHintMessageQueue {
    constexpr std::ptrdiff_t m_tmMessageEnd = 0x8; // float
    constexpr std::ptrdiff_t m_messages = 0x10; // CUtlVector<CHintMessage*>
    constexpr std::ptrdiff_t m_pPlayerController = 0x28; // CBasePlayerController*
}

namespace CHitboxComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CHostage { // CHostageExpresserShim
    constexpr std::ptrdiff_t m_OnHostageBeginGrab = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFirstPickedUp = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDroppedNotRescued = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRescued = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_entitySpottedState = 0xA88; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xAA0; // int32_t
    constexpr std::ptrdiff_t m_uiHostageSpawnExclusionGroupMask = 0xAA4; // uint32_t
    constexpr std::ptrdiff_t m_nHostageSpawnRandomFactor = 0xAA8; // uint32_t
    constexpr std::ptrdiff_t m_bRemove = 0xAAC; // bool
    constexpr std::ptrdiff_t m_vel = 0xAB0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0xABC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xABD; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0xAC0; // int32_t
    constexpr std::ptrdiff_t m_leader = 0xAC4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastLeader = 0xAC8; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_reuseTimer = 0xAD0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xAE8; // bool
    constexpr std::ptrdiff_t m_accel = 0xAEC; // Vector
    constexpr std::ptrdiff_t m_isRunning = 0xAF8; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xAF9; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xB00; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xB18; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2B28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2B40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2BD0; // CountdownTimer
    constexpr std::ptrdiff_t m_wiggleTimer = 0x2BF0; // CountdownTimer
    constexpr std::ptrdiff_t m_isAdjusted = 0x2C0C; // bool
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x2C0D; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x2C10; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x2C14; // GameTime_t
    constexpr std::ptrdiff_t m_vecPositionWhenStartedDroppingToGround = 0x2C18; // Vector
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x2C24; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x2C30; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x2C34; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x2C38; // GameTime_t
    constexpr std::ptrdiff_t m_nApproachRewardPayouts = 0x2C3C; // int32_t
    constexpr std::ptrdiff_t m_nPickupEventCount = 0x2C40; // int32_t
    constexpr std::ptrdiff_t m_vecSpawnGroundPos = 0x2C44; // Vector
}

namespace CHostageAlias_info_hostage_spawn { // CHostage
}

namespace CHostageCarriableProp { // CBaseAnimGraph
}

namespace CHostageExpresserShim { // CBaseCombatCharacter
    constexpr std::ptrdiff_t m_pExpresser = 0x9D0; // CAI_Expresser*
}

namespace CHostageRescueZone { // CHostageRescueZoneShim
}

namespace CHostageRescueZoneShim { // CBaseTrigger
}

namespace CInButtonState {
    constexpr std::ptrdiff_t m_pButtonStates = 0x8; // uint64_t[3]
}

namespace CIncendiaryGrenade { // CMolotovGrenade
}

namespace CInferno { // CBaseModelEntity
    constexpr std::ptrdiff_t m_firePositions = 0x710; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0xA10; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0xD10; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0xD50; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1050; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1054; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1058; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x105C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1060; // bool
    constexpr std::ptrdiff_t m_nFiresExtinguishCount = 0x1064; // int32_t
    constexpr std::ptrdiff_t m_bWasCreatedInSmoke = 0x1068; // bool
    constexpr std::ptrdiff_t m_extent = 0x1270; // Extent
    constexpr std::ptrdiff_t m_damageTimer = 0x1288; // CountdownTimer
    constexpr std::ptrdiff_t m_damageRampTimer = 0x12A0; // CountdownTimer
    constexpr std::ptrdiff_t m_splashVelocity = 0x12B8; // Vector
    constexpr std::ptrdiff_t m_InitialSplashVelocity = 0x12C4; // Vector
    constexpr std::ptrdiff_t m_startPos = 0x12D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0x12DC; // Vector
    constexpr std::ptrdiff_t m_activeTimer = 0x12E8; // IntervalTimer
    constexpr std::ptrdiff_t m_fireSpawnOffset = 0x12F8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFlames = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_BookkeepingTimer = 0x1300; // CountdownTimer
    constexpr std::ptrdiff_t m_NextSpreadTimer = 0x1318; // CountdownTimer
    constexpr std::ptrdiff_t m_nSourceItemDefIndex = 0x1330; // uint16_t
}

namespace CInfoData { // CServerOnlyEntity
}

namespace CInfoDeathmatchSpawn { // SpawnPoint
}

namespace CInfoDynamicShadowHint { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flRange = 0x4B4; // float
    constexpr std::ptrdiff_t m_nImportance = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x4C0; // CHandle<CBaseEntity>
}

namespace CInfoDynamicShadowHintBox { // CInfoDynamicShadowHint
    constexpr std::ptrdiff_t m_vBoxMins = 0x4C8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4D4; // Vector
}

namespace CInfoEnemyTerroristSpawn { // SpawnPointCoopEnemy
}

namespace CInfoGameEventProxy { // CPointEntity
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRange = 0x4B8; // float
}

namespace CInfoInstructorHintBombTargetA { // CPointEntity
}

namespace CInfoInstructorHintBombTargetB { // CPointEntity
}

namespace CInfoInstructorHintHostageRescueZone { // CPointEntity
}

namespace CInfoInstructorHintTarget { // CPointEntity
}

namespace CInfoLadderDismount { // CBaseEntity
}

namespace CInfoLandmark { // CPointEntity
}

namespace CInfoOffscreenPanoramaTexture { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x4D0; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x4F0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_szTargetsName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AdditionalTargetEntities = 0x510; // CUtlVector<CHandle<CBaseModelEntity>>
}

namespace CInfoParticleTarget { // CPointEntity
}

namespace CInfoPlayerCounterterrorist { // SpawnPoint
}

namespace CInfoPlayerStart { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
}

namespace CInfoPlayerTerrorist { // SpawnPoint
}

namespace CInfoSpawnGroupLandmark { // CPointEntity
}

namespace CInfoSpawnGroupLoadUnload { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadStarted = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadFinished = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadStarted = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadFinished = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSpawnGroupName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpawnGroupFilterName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLandmarkName = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sFixedSpawnGroupName = 0x568; // CUtlString
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x570; // float
    constexpr std::ptrdiff_t m_bStreamingStarted = 0x574; // bool
    constexpr std::ptrdiff_t m_bUnloadingStarted = 0x575; // bool
}

namespace CInfoTarget { // CPointEntity
}

namespace CInfoTargetServerOnly { // CServerOnlyPointEntity
}

namespace CInfoTeleportDestination { // CPointEntity
}

namespace CInfoVisibilityBox { // CBaseEntity
    constexpr std::ptrdiff_t m_nMode = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
}

namespace CInfoWorldLayer { // CBaseEntity
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x4EA; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x4EC; // uint32_t
}

namespace CInstancedSceneEntity { // CSceneEntity
    constexpr std::ptrdiff_t m_hOwner = 0xA08; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bHadOwner = 0xA0C; // bool
    constexpr std::ptrdiff_t m_flPostSpeakDelay = 0xA10; // float
    constexpr std::ptrdiff_t m_flPreDelay = 0xA14; // float
    constexpr std::ptrdiff_t m_bIsBackground = 0xA18; // bool
}

namespace CInstructorEventEntity { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetPlayer = 0x4C0; // CHandle<CBasePlayerPawn>
}

namespace CIronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x8; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0xC; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x10; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x14; // float
}

namespace CItem { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_OnPlayerTouch = 0x898; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActivateWhenAtRest = 0x8C0; // bool
    constexpr std::ptrdiff_t m_OnCacheInteraction = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGlovePulled = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0x940; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0x94C; // QAngle
    constexpr std::ptrdiff_t m_bPhysStartAsleep = 0x958; // bool
}

namespace CItemAssaultSuit { // CItem
}

namespace CItemDefuser { // CItem
    constexpr std::ptrdiff_t m_entitySpottedState = 0x968; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x980; // int32_t
}

namespace CItemDefuserAlias_item_defuser { // CItemDefuser
}

namespace CItemDogtags { // CItem
    constexpr std::ptrdiff_t m_OwningPlayer = 0x968; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x96C; // CHandle<CCSPlayerPawn>
}

namespace CItemGeneric { // CItem
    constexpr std::ptrdiff_t m_bHasTriggerRadius = 0x970; // bool
    constexpr std::ptrdiff_t m_bHasPickupRadius = 0x971; // bool
    constexpr std::ptrdiff_t m_flPickupRadiusSqr = 0x974; // float
    constexpr std::ptrdiff_t m_flTriggerRadiusSqr = 0x978; // float
    constexpr std::ptrdiff_t m_flLastPickupCheck = 0x97C; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayerCounterListenerAdded = 0x980; // bool
    constexpr std::ptrdiff_t m_bPlayerInTriggerRadius = 0x981; // bool
    constexpr std::ptrdiff_t m_hSpawnParticleEffect = 0x988; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pAmbientSoundEffect = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAutoStartAmbientSound = 0x998; // bool
    constexpr std::ptrdiff_t m_pSpawnScriptFunction = 0x9A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupParticleEffect = 0x9A8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pPickupSoundEffect = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupScriptFunction = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTimeoutParticleEffect = 0x9C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pTimeoutSoundEffect = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pTimeoutScriptFunction = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupFilterName = 0x9D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupFilter = 0x9E0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnPickup = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimeout = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerStartTouch = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerTouch = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerEndTouch = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pAllowPickupScriptFunction = 0xAB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPickupRadius = 0xAB8; // float
    constexpr std::ptrdiff_t m_flTriggerRadius = 0xABC; // float
    constexpr std::ptrdiff_t m_pTriggerSoundEffect = 0xAC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bGlowWhenInTrigger = 0xAC8; // bool
    constexpr std::ptrdiff_t m_glowColor = 0xAC9; // Color
    constexpr std::ptrdiff_t m_bUseable = 0xACD; // bool
    constexpr std::ptrdiff_t m_hTriggerHelper = 0xAD0; // CHandle<CItemGenericTriggerHelper>
}

namespace CItemGenericTriggerHelper { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hParentItem = 0x700; // CHandle<CItemGeneric>
}

namespace CItemHeavyAssaultSuit { // CItemAssaultSuit
}

namespace CItemKevlar { // CItem
}

namespace CItemSoda { // CBaseAnimGraph
}

namespace CItem_Healthshot { // CWeaponBaseItem
}

namespace CKeepUpright { // CPointEntity
    constexpr std::ptrdiff_t m_worldGoalAxis = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_localTestAxis = 0x4C4; // Vector
    constexpr std::ptrdiff_t m_nameAttach = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_attachedObject = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_angularLimit = 0x4E4; // float
    constexpr std::ptrdiff_t m_bActive = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bDampAllRotation = 0x4E9; // bool
}

namespace CKnife { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bFirstAttack = 0xE18; // bool
}

namespace CLightComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x1C0; // bool
}

namespace CLightDirectionalEntity { // CLightEntity
}

namespace CLightEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_CLightComponent = 0x700; // CLightComponent*
}

namespace CLightEnvironmentEntity { // CLightDirectionalEntity
}

namespace CLightGlow { // CBaseModelEntity
    constexpr std::ptrdiff_t m_nHorizontalSize = 0x700; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0x710; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x714; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x718; // float
}

namespace CLightOrthoEntity { // CLightEntity
}

namespace CLightSpotEntity { // CLightEntity
}

namespace CLogicAchievement { // CLogicalEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszAchievementEventID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnFired = 0x4C0; // CEntityIOOutput
}

namespace CLogicActiveAutosave { // CLogicAutosave
    constexpr std::ptrdiff_t m_TriggerHitPoints = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flTimeToTrigger = 0x4C4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4CC; // float
}

namespace CLogicAuto { // CBaseEntity
    constexpr std::ptrdiff_t m_OnMapSpawn = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDemoMapSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNewGame = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLoadGame = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMapTransition = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBackgroundMap = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewMap = 0x5A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewRound = 0x5C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVREnabled = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVRNotEnabled = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_globalstate = 0x640; // CUtlSymbolLarge
}

namespace CLogicAutosave { // CLogicalEntity
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4B0; // bool
    constexpr std::ptrdiff_t m_minHitPoints = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_minHitPointsToCommit = 0x4B8; // int32_t
}

namespace CLogicBranch { // CLogicalEntity
    constexpr std::ptrdiff_t m_bInValue = 0x4B0; // bool
    constexpr std::ptrdiff_t m_Listeners = 0x4B8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_OnTrue = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFalse = 0x4F8; // CEntityIOOutput
}

namespace CLogicBranchList { // CLogicalEntity
    constexpr std::ptrdiff_t m_nLogicBranchNames = 0x4B0; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_LogicBranchList = 0x530; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_eLastState = 0x548; // CLogicBranchList::LogicBranchListenerLastState_t
    constexpr std::ptrdiff_t m_OnAllTrue = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAllFalse = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMixed = 0x5A0; // CEntityIOOutput
}

namespace CLogicCase { // CLogicalEntity
    constexpr std::ptrdiff_t m_nCase = 0x4B0; // CUtlSymbolLarge[32]
    constexpr std::ptrdiff_t m_nShuffleCases = 0x5B0; // int32_t
    constexpr std::ptrdiff_t m_nLastShuffleCase = 0x5B4; // int32_t
    constexpr std::ptrdiff_t m_uchShuffleCaseMap = 0x5B8; // uint8_t[32]
    constexpr std::ptrdiff_t m_OnCase = 0x5D8; // CEntityIOOutput[32]
    constexpr std::ptrdiff_t m_OnDefault = 0xAD8; // CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>
}

namespace CLogicCollisionPair { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_disabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_succeeded = 0x4C1; // bool
}

namespace CLogicCompare { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInValue = 0x4B0; // float
    constexpr std::ptrdiff_t m_flCompareValue = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnLessThan = 0x4B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnEqualTo = 0x4E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnNotEqualTo = 0x508; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x530; // CEntityOutputTemplate<float>
}

namespace CLogicDistanceAutosave { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszTargetEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceToPlayer = 0x4B8; // float
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bCheckCough = 0x4BD; // bool
    constexpr std::ptrdiff_t m_bThinkDangerous = 0x4BE; // bool
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4C0; // float
}

namespace CLogicDistanceCheck { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszEntityA = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityB = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flZone1Distance = 0x4C0; // float
    constexpr std::ptrdiff_t m_flZone2Distance = 0x4C4; // float
    constexpr std::ptrdiff_t m_InZone1 = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone2 = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone3 = 0x518; // CEntityIOOutput
}

namespace CLogicGameEvent { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
}

namespace CLogicGameEventListener { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnEventFired = 0x4C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszGameEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszGameEventItem = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bEnabled = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4F9; // bool
}

namespace CLogicLineToEntity { // CLogicalEntity
    constexpr std::ptrdiff_t m_Line = 0x4B0; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_SourceName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_StartEntity = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_EndEntity = 0x4E4; // CHandle<CBaseEntity>
}

namespace CLogicMeasureMovement { // CLogicalEntity
    constexpr std::ptrdiff_t m_strMeasureTarget = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMeasureReference = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strTargetReference = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hMeasureReference = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTargetReference = 0x4D4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flScale = 0x4D8; // float
    constexpr std::ptrdiff_t m_nMeasureType = 0x4DC; // int32_t
}

namespace CLogicNPCCounter { // CBaseEntity
    constexpr std::ptrdiff_t m_OnMinCountAll = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCountAll = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactorAll = 0x500; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDistAll = 0x528; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_1 = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_1 = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_1 = 0x5A0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_1 = 0x5C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_2 = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_2 = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_2 = 0x640; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_2 = 0x668; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_3 = 0x690; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_3 = 0x6B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_3 = 0x6E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_3 = 0x708; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_hSource = 0x730; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceMax = 0x740; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x744; // bool
    constexpr std::ptrdiff_t m_nMinCountAll = 0x748; // int32_t
    constexpr std::ptrdiff_t m_nMaxCountAll = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactorAll = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactorAll = 0x754; // int32_t
    constexpr std::ptrdiff_t m_iszNPCClassname_1 = 0x760; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_1 = 0x768; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_1 = 0x76C; // bool
    constexpr std::ptrdiff_t m_nMinCount_1 = 0x770; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_1 = 0x774; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_1 = 0x778; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_1 = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_1 = 0x784; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_2 = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_2 = 0x790; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_2 = 0x794; // bool
    constexpr std::ptrdiff_t m_nMinCount_2 = 0x798; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_2 = 0x79C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_2 = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_2 = 0x7A4; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_2 = 0x7AC; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_3 = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_3 = 0x7B8; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_3 = 0x7BC; // bool
    constexpr std::ptrdiff_t m_nMinCount_3 = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_3 = 0x7C4; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_3 = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_3 = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_3 = 0x7D4; // float
}

namespace CLogicNPCCounterAABB { // CLogicNPCCounter
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x7FC; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x808; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x814; // Vector
}

namespace CLogicNPCCounterOBB { // CLogicNPCCounterAABB
}

namespace CLogicNavigation { // CLogicalEntity
    constexpr std::ptrdiff_t m_isOn = 0x4B8; // bool
    constexpr std::ptrdiff_t m_navProperty = 0x4BC; // navproperties_t
}

namespace CLogicPlayerProxy { // CLogicalEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PlayerHasAmmo = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerHasNoAmmo = 0x4E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerDied = 0x508; // CEntityIOOutput
    constexpr std::ptrdiff_t m_RequestedPlayerHealth = 0x530; // CEntityOutputTemplate<int32_t>
}

namespace CLogicProximity { // CPointEntity
}

namespace CLogicRelay { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTrigger = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x500; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x501; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x502; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x503; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x504; // bool
}

namespace CLogicScript { // CPointEntity
}

namespace CLogicalEntity { // CServerOnlyEntity
}

namespace CMapInfo { // CPointEntity
    constexpr std::ptrdiff_t m_iBuyingStatus = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flBombRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iPetPopulation = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_bUseNormalSpawnsForDM = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bDisableAutoGeneratedDMSpawns = 0x4BD; // bool
    constexpr std::ptrdiff_t m_flBotMaxVisionDistance = 0x4C0; // float
    constexpr std::ptrdiff_t m_iHostageCount = 0x4C4; // int32_t
    constexpr std::ptrdiff_t m_bFadePlayerVisibilityFarZ = 0x4C8; // bool
}

namespace CMapVetoPickController { // CBaseEntity
    constexpr std::ptrdiff_t m_bPlayedIntroVcd = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bNeedToPlayFiveSecondsRemaining = 0x4B1; // bool
    constexpr std::ptrdiff_t m_dblPreMatchDraftSequenceTime = 0x4D0; // double
    constexpr std::ptrdiff_t m_bPreMatchDraftStateChanged = 0x4D8; // bool
    constexpr std::ptrdiff_t m_nDraftType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x4E4; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x5E4; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x600; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x700; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x800; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x900; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC00; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD00; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE00; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE04; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE08; // int32_t
    constexpr std::ptrdiff_t m_OnMapVetoed = 0xE10; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnMapPicked = 0xE38; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnSidesPicked = 0xE60; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnNewPhaseStarted = 0xE88; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnLevelTransition = 0xEB0; // CEntityOutputTemplate<int32_t>
}

namespace CMarkupVolume { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
}

namespace CMarkupVolumeTagged { // CMarkupVolume
    constexpr std::ptrdiff_t m_bIsGroup = 0x738; // bool
    constexpr std::ptrdiff_t m_bGroupByPrefab = 0x739; // bool
    constexpr std::ptrdiff_t m_bGroupByVolume = 0x73A; // bool
    constexpr std::ptrdiff_t m_bGroupOtherGroups = 0x73B; // bool
    constexpr std::ptrdiff_t m_bIsInGroup = 0x73C; // bool
}

namespace CMarkupVolumeTagged_Nav { // CMarkupVolumeTagged
}

namespace CMarkupVolumeTagged_NavGame { // CMarkupVolumeWithRef
    constexpr std::ptrdiff_t m_bFloodFillAttribute = 0x758; // bool
}

namespace CMarkupVolumeWithRef { // CMarkupVolumeTagged
    constexpr std::ptrdiff_t m_bUseRef = 0x740; // bool
    constexpr std::ptrdiff_t m_vRefPos = 0x744; // Vector
    constexpr std::ptrdiff_t m_flRefDot = 0x750; // float
}

namespace CMathColorBlend { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_OutColor1 = 0x4B8; // Color
    constexpr std::ptrdiff_t m_OutColor2 = 0x4BC; // Color
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<Color>
}

namespace CMathCounter { // CLogicalEntity
    constexpr std::ptrdiff_t m_flMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_bHitMin = 0x4B8; // bool
    constexpr std::ptrdiff_t m_bHitMax = 0x4B9; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x4BA; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGetValue = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnHitMin = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHitMax = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMin = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMax = 0x588; // CEntityIOOutput
}

namespace CMathRemap { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flOut1 = 0x4B8; // float
    constexpr std::ptrdiff_t m_flOut2 = 0x4BC; // float
    constexpr std::ptrdiff_t m_flOldInValue = 0x4C0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoseAboveMin = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRoseAboveMax = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMin = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMax = 0x568; // CEntityIOOutput
}

namespace CMelee { // CCSWeaponBase
    constexpr std::ptrdiff_t m_flThrowAt = 0xE18; // GameTime_t
    constexpr std::ptrdiff_t m_hThrower = 0xE1C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bDidThrowDamage = 0xE20; // bool
}

namespace CMessage { // CPointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_MessageVolume = 0x4B8; // float
    constexpr std::ptrdiff_t m_MessageAttenuation = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_Radius = 0x4C0; // float
    constexpr std::ptrdiff_t m_sNoise = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnShowMessage = 0x4D0; // CEntityIOOutput
}

namespace CMessageEntity { // CPointEntity
    constexpr std::ptrdiff_t m_radius = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_messageText = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_drawText = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bDeveloperOnly = 0x4C1; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4C2; // bool
}

namespace CModelPointEntity { // CBaseModelEntity
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CMolotovGrenade { // CBaseCSGrenade
}

namespace CMolotovProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0xA30; // bool
    constexpr std::ptrdiff_t m_bDetonated = 0xA3C; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0xA40; // IntervalTimer
    constexpr std::ptrdiff_t m_bHasBouncedOffPlayer = 0xB20; // bool
}

namespace CMomentaryRotButton { // CRotButton
    constexpr std::ptrdiff_t m_Position = 0x8C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnUnpressed = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedPosition = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_lastUsed = 0x990; // int32_t
    constexpr std::ptrdiff_t m_start = 0x994; // QAngle
    constexpr std::ptrdiff_t m_end = 0x9A0; // QAngle
    constexpr std::ptrdiff_t m_IdealYaw = 0x9AC; // float
    constexpr std::ptrdiff_t m_sNoise = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUpdateTarget = 0x9B8; // bool
    constexpr std::ptrdiff_t m_direction = 0x9BC; // int32_t
    constexpr std::ptrdiff_t m_returnSpeed = 0x9C0; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x9C4; // float
}

namespace CMotorController {
    constexpr std::ptrdiff_t m_speed = 0x8; // float
    constexpr std::ptrdiff_t m_maxTorque = 0xC; // float
    constexpr std::ptrdiff_t m_axis = 0x10; // Vector
    constexpr std::ptrdiff_t m_inertiaFactor = 0x1C; // float
}

namespace CMultiLightProxy { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszLightNameFilter = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLightClassFilter = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flLightRadiusFilter = 0x4C0; // float
    constexpr std::ptrdiff_t m_flBrightnessDelta = 0x4C4; // float
    constexpr std::ptrdiff_t m_bPerformScreenFade = 0x4C8; // bool
    constexpr std::ptrdiff_t m_flTargetBrightnessMultiplier = 0x4CC; // float
    constexpr std::ptrdiff_t m_flCurrentBrightnessMultiplier = 0x4D0; // float
    constexpr std::ptrdiff_t m_vecLights = 0x4D8; // CUtlVector<CHandle<CLightEntity>>
}

namespace CMultiSource { // CLogicalEntity
    constexpr std::ptrdiff_t m_rgEntities = 0x4B0; // CHandle<CBaseEntity>[32]
    constexpr std::ptrdiff_t m_rgTriggered = 0x530; // int32_t[32]
    constexpr std::ptrdiff_t m_OnTrigger = 0x5B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iTotal = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_globalstate = 0x5E0; // CUtlSymbolLarge
}

namespace CMultiplayRules { // CGameRules
}

namespace CMultiplayer_Expresser { // CAI_ExpresserWithFollowup
    constexpr std::ptrdiff_t m_bAllowMultipleScenes = 0x70; // bool
}

namespace CNavHullPresetVData {
    constexpr std::ptrdiff_t m_vecNavHulls = 0x0; // CUtlVector<CUtlString>
}

namespace CNavHullVData {
    constexpr std::ptrdiff_t m_bAgentEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_agentRadius = 0x4; // float
    constexpr std::ptrdiff_t m_agentHeight = 0x8; // float
    constexpr std::ptrdiff_t m_agentShortHeightEnabled = 0xC; // bool
    constexpr std::ptrdiff_t m_agentShortHeight = 0x10; // float
    constexpr std::ptrdiff_t m_agentMaxClimb = 0x14; // float
    constexpr std::ptrdiff_t m_agentMaxSlope = 0x18; // int32_t
    constexpr std::ptrdiff_t m_agentMaxJumpDownDist = 0x1C; // float
    constexpr std::ptrdiff_t m_agentMaxJumpHorizDistBase = 0x20; // float
    constexpr std::ptrdiff_t m_agentMaxJumpUpDist = 0x24; // float
    constexpr std::ptrdiff_t m_agentBorderErosion = 0x28; // int32_t
}

namespace CNavLinkAnimgraphVar {
    constexpr std::ptrdiff_t m_strAnimgraphVar = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_unAlignmentDegrees = 0x8; // uint32_t
}

namespace CNavLinkAreaEntity { // CPointEntity
    constexpr std::ptrdiff_t m_flWidth = 0x4B0; // float
    constexpr std::ptrdiff_t m_vLocatorOffset = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_qLocatorAnglesOffset = 0x4C0; // QAngle
    constexpr std::ptrdiff_t m_strMovementForward = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMovementReverse = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNavLinkIdForward = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nNavLinkIdReverse = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_strFilterName = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4F8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnNavLinkStart = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNavLinkFinish = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsTerminus = 0x550; // bool
}

namespace CNavLinkMovementVData {
    constexpr std::ptrdiff_t m_bIsInterpolated = 0x0; // bool
    constexpr std::ptrdiff_t m_unRecommendedDistance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vecAnimgraphVars = 0x8; // CUtlVector<CNavLinkAnimgraphVar>
}

namespace CNavSpaceInfo { // CPointEntity
    constexpr std::ptrdiff_t m_bCreateFlightSpace = 0x4B0; // bool
}

namespace CNavVolume {
}

namespace CNavVolumeAll { // CNavVolumeVector
}

namespace CNavVolumeBreadthFirstSearch { // CNavVolumeCalculatedVector
    constexpr std::ptrdiff_t m_vStartPos = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flSearchDist = 0xAC; // float
}

namespace CNavVolumeCalculatedVector { // CNavVolume
}

namespace CNavVolumeMarkupVolume { // CNavVolume
}

namespace CNavVolumeSphere { // CNavVolume
    constexpr std::ptrdiff_t m_vCenter = 0x70; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x7C; // float
}

namespace CNavVolumeSphericalShell { // CNavVolumeSphere
    constexpr std::ptrdiff_t m_flRadiusInner = 0x80; // float
}

namespace CNavVolumeVector { // CNavVolume
    constexpr std::ptrdiff_t m_bHasBeenPreFiltered = 0x78; // bool
}

namespace CNavWalkable { // CPointEntity
}

namespace CNetworkOriginCellCoordQuantizedVector {
    constexpr std::ptrdiff_t m_cellX = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_cellY = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_cellZ = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nOutsideWorld = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_vecX = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x20; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x28; // CNetworkedQuantizedFloat
}

namespace CNetworkOriginQuantizedVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkTransmitComponent {
    constexpr std::ptrdiff_t m_nTransmitStateOwnedCounter = 0x16C; // uint8_t
}

namespace CNetworkVelocityVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkViewOffsetVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace CNullEntity { // CBaseEntity
}

namespace COmniLight { // CBarnLight
    constexpr std::ptrdiff_t m_flInnerAngle = 0x928; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0x92C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0x930; // bool
}

namespace COrnamentProp { // CDynamicProp
    constexpr std::ptrdiff_t m_initialOwner = 0xB08; // CUtlSymbolLarge
}

namespace CParticleSystem { // CBaseModelEntity
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0x700; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0x900; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0x901; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x904; // float
    constexpr std::ptrdiff_t m_nStopType = 0x908; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0x90C; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0x910; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0x918; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0x91C; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0x920; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0x950; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0x954; // CHandle<CBaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0xA54; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0xA55; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0xA56; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0xA57; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0xA58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0xA60; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0xC60; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0xC64; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0xC70; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0xC74; // Color
}

namespace CPathCorner { // CPointEntity
    constexpr std::ptrdiff_t m_flWait = 0x4B0; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
}

namespace CPathCornerCrash { // CPathCorner
}

namespace CPathKeyFrame { // CLogicalEntity
    constexpr std::ptrdiff_t m_Origin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_Angles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_qAngle = 0x4D0; // Quaternion
    constexpr std::ptrdiff_t m_iNextKey = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flNextTime = 0x4E8; // float
    constexpr std::ptrdiff_t m_pNextKey = 0x4F0; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPrevKey = 0x4F8; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flSpeed = 0x500; // float
}

namespace CPathParticleRope { // CBaseEntity
    constexpr std::ptrdiff_t m_bStartActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x4B4; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x4C0; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x4D8; // float
    constexpr std::ptrdiff_t m_flSlack = 0x4DC; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x4E4; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x4F0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x4F8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x510; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x528; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x540; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x558; // CNetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x570; // CNetworkUtlVectorBase<float>
}

namespace CPathParticleRopeAlias_path_particle_rope_clientside { // CPathParticleRope
}

namespace CPathTrack { // CPointEntity
    constexpr std::ptrdiff_t m_pnext = 0x4B0; // CPathTrack*
    constexpr std::ptrdiff_t m_pprevious = 0x4B8; // CPathTrack*
    constexpr std::ptrdiff_t m_paltpath = 0x4C0; // CPathTrack*
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_length = 0x4CC; // float
    constexpr std::ptrdiff_t m_altName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nIterVal = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_eOrientationType = 0x4DC; // TrackOrientationType_t
    constexpr std::ptrdiff_t m_OnPass = 0x4E0; // CEntityIOOutput
}

namespace CPhysBallSocket { // CPhysConstraint
    constexpr std::ptrdiff_t m_flFriction = 0x508; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x50C; // bool
    constexpr std::ptrdiff_t m_flSwingLimit = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinTwistAngle = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxTwistAngle = 0x51C; // float
}

namespace CPhysBox { // CBreakable
    constexpr std::ptrdiff_t m_damageType = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_massScale = 0x7C4; // float
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0x7CC; // float
    constexpr std::ptrdiff_t m_angPreferredCarryAngles = 0x7D0; // QAngle
    constexpr std::ptrdiff_t m_bNotSolidToWorld = 0x7DC; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0x7DD; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_flTouchOutputPerEntityDelay = 0x7E4; // float
    constexpr std::ptrdiff_t m_OnDamaged = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMotionEnabled = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouch = 0x888; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hCarryingPlayer = 0x8B0; // CHandle<CBasePlayerPawn>
}

namespace CPhysConstraint { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_breakSound = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceLimit = 0x4D0; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x4D4; // float
    constexpr std::ptrdiff_t m_teleportTick = 0x4D8; // uint32_t
    constexpr std::ptrdiff_t m_minTeleportDistance = 0x4DC; // float
    constexpr std::ptrdiff_t m_OnBreak = 0x4E0; // CEntityIOOutput
}

namespace CPhysExplosion { // CPointEntity
    constexpr std::ptrdiff_t m_bExplodeOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flDamage = 0x4B8; // float
    constexpr std::ptrdiff_t m_radius = 0x4BC; // float
    constexpr std::ptrdiff_t m_targetEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_flPushScale = 0x4CC; // float
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x4D0; // bool
    constexpr std::ptrdiff_t m_OnPushedPlayer = 0x4D8; // CEntityIOOutput
}

namespace CPhysFixed { // CPhysConstraint
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0x510; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0x514; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x519; // bool
}

namespace CPhysForce { // CPointEntity
    constexpr std::ptrdiff_t m_nameAttach = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_force = 0x4C0; // float
    constexpr std::ptrdiff_t m_forceTime = 0x4C4; // float
    constexpr std::ptrdiff_t m_attachedObject = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_wasRestored = 0x4CC; // bool
    constexpr std::ptrdiff_t m_integrator = 0x4D0; // CConstantForceController
}

namespace CPhysHinge { // CPhysConstraint
    constexpr std::ptrdiff_t m_soundInfo = 0x510; // ConstraintSoundInfo
    constexpr std::ptrdiff_t m_NotifyMinLimitReached = 0x598; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyMaxLimitReached = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAtMinLimit = 0x5E8; // bool
    constexpr std::ptrdiff_t m_bAtMaxLimit = 0x5E9; // bool
    constexpr std::ptrdiff_t m_hinge = 0x5EC; // constraint_hingeparams_t
    constexpr std::ptrdiff_t m_hingeFriction = 0x62C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x630; // float
    constexpr std::ptrdiff_t m_bIsAxisLocal = 0x634; // bool
    constexpr std::ptrdiff_t m_flMinRotation = 0x638; // float
    constexpr std::ptrdiff_t m_flMaxRotation = 0x63C; // float
    constexpr std::ptrdiff_t m_flInitialRotation = 0x640; // float
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x644; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x648; // float
    constexpr std::ptrdiff_t m_flAngleSpeed = 0x64C; // float
    constexpr std::ptrdiff_t m_flAngleSpeedThreshold = 0x650; // float
    constexpr std::ptrdiff_t m_OnStartMoving = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStopMoving = 0x680; // CEntityIOOutput
}

namespace CPhysHingeAlias_phys_hinge_local { // CPhysHinge
}

namespace CPhysImpact { // CPointEntity
    constexpr std::ptrdiff_t m_damage = 0x4B0; // float
    constexpr std::ptrdiff_t m_distance = 0x4B4; // float
    constexpr std::ptrdiff_t m_directionEntityName = 0x4B8; // CUtlSymbolLarge
}

namespace CPhysLength { // CPhysConstraint
    constexpr std::ptrdiff_t m_offset = 0x508; // Vector[2]
    constexpr std::ptrdiff_t m_vecAttach = 0x520; // Vector
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_minLength = 0x530; // float
    constexpr std::ptrdiff_t m_totalLength = 0x534; // float
    constexpr std::ptrdiff_t m_bEnableCollision = 0x538; // bool
}

namespace CPhysMagnet { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_OnMagnetAttach = 0x890; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMagnetDetach = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0x8E0; // float
    constexpr std::ptrdiff_t m_forceLimit = 0x8E4; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x8E8; // float
    constexpr std::ptrdiff_t m_MagnettedEntities = 0x8F0; // CUtlVector<magnetted_objects_t>
    constexpr std::ptrdiff_t m_bActive = 0x908; // bool
    constexpr std::ptrdiff_t m_bHasHitSomething = 0x909; // bool
    constexpr std::ptrdiff_t m_flTotalMass = 0x90C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x910; // float
    constexpr std::ptrdiff_t m_flNextSuckTime = 0x914; // GameTime_t
    constexpr std::ptrdiff_t m_iMaxObjectsAttached = 0x918; // int32_t
}

namespace CPhysMotor { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hAttachedObject = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_spinUp = 0x4BC; // float
    constexpr std::ptrdiff_t m_additionalAcceleration = 0x4C0; // float
    constexpr std::ptrdiff_t m_angularAcceleration = 0x4C4; // float
    constexpr std::ptrdiff_t m_lastTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_motor = 0x4E0; // CMotorController
}

namespace CPhysPulley { // CPhysConstraint
    constexpr std::ptrdiff_t m_position2 = 0x508; // Vector
    constexpr std::ptrdiff_t m_offset = 0x514; // Vector[2]
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_gearRatio = 0x530; // float
}

namespace CPhysSlideConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_axisEnd = 0x510; // Vector
    constexpr std::ptrdiff_t m_slideFriction = 0x51C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x520; // float
    constexpr std::ptrdiff_t m_initialOffset = 0x524; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x528; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x529; // bool
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x52C; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x530; // float
    constexpr std::ptrdiff_t m_bUseEntityPivot = 0x534; // bool
    constexpr std::ptrdiff_t m_soundInfo = 0x538; // ConstraintSoundInfo
}

namespace CPhysThruster { // CPhysForce
    constexpr std::ptrdiff_t m_localOrigin = 0x510; // Vector
}

namespace CPhysTorque { // CPhysForce
    constexpr std::ptrdiff_t m_axis = 0x510; // Vector
}

namespace CPhysWheelConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_flSuspensionFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flSuspensionDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flSuspensionHeightOffset = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableSuspensionLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinSuspensionOffset = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxSuspensionOffset = 0x51C; // float
    constexpr std::ptrdiff_t m_bEnableSteeringLimit = 0x520; // bool
    constexpr std::ptrdiff_t m_flMinSteeringAngle = 0x524; // float
    constexpr std::ptrdiff_t m_flMaxSteeringAngle = 0x528; // float
    constexpr std::ptrdiff_t m_flSteeringAxisFriction = 0x52C; // float
    constexpr std::ptrdiff_t m_flSpinAxisFriction = 0x530; // float
}

namespace CPhysicalButton { // CBaseButton
}

namespace CPhysicsEntitySolver { // CLogicalEntity
    constexpr std::ptrdiff_t m_hMovingEntity = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsBlocker = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_separationDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_cancelTime = 0x4C4; // GameTime_t
}

namespace CPhysicsProp { // CBreakableProp
    constexpr std::ptrdiff_t m_MotionEnabled = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwake = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAsleep = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xAB0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xAD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOutOfWorld = 0xB00; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0xB28; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xB2C; // float
    constexpr std::ptrdiff_t m_buoyancyScale = 0xB30; // float
    constexpr std::ptrdiff_t m_damageType = 0xB34; // int32_t
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0xB3C; // float
    constexpr std::ptrdiff_t m_bThrownByPlayer = 0xB40; // bool
    constexpr std::ptrdiff_t m_bDroppedByPlayer = 0xB41; // bool
    constexpr std::ptrdiff_t m_bTouchedByPlayer = 0xB42; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0xB43; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0xB44; // int32_t
    constexpr std::ptrdiff_t m_bHasBeenAwakened = 0xB48; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xB49; // bool
    constexpr std::ptrdiff_t m_fNextCheckDisableMotionContactsTime = 0xB4C; // GameTime_t
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xB50; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xB54; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xB58; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB5C; // Color
    constexpr std::ptrdiff_t m_bForceNavIgnore = 0xB60; // bool
    constexpr std::ptrdiff_t m_bNoNavmeshBlocker = 0xB61; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xB62; // bool
    constexpr std::ptrdiff_t m_bShouldAutoConvertBackFromDebris = 0xB63; // bool
    constexpr std::ptrdiff_t m_bMuteImpactEffects = 0xB64; // bool
    constexpr std::ptrdiff_t m_bAcceptDamageFromHeldObjects = 0xB6C; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0xB6D; // bool
    constexpr std::ptrdiff_t m_bAwake = 0xB6E; // bool
    constexpr std::ptrdiff_t m_nCollisionGroupOverride = 0xB70; // int32_t
}

namespace CPhysicsPropMultiplayer { // CPhysicsProp
}

namespace CPhysicsPropOverride { // CPhysicsProp
}

namespace CPhysicsPropRespawnable { // CPhysicsProp
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0xB78; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0xB84; // QAngle
    constexpr std::ptrdiff_t m_vOriginalMins = 0xB90; // Vector
    constexpr std::ptrdiff_t m_vOriginalMaxs = 0xB9C; // Vector
    constexpr std::ptrdiff_t m_flRespawnDuration = 0xBA8; // float
}

namespace CPhysicsShake {
    constexpr std::ptrdiff_t m_force = 0x8; // Vector
}

namespace CPhysicsSpring { // CBaseEntity
    constexpr std::ptrdiff_t m_flFrequency = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x4BC; // float
    constexpr std::ptrdiff_t m_flRestLength = 0x4C0; // float
    constexpr std::ptrdiff_t m_nameAttachStart = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttachEnd = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_start = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_end = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_teleportTick = 0x4F0; // uint32_t
}

namespace CPhysicsWire { // CBaseEntity
    constexpr std::ptrdiff_t m_nDensity = 0x4B0; // int32_t
}

namespace CPlantedC4 { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bBombTicking = 0x890; // bool
    constexpr std::ptrdiff_t m_flC4Blow = 0x894; // GameTime_t
    constexpr std::ptrdiff_t m_nBombSite = 0x898; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0x89C; // int32_t
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombBeginDefuse = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefuseAborted = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0x918; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x920; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x938; // int32_t
    constexpr std::ptrdiff_t m_bTrainingPlacedByPlayer = 0x93C; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0x93D; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0x940; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0x944; // bool
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0x94C; // GameTime_t
    constexpr std::ptrdiff_t m_flDefuseLength = 0x954; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0x958; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0x95C; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0x960; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0x964; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iProgressBarTime = 0x968; // int32_t
    constexpr std::ptrdiff_t m_bVoiceAlertFired = 0x96C; // bool
    constexpr std::ptrdiff_t m_bVoiceAlertPlayed = 0x96D; // bool[4]
    constexpr std::ptrdiff_t m_flNextBotBeepTime = 0x974; // GameTime_t
    constexpr std::ptrdiff_t m_bPlantedAfterPickup = 0x97C; // bool
    constexpr std::ptrdiff_t m_angCatchUpToPlayerEye = 0x980; // QAngle
    constexpr std::ptrdiff_t m_flLastSpinDetectionTime = 0x98C; // GameTime_t
}

namespace CPlatTrigger { // CBaseModelEntity
    constexpr std::ptrdiff_t m_pPlatform = 0x700; // CHandle<CFuncPlat>
}

namespace CPlayerControllerComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPawnComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPing { // CBaseEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x4B8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x4C4; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x4C5; // char[18]
}

namespace CPlayerSprayDecal { // CModelPointEntity
    constexpr std::ptrdiff_t m_nUniqueID = 0x700; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0x710; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0x71C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0x734; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0x740; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0x744; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0x748; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0x74C; // float
    constexpr std::ptrdiff_t m_nTintID = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0x754; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0x755; // uint8_t[128]
}

namespace CPlayerVisibility { // CBaseEntity
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4C1; // bool
}

namespace CPlayer_AutoaimServices { // CPlayerPawnComponent
}

namespace CPlayer_CameraServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<CColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<CTonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_hTriggerSoundscapeList = 0x158; // CUtlVector<CHandle<CEnvSoundscapeTriggerable>>
}

namespace CPlayer_FlashlightServices { // CPlayerPawnComponent
}

namespace CPlayer_ItemServices { // CPlayerPawnComponent
}

namespace CPlayer_MovementServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid { // CPlayer_MovementServices
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iTargetVolume = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_vecSmoothedVelocity = 0x210; // Vector
}

namespace CPlayer_ObserverServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
}

namespace CPlayer_UseServices { // CPlayerPawnComponent
}

namespace CPlayer_ViewModelServices { // CPlayerPawnComponent
}

namespace CPlayer_WaterServices { // CPlayerPawnComponent
}

namespace CPlayer_WeaponServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
    constexpr std::ptrdiff_t m_bPreventWeaponPickup = 0xA8; // bool
}

namespace CPointAngleSensor { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nLookAtName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hLookAtEntity = 0x4C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDuration = 0x4C8; // float
    constexpr std::ptrdiff_t m_flDotTolerance = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFacingTime = 0x4D0; // GameTime_t
    constexpr std::ptrdiff_t m_bFired = 0x4D4; // bool
    constexpr std::ptrdiff_t m_OnFacingLookat = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotFacingLookat = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_TargetDir = 0x528; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_FacingPercentage = 0x550; // CEntityOutputTemplate<float>
}

namespace CPointAngularVelocitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flThreshold = 0x4B4; // float
    constexpr std::ptrdiff_t m_nLastCompareResult = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLastFireResult = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flFireTime = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flFireInterval = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLastAngVelocity = 0x4C8; // float
    constexpr std::ptrdiff_t m_lastOrientation = 0x4CC; // QAngle
    constexpr std::ptrdiff_t m_vecAxis = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_bUseHelper = 0x4E4; // bool
    constexpr std::ptrdiff_t m_AngularVelocity = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnLessThan = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLessThanOrEqualTo = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThanOrEqualTo = 0x588; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEqualTo = 0x5B0; // CEntityIOOutput
}

namespace CPointBroadcastClientCommand { // CPointEntity
}

namespace CPointCamera { // CBaseEntity
    constexpr std::ptrdiff_t m_FOV = 0x4B0; // float
    constexpr std::ptrdiff_t m_Resolution = 0x4B4; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x4B8; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x4B9; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x4C8; // float
    constexpr std::ptrdiff_t m_bActive = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x4CD; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x4D0; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x4D4; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x4D8; // float
    constexpr std::ptrdiff_t m_flZFar = 0x4DC; // float
    constexpr std::ptrdiff_t m_flZNear = 0x4E0; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x4E4; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x4E5; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x4E8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x4EC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x4F0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x4F4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x4F8; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x4FC; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x500; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x504; // bool
    constexpr std::ptrdiff_t m_pNext = 0x508; // CPointCamera*
}

namespace CPointCameraVFOV { // CPointCamera
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x510; // float
}

namespace CPointClientCommand { // CPointEntity
}

namespace CPointClientUIDialog { // CBaseClientUIEntity
    constexpr std::ptrdiff_t m_hActivator = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0x8B4; // bool
}

namespace CPointClientUIWorldPanel { // CBaseClientUIEntity
    constexpr std::ptrdiff_t m_bIgnoreInput = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bLit = 0x8B1; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0x8B2; // bool
    constexpr std::ptrdiff_t m_flWidth = 0x8B4; // float
    constexpr std::ptrdiff_t m_flHeight = 0x8B8; // float
    constexpr std::ptrdiff_t m_flDPI = 0x8BC; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0x8C0; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x8C4; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0x8C8; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0x8CC; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0x8D8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x8E0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0x8F8; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0x8F9; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0x8FA; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0x8FB; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0x8FC; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0x8FD; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0x8FE; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0x8FF; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0x900; // int32_t
}

namespace CPointClientUIWorldTextPanel { // CPointClientUIWorldPanel
    constexpr std::ptrdiff_t m_messageText = 0x908; // char[512]
}

namespace CPointCommentaryNode { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_iszPreCommands = 0x890; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostCommands = 0x898; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0x8A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszViewTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewTargetAngles = 0x8B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszViewPosition = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewPosition = 0x8C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewPositionMover = 0x8C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventMovement = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bUnderCrosshair = 0x8C9; // bool
    constexpr std::ptrdiff_t m_bUnstoppable = 0x8CA; // bool
    constexpr std::ptrdiff_t m_flFinishedTime = 0x8CC; // GameTime_t
    constexpr std::ptrdiff_t m_vecFinishOrigin = 0x8D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalAngles = 0x8DC; // QAngle
    constexpr std::ptrdiff_t m_vecFinishAngles = 0x8E8; // QAngle
    constexpr std::ptrdiff_t m_bPreventChangesWhileMoving = 0x8F4; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x8F5; // bool
    constexpr std::ptrdiff_t m_vecTeleportOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_flAbortedPlaybackAt = 0x904; // GameTime_t
    constexpr std::ptrdiff_t m_pOnCommentaryStarted = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOnCommentaryStopped = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActive = 0x958; // bool
    constexpr std::ptrdiff_t m_flStartTime = 0x95C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0x960; // float
    constexpr std::ptrdiff_t m_iszTitle = 0x968; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0x970; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0x978; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0x97C; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0x980; // bool
}

namespace CPointEntity { // CBaseEntity
}

namespace CPointEntityFinder { // CBaseEntity
    constexpr std::ptrdiff_t m_hEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iFilterName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4C0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iRefName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hReference = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_FindMethod = 0x4D4; // EntFinderMethod_t
    constexpr std::ptrdiff_t m_OnFoundEntity = 0x4D8; // CEntityIOOutput
}

namespace CPointGamestatsCounter { // CPointEntity
    constexpr std::ptrdiff_t m_strStatisticName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x4B8; // bool
}

namespace CPointGiveAmmo { // CPointEntity
    constexpr std::ptrdiff_t m_pActivator = 0x4B0; // CHandle<CBaseEntity>
}

namespace CPointHurt { // CPointEntity
    constexpr std::ptrdiff_t m_nDamage = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bitsDamageType = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
    constexpr std::ptrdiff_t m_strTarget = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pActivator = 0x4C8; // CHandle<CBaseEntity>
}

namespace CPointPrefab { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_targetMapName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceWorldGroupID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_associatedRelayTargetName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fixupNames = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bLoadDynamic = 0x4C9; // bool
    constexpr std::ptrdiff_t m_associatedRelayEntity = 0x4CC; // CHandle<CPointPrefab>
}

namespace CPointProximitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Distance = 0x4B8; // CEntityOutputTemplate<float>
}

namespace CPointPulse { // CBaseEntity
    constexpr std::ptrdiff_t m_sNameFixupStaticPrefix = 0x5C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupParent = 0x5D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupLocal = 0x5D8; // CUtlSymbolLarge
}

namespace CPointPush { // CPointEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4BC; // float
    constexpr std::ptrdiff_t m_flConeOfInfluence = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszFilterName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4D0; // CHandle<CBaseFilter>
}

namespace CPointScript { // CBaseEntity
}

namespace CPointServerCommand { // CPointEntity
}

namespace CPointTeleport { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_vSaveOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vSaveAngles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_bTeleportParentedEntities = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bTeleportUseCurrentAngle = 0x4C9; // bool
}

namespace CPointTemplate { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszWorldName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x4CC; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x4F8; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x4FC; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x500; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x518; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x530; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x538; // HSCRIPT
}

namespace CPointValueRemapper { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x4B1; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x4B4; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_iszRemapLineStartName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszRemapLineEndName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x4D0; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x4D4; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x4D8; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x4DC; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x4E0; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_iszOutputEntityName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity2Name = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity3Name = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity4Name = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOutputEntities = 0x508; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x520; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x524; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x528; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x530; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x534; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x538; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x53C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x540; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x541; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x544; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x54C; // Vector
    constexpr std::ptrdiff_t m_hUsingPlayer = 0x558; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flCustomOutputValue = 0x55C; // float
    constexpr std::ptrdiff_t m_iszSoundEngage = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundDisengage = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueZero = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueOne = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovingLoop = 0x580; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Position = 0x590; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_PositionDelta = 0x5B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnReachedValueZero = 0x5E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueOne = 0x608; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueCustom = 0x630; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEngage = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDisengage = 0x680; // CEntityIOOutput
}

namespace CPointVelocitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecAxis = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_fPrevVelocity = 0x4C4; // float
    constexpr std::ptrdiff_t m_flAvgInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_Velocity = 0x4D0; // CEntityOutputTemplate<float>
}

namespace CPointWorldText { // CModelPointEntity
    constexpr std::ptrdiff_t m_messageText = 0x700; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0x900; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0x940; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0x941; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0x944; // float
    constexpr std::ptrdiff_t m_flFontSize = 0x948; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x94C; // float
    constexpr std::ptrdiff_t m_Color = 0x950; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0x954; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0x958; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0x95C; // PointWorldTextReorientMode_t
}

namespace CPostProcessingVolume { // CBaseTrigger
    constexpr std::ptrdiff_t m_hPostSettings = 0x8B8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0x8C0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0x8C4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0x8C8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0x8D0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0x8D4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0x8D8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0x8DC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x8E0; // float
    constexpr std::ptrdiff_t m_bMaster = 0x8E4; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0x8E5; // bool
    constexpr std::ptrdiff_t m_flRate = 0x8E8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x8EC; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x8F0; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x8F4; // float
}

namespace CPrecipitation { // CBaseTrigger
}

namespace CPrecipitationBlocker { // CBaseModelEntity
}

namespace CPrecipitationVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CPredictedViewModel { // CBaseViewModel
}

namespace CProjectedDecal { // CPointEntity
    constexpr std::ptrdiff_t m_nTexture = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x4B4; // float
}

namespace CPropDoorRotating { // CBasePropDoor
    constexpr std::ptrdiff_t m_vecAxis = 0xD98; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0xDA4; // float
    constexpr std::ptrdiff_t m_eSpawnPosition = 0xDA8; // PropDoorRotatingSpawnPos_t
    constexpr std::ptrdiff_t m_eOpenDirection = 0xDAC; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_eCurrentOpenDirection = 0xDB0; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_flAjarAngle = 0xDB4; // float
    constexpr std::ptrdiff_t m_angRotationAjarDeprecated = 0xDB8; // QAngle
    constexpr std::ptrdiff_t m_angRotationClosed = 0xDC4; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenForward = 0xDD0; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenBack = 0xDDC; // QAngle
    constexpr std::ptrdiff_t m_angGoal = 0xDE8; // QAngle
    constexpr std::ptrdiff_t m_vecForwardBoundsMin = 0xDF4; // Vector
    constexpr std::ptrdiff_t m_vecForwardBoundsMax = 0xE00; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMin = 0xE0C; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMax = 0xE18; // Vector
    constexpr std::ptrdiff_t m_bAjarDoorShouldntAlwaysOpen = 0xE24; // bool
    constexpr std::ptrdiff_t m_hEntityBlocker = 0xE28; // CHandle<CEntityBlocker>
}

namespace CPropDoorRotatingBreakable { // CPropDoorRotating
    constexpr std::ptrdiff_t m_bBreakable = 0xE30; // bool
    constexpr std::ptrdiff_t m_isAbleToCloseAreaPortals = 0xE31; // bool
    constexpr std::ptrdiff_t m_currentDamageState = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_damageStates = 0xE38; // CUtlVector<CUtlSymbolLarge>
}

namespace CPulseCell_Inflow_GameEvent { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_EventName = 0x70; // CBufferString
}

namespace CPulseCell_Outflow_PlayVCD { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_vcdFilename = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_OnFinished = 0x50; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_Triggers = 0x60; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_SoundEventStart { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Type = 0x48; // SoundEventStartType_t
}

namespace CPulseCell_Step_EntFire { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseCell_Step_SetAnimGraphParam { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_ParamName = 0x48; // CUtlString
}

namespace CPulseCell_Value_FindEntByName { // CPulseCell_BaseValue
    constexpr std::ptrdiff_t m_EntityType = 0x48; // CUtlString
}

namespace CPulseGraphInstance_ServerPointEntity { // CBasePulseGraphInstance
}

namespace CPulseServerFuncs {
}

namespace CPulseServerFuncs_Sounds {
}

namespace CPushable { // CBreakable
}

namespace CRR_Response {
    constexpr std::ptrdiff_t m_Type = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_szResponseName = 0x1; // char[192]
    constexpr std::ptrdiff_t m_szMatchingRule = 0xC1; // char[128]
    constexpr std::ptrdiff_t m_Params = 0x148; // ResponseParams
    constexpr std::ptrdiff_t m_fMatchScore = 0x168; // float
    constexpr std::ptrdiff_t m_szSpeakerContext = 0x170; // char*
    constexpr std::ptrdiff_t m_szWorldContext = 0x178; // char*
    constexpr std::ptrdiff_t m_Followup = 0x180; // ResponseFollowup
    constexpr std::ptrdiff_t m_pchCriteriaNames = 0x1B8; // CUtlVector<CUtlSymbol>
    constexpr std::ptrdiff_t m_pchCriteriaValues = 0x1D0; // CUtlVector<char*>
}

namespace CRagdollConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_xmin = 0x508; // float
    constexpr std::ptrdiff_t m_xmax = 0x50C; // float
    constexpr std::ptrdiff_t m_ymin = 0x510; // float
    constexpr std::ptrdiff_t m_ymax = 0x514; // float
    constexpr std::ptrdiff_t m_zmin = 0x518; // float
    constexpr std::ptrdiff_t m_zmax = 0x51C; // float
    constexpr std::ptrdiff_t m_xfriction = 0x520; // float
    constexpr std::ptrdiff_t m_yfriction = 0x524; // float
    constexpr std::ptrdiff_t m_zfriction = 0x528; // float
}

namespace CRagdollMagnet { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_force = 0x4B8; // float
    constexpr std::ptrdiff_t m_axis = 0x4BC; // Vector
}

namespace CRagdollManager { // CBaseEntity
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x4B0; // int8_t
    constexpr std::ptrdiff_t m_iMaxRagdollCount = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_bSaveImportant = 0x4B8; // bool
}

namespace CRagdollProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_ragdoll = 0x898; // ragdoll_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8D0; // bool
    constexpr std::ptrdiff_t m_ragPos = 0x8D8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0x8F0; // CNetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_hRagdollSource = 0x908; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastUpdateTickCount = 0x90C; // uint32_t
    constexpr std::ptrdiff_t m_allAsleep = 0x910; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0x911; // bool
    constexpr std::ptrdiff_t m_hDamageEntity = 0x914; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hKiller = 0x918; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x91C; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x920; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeOutStartTime = 0x924; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeTime = 0x928; // float
    constexpr std::ptrdiff_t m_vecLastOrigin = 0x92C; // Vector
    constexpr std::ptrdiff_t m_flAwakeTime = 0x938; // GameTime_t
    constexpr std::ptrdiff_t m_flLastOriginChangeTime = 0x93C; // GameTime_t
    constexpr std::ptrdiff_t m_nBloodColor = 0x940; // int32_t
    constexpr std::ptrdiff_t m_strOriginClassName = 0x948; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strSourceClassName = 0x950; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bHasBeenPhysgunned = 0x958; // bool
    constexpr std::ptrdiff_t m_bShouldTeleportPhysics = 0x959; // bool
    constexpr std::ptrdiff_t m_flBlendWeight = 0x95C; // float
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x960; // float
    constexpr std::ptrdiff_t m_ragdollMins = 0x968; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_ragdollMaxs = 0x980; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_bShouldDeleteActivationRecord = 0x998; // bool
    constexpr std::ptrdiff_t m_bValidatePoweredRagdollPose = 0x9F8; // bool
}

namespace CRagdollPropAlias_physics_prop_ragdoll { // CRagdollProp
}

namespace CRagdollPropAttached { // CRagdollProp
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xA38; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xA3C; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xA40; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xA4C; // Vector
    constexpr std::ptrdiff_t m_bShouldDetach = 0xA58; // bool
    constexpr std::ptrdiff_t m_bShouldDeleteAttachedActivationRecord = 0xA68; // bool
}

namespace CRandSimTimer { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_minInterval = 0x8; // float
    constexpr std::ptrdiff_t m_maxInterval = 0xC; // float
}

namespace CRandStopwatch { // CStopwatchBase
    constexpr std::ptrdiff_t m_minInterval = 0xC; // float
    constexpr std::ptrdiff_t m_maxInterval = 0x10; // float
}

namespace CRangeFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[2]
}

namespace CRangeInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[2]
}

namespace CRectLight { // CBarnLight
    constexpr std::ptrdiff_t m_bShowLight = 0x928; // bool
}

namespace CRemapFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CRenderComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CResponseCriteriaSet {
    constexpr std::ptrdiff_t m_nNumPrefixedContexts = 0x28; // int32_t
    constexpr std::ptrdiff_t m_bOverrideOnAppend = 0x2C; // bool
}

namespace CResponseQueue {
    constexpr std::ptrdiff_t m_ExpresserTargets = 0x50; // CUtlVector<CAI_Expresser*>
}

namespace CResponseQueue_CDeferredResponse {
    constexpr std::ptrdiff_t m_contexts = 0x10; // CResponseCriteriaSet
    constexpr std::ptrdiff_t m_fDispatchTime = 0x40; // float
    constexpr std::ptrdiff_t m_hIssuer = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_response = 0x50; // CRR_Response
    constexpr std::ptrdiff_t m_bResponseValid = 0x238; // bool
}

namespace CRetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace CRevertSaved { // CModelPointEntity
    constexpr std::ptrdiff_t m_loadTime = 0x700; // float
    constexpr std::ptrdiff_t m_Duration = 0x704; // float
    constexpr std::ptrdiff_t m_HoldTime = 0x708; // float
}

namespace CRopeKeyframe { // CBaseModelEntity
    constexpr std::ptrdiff_t m_RopeFlags = 0x708; // uint16_t
    constexpr std::ptrdiff_t m_iNextLinkName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Slack = 0x718; // int16_t
    constexpr std::ptrdiff_t m_Width = 0x71C; // float
    constexpr std::ptrdiff_t m_TextureScale = 0x720; // float
    constexpr std::ptrdiff_t m_nSegments = 0x724; // uint8_t
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x725; // bool
    constexpr std::ptrdiff_t m_strRopeMaterialModel = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0x730; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_Subdiv = 0x738; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x739; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x73A; // int16_t
    constexpr std::ptrdiff_t m_fLockedPoints = 0x73C; // uint8_t
    constexpr std::ptrdiff_t m_bCreatedFromMapFile = 0x73D; // bool
    constexpr std::ptrdiff_t m_flScrollSpeed = 0x740; // float
    constexpr std::ptrdiff_t m_bStartPointValid = 0x744; // bool
    constexpr std::ptrdiff_t m_bEndPointValid = 0x745; // bool
    constexpr std::ptrdiff_t m_hStartPoint = 0x748; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x74C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x750; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x751; // AttachmentHandle_t
}

namespace CRopeKeyframeAlias_move_rope { // CRopeKeyframe
}

namespace CRotButton { // CBaseButton
}

namespace CRotDoor { // CBaseDoor
    constexpr std::ptrdiff_t m_bSolidBsp = 0x988; // bool
}

namespace CRuleBrushEntity { // CRuleEntity
}

namespace CRuleEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iszMaster = 0x700; // CUtlSymbolLarge
}

namespace CRulePointEntity { // CRuleEntity
    constexpr std::ptrdiff_t m_Score = 0x708; // int32_t
}

namespace CSAdditionalMatchStats_t { // CSAdditionalPerRoundStats_t
    constexpr std::ptrdiff_t m_numRoundsSurvived = 0x14; // int32_t
    constexpr std::ptrdiff_t m_maxNumRoundsSurvived = 0x18; // int32_t
    constexpr std::ptrdiff_t m_numRoundsSurvivedTotal = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchase = 0x20; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchaseTotal = 0x24; // int32_t
    constexpr std::ptrdiff_t m_numFirstKills = 0x28; // int32_t
    constexpr std::ptrdiff_t m_numClutchKills = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_numPistolKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_numSniperKills = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iNumSuicides = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iNumTeamKills = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iTeamDamage = 0x40; // int32_t
}

namespace CSAdditionalPerRoundStats_t {
    constexpr std::ptrdiff_t m_numChickensKilled = 0x0; // int32_t
    constexpr std::ptrdiff_t m_killsWhileBlind = 0x4; // int32_t
    constexpr std::ptrdiff_t m_bombCarrierkills = 0x8; // int32_t
    constexpr std::ptrdiff_t m_iBurnDamageInflicted = 0xC; // int32_t
    constexpr std::ptrdiff_t m_iDinks = 0x10; // int32_t
}

namespace CSMatchStats_t { // CSPerRoundStats_t
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
    constexpr std::ptrdiff_t m_iEnemy2Ks = 0x74; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Count = 0x78; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Successes = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Enemies = 0x80; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Count = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Successes = 0x88; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsRemovedTotal = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsDealtTotal = 0x90; // int32_t
    constexpr std::ptrdiff_t m_nShotsFiredTotal = 0x94; // int32_t
    constexpr std::ptrdiff_t m_nShotsOnTargetTotal = 0x98; // int32_t
    constexpr std::ptrdiff_t m_i1v1Count = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_i1v1Wins = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_i1v2Count = 0xA4; // int32_t
    constexpr std::ptrdiff_t m_i1v2Wins = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_iEntryCount = 0xAC; // int32_t
    constexpr std::ptrdiff_t m_iEntryWins = 0xB0; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CSceneEntity { // CPointEntity
    constexpr std::ptrdiff_t m_iszSceneFile = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszResumeSceneFile = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget1 = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget2 = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget3 = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget4 = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget5 = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget6 = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget7 = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget8 = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTarget1 = 0x508; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget2 = 0x50C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget3 = 0x510; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget4 = 0x514; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget5 = 0x518; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget6 = 0x51C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget7 = 0x520; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget8 = 0x524; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x528; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x529; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x52A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x52B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentTime = 0x530; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x534; // float
    constexpr std::ptrdiff_t m_bCancelAtNextInterrupt = 0x538; // bool
    constexpr std::ptrdiff_t m_fPitch = 0x53C; // float
    constexpr std::ptrdiff_t m_bAutomated = 0x540; // bool
    constexpr std::ptrdiff_t m_nAutomatedAction = 0x544; // int32_t
    constexpr std::ptrdiff_t m_flAutomationDelay = 0x548; // float
    constexpr std::ptrdiff_t m_flAutomationTime = 0x54C; // float
    constexpr std::ptrdiff_t m_hWaitingForThisResumeScene = 0x550; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bWaitingForResumeScene = 0x554; // bool
    constexpr std::ptrdiff_t m_bPausedViaInput = 0x555; // bool
    constexpr std::ptrdiff_t m_bPauseAtNextInterrupt = 0x556; // bool
    constexpr std::ptrdiff_t m_bWaitingForActor = 0x557; // bool
    constexpr std::ptrdiff_t m_bWaitingForInterrupt = 0x558; // bool
    constexpr std::ptrdiff_t m_bInterruptedActorsScenes = 0x559; // bool
    constexpr std::ptrdiff_t m_bBreakOnNonIdle = 0x55A; // bool
    constexpr std::ptrdiff_t m_hActorList = 0x560; // CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    constexpr std::ptrdiff_t m_hRemoveActorList = 0x578; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nSceneFlushCounter = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x5A4; // uint16_t
    constexpr std::ptrdiff_t m_OnStart = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCompletion = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCanceled = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPaused = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnResumed = 0x648; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTrigger = 0x670; // CEntityIOOutput[16]
    constexpr std::ptrdiff_t m_hInterruptScene = 0x980; // CHandle<CSceneEntity>
    constexpr std::ptrdiff_t m_nInterruptCount = 0x984; // int32_t
    constexpr std::ptrdiff_t m_bSceneMissing = 0x988; // bool
    constexpr std::ptrdiff_t m_bInterrupted = 0x989; // bool
    constexpr std::ptrdiff_t m_bCompletedEarly = 0x98A; // bool
    constexpr std::ptrdiff_t m_bInterruptSceneFinished = 0x98B; // bool
    constexpr std::ptrdiff_t m_bRestoring = 0x98C; // bool
    constexpr std::ptrdiff_t m_hNotifySceneCompletion = 0x990; // CUtlVector<CHandle<CSceneEntity>>
    constexpr std::ptrdiff_t m_hListManagers = 0x9A8; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszSoundName = 0x9E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hActor = 0x9F0; // CHandle<CBaseFlex>
    constexpr std::ptrdiff_t m_hActivator = 0x9F4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_BusyActor = 0x9F8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x9FC; // SceneOnPlayerDeath_t
}

namespace CSceneEntityAlias_logic_choreographed_scene { // CSceneEntity
}

namespace CSceneEventInfo {
    constexpr std::ptrdiff_t m_iLayer = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iPriority = 0x4; // int32_t
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flWeight = 0xC; // float
    constexpr std::ptrdiff_t m_bIsMoving = 0x10; // bool
    constexpr std::ptrdiff_t m_bHasArrived = 0x11; // bool
    constexpr std::ptrdiff_t m_flInitialYaw = 0x14; // float
    constexpr std::ptrdiff_t m_flTargetYaw = 0x18; // float
    constexpr std::ptrdiff_t m_flFacingYaw = 0x1C; // float
    constexpr std::ptrdiff_t m_nType = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flNext = 0x24; // GameTime_t
    constexpr std::ptrdiff_t m_bIsGesture = 0x28; // bool
    constexpr std::ptrdiff_t m_bShouldRemove = 0x29; // bool
    constexpr std::ptrdiff_t m_hTarget = 0x54; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSceneEventId = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_bClientSide = 0x5C; // bool
    constexpr std::ptrdiff_t m_bStarted = 0x5D; // bool
}

namespace CSceneListManager { // CLogicalEntity
    constexpr std::ptrdiff_t m_hListManagers = 0x4B0; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszScenes = 0x4C8; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_hScenes = 0x548; // CHandle<CBaseEntity>[16]
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CScriptItem { // CItem
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_MoveTypeOverride = 0x990; // MoveType_t
}

namespace CScriptNavBlocker { // CFuncNavBlocker
    constexpr std::ptrdiff_t m_vExtent = 0x710; // Vector
}

namespace CScriptTriggerHurt { // CTriggerHurt
    constexpr std::ptrdiff_t m_vExtent = 0x948; // Vector
}

namespace CScriptTriggerMultiple { // CTriggerMultiple
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerOnce { // CTriggerOnce
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerPush { // CTriggerPush
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptUniformRandomStream {
    constexpr std::ptrdiff_t m_hScriptScope = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nInitialSeed = 0x9C; // int32_t
}

namespace CScriptedSequence { // CBaseEntity
    constexpr std::ptrdiff_t m_iszEntry = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPreIdle = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPlay = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostIdle = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszModifierToAddOnPlay = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszNextScript = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntity = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSyncGroup = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nMoveTo = 0x4F0; // ScriptedMoveTo_t
    constexpr std::ptrdiff_t m_bIsPlayingPreIdle = 0x4F4; // bool
    constexpr std::ptrdiff_t m_bIsPlayingEntry = 0x4F5; // bool
    constexpr std::ptrdiff_t m_bIsPlayingAction = 0x4F6; // bool
    constexpr std::ptrdiff_t m_bIsPlayingPostIdle = 0x4F7; // bool
    constexpr std::ptrdiff_t m_bLoopPreIdleSequence = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bLoopActionSequence = 0x4F9; // bool
    constexpr std::ptrdiff_t m_bLoopPostIdleSequence = 0x4FA; // bool
    constexpr std::ptrdiff_t m_bSynchPostIdles = 0x4FB; // bool
    constexpr std::ptrdiff_t m_bIgnoreGravity = 0x4FC; // bool
    constexpr std::ptrdiff_t m_bDisableNPCCollisions = 0x4FD; // bool
    constexpr std::ptrdiff_t m_bKeepAnimgraphLockedPost = 0x4FE; // bool
    constexpr std::ptrdiff_t m_bDontAddModifiers = 0x4FF; // bool
    constexpr std::ptrdiff_t m_flRadius = 0x500; // float
    constexpr std::ptrdiff_t m_flRepeat = 0x504; // float
    constexpr std::ptrdiff_t m_flPlayAnimFadeInTime = 0x508; // float
    constexpr std::ptrdiff_t m_flMoveInterpTime = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngRate = 0x510; // float
    constexpr std::ptrdiff_t m_iDelay = 0x514; // int32_t
    constexpr std::ptrdiff_t m_startTime = 0x518; // GameTime_t
    constexpr std::ptrdiff_t m_bWaitForBeginSequence = 0x51C; // bool
    constexpr std::ptrdiff_t m_saved_effects = 0x520; // int32_t
    constexpr std::ptrdiff_t m_savedFlags = 0x524; // int32_t
    constexpr std::ptrdiff_t m_savedCollisionGroup = 0x528; // int32_t
    constexpr std::ptrdiff_t m_interruptable = 0x52C; // bool
    constexpr std::ptrdiff_t m_sequenceStarted = 0x52D; // bool
    constexpr std::ptrdiff_t m_bPrevAnimatedEveryTick = 0x52E; // bool
    constexpr std::ptrdiff_t m_bForcedAnimatedEveryTick = 0x52F; // bool
    constexpr std::ptrdiff_t m_bPositionRelativeToOtherEntity = 0x530; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x534; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hNextCine = 0x538; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_bThinking = 0x53C; // bool
    constexpr std::ptrdiff_t m_bInitiatedSelfDelete = 0x53D; // bool
    constexpr std::ptrdiff_t m_bIsTeleportingDueToMoveTo = 0x53E; // bool
    constexpr std::ptrdiff_t m_bAllowCustomInterruptConditions = 0x53F; // bool
    constexpr std::ptrdiff_t m_hLastFoundEntity = 0x540; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hForcedTarget = 0x544; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_bDontCancelOtherSequences = 0x548; // bool
    constexpr std::ptrdiff_t m_bForceSynch = 0x549; // bool
    constexpr std::ptrdiff_t m_bTargetWasAsleep = 0x54A; // bool
    constexpr std::ptrdiff_t m_bPreventUpdateYawOnFinish = 0x54B; // bool
    constexpr std::ptrdiff_t m_bEnsureOnNavmeshOnFinish = 0x54C; // bool
    constexpr std::ptrdiff_t m_onDeathBehavior = 0x550; // ScriptedOnDeath_t
    constexpr std::ptrdiff_t m_ConflictResponse = 0x554; // ScriptedConflictResponse_t
    constexpr std::ptrdiff_t m_OnBeginSequence = 0x558; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnActionStartOrLoop = 0x580; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndSequence = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPostIdleEndSequence = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelSequence = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelFailedSequence = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnScriptEvent = 0x648; // CEntityIOOutput[8]
    constexpr std::ptrdiff_t m_matOtherToMain = 0x790; // CTransform
    constexpr std::ptrdiff_t m_hInteractionMainEntity = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x7B4; // int32_t
}

namespace CSensorGrenade { // CBaseCSGrenade
}

namespace CSensorGrenadeProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_fExpireTime = 0xA30; // GameTime_t
    constexpr std::ptrdiff_t m_fNextDetectPlayerSound = 0xA34; // GameTime_t
    constexpr std::ptrdiff_t m_hDisplayGrenade = 0xA38; // CHandle<CBaseEntity>
}

namespace CServerOnlyEntity { // CBaseEntity
}

namespace CServerOnlyModelEntity { // CBaseModelEntity
}

namespace CServerOnlyPointEntity { // CServerOnlyEntity
}

namespace CServerRagdollTrigger { // CBaseTrigger
}

namespace CShatterGlassShard {
    constexpr std::ptrdiff_t m_hShardHandle = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x10; // CUtlVector<Vector2D>
    constexpr std::ptrdiff_t m_vLocalPanelSpaceOrigin = 0x28; // Vector2D
    constexpr std::ptrdiff_t m_hModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_hPhysicsEntity = 0x38; // CHandle<CShatterGlassShardPhysics>
    constexpr std::ptrdiff_t m_hParentPanel = 0x3C; // CHandle<CFuncShatterglass>
    constexpr std::ptrdiff_t m_hParentShard = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_ShatterStressType = 0x44; // ShatterGlassStressType
    constexpr std::ptrdiff_t m_vecStressVelocity = 0x48; // Vector
    constexpr std::ptrdiff_t m_bCreatedModel = 0x54; // bool
    constexpr std::ptrdiff_t m_flLongestEdge = 0x58; // float
    constexpr std::ptrdiff_t m_flShortestEdge = 0x5C; // float
    constexpr std::ptrdiff_t m_flLongestAcross = 0x60; // float
    constexpr std::ptrdiff_t m_flShortestAcross = 0x64; // float
    constexpr std::ptrdiff_t m_flSumOfAllEdges = 0x68; // float
    constexpr std::ptrdiff_t m_flArea = 0x6C; // float
    constexpr std::ptrdiff_t m_nOnFrameEdge = 0x70; // OnFrame
    constexpr std::ptrdiff_t m_nParentPanelsNthShard = 0x74; // int32_t
    constexpr std::ptrdiff_t m_nSubShardGeneration = 0x78; // int32_t
    constexpr std::ptrdiff_t m_vecAverageVertPosition = 0x7C; // Vector2D
    constexpr std::ptrdiff_t m_bAverageVertPositionIsValid = 0x84; // bool
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionA = 0x88; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionB = 0x90; // Vector2D
    constexpr std::ptrdiff_t m_bStressPositionAIsValid = 0x98; // bool
    constexpr std::ptrdiff_t m_bStressPositionBIsValid = 0x99; // bool
    constexpr std::ptrdiff_t m_bFlaggedForRemoval = 0x9A; // bool
    constexpr std::ptrdiff_t m_flPhysicsEntitySpawnedAtTime = 0x9C; // GameTime_t
    constexpr std::ptrdiff_t m_bShatterRateLimited = 0xA0; // bool
    constexpr std::ptrdiff_t m_hEntityHittingMe = 0xA4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecNeighbors = 0xA8; // CUtlVector<uint32_t>
}

namespace CShatterGlassShardPhysics { // CPhysicsProp
    constexpr std::ptrdiff_t m_bDebris = 0xB78; // bool
    constexpr std::ptrdiff_t m_hParentShard = 0xB7C; // uint32_t
    constexpr std::ptrdiff_t m_ShardDesc = 0xB80; // shard_model_desc_t
}

namespace CShower { // CModelPointEntity
}

namespace CSimTimer { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_interval = 0x8; // float
}

namespace CSimpleMarkupVolumeTagged { // CMarkupVolumeTagged
}

namespace CSimpleSimTimer {
    constexpr std::ptrdiff_t m_next = 0x0; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x4; // WorldGroupId_t
}

namespace CSimpleStopwatch { // CStopwatchBase
}

namespace CSingleplayRules { // CGameRules
    constexpr std::ptrdiff_t m_bSinglePlayerGameEnding = 0x90; // bool
}

namespace CSkeletonAnimationController { // ISkeletonAnimationController
    constexpr std::ptrdiff_t m_pSkeletonInstance = 0x8; // CSkeletonInstance*
}

namespace CSkeletonInstance { // CGameSceneNode
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkillDamage {
    constexpr std::ptrdiff_t m_flDamage = 0x0; // CSkillFloat
    constexpr std::ptrdiff_t m_flPhysicsForceDamage = 0x10; // float
}

namespace CSkillFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CSkillInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[4]
}

namespace CSkyCamera { // CBaseEntity
    constexpr std::ptrdiff_t m_skyboxData = 0x4B0; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x540; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x544; // bool
    constexpr std::ptrdiff_t m_pNext = 0x548; // CSkyCamera*
}

namespace CSkyboxReference { // CBaseEntity
    constexpr std::ptrdiff_t m_worldGroupId = 0x4B0; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x4B4; // CHandle<CSkyCamera>
}

namespace CSmokeGrenade { // CBaseCSGrenade
}

namespace CSmokeGrenadeProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0xA48; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0xA4C; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0xA50; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0xA54; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0xA60; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0xA70; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_flLastBounce = 0xA88; // GameTime_t
    constexpr std::ptrdiff_t m_fllastSimulationTime = 0xA8C; // GameTime_t
}

namespace CSmoothFunc {
    constexpr std::ptrdiff_t m_flSmoothAmplitude = 0x8; // float
    constexpr std::ptrdiff_t m_flSmoothBias = 0xC; // float
    constexpr std::ptrdiff_t m_flSmoothDuration = 0x10; // float
    constexpr std::ptrdiff_t m_flSmoothRemainingTime = 0x14; // float
    constexpr std::ptrdiff_t m_nSmoothDir = 0x18; // int32_t
}

namespace CSound {
    constexpr std::ptrdiff_t m_hOwner = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iVolume = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flOcclusionScale = 0xC; // float
    constexpr std::ptrdiff_t m_iType = 0x10; // int32_t
    constexpr std::ptrdiff_t m_iNextAudible = 0x14; // int32_t
    constexpr std::ptrdiff_t m_flExpireTime = 0x18; // GameTime_t
    constexpr std::ptrdiff_t m_iNext = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_bNoExpirationTime = 0x1E; // bool
    constexpr std::ptrdiff_t m_ownerChannelIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_vecOrigin = 0x24; // Vector
    constexpr std::ptrdiff_t m_bHasOwner = 0x30; // bool
}

namespace CSoundAreaEntityBase { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x4C0; // Vector
}

namespace CSoundAreaEntityOrientedBox { // CSoundAreaEntityBase
    constexpr std::ptrdiff_t m_vMin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x4DC; // Vector
}

namespace CSoundAreaEntitySphere { // CSoundAreaEntityBase
    constexpr std::ptrdiff_t m_flRadius = 0x4D0; // float
}

namespace CSoundEnt { // CPointEntity
    constexpr std::ptrdiff_t m_iFreeSound = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iActiveSound = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_cLastActiveSounds = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_SoundPool = 0x4BC; // CSound[128]
}

namespace CSoundEnvelope {
    constexpr std::ptrdiff_t m_current = 0x0; // float
    constexpr std::ptrdiff_t m_target = 0x4; // float
    constexpr std::ptrdiff_t m_rate = 0x8; // float
    constexpr std::ptrdiff_t m_forceupdate = 0xC; // bool
}

namespace CSoundEventAABBEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_bStartOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bToLocalPlayer = 0x4B1; // bool
    constexpr std::ptrdiff_t m_bStopOnNew = 0x4B2; // bool
    constexpr std::ptrdiff_t m_bSaveRestore = 0x4B3; // bool
    constexpr std::ptrdiff_t m_bSavedIsPlaying = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSavedElapsedTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszAttachmentName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_onGUIDChanged = 0x4D0; // CEntityOutputTemplate<uint64_t>
    constexpr std::ptrdiff_t m_onSoundFinished = 0x4F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSoundName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSource = 0x550; // CEntityHandle
}

namespace CSoundEventEntityAlias_snd_event_point { // CSoundEventEntity
}

namespace CSoundEventOBBEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventParameter { // CBaseEntity
    constexpr std::ptrdiff_t m_iszParamName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flFloatValue = 0x4C0; // float
}

namespace CSoundEventPathCornerEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_iszPathCorner = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iCountMax = 0x560; // int32_t
    constexpr std::ptrdiff_t m_flDistanceMax = 0x564; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x568; // float
    constexpr std::ptrdiff_t m_flDotProductMax = 0x56C; // float
    constexpr std::ptrdiff_t bPlaying = 0x570; // bool
}

namespace CSoundOpvarSetAABBEntity { // CSoundOpvarSetPointEntity
    constexpr std::ptrdiff_t m_vDistanceInnerMins = 0x648; // Vector
    constexpr std::ptrdiff_t m_vDistanceInnerMaxs = 0x654; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x660; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x66C; // Vector
    constexpr std::ptrdiff_t m_nAABBDirection = 0x678; // int32_t
    constexpr std::ptrdiff_t m_vInnerMins = 0x67C; // Vector
    constexpr std::ptrdiff_t m_vInnerMaxs = 0x688; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x694; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x6A0; // Vector
}

namespace CSoundOpvarSetEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nOpvarType = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nOpvarIndex = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flOpvarValue = 0x4D8; // float
    constexpr std::ptrdiff_t m_OpvarValueString = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bSetOnSpawn = 0x4E8; // bool
}

namespace CSoundOpvarSetOBBEntity { // CSoundOpvarSetAABBEntity
}

namespace CSoundOpvarSetOBBWindEntity { // CSoundOpvarSetPointBase
    constexpr std::ptrdiff_t m_vMins = 0x548; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x554; // Vector
    constexpr std::ptrdiff_t m_vDistanceMins = 0x560; // Vector
    constexpr std::ptrdiff_t m_vDistanceMaxs = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flWindMin = 0x578; // float
    constexpr std::ptrdiff_t m_flWindMax = 0x57C; // float
    constexpr std::ptrdiff_t m_flWindMapMin = 0x580; // float
    constexpr std::ptrdiff_t m_flWindMapMax = 0x584; // float
}

namespace CSoundOpvarSetPathCornerEntity { // CSoundOpvarSetPointEntity
    constexpr std::ptrdiff_t m_flDistMinSqr = 0x660; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x664; // float
    constexpr std::ptrdiff_t m_iszPathCornerEntityName = 0x668; // CUtlSymbolLarge
}

namespace CSoundOpvarSetPointBase { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hSource = 0x4B4; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vLastPosition = 0x518; // Vector
    constexpr std::ptrdiff_t m_iszStackName = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x538; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x540; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x544; // bool
}

namespace CSoundOpvarSetPointEntity { // CSoundOpvarSetPointBase
    constexpr std::ptrdiff_t m_OnEnter = 0x548; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExit = 0x570; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAutoDisable = 0x598; // bool
    constexpr std::ptrdiff_t m_flDistanceMin = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDistanceMax = 0x5E0; // float
    constexpr std::ptrdiff_t m_flDistanceMapMin = 0x5E4; // float
    constexpr std::ptrdiff_t m_flDistanceMapMax = 0x5E8; // float
    constexpr std::ptrdiff_t m_flOcclusionRadius = 0x5EC; // float
    constexpr std::ptrdiff_t m_flOcclusionMin = 0x5F0; // float
    constexpr std::ptrdiff_t m_flOcclusionMax = 0x5F4; // float
    constexpr std::ptrdiff_t m_flValSetOnDisable = 0x5F8; // float
    constexpr std::ptrdiff_t m_bSetValueOnDisable = 0x5FC; // bool
    constexpr std::ptrdiff_t m_nSimulationMode = 0x600; // int32_t
    constexpr std::ptrdiff_t m_nVisibilitySamples = 0x604; // int32_t
    constexpr std::ptrdiff_t m_vDynamicProxyPoint = 0x608; // Vector
    constexpr std::ptrdiff_t m_flDynamicMaximumOcclusion = 0x614; // float
    constexpr std::ptrdiff_t m_hDynamicEntity = 0x618; // CEntityHandle
    constexpr std::ptrdiff_t m_iszDynamicEntityName = 0x620; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPathingDistanceNormFactor = 0x628; // float
    constexpr std::ptrdiff_t m_vPathingSourcePos = 0x62C; // Vector
    constexpr std::ptrdiff_t m_vPathingListenerPos = 0x638; // Vector
    constexpr std::ptrdiff_t m_nPathingSourceIndex = 0x644; // int32_t
}

namespace CSoundPatch {
    constexpr std::ptrdiff_t m_pitch = 0x8; // CSoundEnvelope
    constexpr std::ptrdiff_t m_volume = 0x18; // CSoundEnvelope
    constexpr std::ptrdiff_t m_shutdownTime = 0x30; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x34; // float
    constexpr std::ptrdiff_t m_iszSoundScriptName = 0x38; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEnt = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundEntityIndex = 0x44; // CEntityIndex
    constexpr std::ptrdiff_t m_soundOrigin = 0x48; // Vector
    constexpr std::ptrdiff_t m_isPlaying = 0x54; // int32_t
    constexpr std::ptrdiff_t m_Filter = 0x58; // CCopyRecipientFilter
    constexpr std::ptrdiff_t m_flCloseCaptionDuration = 0x80; // float
    constexpr std::ptrdiff_t m_bUpdatedSoundOrigin = 0x84; // bool
    constexpr std::ptrdiff_t m_iszClassName = 0x88; // CUtlSymbolLarge
}

namespace CSoundStackSave { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x4B0; // CUtlSymbolLarge
}

namespace CSplineConstraint { // CPhysConstraint
}

namespace CSpotlightEnd { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flLightScale = 0x700; // float
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_vSpotlightDir = 0x708; // Vector
    constexpr std::ptrdiff_t m_vSpotlightOrg = 0x714; // Vector
}

namespace CSprite { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0x708; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0x70C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0x710; // float
    constexpr std::ptrdiff_t m_flFrame = 0x714; // float
    constexpr std::ptrdiff_t m_flDieTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0x728; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0x72C; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0x730; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0x734; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0x738; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x73C; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x740; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x744; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0x748; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x74C; // float
    constexpr std::ptrdiff_t m_flDestScale = 0x750; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x754; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0x758; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0x75C; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0x760; // GameTime_t
    constexpr std::ptrdiff_t m_nSpriteWidth = 0x764; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0x768; // int32_t
}

namespace CSpriteAlias_env_glow { // CSprite
}

namespace CSpriteOriented { // CSprite
}

namespace CStopwatch { // CStopwatchBase
    constexpr std::ptrdiff_t m_interval = 0xC; // float
}

namespace CStopwatchBase { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_fIsRunning = 0x8; // bool
}

namespace CSun { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vDirection = 0x700; // Vector
    constexpr std::ptrdiff_t m_clrOverlay = 0x70C; // Color
    constexpr std::ptrdiff_t m_iszEffectName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOn = 0x720; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0x721; // bool
    constexpr std::ptrdiff_t m_flSize = 0x724; // float
    constexpr std::ptrdiff_t m_flRotation = 0x728; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0x72C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0x730; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0x734; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x738; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x73C; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0x740; // float
}

namespace CTablet { // CCSWeaponBase
}

namespace CTakeDamageInfo {
    constexpr std::ptrdiff_t m_vecDamageForce = 0x8; // Vector
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x14; // Vector
    constexpr std::ptrdiff_t m_vecReportedPosition = 0x20; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_hInflictor = 0x38; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAttacker = 0x3C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAbility = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDamage = 0x44; // float
    constexpr std::ptrdiff_t m_bitsDamageType = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iDamageCustom = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iAmmoType = 0x50; // AmmoIndex_t
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x60; // float
    constexpr std::ptrdiff_t m_bShouldBleed = 0x64; // bool
    constexpr std::ptrdiff_t m_bShouldSpark = 0x65; // bool
    constexpr std::ptrdiff_t m_nDamageFlags = 0x70; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_nNumObjectsPenetrated = 0x74; // int32_t
    constexpr std::ptrdiff_t m_hScriptInstance = 0x78; // HSCRIPT
    constexpr std::ptrdiff_t m_bInTakeDamageFlow = 0x94; // bool
}

namespace CTakeDamageResult {
    constexpr std::ptrdiff_t m_nHealthLost = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nDamageTaken = 0x4; // int32_t
}

namespace CTakeDamageSummaryScopeGuard {
    constexpr std::ptrdiff_t m_vecSummaries = 0x8; // CUtlVector<SummaryTakeDamageInfo_t*>
}

namespace CTankTargetChange { // CPointEntity
    constexpr std::ptrdiff_t m_newTarget = 0x4B0; // CVariantBase<CVariantDefaultAllocator>
    constexpr std::ptrdiff_t m_newTargetName = 0x4C0; // CUtlSymbolLarge
}

namespace CTankTrainAI { // CPointEntity
    constexpr std::ptrdiff_t m_hTrain = 0x4B0; // CHandle<CFuncTrackTrain>
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundPlaying = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_startSoundName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_engineSoundName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_movementSoundName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_targetEntityName = 0x4E8; // CUtlSymbolLarge
}

namespace CTeam { // CBaseEntity
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x4B0; // CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x4C8; // CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x4E4; // char[129]
}

namespace CTeamplayRules { // CMultiplayRules
}

namespace CTestEffect { // CBaseEntity
    constexpr std::ptrdiff_t m_iLoop = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iBeam = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_pBeam = 0x4B8; // CBeam*[24]
    constexpr std::ptrdiff_t m_flBeamTime = 0x578; // GameTime_t[24]
    constexpr std::ptrdiff_t m_flStartTime = 0x5D8; // GameTime_t
}

namespace CTextureBasedAnimatable { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bLoop = 0x700; // bool
    constexpr std::ptrdiff_t m_flFPS = 0x704; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0x708; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0x710; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0x718; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0x724; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x730; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0x734; // float
}

namespace CTimeline { // IntervalTimer
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace CTimerEntity { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTimer = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerHigh = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerLow = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iDisabled = 0x528; // int32_t
    constexpr std::ptrdiff_t m_flInitialDelay = 0x52C; // float
    constexpr std::ptrdiff_t m_flRefireTime = 0x530; // float
    constexpr std::ptrdiff_t m_bUpDownState = 0x534; // bool
    constexpr std::ptrdiff_t m_iUseRandomTime = 0x538; // int32_t
    constexpr std::ptrdiff_t m_bPauseAfterFiring = 0x53C; // bool
    constexpr std::ptrdiff_t m_flLowerRandomBound = 0x540; // float
    constexpr std::ptrdiff_t m_flUpperRandomBound = 0x544; // float
    constexpr std::ptrdiff_t m_flRemainingTime = 0x548; // float
    constexpr std::ptrdiff_t m_bPaused = 0x54C; // bool
}

namespace CTonemapController2 { // CBaseEntity
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x4B8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x4C0; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x4C4; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x4C8; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x4CC; // float
}

namespace CTonemapController2Alias_env_tonemap_controller2 { // CTonemapController2
}

namespace CTonemapTrigger { // CBaseTrigger
    constexpr std::ptrdiff_t m_tonemapControllerName = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTonemapController = 0x8B0; // CEntityHandle
}

namespace CTouchExpansionComponent { // CEntityComponent
}

namespace CTriggerActiveWeaponDetect { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnTouchedActiveWeapon = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszWeaponClassName = 0x8D0; // CUtlSymbolLarge
}

namespace CTriggerBombReset { // CBaseTrigger
}

namespace CTriggerBrush { // CBaseModelEntity
    constexpr std::ptrdiff_t m_OnStartTouch = 0x700; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x728; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUse = 0x750; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInputFilter = 0x778; // int32_t
    constexpr std::ptrdiff_t m_iDontMessageParent = 0x77C; // int32_t
}

namespace CTriggerBuoyancy { // CBaseTrigger
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x8A8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0x8C8; // float
}

namespace CTriggerCallback { // CBaseTrigger
}

namespace CTriggerDetectBulletFire { // CBaseTrigger
    constexpr std::ptrdiff_t m_bPlayerFireOnly = 0x8A8; // bool
    constexpr std::ptrdiff_t m_OnDetectedBulletFire = 0x8B0; // CEntityIOOutput
}

namespace CTriggerDetectExplosion { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnDetectedExplosion = 0x8E0; // CEntityIOOutput
}

namespace CTriggerFan { // CBaseTrigger
    constexpr std::ptrdiff_t m_vFanOrigin = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_vFanEnd = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_vNoise = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flPlayerForce = 0x8D0; // float
    constexpr std::ptrdiff_t m_flRampTime = 0x8D4; // float
    constexpr std::ptrdiff_t m_bFalloff = 0x8D8; // bool
    constexpr std::ptrdiff_t m_bPushPlayer = 0x8D9; // bool
    constexpr std::ptrdiff_t m_bRampDown = 0x8DA; // bool
    constexpr std::ptrdiff_t m_bAddNoise = 0x8DB; // bool
    constexpr std::ptrdiff_t m_RampTimer = 0x8E0; // CountdownTimer
}

namespace CTriggerGameEvent { // CBaseTrigger
    constexpr std::ptrdiff_t m_strStartTouchEventName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_strEndTouchEventName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_strTriggerID = 0x8B8; // CUtlString
}

namespace CTriggerGravity { // CBaseTrigger
}

namespace CTriggerHurt { // CBaseTrigger
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x8A8; // float
    constexpr std::ptrdiff_t m_flDamage = 0x8AC; // float
    constexpr std::ptrdiff_t m_flDamageCap = 0x8B0; // float
    constexpr std::ptrdiff_t m_flLastDmgTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_flForgivenessDelay = 0x8B8; // float
    constexpr std::ptrdiff_t m_bitsDamageInflict = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_damageModel = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_bNoDmgForce = 0x8C4; // bool
    constexpr std::ptrdiff_t m_vDamageForce = 0x8C8; // Vector
    constexpr std::ptrdiff_t m_thinkAlways = 0x8D4; // bool
    constexpr std::ptrdiff_t m_hurtThinkPeriod = 0x8D8; // float
    constexpr std::ptrdiff_t m_OnHurt = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHurtPlayer = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hurtEntities = 0x930; // CUtlVector<CHandle<CBaseEntity>>
}

namespace CTriggerHurtGhost { // CTriggerHurt
}

namespace CTriggerImpact { // CTriggerMultiple
    constexpr std::ptrdiff_t m_flMagnitude = 0x8D0; // float
    constexpr std::ptrdiff_t m_flNoise = 0x8D4; // float
    constexpr std::ptrdiff_t m_flViewkick = 0x8D8; // float
    constexpr std::ptrdiff_t m_pOutputForce = 0x8E0; // CEntityOutputTemplate<Vector>
}

namespace CTriggerLerpObject { // CBaseTrigger
    constexpr std::ptrdiff_t m_iszLerpTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszLerpTargetAttachment = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTargetAttachment = 0x8C0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flLerpDuration = 0x8C4; // float
    constexpr std::ptrdiff_t m_bLerpRestoreMoveType = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bSingleLerpObject = 0x8C9; // bool
    constexpr std::ptrdiff_t m_vecLerpingObjects = 0x8D0; // CUtlVector<lerpdata_t>
    constexpr std::ptrdiff_t m_iszLerpEffect = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLerpSound = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnLerpStarted = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLerpFinished = 0x920; // CEntityIOOutput
}

namespace CTriggerLook { // CTriggerOnce
    constexpr std::ptrdiff_t m_hLookTarget = 0x8D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x8D4; // float
    constexpr std::ptrdiff_t m_flLookTime = 0x8D8; // float
    constexpr std::ptrdiff_t m_flLookTimeTotal = 0x8DC; // float
    constexpr std::ptrdiff_t m_flLookTimeLast = 0x8E0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeoutDuration = 0x8E4; // float
    constexpr std::ptrdiff_t m_bTimeoutFired = 0x8E8; // bool
    constexpr std::ptrdiff_t m_bIsLooking = 0x8E9; // bool
    constexpr std::ptrdiff_t m_b2DFOV = 0x8EA; // bool
    constexpr std::ptrdiff_t m_bUseVelocity = 0x8EB; // bool
    constexpr std::ptrdiff_t m_hActivator = 0x8EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bTestOcclusion = 0x8F0; // bool
    constexpr std::ptrdiff_t m_OnTimeout = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartLook = 0x920; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndLook = 0x948; // CEntityIOOutput
}

namespace CTriggerMultiple { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnTrigger = 0x8A8; // CEntityIOOutput
}

namespace CTriggerOnce { // CTriggerMultiple
}

namespace CTriggerPhysics { // CBaseTrigger
    constexpr std::ptrdiff_t m_gravityScale = 0x8B8; // float
    constexpr std::ptrdiff_t m_linearLimit = 0x8BC; // float
    constexpr std::ptrdiff_t m_linearDamping = 0x8C0; // float
    constexpr std::ptrdiff_t m_angularLimit = 0x8C4; // float
    constexpr std::ptrdiff_t m_angularDamping = 0x8C8; // float
    constexpr std::ptrdiff_t m_linearForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFrequency = 0x8D0; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x8D4; // float
    constexpr std::ptrdiff_t m_vecLinearForcePointAt = 0x8D8; // Vector
    constexpr std::ptrdiff_t m_bCollapseToForcePoint = 0x8E4; // bool
    constexpr std::ptrdiff_t m_vecLinearForcePointAtWorld = 0x8E8; // Vector
    constexpr std::ptrdiff_t m_vecLinearForceDirection = 0x8F4; // Vector
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x900; // bool
}

namespace CTriggerProximity { // CBaseTrigger
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x8A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszMeasureTarget = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fRadius = 0x8B8; // float
    constexpr std::ptrdiff_t m_nTouchers = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_NearestEntityDistance = 0x8C0; // CEntityOutputTemplate<float>
}

namespace CTriggerPush { // CBaseTrigger
    constexpr std::ptrdiff_t m_angPushEntitySpace = 0x8A8; // QAngle
    constexpr std::ptrdiff_t m_vecPushDirEntitySpace = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_bTriggerOnStartTouch = 0x8C0; // bool
    constexpr std::ptrdiff_t m_flAlternateTicksFix = 0x8C4; // float
    constexpr std::ptrdiff_t m_flPushSpeed = 0x8C8; // float
}

namespace CTriggerRemove { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnRemove = 0x8A8; // CEntityIOOutput
}

namespace CTriggerSave { // CBaseTrigger
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x8A8; // bool
    constexpr std::ptrdiff_t m_fDangerousTimer = 0x8AC; // float
    constexpr std::ptrdiff_t m_minHitPoints = 0x8B0; // int32_t
}

namespace CTriggerSndSosOpvar { // CBaseTrigger
    constexpr std::ptrdiff_t m_hTouchingPlayers = 0x8A8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_flPosition = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flCenterSize = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMinVal = 0x8D0; // float
    constexpr std::ptrdiff_t m_flMaxVal = 0x8D4; // float
    constexpr std::ptrdiff_t m_flWait = 0x8D8; // float
    constexpr std::ptrdiff_t m_opvarName = 0x8E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_stackName = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_operatorName = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bVolIs2D = 0x8F8; // bool
    constexpr std::ptrdiff_t m_opvarNameChar = 0x8F9; // char[256]
    constexpr std::ptrdiff_t m_stackNameChar = 0x9F9; // char[256]
    constexpr std::ptrdiff_t m_operatorNameChar = 0xAF9; // char[256]
    constexpr std::ptrdiff_t m_VecNormPos = 0xBFC; // Vector
    constexpr std::ptrdiff_t m_flNormCenterSize = 0xC08; // float
}

namespace CTriggerSoundscape { // CBaseTrigger
    constexpr std::ptrdiff_t m_hSoundscape = 0x8A8; // CHandle<CEnvSoundscapeTriggerable>
    constexpr std::ptrdiff_t m_SoundscapeName = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_spectators = 0x8B8; // CUtlVector<CHandle<CBasePlayerPawn>>
}

namespace CTriggerTeleport { // CBaseTrigger
    constexpr std::ptrdiff_t m_iLandmark = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUseLandmarkAngles = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bMirrorPlayer = 0x8B1; // bool
}

namespace CTriggerToggleSave { // CBaseTrigger
    constexpr std::ptrdiff_t m_bDisabled = 0x8A8; // bool
}

namespace CTriggerTripWire { // CBaseTrigger
}

namespace CTriggerVolume { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iFilterName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x708; // CHandle<CBaseFilter>
}

namespace CTripWireFire { // CBaseCSGrenade
}

namespace CTripWireFireProjectile { // CBaseGrenade
}

namespace CVoteController { // CBaseEntity
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x4B8; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x4D0; // bool
    constexpr std::ptrdiff_t m_acceptingVotesTimer = 0x4D8; // CountdownTimer
    constexpr std::ptrdiff_t m_executeCommandTimer = 0x4F0; // CountdownTimer
    constexpr std::ptrdiff_t m_resetVoteTimer = 0x508; // CountdownTimer
    constexpr std::ptrdiff_t m_nVotesCast = 0x520; // int32_t[64]
    constexpr std::ptrdiff_t m_playerHoldingVote = 0x620; // CPlayerSlot
    constexpr std::ptrdiff_t m_playerOverrideForVote = 0x624; // CPlayerSlot
    constexpr std::ptrdiff_t m_nHighestCountIndex = 0x628; // int32_t
    constexpr std::ptrdiff_t m_potentialIssues = 0x630; // CUtlVector<CBaseIssue*>
    constexpr std::ptrdiff_t m_VoteOptions = 0x648; // CUtlVector<char*>
}

namespace CWaterBullet { // CBaseAnimGraph
}

namespace CWeaponAWP { // CCSWeaponBaseGun
}

namespace CWeaponAug { // CCSWeaponBaseGun
}

namespace CWeaponBaseItem { // CCSWeaponBase
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0xE18; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0xE30; // bool
}

namespace CWeaponBizon { // CCSWeaponBaseGun
}

namespace CWeaponCZ75a { // CCSWeaponBaseGun
}

namespace CWeaponElite { // CCSWeaponBaseGun
}

namespace CWeaponFamas { // CCSWeaponBaseGun
}

namespace CWeaponFiveSeven { // CCSWeaponBaseGun
}

namespace CWeaponG3SG1 { // CCSWeaponBaseGun
}

namespace CWeaponGalilAR { // CCSWeaponBaseGun
}

namespace CWeaponGlock { // CCSWeaponBaseGun
}

namespace CWeaponHKP2000 { // CCSWeaponBaseGun
}

namespace CWeaponM249 { // CCSWeaponBaseGun
}

namespace CWeaponM4A1 { // CCSWeaponBaseGun
}

namespace CWeaponM4A1Silencer { // CCSWeaponBaseGun
}

namespace CWeaponMAC10 { // CCSWeaponBaseGun
}

namespace CWeaponMP5SD { // CCSWeaponBaseGun
}

namespace CWeaponMP7 { // CCSWeaponBaseGun
}

namespace CWeaponMP9 { // CCSWeaponBaseGun
}

namespace CWeaponMag7 { // CCSWeaponBaseGun
}

namespace CWeaponNOVA { // CCSWeaponBase
}

namespace CWeaponNegev { // CCSWeaponBaseGun
}

namespace CWeaponP250 { // CCSWeaponBaseGun
}

namespace CWeaponP90 { // CCSWeaponBaseGun
}

namespace CWeaponRevolver { // CCSWeaponBaseGun
}

namespace CWeaponSCAR20 { // CCSWeaponBaseGun
}

namespace CWeaponSG556 { // CCSWeaponBaseGun
}

namespace CWeaponSSG08 { // CCSWeaponBaseGun
}

namespace CWeaponSawedoff { // CCSWeaponBase
}

namespace CWeaponShield { // CCSWeaponBaseGun
    constexpr std::ptrdiff_t m_flBulletDamageAbsorbed = 0xE38; // float
    constexpr std::ptrdiff_t m_flLastBulletHitSoundTime = 0xE3C; // GameTime_t
    constexpr std::ptrdiff_t m_flDisplayHealth = 0xE40; // float
}

namespace CWeaponTaser { // CCSWeaponBaseGun
    constexpr std::ptrdiff_t m_fFireTime = 0xE38; // GameTime_t
}

namespace CWeaponTec9 { // CCSWeaponBaseGun
}

namespace CWeaponUMP45 { // CCSWeaponBaseGun
}

namespace CWeaponUSPSilencer { // CCSWeaponBaseGun
}

namespace CWeaponXM1014 { // CCSWeaponBase
}

namespace CWeaponZoneRepulsor { // CCSWeaponBaseGun
}

namespace CWorld { // CBaseModelEntity
}

namespace CommandToolCommand_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bOpened = 0x1; // bool
    constexpr std::ptrdiff_t m_InternalId = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_ShortName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ExecMode = 0x10; // CommandExecMode_t
    constexpr std::ptrdiff_t m_SpawnGroup = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_PeriodicExecDelay = 0x20; // float
    constexpr std::ptrdiff_t m_SpecType = 0x24; // CommandEntitySpecType_t
    constexpr std::ptrdiff_t m_EntitySpec = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_Commands = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_SetDebugBits = 0x38; // DebugOverlayBits_t
    constexpr std::ptrdiff_t m_ClearDebugBits = 0x40; // DebugOverlayBits_t
}

namespace ConceptHistory_t {
    constexpr std::ptrdiff_t timeSpoken = 0x0; // float
    constexpr std::ptrdiff_t m_response = 0x8; // CRR_Response
}

namespace ConstraintSoundInfo {
    constexpr std::ptrdiff_t m_vSampler = 0x8; // VelocitySampler
    constexpr std::ptrdiff_t m_soundProfile = 0x20; // SimpleConstraintSoundProfile
    constexpr std::ptrdiff_t m_forwardAxis = 0x40; // Vector
    constexpr std::ptrdiff_t m_iszTravelSoundFwd = 0x50; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTravelSoundBack = 0x58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReversalSounds = 0x68; // CUtlSymbolLarge[3]
    constexpr std::ptrdiff_t m_bPlayTravelSound = 0x80; // bool
    constexpr std::ptrdiff_t m_bPlayReversalSound = 0x81; // bool
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace Extent {
    constexpr std::ptrdiff_t lo = 0x0; // Vector
    constexpr std::ptrdiff_t hi = 0xC; // Vector
}

namespace FilterDamageType { // CBaseFilter
    constexpr std::ptrdiff_t m_iDamageType = 0x508; // int32_t
}

namespace FilterHealth { // CBaseFilter
    constexpr std::ptrdiff_t m_bAdrenalineActive = 0x508; // bool
    constexpr std::ptrdiff_t m_iHealthMin = 0x50C; // int32_t
    constexpr std::ptrdiff_t m_iHealthMax = 0x510; // int32_t
}

namespace FilterTeam { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterTeam = 0x508; // int32_t
}

namespace GameAmmoTypeInfo_t { // AmmoTypeInfo_t
    constexpr std::ptrdiff_t m_nBuySize = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nCost = 0x3C; // int32_t
}

namespace GameTick_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace GameTime_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // float
}

namespace HullFlags_t {
    constexpr std::ptrdiff_t m_bHull_Human = 0x0; // bool
    constexpr std::ptrdiff_t m_bHull_SmallCentered = 0x1; // bool
    constexpr std::ptrdiff_t m_bHull_WideHuman = 0x2; // bool
    constexpr std::ptrdiff_t m_bHull_Tiny = 0x3; // bool
    constexpr std::ptrdiff_t m_bHull_Medium = 0x4; // bool
    constexpr std::ptrdiff_t m_bHull_TinyCentered = 0x5; // bool
    constexpr std::ptrdiff_t m_bHull_Large = 0x6; // bool
    constexpr std::ptrdiff_t m_bHull_LargeCentered = 0x7; // bool
    constexpr std::ptrdiff_t m_bHull_MediumTall = 0x8; // bool
    constexpr std::ptrdiff_t m_bHull_Small = 0x9; // bool
}

namespace IChoreoServices {
}

namespace IEconItemInterface {
}

namespace IHasAttributes {
}

namespace IRagdoll {
}

namespace ISkeletonAnimationController {
}

namespace IVehicle {
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace ModelConfigHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace ParticleIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // CNetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<CBaseEntity>
}

namespace QuestProgress {
}

namespace RagdollCreationParams_t {
    constexpr std::ptrdiff_t m_vForce = 0x0; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xC; // int32_t
}

namespace RelationshipOverride_t { // Relationship_t
    constexpr std::ptrdiff_t entity = 0x8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t classType = 0xC; // Class_T
}

namespace Relationship_t {
    constexpr std::ptrdiff_t disposition = 0x0; // Disposition_t
    constexpr std::ptrdiff_t priority = 0x4; // int32_t
}

namespace ResponseContext_t {
    constexpr std::ptrdiff_t m_iszName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszValue = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fExpirationTime = 0x10; // GameTime_t
}

namespace ResponseFollowup {
    constexpr std::ptrdiff_t followup_concept = 0x0; // char*
    constexpr std::ptrdiff_t followup_contexts = 0x8; // char*
    constexpr std::ptrdiff_t followup_delay = 0x10; // float
    constexpr std::ptrdiff_t followup_target = 0x14; // char*
    constexpr std::ptrdiff_t followup_entityiotarget = 0x1C; // char*
    constexpr std::ptrdiff_t followup_entityioinput = 0x24; // char*
    constexpr std::ptrdiff_t followup_entityiodelay = 0x2C; // float
    constexpr std::ptrdiff_t bFired = 0x30; // bool
}

namespace ResponseParams {
    constexpr std::ptrdiff_t odds = 0x10; // int16_t
    constexpr std::ptrdiff_t flags = 0x12; // int16_t
    constexpr std::ptrdiff_t m_pFollowup = 0x18; // ResponseFollowup*
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace SimpleConstraintSoundProfile {
    constexpr std::ptrdiff_t eKeypoints = 0x8; // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    constexpr std::ptrdiff_t m_keyPoints = 0xC; // float[2]
    constexpr std::ptrdiff_t m_reversalSoundThresholds = 0x14; // float[3]
}

namespace SpawnPoint { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_iPriority = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4B4; // bool
    constexpr std::ptrdiff_t m_nType = 0x4B8; // int32_t
}

namespace SpawnPointCoopEnemy { // SpawnPoint
    constexpr std::ptrdiff_t m_szWeaponsToGive = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szPlayerModelToUse = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nArmorToSpawnWith = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nDefaultBehavior = 0x4D4; // SpawnPointCoopEnemy::BotDefaultBehavior_t
    constexpr std::ptrdiff_t m_nBotDifficulty = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_bIsAgressive = 0x4DC; // bool
    constexpr std::ptrdiff_t m_bStartAsleep = 0x4DD; // bool
    constexpr std::ptrdiff_t m_flHideRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_szBehaviorTreeFile = 0x4F0; // CUtlSymbolLarge
}

namespace SummaryTakeDamageInfo_t {
    constexpr std::ptrdiff_t nSummarisedCount = 0x0; // int32_t
    constexpr std::ptrdiff_t info = 0x8; // CTakeDamageInfo
    constexpr std::ptrdiff_t result = 0xA0; // CTakeDamageResult
    constexpr std::ptrdiff_t hTarget = 0xA8; // CHandle<CBaseEntity>
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace VelocitySampler {
    constexpr std::ptrdiff_t m_prevSample = 0x0; // Vector
    constexpr std::ptrdiff_t m_fPrevSampleTime = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_fIdealSampleRate = 0x10; // float
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace dynpitchvol_base_t {
    constexpr std::ptrdiff_t preset = 0x0; // int32_t
    constexpr std::ptrdiff_t pitchrun = 0x4; // int32_t
    constexpr std::ptrdiff_t pitchstart = 0x8; // int32_t
    constexpr std::ptrdiff_t spinup = 0xC; // int32_t
    constexpr std::ptrdiff_t spindown = 0x10; // int32_t
    constexpr std::ptrdiff_t volrun = 0x14; // int32_t
    constexpr std::ptrdiff_t volstart = 0x18; // int32_t
    constexpr std::ptrdiff_t fadein = 0x1C; // int32_t
    constexpr std::ptrdiff_t fadeout = 0x20; // int32_t
    constexpr std::ptrdiff_t lfotype = 0x24; // int32_t
    constexpr std::ptrdiff_t lforate = 0x28; // int32_t
    constexpr std::ptrdiff_t lfomodpitch = 0x2C; // int32_t
    constexpr std::ptrdiff_t lfomodvol = 0x30; // int32_t
    constexpr std::ptrdiff_t cspinup = 0x34; // int32_t
    constexpr std::ptrdiff_t cspincount = 0x38; // int32_t
    constexpr std::ptrdiff_t pitch = 0x3C; // int32_t
    constexpr std::ptrdiff_t spinupsav = 0x40; // int32_t
    constexpr std::ptrdiff_t spindownsav = 0x44; // int32_t
    constexpr std::ptrdiff_t pitchfrac = 0x48; // int32_t
    constexpr std::ptrdiff_t vol = 0x4C; // int32_t
    constexpr std::ptrdiff_t fadeinsav = 0x50; // int32_t
    constexpr std::ptrdiff_t fadeoutsav = 0x54; // int32_t
    constexpr std::ptrdiff_t volfrac = 0x58; // int32_t
    constexpr std::ptrdiff_t lfofrac = 0x5C; // int32_t
    constexpr std::ptrdiff_t lfomult = 0x60; // int32_t
}

namespace dynpitchvol_t { // dynpitchvol_base_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<CFogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace hudtextparms_t {
    constexpr std::ptrdiff_t color1 = 0x0; // Color
    constexpr std::ptrdiff_t color2 = 0x4; // Color
    constexpr std::ptrdiff_t effect = 0x8; // uint8_t
    constexpr std::ptrdiff_t channel = 0x9; // uint8_t
    constexpr std::ptrdiff_t x = 0xC; // float
    constexpr std::ptrdiff_t y = 0x10; // float
}

namespace lerpdata_t {
    constexpr std::ptrdiff_t m_hEnt = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_MoveType = 0x4; // MoveType_t
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_vecStartOrigin = 0xC; // Vector
    constexpr std::ptrdiff_t m_qStartRot = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_nFXIndex = 0x30; // ParticleIndex_t
}

namespace locksound_t {
    constexpr std::ptrdiff_t sLockedSound = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t sUnlockedSound = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flwaitSound = 0x18; // GameTime_t
}

namespace magnetted_objects_t {
    constexpr std::ptrdiff_t hEntity = 0x8; // CHandle<CBaseEntity>
}

namespace ragdoll_t {
    constexpr std::ptrdiff_t list = 0x0; // CUtlVector<ragdollelement_t>
    constexpr std::ptrdiff_t boneIndex = 0x18; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t allowStretch = 0x30; // bool
    constexpr std::ptrdiff_t unused = 0x31; // bool
}

namespace ragdollelement_t {
    constexpr std::ptrdiff_t originParentSpace = 0x0; // Vector
    constexpr std::ptrdiff_t parentIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x24; // float
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // CNetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}

namespace thinkfunc_t {
    constexpr std::ptrdiff_t m_hFn = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nContext = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x14; // GameTick_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x18; // GameTick_t
}
```

`HPCS2/HPCS2/offset/soundsystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CDSPMixgroupModifier {
    constexpr std::ptrdiff_t m_mixgroup = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flModifier = 0x8; // float
    constexpr std::ptrdiff_t m_flModifierMin = 0xC; // float
    constexpr std::ptrdiff_t m_flSourceModifier = 0x10; // float
    constexpr std::ptrdiff_t m_flSourceModifierMin = 0x14; // float
    constexpr std::ptrdiff_t m_flListenerReverbModifierWhenSourceReverbIsActive = 0x18; // float
}

namespace CDSPPresetMixgroupModifierTable {
    constexpr std::ptrdiff_t m_table = 0x0; // CUtlVector<CDspPresetModifierList>
}

namespace CDspPresetModifierList {
    constexpr std::ptrdiff_t m_dspName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modifiers = 0x8; // CUtlVector<CDSPMixgroupModifier>
}

namespace CSosGroupActionLimitSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nStopType = 0x1C; // SosActionStopType_t
    constexpr std::ptrdiff_t m_nSortType = 0x20; // SosActionSortType_t
}

namespace CSosGroupActionSchema {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_actionType = 0x10; // ActionType_t
    constexpr std::ptrdiff_t m_actionInstanceType = 0x14; // ActionType_t
}

namespace CSosGroupActionSetSoundeventParameterSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_flMinValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxValue = 0x20; // float
    constexpr std::ptrdiff_t m_opvarName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_nSortType = 0x30; // SosActionSortType_t
}

namespace CSosGroupActionTimeLimitSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_flMaxDuration = 0x18; // float
}

namespace CSosGroupBranchPattern {
    constexpr std::ptrdiff_t m_bMatchEventName = 0x8; // bool
    constexpr std::ptrdiff_t m_bMatchEventSubString = 0x9; // bool
    constexpr std::ptrdiff_t m_bMatchEntIndex = 0xA; // bool
    constexpr std::ptrdiff_t m_bMatchOpvar = 0xB; // bool
}

namespace CSosGroupMatchPattern { // CSosGroupBranchPattern
    constexpr std::ptrdiff_t m_matchSoundEventName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_matchSoundEventSubString = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_flEntIndex = 0x20; // float
    constexpr std::ptrdiff_t m_flOpvar = 0x24; // float
}

namespace CSosSoundEventGroupListSchema {
    constexpr std::ptrdiff_t m_groupList = 0x0; // CUtlVector<CSosSoundEventGroupSchema>
}

namespace CSosSoundEventGroupSchema {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nType = 0x8; // SosGroupType_t
    constexpr std::ptrdiff_t m_bIsBlocking = 0xC; // bool
    constexpr std::ptrdiff_t m_nBlockMaxCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_bInvertMatch = 0x14; // bool
    constexpr std::ptrdiff_t m_matchPattern = 0x18; // CSosGroupMatchPattern
    constexpr std::ptrdiff_t m_branchPattern = 0x40; // CSosGroupBranchPattern
    constexpr std::ptrdiff_t m_vActions = 0xB0; // CSosGroupActionSchema*[4]
}

namespace CSoundEventMetaData {
    constexpr std::ptrdiff_t m_soundEventVMix = 0x0; // CStrongHandle<InfoForResourceTypeCVMixListResource>
}

namespace SelectedEditItemInfo_t {
    constexpr std::ptrdiff_t m_EditItems = 0x0; // CUtlVector<SosEditItemInfo_t>
}

namespace SosEditItemInfo_t {
    constexpr std::ptrdiff_t itemType = 0x0; // SosEditItemType_t
    constexpr std::ptrdiff_t itemName = 0x8; // CUtlString
    constexpr std::ptrdiff_t itemTypeName = 0x10; // CUtlString
    constexpr std::ptrdiff_t itemKVString = 0x20; // CUtlString
    constexpr std::ptrdiff_t itemPos = 0x28; // Vector2D
}

namespace VMixAutoFilterDesc_t {
    constexpr std::ptrdiff_t m_flEnvelopeAmount = 0x0; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
    constexpr std::ptrdiff_t m_filter = 0xC; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flLFOAmount = 0x1C; // float
    constexpr std::ptrdiff_t m_flLFORate = 0x20; // float
    constexpr std::ptrdiff_t m_flPhase = 0x24; // float
    constexpr std::ptrdiff_t m_nLFOShape = 0x28; // VMixLFOShape_t
}

namespace VMixBoxverbDesc_t {
    constexpr std::ptrdiff_t m_flSizeMax = 0x0; // float
    constexpr std::ptrdiff_t m_flSizeMin = 0x4; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x8; // float
    constexpr std::ptrdiff_t m_flDiffusion = 0xC; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x10; // float
    constexpr std::ptrdiff_t m_flModRate = 0x14; // float
    constexpr std::ptrdiff_t m_bParallel = 0x18; // bool
    constexpr std::ptrdiff_t m_filterType = 0x1C; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flWidth = 0x2C; // float
    constexpr std::ptrdiff_t m_flHeight = 0x30; // float
    constexpr std::ptrdiff_t m_flDepth = 0x34; // float
    constexpr std::ptrdiff_t m_flFeedbackScale = 0x38; // float
    constexpr std::ptrdiff_t m_flFeedbackWidth = 0x3C; // float
    constexpr std::ptrdiff_t m_flFeedbackHeight = 0x40; // float
    constexpr std::ptrdiff_t m_flFeedbackDepth = 0x44; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x48; // float
    constexpr std::ptrdiff_t m_flTaps = 0x4C; // float
}

namespace VMixConvolutionDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_flPreDelayMS = 0x4; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLow = 0xC; // float
    constexpr std::ptrdiff_t m_fldbMid = 0x10; // float
    constexpr std::ptrdiff_t m_fldbHigh = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
}

namespace VMixDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bEnableFilter = 0x10; // bool
    constexpr std::ptrdiff_t m_flDelay = 0x14; // float
    constexpr std::ptrdiff_t m_flDirectGain = 0x18; // float
    constexpr std::ptrdiff_t m_flDelayGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flWidth = 0x24; // float
}

namespace VMixDiffusorDesc_t {
    constexpr std::ptrdiff_t m_flSize = 0x0; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x4; // float
    constexpr std::ptrdiff_t m_flFeedback = 0x8; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0xC; // float
}

namespace VMixDynamics3BandDesc_t {
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x0; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flDepth = 0xC; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x10; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
    constexpr std::ptrdiff_t m_bandDesc = 0x24; // VMixDynamicsBand_t[3]
}

namespace VMixDynamicsBand_t {
    constexpr std::ptrdiff_t m_fldbGainInput = 0x0; // float
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x4; // float
    constexpr std::ptrdiff_t m_fldbThresholdBelow = 0x8; // float
    constexpr std::ptrdiff_t m_fldbThresholdAbove = 0xC; // float
    constexpr std::ptrdiff_t m_flRatioBelow = 0x10; // float
    constexpr std::ptrdiff_t m_flRatioAbove = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_bEnable = 0x20; // bool
    constexpr std::ptrdiff_t m_bSolo = 0x21; // bool
}

namespace VMixDynamicsCompressorDesc_t {
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flCompressionRatio = 0xC; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x10; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x14; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
}

namespace VMixDynamicsDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbNoiseGateThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLimiterThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x10; // float
    constexpr std::ptrdiff_t m_flRatio = 0x14; // float
    constexpr std::ptrdiff_t m_flLimiterRatio = 0x18; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x20; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x24; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x28; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x2C; // bool
}

namespace VMixEQ8Desc_t {
    constexpr std::ptrdiff_t m_stages = 0x0; // VMixFilterDesc_t[8]
}

namespace VMixEffectChainDesc_t {
    constexpr std::ptrdiff_t m_flCrossfadeTime = 0x0; // float
}

namespace VMixEnvelopeDesc_t {
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x0; // float
    constexpr std::ptrdiff_t m_flHoldTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
}

namespace VMixFilterDesc_t {
    constexpr std::ptrdiff_t m_nFilterType = 0x0; // VMixFilterType_t
    constexpr std::ptrdiff_t m_nFilterSlope = 0x2; // VMixFilterSlope_t
    constexpr std::ptrdiff_t m_bEnabled = 0x3; // bool
    constexpr std::ptrdiff_t m_fldbGain = 0x4; // float
    constexpr std::ptrdiff_t m_flCutoffFreq = 0x8; // float
    constexpr std::ptrdiff_t m_flQ = 0xC; // float
}

namespace VMixFreeverbDesc_t {
    constexpr std::ptrdiff_t m_flRoomSize = 0x0; // float
    constexpr std::ptrdiff_t m_flDamp = 0x4; // float
    constexpr std::ptrdiff_t m_flWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flLateReflections = 0xC; // float
}

namespace VMixModDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bPhaseInvert = 0x10; // bool
    constexpr std::ptrdiff_t m_flGlideTime = 0x14; // float
    constexpr std::ptrdiff_t m_flDelay = 0x18; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flModRate = 0x24; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x28; // float
    constexpr std::ptrdiff_t m_bApplyAntialiasing = 0x2C; // bool
}

namespace VMixOscDesc_t {
    constexpr std::ptrdiff_t oscType = 0x0; // VMixLFOShape_t
    constexpr std::ptrdiff_t m_freq = 0x4; // float
    constexpr std::ptrdiff_t m_flPhase = 0x8; // float
}

namespace VMixPannerDesc_t {
    constexpr std::ptrdiff_t m_type = 0x0; // VMixPannerType_t
    constexpr std::ptrdiff_t m_flStrength = 0x4; // float
}

namespace VMixPitchShiftDesc_t {
    constexpr std::ptrdiff_t m_nGrainSampleCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flPitchShift = 0x4; // float
    constexpr std::ptrdiff_t m_nQuality = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nProcType = 0xC; // int32_t
}

namespace VMixPlateverbDesc_t {
    constexpr std::ptrdiff_t m_flPrefilter = 0x0; // float
    constexpr std::ptrdiff_t m_flInputDiffusion1 = 0x4; // float
    constexpr std::ptrdiff_t m_flInputDiffusion2 = 0x8; // float
    constexpr std::ptrdiff_t m_flDecay = 0xC; // float
    constexpr std::ptrdiff_t m_flDamp = 0x10; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion1 = 0x14; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion2 = 0x18; // float
}

namespace VMixShaperDesc_t {
    constexpr std::ptrdiff_t m_nShape = 0x0; // int32_t
    constexpr std::ptrdiff_t m_fldbDrive = 0x4; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x8; // float
    constexpr std::ptrdiff_t m_flWetMix = 0xC; // float
    constexpr std::ptrdiff_t m_nOversampleFactor = 0x10; // int32_t
}

namespace VMixSubgraphSwitchDesc_t {
    constexpr std::ptrdiff_t m_interpolationMode = 0x0; // VMixSubgraphSwitchInterpolationType_t
    constexpr std::ptrdiff_t m_bOnlyTailsOnFadeOut = 0x4; // bool
    constexpr std::ptrdiff_t m_flInterpolationTime = 0x8; // float
}

namespace VMixUtilityDesc_t {
    constexpr std::ptrdiff_t m_nOp = 0x0; // VMixChannelOperation_t
    constexpr std::ptrdiff_t m_flInputPan = 0x4; // float
    constexpr std::ptrdiff_t m_flOutputBalance = 0x8; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0xC; // float
    constexpr std::ptrdiff_t m_bBassMono = 0x10; // bool
    constexpr std::ptrdiff_t m_flBassFreq = 0x14; // float
}

namespace VMixVocoderDesc_t {
    constexpr std::ptrdiff_t m_nBandCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flBandwidth = 0x4; // float
    constexpr std::ptrdiff_t m_fldBModGain = 0x8; // float
    constexpr std::ptrdiff_t m_flFreqRangeStart = 0xC; // float
    constexpr std::ptrdiff_t m_flFreqRangeEnd = 0x10; // float
    constexpr std::ptrdiff_t m_fldBUnvoicedGain = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_nDebugBand = 0x20; // int32_t
    constexpr std::ptrdiff_t m_bPeakMode = 0x24; // bool
}
```

`HPCS2/HPCS2/offset/vphysics2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace CFeIndexedJiggleBone {
    constexpr std::ptrdiff_t m_nNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nJiggleParent = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x8; // CFeJiggleBone
}

namespace CFeJiggleBone {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
    constexpr std::ptrdiff_t m_flTipMass = 0x8; // float
    constexpr std::ptrdiff_t m_flYawStiffness = 0xC; // float
    constexpr std::ptrdiff_t m_flYawDamping = 0x10; // float
    constexpr std::ptrdiff_t m_flPitchStiffness = 0x14; // float
    constexpr std::ptrdiff_t m_flPitchDamping = 0x18; // float
    constexpr std::ptrdiff_t m_flAlongStiffness = 0x1C; // float
    constexpr std::ptrdiff_t m_flAlongDamping = 0x20; // float
    constexpr std::ptrdiff_t m_flAngleLimit = 0x24; // float
    constexpr std::ptrdiff_t m_flMinYaw = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxYaw = 0x2C; // float
    constexpr std::ptrdiff_t m_flYawFriction = 0x30; // float
    constexpr std::ptrdiff_t m_flYawBounce = 0x34; // float
    constexpr std::ptrdiff_t m_flMinPitch = 0x38; // float
    constexpr std::ptrdiff_t m_flMaxPitch = 0x3C; // float
    constexpr std::ptrdiff_t m_flPitchFriction = 0x40; // float
    constexpr std::ptrdiff_t m_flPitchBounce = 0x44; // float
    constexpr std::ptrdiff_t m_flBaseMass = 0x48; // float
    constexpr std::ptrdiff_t m_flBaseStiffness = 0x4C; // float
    constexpr std::ptrdiff_t m_flBaseDamping = 0x50; // float
    constexpr std::ptrdiff_t m_flBaseMinLeft = 0x54; // float
    constexpr std::ptrdiff_t m_flBaseMaxLeft = 0x58; // float
    constexpr std::ptrdiff_t m_flBaseLeftFriction = 0x5C; // float
    constexpr std::ptrdiff_t m_flBaseMinUp = 0x60; // float
    constexpr std::ptrdiff_t m_flBaseMaxUp = 0x64; // float
    constexpr std::ptrdiff_t m_flBaseUpFriction = 0x68; // float
    constexpr std::ptrdiff_t m_flBaseMinForward = 0x6C; // float
    constexpr std::ptrdiff_t m_flBaseMaxForward = 0x70; // float
    constexpr std::ptrdiff_t m_flBaseForwardFriction = 0x74; // float
    constexpr std::ptrdiff_t m_flRadius0 = 0x78; // float
    constexpr std::ptrdiff_t m_flRadius1 = 0x7C; // float
    constexpr std::ptrdiff_t m_vPoint0 = 0x80; // Vector
    constexpr std::ptrdiff_t m_vPoint1 = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nCollisionMask = 0x98; // uint16_t
}

namespace CFeMorphLayer {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
}

namespace CFeNamedJiggleBone {
    constexpr std::ptrdiff_t m_strParentBone = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_transform = 0x10; // CTransform
    constexpr std::ptrdiff_t m_nJiggleParent = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x34; // CFeJiggleBone
}

namespace CFeVertexMapBuildArray {
    constexpr std::ptrdiff_t m_Array = 0x0; // CUtlVector<FeVertexMapBuild_t*>
}

namespace CRegionSVM {
    constexpr std::ptrdiff_t m_Planes = 0x0; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<uint32_t>
}

namespace CastSphereSATParams_t {
    constexpr std::ptrdiff_t m_vRayStart = 0x0; // Vector
    constexpr std::ptrdiff_t m_vRayDelta = 0xC; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_flMaxFraction = 0x1C; // float
    constexpr std::ptrdiff_t m_flScale = 0x20; // float
    constexpr std::ptrdiff_t m_pHull = 0x28; // RnHull_t*
}

namespace CovMatrix3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // Vector
    constexpr std::ptrdiff_t m_flXY = 0xC; // float
    constexpr std::ptrdiff_t m_flXZ = 0x10; // float
    constexpr std::ptrdiff_t m_flYZ = 0x14; // float
}

namespace Dop26_t {
    constexpr std::ptrdiff_t m_flSupport = 0x0; // float[26]
}

namespace FeAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x8; // float
}

namespace FeAxialEdgeBend_t {
    constexpr std::ptrdiff_t te = 0x0; // float
    constexpr std::ptrdiff_t tv = 0x4; // float
    constexpr std::ptrdiff_t flDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight = 0xC; // float[4]
    constexpr std::ptrdiff_t nNode = 0x1C; // uint16_t[6]
}

namespace FeBandBendLimit_t {
    constexpr std::ptrdiff_t flDistMin = 0x0; // float
    constexpr std::ptrdiff_t flDistMax = 0x4; // float
    constexpr std::ptrdiff_t nNode = 0x8; // uint16_t[6]
}

namespace FeBoxRigid_t {
    constexpr std::ptrdiff_t tmFrame2 = 0x0; // CTransform
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t vSize = 0x24; // Vector
    constexpr std::ptrdiff_t nVertexMapIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x32; // uint16_t
}

namespace FeBuildBoxRigid_t { // FeBoxRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x44; // uint32_t
}

namespace FeBuildSphereRigid_t { // FeSphereRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x24; // uint32_t
}

namespace FeBuildTaperedCapsuleRigid_t { // FeTaperedCapsuleRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x34; // uint32_t
}

namespace FeCollisionPlane_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_Plane = 0x4; // RnPlane_t
    constexpr std::ptrdiff_t flStrength = 0x14; // float
}

namespace FeCtrlOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nCtrlParent = 0xC; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0xE; // uint16_t
}

namespace FeCtrlOsOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
}

namespace FeCtrlSoftOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
    constexpr std::ptrdiff_t vOffset = 0x4; // Vector
    constexpr std::ptrdiff_t flAlpha = 0x10; // float
}

namespace FeEdgeDesc_t {
    constexpr std::ptrdiff_t nEdge = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nSide = 0x4; // uint16_t[2][2]
    constexpr std::ptrdiff_t nVirtElem = 0xC; // uint16_t[2]
}

namespace FeEffectDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nType = 0xC; // int32_t
    constexpr std::ptrdiff_t m_Params = 0x10; // KeyValues3
}

namespace FeFitInfluence_t {
    constexpr std::ptrdiff_t nVertexNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
    constexpr std::ptrdiff_t nMatrixNode = 0x8; // uint32_t
}

namespace FeFitMatrix_t {
    constexpr std::ptrdiff_t bone = 0x0; // CTransform
    constexpr std::ptrdiff_t vCenter = 0x20; // Vector
    constexpr std::ptrdiff_t nEnd = 0x2C; // uint16_t
    constexpr std::ptrdiff_t nNode = 0x2E; // uint16_t
    constexpr std::ptrdiff_t nBeginDynamic = 0x30; // uint16_t
}

namespace FeFitWeight_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float
    constexpr std::ptrdiff_t nNode = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
}

namespace FeFollowNode_t {
    constexpr std::ptrdiff_t nParentNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
}

namespace FeKelagerBend2_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float[3]
    constexpr std::ptrdiff_t flHeight0 = 0xC; // float
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t[3]
    constexpr std::ptrdiff_t nReserved = 0x16; // uint16_t
}

namespace FeMorphLayerDepr_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlags = 0x88; // uint32_t
}

namespace FeNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x2; // uint16_t[3]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0xA; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0xC; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0xE; // uint16_t
    constexpr std::ptrdiff_t qAdjust = 0x10; // QuaternionStorage
}

namespace FeNodeIntegrator_t {
    constexpr std::ptrdiff_t flPointDamping = 0x0; // float
    constexpr std::ptrdiff_t flAnimationForceAttraction = 0x4; // float
    constexpr std::ptrdiff_t flAnimationVertexAttraction = 0x8; // float
    constexpr std::ptrdiff_t flGravity = 0xC; // float
}

namespace FeNodeReverseOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nBoneCtrl = 0xC; // uint16_t
    constexpr std::ptrdiff_t nTargetNode = 0xE; // uint16_t
}

namespace FeNodeWindBase_t {
    constexpr std::ptrdiff_t nNodeX0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0x4; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0x6; // uint16_t
}

namespace FeProxyVertexMap_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace FeQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t flSlack = 0x8; // float
    constexpr std::ptrdiff_t vShape = 0xC; // Vector4D[4]
}

namespace FeRigidColliderIndices_t {
    constexpr std::ptrdiff_t m_nTaperedCapsuleRigidIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nSphereRigidIndex = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBoxRigidIndex = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionPlaneIndex = 0x6; // uint16_t
}

namespace FeRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flMinDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight0 = 0xC; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x10; // float
}

namespace FeSimdAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flMaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t flRelaxationFactor = 0x20; // fltx4
}

namespace FeSimdNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX1 = 0x10; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY0 = 0x18; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY1 = 0x20; // uint16_t[4]
    constexpr std::ptrdiff_t nDummy = 0x28; // uint16_t[4]
    constexpr std::ptrdiff_t qAdjust = 0x30; // FourQuaternions
}

namespace FeSimdQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][4]
    constexpr std::ptrdiff_t f4Slack = 0x20; // fltx4
    constexpr std::ptrdiff_t vShape = 0x30; // FourVectors[4]
    constexpr std::ptrdiff_t f4Weights = 0xF0; // fltx4[4]
}

namespace FeSimdRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t f4MaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t f4MinDist = 0x20; // fltx4
    constexpr std::ptrdiff_t f4Weight0 = 0x30; // fltx4
    constexpr std::ptrdiff_t f4RelaxationFactor = 0x40; // fltx4
}

namespace FeSimdSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x10; // fltx4
    constexpr std::ptrdiff_t flSpringConstant = 0x20; // fltx4
    constexpr std::ptrdiff_t flSpringDamping = 0x30; // fltx4
    constexpr std::ptrdiff_t flNodeWeight0 = 0x40; // fltx4
}

namespace FeSimdTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint32_t[4][3]
    constexpr std::ptrdiff_t w1 = 0x30; // fltx4
    constexpr std::ptrdiff_t w2 = 0x40; // fltx4
    constexpr std::ptrdiff_t v1x = 0x50; // fltx4
    constexpr std::ptrdiff_t v2 = 0x60; // FourVectors2D
}

namespace FeSoftParent_t {
    constexpr std::ptrdiff_t nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t flAlpha = 0x4; // float
}

namespace FeSourceEdge_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
}

namespace FeSphereRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x12; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x14; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x16; // uint16_t
}

namespace FeSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x4; // float
    constexpr std::ptrdiff_t flSpringConstant = 0x8; // float
    constexpr std::ptrdiff_t flSpringDamping = 0xC; // float
    constexpr std::ptrdiff_t flNodeWeight0 = 0x10; // float
}

namespace FeStiffHingeBuild_t {
    constexpr std::ptrdiff_t flMaxAngle = 0x0; // float
    constexpr std::ptrdiff_t flStrength = 0x4; // float
    constexpr std::ptrdiff_t flMotionBias = 0x8; // float[3]
    constexpr std::ptrdiff_t nNode = 0x14; // uint16_t[3]
}

namespace FeTaperedCapsuleRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4[2]
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x24; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x26; // uint16_t
}

namespace FeTaperedCapsuleStretch_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nCollisionMask = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
    constexpr std::ptrdiff_t flRadius = 0x8; // float[2]
}

namespace FeTreeChildren_t {
    constexpr std::ptrdiff_t nChild = 0x0; // uint16_t[2]
}

namespace FeTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[3]
    constexpr std::ptrdiff_t w1 = 0x8; // float
    constexpr std::ptrdiff_t w2 = 0xC; // float
    constexpr std::ptrdiff_t v1x = 0x10; // float
    constexpr std::ptrdiff_t v2 = 0x14; // Vector2D
}

namespace FeTwistConstraint_t {
    constexpr std::ptrdiff_t nNodeOrient = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeEnd = 0x2; // uint16_t
    constexpr std::ptrdiff_t flTwistRelax = 0x4; // float
    constexpr std::ptrdiff_t flSwingRelax = 0x8; // float
}

namespace FeVertexMapBuild_t {
    constexpr std::ptrdiff_t m_VertexMapName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Color = 0xC; // Color
    constexpr std::ptrdiff_t m_flVolumetricSolveStrength = 0x10; // float
    constexpr std::ptrdiff_t m_nScaleSourceNode = 0x14; // int32_t
    constexpr std::ptrdiff_t m_Weights = 0x18; // CUtlVector<float>
}

namespace FeVertexMapDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nColor = 0xC; // uint32_t
    constexpr std::ptrdiff_t nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t nVertexBase = 0x14; // uint16_t
    constexpr std::ptrdiff_t nVertexCount = 0x16; // uint16_t
    constexpr std::ptrdiff_t nMapOffset = 0x18; // uint32_t
    constexpr std::ptrdiff_t nNodeListOffset = 0x1C; // uint32_t
    constexpr std::ptrdiff_t vCenterOfMass = 0x20; // Vector
    constexpr std::ptrdiff_t flVolumetricSolveStrength = 0x2C; // float
    constexpr std::ptrdiff_t nScaleSourceNode = 0x30; // int16_t
    constexpr std::ptrdiff_t nNodeListCount = 0x32; // uint16_t
}

namespace FeWeightedNode_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nWeight = 0x2; // uint16_t
}

namespace FeWorldCollisionParams_t {
    constexpr std::ptrdiff_t flWorldFriction = 0x0; // float
    constexpr std::ptrdiff_t flGroundFriction = 0x4; // float
    constexpr std::ptrdiff_t nListBegin = 0x8; // uint16_t
    constexpr std::ptrdiff_t nListEnd = 0xA; // uint16_t
}

namespace FourCovMatrices3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // FourVectors
    constexpr std::ptrdiff_t m_flXY = 0x30; // fltx4
    constexpr std::ptrdiff_t m_flXZ = 0x40; // fltx4
    constexpr std::ptrdiff_t m_flYZ = 0x50; // fltx4
}

namespace FourVectors2D {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
}

namespace IPhysicsPlayerController {
}

namespace OldFeEdge_t {
    constexpr std::ptrdiff_t m_flK = 0x0; // float[3]
    constexpr std::ptrdiff_t invA = 0xC; // float
    constexpr std::ptrdiff_t t = 0x10; // float
    constexpr std::ptrdiff_t flThetaRelaxed = 0x14; // float
    constexpr std::ptrdiff_t flThetaFactor = 0x18; // float
    constexpr std::ptrdiff_t c01 = 0x1C; // float
    constexpr std::ptrdiff_t c02 = 0x20; // float
    constexpr std::ptrdiff_t c03 = 0x24; // float
    constexpr std::ptrdiff_t c04 = 0x28; // float
    constexpr std::ptrdiff_t flAxialModelDist = 0x2C; // float
    constexpr std::ptrdiff_t flAxialModelWeights = 0x30; // float[4]
    constexpr std::ptrdiff_t m_nNode = 0x40; // uint16_t[4]
}

namespace PhysFeModelDesc_t {
    constexpr std::ptrdiff_t m_CtrlHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CtrlName = 0x18; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nStaticNodeFlags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_nDynamicNodeFlags = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_flLocalForce = 0x38; // float
    constexpr std::ptrdiff_t m_flLocalRotation = 0x3C; // float
    constexpr std::ptrdiff_t m_nNodeCount = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_nStaticNodes = 0x42; // uint16_t
    constexpr std::ptrdiff_t m_nRotLockStaticNodes = 0x44; // uint16_t
    constexpr std::ptrdiff_t m_nFirstPositionDrivenNode = 0x46; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount1 = 0x48; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount2 = 0x4A; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount1 = 0x4C; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount2 = 0x4E; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount1 = 0x50; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount2 = 0x52; // uint16_t
    constexpr std::ptrdiff_t m_nTreeDepth = 0x54; // uint16_t
    constexpr std::ptrdiff_t m_nNodeBaseJiggleboneDependsCount = 0x56; // uint16_t
    constexpr std::ptrdiff_t m_nRopeCount = 0x58; // uint16_t
    constexpr std::ptrdiff_t m_Ropes = 0x60; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_NodeBases = 0x78; // CUtlVector<FeNodeBase_t>
    constexpr std::ptrdiff_t m_SimdNodeBases = 0x90; // CUtlVector<FeSimdNodeBase_t>
    constexpr std::ptrdiff_t m_Quads = 0xA8; // CUtlVector<FeQuad_t>
    constexpr std::ptrdiff_t m_SimdQuads = 0xC0; // CUtlVector<FeSimdQuad_t>
    constexpr std::ptrdiff_t m_SimdTris = 0xD8; // CUtlVector<FeSimdTri_t>
    constexpr std::ptrdiff_t m_SimdRods = 0xF0; // CUtlVector<FeSimdRodConstraint_t>
    constexpr std::ptrdiff_t m_InitPose = 0x108; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_Rods = 0x120; // CUtlVector<FeRodConstraint_t>
    constexpr std::ptrdiff_t m_Twists = 0x138; // CUtlVector<FeTwistConstraint_t>
    constexpr std::ptrdiff_t m_AxialEdges = 0x150; // CUtlVector<FeAxialEdgeBend_t>
    constexpr std::ptrdiff_t m_NodeInvMasses = 0x168; // CUtlVector<float>
    constexpr std::ptrdiff_t m_CtrlOffsets = 0x180; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_CtrlOsOffsets = 0x198; // CUtlVector<FeCtrlOsOffset_t>
    constexpr std::ptrdiff_t m_FollowNodes = 0x1B0; // CUtlVector<FeFollowNode_t>
    constexpr std::ptrdiff_t m_CollisionPlanes = 0x1C8; // CUtlVector<FeCollisionPlane_t>
    constexpr std::ptrdiff_t m_NodeIntegrator = 0x1E0; // CUtlVector<FeNodeIntegrator_t>
    constexpr std::ptrdiff_t m_SpringIntegrator = 0x1F8; // CUtlVector<FeSpringIntegrator_t>
    constexpr std::ptrdiff_t m_SimdSpringIntegrator = 0x210; // CUtlVector<FeSimdSpringIntegrator_t>
    constexpr std::ptrdiff_t m_WorldCollisionParams = 0x228; // CUtlVector<FeWorldCollisionParams_t>
    constexpr std::ptrdiff_t m_LegacyStretchForce = 0x240; // CUtlVector<float>
    constexpr std::ptrdiff_t m_NodeCollisionRadii = 0x258; // CUtlVector<float>
    constexpr std::ptrdiff_t m_DynNodeFriction = 0x270; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalRotation = 0x288; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalForce = 0x2A0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_TaperedCapsuleStretches = 0x2B8; // CUtlVector<FeTaperedCapsuleStretch_t>
    constexpr std::ptrdiff_t m_TaperedCapsuleRigids = 0x2D0; // CUtlVector<FeTaperedCapsuleRigid_t>
    constexpr std::ptrdiff_t m_SphereRigids = 0x2E8; // CUtlVector<FeSphereRigid_t>
    constexpr std::ptrdiff_t m_WorldCollisionNodes = 0x300; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeParents = 0x318; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeCollisionMasks = 0x330; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeChildren = 0x348; // CUtlVector<FeTreeChildren_t>
    constexpr std::ptrdiff_t m_FreeNodes = 0x360; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_FitMatrices = 0x378; // CUtlVector<FeFitMatrix_t>
    constexpr std::ptrdiff_t m_FitWeights = 0x390; // CUtlVector<FeFitWeight_t>
    constexpr std::ptrdiff_t m_ReverseOffsets = 0x3A8; // CUtlVector<FeNodeReverseOffset_t>
    constexpr std::ptrdiff_t m_AnimStrayRadii = 0x3C0; // CUtlVector<FeAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_SimdAnimStrayRadii = 0x3D8; // CUtlVector<FeSimdAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_KelagerBends = 0x3F0; // CUtlVector<FeKelagerBend2_t>
    constexpr std::ptrdiff_t m_CtrlSoftOffsets = 0x408; // CUtlVector<FeCtrlSoftOffset_t>
    constexpr std::ptrdiff_t m_JiggleBones = 0x420; // CUtlVector<CFeIndexedJiggleBone>
    constexpr std::ptrdiff_t m_SourceElems = 0x438; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_GoalDampedSpringIntegrators = 0x450; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Tris = 0x468; // CUtlVector<FeTri_t>
    constexpr std::ptrdiff_t m_nTriCount1 = 0x480; // uint16_t
    constexpr std::ptrdiff_t m_nTriCount2 = 0x482; // uint16_t
    constexpr std::ptrdiff_t m_nReservedUint8 = 0x484; // uint8_t
    constexpr std::ptrdiff_t m_nExtraPressureIterations = 0x485; // uint8_t
    constexpr std::ptrdiff_t m_nExtraGoalIterations = 0x486; // uint8_t
    constexpr std::ptrdiff_t m_nExtraIterations = 0x487; // uint8_t
    constexpr std::ptrdiff_t m_BoxRigids = 0x488; // CUtlVector<FeBoxRigid_t>
    constexpr std::ptrdiff_t m_DynNodeVertexSet = 0x4A0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexSetNames = 0x4B8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_RigidColliderPriorities = 0x4D0; // CUtlVector<FeRigidColliderIndices_t>
    constexpr std::ptrdiff_t m_MorphLayers = 0x4E8; // CUtlVector<FeMorphLayerDepr_t>
    constexpr std::ptrdiff_t m_MorphSetData = 0x500; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexMaps = 0x518; // CUtlVector<FeVertexMapDesc_t>
    constexpr std::ptrdiff_t m_VertexMapValues = 0x530; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_Effects = 0x548; // CUtlVector<FeEffectDesc_t>
    constexpr std::ptrdiff_t m_LockToParent = 0x560; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_LockToGoal = 0x578; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_DynNodeWindBases = 0x590; // CUtlVector<FeNodeWindBase_t>
    constexpr std::ptrdiff_t m_flInternalPressure = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDefaultTimeDilation = 0x5AC; // float
    constexpr std::ptrdiff_t m_flWindage = 0x5B0; // float
    constexpr std::ptrdiff_t m_flWindDrag = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDefaultSurfaceStretch = 0x5B8; // float
    constexpr std::ptrdiff_t m_flDefaultThreadStretch = 0x5BC; // float
    constexpr std::ptrdiff_t m_flDefaultGravityScale = 0x5C0; // float
    constexpr std::ptrdiff_t m_flDefaultVelAirDrag = 0x5C4; // float
    constexpr std::ptrdiff_t m_flDefaultExpAirDrag = 0x5C8; // float
    constexpr std::ptrdiff_t m_flDefaultVelQuadAirDrag = 0x5CC; // float
    constexpr std::ptrdiff_t m_flDefaultExpQuadAirDrag = 0x5D0; // float
    constexpr std::ptrdiff_t m_flRodVelocitySmoothRate = 0x5D4; // float
    constexpr std::ptrdiff_t m_flQuadVelocitySmoothRate = 0x5D8; // float
    constexpr std::ptrdiff_t m_flAddWorldCollisionRadius = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDefaultVolumetricSolveAmount = 0x5E0; // float
    constexpr std::ptrdiff_t m_nRodVelocitySmoothIterations = 0x5E4; // uint16_t
    constexpr std::ptrdiff_t m_nQuadVelocitySmoothIterations = 0x5E6; // uint16_t
}

namespace RnBlendVertex_t {
    constexpr std::ptrdiff_t m_nWeight0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nIndex0 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nWeight1 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nIndex1 = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_nWeight2 = 0x8; // uint16_t
    constexpr std::ptrdiff_t m_nIndex2 = 0xA; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0xC; // uint16_t
    constexpr std::ptrdiff_t m_nTargetIndex = 0xE; // uint16_t
}

namespace RnBodyDesc_t {
    constexpr std::ptrdiff_t m_sDebugName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vPosition = 0x8; // Vector
    constexpr std::ptrdiff_t m_qOrientation = 0x14; // QuaternionStorage
    constexpr std::ptrdiff_t m_vLinearVelocity = 0x24; // Vector
    constexpr std::ptrdiff_t m_vAngularVelocity = 0x30; // Vector
    constexpr std::ptrdiff_t m_vLocalMassCenter = 0x3C; // Vector
    constexpr std::ptrdiff_t m_LocalInertiaInv = 0x48; // Vector[3]
    constexpr std::ptrdiff_t m_flMassInv = 0x6C; // float
    constexpr std::ptrdiff_t m_flGameMass = 0x70; // float
    constexpr std::ptrdiff_t m_flInertiaScaleInv = 0x74; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x78; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x7C; // float
    constexpr std::ptrdiff_t m_flLinearDrag = 0x80; // float
    constexpr std::ptrdiff_t m_flAngularDrag = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearBuoyancyDrag = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularBuoyancyDrag = 0x8C; // float
    constexpr std::ptrdiff_t m_vLastAwakeForceAccum = 0x90; // Vector
    constexpr std::ptrdiff_t m_vLastAwakeTorqueAccum = 0x9C; // Vector
    constexpr std::ptrdiff_t m_flBuoyancyFactor = 0xA8; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0xAC; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0xB0; // float
    constexpr std::ptrdiff_t m_nBodyType = 0xB4; // int32_t
    constexpr std::ptrdiff_t m_nGameIndex = 0xB8; // uint32_t
    constexpr std::ptrdiff_t m_nGameFlags = 0xBC; // uint32_t
    constexpr std::ptrdiff_t m_nMinVelocityIterations = 0xC0; // int8_t
    constexpr std::ptrdiff_t m_nMinPositionIterations = 0xC1; // int8_t
    constexpr std::ptrdiff_t m_nMassPriority = 0xC2; // int8_t
    constexpr std::ptrdiff_t m_bEnabled = 0xC3; // bool
    constexpr std::ptrdiff_t m_bSleeping = 0xC4; // bool
    constexpr std::ptrdiff_t m_bIsContinuousEnabled = 0xC5; // bool
    constexpr std::ptrdiff_t m_bDragEnabled = 0xC6; // bool
    constexpr std::ptrdiff_t m_bBuoyancyDragEnabled = 0xC7; // bool
    constexpr std::ptrdiff_t m_bGravityDisabled = 0xC8; // bool
    constexpr std::ptrdiff_t m_bSpeculativeEnabled = 0xC9; // bool
    constexpr std::ptrdiff_t m_bHasShadowController = 0xCA; // bool
}

namespace RnCapsuleDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Capsule = 0x10; // RnCapsule_t
}

namespace RnCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
}

namespace RnFace_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnHalfEdge_t {
    constexpr std::ptrdiff_t m_nNext = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_nTwin = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_nOrigin = 0x2; // uint8_t
    constexpr std::ptrdiff_t m_nFace = 0x3; // uint8_t
}

namespace RnHullDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Hull = 0x10; // RnHull_t
}

namespace RnHull_t {
    constexpr std::ptrdiff_t m_vCentroid = 0x0; // Vector
    constexpr std::ptrdiff_t m_flMaxAngularRadius = 0xC; // float
    constexpr std::ptrdiff_t m_Bounds = 0x10; // AABB_t
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x28; // Vector
    constexpr std::ptrdiff_t m_MassProperties = 0x34; // matrix3x4_t
    constexpr std::ptrdiff_t m_flVolume = 0x64; // float
    constexpr std::ptrdiff_t m_Vertices = 0x68; // CUtlVector<RnVertex_t>
    constexpr std::ptrdiff_t m_VertexPositions = 0x80; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Edges = 0x98; // CUtlVector<RnHalfEdge_t>
    constexpr std::ptrdiff_t m_Faces = 0xB0; // CUtlVector<RnFace_t>
    constexpr std::ptrdiff_t m_FacePlanes = 0xC8; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_nFlags = 0xE0; // uint32_t
    constexpr std::ptrdiff_t m_pRegionSVM = 0xE8; // CRegionSVM*
}

namespace RnMeshDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Mesh = 0x10; // RnMesh_t
}

namespace RnMesh_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0xC; // Vector
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<RnNode_t>
    constexpr std::ptrdiff_t m_Vertices = 0x30; // CUtlVectorSIMDPaddedVector
    constexpr std::ptrdiff_t m_Triangles = 0x48; // CUtlVector<RnTriangle_t>
    constexpr std::ptrdiff_t m_Wings = 0x60; // CUtlVector<RnWing_t>
    constexpr std::ptrdiff_t m_Materials = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x90; // Vector
    constexpr std::ptrdiff_t m_nFlags = 0x9C; // uint32_t
    constexpr std::ptrdiff_t m_nDebugFlags = 0xA0; // uint32_t
}

namespace RnNode_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_nChildren = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_vMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_nTriangleOffset = 0x1C; // uint32_t
}

namespace RnPlane_t {
    constexpr std::ptrdiff_t m_vNormal = 0x0; // Vector
    constexpr std::ptrdiff_t m_flOffset = 0xC; // float
}

namespace RnShapeDesc_t {
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nSurfacePropertyIndex = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_UserFriendlyName = 0x8; // CUtlString
}

namespace RnSoftbodyCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_nParticle = 0x1C; // uint16_t[2]
}

namespace RnSoftbodyParticle_t {
    constexpr std::ptrdiff_t m_flMassInv = 0x0; // float
}

namespace RnSoftbodySpring_t {
    constexpr std::ptrdiff_t m_nParticle = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
}

namespace RnSphereDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Sphere = 0x10; // RnSphere_t
}

namespace RnSphere_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
}

namespace RnTriangle_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace RnVertex_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnWing_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace VertexPositionColor_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
}

namespace VertexPositionNormal_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0xC; // Vector
}

namespace constraint_axislimit_t {
    constexpr std::ptrdiff_t flMinRotation = 0x0; // float
    constexpr std::ptrdiff_t flMaxRotation = 0x4; // float
    constexpr std::ptrdiff_t flMotorTargetAngSpeed = 0x8; // float
    constexpr std::ptrdiff_t flMotorMaxTorque = 0xC; // float
}

namespace constraint_breakableparams_t {
    constexpr std::ptrdiff_t strength = 0x0; // float
    constexpr std::ptrdiff_t forceLimit = 0x4; // float
    constexpr std::ptrdiff_t torqueLimit = 0x8; // float
    constexpr std::ptrdiff_t bodyMassScale = 0xC; // float[2]
    constexpr std::ptrdiff_t isActive = 0x14; // bool
}

namespace constraint_hingeparams_t {
    constexpr std::ptrdiff_t worldPosition = 0x0; // Vector
    constexpr std::ptrdiff_t worldAxisDirection = 0xC; // Vector
    constexpr std::ptrdiff_t hingeAxis = 0x18; // constraint_axislimit_t
    constexpr std::ptrdiff_t constraint = 0x28; // constraint_breakableparams_t
}

namespace vphysics_save_cphysicsbody_t { // RnBodyDesc_t
    constexpr std::ptrdiff_t m_nOldPointer = 0xD0; // uint64_t
}
```

`HPCS2/HPCS2/offset/worldrenderer.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:20 +0000
 */

#pragma once

#include <cstddef>

namespace AggregateLODSetup_t {
    constexpr std::ptrdiff_t m_vLODOrigin = 0x0; // Vector
    constexpr std::ptrdiff_t m_fMaxObjectScale = 0xC; // float
    constexpr std::ptrdiff_t m_fSwitchDistances = 0x10; // CUtlVectorFixedGrowable<float>
}

namespace AggregateMeshInfo_t {
    constexpr std::ptrdiff_t m_nVisClusterMemberOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nVisClusterMemberCount = 0x4; // uint8_t
    constexpr std::ptrdiff_t m_bHasTransform = 0x5; // bool
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nLODSetupIndex = 0x8; // int16_t
    constexpr std::ptrdiff_t m_nLODGroupMask = 0xA; // uint8_t
    constexpr std::ptrdiff_t m_vTintColor = 0xB; // Color
    constexpr std::ptrdiff_t m_objectFlags = 0x10; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x14; // int32_t
}

namespace AggregateSceneObject_t {
    constexpr std::ptrdiff_t m_allFlags = 0x0; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_anyFlags = 0x4; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x8; // int16_t
    constexpr std::ptrdiff_t m_aggregateMeshes = 0x10; // CUtlVector<AggregateMeshInfo_t>
    constexpr std::ptrdiff_t m_lodSetups = 0x28; // CUtlVector<AggregateLODSetup_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x40; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_fragmentTransforms = 0x58; // CUtlVector<matrix3x4_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x70; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace BakedLightingInfo_t {
    constexpr std::ptrdiff_t m_nLightmapVersionNumber = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLightmapGameVersionNumber = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_bHasLightmaps = 0x10; // bool
    constexpr std::ptrdiff_t m_lightMaps = 0x18; // CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>
}

namespace BaseSceneObjectOverride_t {
    constexpr std::ptrdiff_t m_nSceneObjectIndex = 0x0; // uint32_t
}

namespace CEntityComponent {
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CVoxelVisibility {
    constexpr std::ptrdiff_t m_nBaseClusterCount = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_nPVSBytesPerCluster = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_vMinBounds = 0x48; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x54; // Vector
    constexpr std::ptrdiff_t m_flGridSize = 0x60; // float
    constexpr std::ptrdiff_t m_nSkyVisibilityCluster = 0x64; // uint32_t
    constexpr std::ptrdiff_t m_nSunVisibilityCluster = 0x68; // uint32_t
    constexpr std::ptrdiff_t m_NodeBlock = 0x6C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_RegionBlock = 0x74; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClusterListBlock = 0x7C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClustersBlock = 0x84; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_MasksBlock = 0x8C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_nVisBlocks = 0x94; // VoxelVisBlockOffset_t
}

namespace ClutterSceneObject_t {
    constexpr std::ptrdiff_t m_Bounds = 0x0; // AABB_t
    constexpr std::ptrdiff_t m_flags = 0x18; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_instancePositions = 0x20; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_instanceScales = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_instanceTintSrgb = 0x68; // CUtlVector<Color>
    constexpr std::ptrdiff_t m_tiles = 0x80; // CUtlVector<ClutterTile_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x98; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace ClutterTile_t {
    constexpr std::ptrdiff_t m_nFirstInstance = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLastInstance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_BoundsWs = 0x8; // AABB_t
}

namespace EntityIOConnectionData_t {
    constexpr std::ptrdiff_t m_outputName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_targetType = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_targetName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_inputName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_overrideParam = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_flDelay = 0x28; // float
    constexpr std::ptrdiff_t m_nTimesToFire = 0x2C; // int32_t
}

namespace EntityKeyValueData_t {
    constexpr std::ptrdiff_t m_connections = 0x8; // CUtlVector<EntityIOConnectionData_t>
    constexpr std::ptrdiff_t m_keyValuesData = 0x20; // CUtlBinaryBlock
}

namespace ExtraVertexStreamOverride_t { // BaseSceneObjectOverride_t
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_nAdditionalMeshDrawPrimitiveFlags = 0xC; // MeshDrawPrimitiveFlags_t
    constexpr std::ptrdiff_t m_extraBufferBinding = 0x10; // CRenderBufferBinding
}

namespace InfoForResourceTypeVMapResourceData_t {
}

namespace InfoOverlayData_t {
    constexpr std::ptrdiff_t m_transform = 0x0; // matrix3x4_t
    constexpr std::ptrdiff_t m_flWidth = 0x30; // float
    constexpr std::ptrdiff_t m_flHeight = 0x34; // float
    constexpr std::ptrdiff_t m_flDepth = 0x38; // float
    constexpr std::ptrdiff_t m_vUVStart = 0x3C; // Vector2D
    constexpr std::ptrdiff_t m_vUVEnd = 0x44; // Vector2D
    constexpr std::ptrdiff_t m_pMaterial = 0x50; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nRenderOrder = 0x58; // int32_t
    constexpr std::ptrdiff_t m_vTintColor = 0x5C; // Vector4D
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x6C; // int32_t
}

namespace MaterialOverride_t { // BaseSceneObjectOverride_t
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace NodeData_t {
    constexpr std::ptrdiff_t m_nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOrigin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vMinBounds = 0x10; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinimumDistance = 0x28; // float
    constexpr std::ptrdiff_t m_ChildNodeIndices = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldNodePrefix = 0x48; // CUtlString
}

namespace PermEntityLumpData_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_hammerUniqueId = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_childLumps = 0x18; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    constexpr std::ptrdiff_t m_entityKeyValues = 0x30; // CUtlLeanVector<EntityKeyValueData_t>
}

namespace SceneObject_t {
    constexpr std::ptrdiff_t m_nObjectID = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vTransform = 0x4; // Vector4D[3]
    constexpr std::ptrdiff_t m_flFadeStartDistance = 0x34; // float
    constexpr std::ptrdiff_t m_flFadeEndDistance = 0x38; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x3C; // Vector4D
    constexpr std::ptrdiff_t m_skin = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_nObjectTypeFlags = 0x58; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_vLightingOrigin = 0x5C; // Vector
    constexpr std::ptrdiff_t m_nOverlayRenderOrder = 0x68; // int16_t
    constexpr std::ptrdiff_t m_nLODOverride = 0x6A; // int16_t
    constexpr std::ptrdiff_t m_nCubeMapPrecomputedHandshake = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x70; // int32_t
    constexpr std::ptrdiff_t m_renderableModel = 0x78; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_renderable = 0x80; // CStrongHandle<InfoForResourceTypeCRenderMesh>
}

namespace VMapResourceData_t {
}

namespace VoxelVisBlockOffset_t {
    constexpr std::ptrdiff_t m_nOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nElementCount = 0x4; // uint32_t
}

namespace WorldBuilderParams_t {
    constexpr std::ptrdiff_t m_flMinDrawVolumeSize = 0x0; // float
    constexpr std::ptrdiff_t m_bBuildBakedLighting = 0x4; // bool
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_nCompileTimestamp = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nCompileFingerprint = 0x18; // uint64_t
}

namespace WorldNodeOnDiskBufferData_t {
    constexpr std::ptrdiff_t m_nElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nElementSizeInBytes = 0x4; // int32_t
    constexpr std::ptrdiff_t m_inputLayoutFields = 0x8; // CUtlVector<RenderInputLayoutField_t>
    constexpr std::ptrdiff_t m_pData = 0x20; // CUtlVector<uint8_t>
}

namespace WorldNode_t {
    constexpr std::ptrdiff_t m_sceneObjects = 0x0; // CUtlVector<SceneObject_t>
    constexpr std::ptrdiff_t m_infoOverlays = 0x18; // CUtlVector<InfoOverlayData_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x30; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_aggregateSceneObjects = 0x48; // CUtlVector<AggregateSceneObject_t>
    constexpr std::ptrdiff_t m_clutterSceneObjects = 0x60; // CUtlVector<ClutterSceneObject_t>
    constexpr std::ptrdiff_t m_extraVertexStreamOverrides = 0x78; // CUtlVector<ExtraVertexStreamOverride_t>
    constexpr std::ptrdiff_t m_materialOverrides = 0x90; // CUtlVector<MaterialOverride_t>
    constexpr std::ptrdiff_t m_extraVertexStreams = 0xA8; // CUtlVector<WorldNodeOnDiskBufferData_t>
    constexpr std::ptrdiff_t m_layerNames = 0xC0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_sceneObjectLayerIndices = 0xD8; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_overlayLayerIndices = 0xF0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_grassFileName = 0x108; // CUtlString
    constexpr std::ptrdiff_t m_nodeLightingInfo = 0x110; // BakedLightingInfo_t
}

namespace World_t {
    constexpr std::ptrdiff_t m_builderParams = 0x0; // WorldBuilderParams_t
    constexpr std::ptrdiff_t m_worldNodes = 0x20; // CUtlVector<NodeData_t>
    constexpr std::ptrdiff_t m_worldLightingInfo = 0x38; // BakedLightingInfo_t
    constexpr std::ptrdiff_t m_entityLumps = 0x68; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
}
```

`HPCS2/HPCS2/x64/Release/HPCS2.Build.CppClean.log`:

```log
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\vc142.pdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\memory.obj
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\source.obj
g:\halfpeoplestudioc++ porject\hpcs2\x64\release\hpcs2.exe
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.ipdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.iobj
g:\halfpeoplestudioc++ porject\hpcs2\x64\release\hpcs2.pdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.command.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.read.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.write.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.command.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.read.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.write.1.tlog

```

`HPCS2/HPCS2/x64/Release/HPCS2.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>G:\HalfPeopleStudioC++ Porject\HPCS2\x64\Release\HPCS2.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`HPCS2/HPCS2/x64/Release/HPCS2.log`:

```log
  Source.cpp
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\memory.hpp(97,1): warning C4267: '引數': 將 'size_t' 轉換為 'ULONG'，資料可能遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(465,84): warning C4312: 'reinterpret_cast': 將 'LONG' 轉換為較大的 'HINSTANCE'
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(571,17): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(570,17): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(569,31): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(568,31): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(578,28): warning C4244: '引數': 將 'const float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(577,31): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(638,120): warning C4244: '引數': 將 'double' 轉換為 'float'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(638,94): warning C4244: '引數': 將 'LONG' 轉換為 'float'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(645,33): warning C4244: '正在初始化': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(652,17): warning C4244: '引數': 將 'const float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(651,17): warning C4244: '引數': 將 'const float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(650,27): warning C4244: '引數': 將 'const float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(649,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(661,24): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(659,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(658,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(670,24): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(668,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(667,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(681,27): warning C4244: '引數': 將 'const float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(680,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(696,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(695,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(709,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(708,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(722,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(721,30): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(762,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(761,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(771,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(770,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(780,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(779,34): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(791,38): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(790,38): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(804,38): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
G:\HalfPeopleStudioC++ Porject\HPCS2\HPCS2\Source.cpp(803,38): warning C4244: '引數': 將 'float' 轉換為 'int'，由於類型不同，可能導致資料遺失
LINK : fatal error LNK1104: 無法開啟檔案 'G:\HalfPeopleStudioC++ Porject\HPCS2\x64\Release\HPCS2.exe'

```

`HPCS2/HPCS2/x64/Release/HPCS2.tlog/CL.command.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /permissive- /Zc:wchar_t /Zc:forScope /Zc:inline /std:c++20 /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC142.PDB" /external:W3 /Gd /TP /FC G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /permissive- /Zc:wchar_t /Zc:forScope /Zc:inline /std:c++20 /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC142.PDB" /external:W3 /Gd /TP /FC G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP

```

`HPCS2/HPCS2/x64/Release/HPCS2.tlog/CL.read.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VECTOR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS_CORE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XKEYCHECK.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XMEMORY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDINT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDLIB.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\FLOAT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLIMITS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CWCHAR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\TYPES.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.INL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISA_AVAILABILITY.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTDDEF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDDEF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTR1COMMON
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INITIALIZER_LIST
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NEW
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCEPTION
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CRTDBG.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW_DEBUG.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CRTDEFS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\USE_ANSI.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MALLOC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_EXCEPTION.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_TERMINATE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XUTILITY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTRING
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UTILITY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCEPTS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMPARE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\BIT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TUPLE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XPOLYMORPHIC_ALLOCATOR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TLHELP32.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STRING
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTRING
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSFWD
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CCTYPE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OSTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCNUM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CMATH
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ITERATOR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STREAMBUF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SHARE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SYSTEM_ERROR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CERRNO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDEXCEPT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XCALL_ONCE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XERRC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ATOMIC
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC_WAIT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTHREADS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTIMEC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\TIME.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCALE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MEMORY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPEINFO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_TYPEINFO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XFACET
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\LOCALE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PSAPI.H
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\HANDLE_HIJACK.HPP
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1028\CLUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\OFFSET\OFFSETS.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDDEF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS_CORE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTR1COMMON
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\OFFSET\CLIENT.DLL.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDLIB.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEAUTO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMUTIL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLECTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OCIDL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MALLOC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPE_TRAITS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDINT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTDDEF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MATH.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INITIALIZER_LIST
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMDEFSP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TLHELP32.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OSTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCNUM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLIMITS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CMATH
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CRTDBG.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW_DEBUG.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CRTDEFS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\USE_ANSI.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.INL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XUTILITY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTRING
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UTILITY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCEPTS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMPARE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\BIT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISA_AVAILABILITY.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\FLOAT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CWCHAR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\TYPES.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ITERATOR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSFWD
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STREAMBUF
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SHARE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SYSTEM_ERROR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CERRNO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDEXCEPT
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCEPTION
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_EXCEPTION.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_TERMINATE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTRING
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XMEMORY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NEW
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TUPLE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XPOLYMORPHIC_ALLOCATOR.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XCALL_ONCE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XERRC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ATOMIC
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC_WAIT.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTHREADS.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTIMEC.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\TIME.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCALE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MEMORY
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPEINFO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_TYPEINFO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XFACET
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CCTYPE
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\LOCALE.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\THREAD
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CHRONO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\RATIO
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_TZDB.HPP
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ALGORITHM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\FORWARD_LIST
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OPTIONAL
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSMF_CONTROL.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SSTREAM
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STRING
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VECTOR
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\PROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STARTUP.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STARTUP.H
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STOP_TOKEN
D:\VS22\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NUMBERS
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.HPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PSAPI.H

```

`HPCS2/HPCS2/x64/Release/HPCS2.tlog/CL.write.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP|G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ

```

`HPCS2/HPCS2/x64/Release/HPCS2.tlog/HPCS2.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v142:VCToolArchitecture=Native32Bit:VCToolsVersion=14.29.30133:VCServicingVersionMFC=14.29.30136:VCServicingVersionCrtHeaders=14.29.30136:TargetPlatformVersion=10.0.19041.0:
Release|x64|G:\HalfPeopleStudioC++ Porject\HPCS2\|

```

`HPCS2/Source.cpp`:

```cpp
//#include "offset/offsets.hpp"
#include "offset/client.dll.hpp"
#include <comdef.h>
#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <iostream>
#include <thread>
#include <cmath>
#include <wtypes.h>
#include <numbers>
#include <map>
#include "memory.hpp"
#include "api/ini.h"
#include <fstream>
#include <nlohmann/json.hpp>
using namespace nlohmann;
int render_distance = -1;
bool show_extra = true;
bool ShowViewAngle = false;
bool ShowAimBotFov = true;
int flag_render_distance = 70;
int ShowBoneDistance = 1000;
int TextSize = 15;
int BoomSize = 100;
#define BonesColor RGB(200, 200, 200)
float FOV = 15;//2
bool DrawESP = true;
bool brecoilControl = true;
bool AimBot = true;
bool AimBotHot = true;
bool AimTeam = false;
bool bTriggerbot = false;
bool bBunnyHop = false;
bool OnlyAttackVisible = true;
bool DrawESPLine = true;
bool MenuDrawBorder = false;
int TriggerDelay_ms = 90;
float AimSmoothing = 2;
int AimBones = 5;

HANDLE cs2_process_handle;
ProcessModule cs2_module_client;
ProcessModule base_engine;

std::shared_ptr<pProcess> process;
struct C_UTL_VECTOR
{
	DWORD_PTR count = 0;
	DWORD_PTR data = 0;
};
namespace render
{
	void DrawBorderBox(HDC hdc, int x, int y, int w, int h, COLORREF borderColor)
	{
		HBRUSH hBorderBrush = CreateSolidBrush(borderColor);
		HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBorderBrush);

		RECT rect = { x, y, x + w, y + h };
		FrameRect(hdc, &rect, hBorderBrush);

		SelectObject(hdc, hOldBrush); // Restore the original brush
		DeleteObject(hBorderBrush);	  // Delete the temporary brush
	}

	void DrawCircle(HDC hdc, int centerX, int centerY, int radius, COLORREF color) {
		HPEN hPen = CreatePen(PS_DASH, 2, color); // 使用红色、宽度为1像素，实线样式的画笔
		SelectObject(hdc, hPen);
		Ellipse(hdc, centerX - radius, centerY - radius, centerX + radius, centerY + radius);
		DeleteObject(hPen);
	}

	void DrawFilledBox(HDC hdc, int x, int y, int width, int height, COLORREF color)
	{
		HBRUSH hBrush = CreateSolidBrush(color);
		RECT rect = { x, y, x + width, y + height };
		FillRect(hdc, &rect, hBrush);
		DeleteObject(hBrush);
	}

	void SetTextSize(HDC hdc, int textSize)
	{
		LOGFONT lf;
		HFONT hFont, hOldFont;

		// Initialize the LOGFONT structure
		ZeroMemory(&lf, sizeof(LOGFONT));
		lf.lfHeight = -textSize;			// Set the desired text height (negative for height)
		lf.lfWeight = FW_NORMAL;			// Set the font weight (e.g., FW_NORMAL for normal)
		lf.lfQuality = ANTIALIASED_QUALITY; // Enable anti-aliasing

		// Create a new font based on the LOGFONT structure
		hFont = CreateFontIndirect(&lf);

		// Select the new font into the device context and save the old font
		hOldFont = (HFONT)SelectObject(hdc, hFont);

		// Clean up the old font (when done using it)
		DeleteObject(hOldFont);
	}

	void RenderLine(HDC hdc, float p1x, float p1y, float p2x, float p2y, COLORREF borderColor)
	{
		HPEN hPen = CreatePen(PS_DASH, 2, borderColor); // 使用红色、宽度为1像素，实线样式的画笔
		SelectObject(hdc, hPen);
		MoveToEx(hdc, (int)p1x, (int)p1y, (LPPOINT)NULL);
		LineTo(hdc, (int)p2x, (int)p2y);
		DeleteObject(hPen);
	}

	void RenderText(HDC hdc, int x, int y, const char* text, COLORREF textColor, int textSize)
	{
		SetTextSize(hdc, textSize);
		SetTextColor(hdc, textColor);

		int len = MultiByteToWideChar(CP_UTF8, 0, text, -1, NULL, 0);
		wchar_t* wide_text = new wchar_t[len];
		MultiByteToWideChar(CP_UTF8, 0, text, -1, wide_text, len);

		TextOutW(hdc, x, y, wide_text, len - 1);

		delete[] wide_text;
	}
}
namespace g {
	inline HDC hdcBuffer = NULL;
	inline HBITMAP hbmBuffer = NULL;

	RECT gameBounds;
}
enum bones : int {
	head = 6,
	neck = 5,
	chest = 4,
	shoulderRight = 8,
	shoulderLeft = 13,
	elbowRight = 9,
	elbowLeft = 14,
	handRight = 11,
	handLeft = 16,
	crotch = 0,
	kneeRight = 23,
	kneeLeft = 26,
	ankleRight = 24,
	ankleLeft = 27,
};

inline namespace boneGroups {
	inline std::vector<int> mid = { bones::head,bones::neck,bones::chest,bones::crotch };
	inline std::vector<int> leftArm = { bones::neck,bones::shoulderLeft,bones::elbowLeft,bones::handLeft };
	inline std::vector<int> righttArm = { bones::neck,bones::shoulderRight,bones::elbowRight,bones::handRight };
	inline std::vector<int> leftLeg = { bones::crotch,bones::kneeLeft,bones::ankleLeft };
	inline std::vector<int> rightLeg = { bones::crotch,bones::kneeRight,bones::ankleRight };
	inline std::map<int, std::string> mid_Name = { {bones::head,"head"}, {bones::neck,"neck"}, {bones::chest,"chest"}, {bones::crotch,"crotch"} };

	inline std::vector<std::vector<int>> allGroups = { mid,leftArm,righttArm,leftLeg,rightLeg };
}
void loop();

void FunctionT();
void USETLOOP()
{
	while (true)
		FunctionT();
}
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_CREATE:
	{
		g::hdcBuffer = CreateCompatibleDC(NULL);
		g::hbmBuffer = CreateCompatibleBitmap(GetDC(hWnd), g::gameBounds.right, g::gameBounds.bottom);
		SelectObject(g::hdcBuffer, g::hbmBuffer);

		SetWindowLong(hWnd, GWL_EXSTYLE, GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_LAYERED);

		SetLayeredWindowAttributes(hWnd, RGB(255, 255, 255), 0, LWA_COLORKEY);

		//std::cout << "[overlay] Window created successfully" << std::endl;
		Beep(500, 100);
		break;
	}
	case WM_ERASEBKGND: // We handle this message to avoid flickering
		return TRUE;
	case WM_PAINT:
	{
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd, &ps);

		//DOUBLE BUFFERING
		FillRect(g::hdcBuffer, &ps.rcPaint, (HBRUSH)GetStockObject(WHITE_BRUSH));

		if (GetForegroundWindow() == process->hwnd_) {
			//render::RenderText(g::hdcBuffer, 10, 10, "cs2 | ESP", RGB(75, 175, 175), 15);
			loop();
		}

		BitBlt(hdc, 0, 0, g::gameBounds.right, g::gameBounds.bottom, g::hdcBuffer, 0, 0, SRCCOPY);

		EndPaint(hWnd, &ps);
		InvalidateRect(hWnd, NULL, TRUE);
		break;
	}
	case WM_DESTROY:
		DeleteDC(g::hdcBuffer);
		DeleteObject(g::hbmBuffer);

		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

struct view_matrix_t {
	float* operator[ ](int index) {
		return matrix[index];
	}

	float matrix[4][4];
};

struct Vector3
{
	// constructor
	constexpr Vector3(
		const float x = 0.f,
		const float y = 0.f,
		const float z = 0.f) noexcept :
		x(x), y(y), z(z) { }

	// operator overloads
	constexpr const Vector3& operator-(const Vector3& other) const noexcept
	{
		return Vector3{ x - other.x, y - other.y, z - other.z };
	}

	constexpr const Vector3& operator+(const Vector3& other) const noexcept
	{
		return Vector3{ x + other.x, y + other.y, z + other.z };
	}

	constexpr const Vector3& operator/(const float factor) const noexcept
	{
		return Vector3{ x / factor, y / factor, z / factor };
	}

	constexpr const Vector3& operator*(const float factor) const noexcept
	{
		return Vector3{ x * factor, y * factor, z * factor };
	}

	constexpr const bool operator>(const Vector3& other) const noexcept {
		return x > other.x && y > other.y && z > other.z;
	}

	constexpr const bool operator>=(const Vector3& other) const noexcept {
		return x >= other.x && y >= other.y && z >= other.z;
	}

	constexpr const bool operator<(const Vector3& other) const noexcept {
		return x < other.x&& y < other.y&& z < other.z;
	}

	constexpr const bool operator<=(const Vector3& other) const noexcept {
		return x <= other.x && y <= other.y && z <= other.z;
	}

	constexpr const Vector3& ToAngle() const noexcept
	{
		return Vector3{
			std::atan2(-z, std::hypot(x, y)) * (180.0f / std::numbers::pi_v<float>),
			std::atan2(y, x) * (180.0f / std::numbers::pi_v<float>),
			0.0f
		};
	}

	void Print()const
	{
		std::cout << "\n x : " << x << "   y :" << y << "z :" << z;
		return;
	}

	constexpr const bool IsZero() const noexcept
	{
		return x == 0.f && y == 0.f && z == 0.f;
	}

	float length() const {
		return std::sqrt(x * x + y * y + z * z);
	}

	float length2d() const {
		return std::sqrt(x * x + y * y);
	}

	Vector3 limit(float limit)
	{
		Vector3 T;
		if (x > limit)//|| In.x < -limit)
		{
			T.x = limit;
		}
		else
		{
			if (x < 0 - limit)
			{
				T.x = -limit;
			}
			else
			{
				T.x = x;
			}
		}

		if (y > limit)//|| In.y < -limit)
		{
			T.y = limit;
		}
		else
		{
			if (y < -limit)
			{
				T.y = 0 - limit;
			}
			else
			{
				T.y = y;
			}
		}

		T.z = z;
		return T;
	}

	Vector3 world_to_screen(view_matrix_t matrix) const {
		float _x = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z + matrix[0][3];
		float _y = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z + matrix[1][3];
		float w = matrix[3][0] * x + matrix[3][1] * y + matrix[3][2] * z + matrix[3][3];

		float inv_w = 1.f / w;
		_x *= inv_w;
		_y *= inv_w;

		float x = g::gameBounds.right * .5f;
		float y = g::gameBounds.bottom * .5f;

		x += 0.5f * _x * g::gameBounds.right + 0.5f;
		y -= 0.5f * _y * g::gameBounds.bottom + 0.5f;

		return { x, y, w };
	}

	float calculate_distance(const Vector3& point) const {
		float dx = point.x - x;
		float dy = point.y - y;
		float dz = point.z - z;

		return std::sqrt(dx * dx + dy * dy + dz * dz);
	}

	// struct data
	float x, y, z;
};

inline constexpr Vector3 CalculateAngle(
	const Vector3& localPosition,
	const Vector3& enemyPosition,
	const Vector3& viewAngles) noexcept
{
	return ((enemyPosition - localPosition).ToAngle() - viewAngles);
};

inline Vector3 clampAngles(Vector3 angles) {
	if (angles.x > 89.0f && angles.x <= 180.0f) {
		angles.x = 89.0f;
	}

	if (angles.x > 180.0f) {
		angles.x -= 360.0f;
	}

	if (angles.x < -89.0f) {
		angles.x = -89.0f;
	}

	if (angles.y > 180.0f) {
		angles.y -= 360.0f;
	}

	if (angles.y < -180.0f) {
		angles.y += 360.0f;
	}
	angles.z = 0;

	return angles;
};

inline Vector3 normalizeAngles(Vector3 angle) {
	while (angle.x > 180.f)
		angle.x -= 360.0f;

	while (angle.x < -180.0f)
		angle.x += 360.0f;

	while (angle.y > 180.0f)
		angle.y -= 360.0f;

	while (angle.y < -180.0f)
		angle.y += 360.0f;

	return angle;
};

inline Vector3 calculateBestAngle(Vector3 angle, float& configFov) {
	Vector3 newAngle = 0;

	float fov = std::hypot(angle.x, angle.y);

	if (fov <= configFov) {
		configFov = fov;
		newAngle = angle;
	}
	return newAngle;
}

uintptr_t TraceAddress(uintptr_t BaseAddress, std::vector<unsigned long> Offsets)
{
	uintptr_t Address = 0;

	if (Offsets.size() == 0)
		return BaseAddress;
	Address = process->read<uintptr_t>(BaseAddress);
	if (!Address)
		return 0;

	for (int i = 0; i < Offsets.size() - 1; i++)
	{
		Address = process->read<uintptr_t>(Address + Offsets[i]);
		if (!Address)
			return 0;
	}
	return Address == 0 ? 0 : Address + Offsets[Offsets.size() - 1];
}

int localTeam;
json Offset;

void Triggerbot()
{
	uintptr_t  player = process->read<uintptr_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwLocalPlayerPawn"]["value"]);//client_dll::dwLocalPlayerPawn);
	unsigned long   iIDEntIndex = process->read<unsigned long >(player + C_CSPlayerPawnBase::m_iIDEntIndex);
	//std::cout << "\n " << iIDEntIndex;
	if (iIDEntIndex == -1)
		return;

	const uintptr_t ListEntry = TraceAddress(cs2_module_client.base +/*client_dll::dwEntityList*/ Offset["client_dll"]["data"]["dwEntityList"]["value"], { 0x8 * (iIDEntIndex >> 9) + 0x10,0x0 });
	if (ListEntry == 0)
		return;

	uintptr_t PawnAddress = process->read<uintptr_t>(ListEntry + 0x78 * (iIDEntIndex & 0x1FF));
	if (!PawnAddress)
		return;

	bool AllowShoot = false;

	//std::cout << "\n " << process->read<int>(PawnAddress + C_BaseEntity::m_iHealth);

	if (!AimTeam)
		AllowShoot = process->read<int>(PawnAddress + C_BaseEntity::m_iTeamNum) != localTeam && process->read<int>(PawnAddress + C_BaseEntity::m_iHealth) > 0;
	else
		AllowShoot = process->read<int>(PawnAddress + C_BaseEntity::m_iHealth) > 0;

	if (!AllowShoot)
		return;

	static std::chrono::time_point LastTimePoint = std::chrono::steady_clock::now();
	auto CurTimePoint = std::chrono::steady_clock::now();
	if (CurTimePoint - LastTimePoint >= std::chrono::milliseconds(TriggerDelay_ms/*ms TriggerDelay*/))
	{
		const bool isAlreadyShooting = GetAsyncKeyState(VK_LBUTTON) < 0;
		if (!isAlreadyShooting)
		{
			mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
			mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
		}

		LastTimePoint = CurTimePoint;
	}

	//mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
	//mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
	return;
}

void Bunnyhop(uintptr_t player)
{
	const bool hasFlagInAir = process->read<int>(player + C_BaseEntity::m_fFlags) & (1 << 0);
	if (GetAsyncKeyState(VK_SPACE) && hasFlagInAir)
	{
		process->write(cs2_module_client.base + Offset["client_dll"]["data"]["dwForceJump"]["value"] /*client_dll::dwForceJump*/, 65537);
	}
	else if (GetAsyncKeyState(VK_SPACE) && !hasFlagInAir)
	{
		process->write(cs2_module_client.base + Offset["client_dll"]["data"]["dwForceJump"]["value"], 256);
		process->write(cs2_module_client.base + Offset["client_dll"]["data"]["dwForceJump"]["value"], 65537);
		process->write(cs2_module_client.base + Offset["client_dll"]["data"]["dwForceJump"]["value"], 256);
	}
	else
	{
		process->write(cs2_module_client.base + Offset["client_dll"]["data"]["dwForceJump"]["value"], 256);
	}
}

Vector3 aimBot(C_UTL_VECTOR aimPunchCache, int getShotsFired, Vector3& cameraPos, float& fov, bool isHot, Vector3 baseViewAngles, uintptr_t boneArray) {
	Vector3 aimPos;
	Vector3 newAngle;

	aimPos = process->read<Vector3>(boneArray + AimBones/*head*/ * 32);
	//aimPos.Print();
	const Vector3 angle = CalculateAngle(cameraPos, aimPos, baseViewAngles);

	newAngle = calculateBestAngle(angle, fov/*fov*/);

	if (newAngle.IsZero()) {
		return 0;
	}

	if (isHot) {
		if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {
			if (brecoilControl)
			{
				Vector3 aimPunchAngle = process->read<Vector3>(aimPunchCache.data + (aimPunchCache.count - 1) * sizeof(Vector3));

				if (getShotsFired > 1) {
					newAngle.x = newAngle.x - aimPunchAngle.x * 2.f;
					newAngle.y = newAngle.y - aimPunchAngle.y * 2.f;
				}
			}

			newAngle = clampAngles(newAngle);
			//if (AimSmoothing != 0)
			//	newAngle = newAngle.limit(AimSmoothing);

			if (AimSmoothing != 0)
				newAngle = newAngle / AimSmoothing;

			if (!newAngle.IsZero())
				return  newAngle + baseViewAngles;//baseViewAngles;
			//Triggerbot();
		}
	}
	else {
		if (getShotsFired > 1) {
			Vector3 aimPunchAngle = process->read<Vector3>(aimPunchCache.data + (aimPunchCache.count - 1) * sizeof(Vector3));
			newAngle.x = newAngle.x - aimPunchAngle.x * 2.f;
			newAngle.y = newAngle.y - aimPunchAngle.y * 2.f;
			//newAngle = clampAngles(newAngle);

			//newAngle.x = newAngle.x / AimSmoothing;//smoothing
			//newAngle.y = newAngle.y / AimSmoothing;//smoothing

			if (AimSmoothing != 0)
				newAngle = newAngle.limit(AimSmoothing);

			return newAngle + baseViewAngles;
		}
	}
	return 0;
}

void recoilControl(Vector3& ViewAngle, C_UTL_VECTOR aimPunchCache, int getShotsFired, DWORD_PTR baseViewAnglesAddy) {
	static Vector3 oldPunch;
	if (getShotsFired > 1) {
		Vector3 aimPunchAngle = process->read<Vector3>(aimPunchCache.data + (aimPunchCache.count - 1) * sizeof(Vector3));
		Vector3 recoilVector = {
			ViewAngle.x + oldPunch.x - aimPunchAngle.x * 2.f,
			ViewAngle.y + oldPunch.y - aimPunchAngle.y * 2.f
		};
		recoilVector = clampAngles(recoilVector);

		oldPunch = aimPunchAngle * 2.f;
		process->write<Vector3>(baseViewAnglesAddy, recoilVector);
	}
	else
		oldPunch = 0;
}

int main(int argc, char* argv[])
{
	SetConsoleTitleW(L"cs2-HalfPeople-esp");

	process = std::make_shared<pProcess>();

	while (!process->AttachProcessHj("cs2.exe"))
		std::this_thread::sleep_for(std::chrono::seconds(1));

	do {
		cs2_module_client = process->GetModule("client.dll");
		base_engine = process->GetModule("engine2.dll");
		if (cs2_module_client.base == 0 || base_engine.base == 0) {
			std::this_thread::sleep_for(std::chrono::seconds(1));
			std::cout << " Failed to find module client.dll/engine2.dll, waiting for the game to load it..." << std::endl;
		}
	} while (cs2_module_client.base == 0 || base_engine.base == 0);

	system("call cs2-dumper.exe -b .json --output offsets -o -v");

	std::ifstream rfileOffset;
	rfileOffset.open("offsets\\offsets.json");
	if (rfileOffset.good())
	{
		std::cout << "\n Read Offsets.json";
		rfileOffset >> Offset;
	}
	else
		std::cout << "\n Read Offsets.json Error";

	rfileOffset.close();

	const uintptr_t buildNumber = process->read<uintptr_t>(base_engine.base + Offset["engine2_dll"]["data"]["dwBuildNumber"]["value"] /*engine2_dll::dwBuildNumber*/);
	std::cout << "\n build number : " << buildNumber;

	std::cout << " Make sure your game is in \"Full Screen Windowed\"" << std::endl;
	while (GetForegroundWindow() != process->hwnd_) {
		std::this_thread::sleep_for(std::chrono::seconds(1));
		process->UpdateHWND();
		ShowWindow(process->hwnd_, TRUE);
	}
	std::cout << "Creating window overlay" << std::endl;

	WNDCLASSEXA wc = { 0 };
	wc.cbSize = sizeof(WNDCLASSEXA);
	wc.lpfnWndProc = WndProc;
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.hbrBackground = WHITE_BRUSH;
	wc.hInstance = reinterpret_cast<HINSTANCE>(GetWindowLongA(process->hwnd_, (-6))); // GWL_HINSTANCE));
	wc.lpszMenuName = " ";
	wc.lpszClassName = " ";

	RegisterClassExA(&wc);

	GetClientRect(process->hwnd_, &g::gameBounds);

	// Create the window
	HINSTANCE hInstance = NULL;
	HWND hWnd = CreateWindowExA(WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW, " ", "cs2-HalfPeople-esp", WS_POPUP,
		g::gameBounds.left, g::gameBounds.top, g::gameBounds.right - g::gameBounds.left, g::gameBounds.bottom + g::gameBounds.left, NULL, NULL, hInstance, NULL); // NULL, NULL);

	if (hWnd == NULL)
		return 0;

	SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
	ShowWindow(hWnd, TRUE);
	//SetActiveWindow(hack::process->hwnd_);
	std::thread T(USETLOOP);
	// Message loop
	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		//std::thread T(FunctionT);
		if (GetAsyncKeyState(VK_END) & 0x8000) break;

		TranslateMessage(&msg);
		DispatchMessage(&msg);

		//T.join();
		//std::this_thread::sleep_for(std::chrono::milliseconds(1));
	}

	DeleteDC(g::hdcBuffer);
	DeleteObject(g::hbmBuffer);

	DestroyWindow(hWnd);

	process->Close();

	system("pause");

	return 0;
}
uintptr_t entity_list;
uintptr_t localpCSPlayerPawn;
uintptr_t localPlayerController;

//Vector3 TEST_CAMEPOS, TEST_CAMEANGLE, TEST_VIEWANGLE;

#define MenuOffset 100
#define MenuItemSelectColor RGB(100,200,200)
#define MenuItemColor RGB(200,200,200)
#define MenuItemMaxIndex 22
#define MenuTitleColor RGB(195,125,255)
int ApplayItem = false;
bool isDrawMenu = false;

void MenuTitle(int& MenuTitleIndexOffset, int index, const char* Text)
{
	render::RenderText(g::hdcBuffer, 0, MenuOffset + 5 + MenuTitleIndexOffset + TextSize * index, Text, MenuTitleColor, TextSize + 5);
	MenuTitleIndexOffset += (TextSize + 15);
}
bool MenuItem(int Offset, int& SelectIndex, int& index, const char* text)
{
	bool R = SelectIndex == index;
	render::RenderText(g::hdcBuffer, 0, MenuOffset + 5 + Offset + TextSize * index, text, (R ? MenuItemSelectColor : MenuItemColor), TextSize);
	index++;
	return R && ApplayItem > 0;
}

void DrawMenu()
{
	int MenuTitleIndexOffset = 0;
	static int MenuSelectIndex = 0;
	int index = 0;
	static int MenuHight = 0;
	if (GetKeyState(VK_UP) & 0x8000)
	{
		if (MenuSelectIndex - 1 < 0)
			MenuSelectIndex = MenuItemMaxIndex;
		MenuSelectIndex--;
		Beep(500, 90);
	}

	if (GetKeyState(VK_DOWN) & 0x8000)
	{
		if (MenuSelectIndex + 1 > MenuItemMaxIndex)
			MenuSelectIndex = 0;
		MenuSelectIndex++;
		Beep(500, 90);
	}
	ApplayItem = 0;
	if (GetKeyState(VK_RIGHT) & 0x8000)
	{
		ApplayItem = 1;

		Beep(600, 90);
	}

	if (GetKeyState(VK_LEFT) & 0x8000)
	{
		ApplayItem = 2;

		Beep(600, 90);
	}

	render::DrawFilledBox(g::hdcBuffer, 0, MenuOffset, TextSize * 15, MenuHight, RGB(0, 0, 0));

	SetBkColor(g::hdcBuffer, RGB(0, 0, 0));

	MenuTitle(MenuTitleIndexOffset, index, "F1 - Hide Menu");
	MenuTitle(MenuTitleIndexOffset, index, "-----Function-----");

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("RecoilControl -> ").append((brecoilControl ? "true" : "false")).c_str()))
	{
		brecoilControl = !brecoilControl;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimBot -> ").append((AimBot ? "true" : "false")).c_str()))
	{
		AimBot = !AimBot;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("Triggerbot -> ").append((bTriggerbot ? "true" : "false")).c_str()))
	{
		bTriggerbot = !bTriggerbot;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("BunnyHop -> ").append((bBunnyHop ? "true" : "false")).c_str()))
	{
		bBunnyHop = !bBunnyHop;
	}

	MenuTitle(MenuTitleIndexOffset, index, "-------ESP-------");

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("Draw ESP -> ").append((DrawESP ? "true" : "false")).c_str()))
	{
		DrawESP = !DrawESP;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("Draw ESP Line -> ").append((DrawESPLine ? "true" : "false")).c_str()))
	{
		DrawESPLine = !DrawESPLine;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("ShowViewAngle -> ").append((ShowViewAngle ? "true" : "false")).c_str()))
	{
		ShowViewAngle = !ShowViewAngle;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("show_extra -> ").append((show_extra ? "true" : "false")).c_str()))
	{
		show_extra = !show_extra;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("TextSize -> ").append(std::to_string(TextSize)).c_str()))
	{
		MenuHight = 0;
		if (ApplayItem == 1)
		{
			TextSize++;
		}
		else
			if (TextSize - 1 > 0)
				TextSize--;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("ShowBoneDistance -> ").append(std::to_string(ShowBoneDistance)).c_str()))
	{
		if (ApplayItem == 1)
		{
			ShowBoneDistance += 10;
		}
		else
			if (ShowBoneDistance - 10 > 0)
				ShowBoneDistance -= 10;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("flag_render_distance -> ").append(std::to_string(flag_render_distance)).c_str()))
	{
		if (ApplayItem == 1)
		{
			flag_render_distance += 10;
		}
		else
			if (flag_render_distance - 10 > 0)
				flag_render_distance -= 10;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("render_distance -> ").append(std::to_string(render_distance)).c_str()))
	{
		if (ApplayItem == 1)
		{
			render_distance += 10;
		}
		else
			if (render_distance - 10 > -1)
				render_distance -= 10;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("Draw Boom MaxSize -> ").append(std::to_string(BoomSize)).c_str()))
	{
		if (ApplayItem == 1)
		{
			BoomSize += 10;
		}
		else
			if (BoomSize - 10 > -1)
				BoomSize -= 10;

		render::DrawFilledBox(
			g::hdcBuffer,
			25,
			25,
			BoomSize,
			BoomSize * 1.4,
			RGB(175, 75, 75)
		);
	}

	MenuTitle(MenuTitleIndexOffset, index, "-----AimBot-----");

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimTeam -> ").append((AimTeam ? "true" : "false")).c_str()))
	{
		AimTeam = !AimTeam;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimBotHot -> ").append((AimBotHot ? "true" : "false")).c_str()))
	{
		AimBotHot = !AimBotHot;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("OnlyAttackVisible -> ").append((OnlyAttackVisible ? "true" : "false")).c_str()))
	{
		OnlyAttackVisible = !OnlyAttackVisible;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimBot FOV -> ").append(std::to_string(FOV)).c_str()))
	{
		if (ApplayItem == 1)
		{
			FOV++;
		}
		else
			if (FOV - 1 > 0)
				FOV -= 1;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimBot Smoothing -> ").append(std::to_string(AimSmoothing)).c_str()))
	{
		if (ApplayItem == 1)
		{
			AimSmoothing += 0.5;
		}
		else
			if (AimSmoothing - 0.5 > 0.5)
				AimSmoothing -= 0.5;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("AimBot AimBone -> ").append(boneGroups::mid_Name.find(AimBones)->second).c_str()))
	{
		if (ApplayItem == 1)
		{
			for (size_t i = 0; i < boneGroups::mid.size(); i++)
			{
				if (boneGroups::mid[i] == AimBones)
				{
					if (i + 1 < boneGroups::mid.size())
					{
						AimBones = boneGroups::mid.at(i + 1);
					}
					else
						AimBones = boneGroups::mid.front();

					i = boneGroups::mid.size();
				}
			}
		}
		else
			if (AimSmoothing - 1 > -1)
				for (size_t i = 0; i < boneGroups::mid.size(); i++)
				{
					if (boneGroups::mid[i] == AimBones)
					{
						if (i - 1 > 0)
						{
							AimBones = boneGroups::mid.at(i - 1);
						}
						else
							AimBones = boneGroups::mid.back();

						i = boneGroups::mid.size();
					}
				}
	}

	MenuTitle(MenuTitleIndexOffset, index, "-----Misc-----");

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("Menu Draw Border -> ").append((MenuDrawBorder ? "true" : "false")).c_str()))
	{
		MenuDrawBorder = !MenuDrawBorder;
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, std::string("TriggerDelay -> ").append(std::to_string(TriggerDelay_ms)).append(" ms").c_str()))
	{
		if (ApplayItem == 1)
		{
			TriggerDelay_ms++;
		}
		else
			if (TriggerDelay_ms - 1 > 0)
				TriggerDelay_ms -= 1;
	} // <<

	MenuTitle(MenuTitleIndexOffset, index, "-----File-----");

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, "Save Setting"))
	{
		// first, create a file instance
		mINI::INIFile file("Configuration.ini");
		mINI::INIStructure ini;
		file.read(ini);
		ini["Function"]["brecoilControl"] = std::to_string(brecoilControl);
		ini["Function"]["AimBot"] = std::to_string(AimBot);
		ini["Function"]["DrawESP"] = std::to_string(DrawESP);
		ini["Function"]["bTriggerbot"] = std::to_string(bTriggerbot);
		ini["Function"]["bBunnyHop"] = std::to_string(bBunnyHop);

		ini["AimBot"]["AimBotHot"] = std::to_string(AimBotHot);
		ini["AimBot"]["AimTeam"] = std::to_string(AimTeam);
		ini["AimBot"]["AimBone"] = std::to_string(AimBones);
		ini["AimBot"]["FOV"] = std::to_string(FOV);
		ini["AimBot"]["Smoothing"] = std::to_string((int)AimSmoothing);
		ini["AimBot"]["OnlyAttackVisible"] = std::to_string(OnlyAttackVisible);

		ini["TriggerBot"]["TriggerDelay"] = std::to_string(TriggerDelay_ms);
		ini["Menu"]["MenuDrawBorder"] = std::to_string(MenuDrawBorder);

		ini["ESP"]["show_extra"] = std::to_string(show_extra);
		ini["ESP"]["ShowViewAngle"] = std::to_string(ShowViewAngle);
		ini["ESP"]["TextSize"] = std::to_string(TextSize);
		ini["ESP"]["ShowBoneDistance"] = std::to_string(ShowBoneDistance);
		ini["ESP"]["flag_render_distance"] = std::to_string(flag_render_distance);
		ini["ESP"]["render_distance"] = std::to_string(render_distance);
		ini["ESP"]["BoomSize"] = std::to_string(BoomSize);
		ini["ESP"]["DrawESPLine"] = std::to_string(DrawESPLine);
		std::cout << "\n Save :" << file.write(ini);
	}

	if (MenuItem(MenuTitleIndexOffset, MenuSelectIndex, index, "Load Setting"))
	{
		mINI::INIFile file("Configuration.ini");
		mINI::INIStructure ini;
		std::cout << "\n Load :" << file.read(ini);
		brecoilControl = atoi(ini["Function"]["brecoilControl"].c_str());
		AimBot = atoi(ini["Function"]["AimBot"].c_str());
		DrawESP = atoi(ini["Function"]["DrawESP"].c_str());
		bTriggerbot = atoi(ini["Function"]["bTriggerbot"].c_str());
		bBunnyHop = atoi(ini["Function"]["bBunnyHop"].c_str());

		AimTeam = atoi(ini["AimBot"]["AimTeam"].c_str());
		AimBotHot = atoi(ini["AimBot"]["AimBotHot"].c_str());
		FOV = atof(ini["AimBot"]["FOV"].c_str());
		AimSmoothing = atoi(ini["AimBot"]["Smoothing"].c_str());
		AimBones = atoi(ini["AimBot"]["AimBone"].c_str());
		OnlyAttackVisible = atoi(ini["AimBot"]["OnlyAttackVisible"].c_str());

		TriggerDelay_ms = atoi(ini["TriggerBot"]["TriggerDelay"].c_str());

		MenuDrawBorder = atoi(ini["Menu"]["MenuDrawBorder"].c_str());

		show_extra = atoi(ini["ESP"]["show_extra"].c_str());
		TextSize = atoi(ini["ESP"]["TextSize"].c_str());
		ShowViewAngle = atoi(ini["ESP"]["ShowViewAngle"].c_str());
		ShowBoneDistance = atoi(ini["ESP"]["ShowBoneDistance"].c_str());
		flag_render_distance = atoi(ini["ESP"]["flag_render_distance"].c_str());
		render_distance = atoi(ini["ESP"]["render_distance"].c_str());
		BoomSize = atoi(ini["ESP"]["BoomSize"].c_str());
		DrawESPLine = atoi(ini["ESP"]["DrawESPLine"].c_str());
	}

	if (MenuHight == 0)
		MenuHight = MenuTitleIndexOffset + (index + 1) * TextSize;

	SetBkColor(g::hdcBuffer, RGB(255, 255, 255));
}

void DrawAimBotFOV(float Fov)
{
	float Radius = tan(FOV / 180.f * std::numbers::pi_v<float> / 2.f) / tan(Fov / 180.f * std::numbers::pi_v<float> / 2.f) * g::gameBounds.right;
	render::DrawCircle(g::hdcBuffer, g::gameBounds.right / 2, g::gameBounds.bottom / 2, Radius, RGB(134, 133, 218));

	float Length;
	float radian;
	Vector3 LineEndPoint[2];
	Vector3 Pos;// = Gui.Window.Size / 2;
	Pos.x = g::gameBounds.right / 2;
	Pos.y = g::gameBounds.bottom / 2;

	radian = (Fov / 2) * std::numbers::pi_v<float> / 180;

	LineEndPoint[0].y = Pos.y - 60/*FovLineSize */;
	LineEndPoint[1].y = LineEndPoint[0].y;

	Length = 60/*FovLineSize */ * tan(radian);

	LineEndPoint[0].x = Pos.x - Length;
	LineEndPoint[1].x = Pos.x + Length;

	//Gui.Line(Pos, LineEndPoint[0], Color, 1.5);
	//Gui.Line(Pos, LineEndPoint[1], Color, 1.5);

	render::RenderLine(g::hdcBuffer, Pos.x, Pos.y, LineEndPoint[0].x, LineEndPoint[0].y, RGB(134, 133, 218));
	render::RenderLine(g::hdcBuffer, Pos.x, Pos.y, LineEndPoint[1].x, LineEndPoint[1].y, RGB(134, 133, 218));
}

void loop()
{
	static int indirectUpdate = 0;
	static uintptr_t localPlayer;
	if (GetKeyState(VK_F1) & 0x8000)
	{
		Sleep(100);
		isDrawMenu = !isDrawMenu;
	}
	if (isDrawMenu)
		DrawMenu();
	else
		render::RenderText(g::hdcBuffer, 0, MenuOffset, "F1 - Show Menu", RGB(200, 200, 200), TextSize);

	//render::RenderText(g::hdcBuffer, 0, MenuOffset + 500, std::string("TEST_CAMEPOS : ").append(std::to_string(TEST_CAMEPOS.x)).append(",").append(std::to_string(TEST_CAMEPOS.y)).append(",").append(std::to_string(TEST_CAMEPOS.z)).c_str(), RGB(200, 0, 0), TextSize);
	//render::RenderText(g::hdcBuffer, 0, MenuOffset + 500 + TextSize, std::string("TEST_CAMEANGLE : ").append(std::to_string(TEST_CAMEANGLE.x)).append(",").append(std::to_string(TEST_CAMEANGLE.y)).append(",").append(std::to_string(TEST_CAMEANGLE.z)).c_str(), RGB(200, 0, 0), TextSize);
	//render::RenderText(g::hdcBuffer, 0, MenuOffset + 500 + TextSize * 2, std::string("TEST_VIEWANGLE : ").append(std::to_string(TEST_VIEWANGLE.x)).append(",").append(std::to_string(TEST_VIEWANGLE.y)).append(",").append(std::to_string(TEST_VIEWANGLE.z)).c_str(), RGB(200, 0, 0), TextSize);
	//localPlayerController = process->read<uintptr_t>(cs2_module_client.base + client_dll::dwLocalPlayerController);

	static float PlayerFov;
	if (indirectUpdate == 0)
	{
		indirectUpdate++;
		entity_list = process->read<uintptr_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwEntityList"]["value"] /*client_dll::dwEntityList*/);

		//localPlayer = process->read<uintptr_t>(localPlayerController + CCSPlayerController::m_hPlayerPawn);
		localPlayer = process->read<uintptr_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwLocalPlayerPawn"]["value"] /*client_dll::dwLocalPlayerPawn*/);
		if (!localPlayer)
			return;

		localTeam = process->read<int>(localPlayer + C_BaseEntity::m_iTeamNum);

		if (ShowAimBotFov)
		{
			const DWORD64 CameraServices = process->read<DWORD64>(localPlayer + C_BasePlayerPawn::m_pCameraServices);
			if (CameraServices)
				PlayerFov = process->read<int>(CameraServices + CCSPlayerBase_CameraServices::m_iFOVStart);
		}
	}
	else if (indirectUpdate > 10)
	{
		indirectUpdate = 0;
	}
	else
	{
		indirectUpdate++;
	}

	if (ShowAimBotFov)
		DrawAimBotFOV(PlayerFov);

	if (!DrawESP)
		return;
	const view_matrix_t view_matrix = process->read<view_matrix_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwViewMatrix"]["value"] /*client_dll::dwViewMatrix*/);

	int playerIndex = 0;
	uintptr_t list_entry;

	static uintptr_t localCGameSceneNode;
	static bool c4IsPlanted;
	if (indirectUpdate == 0)
	{
		localCGameSceneNode = process->read<uintptr_t>(localPlayer + C_BaseEntity::m_pGameSceneNode);
		c4IsPlanted = process->read<bool>(cs2_module_client.base + Offset["client_dll"]["data"]["dwPlantedC4"]["value"] /*client_dll::dwPlantedC4*/ - 0x8);
	}

	const Vector3 localOrigin = process->read<Vector3>(localCGameSceneNode + CGameSceneNode::m_vecOrigin);

	render::RenderText(g::hdcBuffer, 50, 50, "HalfPeople CSGO 2 GameHack Test", RGB(200, 200, 200), 30);
	if (c4IsPlanted)
	{
		const uintptr_t planted_c4 = process->read<uintptr_t>(process->read<uintptr_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwPlantedC4"]["value"] /*client_dll::dwPlantedC4*/));

		const uintptr_t c4Node = process->read<uintptr_t>(planted_c4 + C_BaseEntity::m_pGameSceneNode);

		const Vector3 c4Origin = process->read<Vector3>(c4Node + CGameSceneNode::m_vecAbsOrigin);

		const Vector3 c4ScreenPos = c4Origin.world_to_screen(view_matrix);

		if (c4ScreenPos.z >= 0.01f) {
			float c4Distance = localOrigin.calculate_distance(c4Origin);
			float c4RoundedDistance = std::round(c4Distance / 500.f);

			float height = BoomSize - c4RoundedDistance;
			float width = height * 1.4f;

			if (DrawESPLine)
				render::RenderLine(g::hdcBuffer, 0, 0, c4ScreenPos.x, c4ScreenPos.y, RGB(175, 75, 75));

			render::DrawFilledBox(
				g::hdcBuffer,
				c4ScreenPos.x - (width / 2),
				c4ScreenPos.y - (height / 2),
				width,
				height,
				RGB(175, 75, 75)
			);

			render::RenderText(
				g::hdcBuffer,
				c4ScreenPos.x + (width / 2 + 5),
				c4ScreenPos.y,
				"C4",
				RGB(75, 75, 175),
				TextSize
			);
		}
	}
	while (true)
	{
		playerIndex++;
		list_entry = process->read<uintptr_t>(entity_list + (8 * (playerIndex & 0x7FFF) >> 9) + 16);
		if (!list_entry)
			break;

		const uintptr_t player = process->read<uintptr_t>(list_entry + 120 * (playerIndex & 0x1FF));
		if (!player)
			continue;

		const int playerTeam = process->read<int>(player + C_BaseEntity::m_iTeamNum);

		const std::uint32_t playerPawn = process->read<std::uint32_t>(player + CCSPlayerController::m_hPlayerPawn);

		const uintptr_t list_entry2 = process->read<uintptr_t>(entity_list + 0x8 * ((playerPawn & 0x7FFF) >> 9) + 16);
		if (!list_entry2)
			continue;

		const uintptr_t pCSPlayerPawn = process->read<uintptr_t>(list_entry2 + 120 * (playerPawn & 0x1FF));

		const int playerArmor = process->read<int>(pCSPlayerPawn + C_CSPlayerPawnBase::m_ArmorValue);
		const int playerHealth = process->read<int>(pCSPlayerPawn + C_BaseEntity::m_iHealth);
		if (playerHealth <= 0 || playerHealth > 100)
			continue;

		if (pCSPlayerPawn == localPlayer)
			continue;

		std::string playerName = "Invalid Name";
		const DWORD64 playerNameAddress = process->read<DWORD64>(player + CCSPlayerController::m_sSanitizedPlayerName);
		if (playerNameAddress) {
			char buf[256];
			process->read_raw(playerNameAddress, buf, sizeof(buf));
			playerName = std::string(buf);
		}

		const uintptr_t CGameSceneNode = process->read<uintptr_t>(pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
		const Vector3 origin = process->read<Vector3>(CGameSceneNode + CGameSceneNode::m_vecOrigin);
		const Vector3 head = { origin.x, origin.y, origin.z + 75.f };

		if (render_distance != -1 && (localOrigin - origin).length2d() > render_distance)
			continue;

		const Vector3 screenPos = origin.world_to_screen(view_matrix);
		if (screenPos.z < 0)
			continue;
		const Vector3 screenHead = head.world_to_screen(view_matrix);

		if (screenPos.z >= 0.01f) {
			const float height = screenPos.y - screenHead.y;
			const float width = height / 2.4f;
			const float head_height = (screenPos.y - screenHead.y) / 8;
			const float head_width = (height / 2.4f) / 4;

			float distance = localOrigin.calculate_distance(origin);
			int roundedDistance = std::round(distance / 10.f);

			render::DrawBorderBox(
				g::hdcBuffer,
				screenHead.x - width / 2,
				screenHead.y,
				width,
				height,
				(localTeam == playerTeam ? RGB(75, 175, 75) : RGB(175, 75, 75))
			);
			if (DrawESPLine)
				render::RenderLine(g::hdcBuffer, screenHead.x, screenHead.y + height, g::gameBounds.right / 2, g::gameBounds.bottom * 0.8, (localTeam == playerTeam ? RGB(75, 175, 75) : RGB(175, 75, 75)));

			render::DrawBorderBox(
				g::hdcBuffer,
				screenHead.x - (width / 2 + 10),
				screenHead.y + (height * (100 - playerArmor) / 100),
				2,
				height - (height * (100 - playerArmor) / 100),
				RGB(0, 185, 255)
			);

			render::DrawBorderBox(
				g::hdcBuffer,
				screenHead.x - (width / 2 + 5),
				screenHead.y + (height * (100 - playerHealth) / 100),
				2,
				height - (height * (100 - playerHealth) / 100),
				RGB(
					(255 - playerHealth),
					(55 + playerHealth * 2),
					75
				)
			);

			render::RenderText(
				g::hdcBuffer,
				screenHead.x + (width / 2 + 5),
				screenHead.y,
				playerName.c_str(),
				RGB(75, 75, 175),
				TextSize
			);

			/**
			* I know is not the best way but a simple way to not saturate the screen with a ton of information
			*/
			if (roundedDistance > flag_render_distance)
				continue;

			render::RenderText(
				g::hdcBuffer,
				screenHead.x + (width / 2 + 5),
				screenHead.y + TextSize,
				(std::to_string(playerHealth) + "hp").c_str(),
				RGB(
					(255 - playerHealth),
					(55 + playerHealth * 2),
					75
				),
				TextSize
			);

			render::RenderText(
				g::hdcBuffer,
				screenHead.x + (width / 2 + 5),
				screenHead.y + TextSize * 2,
				(std::to_string(playerArmor) + "armor").c_str(),
				RGB(
					(255 - playerArmor),
					(55 + playerArmor * 2),
					75
				),
				TextSize
			);

			render::RenderText(
				g::hdcBuffer,
				screenHead.x + (width / 2 + 5),
				screenHead.y + TextSize * 8,
				(std::to_string((int)distance) + "cm").c_str(),
				RGB(
					(255 - playerArmor),
					(55 + playerArmor * 2),
					75
				),
				TextSize
			);

			if (show_extra)
			{
				/*
				* Reading values for extra flags is now seperated from the other reads
				* This removes unnecessary memory reads, improving performance when not showing extra flags
				*/
				const bool isDefusing = process->read<bool>(pCSPlayerPawn + C_CSPlayerPawnBase::m_bIsDefusing);
				const uintptr_t playerMoneyServices = process->read<uintptr_t>(player + CCSPlayerController::m_pInGameMoneyServices);
				const int32_t money = process->read<int32_t>(playerMoneyServices + CCSPlayerController_InGameMoneyServices::m_iAccount);
				const float flashAlpha = process->read<float>(pCSPlayerPawn + C_CSPlayerPawnBase::m_flFlashOverlayAlpha);

				const auto clippingWeapon = process->read<std::uint64_t>(pCSPlayerPawn + C_CSPlayerPawnBase::m_pClippingWeapon);
				const auto weaponData = process->read<std::uint64_t>(clippingWeapon + 0x360);
				const auto weaponNameAddress = process->read<std::uint64_t>(weaponData + CCSWeaponBaseVData::m_szName);
				std::string weaponName = "Invalid Weapon Name";

				if (!weaponNameAddress) {
					weaponName = "Invalid Weapon Name";
				}
				else {
					char buf[32];
					process->read_raw(weaponNameAddress, buf, sizeof(buf));
					weaponName = std::string(buf);
					if (weaponName.compare(0, 7, "weapon_") == 0)
						weaponName = weaponName.substr(7, weaponName.length()); // Remove weapon_ prefix
				}

				render::RenderText(
					g::hdcBuffer,
					screenHead.x + (width / 2 + 5),
					screenHead.y + TextSize * 3,
					weaponName.c_str(),
					RGB(75, 75, 175),
					TextSize
				);

				render::RenderText(
					g::hdcBuffer,
					screenHead.x + (width / 2 + 5),
					screenHead.y + TextSize * 4,
					(std::to_string(roundedDistance) + "m away").c_str(),
					RGB(75, 75, 175),
					TextSize
				);

				render::RenderText(
					g::hdcBuffer,
					screenHead.x + (width / 2 + 5),
					screenHead.y + TextSize * 5,
					("$" + std::to_string(money)).c_str(),
					RGB(0, 125, 0),
					TextSize
				);

				if (flashAlpha > 100)
				{
					render::RenderText(
						g::hdcBuffer,
						screenHead.x + (width / 2 + 5),
						screenHead.y + TextSize * 6,
						"Player is flashed",
						RGB(75, 75, 175),
						TextSize
					);
				}

				if (isDefusing)
				{
					const std::string defuText = "Player is defusing";
					render::RenderText(
						g::hdcBuffer,
						screenHead.x + (width / 2 + 5),
						screenHead.y + 60,
						defuText.c_str(),
						RGB(75, 75, 175),
						TextSize
					);
				}
			}

			if (distance > ShowBoneDistance)
			{
				continue;
			}

			// const uintptr_t CGameSceneNode = process->read<uintptr_t>( pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
			const uintptr_t boneArray = process->read<uintptr_t>(CGameSceneNode + CSkeletonInstance::m_modelState + CGameSceneNode::m_vecOrigin);

			Vector3 head_ = process->read<Vector3>(boneArray + 6 * 32);
			Vector3 cou = process->read<Vector3>(boneArray + 5 * 32);
			Vector3 shoulderR = process->read<Vector3>(boneArray + 8 * 32);
			Vector3 shoulderL = process->read<Vector3>(boneArray + 13 * 32);
			Vector3 brasR = process->read<Vector3>(boneArray + 9 * 32);
			Vector3 brasL = process->read<Vector3>(boneArray + 14 * 32);
			Vector3 handR = process->read<Vector3>(boneArray + 11 * 32);
			Vector3 handL = process->read<Vector3>(boneArray + 16 * 32);
			Vector3 cock = process->read<Vector3>(boneArray + 0 * 32);
			Vector3 kneesR = process->read<Vector3>(boneArray + 23 * 32);
			Vector3 kneesL = process->read<Vector3>(boneArray + 26 * 32);
			Vector3 feetR = process->read<Vector3>(boneArray + 24 * 32);
			Vector3 feetL = process->read<Vector3>(boneArray + 27 * 32);

			Vector3 Ahead;
			Vector3 Acou;
			Vector3 AshoulderR;
			Vector3 AshoulderL;
			Vector3 AbrasR;
			Vector3 AbrasL;
			Vector3 AhandR;
			Vector3 AhandL;
			Vector3 Acock;
			Vector3 AkneesR;
			Vector3 AkneesL;
			Vector3 AfeetR;
			Vector3 AfeetL;

			Ahead = head_.world_to_screen(view_matrix);
			if (Ahead.z < 0)
				continue;

			if (ShowViewAngle)
			{
				Vector3 EyeAngle = process->read<Vector3>(player + C_CSPlayerPawnBase::m_angEyeAngles);
				//Vec2 StartPoint, EndPoint;
				Vector3 Temp;

				//StartPoint = head_;

				float LineLength = cos(EyeAngle.x * std::numbers::pi_v<float> / 180) * 25/*Length*/;

				Temp.x = head_.x + cos(EyeAngle.y * std::numbers::pi_v<float> / 180) * LineLength;
				Temp.y = head_.y + sin(EyeAngle.y * std::numbers::pi_v<float> / 180) * LineLength;
				Temp.z = head_.z - sin(EyeAngle.x * std::numbers::pi_v<float> / 180) * 25/*Length*/;

				Temp = Temp.world_to_screen(view_matrix);
				if (Temp.z > 0)
					render::RenderLine(g::hdcBuffer, Ahead.x, Ahead.y, Temp.x, Temp.y, RGB(0, 255, 0));
			}

			Acou = cou.world_to_screen(view_matrix);
			if (Acou.z < 0)
				continue;
			AshoulderR = shoulderR.world_to_screen(view_matrix);
			if (AshoulderR.z < 0)
				continue;
			AshoulderL = shoulderL.world_to_screen(view_matrix);
			if (AshoulderL.z < 0)
				continue;
			AbrasR = brasR.world_to_screen(view_matrix);
			if (AbrasR.z < 0)
				continue;
			AbrasL = brasL.world_to_screen(view_matrix);
			if (AbrasL.z < 0)
				continue;
			AhandL = handL.world_to_screen(view_matrix);
			if (AhandL.z < 0)
				continue;
			AhandR = handR.world_to_screen(view_matrix);
			if (AhandR.z < 0)
				continue;
			Acock = cock.world_to_screen(view_matrix);
			if (Acock.z < 0)
				continue;
			AkneesR = kneesR.world_to_screen(view_matrix);
			if (AkneesR.z < 0)
				continue;
			AkneesL = kneesL.world_to_screen(view_matrix);
			if (AkneesL.z < 0)
				continue;
			AfeetR = feetR.world_to_screen(view_matrix);
			if (AfeetR.z < 0)
				continue;
			AfeetL = feetL.world_to_screen(view_matrix);
			if (AfeetL.z < 0)
				continue;

			render::RenderLine(g::hdcBuffer, Ahead.x, Ahead.y, Acou.x, Acou.y, BonesColor);
			render::RenderLine(g::hdcBuffer, Acou.x, Acou.y, AshoulderR.x, AshoulderR.y, BonesColor);
			render::RenderLine(g::hdcBuffer, Acou.x, Acou.y, AshoulderL.x, AshoulderL.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AbrasL.x, AbrasL.y, AshoulderL.x, AshoulderL.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AbrasR.x, AbrasR.y, AshoulderR.x, AshoulderR.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AbrasR.x, AbrasR.y, AhandR.x, AhandR.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AbrasL.x, AbrasL.y, AhandL.x, AhandL.y, BonesColor);
			render::RenderLine(g::hdcBuffer, Acou.x, Acou.y, Acock.x, Acock.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AkneesR.x, AkneesR.y, Acock.x, Acock.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AkneesL.x, AkneesL.y, Acock.x, Acock.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AkneesL.x, AkneesL.y, AfeetL.x, AfeetL.y, BonesColor);
			render::RenderLine(g::hdcBuffer, AkneesR.x, AkneesR.y, AfeetR.x, AfeetR.y, BonesColor);

			// Vector3 previous, current;
			//
			//
			// for (std::vector<int> currentGroup : boneGroups::allGroups) {
			//     previous = { 0,0,0 };
			//
			//     for (int currentBone : currentGroup) {
			//         current = process->read<Vector3>(boneArray + currentBone * 32);
			//
			//         if (previous.IsZero()) {
			//             previous = current;
			//             continue;
			//         }
			//
			//         Vector3 currentScreenPos = current.world_to_screen(view_matrix);
			//         Vector3 previousScreenPos = previous.world_to_screen(view_matrix);
			//
			//
			//        render::RenderLine(g::hdcBuffer, previousScreenPos.x, previousScreenPos.y, currentScreenPos.x, currentScreenPos.y, BonesColor);
			//
			//         previous = current;
			//     }
			// }
		}
	}
}

void FunctionT()
{
	if (bTriggerbot)
		Triggerbot();

	static int indirectUpdate = 0;
	static uintptr_t localPlayer;
	//if (!(brecoilControl || AimBot || entity_list || localPlayer))
	//{
	//	std::cout << "\n brecoilControl : " << brecoilControl;
	//	std::cout << "\n AimBot : " << AimBot;
	//	std::cout << "\n entity_list : " << entity_list;
	//	std::cout << "\n localPlayer : " << localPlayer;
	//	return;
	//}

	int playerIndex = -1;
	uintptr_t list_entry;
	static uintptr_t baseViewAnglesAddy;
	if (indirectUpdate == 0)
	{
		indirectUpdate++;
		localPlayer = process->read<uintptr_t>(cs2_module_client.base + Offset["client_dll"]["data"]["dwLocalPlayerPawn"]["value"] /*client_dll::dwLocalPlayerPawn*/);
		//std::cout << "\n " << process->read<int>(localPlayer + C_BaseEntity::m_iHealth);

		baseViewAnglesAddy = cs2_module_client.base + Offset["client_dll"]["data"]["dwViewAngles"]["value"] /*client_dll::dwViewAngles*/;
	}
	else if (indirectUpdate > 20)
		indirectUpdate = 0;
	else
		indirectUpdate++;

	if (bBunnyHop)
		Bunnyhop(localPlayer);

	Vector3 cameraPos = process->read<Vector3>(localPlayer + C_CSPlayerPawnBase::m_vecLastClipCameraPos);

	Vector3 baseViewAngles = process->read<Vector3>(cs2_module_client.base + Offset["client_dll"]["data"]["dwViewAngles"]["value"] /*client_dll::dwViewAngles*/);

	C_UTL_VECTOR aimPunchCache = process->read<C_UTL_VECTOR>(localPlayer + C_CSPlayerPawn::m_aimPunchCache);

	int shotsFired = process->read<int>(localPlayer + C_CSPlayerPawnBase::m_iShotsFired);

	float fov = FOV;

	Vector3 AimTarget;
	while (true)
	{
		playerIndex++;

		list_entry = process->read<uintptr_t>(entity_list + (8 * (playerIndex & 0x7FFF) >> 9) + 16);
		if (!list_entry)
			break;

		const uintptr_t player = process->read<uintptr_t>(list_entry + 120 * (playerIndex & 0x1FF));
		if (!player)
			continue;

		const int playerTeam = process->read<int>(player + C_BaseEntity::m_iTeamNum);
		if ((!AimTeam) && playerTeam == localTeam)
		{
			continue;
		}

		const std::uint32_t playerPawn = process->read<std::uint32_t>(player + CCSPlayerController::m_hPlayerPawn);

		const uintptr_t list_entry2 = process->read<uintptr_t>(entity_list + 0x8 * ((playerPawn & 0x7FFF) >> 9) + 16);
		if (!list_entry2)
			continue;

		const uintptr_t pCSPlayerPawn = process->read<uintptr_t>(list_entry2 + 120 * (playerPawn & 0x1FF));
		if ((!pCSPlayerPawn) || pCSPlayerPawn == localPlayer)
			continue;

		if (process->read<int>(player + C_BaseEntity::m_lifeState))
			continue;

		const uintptr_t CGameSceneNode = process->read<uintptr_t>(pCSPlayerPawn + C_BaseEntity::m_pGameSceneNode);
		if (process->read<bool>(CGameSceneNode + CGameSceneNode::m_bDormant))
			return;

		const int playerHealth = process->read<int>(pCSPlayerPawn + C_BaseEntity::m_iHealth);
		if (playerHealth <= 0 || playerHealth > 100)
			continue;

		if (OnlyAttackVisible)
		{
			const int EntitySpottedState = process->read<DWORD_PTR>(pCSPlayerPawn + C_CSPlayerPawnBase::m_entitySpottedState + EntitySpottedState_t::m_bSpottedByMask);
			if (!(EntitySpottedState & (1 << localPlayer)))
				continue;
		}

		const uintptr_t boneArray = process->read<uintptr_t>(CGameSceneNode + CSkeletonInstance::m_modelState + CGameSceneNode::m_vecOrigin);

		if (AimBot)
		{
			Vector3 AimTargteBuffer = aimBot(aimPunchCache, shotsFired, cameraPos, fov, AimBotHot, baseViewAngles, boneArray);

			if (!AimTargteBuffer.IsZero())
			{
				AimTarget = AimTargteBuffer;
			}
		}
	}
	if (brecoilControl && AimTarget.IsZero())
	{
		recoilControl(baseViewAngles, aimPunchCache, shotsFired, baseViewAnglesAddy);
	}
	else if (!AimTarget.IsZero())
		process->write(baseViewAnglesAddy, AimTarget);
}
```

`HPCS2/api/ini.h`:

```h
/*
 * The MIT License (MIT)
 * Copyright (c) 2018 Danijel Durakovic
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

///////////////////////////////////////////////////////////////////////////////
//
//  /mINI/ v0.9.14
//  An INI file reader and writer for the modern age.
//
///////////////////////////////////////////////////////////////////////////////
//
//  A tiny utility library for manipulating INI files with a straightforward
//  API and a minimal footprint. It conforms to the (somewhat) standard INI
//  format - sections and keys are case insensitive and all leading and
//  trailing whitespace is ignored. Comments are lines that begin with a
//  semicolon. Trailing comments are allowed on section lines.
//
//  Files are read on demand, upon which data is kept in memory and the file
//  is closed. This utility supports lazy writing, which only writes changes
//  and updates to a file and preserves custom formatting and comments. A lazy
//  write invoked by a write() call will read the output file, find what
//  changes have been made and update the file accordingly. If you only need to
//  generate files, use generate() instead. Section and key order is preserved
//  on read, write and insert.
//
///////////////////////////////////////////////////////////////////////////////
//
//  /* BASIC USAGE EXAMPLE: */
//
//  /* read from file */
//  mINI::INIFile file("myfile.ini");
//  mINI::INIStructure ini;
//  file.read(ini);
//
//  /* read value; gets a reference to actual value in the structure.
//     if key or section don't exist, a new empty value will be created */
//  std::string& value = ini["section"]["key"];
//
//  /* read value safely; gets a copy of value in the structure.
//     does not alter the structure */
//  std::string value = ini.get("section").get("key");
//
//  /* set or update values */
//  ini["section"]["key"] = "value";
//
//  /* set multiple values */
//  ini["section2"].set({
//      {"key1", "value1"},
//      {"key2", "value2"}
//  });
//
//  /* write updates back to file, preserving comments and formatting */
//  file.write(ini);
//
//  /* or generate a file (overwrites the original) */
//  file.generate(ini);
//
///////////////////////////////////////////////////////////////////////////////
//
//  Long live the INI file!!!
//
///////////////////////////////////////////////////////////////////////////////

#ifndef MINI_INI_H_
#define MINI_INI_H_

#include <string>
#include <sstream>
#include <algorithm>
#include <utility>
#include <unordered_map>
#include <vector>
#include <memory>
#include <fstream>
#include <sys/stat.h>
#include <cctype>

namespace mINI
{
	namespace INIStringUtil
	{
		const char* const whitespaceDelimiters = " \t\n\r\f\v";
		inline void trim(std::string& str)
		{
			str.erase(str.find_last_not_of(whitespaceDelimiters) + 1);
			str.erase(0, str.find_first_not_of(whitespaceDelimiters));
		}
#ifndef MINI_CASE_SENSITIVE
		inline void toLower(std::string& str)
		{
			std::transform(str.begin(), str.end(), str.begin(), [](const char c) {
				return static_cast<char>(std::tolower(c));
			});
		}
#endif
		inline void replace(std::string& str, std::string const& a, std::string const& b)
		{
			if (!a.empty())
			{
				std::size_t pos = 0;
				while ((pos = str.find(a, pos)) != std::string::npos)
				{
					str.replace(pos, a.size(), b);
					pos += b.size();
				}
			}
		}
#ifdef _WIN32
		const char* const endl = "\r\n";
#else
		const char* const endl = "\n";
#endif
	}

	template<typename T>
	class INIMap
	{
	private:
		using T_DataIndexMap = std::unordered_map<std::string, std::size_t>;
		using T_DataItem = std::pair<std::string, T>;
		using T_DataContainer = std::vector<T_DataItem>;
		using T_MultiArgs = typename std::vector<std::pair<std::string, T>>;

		T_DataIndexMap dataIndexMap;
		T_DataContainer data;

		inline std::size_t setEmpty(std::string& key)
		{
			std::size_t index = data.size();
			dataIndexMap[key] = index;
			data.emplace_back(key, T());
			return index;
		}

	public:
		using const_iterator = typename T_DataContainer::const_iterator;

		INIMap() { }

		INIMap(INIMap const& other)
		{
			std::size_t data_size = other.data.size();
			for (std::size_t i = 0; i < data_size; ++i)
			{
				auto const& key = other.data[i].first;
				auto const& obj = other.data[i].second;
				data.emplace_back(key, obj);
			}
			dataIndexMap = T_DataIndexMap(other.dataIndexMap);
		}

		T& operator[](std::string key)
		{
			INIStringUtil::trim(key);
#ifndef MINI_CASE_SENSITIVE
			INIStringUtil::toLower(key);
#endif
			auto it = dataIndexMap.find(key);
			bool hasIt = (it != dataIndexMap.end());
			std::size_t index = (hasIt) ? it->second : setEmpty(key);
			return data[index].second;
		}
		T get(std::string key) const
		{
			INIStringUtil::trim(key);
#ifndef MINI_CASE_SENSITIVE
			INIStringUtil::toLower(key);
#endif
			auto it = dataIndexMap.find(key);
			if (it == dataIndexMap.end())
			{
				return T();
			}
			return T(data[it->second].second);
		}
		bool has(std::string key) const
		{
			INIStringUtil::trim(key);
#ifndef MINI_CASE_SENSITIVE
			INIStringUtil::toLower(key);
#endif
			return (dataIndexMap.count(key) == 1);
		}
		void set(std::string key, T obj)
		{
			INIStringUtil::trim(key);
#ifndef MINI_CASE_SENSITIVE
			INIStringUtil::toLower(key);
#endif
			auto it = dataIndexMap.find(key);
			if (it != dataIndexMap.end())
			{
				data[it->second].second = obj;
			}
			else
			{
				dataIndexMap[key] = data.size();
				data.emplace_back(key, obj);
			}
		}
		void set(T_MultiArgs const& multiArgs)
		{
			for (auto const& it : multiArgs)
			{
				auto const& key = it.first;
				auto const& obj = it.second;
				set(key, obj);
			}
		}
		bool remove(std::string key)
		{
			INIStringUtil::trim(key);
#ifndef MINI_CASE_SENSITIVE
			INIStringUtil::toLower(key);
#endif
			auto it = dataIndexMap.find(key);
			if (it != dataIndexMap.end())
			{
				std::size_t index = it->second;
				data.erase(data.begin() + index);
				dataIndexMap.erase(it);
				for (auto& it2 : dataIndexMap)
				{
					auto& vi = it2.second;
					if (vi > index)
					{
						vi--;
					}
				}
				return true;
			}
			return false;
		}
		void clear()
		{
			data.clear();
			dataIndexMap.clear();
		}
		std::size_t size() const
		{
			return data.size();
		}
		const_iterator begin() const { return data.begin(); }
		const_iterator end() const { return data.end(); }
	};

	using INIStructure = INIMap<INIMap<std::string>>;

	namespace INIParser
	{
		using T_ParseValues = std::pair<std::string, std::string>;

		enum class PDataType : char
		{
			PDATA_NONE,
			PDATA_COMMENT,
			PDATA_SECTION,
			PDATA_KEYVALUE,
			PDATA_UNKNOWN
		};

		inline PDataType parseLine(std::string line, T_ParseValues& parseData)
		{
			parseData.first.clear();
			parseData.second.clear();
			INIStringUtil::trim(line);
			if (line.empty())
			{
				return PDataType::PDATA_NONE;
			}
			char firstCharacter = line[0];
			if (firstCharacter == ';')
			{
				return PDataType::PDATA_COMMENT;
			}
			if (firstCharacter == '[')
			{
				auto commentAt = line.find_first_of(';');
				if (commentAt != std::string::npos)
				{
					line = line.substr(0, commentAt);
				}
				auto closingBracketAt = line.find_last_of(']');
				if (closingBracketAt != std::string::npos)
				{
					auto section = line.substr(1, closingBracketAt - 1);
					INIStringUtil::trim(section);
					parseData.first = section;
					return PDataType::PDATA_SECTION;
				}
			}
			auto lineNorm = line;
			INIStringUtil::replace(lineNorm, "\\=", "  ");
			auto equalsAt = lineNorm.find_first_of('=');
			if (equalsAt != std::string::npos)
			{
				auto key = line.substr(0, equalsAt);
				INIStringUtil::trim(key);
				INIStringUtil::replace(key, "\\=", "=");
				auto value = line.substr(equalsAt + 1);
				INIStringUtil::trim(value);
				parseData.first = key;
				parseData.second = value;
				return PDataType::PDATA_KEYVALUE;
			}
			return PDataType::PDATA_UNKNOWN;
		}
	}

	class INIReader
	{
	public:
		using T_LineData = std::vector<std::string>;
		using T_LineDataPtr = std::shared_ptr<T_LineData>;

		bool isBOM = false;

	private:
		std::ifstream fileReadStream;
		T_LineDataPtr lineData;

		T_LineData readFile()
		{
			fileReadStream.seekg(0, std::ios::end);
			const std::size_t fileSize = static_cast<std::size_t>(fileReadStream.tellg());
			fileReadStream.seekg(0, std::ios::beg);
			if (fileSize >= 3) {
				const char header[3] = {
					static_cast<char>(fileReadStream.get()),
					static_cast<char>(fileReadStream.get()),
					static_cast<char>(fileReadStream.get())
				};
				isBOM = (
					header[0] == static_cast<char>(0xEF) &&
					header[1] == static_cast<char>(0xBB) &&
					header[2] == static_cast<char>(0xBF)
				);
			}
			else {
				isBOM = false;
			}
			std::string fileContents;
			fileContents.resize(fileSize);
			fileReadStream.seekg(isBOM ? 3 : 0, std::ios::beg);
			fileReadStream.read(&fileContents[0], fileSize);
			fileReadStream.close();
			T_LineData output;
			if (fileSize == 0)
			{
				return output;
			}
			std::string buffer;
			buffer.reserve(50);
			for (std::size_t i = 0; i < fileSize; ++i)
			{
				char& c = fileContents[i];
				if (c == '\n')
				{
					output.emplace_back(buffer);
					buffer.clear();
					continue;
				}
				if (c != '\0' && c != '\r')
				{
					buffer += c;
				}
			}
			output.emplace_back(buffer);
			return output;
		}

	public:
		INIReader(std::string const& filename, bool keepLineData = false)
		{
			fileReadStream.open(filename, std::ios::in | std::ios::binary);
			if (keepLineData)
			{
				lineData = std::make_shared<T_LineData>();
			}
		}
		~INIReader() { }

		bool operator>>(INIStructure& data)
		{
			if (!fileReadStream.is_open())
			{
				return false;
			}
			T_LineData fileLines = readFile();
			std::string section;
			bool inSection = false;
			INIParser::T_ParseValues parseData;
			for (auto const& line : fileLines)
			{
				auto parseResult = INIParser::parseLine(line, parseData);
				if (parseResult == INIParser::PDataType::PDATA_SECTION)
				{
					inSection = true;
					data[section = parseData.first];
				}
				else if (inSection && parseResult == INIParser::PDataType::PDATA_KEYVALUE)
				{
					auto const& key = parseData.first;
					auto const& value = parseData.second;
					data[section][key] = value;
				}
				if (lineData && parseResult != INIParser::PDataType::PDATA_UNKNOWN)
				{
					if (parseResult == INIParser::PDataType::PDATA_KEYVALUE && !inSection)
					{
						continue;
					}
					lineData->emplace_back(line);
				}
			}
			return true;
		}
		T_LineDataPtr getLines()
		{
			return lineData;
		}
	};

	class INIGenerator
	{
	private:
		std::ofstream fileWriteStream;

	public:
		bool prettyPrint = false;

		INIGenerator(std::string const& filename)
		{
			fileWriteStream.open(filename, std::ios::out | std::ios::binary);
		}
		~INIGenerator() { }

		bool operator<<(INIStructure const& data)
		{
			if (!fileWriteStream.is_open())
			{
				return false;
			}
			if (!data.size())
			{
				return true;
			}
			auto it = data.begin();
			for (;;)
			{
				auto const& section = it->first;
				auto const& collection = it->second;
				fileWriteStream
					<< "["
					<< section
					<< "]";
				if (collection.size())
				{
					fileWriteStream << INIStringUtil::endl;
					auto it2 = collection.begin();
					for (;;)
					{
						auto key = it2->first;
						INIStringUtil::replace(key, "=", "\\=");
						auto value = it2->second;
						INIStringUtil::trim(value);
						fileWriteStream
							<< key
							<< ((prettyPrint) ? " = " : "=")
							<< value;
						if (++it2 == collection.end())
						{
							break;
						}
						fileWriteStream << INIStringUtil::endl;
					}
				}
				if (++it == data.end())
				{
					break;
				}
				fileWriteStream << INIStringUtil::endl;
				if (prettyPrint)
				{
					fileWriteStream << INIStringUtil::endl;
				}
			}
			return true;
		}
	};

	class INIWriter
	{
	private:
		using T_LineData = std::vector<std::string>;
		using T_LineDataPtr = std::shared_ptr<T_LineData>;

		std::string filename;

		T_LineData getLazyOutput(T_LineDataPtr const& lineData, INIStructure& data, INIStructure& original)
		{
			T_LineData output;
			INIParser::T_ParseValues parseData;
			std::string sectionCurrent;
			bool parsingSection = false;
			bool continueToNextSection = false;
			bool discardNextEmpty = false;
			bool writeNewKeys = false;
			std::size_t lastKeyLine = 0;
			for (auto line = lineData->begin(); line != lineData->end(); ++line)
			{
				if (!writeNewKeys)
				{
					auto parseResult = INIParser::parseLine(*line, parseData);
					if (parseResult == INIParser::PDataType::PDATA_SECTION)
					{
						if (parsingSection)
						{
							writeNewKeys = true;
							parsingSection = false;
							--line;
							continue;
						}
						sectionCurrent = parseData.first;
						if (data.has(sectionCurrent))
						{
							parsingSection = true;
							continueToNextSection = false;
							discardNextEmpty = false;
							output.emplace_back(*line);
							lastKeyLine = output.size();
						}
						else
						{
							continueToNextSection = true;
							discardNextEmpty = true;
							continue;
						}
					}
					else if (parseResult == INIParser::PDataType::PDATA_KEYVALUE)
					{
						if (continueToNextSection)
						{
							continue;
						}
						if (data.has(sectionCurrent))
						{
							auto& collection = data[sectionCurrent];
							auto const& key = parseData.first;
							auto const& value = parseData.second;
							if (collection.has(key))
							{
								auto outputValue = collection[key];
								if (value == outputValue)
								{
									output.emplace_back(*line);
								}
								else
								{
									INIStringUtil::trim(outputValue);
									auto lineNorm = *line;
									INIStringUtil::replace(lineNorm, "\\=", "  ");
									auto equalsAt = lineNorm.find_first_of('=');
									auto valueAt = lineNorm.find_first_not_of(
										INIStringUtil::whitespaceDelimiters,
										equalsAt + 1
									);
									std::string outputLine = line->substr(0, valueAt);
									if (prettyPrint && equalsAt + 1 == valueAt)
									{
										outputLine += " ";
									}
									outputLine += outputValue;
									output.emplace_back(outputLine);
								}
								lastKeyLine = output.size();
							}
						}
					}
					else
					{
						if (discardNextEmpty && line->empty())
						{
							discardNextEmpty = false;
						}
						else if (parseResult != INIParser::PDataType::PDATA_UNKNOWN)
						{
							output.emplace_back(*line);
						}
					}
				}
				if (writeNewKeys || std::next(line) == lineData->end())
				{
					T_LineData linesToAdd;
					if (data.has(sectionCurrent) && original.has(sectionCurrent))
					{
						auto const& collection = data[sectionCurrent];
						auto const& collectionOriginal = original[sectionCurrent];
						for (auto const& it : collection)
						{
							auto key = it.first;
							if (collectionOriginal.has(key))
							{
								continue;
							}
							auto value = it.second;
							INIStringUtil::replace(key, "=", "\\=");
							INIStringUtil::trim(value);
							linesToAdd.emplace_back(
								key + ((prettyPrint) ? " = " : "=") + value
							);
						}
					}
					if (!linesToAdd.empty())
					{
						output.insert(
							output.begin() + lastKeyLine,
							linesToAdd.begin(),
							linesToAdd.end()
						);
					}
					if (writeNewKeys)
					{
						writeNewKeys = false;
						--line;
					}
				}
			}
			for (auto const& it : data)
			{
				auto const& section = it.first;
				if (original.has(section))
				{
					continue;
				}
				if (prettyPrint && output.size() > 0 && !output.back().empty())
				{
					output.emplace_back();
				}
				output.emplace_back("[" + section + "]");
				auto const& collection = it.second;
				for (auto const& it2 : collection)
				{
					auto key = it2.first;
					auto value = it2.second;
					INIStringUtil::replace(key, "=", "\\=");
					INIStringUtil::trim(value);
					output.emplace_back(
						key + ((prettyPrint) ? " = " : "=") + value
					);
				}
			}
			return output;
		}

	public:
		bool prettyPrint = false;

		INIWriter(std::string const& filename)
		: filename(filename)
		{
		}
		~INIWriter() { }

		bool operator<<(INIStructure& data)
		{
			struct stat buf;
			bool fileExists = (stat(filename.c_str(), &buf) == 0);
			if (!fileExists)
			{
				INIGenerator generator(filename);
				generator.prettyPrint = prettyPrint;
				return generator << data;
			}
			INIStructure originalData;
			T_LineDataPtr lineData;
			bool readSuccess = false;
			bool fileIsBOM = false;
			{
				INIReader reader(filename, true);
				if ((readSuccess = reader >> originalData))
				{
					lineData = reader.getLines();
					fileIsBOM = reader.isBOM;
				}
			}
			if (!readSuccess)
			{
				return false;
			}
			T_LineData output = getLazyOutput(lineData, data, originalData);
			std::ofstream fileWriteStream(filename, std::ios::out | std::ios::binary);
			if (fileWriteStream.is_open())
			{
				if (fileIsBOM) {
					const char utf8_BOM[3] = {
						static_cast<char>(0xEF),
						static_cast<char>(0xBB),
						static_cast<char>(0xBF)
					};
					fileWriteStream.write(utf8_BOM, 3);
				}
				if (output.size())
				{
					auto line = output.begin();
					for (;;)
					{
						fileWriteStream << *line;
						if (++line == output.end())
						{
							break;
						}
						fileWriteStream << INIStringUtil::endl;
					}
				}
				return true;
			}
			return false;
		}
	};

	class INIFile
	{
	private:
		std::string filename;

	public:
		INIFile(std::string const& filename)
		: filename(filename)
		{ }

		~INIFile() { }

		bool read(INIStructure& data) const
		{
			if (data.size())
			{
				data.clear();
			}
			if (filename.empty())
			{
				return false;
			}
			INIReader reader(filename);
			return reader >> data;
		}
		bool generate(INIStructure const& data, bool pretty = false) const
		{
			if (filename.empty())
			{
				return false;
			}
			INIGenerator generator(filename);
			generator.prettyPrint = pretty;
			return generator << data;
		}
		bool write(INIStructure& data, bool pretty = false) const
		{
			if (filename.empty())
			{
				return false;
			}
			INIWriter writer(filename);
			writer.prettyPrint = pretty;
			return writer << data;
		}
	};
}

#endif // MINI_INI_H_

```

`HPCS2/handle_hijack.hpp`:

```hpp

/*
	Credits to: https://github.com/Apxaey/Handle-Hijacking-Anti-Cheat-Bypass for the source and public sharing!

	Its a little bit messy as i tried to make it asap. All comments below this are from the original creator!
*/

/*
	This is a stand alone bypass made by Apxaey. Feel free to use this in your cheats but credit me for the bypass as i put alot of time into this.
	If you have some brain cells you will be able to incorporate this into your cheats and remain undetected by user-mode anticheats.
	Obviously standard cheat 'recommendations' still apply:
	1.) Use self-written or not signatured code
	2.) Dont write impossible values
	3.) If your going internal use a manual map injector

	If you follow the guidelines above and use this bypass you will be safe from usermode anticheats like VAC.
	Obviously you can build and adapt upon my code to suit your needs.
	If I was to make a cheat for myself i would put this bypass into something i call an 'external internal' cheat.
	Whereby you make a cheat and inject into a legitimate program like discord and add a check to the this bypass to only hijack a handle from the process you inject into, giving the appearence that nothing is out of the ordinary
	However you can implement this bypass into any form of cheat, its your decision.
	If you need want some more info i recommend you watch my YT video on this bypass.
	Anyways if you want to see more of my stuff feel free to join my discord server discord.gg/********. Here's my YT as well https://www.youtube.com/channel/UCPN6OOLxn1OaBP5jPThIiog.
*/

#include <Windows.h> 
#include <iostream>
#include <TlHelp32.h>
#include <string>

// macros we use.Some can be found in wintrnl.h
#define SeDebugPriv 20
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004)
#define NtCurrentProcess ( (HANDLE)(LONG_PTR) -1 ) 
#define ProcessHandleType 0x7
#define SystemHandleInformation 16 

/*
STRUCTURES NEEDED FOR NTOPENPROCESS:
*/
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWCH   Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

/*
STRUCTURES NEEDED FOR HANDLE INFORMATION:
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE; //i shortened it to SYSTEM_HANDLE for the sake of typing

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

/*
FUNCTION PROTOTYPES:
*/
typedef NTSTATUS(NTAPI* _NtDuplicateObject)(
	HANDLE SourceProcessHandle,
	HANDLE SourceHandle,
	HANDLE TargetProcessHandle,
	PHANDLE TargetHandle,
	ACCESS_MASK DesiredAccess,
	ULONG Attributes,
	ULONG Options
	);

typedef NTSTATUS(NTAPI* _RtlAdjustPrivilege)(
	ULONG Privilege,
	BOOLEAN Enable,
	BOOLEAN CurrentThread,
	PBOOLEAN Enabled
	);

typedef NTSYSAPI NTSTATUS(NTAPI* _NtOpenProcess)(
	PHANDLE            ProcessHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PCLIENT_ID         ClientId
	);

typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
	ULONG SystemInformationClass, //your supposed to supply the whole class but microsoft kept the enum mostly empty so I just passed 16 instead for handle info. Thats why you get a warning in your code btw
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);

SYSTEM_HANDLE_INFORMATION* hInfo; //holds the handle information

//the handles we will need to use later on

namespace hj {
	HANDLE procHandle = NULL;
	HANDLE hProcess = NULL;
	HANDLE HijackedHandle = NULL;

	// simple function i made that will just initialize our Object_Attributes structure as NtOpenProcess will fail otherwise
	OBJECT_ATTRIBUTES InitObjectAttributes(PUNICODE_STRING name, ULONG attributes, HANDLE hRoot, PSECURITY_DESCRIPTOR security)
	{
		OBJECT_ATTRIBUTES object;

		object.Length = sizeof(OBJECT_ATTRIBUTES);
		object.ObjectName = name;
		object.Attributes = attributes;
		object.RootDirectory = hRoot;
		object.SecurityDescriptor = security;

		return object;
	}

	bool IsHandleValid(HANDLE handle) // i made this to simply check if a handle is valid rather than repeating the if statments
	{
		if (handle && handle != INVALID_HANDLE_VALUE)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	HANDLE HijackExistingHandle(DWORD dwTargetProcessId)
	{
		HMODULE Ntdll = GetModuleHandleA("ntdll"); // get the base address of ntdll.dll

		//get the address of RtlAdjustPrivilege in ntdll.dll so we can grant our process the highest permission possible
		_RtlAdjustPrivilege RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(Ntdll, "RtlAdjustPrivilege");

		boolean OldPriv; //store the old privileges

		// Give our program SeDeugPrivileges whcih allows us to get a handle to every process, even the highest privileged SYSTEM level processes.
		RtlAdjustPrivilege(SeDebugPriv, TRUE, FALSE, &OldPriv);

		//get the address of NtQuerySystemInformation in ntdll.dll so we can find all the open handles on our system
		_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(Ntdll, "NtQuerySystemInformation");

		//get the address of NtDuplicateObject in ntdll.dll so we can duplicate an existing handle into our cheat, basically performing the hijacking
		_NtDuplicateObject NtDuplicateObject = (_NtDuplicateObject)GetProcAddress(Ntdll, "NtDuplicateObject");

		//get the address of NtOpenProcess in ntdll.dll so wecan create a Duplicate handle
		_NtOpenProcess NtOpenProcess = (_NtOpenProcess)GetProcAddress(Ntdll, "NtOpenProcess");


		//initialize the Object Attributes structure, you can just set each member to NULL rather than create a function like i did
		OBJECT_ATTRIBUTES Obj_Attribute = InitObjectAttributes(NULL, NULL, NULL, NULL);

		//clientID is a PDWORD or DWORD* of the process id to create a handle to
		CLIENT_ID clientID = { 0 };


		//the size variable is the amount of bytes allocated to store all the open handles
		DWORD size = sizeof(SYSTEM_HANDLE_INFORMATION);

		//we allocate the memory to store all the handles on the heap rather than the stack becuase of the large amount of data
		hInfo = (SYSTEM_HANDLE_INFORMATION*) new byte[size];

		//zero the memory handle info
		ZeroMemory(hInfo, size);

		//we use this for checking if the Native functions succeed
		NTSTATUS NtRet = NULL;

		do
		{
			// delete the previously allocated memory on the heap because it wasn't large enough to store all the handles
			delete[] hInfo;

			//increase the amount of memory allocated by 50%
			size *= 1.5;
			try
			{
				//set and allocate the larger size on the heap
				hInfo = (PSYSTEM_HANDLE_INFORMATION) new byte[size];
			}
			catch (std::bad_alloc) //catch a bad heap allocation.
			{
				procHandle ? CloseHandle(procHandle) : 0;
			}
			Sleep(1); //sleep for the cpu

			//we continue this loop until all the handles have been stored
		} while ((NtRet = NtQuerySystemInformation(SystemHandleInformation, hInfo, size, NULL)) == STATUS_INFO_LENGTH_MISMATCH);

		//check if we got all the open handles on our system
		if (!NT_SUCCESS(NtRet))
		{
			procHandle ? CloseHandle(procHandle) : 0;
		}


		//loop through each handle on our system, and filter out handles that are invalid or cant be hijacked
		for (unsigned int i = 0; i < hInfo->HandleCount; ++i)
		{
			//a variable to store the number of handles OUR cheat has open.
			static DWORD NumOfOpenHandles;

			//get the amount of outgoing handles OUR cheat has open
			GetProcessHandleCount(GetCurrentProcess(), &NumOfOpenHandles);

			//you can do a higher number if this is triggering false positives. Its just to make sure we dont fuck up and create thousands of handles
			if (NumOfOpenHandles > 50)
			{
				procHandle ? CloseHandle(procHandle) : 0;
			}

			//check if the current handle is valid, otherwise increment i and check the next handle
			if (!IsHandleValid((HANDLE)hInfo->Handles[i].Handle))
			{
				continue;
			}

			//check the handle type is 0x7 meaning a process handle so we dont hijack a file handle for example
			if (hInfo->Handles[i].ObjectTypeNumber != ProcessHandleType)
			{
				continue;
			}


			//set clientID to a pointer to the process with the handle to out target
			clientID.UniqueProcess = (DWORD*)hInfo->Handles[i].ProcessId;

			//if procHandle is open, close it
			procHandle ? CloseHandle(procHandle) : 0;

			//create a a handle with duplicate only permissions to the process with a handle to our target. NOT OUR TARGET.
			NtRet = NtOpenProcess(&procHandle, PROCESS_DUP_HANDLE, &Obj_Attribute, &clientID);
			if (!IsHandleValid(procHandle) || !NT_SUCCESS(NtRet)) //check is the funcions succeeded and check the handle is valid
			{
				continue;
			}


			//we duplicate the handle another process has to our target into our cheat with whatever permissions we want. I did all access.
			NtRet = NtDuplicateObject(procHandle, (HANDLE)hInfo->Handles[i].Handle, NtCurrentProcess, &HijackedHandle, PROCESS_ALL_ACCESS, 0, 0);
			if (!IsHandleValid(HijackedHandle) || !NT_SUCCESS(NtRet))//check is the funcions succeeded and check the handle is valid
			{

				continue;
			}

			//get the process id of the handle we duplicated and check its to our target
			if (GetProcessId(HijackedHandle) != dwTargetProcessId) {
				CloseHandle(HijackedHandle);
				continue;
			}



			hProcess = HijackedHandle;

			break;
		}

		procHandle ? CloseHandle(procHandle) : 0;

		return hProcess;
	}
}
```

`HPCS2/memory.cpp`:

```cpp
#include "memory.hpp"
#include <tlhelp32.h>
#include "handle_hijack.hpp"

uint32_t pProcess::FindProcessIdByProcessName(const char* ProcessName)
{
	std::wstring wideProcessName;
	int wideCharLength = MultiByteToWideChar(CP_UTF8, 0, ProcessName, -1, nullptr, 0);
	if (wideCharLength > 0)
	{
		wideProcessName.resize(wideCharLength);
		MultiByteToWideChar(CP_UTF8, 0, ProcessName, -1, &wideProcessName[0], wideCharLength);
	}

	HANDLE hPID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	PROCESSENTRY32W process_entry_{ };
	process_entry_.dwSize = sizeof(PROCESSENTRY32W);

	DWORD pid = 0;
	if (Process32FirstW(hPID, &process_entry_))
	{
		do
		{
			if (!wcscmp(process_entry_.szExeFile, wideProcessName.c_str()))
			{
				pid = process_entry_.th32ProcessID;
				break;
			}
		} while (Process32NextW(hPID, &process_entry_));
	}
	CloseHandle(hPID);
	return pid;
}

uint32_t pProcess::FindProcessIdByWindowName(const char* WindowName)
{
	DWORD process_id = 0;
	HWND windowHandle = FindWindowA(nullptr, WindowName);
	if (windowHandle)
		GetWindowThreadProcessId(windowHandle, &process_id);
	return process_id;
}

HWND pProcess::GetWindowHandleFromProcessId(DWORD ProcessId) {
	HWND hwnd = NULL;
	do {
		hwnd = FindWindowEx(NULL, hwnd, NULL, NULL);
		DWORD pid = 0;
		GetWindowThreadProcessId(hwnd, &pid);
		if (pid == ProcessId) {
			TCHAR windowTitle[MAX_PATH];
			GetWindowText(hwnd, windowTitle, MAX_PATH);
			if (IsWindowVisible(hwnd) && windowTitle[0] != '\0') {
				return hwnd;
			}
		}
	} while (hwnd != NULL);
	return NULL; // No main window found for the given process ID
}

bool pProcess::AttachProcess(const char* ProcessName)
{
	this->pid_ = this->FindProcessIdByProcessName(ProcessName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;

		handle_ = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid_);

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}

	return false;
}

bool pProcess::AttachProcessHj(const char* ProcessName)
{
	this->pid_ = this->FindProcessIdByProcessName(ProcessName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;


		// Using Apxaey's handle hijack function to safely open a handle
		handle_ = hj::HijackExistingHandle(pid_);

		if (!hj::IsHandleValid(handle_))
		{
			std::cout << "[cheat] Handle Hijack failed, falling back to OpenProcess method." << std::endl;
			return pProcess::AttachProcess(ProcessName); // Handle hijacking failed, so we fall back to the normal OpenProcess method
		}

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}

	return false;
}


bool pProcess::AttachWindow(const char* WindowName)
{
	this->pid_ = this->FindProcessIdByWindowName(WindowName);

	if (pid_)
	{
		HMODULE modules[0xFF];
		MODULEINFO module_info;
		DWORD _;

		handle_ = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid_);

		EnumProcessModulesEx(this->handle_, modules, sizeof(modules), &_, LIST_MODULES_64BIT);
		base_client_.base = (uintptr_t)modules[0];

		GetModuleInformation(this->handle_, modules[0], &module_info, sizeof(module_info));
		base_client_.size = module_info.SizeOfImage;

		hwnd_ = this->GetWindowHandleFromProcessId(pid_);

		return true;
	}
	return false;
}

bool pProcess::UpdateHWND()
{
	hwnd_ = this->GetWindowHandleFromProcessId(pid_);
	return hwnd_ == nullptr;
}

ProcessModule pProcess::GetModule(const char* lModule)
{
	std::wstring wideModule;
	int wideCharLength = MultiByteToWideChar(CP_UTF8, 0, lModule, -1, nullptr, 0);
	if (wideCharLength > 0)
	{
		wideModule.resize(wideCharLength);
		MultiByteToWideChar(CP_UTF8, 0, lModule, -1, &wideModule[0], wideCharLength);
	}

	HANDLE handle_module = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid_);
	MODULEENTRY32W module_entry_{};
	module_entry_.dwSize = sizeof(MODULEENTRY32W);

	do
	{
		if (!wcscmp(module_entry_.szModule, wideModule.c_str()))
		{
			CloseHandle(handle_module);
			return { (DWORD_PTR)module_entry_.modBaseAddr, module_entry_.dwSize };
		}
	} while (Module32NextW(handle_module, &module_entry_));

	CloseHandle(handle_module);
	return { 0, 0 };
}

LPVOID pProcess::Allocate(size_t size_in_bytes)
{
	return VirtualAllocEx(this->handle_, NULL, size_in_bytes, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
}

uintptr_t pProcess::FindSignature(std::vector<uint8_t> signature)
{
	std::unique_ptr<uint8_t[]> data;
	data = std::make_unique<uint8_t[]>(this->base_client_.size);

	if (!ReadProcessMemory(this->handle_, (void*)(this->base_client_.base), data.get(), this->base_client_.size, NULL)) {
		return 0x0;
	}

	for (uintptr_t i = 0; i < this->base_client_.size; i++)
	{
		for (uintptr_t j = 0; j < signature.size(); j++)
		{
			if (signature.at(j) == 0x00)
				continue;

			if (*reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(&data[i + j])) == signature.at(j))
			{
				if (j == signature.size() - 1)
					return this->base_client_.base + i;
				continue;
			}
			break;
		}
	}
	return 0x0;
}

uintptr_t pProcess::FindSignature(ProcessModule target_module, std::vector<uint8_t> signature)
{
	std::unique_ptr<uint8_t[]> data;
	data = std::make_unique<uint8_t[]>(0xFFFFFFF);

	if (!ReadProcessMemory(this->handle_, (void*)(target_module.base), data.get(), 0xFFFFFFF, NULL)) {
		return NULL;
	}

	for (uintptr_t i = 0; i < 0xFFFFFFF; i++)
	{
		for (uintptr_t j = 0; j < signature.size(); j++)
		{
			if (signature.at(j) == 0x00)
				continue;

			if (*reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(&data[i + j])) == signature.at(j))
			{
				if (j == signature.size() - 1)
					return this->base_client_.base + i;
				continue;
			}
			break;
		}
	}
	return 0x0;
}

uintptr_t pProcess::FindCodeCave(uint32_t length_in_bytes)
{
	std::vector<uint8_t> cave_pattern = {};

	for (uint32_t i = 0; i < length_in_bytes; i++) {
		cave_pattern.push_back(0x00);
	}

	return FindSignature(cave_pattern);
}

void pProcess::Close()
{
	CloseHandle(handle_);
}
```

`HPCS2/memory.hpp`:

```hpp
#ifndef _PPROCESS_HPP_
#define _PPROCESS_HPP_

#include <vector>
#include <math.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#include <iostream>
#include <Psapi.h> 

typedef NTSTATUS(WINAPI* pNtReadVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesRead);
typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten);

class pMemory {

public:
	pMemory() {
		pfnNtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtReadVirtualMemory");
		pfnNtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");
	}

	pNtReadVirtualMemory pfnNtReadVirtualMemory;
	pNtWriteVirtualMemory pfnNtWriteVirtualMemory;
};

struct ProcessModule
{
	uintptr_t base, size;
};

class pProcess
{
public:
	DWORD		  pid_; // process id
	HANDLE		  handle_; // handle to process
	HWND		  hwnd_; // window handle
	ProcessModule base_client_;

public:
	bool AttachProcess(const char* process_name);
	bool AttachProcessHj(const char* process_name);
	bool AttachWindow(const char* window_name);
	bool UpdateHWND();
	void Close();

public:
	ProcessModule GetModule(const char* module_name);
	LPVOID		  Allocate(size_t size_in_bytes);
	uintptr_t	  FindCodeCave(uint32_t length_in_bytes);
	uintptr_t     FindSignature(std::vector<uint8_t> signature);
	uintptr_t     FindSignature(ProcessModule target_module, std::vector<uint8_t> signature);

	template<class T>
	uintptr_t ReadOffsetFromSignature(std::vector<uint8_t> signature, uint8_t offset) // offset example: "FF 05 ->22628B01<-" offset is 2
	{
		uintptr_t pattern_address = this->FindSignature(signature);
		if (!pattern_address)
			return 0x0;

		T offset_value = this->read<T>(pattern_address + offset);
		return pattern_address + offset_value + offset + sizeof(T);
	}

	bool read_raw(uintptr_t address, void* buffer, size_t size)
	{
		SIZE_T bytesRead;
		pMemory cMemory;

		if (cMemory.pfnNtReadVirtualMemory(this->handle_, (PVOID)(address), buffer, static_cast<ULONG>(size), (PULONG)&bytesRead))
		{
			return bytesRead == size;
		}
		return false;
	}

	template<class T>
	void write(uintptr_t address, T value)
	{
		pMemory cMemory;
		cMemory.pfnNtWriteVirtualMemory(handle_, (void*)address, &value, sizeof(T), 0);
	}

	template<class T>
	T read(uintptr_t address)
	{
		T buffer{};
		pMemory cMemory;

		cMemory.pfnNtReadVirtualMemory(handle_, (void*)address, &buffer, sizeof(T), 0);
		return buffer;
	}

	void write_bytes(uintptr_t addr, std::vector<uint8_t> patch)
	{
		pMemory cMemory;
		cMemory.pfnNtWriteVirtualMemory(handle_, (void*)addr, &patch[0], patch.size(), 0);
	}

	uintptr_t read_multi_address(uintptr_t ptr, std::vector<uintptr_t> offsets)
	{
		uintptr_t buffer = ptr;
		for (int i = 0; i < offsets.size(); i++)
			buffer = this->read<uintptr_t>(buffer + offsets[i]);

		return buffer;
	}

	template <typename T>
	T read_multi(uintptr_t base, std::vector<uintptr_t> offsets) {
		uintptr_t buffer = base;
		for (int i = 0; i < offsets.size() - 1; i++)
		{
			buffer = this->read<uintptr_t>(buffer + offsets[i]);
		}
		return this->read<T>(buffer + offsets.back());
	}

private:
	uint32_t FindProcessIdByProcessName(const char* process_name);
	uint32_t FindProcessIdByWindowName(const char* window_name);
	HWND GetWindowHandleFromProcessId(DWORD ProcessId);
};
#endif
```

`HPCS2/offset/animationsystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace AimMatrixOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_poseCacheHandles = 0x90; // CPoseHandle[10]
    constexpr std::ptrdiff_t m_eBlendMode = 0xB8; // AimMatrixBlendMode
    constexpr std::ptrdiff_t m_fAngleIncrement = 0xBC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nBoneMaskIndex = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xC8; // bool
}

namespace AnimComponentID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimNodeOutputID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimParamID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimScriptHandle {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimStateID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimTagID {
    constexpr std::ptrdiff_t m_id = 0x0; // uint32_t
}

namespace AnimationDecodeDebugDumpElement_t {
    constexpr std::ptrdiff_t m_nEntityIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_poseParams = 0x10; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodeOps = 0x28; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_internalOps = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_decodedAnims = 0x58; // CUtlVector<CUtlString>
}

namespace AnimationDecodeDebugDump_t {
    constexpr std::ptrdiff_t m_processingType = 0x0; // AnimationProcessingType_t
    constexpr std::ptrdiff_t m_elems = 0x8; // CUtlVector<AnimationDecodeDebugDumpElement_t>
}

namespace AnimationSnapshotBase_t {
    constexpr std::ptrdiff_t m_flRealTime = 0x0; // float
    constexpr std::ptrdiff_t m_rootToWorld = 0x10; // matrix3x4a_t
    constexpr std::ptrdiff_t m_bBonesInWorldSpace = 0x40; // bool
    constexpr std::ptrdiff_t m_boneSetupMask = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneTransforms = 0x60; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_flexControllers = 0x78; // CUtlVector<float>
    constexpr std::ptrdiff_t m_SnapshotType = 0x90; // AnimationSnapshotType_t
    constexpr std::ptrdiff_t m_bHasDecodeDump = 0x94; // bool
    constexpr std::ptrdiff_t m_DecodeDump = 0x98; // AnimationDecodeDebugDumpElement_t
}

namespace AnimationSnapshot_t { // AnimationSnapshotBase_t
    constexpr std::ptrdiff_t m_nEntIndex = 0x110; // int32_t
    constexpr std::ptrdiff_t m_modelName = 0x118; // CUtlString
}

namespace AttachmentHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint8_t
}

namespace BlendItem_t {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pChild = 0x18; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hSequence = 0x28; // HSequence
    constexpr std::ptrdiff_t m_vPos = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_flDuration = 0x34; // float
    constexpr std::ptrdiff_t m_bUseCustomDuration = 0x38; // bool
}

namespace BoneDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flChainLength = 0x8; // float
}

namespace CActionComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_actions = 0x30; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
}

namespace CAddUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CAimConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_qAimOffset = 0x70; // Quaternion
    constexpr std::ptrdiff_t m_nUpType = 0x80; // uint32_t
}

namespace CAimMatrixUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // AimMatrixOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x148; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x14C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSequence = 0x150; // HSequence
    constexpr std::ptrdiff_t m_bResetChild = 0x154; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x155; // bool
}

namespace CAnimActionUpdater {
}

namespace CAnimActivity {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nActivity = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nWeight = 0x18; // int32_t
}

namespace CAnimAttachment {
    constexpr std::ptrdiff_t m_influenceRotations = 0x0; // Quaternion[3]
    constexpr std::ptrdiff_t m_influenceOffsets = 0x30; // VectorAligned[3]
    constexpr std::ptrdiff_t m_influenceIndices = 0x60; // int32_t[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x6C; // float[3]
    constexpr std::ptrdiff_t m_numInfluences = 0x78; // uint8_t
}

namespace CAnimBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // int32_t
    constexpr std::ptrdiff_t m_pos = 0x14; // Vector
    constexpr std::ptrdiff_t m_quat = 0x20; // QuaternionStorage
    constexpr std::ptrdiff_t m_scale = 0x30; // float
    constexpr std::ptrdiff_t m_qAlignment = 0x34; // QuaternionStorage
    constexpr std::ptrdiff_t m_flags = 0x44; // int32_t
}

namespace CAnimBoneDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_parent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_posError = 0x20; // Vector
    constexpr std::ptrdiff_t m_bHasRotation = 0x2C; // bool
    constexpr std::ptrdiff_t m_bHasMovement = 0x2D; // bool
}

namespace CAnimComponentUpdater {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimComponentID
    constexpr std::ptrdiff_t m_networkMode = 0x24; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_bStartEnabled = 0x28; // bool
}

namespace CAnimCycle { // CCycleBase
}

namespace CAnimData {
    constexpr std::ptrdiff_t m_name = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_animArray = 0x20; // CUtlVector<CAnimDesc>
    constexpr std::ptrdiff_t m_decoderArray = 0x38; // CUtlVector<CAnimDecoder>
    constexpr std::ptrdiff_t m_nMaxUniqueFrameIndex = 0x50; // int32_t
    constexpr std::ptrdiff_t m_segmentArray = 0x58; // CUtlVector<CAnimFrameSegment>
}

namespace CAnimDataChannelDesc {
    constexpr std::ptrdiff_t m_szChannelClass = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_szVariableName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x24; // int32_t
    constexpr std::ptrdiff_t m_szGrouping = 0x28; // CBufferString
    constexpr std::ptrdiff_t m_szDescription = 0x38; // CBufferString
    constexpr std::ptrdiff_t m_szElementNameArray = 0x48; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nElementIndexArray = 0x60; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nElementMaskArray = 0x78; // CUtlVector<uint32_t>
}

namespace CAnimDecoder {
    constexpr std::ptrdiff_t m_szName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nVersion = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x14; // int32_t
}

namespace CAnimDemoCaptureSettings {
    constexpr std::ptrdiff_t m_rangeBoneChainLength = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_rangeMaxSplineErrorRotation = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_flMaxSplineErrorTranslation = 0x10; // float
    constexpr std::ptrdiff_t m_flMaxSplineErrorScale = 0x14; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxSplineError = 0x18; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxSplineError = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorRotation = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorTranslation = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxQuantizationErrorScale = 0x28; // float
    constexpr std::ptrdiff_t m_flIkRotation_MaxQuantizationError = 0x2C; // float
    constexpr std::ptrdiff_t m_flIkTranslation_MaxQuantizationError = 0x30; // float
    constexpr std::ptrdiff_t m_baseSequence = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_nBaseSequenceFrame = 0x40; // int32_t
    constexpr std::ptrdiff_t m_boneSelectionMode = 0x44; // EDemoBoneSelectionMode
    constexpr std::ptrdiff_t m_bones = 0x48; // CUtlVector<BoneDemoCaptureSettings_t>
    constexpr std::ptrdiff_t m_ikChains = 0x60; // CUtlVector<IKDemoCaptureSettings_t>
}

namespace CAnimDesc {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CAnimDesc_Flag
    constexpr std::ptrdiff_t fps = 0x18; // float
    constexpr std::ptrdiff_t m_Data = 0x20; // CAnimEncodedFrames
    constexpr std::ptrdiff_t m_movementArray = 0xF8; // CUtlVector<CAnimMovement>
    constexpr std::ptrdiff_t m_eventArray = 0x110; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x128; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_hierarchyArray = 0x140; // CUtlVector<CAnimLocalHierarchy>
    constexpr std::ptrdiff_t framestalltime = 0x158; // float
    constexpr std::ptrdiff_t m_vecRootMin = 0x15C; // Vector
    constexpr std::ptrdiff_t m_vecRootMax = 0x168; // Vector
    constexpr std::ptrdiff_t m_vecBoneWorldMin = 0x178; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vecBoneWorldMax = 0x190; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_sequenceParams = 0x1A8; // CAnimSequenceParams
}

namespace CAnimDesc_Flag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bAllZeros = 0x1; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x2; // bool
    constexpr std::ptrdiff_t m_bDelta = 0x3; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x4; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0x5; // bool
    constexpr std::ptrdiff_t m_bImplicitSeqIgnoreDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bAnimGraphAdditive = 0x7; // bool
}

namespace CAnimEncodeDifference {
    constexpr std::ptrdiff_t m_boneArray = 0x0; // CUtlVector<CAnimBoneDifference>
    constexpr std::ptrdiff_t m_morphArray = 0x18; // CUtlVector<CAnimMorphDifference>
    constexpr std::ptrdiff_t m_userArray = 0x30; // CUtlVector<CAnimUserDifference>
    constexpr std::ptrdiff_t m_bHasRotationBitArray = 0x48; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMovementBitArray = 0x60; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasMorphBitArray = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bHasUserBitArray = 0x90; // CUtlVector<uint8_t>
}

namespace CAnimEncodedFrames {
    constexpr std::ptrdiff_t m_fileName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nFrames = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nFramesPerBlock = 0x14; // int32_t
    constexpr std::ptrdiff_t m_frameblockArray = 0x18; // CUtlVector<CAnimFrameBlockAnim>
    constexpr std::ptrdiff_t m_usageDifferences = 0x30; // CAnimEncodeDifference
}

namespace CAnimEnum {
    constexpr std::ptrdiff_t m_value = 0x0; // uint8_t
}

namespace CAnimEventDefinition {
    constexpr std::ptrdiff_t m_nFrame = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xC; // float
    constexpr std::ptrdiff_t m_EventData = 0x10; // KeyValues3
    constexpr std::ptrdiff_t m_sLegacyOptions = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_sEventName = 0x30; // CGlobalSymbol
}

namespace CAnimFoot {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x8; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_ankleBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_toeBoneIndex = 0x24; // int32_t
}

namespace CAnimFrameBlockAnim {
    constexpr std::ptrdiff_t m_nStartFrame = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x4; // int32_t
    constexpr std::ptrdiff_t m_segmentIndexArray = 0x8; // CUtlVector<int32_t>
}

namespace CAnimFrameSegment {
    constexpr std::ptrdiff_t m_nUniqueFrameIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nLocalElementMasks = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nLocalChannel = 0x8; // int32_t
    constexpr std::ptrdiff_t m_container = 0x10; // CUtlBinaryBlock
}

namespace CAnimGraphDebugReplay {
    constexpr std::ptrdiff_t m_animGraphFileName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_frameList = 0x48; // CUtlVector<CSmartPtr<CAnimReplayFrame>>
    constexpr std::ptrdiff_t m_startIndex = 0x60; // int32_t
    constexpr std::ptrdiff_t m_writeIndex = 0x64; // int32_t
    constexpr std::ptrdiff_t m_frameCount = 0x68; // int32_t
}

namespace CAnimGraphModelBinding {
    constexpr std::ptrdiff_t m_modelName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_pSharedData = 0x10; // CSmartPtr<CAnimUpdateSharedData>
}

namespace CAnimGraphNetworkSettings { // CAnimGraphSettingsGroup
    constexpr std::ptrdiff_t m_bNetworkingEnabled = 0x20; // bool
}

namespace CAnimGraphSettingsGroup {
}

namespace CAnimGraphSettingsManager {
    constexpr std::ptrdiff_t m_settingsGroups = 0x18; // CUtlVector<CSmartPtr<CAnimGraphSettingsGroup>>
}

namespace CAnimInputDamping {
    constexpr std::ptrdiff_t m_speedFunction = 0x8; // DampingSpeedFunction
    constexpr std::ptrdiff_t m_fSpeedScale = 0xC; // float
}

namespace CAnimKeyData {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_boneArray = 0x10; // CUtlVector<CAnimBone>
    constexpr std::ptrdiff_t m_userArray = 0x28; // CUtlVector<CAnimUser>
    constexpr std::ptrdiff_t m_morphArray = 0x40; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_nChannelElements = 0x58; // int32_t
    constexpr std::ptrdiff_t m_dataChannelArray = 0x60; // CUtlVector<CAnimDataChannelDesc>
}

namespace CAnimLocalHierarchy {
    constexpr std::ptrdiff_t m_sBone = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sNewParent = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nStartFrame = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nPeakFrame = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nTailFrame = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nEndFrame = 0x2C; // int32_t
}

namespace CAnimMorphDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
}

namespace CAnimMotorUpdaterBase {
    constexpr std::ptrdiff_t m_name = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDefault = 0x18; // bool
}

namespace CAnimMovement {
    constexpr std::ptrdiff_t endframe = 0x0; // int32_t
    constexpr std::ptrdiff_t motionflags = 0x4; // int32_t
    constexpr std::ptrdiff_t v0 = 0x8; // float
    constexpr std::ptrdiff_t v1 = 0xC; // float
    constexpr std::ptrdiff_t angle = 0x10; // float
    constexpr std::ptrdiff_t vector = 0x14; // Vector
    constexpr std::ptrdiff_t position = 0x20; // Vector
}

namespace CAnimNodePath {
    constexpr std::ptrdiff_t m_path = 0x0; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nCount = 0x2C; // int32_t
}

namespace CAnimParamHandle {
    constexpr std::ptrdiff_t m_type = 0x0; // AnimParamType_t
    constexpr std::ptrdiff_t m_index = 0x1; // uint8_t
}

namespace CAnimParamHandleMap {
    constexpr std::ptrdiff_t m_list = 0x0; // CUtlHashtable<uint16_t,int16_t>
}

namespace CAnimParameterBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x28; // AnimParamID
    constexpr std::ptrdiff_t m_componentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_bNetworkingRequested = 0x4C; // bool
    constexpr std::ptrdiff_t m_bIsReferenced = 0x4D; // bool
}

namespace CAnimParameterManagerUpdater {
    constexpr std::ptrdiff_t m_parameters = 0x18; // CUtlVector<CSmartPtr<CAnimParameterBase>>
    constexpr std::ptrdiff_t m_idToIndexMap = 0x30; // CUtlHashtable<AnimParamID,int32_t>
    constexpr std::ptrdiff_t m_nameToIndexMap = 0x50; // CUtlHashtable<CUtlString,int32_t>
    constexpr std::ptrdiff_t m_indexToHandle = 0x70; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_autoResetParams = 0x88; // CUtlVector<CUtlPair<CAnimParamHandle,CAnimVariant>>
    constexpr std::ptrdiff_t m_autoResetMap = 0xA0; // CUtlHashtable<CAnimParamHandle,int16_t>
}

namespace CAnimReplayFrame {
    constexpr std::ptrdiff_t m_inputDataBlocks = 0x10; // CUtlVector<CUtlBinaryBlock>
    constexpr std::ptrdiff_t m_instanceData = 0x28; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_startingLocalToWorldTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_localToWorldTransform = 0x60; // CTransform
    constexpr std::ptrdiff_t m_timeStamp = 0x80; // float
}

namespace CAnimScriptComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_hScript = 0x30; // AnimScriptHandle
}

namespace CAnimScriptManager {
    constexpr std::ptrdiff_t m_scriptInfo = 0x10; // CUtlVector<ScriptInfo_t>
}

namespace CAnimSequenceParams {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CAnimSkeleton {
    constexpr std::ptrdiff_t m_localSpaceTransforms = 0x10; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_modelSpaceTransforms = 0x28; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_boneNames = 0x40; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_parents = 0x70; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_feet = 0x88; // CUtlVector<CAnimFoot>
    constexpr std::ptrdiff_t m_morphNames = 0xA0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_lodBoneCounts = 0xB8; // CUtlVector<int32_t>
}

namespace CAnimStateMachineUpdater {
    constexpr std::ptrdiff_t m_states = 0x8; // CUtlVector<CStateUpdateData>
    constexpr std::ptrdiff_t m_transitions = 0x20; // CUtlVector<CTransitionUpdateData>
    constexpr std::ptrdiff_t m_startStateIndex = 0x50; // int32_t
}

namespace CAnimTagBase {
    constexpr std::ptrdiff_t m_name = 0x18; // CGlobalSymbol
    constexpr std::ptrdiff_t m_group = 0x20; // CGlobalSymbol
    constexpr std::ptrdiff_t m_tagID = 0x28; // AnimTagID
    constexpr std::ptrdiff_t m_bIsReferenced = 0x2C; // bool
}

namespace CAnimTagManagerUpdater {
    constexpr std::ptrdiff_t m_tags = 0x18; // CUtlVector<CSmartPtr<CAnimTagBase>>
}

namespace CAnimUpdateNodeBase {
    constexpr std::ptrdiff_t m_nodePath = 0x18; // CAnimNodePath
    constexpr std::ptrdiff_t m_networkMode = 0x48; // AnimNodeNetworkMode
    constexpr std::ptrdiff_t m_name = 0x50; // CUtlString
}

namespace CAnimUpdateNodeRef {
    constexpr std::ptrdiff_t m_nodeIndex = 0x8; // int32_t
}

namespace CAnimUpdateSharedData {
    constexpr std::ptrdiff_t m_nodes = 0x10; // CUtlVector<CSmartPtr<CAnimUpdateNodeBase>>
    constexpr std::ptrdiff_t m_nodeIndexMap = 0x28; // CUtlHashtable<CAnimNodePath,int32_t>
    constexpr std::ptrdiff_t m_components = 0x48; // CUtlVector<CSmartPtr<CAnimComponentUpdater>>
    constexpr std::ptrdiff_t m_pParamListUpdater = 0x60; // CSmartPtr<CAnimParameterManagerUpdater>
    constexpr std::ptrdiff_t m_pTagManagerUpdater = 0x68; // CSmartPtr<CAnimTagManagerUpdater>
    constexpr std::ptrdiff_t m_scriptManager = 0x70; // CSmartPtr<CAnimScriptManager>
    constexpr std::ptrdiff_t m_settings = 0x78; // CAnimGraphSettingsManager
    constexpr std::ptrdiff_t m_pStaticPoseCache = 0xA8; // CSmartPtr<CStaticPoseCacheBuilder>
    constexpr std::ptrdiff_t m_pSkeleton = 0xB0; // CSmartPtr<CAnimSkeleton>
    constexpr std::ptrdiff_t m_rootNodePath = 0xB8; // CAnimNodePath
}

namespace CAnimUser {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimUserDifference {
    constexpr std::ptrdiff_t m_name = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nType = 0x10; // int32_t
}

namespace CAnimationGraphVisualizerAxis { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_xWsTransform = 0x40; // CTransform
    constexpr std::ptrdiff_t m_flAxisSize = 0x60; // float
}

namespace CAnimationGraphVisualizerLine { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPositionStart = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsPositionEnd = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x60; // Color
}

namespace CAnimationGraphVisualizerPie { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsCenter = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_vWsStart = 0x50; // VectorAligned
    constexpr std::ptrdiff_t m_vWsEnd = 0x60; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x70; // Color
}

namespace CAnimationGraphVisualizerPrimitiveBase {
    constexpr std::ptrdiff_t m_Type = 0x8; // CAnimationGraphVisualizerPrimitiveType
    constexpr std::ptrdiff_t m_OwningAnimNodePaths = 0xC; // AnimNodeID[11]
    constexpr std::ptrdiff_t m_nOwningAnimNodePathCount = 0x38; // int32_t
}

namespace CAnimationGraphVisualizerSphere { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_flRadius = 0x50; // float
    constexpr std::ptrdiff_t m_Color = 0x54; // Color
}

namespace CAnimationGraphVisualizerText { // CAnimationGraphVisualizerPrimitiveBase
    constexpr std::ptrdiff_t m_vWsPosition = 0x40; // VectorAligned
    constexpr std::ptrdiff_t m_Color = 0x50; // Color
    constexpr std::ptrdiff_t m_Text = 0x58; // CUtlString
}

namespace CAnimationGroup {
    constexpr std::ptrdiff_t m_nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CBufferString
    constexpr std::ptrdiff_t m_localHAnimArray_Handle = 0x60; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimData>>
    constexpr std::ptrdiff_t m_includedGroupArray_Handle = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_directHSeqGroup_Handle = 0x90; // CStrongHandle<InfoForResourceTypeCSequenceGroupData>
    constexpr std::ptrdiff_t m_decodeKey = 0x98; // CAnimKeyData
    constexpr std::ptrdiff_t m_szScripts = 0x110; // CUtlVector<CBufferString>
}

namespace CAttachment {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_influenceNames = 0x8; // CUtlString[3]
    constexpr std::ptrdiff_t m_vInfluenceRotations = 0x20; // Quaternion[3]
    constexpr std::ptrdiff_t m_vInfluenceOffsets = 0x50; // Vector[3]
    constexpr std::ptrdiff_t m_influenceWeights = 0x74; // float[3]
    constexpr std::ptrdiff_t m_bInfluenceRootTransform = 0x80; // bool[3]
    constexpr std::ptrdiff_t m_nInfluences = 0x83; // uint8_t
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x84; // bool
}

namespace CAudioAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_clipName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_attachmentName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flVolume = 0x48; // float
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x4C; // bool
    constexpr std::ptrdiff_t m_bStopWhenGraphEnds = 0x4D; // bool
    constexpr std::ptrdiff_t m_bPlayOnServer = 0x4E; // bool
    constexpr std::ptrdiff_t m_bPlayOnClient = 0x4F; // bool
}

namespace CBaseConstraint { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_name = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vUpVector = 0x30; // Vector
    constexpr std::ptrdiff_t m_slaves = 0x40; // CUtlVector<CConstraintSlave>
    constexpr std::ptrdiff_t m_targets = 0x58; // CUtlVector<CConstraintTarget>
}

namespace CBinaryUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_pChild1 = 0x58; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_pChild2 = 0x68; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_timingBehavior = 0x78; // BinaryNodeTiming
    constexpr std::ptrdiff_t m_flTimingBlend = 0x7C; // float
    constexpr std::ptrdiff_t m_bResetChild1 = 0x80; // bool
    constexpr std::ptrdiff_t m_bResetChild2 = 0x81; // bool
}

namespace CBindPoseUpdateNode { // CLeafUpdateNode
}

namespace CBlend2DUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_items = 0x60; // CUtlVector<BlendItem_t>
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_paramSpans = 0x90; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_nodeItemIndices = 0xA8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_damping = 0xC0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSourceX = 0xD0; // AnimValueSource
    constexpr std::ptrdiff_t m_paramX = 0xD4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_blendSourceY = 0xD8; // AnimValueSource
    constexpr std::ptrdiff_t m_paramY = 0xDC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eBlendMode = 0xE0; // Blend2DMode
    constexpr std::ptrdiff_t m_playbackSpeed = 0xE4; // float
    constexpr std::ptrdiff_t m_bLoop = 0xE8; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xE9; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xEA; // bool
    constexpr std::ptrdiff_t m_bAnimEventsAndTagsOnMostWeightedOnly = 0xEB; // bool
}

namespace CBlendCurve {
    constexpr std::ptrdiff_t m_flControlPoint1 = 0x0; // float
    constexpr std::ptrdiff_t m_flControlPoint2 = 0x4; // float
}

namespace CBlendUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x60; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_sortedOrder = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_targetValues = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendValueSource = 0xAC; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0xB0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_damping = 0xB8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendKeyType = 0xC8; // BlendKeyType
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xCC; // bool
    constexpr std::ptrdiff_t m_bSyncCycles = 0xCD; // bool
    constexpr std::ptrdiff_t m_bLoop = 0xCE; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0xCF; // bool
}

namespace CBlockSelectionMetricEvaluator { // CMotionMetricEvaluator
}

namespace CBodyGroupAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_nPriority = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bodyGroupSettings = 0x40; // CUtlVector<CBodyGroupSetting>
}

namespace CBodyGroupSetting {
    constexpr std::ptrdiff_t m_BodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nBodyGroupOption = 0x8; // int32_t
}

namespace CBoneConstraintBase {
}

namespace CBoneConstraintDotToMorph { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sTargetBoneName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_sMorphChannelName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_flRemap = 0x40; // float[4]
}

namespace CBoneConstraintPoseSpaceBone { // CBaseConstraint
    constexpr std::ptrdiff_t m_inputList = 0x70; // CUtlVector<CBoneConstraintPoseSpaceBone::Input_t>
}

namespace CBoneConstraintPoseSpaceBone_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputTransformList = 0x10; // CUtlVector<CTransform>
}

namespace CBoneConstraintPoseSpaceMorph { // CBoneConstraintBase
    constexpr std::ptrdiff_t m_sBoneName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_sAttachmentName = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outputMorph = 0x38; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_inputList = 0x50; // CUtlVector<CBoneConstraintPoseSpaceMorph::Input_t>
    constexpr std::ptrdiff_t m_bClamp = 0x68; // bool
}

namespace CBoneConstraintPoseSpaceMorph_Input_t {
    constexpr std::ptrdiff_t m_inputValue = 0x0; // Vector
    constexpr std::ptrdiff_t m_outputWeightList = 0x10; // CUtlVector<float>
}

namespace CBoneMaskUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_flRootMotionBlend = 0x90; // float
    constexpr std::ptrdiff_t m_blendSpace = 0x94; // BoneMaskBlendSpace
    constexpr std::ptrdiff_t m_footMotionTiming = 0x98; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bUseBlendScale = 0x9C; // bool
    constexpr std::ptrdiff_t m_blendValueSource = 0xA0; // AnimValueSource
    constexpr std::ptrdiff_t m_hBlendParameter = 0xA4; // CAnimParamHandle
}

namespace CBonePositionMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoneVelocityMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_nBoneIndex = 0x50; // int32_t
}

namespace CBoolAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_bDefaultValue = 0x60; // bool
}

namespace CCPPScriptComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_scriptsToRun = 0x30; // CUtlVector<CGlobalSymbol>
}

namespace CCachedPose {
    constexpr std::ptrdiff_t m_transforms = 0x8; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_morphWeights = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_hSequence = 0x38; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x3C; // float
}

namespace CChoiceUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_weights = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_blendTimes = 0x88; // CUtlVector<float>
    constexpr std::ptrdiff_t m_choiceMethod = 0xA0; // ChoiceMethod
    constexpr std::ptrdiff_t m_choiceChangeMethod = 0xA4; // ChoiceChangeMethod
    constexpr std::ptrdiff_t m_blendMethod = 0xA8; // ChoiceBlendMethod
    constexpr std::ptrdiff_t m_blendTime = 0xAC; // float
    constexpr std::ptrdiff_t m_bCrossFade = 0xB0; // bool
    constexpr std::ptrdiff_t m_bResetChosen = 0xB1; // bool
    constexpr std::ptrdiff_t m_bDontResetSameSelection = 0xB2; // bool
}

namespace CChoreoUpdateNode { // CUnaryUpdateNode
}

namespace CClothSettingsAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_flStiffness = 0x38; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x3C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x40; // float
    constexpr std::ptrdiff_t m_nVertexSet = 0x48; // CUtlString
}

namespace CCompressorGroup {
    constexpr std::ptrdiff_t m_nTotalElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_szChannelClass = 0x8; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_szVariableName = 0x20; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_nType = 0x38; // CUtlVector<fieldtype_t>
    constexpr std::ptrdiff_t m_nFlags = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szGrouping = 0x68; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nCompressorIndex = 0x80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_szElementNames = 0x98; // CUtlVector<CUtlVector<char*>>
    constexpr std::ptrdiff_t m_nElementUniqueID = 0xB0; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_nElementMask = 0xC8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_vectorCompressor = 0xF8; // CUtlVector<CCompressor<Vector>*>
    constexpr std::ptrdiff_t m_quaternionCompressor = 0x110; // CUtlVector<CCompressor<QuaternionStorage>*>
    constexpr std::ptrdiff_t m_intCompressor = 0x128; // CUtlVector<CCompressor<int32_t>*>
    constexpr std::ptrdiff_t m_boolCompressor = 0x140; // CUtlVector<CCompressor<bool>*>
    constexpr std::ptrdiff_t m_colorCompressor = 0x158; // CUtlVector<CCompressor<Color>*>
    constexpr std::ptrdiff_t m_vector2DCompressor = 0x170; // CUtlVector<CCompressor<Vector2D>*>
    constexpr std::ptrdiff_t m_vector4DCompressor = 0x188; // CUtlVector<CCompressor<Vector4D>*>
}

namespace CConcreteAnimParameter { // CAnimParameterBase
    constexpr std::ptrdiff_t m_previewButton = 0x50; // AnimParamButton_t
    constexpr std::ptrdiff_t m_eNetworkSetting = 0x54; // AnimParamNetworkSetting
    constexpr std::ptrdiff_t m_bUseMostRecentValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bAutoReset = 0x59; // bool
    constexpr std::ptrdiff_t m_bGameWritable = 0x5A; // bool
    constexpr std::ptrdiff_t m_bGraphWritable = 0x5B; // bool
}

namespace CConstraintSlave {
    constexpr std::ptrdiff_t m_qBaseOrientation = 0x0; // Quaternion
    constexpr std::ptrdiff_t m_vBasePosition = 0x10; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x1C; // uint32_t
    constexpr std::ptrdiff_t m_flWeight = 0x20; // float
    constexpr std::ptrdiff_t m_sName = 0x28; // CUtlString
}

namespace CConstraintTarget {
    constexpr std::ptrdiff_t m_qOffset = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_vOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_nBoneHash = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_sName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_bIsAttachment = 0x59; // bool
}

namespace CCurrentRotationVelocityMetricEvaluator { // CMotionMetricEvaluator
}

namespace CCurrentVelocityMetricEvaluator { // CMotionMetricEvaluator
}

namespace CCycleBase {
    constexpr std::ptrdiff_t m_flCycle = 0x0; // float
}

namespace CCycleControlClipUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_tags = 0x60; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x7C; // HSequence
    constexpr std::ptrdiff_t m_duration = 0x80; // float
    constexpr std::ptrdiff_t m_valueSource = 0x84; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x88; // CAnimParamHandle
}

namespace CCycleControlUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_valueSource = 0x68; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x6C; // CAnimParamHandle
}

namespace CDampedPathAnimMotorUpdater { // CPathAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_flAnticipationTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flMinSpeedScale = 0x30; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flSpringConstant = 0x38; // float
    constexpr std::ptrdiff_t m_flMinSpringTension = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxSpringTension = 0x40; // float
}

namespace CDampedValueComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_items = 0x30; // CUtlVector<CDampedValueUpdateItem>
}

namespace CDampedValueUpdateItem {
    constexpr std::ptrdiff_t m_damping = 0x0; // CAnimInputDamping
    constexpr std::ptrdiff_t m_hParamIn = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hParamOut = 0x1A; // CAnimParamHandle
}

namespace CDemoSettingsComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_settings = 0x30; // CAnimDemoCaptureSettings
}

namespace CDirectPlaybackTagData {
    constexpr std::ptrdiff_t m_sequenceName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_tags = 0x8; // CUtlVector<TagSpan_t>
}

namespace CDirectPlaybackUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_bFinishEarly = 0x6C; // bool
    constexpr std::ptrdiff_t m_bResetOnFinish = 0x6D; // bool
    constexpr std::ptrdiff_t m_allTags = 0x70; // CUtlVector<CDirectPlaybackTagData>
}

namespace CDirectionalBlendUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_hSequences = 0x5C; // HSequence[8]
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendValueSource = 0x90; // AnimValueSource
    constexpr std::ptrdiff_t m_paramIndex = 0x94; // CAnimParamHandle
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
    constexpr std::ptrdiff_t m_bLockBlendOnReset = 0xA1; // bool
}

namespace CDistanceRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flMaxDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flMinDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flStartGoalFilterDistance = 0x58; // float
    constexpr std::ptrdiff_t m_flMaxGoalOvershootScale = 0x5C; // float
    constexpr std::ptrdiff_t m_bFilterFixedMinDistance = 0x60; // bool
    constexpr std::ptrdiff_t m_bFilterGoalDistance = 0x61; // bool
    constexpr std::ptrdiff_t m_bFilterGoalOvershoot = 0x62; // bool
}

namespace CDrawCullingData {
    constexpr std::ptrdiff_t m_vConeApex = 0x0; // Vector
    constexpr std::ptrdiff_t m_ConeAxis = 0xC; // int8_t[3]
    constexpr std::ptrdiff_t m_ConeCutoff = 0xF; // int8_t
}

namespace CEditableMotionGraph { // CMotionGraph
}

namespace CEmitTagActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_nTagIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bIsZeroDuration = 0x1C; // bool
}

namespace CEnumAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x68; // uint8_t
    constexpr std::ptrdiff_t m_enumOptions = 0x70; // CUtlVector<CUtlString>
}

namespace CExpressionActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_hScript = 0x1C; // AnimScriptHandle
}

namespace CFingerBone {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hingeAxis = 0x8; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x14; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x20; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x30; // float
    constexpr std::ptrdiff_t m_flRadius = 0x34; // float
}

namespace CFingerChain {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<CFingerSource>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<CFingerBone>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_tipParentBoneName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_vTipOffset = 0x40; // Vector
    constexpr std::ptrdiff_t m_metacarpalBoneName = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x58; // Vector
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x64; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x68; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x6C; // float
}

namespace CFingerSource {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace CFlexController {
    constexpr std::ptrdiff_t m_szName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_szType = 0x8; // CUtlString
    constexpr std::ptrdiff_t min = 0x10; // float
    constexpr std::ptrdiff_t max = 0x14; // float
}

namespace CFlexDesc {
    constexpr std::ptrdiff_t m_szFacs = 0x0; // CUtlString
}

namespace CFlexOp {
    constexpr std::ptrdiff_t m_OpCode = 0x0; // FlexOpCode_t
    constexpr std::ptrdiff_t m_Data = 0x4; // int32_t
}

namespace CFlexRule {
    constexpr std::ptrdiff_t m_nFlex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_FlexOps = 0x8; // CUtlVector<CFlexOp>
}

namespace CFloatAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_fDefaultValue = 0x60; // float
    constexpr std::ptrdiff_t m_fMinValue = 0x64; // float
    constexpr std::ptrdiff_t m_fMaxValue = 0x68; // float
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CFollowAttachmentUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // FollowAttachmentSettings_t
}

namespace CFollowPathUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flBlendOutTime = 0x6C; // float
    constexpr std::ptrdiff_t m_bBlockNonPathMovement = 0x70; // bool
    constexpr std::ptrdiff_t m_bStopFeetAtGoal = 0x71; // bool
    constexpr std::ptrdiff_t m_bScaleSpeed = 0x72; // bool
    constexpr std::ptrdiff_t m_flScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinAngle = 0x78; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x7C; // float
    constexpr std::ptrdiff_t m_flSpeedScaleBlending = 0x80; // float
    constexpr std::ptrdiff_t m_turnDamping = 0x88; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x98; // AnimValueSource
    constexpr std::ptrdiff_t m_hParam = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0xA0; // float
    constexpr std::ptrdiff_t m_bTurnToFace = 0xA4; // bool
}

namespace CFootAdjustmentUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_clips = 0x70; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hBasePoseCacheHandle = 0x88; // CPoseHandle
    constexpr std::ptrdiff_t m_facingTarget = 0x8C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnTimeMin = 0x90; // float
    constexpr std::ptrdiff_t m_flTurnTimeMax = 0x94; // float
    constexpr std::ptrdiff_t m_flStepHeightMax = 0x98; // float
    constexpr std::ptrdiff_t m_flStepHeightMaxAngle = 0x9C; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xA0; // bool
    constexpr std::ptrdiff_t m_bAnimationDriven = 0xA1; // bool
}

namespace CFootCycle { // CCycleBase
}

namespace CFootCycleDefinition {
    constexpr std::ptrdiff_t m_vStancePositionMS = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMidpointPositionMS = 0xC; // Vector
    constexpr std::ptrdiff_t m_flStanceDirectionMS = 0x18; // float
    constexpr std::ptrdiff_t m_vToStrideStartPos = 0x1C; // Vector
    constexpr std::ptrdiff_t m_stanceCycle = 0x28; // CAnimCycle
    constexpr std::ptrdiff_t m_footLiftCycle = 0x2C; // CFootCycle
    constexpr std::ptrdiff_t m_footOffCycle = 0x30; // CFootCycle
    constexpr std::ptrdiff_t m_footStrikeCycle = 0x34; // CFootCycle
    constexpr std::ptrdiff_t m_footLandCycle = 0x38; // CFootCycle
}

namespace CFootCycleMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
}

namespace CFootDefinition {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ankleBoneName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_toeBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vBallOffset = 0x18; // Vector
    constexpr std::ptrdiff_t m_vHeelOffset = 0x24; // Vector
    constexpr std::ptrdiff_t m_flFootLength = 0x30; // float
    constexpr std::ptrdiff_t m_flBindPoseDirectionMS = 0x34; // float
    constexpr std::ptrdiff_t m_flTraceHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x3C; // float
}

namespace CFootFallAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_foot = 0x38; // FootFallTagFoot_t
}

namespace CFootLockUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // FootLockPoseOpFixedSettings
    constexpr std::ptrdiff_t m_footSettings = 0xD0; // CUtlVector<FootFixedSettings>
    constexpr std::ptrdiff_t m_hipShiftDamping = 0xE8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_rootHeightDamping = 0xF8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flStrideCurveScale = 0x108; // float
    constexpr std::ptrdiff_t m_flStrideCurveLimitScale = 0x10C; // float
    constexpr std::ptrdiff_t m_flStepHeightIncreaseScale = 0x110; // float
    constexpr std::ptrdiff_t m_flStepHeightDecreaseScale = 0x114; // float
    constexpr std::ptrdiff_t m_flHipShiftScale = 0x118; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0x11C; // float
    constexpr std::ptrdiff_t m_flMaxRootHeightOffset = 0x120; // float
    constexpr std::ptrdiff_t m_flMinRootHeightOffset = 0x124; // float
    constexpr std::ptrdiff_t m_flTiltPlanePitchSpringStrength = 0x128; // float
    constexpr std::ptrdiff_t m_flTiltPlaneRollSpringStrength = 0x12C; // float
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x130; // bool
    constexpr std::ptrdiff_t m_bApplyHipShift = 0x131; // bool
    constexpr std::ptrdiff_t m_bModulateStepHeight = 0x132; // bool
    constexpr std::ptrdiff_t m_bResetChild = 0x133; // bool
    constexpr std::ptrdiff_t m_bEnableVerticalCurvedPaths = 0x134; // bool
    constexpr std::ptrdiff_t m_bEnableRootHeightDamping = 0x135; // bool
}

namespace CFootMotion {
    constexpr std::ptrdiff_t m_strides = 0x0; // CUtlVector<CFootStride>
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bAdditive = 0x20; // bool
}

namespace CFootPinningUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_poseOpFixedData = 0x70; // FootPinningPoseOpFixedData_t
    constexpr std::ptrdiff_t m_eTimingSource = 0xA0; // FootPinningTimingSource
    constexpr std::ptrdiff_t m_params = 0xA8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_bResetChild = 0xC0; // bool
}

namespace CFootPositionMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bIgnoreSlope = 0x68; // bool
}

namespace CFootStepTriggerUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_triggers = 0x68; // CUtlVector<FootStepTrigger>
    constexpr std::ptrdiff_t m_flTolerance = 0x84; // float
}

namespace CFootStride {
    constexpr std::ptrdiff_t m_definition = 0x0; // CFootCycleDefinition
    constexpr std::ptrdiff_t m_trajectories = 0x40; // CFootTrajectories
}

namespace CFootTrajectories {
    constexpr std::ptrdiff_t m_trajectories = 0x0; // CUtlVector<CFootTrajectory>
}

namespace CFootTrajectory {
    constexpr std::ptrdiff_t m_vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRotationOffset = 0xC; // float
    constexpr std::ptrdiff_t m_flProgression = 0x10; // float
}

namespace CFootstepLandedAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_FootstepType = 0x38; // FootstepLandedFootSoundType_t
    constexpr std::ptrdiff_t m_OverrideSoundName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DebugAnimSourceString = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_BoneName = 0x50; // CUtlString
}

namespace CFutureFacingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flTime = 0x54; // float
}

namespace CFutureVelocityMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_flDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flStoppingDistance = 0x54; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x58; // float
    constexpr std::ptrdiff_t m_eMode = 0x5C; // VelocityMetricMode
}

namespace CHitBox {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_sBoneName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_vMinBounds = 0x18; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x24; // Vector
    constexpr std::ptrdiff_t m_flShapeRadius = 0x30; // float
    constexpr std::ptrdiff_t m_nBoneNameHash = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_nGroupId = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nShapeType = 0x3C; // uint8_t
    constexpr std::ptrdiff_t m_bTranslationOnly = 0x3D; // bool
    constexpr std::ptrdiff_t m_CRC = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_cRenderColor = 0x44; // Color
    constexpr std::ptrdiff_t m_nHitBoxIndex = 0x48; // uint16_t
}

namespace CHitBoxSet {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_HitBoxes = 0x10; // CUtlVector<CHitBox>
    constexpr std::ptrdiff_t m_SourceFilename = 0x28; // CUtlString
}

namespace CHitBoxSetList {
    constexpr std::ptrdiff_t m_HitBoxSets = 0x0; // CUtlVector<CHitBoxSet>
}

namespace CHitReactUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x68; // HitReactFixedSettings_t
    constexpr std::ptrdiff_t m_triggerParam = 0xB4; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitBoneParam = 0xB6; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitOffsetParam = 0xB8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitDirectionParam = 0xBA; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hitStrengthParam = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flMinDelayBetweenHits = 0xC0; // float
    constexpr std::ptrdiff_t m_bResetChild = 0xC4; // bool
}

namespace CInputStreamUpdateNode { // CLeafUpdateNode
}

namespace CIntAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // int32_t
    constexpr std::ptrdiff_t m_minValue = 0x64; // int32_t
    constexpr std::ptrdiff_t m_maxValue = 0x68; // int32_t
}

namespace CJiggleBoneUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x68; // JiggleBoneSettingsList_t
}

namespace CJumpHelperUpdateNode { // CSequenceUpdateNode
    constexpr std::ptrdiff_t m_hTargetParam = 0xA8; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flOriginalJumpMovement = 0xAC; // Vector
    constexpr std::ptrdiff_t m_flOriginalJumpDuration = 0xB8; // float
    constexpr std::ptrdiff_t m_flJumpStartCycle = 0xBC; // float
    constexpr std::ptrdiff_t m_flJumpEndCycle = 0xC0; // float
    constexpr std::ptrdiff_t m_eCorrectionMethod = 0xC4; // JumpCorrectionMethod
    constexpr std::ptrdiff_t m_bTranslationAxis = 0xC8; // bool[3]
    constexpr std::ptrdiff_t m_bScaleSpeed = 0xCB; // bool
}

namespace CLODComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_nServerLOD = 0x30; // int32_t
}

namespace CLeafUpdateNode { // CAnimUpdateNodeBase
}

namespace CLeanMatrixUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_frameCorners = 0x5C; // int32_t[3][3]
    constexpr std::ptrdiff_t m_poses = 0x80; // CPoseHandle[9]
    constexpr std::ptrdiff_t m_damping = 0xA8; // CAnimInputDamping
    constexpr std::ptrdiff_t m_blendSource = 0xB8; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0xBC; // CAnimParamHandle
    constexpr std::ptrdiff_t m_verticalAxis = 0xC0; // Vector
    constexpr std::ptrdiff_t m_horizontalAxis = 0xCC; // Vector
    constexpr std::ptrdiff_t m_hSequence = 0xD8; // HSequence
    constexpr std::ptrdiff_t m_flMaxValue = 0xDC; // float
    constexpr std::ptrdiff_t m_nSequenceMaxFrame = 0xE0; // int32_t
}

namespace CLookAtUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedSettings = 0x70; // LookAtOpFixedSettings_t
    constexpr std::ptrdiff_t m_target = 0x138; // AnimVectorSource
    constexpr std::ptrdiff_t m_paramIndex = 0x13C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_weightParamIndex = 0x13E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bResetChild = 0x140; // bool
    constexpr std::ptrdiff_t m_bLockWhenWaning = 0x141; // bool
}

namespace CLookComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_hLookHeading = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookHeadingVelocity = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookPitch = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDistance = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookDirection = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTarget = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hLookTargetWorldSpace = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bNetworkLookTarget = 0x42; // bool
}

namespace CMaterialAttributeAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_AttributeName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_AttributeType = 0x40; // MatterialAttributeTagType_t
    constexpr std::ptrdiff_t m_flValue = 0x44; // float
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CMaterialDrawDescriptor {
    constexpr std::ptrdiff_t m_nPrimitiveType = 0x0; // RenderPrimitiveType_t
    constexpr std::ptrdiff_t m_nBaseVertex = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nVertexCount = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStartIndex = 0xC; // int32_t
    constexpr std::ptrdiff_t m_nIndexCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_flUvDensity = 0x14; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x18; // Vector
    constexpr std::ptrdiff_t m_flAlpha = 0x24; // float
    constexpr std::ptrdiff_t m_nFirstMeshlet = 0x2C; // uint32_t
    constexpr std::ptrdiff_t m_nNumMeshlets = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_indexBuffer = 0xB8; // CRenderBufferBinding
    constexpr std::ptrdiff_t m_material = 0xE0; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CMeshletDescriptor {
    constexpr std::ptrdiff_t m_PackedAABB = 0x0; // PackedAABB_t
    constexpr std::ptrdiff_t m_CullingData = 0x8; // CDrawCullingData
}

namespace CModelConfig {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_Elements = 0x8; // CUtlVector<CModelConfigElement*>
    constexpr std::ptrdiff_t m_bTopLevel = 0x20; // bool
}

namespace CModelConfigElement {
    constexpr std::ptrdiff_t m_ElementName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_NestedElements = 0x10; // CUtlVector<CModelConfigElement*>
}

namespace CModelConfigElement_AttachedModel { // CModelConfigElement
    constexpr std::ptrdiff_t m_InstanceName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_EntityClass = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_hModel = 0x58; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_vOffset = 0x60; // Vector
    constexpr std::ptrdiff_t m_aAngOffset = 0x6C; // QAngle
    constexpr std::ptrdiff_t m_AttachmentName = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_LocalAttachmentOffsetName = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_AttachmentType = 0x88; // ModelConfigAttachmentType_t
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x8C; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedColor = 0x8D; // bool
    constexpr std::ptrdiff_t m_bUserSpecifiedMaterialGroup = 0x8E; // bool
    constexpr std::ptrdiff_t m_bAcceptParentMaterialDrivenDecals = 0x8F; // bool
    constexpr std::ptrdiff_t m_BodygroupOnOtherModels = 0x90; // CUtlString
    constexpr std::ptrdiff_t m_MaterialGroupOnOtherModels = 0x98; // CUtlString
}

namespace CModelConfigElement_Command { // CModelConfigElement
    constexpr std::ptrdiff_t m_Command = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_Args = 0x50; // KeyValues3
}

namespace CModelConfigElement_RandomColor { // CModelConfigElement
    constexpr std::ptrdiff_t m_Gradient = 0x48; // CColorGradient
}

namespace CModelConfigElement_RandomPick { // CModelConfigElement
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_ChoiceWeights = 0x60; // CUtlVector<float>
}

namespace CModelConfigElement_SetBodygroup { // CModelConfigElement
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetBodygroupOnAttachedModels { // CModelConfigElement
    constexpr std::ptrdiff_t m_GroupName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_nChoice = 0x50; // int32_t
}

namespace CModelConfigElement_SetMaterialGroup { // CModelConfigElement
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetMaterialGroupOnAttachedModels { // CModelConfigElement
    constexpr std::ptrdiff_t m_MaterialGroupName = 0x48; // CUtlString
}

namespace CModelConfigElement_SetRenderColor { // CModelConfigElement
    constexpr std::ptrdiff_t m_Color = 0x48; // Color
}

namespace CModelConfigElement_UserPick { // CModelConfigElement
    constexpr std::ptrdiff_t m_Choices = 0x48; // CUtlVector<CUtlString>
}

namespace CModelConfigList {
    constexpr std::ptrdiff_t m_bHideMaterialGroupInTools = 0x0; // bool
    constexpr std::ptrdiff_t m_bHideRenderColorInTools = 0x1; // bool
    constexpr std::ptrdiff_t m_Configs = 0x8; // CUtlVector<CModelConfig*>
}

namespace CMoodVData {
    constexpr std::ptrdiff_t m_sModelName = 0x0; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_nMoodType = 0xE0; // MoodType_t
    constexpr std::ptrdiff_t m_animationLayers = 0xE8; // CUtlVector<MoodAnimationLayer_t>
}

namespace CMorphBundleData {
    constexpr std::ptrdiff_t m_flULeftSrc = 0x0; // float
    constexpr std::ptrdiff_t m_flVTopSrc = 0x4; // float
    constexpr std::ptrdiff_t m_offsets = 0x8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_ranges = 0x20; // CUtlVector<float>
}

namespace CMorphConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_sTargetMorph = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_nSlaveChannel = 0x78; // int32_t
    constexpr std::ptrdiff_t m_flMin = 0x7C; // float
    constexpr std::ptrdiff_t m_flMax = 0x80; // float
}

namespace CMorphData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_morphRectDatas = 0x8; // CUtlVector<CMorphRectData>
}

namespace CMorphRectData {
    constexpr std::ptrdiff_t m_nXLeftDst = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nYTopDst = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flUWidthSrc = 0x4; // float
    constexpr std::ptrdiff_t m_flVHeightSrc = 0x8; // float
    constexpr std::ptrdiff_t m_bundleDatas = 0x10; // CUtlVector<CMorphBundleData>
}

namespace CMorphSetData {
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_bundleTypes = 0x18; // CUtlVector<MorphBundleType_t>
    constexpr std::ptrdiff_t m_morphDatas = 0x30; // CUtlVector<CMorphData>
    constexpr std::ptrdiff_t m_pTextureAtlas = 0x48; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_FlexDesc = 0x50; // CUtlVector<CFlexDesc>
    constexpr std::ptrdiff_t m_FlexControllers = 0x68; // CUtlVector<CFlexController>
    constexpr std::ptrdiff_t m_FlexRules = 0x80; // CUtlVector<CFlexRule>
}

namespace CMotionDataSet {
    constexpr std::ptrdiff_t m_groups = 0x0; // CUtlVector<CMotionGraphGroup>
    constexpr std::ptrdiff_t m_nDimensionCount = 0x18; // int32_t
}

namespace CMotionGraph {
    constexpr std::ptrdiff_t m_paramSpans = 0x10; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_pRootNode = 0x40; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_nParameterCount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nConfigStartIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nConfigCount = 0x50; // int32_t
    constexpr std::ptrdiff_t m_bLoop = 0x54; // bool
}

namespace CMotionGraphConfig {
    constexpr std::ptrdiff_t m_paramValues = 0x0; // float[4]
    constexpr std::ptrdiff_t m_flDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nMotionIndex = 0x14; // MotionIndex
    constexpr std::ptrdiff_t m_nSampleStart = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nSampleCount = 0x1C; // int32_t
}

namespace CMotionGraphGroup {
    constexpr std::ptrdiff_t m_searchDB = 0x0; // CMotionSearchDB
    constexpr std::ptrdiff_t m_motionGraphs = 0xB8; // CUtlVector<CSmartPtr<CMotionGraph>>
    constexpr std::ptrdiff_t m_motionGraphConfigs = 0xD0; // CUtlVector<CMotionGraphConfig>
    constexpr std::ptrdiff_t m_sampleToConfig = 0xE8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hIsActiveScript = 0x100; // AnimScriptHandle
}

namespace CMotionGraphUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_pMotionGraph = 0x58; // CSmartPtr<CMotionGraph>
}

namespace CMotionMatchingUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_dataSet = 0x58; // CMotionDataSet
    constexpr std::ptrdiff_t m_metrics = 0x78; // CUtlVector<CSmartPtr<CMotionMetricEvaluator>>
    constexpr std::ptrdiff_t m_weights = 0x90; // CUtlVector<float>
    constexpr std::ptrdiff_t m_bSearchEveryTick = 0xE0; // bool
    constexpr std::ptrdiff_t m_flSearchInterval = 0xE4; // float
    constexpr std::ptrdiff_t m_bSearchWhenClipEnds = 0xE8; // bool
    constexpr std::ptrdiff_t m_bSearchWhenGoalChanges = 0xE9; // bool
    constexpr std::ptrdiff_t m_blendCurve = 0xEC; // CBlendCurve
    constexpr std::ptrdiff_t m_flSampleRate = 0xF4; // float
    constexpr std::ptrdiff_t m_flBlendTime = 0xF8; // float
    constexpr std::ptrdiff_t m_bLockClipWhenWaning = 0xFC; // bool
    constexpr std::ptrdiff_t m_flSelectionThreshold = 0x100; // float
    constexpr std::ptrdiff_t m_flReselectionTimeWindow = 0x104; // float
    constexpr std::ptrdiff_t m_bEnableRotationCorrection = 0x108; // bool
    constexpr std::ptrdiff_t m_bGoalAssist = 0x109; // bool
    constexpr std::ptrdiff_t m_flGoalAssistDistance = 0x10C; // float
    constexpr std::ptrdiff_t m_flGoalAssistTolerance = 0x110; // float
    constexpr std::ptrdiff_t m_distanceScale_Damping = 0x118; // CAnimInputDamping
    constexpr std::ptrdiff_t m_flDistanceScale_OuterRadius = 0x128; // float
    constexpr std::ptrdiff_t m_flDistanceScale_InnerRadius = 0x12C; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MaxScale = 0x130; // float
    constexpr std::ptrdiff_t m_flDistanceScale_MinScale = 0x134; // float
    constexpr std::ptrdiff_t m_bEnableDistanceScaling = 0x138; // bool
}

namespace CMotionMetricEvaluator {
    constexpr std::ptrdiff_t m_means = 0x18; // CUtlVector<float>
    constexpr std::ptrdiff_t m_standardDeviations = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flWeight = 0x48; // float
    constexpr std::ptrdiff_t m_nDimensionStartIndex = 0x4C; // int32_t
}

namespace CMotionNode {
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_id = 0x20; // AnimNodeID
}

namespace CMotionNodeBlend1D { // CMotionNode
    constexpr std::ptrdiff_t m_blendItems = 0x28; // CUtlVector<MotionBlendItem>
    constexpr std::ptrdiff_t m_nParamIndex = 0x40; // int32_t
}

namespace CMotionNodeSequence { // CMotionNode
    constexpr std::ptrdiff_t m_tags = 0x28; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x40; // HSequence
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x44; // float
}

namespace CMotionSearchDB {
    constexpr std::ptrdiff_t m_rootNode = 0x0; // CMotionSearchNode
    constexpr std::ptrdiff_t m_residualQuantizer = 0x80; // CProductQuantizer
    constexpr std::ptrdiff_t m_codeIndices = 0xA0; // CUtlVector<MotionDBIndex>
}

namespace CMotionSearchNode {
    constexpr std::ptrdiff_t m_children = 0x0; // CUtlVector<CMotionSearchNode*>
    constexpr std::ptrdiff_t m_quantizer = 0x18; // CVectorQuantizer
    constexpr std::ptrdiff_t m_sampleCodes = 0x38; // CUtlVector<CUtlVector<SampleCode>>
    constexpr std::ptrdiff_t m_sampleIndices = 0x50; // CUtlVector<CUtlVector<int32_t>>
    constexpr std::ptrdiff_t m_selectableSamples = 0x68; // CUtlVector<int32_t>
}

namespace CMovementComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_movementModes = 0x30; // CUtlVector<CMovementMode>
    constexpr std::ptrdiff_t m_motors = 0x48; // CUtlVector<CSmartPtr<CAnimMotorUpdaterBase>>
    constexpr std::ptrdiff_t m_facingDamping = 0x60; // CAnimInputDamping
    constexpr std::ptrdiff_t m_eDefaultFacingMode = 0x70; // FacingMode
    constexpr std::ptrdiff_t m_nDefaultMotorIndex = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_bMoveVarsDisabled = 0x80; // bool
    constexpr std::ptrdiff_t m_bNetworkPath = 0x81; // bool
    constexpr std::ptrdiff_t m_bNetworkFacing = 0x82; // bool
    constexpr std::ptrdiff_t m_paramHandles = 0x83; // CAnimParamHandle[30]
}

namespace CMovementMode {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flSpeed = 0x8; // float
}

namespace CMoverUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_damping = 0x70; // CAnimInputDamping
    constexpr std::ptrdiff_t m_facingTarget = 0x80; // AnimValueSource
    constexpr std::ptrdiff_t m_hMoveVecParam = 0x84; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hMoveHeadingParam = 0x86; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hTurnToFaceParam = 0x88; // CAnimParamHandle
    constexpr std::ptrdiff_t m_flTurnToFaceOffset = 0x8C; // float
    constexpr std::ptrdiff_t m_flTurnToFaceLimit = 0x90; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x94; // bool
    constexpr std::ptrdiff_t m_bApplyMovement = 0x95; // bool
    constexpr std::ptrdiff_t m_bOrientMovement = 0x96; // bool
    constexpr std::ptrdiff_t m_bApplyRotation = 0x97; // bool
    constexpr std::ptrdiff_t m_bLimitOnly = 0x98; // bool
}

namespace COrientConstraint { // CBaseConstraint
}

namespace CParamSpanUpdater {
    constexpr std::ptrdiff_t m_spans = 0x0; // CUtlVector<ParamSpan_t>
}

namespace CParentConstraint { // CBaseConstraint
}

namespace CParticleAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_hParticleSystem = 0x38; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_particleSystemName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_configName = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_bDetachFromOwner = 0x50; // bool
    constexpr std::ptrdiff_t m_bStopWhenTagEnds = 0x51; // bool
    constexpr std::ptrdiff_t m_bTagEndStopIsInstant = 0x52; // bool
    constexpr std::ptrdiff_t m_attachmentName = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_attachmentType = 0x60; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentCP1Name = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_attachmentCP1Type = 0x70; // ParticleAttachment_t
}

namespace CPathAnimMotorUpdater { // CPathAnimMotorUpdaterBase
}

namespace CPathAnimMotorUpdaterBase { // CAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_bLockToPath = 0x20; // bool
}

namespace CPathHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flStoppingRadius = 0x68; // float
    constexpr std::ptrdiff_t m_flStoppingSpeedScale = 0x6C; // float
}

namespace CPathMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_pathTimeSamples = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDistance = 0x68; // float
    constexpr std::ptrdiff_t m_bExtrapolateMovement = 0x6C; // bool
    constexpr std::ptrdiff_t m_flMinExtrapolationSpeed = 0x70; // float
}

namespace CPhysSurfaceProperties {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_baseNameHash = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_bHidden = 0x18; // bool
    constexpr std::ptrdiff_t m_description = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_physics = 0x28; // CPhysSurfacePropertiesPhysics
    constexpr std::ptrdiff_t m_audioSounds = 0x48; // CPhysSurfacePropertiesSoundNames
    constexpr std::ptrdiff_t m_audioParams = 0x88; // CPhysSurfacePropertiesAudio
}

namespace CPhysSurfacePropertiesAudio {
    constexpr std::ptrdiff_t m_reflectivity = 0x0; // float
    constexpr std::ptrdiff_t m_hardnessFactor = 0x4; // float
    constexpr std::ptrdiff_t m_roughnessFactor = 0x8; // float
    constexpr std::ptrdiff_t m_roughThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_hardThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_hardVelocityThreshold = 0x14; // float
    constexpr std::ptrdiff_t m_flStaticImpactVolume = 0x18; // float
    constexpr std::ptrdiff_t m_flOcclusionFactor = 0x1C; // float
}

namespace CPhysSurfacePropertiesPhysics {
    constexpr std::ptrdiff_t m_friction = 0x0; // float
    constexpr std::ptrdiff_t m_elasticity = 0x4; // float
    constexpr std::ptrdiff_t m_density = 0x8; // float
    constexpr std::ptrdiff_t m_thickness = 0xC; // float
    constexpr std::ptrdiff_t m_softContactFrequency = 0x10; // float
    constexpr std::ptrdiff_t m_softContactDampingRatio = 0x14; // float
    constexpr std::ptrdiff_t m_wheelDrag = 0x18; // float
}

namespace CPhysSurfacePropertiesSoundNames {
    constexpr std::ptrdiff_t m_impactSoft = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_impactHard = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_scrapeSmooth = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_scrapeRough = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bulletImpact = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_rolling = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_break = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_strain = 0x38; // CUtlString
}

namespace CPlayerInputAnimMotorUpdater { // CAnimMotorUpdaterBase
    constexpr std::ptrdiff_t m_sampleTimes = 0x20; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flSpringConstant = 0x3C; // float
    constexpr std::ptrdiff_t m_flAnticipationDistance = 0x40; // float
    constexpr std::ptrdiff_t m_hAnticipationPosParam = 0x44; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hAnticipationHeadingParam = 0x46; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bUseAcceleration = 0x48; // bool
}

namespace CPointConstraint { // CBaseConstraint
}

namespace CPoseHandle {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_eType = 0x2; // PoseType_t
}

namespace CProductQuantizer {
    constexpr std::ptrdiff_t m_subQuantizers = 0x0; // CUtlVector<CVectorQuantizer>
    constexpr std::ptrdiff_t m_nDimensions = 0x18; // int32_t
}

namespace CQuaternionAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Quaternion
    constexpr std::ptrdiff_t m_bInterpolate = 0x70; // bool
}

namespace CRagdollAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_nPoseControl = 0x38; // AnimPoseControl
    constexpr std::ptrdiff_t m_flFrequency = 0x3C; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x40; // float
    constexpr std::ptrdiff_t m_flDecayDuration = 0x44; // float
    constexpr std::ptrdiff_t m_flDecayBias = 0x48; // float
    constexpr std::ptrdiff_t m_bDestroy = 0x4C; // bool
}

namespace CRagdollComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_ragdollNodePaths = 0x30; // CUtlVector<CAnimNodePath>
    constexpr std::ptrdiff_t m_boneIndices = 0x48; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x60; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_weightLists = 0x78; // CUtlVector<WeightList>
    constexpr std::ptrdiff_t m_flSpringFrequencyMin = 0x90; // float
    constexpr std::ptrdiff_t m_flSpringFrequencyMax = 0x94; // float
    constexpr std::ptrdiff_t m_flMaxStretch = 0x98; // float
}

namespace CRagdollUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t m_poseControlMethod = 0x6C; // RagdollPoseControl
}

namespace CRenderBufferBinding {
    constexpr std::ptrdiff_t m_hBuffer = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nBindOffsetBytes = 0x10; // uint32_t
}

namespace CRenderMesh {
    constexpr std::ptrdiff_t m_sceneObjects = 0x10; // CUtlVectorFixedGrowable<CSceneObjectData>
    constexpr std::ptrdiff_t m_constraints = 0xA0; // CUtlVector<CBaseConstraint*>
    constexpr std::ptrdiff_t m_skeleton = 0xB8; // CRenderSkeleton
}

namespace CRenderSkeleton {
    constexpr std::ptrdiff_t m_bones = 0x0; // CUtlVector<RenderSkeletonBone_t>
    constexpr std::ptrdiff_t m_boneParents = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nBoneWeightCount = 0x48; // int32_t
}

namespace CRootUpdateNode { // CUnaryUpdateNode
}

namespace CSceneObjectData {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
    constexpr std::ptrdiff_t m_drawCalls = 0x18; // CUtlVector<CMaterialDrawDescriptor>
    constexpr std::ptrdiff_t m_drawBounds = 0x30; // CUtlVector<AABB_t>
    constexpr std::ptrdiff_t m_meshlets = 0x48; // CUtlVector<CMeshletDescriptor>
    constexpr std::ptrdiff_t m_vTintColor = 0x60; // Vector4D
}

namespace CSelectorUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_children = 0x58; // CUtlVector<CAnimUpdateNodeRef>
    constexpr std::ptrdiff_t m_tags = 0x70; // CUtlVector<int8_t>
    constexpr std::ptrdiff_t m_blendCurve = 0x8C; // CBlendCurve
    constexpr std::ptrdiff_t m_flBlendTime = 0x94; // CAnimValue<float>
    constexpr std::ptrdiff_t m_hParameter = 0x9C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eTagBehavior = 0xA0; // SelectorTagBehavior_t
    constexpr std::ptrdiff_t m_bResetOnChange = 0xA4; // bool
    constexpr std::ptrdiff_t m_bSyncCyclesOnChange = 0xA5; // bool
}

namespace CSeqAutoLayer {
    constexpr std::ptrdiff_t m_nLocalReference = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalPose = 0x2; // int16_t
    constexpr std::ptrdiff_t m_flags = 0x4; // CSeqAutoLayerFlag
    constexpr std::ptrdiff_t m_start = 0xC; // float
    constexpr std::ptrdiff_t m_peak = 0x10; // float
    constexpr std::ptrdiff_t m_tail = 0x14; // float
    constexpr std::ptrdiff_t m_end = 0x18; // float
}

namespace CSeqAutoLayerFlag {
    constexpr std::ptrdiff_t m_bPost = 0x0; // bool
    constexpr std::ptrdiff_t m_bSpline = 0x1; // bool
    constexpr std::ptrdiff_t m_bXFade = 0x2; // bool
    constexpr std::ptrdiff_t m_bNoBlend = 0x3; // bool
    constexpr std::ptrdiff_t m_bLocal = 0x4; // bool
    constexpr std::ptrdiff_t m_bPose = 0x5; // bool
    constexpr std::ptrdiff_t m_bFetchFrame = 0x6; // bool
    constexpr std::ptrdiff_t m_bSubtract = 0x7; // bool
}

namespace CSeqBoneMaskList {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x10; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneWeightArray = 0x28; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flDefaultMorphCtrlWeight = 0x40; // float
    constexpr std::ptrdiff_t m_morphCtrlWeightArray = 0x48; // CUtlVector<CUtlPair<CBufferString,float>>
}

namespace CSeqCmdLayer {
    constexpr std::ptrdiff_t m_cmd = 0x0; // int16_t
    constexpr std::ptrdiff_t m_nLocalReference = 0x2; // int16_t
    constexpr std::ptrdiff_t m_nLocalBonemask = 0x4; // int16_t
    constexpr std::ptrdiff_t m_nDstResult = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nSrcResult = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bSpline = 0xA; // bool
    constexpr std::ptrdiff_t m_flVar1 = 0xC; // float
    constexpr std::ptrdiff_t m_flVar2 = 0x10; // float
    constexpr std::ptrdiff_t m_nLineNumber = 0x14; // int16_t
}

namespace CSeqCmdSeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nFrameRangeSequence = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x26; // int16_t
    constexpr std::ptrdiff_t m_flFPS = 0x28; // float
    constexpr std::ptrdiff_t m_nSubCycles = 0x2C; // int16_t
    constexpr std::ptrdiff_t m_numLocalResults = 0x2E; // int16_t
    constexpr std::ptrdiff_t m_cmdLayerArray = 0x30; // CUtlVector<CSeqCmdLayer>
    constexpr std::ptrdiff_t m_eventArray = 0x48; // CUtlVector<CAnimEventDefinition>
    constexpr std::ptrdiff_t m_activityArray = 0x60; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_poseSettingArray = 0x78; // CUtlVector<CSeqPoseSetting>
}

namespace CSeqIKLock {
    constexpr std::ptrdiff_t m_flPosWeight = 0x0; // float
    constexpr std::ptrdiff_t m_flAngleWeight = 0x4; // float
    constexpr std::ptrdiff_t m_nLocalBone = 0x8; // int16_t
    constexpr std::ptrdiff_t m_bBonesOrientedAlongPositiveX = 0xA; // bool
}

namespace CSeqMultiFetch {
    constexpr std::ptrdiff_t m_flags = 0x0; // CSeqMultiFetchFlag
    constexpr std::ptrdiff_t m_localReferenceArray = 0x8; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_nGroupSize = 0x20; // int32_t[2]
    constexpr std::ptrdiff_t m_nLocalPose = 0x28; // int32_t[2]
    constexpr std::ptrdiff_t m_poseKeyArray0 = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_poseKeyArray1 = 0x48; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nLocalCyclePoseParameter = 0x60; // int32_t
    constexpr std::ptrdiff_t m_bCalculatePoseParameters = 0x64; // bool
}

namespace CSeqMultiFetchFlag {
    constexpr std::ptrdiff_t m_bRealtime = 0x0; // bool
    constexpr std::ptrdiff_t m_bCylepose = 0x1; // bool
    constexpr std::ptrdiff_t m_b0D = 0x2; // bool
    constexpr std::ptrdiff_t m_b1D = 0x3; // bool
    constexpr std::ptrdiff_t m_b2D = 0x4; // bool
    constexpr std::ptrdiff_t m_b2D_TRI = 0x5; // bool
}

namespace CSeqPoseParamDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flStart = 0x10; // float
    constexpr std::ptrdiff_t m_flEnd = 0x14; // float
    constexpr std::ptrdiff_t m_flLoop = 0x18; // float
    constexpr std::ptrdiff_t m_bLooping = 0x1C; // bool
}

namespace CSeqPoseSetting {
    constexpr std::ptrdiff_t m_sPoseParameter = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_sAttachment = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_sReferenceSequence = 0x20; // CBufferString
    constexpr std::ptrdiff_t m_flValue = 0x30; // float
    constexpr std::ptrdiff_t m_bX = 0x34; // bool
    constexpr std::ptrdiff_t m_bY = 0x35; // bool
    constexpr std::ptrdiff_t m_bZ = 0x36; // bool
    constexpr std::ptrdiff_t m_eType = 0x38; // int32_t
}

namespace CSeqS1SeqDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_fetch = 0x20; // CSeqMultiFetch
    constexpr std::ptrdiff_t m_nLocalWeightlist = 0x88; // int32_t
    constexpr std::ptrdiff_t m_autoLayerArray = 0x90; // CUtlVector<CSeqAutoLayer>
    constexpr std::ptrdiff_t m_IKLockArray = 0xA8; // CUtlVector<CSeqIKLock>
    constexpr std::ptrdiff_t m_transition = 0xC0; // CSeqTransition
    constexpr std::ptrdiff_t m_SequenceKeys = 0xC8; // KeyValues3
    constexpr std::ptrdiff_t m_LegacyKeyValueText = 0xD8; // CBufferString
    constexpr std::ptrdiff_t m_activityArray = 0xE8; // CUtlVector<CAnimActivity>
    constexpr std::ptrdiff_t m_footMotion = 0x100; // CUtlVector<CFootMotion>
}

namespace CSeqScaleSet {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_bRootOffset = 0x10; // bool
    constexpr std::ptrdiff_t m_vRootOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_nLocalBoneArray = 0x20; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_flBoneScaleArray = 0x38; // CUtlVector<float>
}

namespace CSeqSeqDescFlag {
    constexpr std::ptrdiff_t m_bLooping = 0x0; // bool
    constexpr std::ptrdiff_t m_bSnap = 0x1; // bool
    constexpr std::ptrdiff_t m_bAutoplay = 0x2; // bool
    constexpr std::ptrdiff_t m_bPost = 0x3; // bool
    constexpr std::ptrdiff_t m_bHidden = 0x4; // bool
    constexpr std::ptrdiff_t m_bMulti = 0x5; // bool
    constexpr std::ptrdiff_t m_bLegacyDelta = 0x6; // bool
    constexpr std::ptrdiff_t m_bLegacyWorldspace = 0x7; // bool
    constexpr std::ptrdiff_t m_bLegacyCyclepose = 0x8; // bool
    constexpr std::ptrdiff_t m_bLegacyRealtime = 0x9; // bool
    constexpr std::ptrdiff_t m_bModelDoc = 0xA; // bool
}

namespace CSeqSynthAnimDesc {
    constexpr std::ptrdiff_t m_sName = 0x0; // CBufferString
    constexpr std::ptrdiff_t m_flags = 0x10; // CSeqSeqDescFlag
    constexpr std::ptrdiff_t m_transition = 0x1C; // CSeqTransition
    constexpr std::ptrdiff_t m_nLocalBaseReference = 0x24; // int16_t
    constexpr std::ptrdiff_t m_nLocalBoneMask = 0x26; // int16_t
    constexpr std::ptrdiff_t m_activityArray = 0x28; // CUtlVector<CAnimActivity>
}

namespace CSeqTransition {
    constexpr std::ptrdiff_t m_flFadeInTime = 0x0; // float
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x4; // float
}

namespace CSequenceFinishedAnimTag { // CAnimTagBase
    constexpr std::ptrdiff_t m_sequenceName = 0x38; // CUtlString
}

namespace CSequenceGroupData {
    constexpr std::ptrdiff_t m_sName = 0x10; // CBufferString
    constexpr std::ptrdiff_t m_nFlags = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_localSequenceNameArray = 0x28; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localS1SeqDescArray = 0x40; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localMultiSeqDescArray = 0x58; // CUtlVector<CSeqS1SeqDesc>
    constexpr std::ptrdiff_t m_localSynthAnimDescArray = 0x70; // CUtlVector<CSeqSynthAnimDesc>
    constexpr std::ptrdiff_t m_localCmdSeqDescArray = 0x88; // CUtlVector<CSeqCmdSeqDesc>
    constexpr std::ptrdiff_t m_localBoneMaskArray = 0xA0; // CUtlVector<CSeqBoneMaskList>
    constexpr std::ptrdiff_t m_localScaleSetArray = 0xB8; // CUtlVector<CSeqScaleSet>
    constexpr std::ptrdiff_t m_localBoneNameArray = 0xD0; // CUtlVector<CBufferString>
    constexpr std::ptrdiff_t m_localNodeName = 0xE8; // CBufferString
    constexpr std::ptrdiff_t m_localPoseParamArray = 0xF8; // CUtlVector<CSeqPoseParamDesc>
    constexpr std::ptrdiff_t m_keyValues = 0x110; // KeyValues3
    constexpr std::ptrdiff_t m_localIKAutoplayLockArray = 0x120; // CUtlVector<CSeqIKLock>
}

namespace CSequenceUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_paramSpans = 0x60; // CParamSpanUpdater
    constexpr std::ptrdiff_t m_tags = 0x78; // CUtlVector<TagSpan_t>
    constexpr std::ptrdiff_t m_hSequence = 0x94; // HSequence
    constexpr std::ptrdiff_t m_playbackSpeed = 0x98; // float
    constexpr std::ptrdiff_t m_duration = 0x9C; // float
    constexpr std::ptrdiff_t m_bLoop = 0xA0; // bool
}

namespace CSetFacingUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_facingMode = 0x68; // FacingMode
    constexpr std::ptrdiff_t m_bResetChild = 0x6C; // bool
}

namespace CSetParameterActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_value = 0x1A; // CAnimVariant
}

namespace CSingleFrameUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_actions = 0x58; // CUtlVector<CSmartPtr<CAnimActionUpdater>>
    constexpr std::ptrdiff_t m_hPoseCacheHandle = 0x70; // CPoseHandle
    constexpr std::ptrdiff_t m_hSequence = 0x74; // HSequence
    constexpr std::ptrdiff_t m_flCycle = 0x78; // float
}

namespace CSkeletalInputUpdateNode { // CLeafUpdateNode
    constexpr std::ptrdiff_t m_fixedOpData = 0x58; // SkeletalInputOpFixedSettings_t
}

namespace CSlopeComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_flTraceDistance = 0x34; // float
    constexpr std::ptrdiff_t m_hSlopeAngle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleFront = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeAngleSide = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeHeading = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hSlopeNormal_WorldSpace = 0x42; // CAnimParamHandle
}

namespace CSlowDownOnSlopesUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flSlowDownStrength = 0x68; // float
}

namespace CSolveIKChainUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_targetHandles = 0x68; // CUtlVector<CSolveIKTargetHandle_t>
    constexpr std::ptrdiff_t m_opFixedData = 0x80; // SolveIKChainPoseOpFixedSettings_t
}

namespace CSolveIKTargetHandle_t {
    constexpr std::ptrdiff_t m_positionHandle = 0x0; // CAnimParamHandle
    constexpr std::ptrdiff_t m_orientationHandle = 0x2; // CAnimParamHandle
}

namespace CSpeedScaleUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_paramIndex = 0x68; // CAnimParamHandle
}

namespace CStanceOverrideUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_footStanceInfo = 0x68; // CUtlVector<StanceInfo_t>
    constexpr std::ptrdiff_t m_pStanceSourceNode = 0x80; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_hParameter = 0x90; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eMode = 0x94; // StanceOverrideMode
}

namespace CStanceScaleUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_hParam = 0x68; // CAnimParamHandle
}

namespace CStateActionUpdater {
    constexpr std::ptrdiff_t m_pAction = 0x0; // CSmartPtr<CAnimActionUpdater>
    constexpr std::ptrdiff_t m_eBehavior = 0x8; // StateActionBehavior
}

namespace CStateMachineComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_stateMachine = 0x30; // CAnimStateMachineUpdater
}

namespace CStateMachineUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_stateMachine = 0x68; // CAnimStateMachineUpdater
    constexpr std::ptrdiff_t m_stateData = 0xC0; // CUtlVector<CStateNodeStateData>
    constexpr std::ptrdiff_t m_transitionData = 0xD8; // CUtlVector<CStateNodeTransitionData>
    constexpr std::ptrdiff_t m_bBlockWaningTags = 0xF4; // bool
    constexpr std::ptrdiff_t m_bLockStateWhenWaning = 0xF5; // bool
}

namespace CStateNodeStateData {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CAnimUpdateNodeRef
    constexpr std::ptrdiff_t m_bExclusiveRootMotion = 0x0; // bitfield:1
}

namespace CStateNodeTransitionData {
    constexpr std::ptrdiff_t m_curve = 0x0; // CBlendCurve
    constexpr std::ptrdiff_t m_blendDuration = 0x8; // CAnimValue<float>
    constexpr std::ptrdiff_t m_resetCycleValue = 0x10; // CAnimValue<float>
    constexpr std::ptrdiff_t m_bReset = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_resetCycleOption = 0x0; // bitfield:3
}

namespace CStateUpdateData {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_hScript = 0x8; // AnimScriptHandle
    constexpr std::ptrdiff_t m_transitionIndices = 0x10; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_actions = 0x28; // CUtlVector<CStateActionUpdater>
    constexpr std::ptrdiff_t m_stateID = 0x40; // AnimStateID
    constexpr std::ptrdiff_t m_bIsStartState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsEndState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsPassthrough = 0x0; // bitfield:1
}

namespace CStaticPoseCache {
    constexpr std::ptrdiff_t m_poses = 0x10; // CUtlVector<CCachedPose>
    constexpr std::ptrdiff_t m_nBoneCount = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nMorphCount = 0x2C; // int32_t
}

namespace CStaticPoseCacheBuilder { // CStaticPoseCache
}

namespace CStepsRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_footIndices = 0x50; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_flMinStepsRemaining = 0x68; // float
}

namespace CStopAtGoalUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flOuterRadius = 0x6C; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70; // float
    constexpr std::ptrdiff_t m_flMaxScale = 0x74; // float
    constexpr std::ptrdiff_t m_flMinScale = 0x78; // float
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
}

namespace CStringAnimTag { // CAnimTagBase
}

namespace CSubtractUpdateNode { // CBinaryUpdateNode
    constexpr std::ptrdiff_t m_footMotionTiming = 0x8C; // BinaryNodeChildOption
    constexpr std::ptrdiff_t m_bApplyToFootMotion = 0x90; // bool
    constexpr std::ptrdiff_t m_bApplyChannelsSeparately = 0x91; // bool
    constexpr std::ptrdiff_t m_bUseModelSpace = 0x92; // bool
}

namespace CTaskStatusAnimTag { // CAnimTagBase
}

namespace CTiltTwistConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_nTargetAxis = 0x70; // int32_t
    constexpr std::ptrdiff_t m_nSlaveAxis = 0x74; // int32_t
}

namespace CTimeRemainingMetricEvaluator { // CMotionMetricEvaluator
    constexpr std::ptrdiff_t m_bMatchByTimeRemaining = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxTimeRemaining = 0x54; // float
    constexpr std::ptrdiff_t m_bFilterByTimeRemaining = 0x58; // bool
    constexpr std::ptrdiff_t m_flMinTimeRemaining = 0x5C; // float
}

namespace CToggleComponentActionUpdater { // CAnimActionUpdater
    constexpr std::ptrdiff_t m_componentID = 0x18; // AnimComponentID
    constexpr std::ptrdiff_t m_bSetEnabled = 0x1C; // bool
}

namespace CTransitionUpdateData {
    constexpr std::ptrdiff_t m_srcStateIndex = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_destStateIndex = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_bDisabled = 0x0; // bitfield:1
}

namespace CTurnHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_facingTarget = 0x6C; // AnimValueSource
    constexpr std::ptrdiff_t m_turnStartTimeOffset = 0x70; // float
    constexpr std::ptrdiff_t m_turnDuration = 0x74; // float
    constexpr std::ptrdiff_t m_bMatchChildDuration = 0x78; // bool
    constexpr std::ptrdiff_t m_manualTurnOffset = 0x7C; // float
    constexpr std::ptrdiff_t m_bUseManualTurnOffset = 0x80; // bool
}

namespace CTwistConstraint { // CBaseConstraint
    constexpr std::ptrdiff_t m_bInverse = 0x70; // bool
    constexpr std::ptrdiff_t m_qParentBindRotation = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qChildBindRotation = 0x90; // Quaternion
}

namespace CTwoBoneIKUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_opFixedData = 0x70; // TwoBoneIKSettings_t
}

namespace CUnaryUpdateNode { // CAnimUpdateNodeBase
    constexpr std::ptrdiff_t m_pChildNode = 0x58; // CAnimUpdateNodeRef
}

namespace CVPhysXSurfacePropertiesList {
    constexpr std::ptrdiff_t m_surfacePropertiesList = 0x0; // CUtlVector<CPhysSurfaceProperties*>
}

namespace CVRInputComponentUpdater { // CAnimComponentUpdater
    constexpr std::ptrdiff_t m_FingerCurl_Thumb = 0x34; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Index = 0x36; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Middle = 0x38; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Ring = 0x3A; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerCurl_Pinky = 0x3C; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Thumb_Index = 0x3E; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Index_Middle = 0x40; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Middle_Ring = 0x42; // CAnimParamHandle
    constexpr std::ptrdiff_t m_FingerSplay_Ring_Pinky = 0x44; // CAnimParamHandle
}

namespace CVectorAnimParameter { // CConcreteAnimParameter
    constexpr std::ptrdiff_t m_defaultValue = 0x60; // Vector
    constexpr std::ptrdiff_t m_bInterpolate = 0x6C; // bool
}

namespace CVectorQuantizer {
    constexpr std::ptrdiff_t m_centroidVectors = 0x0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nCentroids = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nDimensions = 0x1C; // int32_t
}

namespace CVirtualAnimParameter { // CAnimParameterBase
    constexpr std::ptrdiff_t m_expressionString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_eParamType = 0x58; // AnimParamType_t
}

namespace CVrSkeletalInputSettings {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<CWristBone>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<CFingerChain>
    constexpr std::ptrdiff_t m_name = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_eHand = 0x48; // AnimVRHand_t
}

namespace CWayPointHelperUpdateNode { // CUnaryUpdateNode
    constexpr std::ptrdiff_t m_flStartCycle = 0x6C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x70; // float
    constexpr std::ptrdiff_t m_bOnlyGoals = 0x74; // bool
    constexpr std::ptrdiff_t m_bPreventOvershoot = 0x75; // bool
    constexpr std::ptrdiff_t m_bPreventUndershoot = 0x76; // bool
}

namespace CWristBone {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vForwardLS = 0x8; // Vector
    constexpr std::ptrdiff_t m_vUpLS = 0x14; // Vector
    constexpr std::ptrdiff_t m_vOffset = 0x20; // Vector
}

namespace CZeroPoseUpdateNode { // CLeafUpdateNode
}

namespace ChainToSolveData_t {
    constexpr std::ptrdiff_t m_nChainIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_SolverSettings = 0x4; // IKSolverSettings_t
    constexpr std::ptrdiff_t m_TargetSettings = 0x10; // IKTargetSettings_t
    constexpr std::ptrdiff_t m_DebugSetting = 0x38; // SolveIKChainAnimNodeDebugSetting
    constexpr std::ptrdiff_t m_flDebugNormalizedValue = 0x3C; // float
    constexpr std::ptrdiff_t m_vDebugOffset = 0x40; // VectorAligned
}

namespace ConfigIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nConfig = 0x2; // uint16_t
}

namespace FingerBone_t {
    constexpr std::ptrdiff_t m_boneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_hingeAxis = 0x4; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos1 = 0x10; // Vector
    constexpr std::ptrdiff_t m_vCapsulePos2 = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinAngle = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngle = 0x2C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x30; // float
}

namespace FingerChain_t {
    constexpr std::ptrdiff_t m_targets = 0x0; // CUtlVector<FingerSource_t>
    constexpr std::ptrdiff_t m_bones = 0x18; // CUtlVector<FingerBone_t>
    constexpr std::ptrdiff_t m_vTipOffset = 0x30; // Vector
    constexpr std::ptrdiff_t m_vSplayHingeAxis = 0x3C; // Vector
    constexpr std::ptrdiff_t m_tipParentBoneIndex = 0x48; // int32_t
    constexpr std::ptrdiff_t m_metacarpalBoneIndex = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_flSplayMinAngle = 0x50; // float
    constexpr std::ptrdiff_t m_flSplayMaxAngle = 0x54; // float
    constexpr std::ptrdiff_t m_flFingerScaleRatio = 0x58; // float
}

namespace FingerSource_t {
    constexpr std::ptrdiff_t m_nFingerIndex = 0x0; // AnimVRFinger_t
    constexpr std::ptrdiff_t m_flFingerWeight = 0x4; // float
}

namespace FollowAttachmentSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_boneIndex = 0x80; // int32_t
    constexpr std::ptrdiff_t m_bMatchTranslation = 0x84; // bool
    constexpr std::ptrdiff_t m_bMatchRotation = 0x85; // bool
}

namespace FootFixedData_t {
    constexpr std::ptrdiff_t m_vToeOffset = 0x0; // VectorAligned
    constexpr std::ptrdiff_t m_vHeelOffset = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_nTargetBoneIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nAnkleBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nIKAnchorBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikChainIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_flMaxIKLength = 0x30; // float
    constexpr std::ptrdiff_t m_nFootIndex = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x40; // float
}

namespace FootFixedSettings {
    constexpr std::ptrdiff_t m_traceSettings = 0x0; // TraceSettings_t
    constexpr std::ptrdiff_t m_vFootBaseBindPosePositionMS = 0x10; // VectorAligned
    constexpr std::ptrdiff_t m_flFootBaseLength = 0x20; // float
    constexpr std::ptrdiff_t m_flMaxRotationLeft = 0x24; // float
    constexpr std::ptrdiff_t m_flMaxRotationRight = 0x28; // float
    constexpr std::ptrdiff_t m_footstepLandedTagIndex = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_bEnableTracing = 0x30; // bool
    constexpr std::ptrdiff_t m_flTraceAngleBlend = 0x34; // float
    constexpr std::ptrdiff_t m_nDisableTagIndex = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nFootIndex = 0x3C; // int32_t
}

namespace FootLockPoseOpFixedSettings {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_hipDampingSettings = 0x18; // CAnimInputDamping
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x28; // int32_t
    constexpr std::ptrdiff_t m_ikSolverType = 0x2C; // IKSolverType
    constexpr std::ptrdiff_t m_bApplyTilt = 0x30; // bool
    constexpr std::ptrdiff_t m_bApplyHipDrop = 0x31; // bool
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x32; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x33; // bool
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x34; // bool
    constexpr std::ptrdiff_t m_flMaxFootHeight = 0x38; // float
    constexpr std::ptrdiff_t m_flExtensionScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x40; // float
    constexpr std::ptrdiff_t m_bEnableLockBreaking = 0x44; // bool
    constexpr std::ptrdiff_t m_flLockBreakTolerance = 0x48; // float
    constexpr std::ptrdiff_t m_flLockBlendTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEnableStretching = 0x50; // bool
    constexpr std::ptrdiff_t m_flMaxStretchAmount = 0x54; // float
    constexpr std::ptrdiff_t m_flStretchExtensionScale = 0x58; // float
}

namespace FootPinningPoseOpFixedData_t {
    constexpr std::ptrdiff_t m_footInfo = 0x0; // CUtlVector<FootFixedData_t>
    constexpr std::ptrdiff_t m_flBlendTime = 0x18; // float
    constexpr std::ptrdiff_t m_flLockBreakDistance = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxLegTwist = 0x20; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x24; // int32_t
    constexpr std::ptrdiff_t m_bApplyLegTwistLimits = 0x28; // bool
    constexpr std::ptrdiff_t m_bApplyFootRotationLimits = 0x29; // bool
}

namespace FootStepTrigger {
    constexpr std::ptrdiff_t m_tags = 0x0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nFootIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_triggerPhase = 0x1C; // StepPhase
}

namespace HSequence {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace HitReactFixedSettings_t {
    constexpr std::ptrdiff_t m_nWeightListIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEffectedBoneCount = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flMaxImpactForce = 0x8; // float
    constexpr std::ptrdiff_t m_flMinImpactForce = 0xC; // float
    constexpr std::ptrdiff_t m_flWhipImpactScale = 0x10; // float
    constexpr std::ptrdiff_t m_flCounterRotationScale = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceFadeScale = 0x18; // float
    constexpr std::ptrdiff_t m_flPropagationScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flWhipDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flSpringStrength = 0x24; // float
    constexpr std::ptrdiff_t m_flWhipSpringStrength = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxAngleRadians = 0x2C; // float
    constexpr std::ptrdiff_t m_nHipBoneIndex = 0x30; // int32_t
    constexpr std::ptrdiff_t m_flHipBoneTranslationScale = 0x34; // float
    constexpr std::ptrdiff_t m_flHipDipSpringStrength = 0x38; // float
    constexpr std::ptrdiff_t m_flHipDipImpactScale = 0x3C; // float
    constexpr std::ptrdiff_t m_flHipDipDelay = 0x40; // float
}

namespace IKBoneNameAndIndex_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
}

namespace IKDemoCaptureSettings_t {
    constexpr std::ptrdiff_t m_parentBoneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_eMode = 0x8; // IKChannelMode
    constexpr std::ptrdiff_t m_ikChainName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneStart = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_oneBoneEnd = 0x20; // CUtlString
}

namespace IKSolverSettings_t {
    constexpr std::ptrdiff_t m_SolverType = 0x0; // IKSolverType
    constexpr std::ptrdiff_t m_nNumIterations = 0x4; // int32_t
}

namespace IKTargetSettings_t {
    constexpr std::ptrdiff_t m_TargetSource = 0x0; // IKTargetSource
    constexpr std::ptrdiff_t m_Bone = 0x8; // IKBoneNameAndIndex_t
    constexpr std::ptrdiff_t m_AnimgraphParameterNamePosition = 0x18; // AnimParamID
    constexpr std::ptrdiff_t m_AnimgraphParameterNameOrientation = 0x1C; // AnimParamID
    constexpr std::ptrdiff_t m_TargetCoordSystem = 0x20; // IKTargetCoordinateSystem
}

namespace JiggleBoneSettingsList_t {
    constexpr std::ptrdiff_t m_boneSettings = 0x0; // CUtlVector<JiggleBoneSettings_t>
}

namespace JiggleBoneSettings_t {
    constexpr std::ptrdiff_t m_nBoneIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flSpringStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flMaxTimeStep = 0x8; // float
    constexpr std::ptrdiff_t m_flDamping = 0xC; // float
    constexpr std::ptrdiff_t m_vBoundsMaxLS = 0x10; // Vector
    constexpr std::ptrdiff_t m_vBoundsMinLS = 0x1C; // Vector
    constexpr std::ptrdiff_t m_eSimSpace = 0x28; // JiggleBoneSimSpace
}

namespace LookAtBone_t {
    constexpr std::ptrdiff_t m_index = 0x0; // int32_t
    constexpr std::ptrdiff_t m_weight = 0x4; // float
}

namespace LookAtOpFixedSettings_t {
    constexpr std::ptrdiff_t m_attachment = 0x0; // CAnimAttachment
    constexpr std::ptrdiff_t m_damping = 0x80; // CAnimInputDamping
    constexpr std::ptrdiff_t m_bones = 0x90; // CUtlVector<LookAtBone_t>
    constexpr std::ptrdiff_t m_flYawLimit = 0xA8; // float
    constexpr std::ptrdiff_t m_flPitchLimit = 0xAC; // float
    constexpr std::ptrdiff_t m_flHysteresisInnerAngle = 0xB0; // float
    constexpr std::ptrdiff_t m_flHysteresisOuterAngle = 0xB4; // float
    constexpr std::ptrdiff_t m_bRotateYawForward = 0xB8; // bool
    constexpr std::ptrdiff_t m_bMaintainUpDirection = 0xB9; // bool
    constexpr std::ptrdiff_t m_bTargetIsPosition = 0xBA; // bool
    constexpr std::ptrdiff_t m_bUseHysteresis = 0xBB; // bool
}

namespace MaterialGroup_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_materials = 0x8; // CUtlVector<CStrongHandle<InfoForResourceTypeIMaterial2>>
}

namespace ModelBoneFlexDriverControl_t {
    constexpr std::ptrdiff_t m_nBoneComponent = 0x0; // ModelBoneFlexComponent_t
    constexpr std::ptrdiff_t m_flexController = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_flexControllerToken = 0x10; // uint32_t
    constexpr std::ptrdiff_t m_flMin = 0x14; // float
    constexpr std::ptrdiff_t m_flMax = 0x18; // float
}

namespace ModelBoneFlexDriver_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_boneNameToken = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_controls = 0x10; // CUtlVector<ModelBoneFlexDriverControl_t>
}

namespace ModelSkeletonData_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nParent = 0x18; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_boneSphere = 0x30; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlag = 0x48; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_bonePosParent = 0x60; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_boneRotParent = 0x78; // CUtlVector<QuaternionStorage>
    constexpr std::ptrdiff_t m_boneScaleParent = 0x90; // CUtlVector<float>
}

namespace MoodAnimationLayer_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bActiveListening = 0x8; // bool
    constexpr std::ptrdiff_t m_bActiveTalking = 0x9; // bool
    constexpr std::ptrdiff_t m_layerAnimations = 0x10; // CUtlVector<MoodAnimation_t>
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // CRangeFloat
    constexpr std::ptrdiff_t m_flDurationScale = 0x30; // CRangeFloat
    constexpr std::ptrdiff_t m_bScaleWithInts = 0x38; // bool
    constexpr std::ptrdiff_t m_flNextStart = 0x3C; // CRangeFloat
    constexpr std::ptrdiff_t m_flStartOffset = 0x44; // CRangeFloat
    constexpr std::ptrdiff_t m_flEndOffset = 0x4C; // CRangeFloat
    constexpr std::ptrdiff_t m_flFadeIn = 0x54; // float
    constexpr std::ptrdiff_t m_flFadeOut = 0x58; // float
}

namespace MoodAnimation_t {
    constexpr std::ptrdiff_t m_sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace MotionBlendItem {
    constexpr std::ptrdiff_t m_pChild = 0x0; // CSmartPtr<CMotionNode>
    constexpr std::ptrdiff_t m_flKeyValue = 0x8; // float
}

namespace MotionDBIndex {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // uint32_t
}

namespace MotionIndex {
    constexpr std::ptrdiff_t m_nGroup = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nMotion = 0x2; // uint16_t
}

namespace ParamSpanSample_t {
    constexpr std::ptrdiff_t m_value = 0x0; // CAnimVariant
    constexpr std::ptrdiff_t m_flCycle = 0x14; // float
}

namespace ParamSpan_t {
    constexpr std::ptrdiff_t m_samples = 0x0; // CUtlVector<ParamSpanSample_t>
    constexpr std::ptrdiff_t m_hParam = 0x18; // CAnimParamHandle
    constexpr std::ptrdiff_t m_eParamType = 0x1A; // AnimParamType_t
    constexpr std::ptrdiff_t m_flStartCycle = 0x1C; // float
    constexpr std::ptrdiff_t m_flEndCycle = 0x20; // float
}

namespace PermModelDataAnimatedMaterialAttribute_t {
    constexpr std::ptrdiff_t m_AttributeName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNumChannels = 0x8; // int32_t
}

namespace PermModelData_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modelInfo = 0x8; // PermModelInfo_t
    constexpr std::ptrdiff_t m_ExtParts = 0x60; // CUtlVector<PermModelExtPart_t>
    constexpr std::ptrdiff_t m_refMeshes = 0x78; // CUtlVector<CStrongHandle<InfoForResourceTypeCRenderMesh>>
    constexpr std::ptrdiff_t m_refMeshGroupMasks = 0x90; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refPhysGroupMasks = 0xA8; // CUtlVector<uint64_t>
    constexpr std::ptrdiff_t m_refLODGroupMasks = 0xC0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_lodGroupSwitchDistances = 0xD8; // CUtlVector<float>
    constexpr std::ptrdiff_t m_refPhysicsData = 0xF0; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refPhysicsHitboxData = 0x108; // CUtlVector<CStrongHandle<InfoForResourceTypeCPhysAggregateData>>
    constexpr std::ptrdiff_t m_refAnimGroups = 0x120; // CUtlVector<CStrongHandle<InfoForResourceTypeCAnimationGroup>>
    constexpr std::ptrdiff_t m_refSequenceGroups = 0x138; // CUtlVector<CStrongHandle<InfoForResourceTypeCSequenceGroupData>>
    constexpr std::ptrdiff_t m_meshGroups = 0x150; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_materialGroups = 0x168; // CUtlVector<MaterialGroup_t>
    constexpr std::ptrdiff_t m_nDefaultMeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_modelSkeleton = 0x188; // ModelSkeletonData_t
    constexpr std::ptrdiff_t m_remappingTable = 0x230; // CUtlVector<int16_t>
    constexpr std::ptrdiff_t m_remappingTableStarts = 0x248; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_boneFlexDrivers = 0x260; // CUtlVector<ModelBoneFlexDriver_t>
    constexpr std::ptrdiff_t m_pModelConfigList = 0x278; // CModelConfigList*
    constexpr std::ptrdiff_t m_BodyGroupsHiddenInTools = 0x280; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_refAnimIncludeModels = 0x298; // CUtlVector<CStrongHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_AnimatedMaterialAttributes = 0x2B0; // CUtlVector<PermModelDataAnimatedMaterialAttribute_t>
}

namespace PermModelExtPart_t {
    constexpr std::ptrdiff_t m_Transform = 0x0; // CTransform
    constexpr std::ptrdiff_t m_Name = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_nParent = 0x28; // int32_t
    constexpr std::ptrdiff_t m_refModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace PermModelInfo_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vHullMin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vHullMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_vViewMin = 0x1C; // Vector
    constexpr std::ptrdiff_t m_vViewMax = 0x28; // Vector
    constexpr std::ptrdiff_t m_flMass = 0x34; // float
    constexpr std::ptrdiff_t m_vEyePosition = 0x38; // Vector
    constexpr std::ptrdiff_t m_flMaxEyeDeflection = 0x44; // float
    constexpr std::ptrdiff_t m_sSurfaceProperty = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_keyValueText = 0x50; // CUtlString
}

namespace PhysSoftbodyDesc_t {
    constexpr std::ptrdiff_t m_ParticleBoneHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Particles = 0x18; // CUtlVector<RnSoftbodyParticle_t>
    constexpr std::ptrdiff_t m_Springs = 0x30; // CUtlVector<RnSoftbodySpring_t>
    constexpr std::ptrdiff_t m_Capsules = 0x48; // CUtlVector<RnSoftbodyCapsule_t>
    constexpr std::ptrdiff_t m_InitPose = 0x60; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_ParticleBoneName = 0x78; // CUtlVector<CUtlString>
}

namespace RenderSkeletonBone_t {
    constexpr std::ptrdiff_t m_boneName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_parentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_invBindPose = 0x10; // matrix3x4_t
    constexpr std::ptrdiff_t m_bbox = 0x40; // SkeletonBoneBounds_t
    constexpr std::ptrdiff_t m_flSphereRadius = 0x58; // float
}

namespace SampleCode {
    constexpr std::ptrdiff_t m_subCode = 0x0; // uint8_t[8]
}

namespace ScriptInfo_t {
    constexpr std::ptrdiff_t m_code = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_paramsModified = 0x8; // CUtlVector<CAnimParamHandle>
    constexpr std::ptrdiff_t m_proxyReadParams = 0x20; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_proxyWriteParams = 0x38; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_eScriptType = 0x50; // AnimScriptType
}

namespace SkeletalInputOpFixedSettings_t {
    constexpr std::ptrdiff_t m_wristBones = 0x0; // CUtlVector<WristBone_t>
    constexpr std::ptrdiff_t m_fingers = 0x18; // CUtlVector<FingerChain_t>
    constexpr std::ptrdiff_t m_outerKnuckle1 = 0x30; // int32_t
    constexpr std::ptrdiff_t m_outerKnuckle2 = 0x34; // int32_t
    constexpr std::ptrdiff_t m_eHand = 0x38; // AnimVRHand_t
    constexpr std::ptrdiff_t m_eMotionRange = 0x3C; // AnimVRHandMotionRange_t
    constexpr std::ptrdiff_t m_eTransformSource = 0x40; // AnimVrBoneTransformSource_t
    constexpr std::ptrdiff_t m_bEnableIK = 0x44; // bool
    constexpr std::ptrdiff_t m_bEnableCollision = 0x45; // bool
}

namespace SkeletonBoneBounds_t {
    constexpr std::ptrdiff_t m_vecCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_vecSize = 0xC; // Vector
}

namespace SolveIKChainPoseOpFixedSettings_t {
    constexpr std::ptrdiff_t m_ChainsToSolveData = 0x0; // CUtlVector<ChainToSolveData_t>
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x18; // bool
}

namespace StanceInfo_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_flDirection = 0xC; // float
}

namespace TagSpan_t {
    constexpr std::ptrdiff_t m_tagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_startCycle = 0x4; // float
    constexpr std::ptrdiff_t m_endCycle = 0x8; // float
}

namespace TraceSettings_t {
    constexpr std::ptrdiff_t m_flTraceHeight = 0x0; // float
    constexpr std::ptrdiff_t m_flTraceRadius = 0x4; // float
}

namespace TwoBoneIKSettings_t {
    constexpr std::ptrdiff_t m_endEffectorType = 0x0; // IkEndEffectorType
    constexpr std::ptrdiff_t m_endEffectorAttachment = 0x10; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetType = 0x90; // IkTargetType
    constexpr std::ptrdiff_t m_targetAttachment = 0xA0; // CAnimAttachment
    constexpr std::ptrdiff_t m_targetBoneIndex = 0x120; // int32_t
    constexpr std::ptrdiff_t m_hPositionParam = 0x124; // CAnimParamHandle
    constexpr std::ptrdiff_t m_hRotationParam = 0x126; // CAnimParamHandle
    constexpr std::ptrdiff_t m_bAlwaysUseFallbackHinge = 0x128; // bool
    constexpr std::ptrdiff_t m_vLsFallbackHingeAxis = 0x130; // VectorAligned
    constexpr std::ptrdiff_t m_nFixedBoneIndex = 0x140; // int32_t
    constexpr std::ptrdiff_t m_nMiddleBoneIndex = 0x144; // int32_t
    constexpr std::ptrdiff_t m_nEndBoneIndex = 0x148; // int32_t
    constexpr std::ptrdiff_t m_bMatchTargetOrientation = 0x14C; // bool
    constexpr std::ptrdiff_t m_bConstrainTwist = 0x14D; // bool
    constexpr std::ptrdiff_t m_flMaxTwist = 0x150; // float
}

namespace VPhysXAggregateData_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nRefCounter = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_bonesHash = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_boneNames = 0x20; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_indexNames = 0x38; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_indexHash = 0x50; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_bindPose = 0x68; // CUtlVector<matrix3x4a_t>
    constexpr std::ptrdiff_t m_parts = 0x80; // CUtlVector<VPhysXBodyPart_t>
    constexpr std::ptrdiff_t m_constraints2 = 0x98; // CUtlVector<VPhysXConstraint2_t>
    constexpr std::ptrdiff_t m_joints = 0xB0; // CUtlVector<VPhysXJoint_t>
    constexpr std::ptrdiff_t m_pFeModel = 0xC8; // PhysFeModelDesc_t*
    constexpr std::ptrdiff_t m_boneParents = 0xD0; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_surfacePropertyHashes = 0xE8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_collisionAttributes = 0x100; // CUtlVector<VPhysXCollisionAttributes_t>
    constexpr std::ptrdiff_t m_debugPartNames = 0x118; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_embeddedKeyvalues = 0x130; // CUtlString
}

namespace VPhysXBodyPart_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flMass = 0x4; // float
    constexpr std::ptrdiff_t m_rnShape = 0x8; // VPhysics2ShapeDef_t
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x80; // uint16_t
    constexpr std::ptrdiff_t m_nReserved = 0x82; // uint16_t
    constexpr std::ptrdiff_t m_flInertiaScale = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x8C; // float
    constexpr std::ptrdiff_t m_bOverrideMassCenter = 0x90; // bool
    constexpr std::ptrdiff_t m_vMassCenterOverride = 0x94; // Vector
}

namespace VPhysXCollisionAttributes_t {
    constexpr std::ptrdiff_t m_CollisionGroup = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_InteractAs = 0x8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractWith = 0x20; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_InteractExclude = 0x38; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CollisionGroupString = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_InteractAsStrings = 0x58; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractWithStrings = 0x70; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_InteractExcludeStrings = 0x88; // CUtlVector<CUtlString>
}

namespace VPhysXConstraint2_t {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nParent = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nChild = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_params = 0x8; // VPhysXConstraintParams_t
}

namespace VPhysXConstraintParams_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // int8_t
    constexpr std::ptrdiff_t m_nTranslateMotion = 0x1; // int8_t
    constexpr std::ptrdiff_t m_nRotateMotion = 0x2; // int8_t
    constexpr std::ptrdiff_t m_nFlags = 0x3; // int8_t
    constexpr std::ptrdiff_t m_anchor = 0x4; // Vector[2]
    constexpr std::ptrdiff_t m_axes = 0x1C; // QuaternionStorage[2]
    constexpr std::ptrdiff_t m_maxForce = 0x3C; // float
    constexpr std::ptrdiff_t m_maxTorque = 0x40; // float
    constexpr std::ptrdiff_t m_linearLimitValue = 0x44; // float
    constexpr std::ptrdiff_t m_linearLimitRestitution = 0x48; // float
    constexpr std::ptrdiff_t m_linearLimitSpring = 0x4C; // float
    constexpr std::ptrdiff_t m_linearLimitDamping = 0x50; // float
    constexpr std::ptrdiff_t m_twistLowLimitValue = 0x54; // float
    constexpr std::ptrdiff_t m_twistLowLimitRestitution = 0x58; // float
    constexpr std::ptrdiff_t m_twistLowLimitSpring = 0x5C; // float
    constexpr std::ptrdiff_t m_twistLowLimitDamping = 0x60; // float
    constexpr std::ptrdiff_t m_twistHighLimitValue = 0x64; // float
    constexpr std::ptrdiff_t m_twistHighLimitRestitution = 0x68; // float
    constexpr std::ptrdiff_t m_twistHighLimitSpring = 0x6C; // float
    constexpr std::ptrdiff_t m_twistHighLimitDamping = 0x70; // float
    constexpr std::ptrdiff_t m_swing1LimitValue = 0x74; // float
    constexpr std::ptrdiff_t m_swing1LimitRestitution = 0x78; // float
    constexpr std::ptrdiff_t m_swing1LimitSpring = 0x7C; // float
    constexpr std::ptrdiff_t m_swing1LimitDamping = 0x80; // float
    constexpr std::ptrdiff_t m_swing2LimitValue = 0x84; // float
    constexpr std::ptrdiff_t m_swing2LimitRestitution = 0x88; // float
    constexpr std::ptrdiff_t m_swing2LimitSpring = 0x8C; // float
    constexpr std::ptrdiff_t m_swing2LimitDamping = 0x90; // float
    constexpr std::ptrdiff_t m_goalPosition = 0x94; // Vector
    constexpr std::ptrdiff_t m_goalOrientation = 0xA0; // QuaternionStorage
    constexpr std::ptrdiff_t m_goalAngularVelocity = 0xB0; // Vector
    constexpr std::ptrdiff_t m_driveSpringX = 0xBC; // float
    constexpr std::ptrdiff_t m_driveSpringY = 0xC0; // float
    constexpr std::ptrdiff_t m_driveSpringZ = 0xC4; // float
    constexpr std::ptrdiff_t m_driveDampingX = 0xC8; // float
    constexpr std::ptrdiff_t m_driveDampingY = 0xCC; // float
    constexpr std::ptrdiff_t m_driveDampingZ = 0xD0; // float
    constexpr std::ptrdiff_t m_driveSpringTwist = 0xD4; // float
    constexpr std::ptrdiff_t m_driveSpringSwing = 0xD8; // float
    constexpr std::ptrdiff_t m_driveSpringSlerp = 0xDC; // float
    constexpr std::ptrdiff_t m_driveDampingTwist = 0xE0; // float
    constexpr std::ptrdiff_t m_driveDampingSwing = 0xE4; // float
    constexpr std::ptrdiff_t m_driveDampingSlerp = 0xE8; // float
    constexpr std::ptrdiff_t m_solverIterationCount = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_projectionLinearTolerance = 0xF0; // float
    constexpr std::ptrdiff_t m_projectionAngularTolerance = 0xF4; // float
}

namespace VPhysXJoint_t {
    constexpr std::ptrdiff_t m_nType = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nBody1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBody2 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_Frame1 = 0x10; // CTransform
    constexpr std::ptrdiff_t m_Frame2 = 0x30; // CTransform
    constexpr std::ptrdiff_t m_bEnableCollision = 0x50; // bool
    constexpr std::ptrdiff_t m_bEnableLinearLimit = 0x51; // bool
    constexpr std::ptrdiff_t m_LinearLimit = 0x54; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableLinearMotor = 0x5C; // bool
    constexpr std::ptrdiff_t m_vLinearTargetVelocity = 0x60; // Vector
    constexpr std::ptrdiff_t m_flMaxForce = 0x6C; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x70; // bool
    constexpr std::ptrdiff_t m_SwingLimit = 0x74; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x7C; // bool
    constexpr std::ptrdiff_t m_TwistLimit = 0x80; // VPhysXRange_t
    constexpr std::ptrdiff_t m_bEnableAngularMotor = 0x88; // bool
    constexpr std::ptrdiff_t m_vAngularTargetVelocity = 0x8C; // Vector
    constexpr std::ptrdiff_t m_flMaxTorque = 0x98; // float
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x9C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0xA0; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0xA4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0xA8; // float
    constexpr std::ptrdiff_t m_flFriction = 0xAC; // float
}

namespace VPhysXRange_t {
    constexpr std::ptrdiff_t m_flMin = 0x0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4; // float
}

namespace VPhysics2ShapeDef_t {
    constexpr std::ptrdiff_t m_spheres = 0x0; // CUtlVector<RnSphereDesc_t>
    constexpr std::ptrdiff_t m_capsules = 0x18; // CUtlVector<RnCapsuleDesc_t>
    constexpr std::ptrdiff_t m_hulls = 0x30; // CUtlVector<RnHullDesc_t>
    constexpr std::ptrdiff_t m_meshes = 0x48; // CUtlVector<RnMeshDesc_t>
    constexpr std::ptrdiff_t m_CollisionAttributeIndices = 0x60; // CUtlVector<uint16_t>
}

namespace WeightList {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_weights = 0x8; // CUtlVector<float>
}

namespace WristBone_t {
    constexpr std::ptrdiff_t m_xOffsetTransformMS = 0x0; // CTransform
    constexpr std::ptrdiff_t m_boneIndex = 0x20; // int32_t
}
```

`HPCS2/offset/client.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:53 +0000
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // C_NetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // C_NetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // C_NetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // C_NetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // C_NetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // C_NetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // C_UtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBaseAnimGraph { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0xCC1; // bool
    constexpr std::ptrdiff_t m_bSuppressAnimEventSounds = 0xCC3; // bool
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0xCD4; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vecForce = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_pClientsideRagdoll = 0xCF8; // CBaseAnimGraph*
    constexpr std::ptrdiff_t m_bBuiltRagdoll = 0xD00; // bool
    constexpr std::ptrdiff_t m_pRagdollPose = 0xD18; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0xD20; // bool
    constexpr std::ptrdiff_t m_bHasAnimatedMaterialAttributes = 0xD30; // bool
}

namespace CBaseAnimGraphController { // CSkeletonAnimationController
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x1320; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x1324; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x1328; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x132C; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x1334; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x1338; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x1339; // bool
    constexpr std::ptrdiff_t m_nPrevNewSequenceParity = 0x133A; // uint8_t
    constexpr std::ptrdiff_t m_nPrevResetEventsParity = 0x133B; // uint8_t
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x133C; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x1344; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x13E4; // AnimationUpdateListHandle_t
    constexpr std::ptrdiff_t m_hLastAnimEventSequence = 0x13E8; // HSequence
}

namespace CBasePlayerController { // C_BaseEntity
    constexpr std::ptrdiff_t m_nFinalPredictedTick = 0x548; // int32_t
    constexpr std::ptrdiff_t m_CommandContext = 0x550; // C_CommandContext
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x600; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x608; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x60C; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_hPredictedPawn = 0x610; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x614; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x618; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x620; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x638; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x63C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x640; // char[128]
    constexpr std::ptrdiff_t m_steamID = 0x6C8; // uint64_t
    constexpr std::ptrdiff_t m_bIsLocalPlayerController = 0x6D0; // bool
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x6D4; // uint32_t
}

namespace CBasePlayerVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeaponVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0xE80; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0xE88; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0xE8C; // matrix3x4_t
}

namespace CBodyComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x18C0; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint { // CBodyComponent
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance { // CBodyComponent
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget { // C_BaseTrigger
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0xCC8; // bool
}

namespace CBreachCharge { // C_CSWeaponBase
}

namespace CBreachChargeProjectile { // C_BaseGrenade
}

namespace CBumpMine { // C_CSWeaponBase
}

namespace CBumpMineProjectile { // C_BaseGrenade
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CCSGO_WingmanIntroCharacterPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace CCSGO_WingmanIntroCounterTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGO_WingmanIntroTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch { // CCSGameModeRules
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSGameModeRules_Noop { // CCSGameModeRules
}

namespace CCSGameModeRules_Scripted { // CCSGameModeRules
}

namespace CCSGameModeScript { // CBasePulseGraphInstance
}

namespace CCSObserver_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSObserver_MovementServices { // CPlayer_MovementServices
}

namespace CCSObserver_ObserverServices { // CPlayer_ObserverServices
    constexpr std::ptrdiff_t m_hLastObserverTarget = 0x58; // CEntityHandle
    constexpr std::ptrdiff_t m_vecObserverInterpolateOffset = 0x5C; // Vector
    constexpr std::ptrdiff_t m_vecObserverInterpStartPos = 0x68; // Vector
    constexpr std::ptrdiff_t m_flObsInterp_PathLength = 0x74; // float
    constexpr std::ptrdiff_t m_qObsInterp_OrientationStart = 0x80; // Quaternion
    constexpr std::ptrdiff_t m_qObsInterp_OrientationTravelDir = 0x90; // Quaternion
    constexpr std::ptrdiff_t m_obsInterpState = 0xA0; // ObserverInterpState_t
    constexpr std::ptrdiff_t m_bObserverInterpolationNeedsDeferredSetup = 0xA4; // bool
}

namespace CCSObserver_UseServices { // CPlayer_UseServices
}

namespace CCSObserver_ViewModelServices { // CPlayer_ViewModelServices
}

namespace CCSPlayerBase_CameraServices { // CPlayer_CameraServices
    constexpr std::ptrdiff_t m_iFOV = 0x210; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x214; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x21C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x220; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flLastShotFOV = 0x224; // float
}

namespace CCSPlayerController { // CBasePlayerController
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x700; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x708; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x710; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x718; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x720; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x724; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x730; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x734; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x738; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x73C; // bool
    constexpr std::ptrdiff_t m_flPreviousForceJoinTeamTime = 0x740; // GameTime_t
    constexpr std::ptrdiff_t m_szClan = 0x748; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSanitizedPlayerName = 0x750; // CUtlString
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x758; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x760; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x768; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x770; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x774; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x778; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x780; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x784; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x788; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x78C; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x790; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x794; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x7C4; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x7C8; // uint32_t
    constexpr std::ptrdiff_t m_bCannotBeKicked = 0x7CC; // bool
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x7CD; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x7CE; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x7CF; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7D1; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7D4; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7E0; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7E1; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7E2; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7E8; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7EC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7F0; // CHandle<C_CSObserverPawn>
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7F4; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7F8; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x800; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x801; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x802; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x804; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x808; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x80C; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x810; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x814; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x818; // C_NetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x830; // int32_t
    constexpr std::ptrdiff_t m_bIsPlayerNameDirty = 0x834; // bool
}

namespace CCSPlayerController_ActionTrackingServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // C_UtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x108; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x110; // uint32_t
}

namespace CCSPlayerController_DamageServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // C_UtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_iAccount = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_nPreviousAccount = 0x50; // int32_t
}

namespace CCSPlayerController_InventoryServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0x70; // C_UtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayer_ActionTrackingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x40; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x44; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x48; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0xA0; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0x40; // C_UtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_CameraServices { // CCSPlayerBase_CameraServices
    constexpr std::ptrdiff_t m_flDeathCamTilt = 0x228; // float
}

namespace CCSPlayer_GlowServices { // CPlayerPawnComponent
}

namespace CCSPlayer_HostageServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_ItemServices { // CPlayer_ItemServices
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices { // CPlayer_MovementServices_Humanoid
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x210; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x214; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x220; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x224; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x228; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x22C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x22D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x230; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x234; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x238; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x23C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x240; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x250; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x258; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x259; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x25A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x268; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x468; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x46C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x470; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x474; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x478; // float
    constexpr std::ptrdiff_t m_vecForward = 0x47C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x488; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x494; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4A0; // Vector
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4AC; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4B0; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4B4; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4B8; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4BC; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4C0; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4CC; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4D0; // float
    constexpr std::ptrdiff_t m_bUpdatePredictedOriginAfterDataUpdate = 0x4D4; // bool
    constexpr std::ptrdiff_t m_flHeightAtJumpStart = 0x4D8; // float
    constexpr std::ptrdiff_t m_flMaxJumpHeightThisJump = 0x4DC; // float
}

namespace CCSPlayer_PingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hPlayerPing = 0x40; // CHandle<C_BaseEntity>
}

namespace CCSPlayer_UseServices { // CPlayer_UseServices
}

namespace CCSPlayer_ViewModelServices { // CPlayer_ViewModelServices
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<C_BaseViewModel>[3]
}

namespace CCSPlayer_WaterServices { // CPlayer_WaterServices
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x40; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x44; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x50; // float
}

namespace CCSPlayer_WeaponServices { // CPlayer_WeaponServices
    constexpr std::ptrdiff_t m_flNextAttack = 0xC0; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xC4; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xC5; // bool
}

namespace CCSWeaponBaseVData { // CBasePlayerWeaponVData
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CClientAlphaProperty { // IClientAlphaProperty
    constexpr std::ptrdiff_t m_nRenderFX = 0x10; // uint8_t
    constexpr std::ptrdiff_t m_nRenderMode = 0x11; // uint8_t
    constexpr std::ptrdiff_t m_bAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShadowAlphaOverride = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nReserved = 0x0; // bitfield:6
    constexpr std::ptrdiff_t m_nAlpha = 0x13; // uint8_t
    constexpr std::ptrdiff_t m_nDesyncOffset = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nReserved2 = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeStart = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_nDistFadeEnd = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flFadeScale = 0x1C; // float
    constexpr std::ptrdiff_t m_flRenderFxStartTime = 0x20; // GameTime_t
    constexpr std::ptrdiff_t m_flRenderFxDuration = 0x24; // float
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CComicBook {
    constexpr std::ptrdiff_t m_CoverImage = 0x8; // CPanoramaImageName
    constexpr std::ptrdiff_t m_XmlFile = 0x18; // CUtlString
}

namespace CCompositeMaterialEditorDoc {
    constexpr std::ptrdiff_t m_nVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Points = 0x10; // CUtlVector<CompositeMaterialEditorPoint_t>
    constexpr std::ptrdiff_t m_KVthumbnail = 0x28; // KeyValues3
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDecalInfo {
    constexpr std::ptrdiff_t m_flAnimationScale = 0x0; // float
    constexpr std::ptrdiff_t m_flAnimationLifeSpan = 0x4; // float
    constexpr std::ptrdiff_t m_flPlaceTime = 0x8; // float
    constexpr std::ptrdiff_t m_flFadeStartTime = 0xC; // float
    constexpr std::ptrdiff_t m_flFadeDuration = 0x10; // float
    constexpr std::ptrdiff_t m_nVBSlot = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nBoneIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_vPosition = 0x28; // Vector
    constexpr std::ptrdiff_t m_flBoundingRadiusSqr = 0x34; // float
    constexpr std::ptrdiff_t m_pNext = 0x40; // CDecalInfo*
    constexpr std::ptrdiff_t m_pPrev = 0x48; // CDecalInfo*
    constexpr std::ptrdiff_t m_nDecalMaterialIndex = 0xA8; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEntityComponent {
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CFireOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_pOwner = 0xD0; // C_FireSmoke*
    constexpr std::ptrdiff_t m_vBaseColors = 0xD8; // Vector[4]
    constexpr std::ptrdiff_t m_flScale = 0x108; // float
    constexpr std::ptrdiff_t m_nGUID = 0x10C; // int32_t
}

namespace CFlashlightEffect {
    constexpr std::ptrdiff_t m_bIsOn = 0x10; // bool
    constexpr std::ptrdiff_t m_bMuzzleFlashEnabled = 0x20; // bool
    constexpr std::ptrdiff_t m_flMuzzleFlashBrightness = 0x24; // float
    constexpr std::ptrdiff_t m_quatMuzzleFlashOrientation = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_vecMuzzleFlashOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flFov = 0x4C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x50; // float
    constexpr std::ptrdiff_t m_flLinearAtten = 0x54; // float
    constexpr std::ptrdiff_t m_bCastsShadows = 0x58; // bool
    constexpr std::ptrdiff_t m_flCurrentPullBackDist = 0x5C; // float
    constexpr std::ptrdiff_t m_FlashlightTexture = 0x60; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_MuzzleFlashTexture = 0x68; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_textureName = 0x70; // char[64]
}

namespace CFuncWater { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC0; // CBuoyancyHelper
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGlobalLightBase {
    constexpr std::ptrdiff_t m_bSpotLight = 0x10; // bool
    constexpr std::ptrdiff_t m_SpotLightOrigin = 0x14; // Vector
    constexpr std::ptrdiff_t m_SpotLightAngles = 0x20; // QAngle
    constexpr std::ptrdiff_t m_ShadowDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_AmbientDirection = 0x38; // Vector
    constexpr std::ptrdiff_t m_SpecularDirection = 0x44; // Vector
    constexpr std::ptrdiff_t m_InspectorSpecularDirection = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSpecularPower = 0x5C; // float
    constexpr std::ptrdiff_t m_flSpecularIndependence = 0x60; // float
    constexpr std::ptrdiff_t m_SpecularColor = 0x64; // Color
    constexpr std::ptrdiff_t m_bStartDisabled = 0x68; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x69; // bool
    constexpr std::ptrdiff_t m_LightColor = 0x6A; // Color
    constexpr std::ptrdiff_t m_AmbientColor1 = 0x6E; // Color
    constexpr std::ptrdiff_t m_AmbientColor2 = 0x72; // Color
    constexpr std::ptrdiff_t m_AmbientColor3 = 0x76; // Color
    constexpr std::ptrdiff_t m_flSunDistance = 0x7C; // float
    constexpr std::ptrdiff_t m_flFOV = 0x80; // float
    constexpr std::ptrdiff_t m_flNearZ = 0x84; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x88; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x8C; // bool
    constexpr std::ptrdiff_t m_bOldEnableShadows = 0x8D; // bool
    constexpr std::ptrdiff_t m_bBackgroundClearNotRequired = 0x8E; // bool
    constexpr std::ptrdiff_t m_flCloudScale = 0x90; // float
    constexpr std::ptrdiff_t m_flCloud1Speed = 0x94; // float
    constexpr std::ptrdiff_t m_flCloud1Direction = 0x98; // float
    constexpr std::ptrdiff_t m_flCloud2Speed = 0x9C; // float
    constexpr std::ptrdiff_t m_flCloud2Direction = 0xA0; // float
    constexpr std::ptrdiff_t m_flAmbientScale1 = 0xB0; // float
    constexpr std::ptrdiff_t m_flAmbientScale2 = 0xB4; // float
    constexpr std::ptrdiff_t m_flGroundScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flLightScale = 0xBC; // float
    constexpr std::ptrdiff_t m_flFoWDarkness = 0xC0; // float
    constexpr std::ptrdiff_t m_bEnableSeparateSkyboxFog = 0xC4; // bool
    constexpr std::ptrdiff_t m_vFowColor = 0xC8; // Vector
    constexpr std::ptrdiff_t m_ViewOrigin = 0xD4; // Vector
    constexpr std::ptrdiff_t m_ViewAngles = 0xE0; // QAngle
    constexpr std::ptrdiff_t m_flViewFoV = 0xEC; // float
    constexpr std::ptrdiff_t m_WorldPoints = 0xF0; // Vector[8]
    constexpr std::ptrdiff_t m_vFogOffsetLayer0 = 0x4A8; // Vector2D
    constexpr std::ptrdiff_t m_vFogOffsetLayer1 = 0x4B0; // Vector2D
    constexpr std::ptrdiff_t m_hEnvWind = 0x4B8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEnvSky = 0x4BC; // CHandle<C_BaseEntity>
}

namespace CGlowOverlay {
    constexpr std::ptrdiff_t m_vPos = 0x8; // Vector
    constexpr std::ptrdiff_t m_bDirectional = 0x14; // bool
    constexpr std::ptrdiff_t m_vDirection = 0x18; // Vector
    constexpr std::ptrdiff_t m_bInSky = 0x24; // bool
    constexpr std::ptrdiff_t m_skyObstructionScale = 0x28; // float
    constexpr std::ptrdiff_t m_Sprites = 0x30; // CGlowSprite[4]
    constexpr std::ptrdiff_t m_nSprites = 0xB0; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0xB4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xB8; // float
    constexpr std::ptrdiff_t m_flGlowObstructionScale = 0xBC; // float
    constexpr std::ptrdiff_t m_bCacheGlowObstruction = 0xC0; // bool
    constexpr std::ptrdiff_t m_bCacheSkyObstruction = 0xC1; // bool
    constexpr std::ptrdiff_t m_bActivated = 0xC2; // int16_t
    constexpr std::ptrdiff_t m_ListIndex = 0xC4; // uint16_t
    constexpr std::ptrdiff_t m_queryHandle = 0xC8; // int32_t
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGlowSprite {
    constexpr std::ptrdiff_t m_vColor = 0x0; // Vector
    constexpr std::ptrdiff_t m_flHorzSize = 0xC; // float
    constexpr std::ptrdiff_t m_flVertSize = 0x10; // float
    constexpr std::ptrdiff_t m_hMaterial = 0x18; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace CGrenadeTracer { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flTracerDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_nType = 0xCE4; // GrenadeType_t
}

namespace CHitboxComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CHostageRescueZone { // CHostageRescueZoneShim
}

namespace CHostageRescueZoneShim { // C_BaseTrigger
}

namespace CInfoDynamicShadowHint { // C_PointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_flRange = 0x544; // float
    constexpr std::ptrdiff_t m_nImportance = 0x548; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x54C; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x550; // CHandle<C_BaseEntity>
}

namespace CInfoDynamicShadowHintBox { // CInfoDynamicShadowHint
    constexpr std::ptrdiff_t m_vBoxMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x564; // Vector
}

namespace CInfoOffscreenPanoramaTexture { // C_PointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x548; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x560; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x578; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x580; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0x6F8; // bool
}

namespace CInfoParticleTarget { // C_PointEntity
}

namespace CInfoTarget { // C_PointEntity
}

namespace CInfoWorldLayer { // C_BaseEntity
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x578; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x579; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x57A; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x57C; // uint32_t
    constexpr std::ptrdiff_t m_bWorldLayerActuallyVisible = 0x580; // bool
}

namespace CInterpolatedValue {
    constexpr std::ptrdiff_t m_flStartTime = 0x0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x4; // float
    constexpr std::ptrdiff_t m_flStartValue = 0x8; // float
    constexpr std::ptrdiff_t m_flEndValue = 0xC; // float
    constexpr std::ptrdiff_t m_nInterpType = 0x10; // int32_t
}

namespace CLightComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
}

namespace CLogicRelay { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTrigger = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x568; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x590; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x591; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x592; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x593; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x594; // bool
}

namespace CLogicalEntity { // C_BaseEntity
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace CPlayerSprayDecalRenderHelper {
}

namespace CPlayer_AutoaimServices { // CPlayerPawnComponent
}

namespace CPlayer_CameraServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // C_fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<C_ColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<C_TonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // C_NetworkUtlVectorBase<CHandle<C_PostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_CurrentFog = 0x140; // fogparams_t
    constexpr std::ptrdiff_t m_hOldFogController = 0x1A8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_bOverrideFogColor = 0x1AC; // bool[5]
    constexpr std::ptrdiff_t m_OverrideFogColor = 0x1B1; // Color[5]
    constexpr std::ptrdiff_t m_bOverrideFogStartEnd = 0x1C5; // bool[5]
    constexpr std::ptrdiff_t m_fOverrideFogStart = 0x1CC; // float[5]
    constexpr std::ptrdiff_t m_fOverrideFogEnd = 0x1E0; // float[5]
    constexpr std::ptrdiff_t m_hActivePostProcessingVolume = 0x1F4; // CHandle<C_PostProcessingVolume>
    constexpr std::ptrdiff_t m_angDemoViewAngles = 0x1F8; // QAngle
}

namespace CPlayer_FlashlightServices { // CPlayerPawnComponent
}

namespace CPlayer_ItemServices { // CPlayerPawnComponent
}

namespace CPlayer_MovementServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid { // CPlayer_MovementServices
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
}

namespace CPlayer_ObserverServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
    constexpr std::ptrdiff_t m_flObserverChaseDistance = 0x50; // float
    constexpr std::ptrdiff_t m_flObserverChaseDistanceCalcTime = 0x54; // GameTime_t
}

namespace CPlayer_UseServices { // CPlayerPawnComponent
}

namespace CPlayer_ViewModelServices { // CPlayerPawnComponent
}

namespace CPlayer_WaterServices { // CPlayerPawnComponent
}

namespace CPlayer_WeaponServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
}

namespace CPointOffScreenIndicatorUi { // C_PointClientUIWorldPanel
    constexpr std::ptrdiff_t m_bBeenEnabled = 0xF20; // bool
    constexpr std::ptrdiff_t m_bHide = 0xF21; // bool
    constexpr std::ptrdiff_t m_flSeenTargetTime = 0xF24; // float
    constexpr std::ptrdiff_t m_pTargetPanel = 0xF28; // C_PointClientUIWorldPanel*
}

namespace CPointTemplate { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszWorldName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x558; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x55C; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x588; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x58C; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x590; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x5A8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x5C0; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x5C8; // HSCRIPT
}

namespace CPrecipitationVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CProjectedTextureBase {
    constexpr std::ptrdiff_t m_hTargetEntity = 0xC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x10; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x11; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x14; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x18; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x19; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x1A; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x1B; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x1C; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x20; // float
    constexpr std::ptrdiff_t m_LightColor = 0x24; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x28; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x2C; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x30; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x34; // bool
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x38; // float
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x3C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x40; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x48; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x4C; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x50; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x54; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x258; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x25C; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x260; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x264; // float
    constexpr std::ptrdiff_t m_flRotation = 0x268; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x26C; // bool
}

namespace CRenderComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CSMatchStats_t { // CSPerRoundStats_t
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CServerOnlyModelEntity { // C_BaseModelEntity
}

namespace CSkeletonInstance { // CGameSceneNode
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkyboxReference { // C_BaseEntity
    constexpr std::ptrdiff_t m_worldGroupId = 0x540; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x544; // CHandle<C_SkyCamera>
}

namespace CTablet { // C_CSWeaponBase
}

namespace CTimeline { // IntervalTimer
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace CTripWireFire { // C_BaseCSGrenade
}

namespace CTripWireFireProjectile { // C_BaseGrenade
}

namespace CWaterSplasher { // C_BaseModelEntity
}

namespace CWeaponZoneRepulsor { // C_CSWeaponBaseGun
}

namespace C_AK47 { // C_CSWeaponBaseGun
}

namespace C_AttributeContainer { // CAttributeManager
    constexpr std::ptrdiff_t m_Item = 0x50; // C_EconItemView
    constexpr std::ptrdiff_t m_iExternalItemProviderRegisteredToken = 0x498; // int32_t
    constexpr std::ptrdiff_t m_ullRegisteredAsItemID = 0x4A0; // uint64_t
}

namespace C_BarnLight { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0xCC4; // int32_t
    constexpr std::ptrdiff_t m_Color = 0xCC8; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0xCCC; // float
    constexpr std::ptrdiff_t m_flBrightness = 0xCD0; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCD4; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0xCE4; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0xCE8; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0xCF0; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0xCF8; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0xD00; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0xD18; // C_NetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0xD30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0xD48; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0xDE8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0xDF0; // float
    constexpr std::ptrdiff_t m_flSoftX = 0xDF4; // float
    constexpr std::ptrdiff_t m_flSoftY = 0xDF8; // float
    constexpr std::ptrdiff_t m_flSkirt = 0xDFC; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0xE00; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0xE04; // Vector
    constexpr std::ptrdiff_t m_flRange = 0xE10; // float
    constexpr std::ptrdiff_t m_vShear = 0xE14; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0xE20; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0xE24; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0xE30; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0xE38; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0xE3C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0xE40; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0xE44; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0xE48; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0xE4C; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0xE58; // float
    constexpr std::ptrdiff_t m_nFog = 0xE5C; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0xE60; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0xE64; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0xE68; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0xE6C; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0xE70; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0xE74; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0xE78; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0xE7C; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0xE98; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0xEA4; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0xEB0; // Vector
}

namespace C_BaseButton { // C_BaseToggle
    constexpr std::ptrdiff_t m_glowEntity = 0xCC0; // CHandle<C_BaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0xCC4; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0xCC8; // CUtlSymbolLarge
}

namespace C_BaseCSGrenade { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_bClientPredictDelete = 0x19F0; // bool
    constexpr std::ptrdiff_t m_bRedraw = 0x19F1; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0x19F2; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0x19F3; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0x19F4; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0x19F8; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0x19FC; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0x1A00; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0x1A04; // float
    constexpr std::ptrdiff_t m_fDropTime = 0x1A08; // GameTime_t
}

namespace C_BaseCSGrenadeProjectile { // C_BaseGrenade
    constexpr std::ptrdiff_t m_vInitialPosition = 0x1068; // Vector
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x1074; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x1080; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x1088; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x1090; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x1094; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0x10A0; // GameTime_t
    constexpr std::ptrdiff_t vecLastTrailLinePos = 0x10A4; // Vector
    constexpr std::ptrdiff_t flNextTrailLineTime = 0x10B0; // GameTime_t
    constexpr std::ptrdiff_t m_bExplodeEffectBegan = 0x10B4; // bool
    constexpr std::ptrdiff_t m_bCanCreateGrenadeTrail = 0x10B5; // bool
    constexpr std::ptrdiff_t m_nSnapshotTrajectoryEffectIndex = 0x10B8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_hSnapshotTrajectoryParticleSnapshot = 0x10C0; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPoints = 0x10C8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_arrTrajectoryTrailPointCreationTimes = 0x10E0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_flTrajectoryTrailEffectCreationTime = 0x10F8; // float
}

namespace C_BaseClientUIEntity { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0xCC8; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0xCD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0xCD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0xCE0; // CUtlSymbolLarge
}

namespace C_BaseCombatCharacter { // C_BaseFlex
    constexpr std::ptrdiff_t m_hMyWearables = 0x1018; // C_NetworkUtlVectorBase<CHandle<C_EconWearable>>
    constexpr std::ptrdiff_t m_bloodColor = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_leftFootAttachment = 0x1034; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_rightFootAttachment = 0x1035; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nWaterWakeMode = 0x1038; // C_BaseCombatCharacter::WaterWakeMode_t
    constexpr std::ptrdiff_t m_flWaterWorldZ = 0x103C; // float
    constexpr std::ptrdiff_t m_flWaterNextTraceTime = 0x1040; // float
    constexpr std::ptrdiff_t m_flFieldOfView = 0x1044; // float
}

namespace C_BaseDoor { // C_BaseToggle
    constexpr std::ptrdiff_t m_bIsUsable = 0xCC0; // bool
}

namespace C_BaseEntity { // CEntityInstance
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x308; // GameTick_t
    constexpr std::ptrdiff_t m_pGameSceneNode = 0x310; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pRenderComponent = 0x318; // CRenderComponent*
    constexpr std::ptrdiff_t m_pCollision = 0x320; // CCollisionProperty*
    constexpr std::ptrdiff_t m_iMaxHealth = 0x328; // int32_t
    constexpr std::ptrdiff_t m_iHealth = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x330; // uint8_t
    constexpr std::ptrdiff_t m_bTakesDamage = 0x331; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x334; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x338; // uint8_t
    constexpr std::ptrdiff_t m_hSceneObjectController = 0x33C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nNoInterpolationTick = 0x340; // int32_t
    constexpr std::ptrdiff_t m_nVisibilityNoInterpolationTick = 0x344; // int32_t
    constexpr std::ptrdiff_t m_flProxyRandomValue = 0x348; // float
    constexpr std::ptrdiff_t m_iEFlags = 0x34C; // int32_t
    constexpr std::ptrdiff_t m_nWaterType = 0x350; // uint8_t
    constexpr std::ptrdiff_t m_bInterpolateEvenWithNoModel = 0x351; // bool
    constexpr std::ptrdiff_t m_bPredictionEligible = 0x352; // bool
    constexpr std::ptrdiff_t m_bApplyLayerMatchIDToModel = 0x353; // bool
    constexpr std::ptrdiff_t m_tokLayerMatchID = 0x354; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSubclassID = 0x358; // CUtlStringToken
    constexpr std::ptrdiff_t m_nSimulationTick = 0x368; // int32_t
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x36C; // int32_t
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x370; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_flAnimTime = 0x388; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x38C; // float
    constexpr std::ptrdiff_t m_nSceneObjectOverrideFlags = 0x390; // uint8_t
    constexpr std::ptrdiff_t m_bHasSuccessfullyInterpolated = 0x391; // bool
    constexpr std::ptrdiff_t m_bHasAddedVarsToInterpolation = 0x392; // bool
    constexpr std::ptrdiff_t m_bRenderEvenWhenNotSuccessfullyInterpolated = 0x393; // bool
    constexpr std::ptrdiff_t m_nInterpolationLatchDirtyFlags = 0x394; // int32_t[2]
    constexpr std::ptrdiff_t m_ListEntry = 0x39C; // uint16_t[11]
    constexpr std::ptrdiff_t m_flCreateTime = 0x3B4; // GameTime_t
    constexpr std::ptrdiff_t m_flSpeed = 0x3B8; // float
    constexpr std::ptrdiff_t m_EntClientFlags = 0x3BC; // uint16_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x3BE; // bool
    constexpr std::ptrdiff_t m_iTeamNum = 0x3BF; // uint8_t
    constexpr std::ptrdiff_t m_spawnflags = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x3C4; // GameTick_t
    constexpr std::ptrdiff_t m_fFlags = 0x3C8; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x3CC; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x3D8; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x408; // Vector
    constexpr std::ptrdiff_t m_hEffectEntity = 0x414; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x418; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_MoveCollide = 0x41C; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x41D; // MoveType_t
    constexpr std::ptrdiff_t m_flWaterLevel = 0x420; // float
    constexpr std::ptrdiff_t m_fEffects = 0x424; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x428; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x42C; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x430; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x434; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x438; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x43C; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x43D; // bool
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x440; // GameTime_t
    constexpr std::ptrdiff_t m_hThink = 0x444; // uint16_t
    constexpr std::ptrdiff_t m_fBBoxVisFlags = 0x450; // uint8_t
    constexpr std::ptrdiff_t m_bPredictable = 0x451; // bool
    constexpr std::ptrdiff_t m_bRenderWithViewModels = 0x452; // bool
    constexpr std::ptrdiff_t m_nSplitUserPlayerPredictionSlot = 0x454; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_nFirstPredictableCommand = 0x458; // int32_t
    constexpr std::ptrdiff_t m_nLastPredictableCommand = 0x45C; // int32_t
    constexpr std::ptrdiff_t m_hOldMoveParent = 0x460; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_Particles = 0x468; // CParticleProperty
    constexpr std::ptrdiff_t m_vecPredictedScriptFloats = 0x490; // CUtlVector<float>
    constexpr std::ptrdiff_t m_vecPredictedScriptFloatIDs = 0x4A8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_nNextScriptVarRecordID = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x4E8; // QAngle
    constexpr std::ptrdiff_t m_DataChangeEventRef = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_dependencies = 0x4F8; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_nCreationTick = 0x510; // int32_t
    constexpr std::ptrdiff_t m_bAnimTimeChanged = 0x529; // bool
    constexpr std::ptrdiff_t m_bSimulationTimeChanged = 0x52A; // bool
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x538; // CUtlString
}

namespace C_BaseFire { // C_BaseEntity
    constexpr std::ptrdiff_t m_flScale = 0x540; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x544; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x548; // float
    constexpr std::ptrdiff_t m_nFlags = 0x54C; // uint32_t
}

namespace C_BaseFlex { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_flexWeight = 0xE90; // C_NetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0xEA8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0xEC0; // bool
    constexpr std::ptrdiff_t m_nLastFlexUpdateFrameCount = 0xF20; // int32_t
    constexpr std::ptrdiff_t m_CachedViewTarget = 0xF24; // Vector
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0xF30; // uint32_t
    constexpr std::ptrdiff_t m_iBlink = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_blinktime = 0xF38; // float
    constexpr std::ptrdiff_t m_prevblinktoggle = 0xF3C; // bool
    constexpr std::ptrdiff_t m_iJawOpen = 0xF40; // int32_t
    constexpr std::ptrdiff_t m_flJawOpenAmount = 0xF44; // float
    constexpr std::ptrdiff_t m_flBlinkAmount = 0xF48; // float
    constexpr std::ptrdiff_t m_iMouthAttachment = 0xF4C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xF4D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bResetFlexWeightsOnModelChange = 0xF4E; // bool
    constexpr std::ptrdiff_t m_nEyeOcclusionRendererBone = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_mEyeOcclusionRendererCameraToBoneTransform = 0xF6C; // matrix3x4_t
    constexpr std::ptrdiff_t m_vEyeOcclusionRendererHalfExtent = 0xF9C; // Vector
    constexpr std::ptrdiff_t m_PhonemeClasses = 0xFB8; // C_BaseFlex::Emphasized_Phoneme[3]
}

namespace C_BaseFlex_Emphasized_Phoneme {
    constexpr std::ptrdiff_t m_sClassName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flAmount = 0x18; // float
    constexpr std::ptrdiff_t m_bRequired = 0x1C; // bool
    constexpr std::ptrdiff_t m_bBasechecked = 0x1D; // bool
    constexpr std::ptrdiff_t m_bValid = 0x1E; // bool
}

namespace C_BaseGrenade { // C_BaseFlex
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x1018; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x1019; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x101A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x101C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x1020; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x1024; // float
    constexpr std::ptrdiff_t m_flDamage = 0x1028; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x1030; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x1038; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x1044; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x105C; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x1060; // CHandle<C_CSPlayerPawn>
}

namespace C_BaseModelEntity { // C_BaseEntity
    constexpr std::ptrdiff_t m_CRenderComponent = 0xA10; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0xA18; // CHitboxComponent
    constexpr std::ptrdiff_t m_bInitModelEffects = 0xA60; // bool
    constexpr std::ptrdiff_t m_bIsStaticProp = 0xA61; // bool
    constexpr std::ptrdiff_t m_nLastAddDecal = 0xA64; // int32_t
    constexpr std::ptrdiff_t m_nDecalsAdded = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_iOldHealth = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_nRenderMode = 0xA70; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0xA71; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0xA72; // bool
    constexpr std::ptrdiff_t m_clrRender = 0xA73; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0xA78; // C_UtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0xAE0; // bool
    constexpr std::ptrdiff_t m_Collision = 0xAE8; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0xB98; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0xBF0; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0xBF4; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0xBF8; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0xBFC; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0xC00; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0xC04; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0xC0C; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0xC18; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0xC24; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0xC28; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0xC30; // C_NetworkUtlVectorBase<CHandle<C_BaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0xC48; // CNetworkViewOffsetVector
    constexpr std::ptrdiff_t m_pClientAlphaProperty = 0xC78; // CClientAlphaProperty*
    constexpr std::ptrdiff_t m_ClientOverrideTint = 0xC80; // Color
    constexpr std::ptrdiff_t m_bUseClientOverrideTint = 0xC84; // bool
}

namespace C_BasePlayerPawn { // C_BaseCombatCharacter
    constexpr std::ptrdiff_t m_pWeaponServices = 0x10A8; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x10B0; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x10B8; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x10C0; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x10C8; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x10D0; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0x10D8; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0x10E0; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0x10E8; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0x10F8; // C_UtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestConsumedServerViewAngleChangeIndex = 0x1148; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0x114C; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0x1158; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0x1164; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0x1168; // sky3dparams_t
    constexpr std::ptrdiff_t m_flDeathTime = 0x11F8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPredictionError = 0x11FC; // Vector
    constexpr std::ptrdiff_t m_flPredictionErrorTime = 0x1208; // GameTime_t
    constexpr std::ptrdiff_t m_vecLastCameraSetupLocalOrigin = 0x120C; // Vector
    constexpr std::ptrdiff_t m_flLastCameraSetupTime = 0x1218; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVSensitivityAdjust = 0x121C; // float
    constexpr std::ptrdiff_t m_flMouseSensitivity = 0x1220; // float
    constexpr std::ptrdiff_t m_vOldOrigin = 0x1224; // Vector
    constexpr std::ptrdiff_t m_flOldSimulationTime = 0x1230; // float
    constexpr std::ptrdiff_t m_nLastExecutedCommandNumber = 0x1234; // int32_t
    constexpr std::ptrdiff_t m_nLastExecutedCommandTick = 0x1238; // int32_t
    constexpr std::ptrdiff_t m_hController = 0x123C; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_bIsSwappingToPredictableController = 0x1240; // bool
}

namespace C_BasePlayerWeapon { // C_EconEntity
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0x1560; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0x1564; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0x1568; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0x156C; // float
    constexpr std::ptrdiff_t m_iClip1 = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0x1578; // int32_t[2]
}

namespace C_BasePropDoor { // C_DynamicProp
    constexpr std::ptrdiff_t m_eDoorState = 0x10F8; // DoorState_t
    constexpr std::ptrdiff_t m_modelChanged = 0x10FC; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x10FD; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0x1100; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0x110C; // QAngle
    constexpr std::ptrdiff_t m_hMaster = 0x1118; // CHandle<C_BasePropDoor>
    constexpr std::ptrdiff_t m_vWhereToSetLightingOrigin = 0x111C; // Vector
}

namespace C_BaseToggle { // C_BaseModelEntity
}

namespace C_BaseTrigger { // C_BaseToggle
    constexpr std::ptrdiff_t m_bDisabled = 0xCC0; // bool
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0xCC1; // bool
}

namespace C_BaseViewModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_vecLastFacing = 0xE88; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xE94; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0xE9C; // float
    constexpr std::ptrdiff_t m_hWeapon = 0xEA0; // CHandle<C_BasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0xEB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hWeaponModel = 0xEB8; // CHandle<C_ViewmodelWeapon>
    constexpr std::ptrdiff_t m_iCameraAttachment = 0xEBC; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_vecLastCameraAngles = 0xEC0; // QAngle
    constexpr std::ptrdiff_t m_previousElapsedDuration = 0xECC; // float
    constexpr std::ptrdiff_t m_previousCycle = 0xED0; // float
    constexpr std::ptrdiff_t m_nOldAnimationParity = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0xED8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0xEDC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0xEE0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0xEE4; // CHandle<C_BaseEntity>
}

namespace C_Beam { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flFrameRate = 0xCC0; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCC4; // float
    constexpr std::ptrdiff_t m_flFireTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0xCCC; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0xCD0; // uint8_t
    constexpr std::ptrdiff_t m_queryHandleHalo = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0xCF8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0xD00; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0xD08; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0xD0C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0xD10; // CHandle<C_BaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0xD38; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0xD44; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0xD48; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0xD4C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0xD50; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0xD54; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0xD58; // float
    constexpr std::ptrdiff_t m_fSpeed = 0xD5C; // float
    constexpr std::ptrdiff_t m_flFrame = 0xD60; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0xD64; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0xD68; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0xD78; // CHandle<C_BaseEntity>
}

namespace C_Breakable { // C_BaseModelEntity
}

namespace C_BreakableProp { // CBaseProp
    constexpr std::ptrdiff_t m_OnBreak = 0xEC8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0xEF0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0xF18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xF40; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0xF44; // int32_t
    constexpr std::ptrdiff_t m_flPressureDelay = 0xF48; // float
    constexpr std::ptrdiff_t m_hBreaker = 0xF4C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0xF50; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xF54; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xF58; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xF5C; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xF60; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xF68; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xF70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0xF78; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0xF7C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0xF80; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0xF84; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0xF88; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0xF90; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0xF98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0xFA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0xFA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0xFB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0xFB8; // CHandle<C_BasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0xFBC; // GameTime_t
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0xFC0; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0xFC4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0xFC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_noGhostCollision = 0xFCC; // bool
}

namespace C_BulletHitModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_matLocal = 0xE80; // matrix3x4_t
    constexpr std::ptrdiff_t m_iBoneIndex = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_hPlayerParent = 0xEB4; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bIsHit = 0xEB8; // bool
    constexpr std::ptrdiff_t m_flTimeCreated = 0xEBC; // float
    constexpr std::ptrdiff_t m_vecStartPos = 0xEC0; // Vector
}

namespace C_C4 { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_szScreenText = 0x19F0; // char[32]
    constexpr std::ptrdiff_t m_activeLightParticleIndex = 0x1A10; // ParticleIndex_t
    constexpr std::ptrdiff_t m_eActiveLightEffect = 0x1A14; // C4LightEffect_t
    constexpr std::ptrdiff_t m_bStartedArming = 0x1A18; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0x1A1C; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0x1A20; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0x1A21; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x1A28; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x1A40; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0x1A44; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0x1A4B; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0x1A4C; // bool
}

namespace C_CSGOViewModel { // C_PredictedViewModel
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0xF10; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0xF14; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0xF18; // uint32_t
    constexpr std::ptrdiff_t m_nLastKnownAssociatedWeaponEntIndex = 0xF1C; // CEntityIndex
    constexpr std::ptrdiff_t m_bNeedToQueueHighResComposite = 0xF20; // bool
    constexpr std::ptrdiff_t m_vLoweredWeaponOffset = 0xF64; // QAngle
}

namespace C_CSGO_CounterTerroristTeamIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_CounterTerroristWingmanIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_EndOfMatchCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_EndOfMatchCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_EndOfMatchLineupEnd { // C_CSGO_EndOfMatchLineupEndpoint
}

namespace C_CSGO_EndOfMatchLineupEndpoint { // C_BaseEntity
}

namespace C_CSGO_EndOfMatchLineupStart { // C_CSGO_EndOfMatchLineupEndpoint
}

namespace C_CSGO_MapPreviewCameraPath { // C_BaseEntity
    constexpr std::ptrdiff_t m_flZFar = 0x540; // float
    constexpr std::ptrdiff_t m_flZNear = 0x544; // float
    constexpr std::ptrdiff_t m_bLoop = 0x548; // bool
    constexpr std::ptrdiff_t m_bVerticalFOV = 0x549; // bool
    constexpr std::ptrdiff_t m_bConstantSpeed = 0x54A; // bool
    constexpr std::ptrdiff_t m_flDuration = 0x54C; // float
    constexpr std::ptrdiff_t m_flPathLength = 0x590; // float
    constexpr std::ptrdiff_t m_flPathDuration = 0x594; // float
}

namespace C_CSGO_MapPreviewCameraPathNode { // C_BaseEntity
    constexpr std::ptrdiff_t m_szParentPathUniqueID = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nPathIndex = 0x548; // int32_t
    constexpr std::ptrdiff_t m_vInTangentLocal = 0x54C; // Vector
    constexpr std::ptrdiff_t m_vOutTangentLocal = 0x558; // Vector
    constexpr std::ptrdiff_t m_flFOV = 0x564; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x568; // float
    constexpr std::ptrdiff_t m_flEaseIn = 0x56C; // float
    constexpr std::ptrdiff_t m_flEaseOut = 0x570; // float
    constexpr std::ptrdiff_t m_vInTangentWorld = 0x574; // Vector
    constexpr std::ptrdiff_t m_vOutTangentWorld = 0x580; // Vector
}

namespace C_CSGO_PreviewModel { // C_BaseFlex
    constexpr std::ptrdiff_t m_animgraph = 0x1018; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x1020; // CUtlString
    constexpr std::ptrdiff_t m_defaultAnim = 0x1028; // CUtlString
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x1030; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x1034; // float
}

namespace C_CSGO_PreviewModelAlias_csgo_item_previewmodel { // C_CSGO_PreviewModel
}

namespace C_CSGO_PreviewPlayer { // C_CSPlayerPawn
    constexpr std::ptrdiff_t m_animgraph = 0x22E8; // CUtlString
    constexpr std::ptrdiff_t m_animgraphCharacterModeString = 0x22F0; // CUtlString
    constexpr std::ptrdiff_t m_flInitialModelScale = 0x22F8; // float
}

namespace C_CSGO_PreviewPlayerAlias_csgo_player_previewmodel { // C_CSGO_PreviewPlayer
}

namespace C_CSGO_TeamIntroCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_TeamIntroCounterTerroristPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace C_CSGO_TeamIntroTerroristPosition { // C_CSGO_TeamIntroCharacterPosition
}

namespace C_CSGO_TeamPreviewCamera { // C_CSGO_MapPreviewCameraPath
    constexpr std::ptrdiff_t m_nVariant = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_bDofEnabled = 0x5A4; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x5AC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x5B0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x5B8; // float
}

namespace C_CSGO_TeamPreviewCharacterPosition { // C_BaseEntity
    constexpr std::ptrdiff_t m_nVariant = 0x540; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x544; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x548; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x550; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x558; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x560; // C_EconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x9A8; // C_EconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0xDF0; // C_EconItemView
}

namespace C_CSGO_TeamPreviewModel { // C_CSGO_PreviewPlayer
}

namespace C_CSGO_TeamSelectCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_TeamSelectCharacterPosition { // C_CSGO_TeamPreviewCharacterPosition
}

namespace C_CSGO_TeamSelectCounterTerroristPosition { // C_CSGO_TeamSelectCharacterPosition
}

namespace C_CSGO_TeamSelectTerroristPosition { // C_CSGO_TeamSelectCharacterPosition
}

namespace C_CSGO_TerroristTeamIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGO_TerroristWingmanIntroCamera { // C_CSGO_TeamPreviewCamera
}

namespace C_CSGameRules { // C_TeamplayRules
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bFreezePeriod = 0x30; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0x31; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0x40; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0x44; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x45; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0x46; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0x47; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0x48; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0x4C; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0x54; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0x58; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0x59; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0x60; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0x64; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0x68; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x6C; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x70; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x74; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x78; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x88; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x8C; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x8D; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x8E; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x8F; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x90; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x94; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x98; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x99; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x9A; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0xA4; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0xAC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x2AC; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x4AC; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x6AC; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x8AC; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x8B0; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x8B8; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x8B9; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x8BA; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x8C8; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x8D8; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x8DC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x8EC; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x8FC; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0x9C4; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0x9D4; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0x9D8; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0x9DC; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0x9DD; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0x9E4; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0x9E8; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0x9E9; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0x9EC; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0x9F0; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xA68; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xAE0; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xB58; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xBD8; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xC58; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xC5C; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xC68; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xC74; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xC94; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xC95; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xC98; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xCC0; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xCE8; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_bMarkClientStopRecordAtRoundEnd = 0xD10; // bool
    constexpr std::ptrdiff_t m_nMatchAbortedEarlyReason = 0xD68; // int32_t
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0xD6C; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0xD6D; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0xD6E; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0xD88; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_RetakeRules = 0xD90; // C_RetakeGameRules
    constexpr std::ptrdiff_t m_nMatchEndCount = 0xEA8; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0xEAC; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0xEB4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x4EC0; // double
}

namespace C_CSGameRulesProxy { // C_GameRulesProxy
    constexpr std::ptrdiff_t m_pGameRules = 0x540; // C_CSGameRules*
}

namespace C_CSMinimapBoundary { // C_BaseEntity
}

namespace C_CSObserverPawn { // C_CSPlayerPawnBase
    constexpr std::ptrdiff_t m_hDetectParentChange = 0x16B0; // CEntityHandle
}

namespace C_CSPlayerPawn { // C_CSPlayerPawnBase
    constexpr std::ptrdiff_t m_pBulletServices = 0x16B0; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x16B8; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x16C0; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pGlowServices = 0x16C8; // CCSPlayer_GlowServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x16D0; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x16D8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFiredWeaponTime = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x16E0; // bool
    constexpr std::ptrdiff_t m_flLandseconds = 0x16E4; // float
    constexpr std::ptrdiff_t m_flOldFallVelocity = 0x16E8; // float
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x16EC; // char[18]
    constexpr std::ptrdiff_t m_bPrevDefuser = 0x16FE; // bool
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x16FF; // bool
    constexpr std::ptrdiff_t m_nPrevArmorVal = 0x1700; // int32_t
    constexpr std::ptrdiff_t m_nPrevGrenadeAmmoCount = 0x1704; // int32_t
    constexpr std::ptrdiff_t m_unPreviousWeaponHash = 0x1708; // uint32_t
    constexpr std::ptrdiff_t m_unWeaponHash = 0x170C; // uint32_t
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1710; // bool
    constexpr std::ptrdiff_t m_bPreviouslyInBuyZone = 0x1711; // bool
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1714; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1720; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x172C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x1730; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x1738; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bInLanding = 0x1758; // bool
    constexpr std::ptrdiff_t m_flLandingTime = 0x175C; // float
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1760; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1761; // bool
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x1762; // bool
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1764; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1768; // GameTime_t
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1880; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x1884; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1888; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1889; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x188C; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1890; // loadout_slot_t
    constexpr std::ptrdiff_t m_bNeedToReApplyGloves = 0x18B0; // bool
    constexpr std::ptrdiff_t m_EconGloves = 0x18B8; // C_EconItemView
    constexpr std::ptrdiff_t m_bMustSyncRagdollState = 0x1D00; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1D04; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1D08; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1D14; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1D20; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1D60; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1D64; // Vector
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x22B0; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x22B4; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x22B8; // bool
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x22D4; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x22E0; // bool
}

namespace C_CSPlayerPawnBase { // C_BasePlayerPawn
    constexpr std::ptrdiff_t m_pPingServices = 0x1268; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0x1270; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_fRenderingClipPlane = 0x1278; // float[4]
    constexpr std::ptrdiff_t m_nLastClipPlaneSetupFrame = 0x1288; // int32_t
    constexpr std::ptrdiff_t m_vecLastClipCameraPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_vecLastClipCameraForward = 0x1298; // Vector
    constexpr std::ptrdiff_t m_bClipHitStaticWorld = 0x12A4; // bool
    constexpr std::ptrdiff_t m_bCachedPlaneIsValid = 0x12A5; // bool
    constexpr std::ptrdiff_t m_pClippingWeapon = 0x12A8; // C_CSWeaponBase*
    constexpr std::ptrdiff_t m_previousPlayerState = 0x12B0; // CSPlayerState
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x12B4; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x12B8; // float
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x12D8; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x12DC; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x12EC; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x12F8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x1304; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x131C; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x1334; // Vector[2]
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1350; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x1368; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x1378; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x1388; // Vector
    constexpr std::ptrdiff_t m_bIsScoped = 0x13A0; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0x13A1; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0x13A2; // bool
    constexpr std::ptrdiff_t m_iPlayerState = 0x13A4; // CSPlayerState
    constexpr std::ptrdiff_t m_bIsDefusing = 0x13A8; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0x13A9; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0x13AC; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_bIsRescuing = 0x13B0; // bool
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0x13B4; // GameTime_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTimeLast = 0x13B8; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0x13BC; // bool
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0x13BD; // bool
    constexpr std::ptrdiff_t m_fMolotovUseTime = 0x13C0; // float
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0x13C4; // float
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x13C8; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x13CC; // bool
    constexpr std::ptrdiff_t m_iThrowGrenadeCounter = 0x13D0; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x13D4; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0x13D8; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0x13DC; // GameTime_t
    constexpr std::ptrdiff_t m_flNextGuardianTooFarWarning = 0x13E0; // float
    constexpr std::ptrdiff_t m_bSuppressGuardianTooFarWarningAudio = 0x13E4; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x13E5; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x13E8; // int32_t
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0x13EC; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x13F0; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x13F4; // bool
    constexpr std::ptrdiff_t m_flLastSpawnTimeIndex = 0x13F8; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0x13FC; // GameTime_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1400; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1404; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x1408; // int32_t
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x140C; // int32_t
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1410; // float
    constexpr std::ptrdiff_t m_iDirection = 0x1414; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1418; // int32_t
    constexpr std::ptrdiff_t m_bNightVisionOn = 0x141C; // bool
    constexpr std::ptrdiff_t m_bHasNightVision = 0x141D; // bool
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x1420; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1424; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1428; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x142C; // int32_t
    constexpr std::ptrdiff_t m_vecIntroStartEyePosition = 0x1430; // Vector
    constexpr std::ptrdiff_t m_vecIntroStartPlayerForward = 0x143C; // Vector
    constexpr std::ptrdiff_t m_flClientDeathTime = 0x1448; // GameTime_t
    constexpr std::ptrdiff_t m_flNightVisionAlpha = 0x144C; // float
    constexpr std::ptrdiff_t m_bScreenTearFrameCaptured = 0x1450; // bool
    constexpr std::ptrdiff_t m_flFlashBangTime = 0x1454; // float
    constexpr std::ptrdiff_t m_flFlashScreenshotAlpha = 0x1458; // float
    constexpr std::ptrdiff_t m_flFlashOverlayAlpha = 0x145C; // float
    constexpr std::ptrdiff_t m_bFlashBuildUp = 0x1460; // bool
    constexpr std::ptrdiff_t m_bFlashDspHasBeenCleared = 0x1461; // bool
    constexpr std::ptrdiff_t m_bFlashScreenshotHasBeenGrabbed = 0x1462; // bool
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x1464; // float
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1468; // float
    constexpr std::ptrdiff_t m_lastStandingPos = 0x146C; // Vector
    constexpr std::ptrdiff_t m_vecLastMuzzleFlashPos = 0x1478; // Vector
    constexpr std::ptrdiff_t m_angLastMuzzleFlashAngle = 0x1484; // QAngle
    constexpr std::ptrdiff_t m_hMuzzleFlashShape = 0x1490; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iHealthBarRenderMaskIndex = 0x1494; // int32_t
    constexpr std::ptrdiff_t m_flHealthFadeValue = 0x1498; // float
    constexpr std::ptrdiff_t m_flHealthFadeAlpha = 0x149C; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x14A0; // int32_t
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x14A4; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x14A8; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x14C0; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x14CC; // Vector
    constexpr std::ptrdiff_t m_flDeathCCWeight = 0x14E0; // float
    constexpr std::ptrdiff_t m_bOldIsScoped = 0x14E4; // bool
    constexpr std::ptrdiff_t m_flPrevRoundEndTime = 0x14E8; // float
    constexpr std::ptrdiff_t m_flPrevMatchEndTime = 0x14EC; // float
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x14F0; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x14F2; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x14F4; // uint16_t
    constexpr std::ptrdiff_t m_vecThirdPersonViewPositionOverride = 0x14F8; // Vector
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0x1504; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1508; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x1510; // QAngle
    constexpr std::ptrdiff_t m_fNextThinkPushAway = 0x1528; // float
    constexpr std::ptrdiff_t m_bShouldAutobuyDMWeapons = 0x152C; // bool
    constexpr std::ptrdiff_t m_bShouldAutobuyNow = 0x152D; // bool
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x152E; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x152F; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x1530; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x1534; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1538; // int32_t
    constexpr std::ptrdiff_t m_iIDEntIndex = 0x153C; // CEntityIndex
    constexpr std::ptrdiff_t m_delayTargetIDTimer = 0x1540; // CountdownTimer
    constexpr std::ptrdiff_t m_iTargetedWeaponEntIndex = 0x1558; // CEntityIndex
    constexpr std::ptrdiff_t m_iOldIDEntIndex = 0x155C; // CEntityIndex
    constexpr std::ptrdiff_t m_holdTargetIDTimer = 0x1560; // CountdownTimer
    constexpr std::ptrdiff_t m_flCurrentMusicStartTime = 0x157C; // float
    constexpr std::ptrdiff_t m_flMusicRoundStartTime = 0x1580; // float
    constexpr std::ptrdiff_t m_bDeferStartMusicOnWarmup = 0x1584; // bool
    constexpr std::ptrdiff_t m_cycleLatch = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_serverIntendedCycle = 0x158C; // float
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1590; // uint32_t[5]
    constexpr std::ptrdiff_t m_bHideTargetID = 0x15AC; // bool
    constexpr std::ptrdiff_t m_nextTaserShakeTime = 0x15B0; // float
    constexpr std::ptrdiff_t m_firstTaserShakeTime = 0x15B4; // float
    constexpr std::ptrdiff_t m_flLastSmokeOverlayAlpha = 0x15B8; // float
    constexpr std::ptrdiff_t m_vLastSmokeOverlayColor = 0x15BC; // Vector
    constexpr std::ptrdiff_t m_nPlayerSmokedFx = 0x15C8; // ParticleIndex_t
    constexpr std::ptrdiff_t m_flNextMagDropTime = 0x15CC; // float
    constexpr std::ptrdiff_t m_nLastMagDropAttachmentIndex = 0x15D0; // int32_t
    constexpr std::ptrdiff_t m_vecBulletHitModels = 0x15D8; // CUtlVector<C_BulletHitModel*>
    constexpr std::ptrdiff_t m_vecPickupModelSlerpers = 0x15F0; // CUtlVector<C_PickUpModelSlerper*>
    constexpr std::ptrdiff_t m_vecLastAliveLocalVelocity = 0x1608; // Vector
    constexpr std::ptrdiff_t m_entitySpottedState = 0x1630; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_bGuardianShouldSprayCustomXMark = 0x164C; // bool
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x164D; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1650; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x1654; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1660; // bool
    constexpr std::ptrdiff_t m_hOriginalController = 0x1664; // CHandle<CCSPlayerController>
}

namespace C_CSPlayerResource { // C_BaseEntity
    constexpr std::ptrdiff_t m_bHostageAlive = 0x540; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x54C; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x558; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x588; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x594; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x5A0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x5B0; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x5C0; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x5D0; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x5D1; // bool
}

namespace C_CSTeam { // C_Team
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x5F8; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x7F8; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x7FC; // bool
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x800; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x804; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x808; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x80C; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x890; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x894; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x89C; // char[8]
}

namespace C_CSWeaponBase { // C_BasePlayerWeapon
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0x15D4; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0x15D8; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0x15DC; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0x15E0; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0x15E4; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0x15E8; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0x15EC; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0x15F0; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0x1608; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0x1610; // HSequence[6]
    constexpr std::ptrdiff_t m_ClientPreviousWeaponState = 0x1640; // CSWeaponState_t
    constexpr std::ptrdiff_t m_iState = 0x1644; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flCrosshairDistance = 0x1648; // float
    constexpr std::ptrdiff_t m_iAmmoLastCheck = 0x164C; // int32_t
    constexpr std::ptrdiff_t m_iAlpha = 0x1650; // int32_t
    constexpr std::ptrdiff_t m_iScopeTextureID = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_iCrosshairTextureID = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_flGunAccuracyPosition = 0x165C; // float
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x1660; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0x1664; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0x1668; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0x166C; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x1670; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0x1698; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0x169C; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0x16A0; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0x16AC; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0x16B0; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0x16B4; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0x16B8; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0x16BC; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0x16C0; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0x16C4; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0x16C8; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0x16CC; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0x16D0; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0x16D1; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0x16D4; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0x16D8; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0x16D9; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0x16DC; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0x16E0; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0x16E4; // float
    constexpr std::ptrdiff_t m_bVisualsDataSet = 0x1768; // bool
    constexpr std::ptrdiff_t m_bOldFirstPersonSpectatedState = 0x1769; // bool
    constexpr std::ptrdiff_t m_hOurPing = 0x176C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nOurPingIndex = 0x1770; // CEntityIndex
    constexpr std::ptrdiff_t m_vecOurPingPos = 0x1774; // Vector
    constexpr std::ptrdiff_t m_bGlowForPing = 0x1780; // bool
    constexpr std::ptrdiff_t m_bUIWeapon = 0x1781; // bool
    constexpr std::ptrdiff_t m_hPrevOwner = 0x1790; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0x1794; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0x17B4; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0x17B8; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0x17BC; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0x17BD; // bool
    constexpr std::ptrdiff_t m_gunHeat = 0x17C0; // float
    constexpr std::ptrdiff_t m_smokeAttachments = 0x17C4; // uint32_t
    constexpr std::ptrdiff_t m_lastSmokeTime = 0x17C8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime = 0x17CC; // float
    constexpr std::ptrdiff_t m_flNextClientFireBulletTime_Repredict = 0x17D0; // float
    constexpr std::ptrdiff_t m_IronSightController = 0x18B0; // C_IronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0x1960; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0x1970; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0x1974; // int32_t
}

namespace C_CSWeaponBaseGun { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_zoomLevel = 0x19F0; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0x19F4; // int32_t
    constexpr std::ptrdiff_t m_iSilencerBodygroup = 0x19F8; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0x1A08; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0x1A0C; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0x1A0D; // bool
}

namespace C_Chicken { // C_DynamicProp
    constexpr std::ptrdiff_t m_hHolidayHatAddon = 0x10F0; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10F4; // bool
    constexpr std::ptrdiff_t m_leader = 0x10F8; // CHandle<C_CSPlayerPawnBase>
    constexpr std::ptrdiff_t m_AttributeManager = 0x1100; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x15A8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x15AC; // uint32_t
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x15B0; // bool
    constexpr std::ptrdiff_t m_hWaterWakeParticles = 0x15B4; // ParticleIndex_t
}

namespace C_ClientRagdoll { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bFadeOut = 0xE80; // bool
    constexpr std::ptrdiff_t m_bImportant = 0xE81; // bool
    constexpr std::ptrdiff_t m_flEffectTime = 0xE84; // GameTime_t
    constexpr std::ptrdiff_t m_gibDespawnTime = 0xE88; // GameTime_t
    constexpr std::ptrdiff_t m_iCurrentFriction = 0xE8C; // int32_t
    constexpr std::ptrdiff_t m_iMinFriction = 0xE90; // int32_t
    constexpr std::ptrdiff_t m_iMaxFriction = 0xE94; // int32_t
    constexpr std::ptrdiff_t m_iFrictionAnimState = 0xE98; // int32_t
    constexpr std::ptrdiff_t m_bReleaseRagdoll = 0xE9C; // bool
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xE9D; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_bFadingOut = 0xE9E; // bool
    constexpr std::ptrdiff_t m_flScaleEnd = 0xEA0; // float[10]
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xEC8; // GameTime_t[10]
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0xEF0; // GameTime_t[10]
}

namespace C_ColorCorrection { // C_BaseEntity
    constexpr std::ptrdiff_t m_vecOrigin = 0x540; // Vector
    constexpr std::ptrdiff_t m_MinFalloff = 0x54C; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x554; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x558; // float
    constexpr std::ptrdiff_t m_flMaxWeight = 0x55C; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x560; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x564; // char[512]
    constexpr std::ptrdiff_t m_bEnabled = 0x764; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x765; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x766; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x767; // bool
    constexpr std::ptrdiff_t m_bEnabledOnClient = 0x768; // bool[1]
    constexpr std::ptrdiff_t m_flCurWeightOnClient = 0x76C; // float[1]
    constexpr std::ptrdiff_t m_bFadingIn = 0x770; // bool[1]
    constexpr std::ptrdiff_t m_flFadeStartWeight = 0x774; // float[1]
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x778; // float[1]
    constexpr std::ptrdiff_t m_flFadeDuration = 0x77C; // float[1]
}

namespace C_ColorCorrectionVolume { // C_BaseTrigger
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xCC8; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xCCC; // float
    constexpr std::ptrdiff_t m_LastExitWeight = 0xCD0; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xCD4; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCD8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0xCDC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_Weight = 0xCE4; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0xCE8; // char[512]
}

namespace C_CommandContext {
    constexpr std::ptrdiff_t needsprocessing = 0x0; // bool
    constexpr std::ptrdiff_t command_number = 0xA8; // int32_t
}

namespace C_CsmFovOverride { // C_BaseEntity
    constexpr std::ptrdiff_t m_cameraName = 0x540; // CUtlString
    constexpr std::ptrdiff_t m_flCsmFovOverrideValue = 0x548; // float
}

namespace C_DEagle { // C_CSWeaponBaseGun
}

namespace C_DecoyGrenade { // C_BaseCSGrenade
}

namespace C_DecoyProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0x1100; // int32_t
    constexpr std::ptrdiff_t m_nClientLastKnownDecoyShotTick = 0x1104; // int32_t
    constexpr std::ptrdiff_t m_flTimeParticleEffectSpawn = 0x1128; // GameTime_t
}

namespace C_DynamicLight { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_Flags = 0xCC0; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0xCC1; // uint8_t
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
    constexpr std::ptrdiff_t m_Exponent = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0xCCC; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0xCD0; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0xCD4; // float
}

namespace C_DynamicProp { // C_BreakableProp
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xFD1; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xFD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0x1000; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0x1028; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0x1050; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0x1078; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0x10A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0x10A8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0x10AC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0x10AD; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x10AE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x10AF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0x10B0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x10B1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0x10B2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0x10B3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0x10B4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x10B8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x10BC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0x10C0; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0x10C4; // int32_t
    constexpr std::ptrdiff_t m_iCachedFrameCount = 0x10C8; // int32_t
    constexpr std::ptrdiff_t m_vecCachedRenderMins = 0x10CC; // Vector
    constexpr std::ptrdiff_t m_vecCachedRenderMaxs = 0x10D8; // Vector
}

namespace C_DynamicPropAlias_cable_dynamic { // C_DynamicProp
}

namespace C_DynamicPropAlias_dynamic_prop { // C_DynamicProp
}

namespace C_DynamicPropAlias_prop_dynamic_override { // C_DynamicProp
}

namespace C_EconEntity { // C_BaseFlex
    constexpr std::ptrdiff_t m_flFlexDelayTime = 0x1028; // float
    constexpr std::ptrdiff_t m_flFlexDelayedWeight = 0x1030; // float*
    constexpr std::ptrdiff_t m_bAttributesInitialized = 0x1038; // bool
    constexpr std::ptrdiff_t m_AttributeManager = 0x1040; // C_AttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0x14E8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x14EC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0x14F0; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0x14F4; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0x14F8; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0x14FC; // int32_t
    constexpr std::ptrdiff_t m_bClientside = 0x1500; // bool
    constexpr std::ptrdiff_t m_bParticleSystemsCreated = 0x1501; // bool
    constexpr std::ptrdiff_t m_vecAttachedParticles = 0x1508; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_hViewmodelAttachment = 0x1520; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_iOldTeam = 0x1524; // int32_t
    constexpr std::ptrdiff_t m_bAttachmentDirty = 0x1528; // bool
    constexpr std::ptrdiff_t m_nUnloadedModelIndex = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_iNumOwnerValidationRetries = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0x1540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_vecAttachedModels = 0x1548; // CUtlVector<C_EconEntity::AttachedModelData_t>
}

namespace C_EconEntity_AttachedModelData_t {
    constexpr std::ptrdiff_t m_iModelDisplayFlags = 0x0; // int32_t
}

namespace C_EconItemView { // IEconItemInterface
    constexpr std::ptrdiff_t m_bInventoryImageRgbaRequested = 0x60; // bool
    constexpr std::ptrdiff_t m_bInventoryImageTriedCache = 0x61; // bool
    constexpr std::ptrdiff_t m_nInventoryImageRgbaWidth = 0x80; // int32_t
    constexpr std::ptrdiff_t m_nInventoryImageRgbaHeight = 0x84; // int32_t
    constexpr std::ptrdiff_t m_szCurrentLoadCachedFileName = 0x88; // char[260]
    constexpr std::ptrdiff_t m_bRestoreCustomMaterialAfterPrecache = 0x1B8; // bool
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x1BA; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x1C0; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x1C8; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x1D0; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x1D4; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x1D8; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x1E8; // bool
    constexpr std::ptrdiff_t m_bIsStoreItem = 0x1E9; // bool
    constexpr std::ptrdiff_t m_bIsTradeItem = 0x1EA; // bool
    constexpr std::ptrdiff_t m_iEntityQuantity = 0x1EC; // int32_t
    constexpr std::ptrdiff_t m_iRarityOverride = 0x1F0; // int32_t
    constexpr std::ptrdiff_t m_iQualityOverride = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_unClientFlags = 0x1F8; // uint8_t
    constexpr std::ptrdiff_t m_unOverrideStyle = 0x1F9; // uint8_t
    constexpr std::ptrdiff_t m_AttributeList = 0x210; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0x270; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x2D0; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x371; // char[161]
    constexpr std::ptrdiff_t m_bInitializedTags = 0x440; // bool
}

namespace C_EconWearable { // C_EconEntity
    constexpr std::ptrdiff_t m_nForceSkin = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0x1564; // bool
}

namespace C_EntityDissolve { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flStartTime = 0xCC8; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeInStart = 0xCCC; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0xCD0; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0xCD4; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0xCD8; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0xCDC; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0xCE0; // float
    constexpr std::ptrdiff_t m_flNextSparkTime = 0xCE4; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0xCE8; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0xCEC; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0xCF8; // uint32_t
    constexpr std::ptrdiff_t m_bCoreExplode = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bLinkedToServerEnt = 0xCFD; // bool
}

namespace C_EntityFlame { // C_BaseEntity
    constexpr std::ptrdiff_t m_hEntAttached = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hOldAttached = 0x568; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x56C; // bool
}

namespace C_EnvCombinedLightProbeVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_Color = 0x1598; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x159C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x15A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x15A8; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x15B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x15B8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x15C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x15C8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x15D0; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x15DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x15E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x15EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x15F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x15F4; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x15F8; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x15FC; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1600; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x160C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1610; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1614; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1618; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x161C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1639; // bool
}

namespace C_EnvCubemap { // C_BaseEntity
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x5C0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x5C8; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x5CC; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x5D0; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x5DC; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x5E8; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x5EC; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x5F0; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x5F4; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x5F8; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x5FC; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x608; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x60C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x60D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x60E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x60F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x610; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x620; // bool
}

namespace C_EnvCubemapBox { // C_EnvCubemap
}

namespace C_EnvCubemapFog { // C_BaseEntity
    constexpr std::ptrdiff_t m_flEndDistance = 0x540; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x544; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x548; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x550; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x558; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x55C; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x560; // float
    constexpr std::ptrdiff_t m_bActive = 0x564; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x565; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x568; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x570; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x580; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x588; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x589; // bool
}

namespace C_EnvDecal { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hDecalMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeight = 0xCCC; // float
    constexpr std::ptrdiff_t m_flDepth = 0xCD0; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0xCD4; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0xCD8; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0xCD9; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0xCDA; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0xCDC; // float
}

namespace C_EnvDetailController { // C_BaseEntity
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x540; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x544; // float
}

namespace C_EnvLightProbeVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1518; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1538; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x1544; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1550; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x1554; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1558; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x155C; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1568; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x156C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x1570; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1574; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x1581; // bool
}

namespace C_EnvParticleGlow { // C_ParticleSystem
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1270; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1274; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0x1278; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x127C; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0x1280; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_EnvProjectedTexture { // C_ModelPointEntity
}

namespace C_EnvScreenOverlay { // C_PointEntity
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x540; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x590; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x5B8; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x5BC; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x5C0; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0x5C1; // bool
    constexpr std::ptrdiff_t m_iCachedDesiredOverlay = 0x5C4; // int32_t
    constexpr std::ptrdiff_t m_iCurrentOverlay = 0x5C8; // int32_t
    constexpr std::ptrdiff_t m_flCurrentOverlayTime = 0x5CC; // GameTime_t
}

namespace C_EnvSky { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hSkyMaterial = 0xCC0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0xCC8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0xCD0; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0xCD1; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0xCD5; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0xCDC; // float
    constexpr std::ptrdiff_t m_nFogType = 0xCE0; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0xCE4; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0xCEC; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0xCF0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0xCF4; // bool
}

namespace C_EnvVolumetricFogController { // C_BaseEntity
    constexpr std::ptrdiff_t m_flScattering = 0x540; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x544; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x548; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x558; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x564; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x568; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x574; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x580; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x588; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x58C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x590; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x594; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x598; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x59C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x5A0; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x5A4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x5A8; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x5A9; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x5AA; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x5B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x5B8; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x5BC; // bool
}

namespace C_EnvVolumetricFogVolume { // C_BaseEntity
    constexpr std::ptrdiff_t m_bActive = 0x540; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x544; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x550; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x55C; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x560; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x568; // float
}

namespace C_EnvWind { // C_BaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindClientside { // C_BaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x540; // C_EnvWindShared
}

namespace C_EnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_flVariationTime = 0x70; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0x74; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0x78; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0x7C; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x80; // float
    constexpr std::ptrdiff_t m_bGusting = 0x84; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x88; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x8C; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0x90; // CEntityIndex
}

namespace C_EnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace C_EnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace C_FireCrackerBlast { // C_Inferno
}

namespace C_FireFromAboveSprite { // C_Sprite
}

namespace C_FireSmoke { // C_BaseFire
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x554; // int32_t
    constexpr std::ptrdiff_t m_flScaleRegister = 0x558; // float
    constexpr std::ptrdiff_t m_flScaleStart = 0x55C; // float
    constexpr std::ptrdiff_t m_flScaleEnd = 0x560; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x564; // GameTime_t
    constexpr std::ptrdiff_t m_flScaleTimeEnd = 0x568; // GameTime_t
    constexpr std::ptrdiff_t m_flChildFlameSpread = 0x56C; // float
    constexpr std::ptrdiff_t m_flClipPerc = 0x580; // float
    constexpr std::ptrdiff_t m_bClipTested = 0x584; // bool
    constexpr std::ptrdiff_t m_bFadingOut = 0x585; // bool
    constexpr std::ptrdiff_t m_tParticleSpawn = 0x588; // TimedEvent
    constexpr std::ptrdiff_t m_pFireOverlay = 0x590; // CFireOverlay*
}

namespace C_FireSprite { // C_Sprite
    constexpr std::ptrdiff_t m_vecMoveDir = 0xDF0; // Vector
    constexpr std::ptrdiff_t m_bFadeFromAbove = 0xDFC; // bool
}

namespace C_Fish { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_pos = 0xE80; // Vector
    constexpr std::ptrdiff_t m_vel = 0xE8C; // Vector
    constexpr std::ptrdiff_t m_angles = 0xE98; // QAngle
    constexpr std::ptrdiff_t m_localLifeState = 0xEA4; // int32_t
    constexpr std::ptrdiff_t m_deathDepth = 0xEA8; // float
    constexpr std::ptrdiff_t m_deathAngle = 0xEAC; // float
    constexpr std::ptrdiff_t m_buoyancy = 0xEB0; // float
    constexpr std::ptrdiff_t m_wiggleTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_wigglePhase = 0xED0; // float
    constexpr std::ptrdiff_t m_wiggleRate = 0xED4; // float
    constexpr std::ptrdiff_t m_actualPos = 0xED8; // Vector
    constexpr std::ptrdiff_t m_actualAngles = 0xEE4; // QAngle
    constexpr std::ptrdiff_t m_poolOrigin = 0xEF0; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0xEFC; // float
    constexpr std::ptrdiff_t m_gotUpdate = 0xF00; // bool
    constexpr std::ptrdiff_t m_x = 0xF04; // float
    constexpr std::ptrdiff_t m_y = 0xF08; // float
    constexpr std::ptrdiff_t m_z = 0xF0C; // float
    constexpr std::ptrdiff_t m_angle = 0xF10; // float
    constexpr std::ptrdiff_t m_errorHistory = 0xF14; // float[20]
    constexpr std::ptrdiff_t m_errorHistoryIndex = 0xF64; // int32_t
    constexpr std::ptrdiff_t m_errorHistoryCount = 0xF68; // int32_t
    constexpr std::ptrdiff_t m_averageError = 0xF6C; // float
}

namespace C_Fists { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0x19F0; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0x19F4; // PlayerAnimEvent_t
}

namespace C_Flashbang { // C_BaseCSGrenade
}

namespace C_FlashbangProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_FogController { // C_BaseEntity
    constexpr std::ptrdiff_t m_fog = 0x540; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x5A8; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x5AC; // int32_t
}

namespace C_FootstepControl { // C_BaseTrigger
    constexpr std::ptrdiff_t m_source = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0xCD0; // CUtlSymbolLarge
}

namespace C_FuncBrush { // C_BaseModelEntity
}

namespace C_FuncConveyor { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0xCC8; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0xCD4; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0xCD8; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0xCDC; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0xCE0; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0xCE8; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_flCurrentConveyorOffset = 0xD00; // float
    constexpr std::ptrdiff_t m_flCurrentConveyorSpeed = 0xD04; // float
}

namespace C_FuncElectrifiedVolume { // C_FuncBrush
    constexpr std::ptrdiff_t m_nAmbientEffect = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_EffectName = 0xCC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bState = 0xCD0; // bool
}

namespace C_FuncLadder { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_vecLadderDir = 0xCC0; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0xCD0; // CUtlVector<CHandle<C_InfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0xD00; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0xD0C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0xD10; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0xD12; // bool
}

namespace C_FuncMonitor { // C_FuncBrush
    constexpr std::ptrdiff_t m_targetCamera = 0xCC0; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0xCC8; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0xCCC; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0xCCD; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0xCD0; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0xCD8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0xCDC; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0xCDD; // bool
}

namespace C_FuncMoveLinear { // C_BaseToggle
}

namespace C_FuncRotating { // C_BaseModelEntity
}

namespace C_FuncTrackTrain { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nLongAxis = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0xCC4; // float
    constexpr std::ptrdiff_t m_flLineLength = 0xCC8; // float
}

namespace C_GameRules {
}

namespace C_GameRulesProxy { // C_BaseEntity
}

namespace C_GlobalLight { // C_BaseEntity
    constexpr std::ptrdiff_t m_WindClothForceHandle = 0xA00; // uint16_t
}

namespace C_GradientFog { // C_BaseEntity
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x540; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x548; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x54C; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x550; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x554; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x558; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x55C; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x560; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x564; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x568; // float
    constexpr std::ptrdiff_t m_fogColor = 0x56C; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x570; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x574; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x578; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x579; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x57A; // bool
}

namespace C_HEGrenade { // C_BaseCSGrenade
}

namespace C_HEGrenadeProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_HandleTest { // C_BaseEntity
    constexpr std::ptrdiff_t m_Handle = 0x540; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x544; // bool
}

namespace C_Hostage { // C_BaseCombatCharacter
    constexpr std::ptrdiff_t m_entitySpottedState = 0x10A8; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_leader = 0x10C0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_reuseTimer = 0x10C8; // CountdownTimer
    constexpr std::ptrdiff_t m_vel = 0x10E0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0x10EC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0x10ED; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0x10F0; // int32_t
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x10F4; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x10F8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x10FC; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x1100; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x110C; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x1110; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x1114; // GameTime_t
    constexpr std::ptrdiff_t m_flDeadOrRescuedTime = 0x1118; // GameTime_t
    constexpr std::ptrdiff_t m_blinkTimer = 0x1120; // CountdownTimer
    constexpr std::ptrdiff_t m_lookAt = 0x1138; // Vector
    constexpr std::ptrdiff_t m_lookAroundTimer = 0x1148; // CountdownTimer
    constexpr std::ptrdiff_t m_isInit = 0x1160; // bool
    constexpr std::ptrdiff_t m_eyeAttachment = 0x1161; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_chestAttachment = 0x1162; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0x1168; // CBasePlayerController*
    constexpr std::ptrdiff_t m_fNewestAlphaThinkTime = 0x1170; // GameTime_t
}

namespace C_HostageCarriableProp { // CBaseAnimGraph
}

namespace C_IncendiaryGrenade { // C_MolotovGrenade
}

namespace C_Inferno { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nfxFireDamageEffect = 0xD00; // ParticleIndex_t
    constexpr std::ptrdiff_t m_firePositions = 0xD04; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0x1004; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0x1304; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0x1344; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1644; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1648; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x164C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1650; // bool
    constexpr std::ptrdiff_t m_lastFireCount = 0x1654; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1658; // int32_t
    constexpr std::ptrdiff_t m_drawableCount = 0x8260; // int32_t
    constexpr std::ptrdiff_t m_blosCheck = 0x8264; // bool
    constexpr std::ptrdiff_t m_nlosperiod = 0x8268; // int32_t
    constexpr std::ptrdiff_t m_maxFireHalfWidth = 0x826C; // float
    constexpr std::ptrdiff_t m_maxFireHeight = 0x8270; // float
    constexpr std::ptrdiff_t m_minBounds = 0x8274; // Vector
    constexpr std::ptrdiff_t m_maxBounds = 0x8280; // Vector
    constexpr std::ptrdiff_t m_flLastGrassBurnThink = 0x828C; // float
}

namespace C_InfoInstructorHintHostageRescueZone { // C_PointEntity
}

namespace C_InfoLadderDismount { // C_BaseEntity
}

namespace C_InfoVisibilityBox { // C_BaseEntity
    constexpr std::ptrdiff_t m_nMode = 0x544; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x548; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x554; // bool
}

namespace C_IronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x10; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0x14; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x18; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x1C; // float
    constexpr std::ptrdiff_t m_flIronSightAmount_Interpolated = 0x20; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained_Interpolated = 0x24; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased_Interpolated = 0x28; // float
    constexpr std::ptrdiff_t m_flInterpolationLastUpdated = 0x2C; // float
    constexpr std::ptrdiff_t m_angDeltaAverage = 0x30; // QAngle[8]
    constexpr std::ptrdiff_t m_angViewLast = 0x90; // QAngle
    constexpr std::ptrdiff_t m_vecDotCoords = 0x9C; // Vector2D
    constexpr std::ptrdiff_t m_flDotBlur = 0xA4; // float
    constexpr std::ptrdiff_t m_flSpeedRatio = 0xA8; // float
}

namespace C_Item { // C_EconEntity
    constexpr std::ptrdiff_t m_bShouldGlow = 0x1560; // bool
    constexpr std::ptrdiff_t m_pReticleHintTextName = 0x1561; // char[256]
}

namespace C_ItemDogtags { // C_Item
    constexpr std::ptrdiff_t m_OwningPlayer = 0x1668; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x166C; // CHandle<C_CSPlayerPawn>
}

namespace C_Item_Healthshot { // C_WeaponBaseItem
}

namespace C_Knife { // C_CSWeaponBase
}

namespace C_LightDirectionalEntity { // C_LightEntity
}

namespace C_LightEntity { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_CLightComponent = 0xCC0; // CLightComponent*
}

namespace C_LightEnvironmentEntity { // C_LightDirectionalEntity
}

namespace C_LightGlow { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_nHorizontalSize = 0xCC0; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xCD0; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xCD4; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xCD8; // float
    constexpr std::ptrdiff_t m_Glow = 0xCE0; // C_LightGlowOverlay
}

namespace C_LightGlowOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_vecOrigin = 0xD0; // Vector
    constexpr std::ptrdiff_t m_vecDirection = 0xDC; // Vector
    constexpr std::ptrdiff_t m_nMinDist = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0xEC; // int32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_bOneSided = 0xF4; // bool
    constexpr std::ptrdiff_t m_bModulateByDot = 0xF5; // bool
}

namespace C_LightOrthoEntity { // C_LightEntity
}

namespace C_LightSpotEntity { // C_LightEntity
}

namespace C_LocalTempEntity { // CBaseAnimGraph
    constexpr std::ptrdiff_t flags = 0xE98; // int32_t
    constexpr std::ptrdiff_t die = 0xE9C; // GameTime_t
    constexpr std::ptrdiff_t m_flFrameMax = 0xEA0; // float
    constexpr std::ptrdiff_t x = 0xEA4; // float
    constexpr std::ptrdiff_t y = 0xEA8; // float
    constexpr std::ptrdiff_t fadeSpeed = 0xEAC; // float
    constexpr std::ptrdiff_t bounceFactor = 0xEB0; // float
    constexpr std::ptrdiff_t hitSound = 0xEB4; // int32_t
    constexpr std::ptrdiff_t priority = 0xEB8; // int32_t
    constexpr std::ptrdiff_t tentOffset = 0xEBC; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAngVelocity = 0xEC8; // QAngle
    constexpr std::ptrdiff_t tempent_renderamt = 0xED4; // int32_t
    constexpr std::ptrdiff_t m_vecNormal = 0xED8; // Vector
    constexpr std::ptrdiff_t m_flSpriteScale = 0xEE4; // float
    constexpr std::ptrdiff_t m_nFlickerFrame = 0xEE8; // int32_t
    constexpr std::ptrdiff_t m_flFrameRate = 0xEEC; // float
    constexpr std::ptrdiff_t m_flFrame = 0xEF0; // float
    constexpr std::ptrdiff_t m_pszImpactEffect = 0xEF8; // char*
    constexpr std::ptrdiff_t m_pszParticleEffect = 0xF00; // char*
    constexpr std::ptrdiff_t m_bParticleCollision = 0xF08; // bool
    constexpr std::ptrdiff_t m_iLastCollisionFrame = 0xF0C; // int32_t
    constexpr std::ptrdiff_t m_vLastCollisionOrigin = 0xF10; // Vector
    constexpr std::ptrdiff_t m_vecTempEntVelocity = 0xF1C; // Vector
    constexpr std::ptrdiff_t m_vecPrevAbsOrigin = 0xF28; // Vector
    constexpr std::ptrdiff_t m_vecTempEntAcceleration = 0xF34; // Vector
}

namespace C_MapPreviewParticleSystem { // C_ParticleSystem
}

namespace C_MapVetoPickController { // C_BaseEntity
    constexpr std::ptrdiff_t m_nDraftType = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x558; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x658; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x674; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x774; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x874; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x974; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB74; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC74; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD74; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE7C; // int32_t
    constexpr std::ptrdiff_t m_nPostDataUpdateTick = 0xE80; // int32_t
    constexpr std::ptrdiff_t m_bDisabledHud = 0xE84; // bool
}

namespace C_Melee { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_flThrowAt = 0x19F0; // GameTime_t
}

namespace C_ModelPointEntity { // C_BaseModelEntity
}

namespace C_MolotovGrenade { // C_BaseCSGrenade
}

namespace C_MolotovProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0x1100; // bool
}

namespace C_Multimeter { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_hTargetC4 = 0xE88; // CHandle<C_PlantedC4>
}

namespace C_MultiplayRules { // C_GameRules
}

namespace C_NetTestBaseCombatCharacter { // C_BaseCombatCharacter
}

namespace C_OmniLight { // C_BarnLight
    constexpr std::ptrdiff_t m_flInnerAngle = 0xF08; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0xF0C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0xF10; // bool
}

namespace C_ParticleSystem { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0xCC0; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0xEC0; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0xEC1; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0xEC4; // float
    constexpr std::ptrdiff_t m_nStopType = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0xECC; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0xED0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0xED8; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0xEDC; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0xEE0; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0xF10; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0xF14; // CHandle<C_BaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0x1014; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0x1015; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0x1016; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0x1017; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0x1018; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0x1020; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0x1220; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0x1224; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0x1230; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0x1234; // Color
    constexpr std::ptrdiff_t m_bOldActive = 0x1258; // bool
    constexpr std::ptrdiff_t m_bOldFrozen = 0x1259; // bool
}

namespace C_PathParticleRope { // C_BaseEntity
    constexpr std::ptrdiff_t m_bStartActive = 0x540; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x544; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x550; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x568; // float
    constexpr std::ptrdiff_t m_flSlack = 0x56C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x570; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x574; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x578; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x580; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x588; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x5A0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x5B8; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x5D0; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x5E8; // C_NetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x600; // C_NetworkUtlVectorBase<float>
}

namespace C_PathParticleRopeAlias_path_particle_rope_clientside { // C_PathParticleRope
}

namespace C_PhysBox { // C_Breakable
}

namespace C_PhysMagnet { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_aAttachedObjectsFromServer = 0xE80; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_aAttachedObjects = 0xE98; // CUtlVector<CHandle<C_BaseEntity>>
}

namespace C_PhysPropClientside { // C_BreakableProp
    constexpr std::ptrdiff_t m_flTouchDelta = 0xFD0; // GameTime_t
    constexpr std::ptrdiff_t m_fDeathTime = 0xFD4; // GameTime_t
    constexpr std::ptrdiff_t m_impactEnergyScale = 0xFD8; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xFDC; // float
    constexpr std::ptrdiff_t m_flDmgModBullet = 0xFE0; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0xFE4; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0xFE8; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0xFEC; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0xFF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0xFF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x1000; // int32_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x1004; // bool
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x1008; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x1014; // Vector
    constexpr std::ptrdiff_t m_nDamageType = 0x1020; // int32_t
}

namespace C_PhysicsProp { // C_BreakableProp
    constexpr std::ptrdiff_t m_bAwake = 0xFD0; // bool
}

namespace C_PhysicsPropMultiplayer { // C_PhysicsProp
}

namespace C_PickUpModelSlerper { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_hPlayerParent = 0xE80; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hItem = 0xE84; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flTimePickedUp = 0xE88; // float
    constexpr std::ptrdiff_t m_angOriginal = 0xE8C; // QAngle
    constexpr std::ptrdiff_t m_vecPosOriginal = 0xE98; // Vector
    constexpr std::ptrdiff_t m_angRandom = 0xEA8; // QAngle
}

namespace C_PlantedC4 { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bBombTicking = 0xE80; // bool
    constexpr std::ptrdiff_t m_nBombSite = 0xE84; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0xE88; // int32_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE90; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_flNextGlow = 0xEA8; // GameTime_t
    constexpr std::ptrdiff_t m_flNextBeep = 0xEAC; // GameTime_t
    constexpr std::ptrdiff_t m_flC4Blow = 0xEB0; // GameTime_t
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0xEB4; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0xEB5; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0xEB8; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0xEBC; // bool
    constexpr std::ptrdiff_t m_bTriggerWarning = 0xEC0; // float
    constexpr std::ptrdiff_t m_bExplodeWarning = 0xEC4; // float
    constexpr std::ptrdiff_t m_bC4Activated = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bTenSecWarning = 0xEC9; // bool
    constexpr std::ptrdiff_t m_flDefuseLength = 0xECC; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0xED4; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0xED8; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0xEDC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hDefuserMultimeter = 0xEE0; // CHandle<C_Multimeter>
    constexpr std::ptrdiff_t m_flNextRadarFlashTime = 0xEE4; // GameTime_t
    constexpr std::ptrdiff_t m_bRadarFlash = 0xEE8; // bool
    constexpr std::ptrdiff_t m_pBombDefuser = 0xEEC; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0xEF0; // GameTime_t
    constexpr std::ptrdiff_t m_pPredictionOwner = 0xEF8; // CBasePlayerController*
}

namespace C_PlayerPing { // C_BaseEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x570; // CHandle<C_CSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x574; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x578; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x57C; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x57D; // char[18]
}

namespace C_PlayerSprayDecal { // C_ModelPointEntity
    constexpr std::ptrdiff_t m_nUniqueID = 0xCC0; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0xCC4; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0xCC8; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0xCCC; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0xCD0; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0xCDC; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0xCE8; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0xCF4; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0xD00; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0xD04; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0xD08; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0xD0C; // float
    constexpr std::ptrdiff_t m_nTintID = 0xD10; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0xD14; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0xD15; // uint8_t[128]
    constexpr std::ptrdiff_t m_SprayRenderHelper = 0xDA0; // CPlayerSprayDecalRenderHelper
}

namespace C_PlayerVisibility { // C_BaseEntity
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x540; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x544; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x548; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x54C; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x550; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x551; // bool
}

namespace C_PointCamera { // C_BaseEntity
    constexpr std::ptrdiff_t m_FOV = 0x540; // float
    constexpr std::ptrdiff_t m_Resolution = 0x544; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x548; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x549; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x550; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x554; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x558; // float
    constexpr std::ptrdiff_t m_bActive = 0x55C; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x55D; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x560; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x564; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x568; // float
    constexpr std::ptrdiff_t m_flZFar = 0x56C; // float
    constexpr std::ptrdiff_t m_flZNear = 0x570; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x574; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x575; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x578; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x57C; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x580; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x584; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x588; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x58C; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x590; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x594; // bool
    constexpr std::ptrdiff_t m_pNext = 0x598; // C_PointCamera*
}

namespace C_PointCameraVFOV { // C_PointCamera
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x5A0; // float
}

namespace C_PointClientUIDialog { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_hActivator = 0xCF0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0xCF4; // bool
}

namespace C_PointClientUIHUD { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xE80; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xE84; // float
    constexpr std::ptrdiff_t m_flHeight = 0xE88; // float
    constexpr std::ptrdiff_t m_flDPI = 0xE8C; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xE90; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xE94; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xE98; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xE9C; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEA0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEA4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEA8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEB0; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace C_PointClientUIWorldPanel { // C_BaseClientUIEntity
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCF8; // bool
    constexpr std::ptrdiff_t m_bMoveViewToPlayerNextThink = 0xCF9; // bool
    constexpr std::ptrdiff_t m_bCheckCSSClasses = 0xCFA; // bool
    constexpr std::ptrdiff_t m_anchorDeltaTransform = 0xD00; // CTransform
    constexpr std::ptrdiff_t m_pOffScreenIndicator = 0xEA0; // CPointOffScreenIndicatorUi*
    constexpr std::ptrdiff_t m_bIgnoreInput = 0xEC8; // bool
    constexpr std::ptrdiff_t m_bLit = 0xEC9; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0xECA; // bool
    constexpr std::ptrdiff_t m_flWidth = 0xECC; // float
    constexpr std::ptrdiff_t m_flHeight = 0xED0; // float
    constexpr std::ptrdiff_t m_flDPI = 0xED4; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0xED8; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xEDC; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0xEE0; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0xEE4; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0xEE8; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0xEEC; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0xEF0; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0xEF8; // C_NetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0xF10; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0xF11; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0xF12; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0xF13; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0xF14; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0xF15; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0xF16; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0xF17; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0xF18; // int32_t
}

namespace C_PointClientUIWorldTextPanel { // C_PointClientUIWorldPanel
    constexpr std::ptrdiff_t m_messageText = 0xF20; // char[512]
}

namespace C_PointCommentaryNode { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bActive = 0xE88; // bool
    constexpr std::ptrdiff_t m_bWasActive = 0xE89; // bool
    constexpr std::ptrdiff_t m_flEndTime = 0xE8C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTime = 0xE90; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0xE94; // float
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0xE98; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTitle = 0xEA0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0xEA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0xEB8; // bool
    constexpr std::ptrdiff_t m_hViewPosition = 0xEC8; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bRestartAfterRestore = 0xECC; // bool
}

namespace C_PointEntity { // C_BaseEntity
}

namespace C_PointValueRemapper { // C_BaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bDisabledOld = 0x541; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x542; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x544; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x548; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x54C; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x550; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x554; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x558; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x55C; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x560; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_hOutputEntities = 0x568; // C_NetworkUtlVectorBase<CHandle<C_BaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x580; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x584; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x588; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x58C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x590; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x594; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x598; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x59C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x5A0; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x5A1; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x5A4; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x5A8; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x5AC; // Vector
}

namespace C_PointWorldText { // C_ModelPointEntity
    constexpr std::ptrdiff_t m_bForceRecreateNextUpdate = 0xCC8; // bool
    constexpr std::ptrdiff_t m_messageText = 0xCD8; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0xED8; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0xF18; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0xF19; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0xF1C; // float
    constexpr std::ptrdiff_t m_flFontSize = 0xF20; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0xF24; // float
    constexpr std::ptrdiff_t m_Color = 0xF28; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0xF2C; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0xF30; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0xF34; // PointWorldTextReorientMode_t
}

namespace C_PostProcessingVolume { // C_BaseTrigger
    constexpr std::ptrdiff_t m_hPostSettings = 0xCD8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0xCE0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0xCE4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0xCE8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0xCEC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0xCF0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0xCF4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0xCF8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0xCFC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0xD00; // float
    constexpr std::ptrdiff_t m_bMaster = 0xD04; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0xD05; // bool
    constexpr std::ptrdiff_t m_flRate = 0xD08; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0xD0C; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0xD10; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0xD14; // float
}

namespace C_Precipitation { // C_BaseTrigger
    constexpr std::ptrdiff_t m_flDensity = 0xCC8; // float
    constexpr std::ptrdiff_t m_flParticleInnerDist = 0xCD8; // float
    constexpr std::ptrdiff_t m_pParticleDef = 0xCE0; // char*
    constexpr std::ptrdiff_t m_tParticlePrecipTraceTimer = 0xD08; // TimedEvent[1]
    constexpr std::ptrdiff_t m_bActiveParticlePrecipEmitter = 0xD10; // bool[1]
    constexpr std::ptrdiff_t m_bParticlePrecipInitialized = 0xD11; // bool
    constexpr std::ptrdiff_t m_bHasSimulatedSinceLastSceneObjectUpdate = 0xD12; // bool
    constexpr std::ptrdiff_t m_nAvailableSheetSequencesMaxIndex = 0xD14; // int32_t
}

namespace C_PrecipitationBlocker { // C_BaseModelEntity
}

namespace C_PredictedViewModel { // C_BaseViewModel
    constexpr std::ptrdiff_t m_LagAnglesHistory = 0xEE8; // QAngle
    constexpr std::ptrdiff_t m_vPredictedOffset = 0xF00; // Vector
}

namespace C_RagdollManager { // C_BaseEntity
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x540; // int8_t
}

namespace C_RagdollProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_ragPos = 0xE88; // C_NetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0xEA0; // C_NetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_flBlendWeight = 0xEB8; // float
    constexpr std::ptrdiff_t m_hRagdollSource = 0xEBC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iEyeAttachment = 0xEC0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flBlendWeightCurrent = 0xEC4; // float
    constexpr std::ptrdiff_t m_parentPhysicsBoneIndices = 0xEC8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldSpaceBoneComputationOrder = 0xEE0; // CUtlVector<int32_t>
}

namespace C_RagdollPropAttached { // C_RagdollProp
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xEF8; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xEFC; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xF00; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xF0C; // Vector
    constexpr std::ptrdiff_t m_vecOffset = 0xF18; // Vector
    constexpr std::ptrdiff_t m_parentTime = 0xF24; // float
    constexpr std::ptrdiff_t m_bHasParent = 0xF28; // bool
}

namespace C_RectLight { // C_BarnLight
    constexpr std::ptrdiff_t m_bShowLight = 0xF08; // bool
}

namespace C_RetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace C_RopeKeyframe { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_LinksTouchingSomething = 0xCC8; // CBitVec<10>
    constexpr std::ptrdiff_t m_nLinksTouchingSomething = 0xCCC; // int32_t
    constexpr std::ptrdiff_t m_bApplyWind = 0xCD0; // bool
    constexpr std::ptrdiff_t m_fPrevLockedPoints = 0xCD4; // int32_t
    constexpr std::ptrdiff_t m_iForcePointMoveCounter = 0xCD8; // int32_t
    constexpr std::ptrdiff_t m_bPrevEndPointPos = 0xCDC; // bool[2]
    constexpr std::ptrdiff_t m_vPrevEndPointPos = 0xCE0; // Vector[2]
    constexpr std::ptrdiff_t m_flCurScroll = 0xCF8; // float
    constexpr std::ptrdiff_t m_flScrollSpeed = 0xCFC; // float
    constexpr std::ptrdiff_t m_RopeFlags = 0xD00; // uint16_t
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0xD08; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_LightValues = 0xF80; // Vector[10]
    constexpr std::ptrdiff_t m_nSegments = 0xFF8; // uint8_t
    constexpr std::ptrdiff_t m_hStartPoint = 0xFFC; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x1000; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x1004; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x1005; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_Subdiv = 0x1006; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x1008; // int16_t
    constexpr std::ptrdiff_t m_Slack = 0x100A; // int16_t
    constexpr std::ptrdiff_t m_TextureScale = 0x100C; // float
    constexpr std::ptrdiff_t m_fLockedPoints = 0x1010; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x1011; // uint8_t
    constexpr std::ptrdiff_t m_Width = 0x1014; // float
    constexpr std::ptrdiff_t m_PhysicsDelegate = 0x1018; // C_RopeKeyframe::CPhysicsDelegate
    constexpr std::ptrdiff_t m_hMaterial = 0x1028; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_TextureHeight = 0x1030; // int32_t
    constexpr std::ptrdiff_t m_vecImpulse = 0x1034; // Vector
    constexpr std::ptrdiff_t m_vecPreviousImpulse = 0x1040; // Vector
    constexpr std::ptrdiff_t m_flCurrentGustTimer = 0x104C; // float
    constexpr std::ptrdiff_t m_flCurrentGustLifetime = 0x1050; // float
    constexpr std::ptrdiff_t m_flTimeToNextGust = 0x1054; // float
    constexpr std::ptrdiff_t m_vWindDir = 0x1058; // Vector
    constexpr std::ptrdiff_t m_vColorMod = 0x1064; // Vector
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentPos = 0x1070; // Vector[2]
    constexpr std::ptrdiff_t m_vCachedEndPointAttachmentAngle = 0x1088; // QAngle[2]
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x10A0; // bool
    constexpr std::ptrdiff_t m_bEndPointAttachmentPositionsDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bEndPointAttachmentAnglesDirty = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNewDataThisFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bPhysicsInitted = 0x0; // bitfield:1
}

namespace C_RopeKeyframe_CPhysicsDelegate {
    constexpr std::ptrdiff_t m_pKeyframe = 0x8; // C_RopeKeyframe*
}

namespace C_SceneEntity { // C_PointEntity
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x548; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x549; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x54A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x54B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x54C; // float
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x550; // uint16_t
    constexpr std::ptrdiff_t m_bClientOnly = 0x552; // bool
    constexpr std::ptrdiff_t m_hOwner = 0x554; // CHandle<C_BaseFlex>
    constexpr std::ptrdiff_t m_hActorList = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BaseFlex>>
    constexpr std::ptrdiff_t m_bWasPlaying = 0x570; // bool
    constexpr std::ptrdiff_t m_QueuedEvents = 0x580; // CUtlVector<C_SceneEntity::QueuedEvents_t>
    constexpr std::ptrdiff_t m_flCurrentTime = 0x598; // float
}

namespace C_SceneEntity_QueuedEvents_t {
    constexpr std::ptrdiff_t starttime = 0x0; // float
}

namespace C_SensorGrenade { // C_BaseCSGrenade
}

namespace C_SensorGrenadeProjectile { // C_BaseCSGrenadeProjectile
}

namespace C_ShatterGlassShardPhysics { // C_PhysicsProp
    constexpr std::ptrdiff_t m_ShardDesc = 0xFE0; // shard_model_desc_t
}

namespace C_SingleplayRules { // C_GameRules
}

namespace C_SkyCamera { // C_BaseEntity
    constexpr std::ptrdiff_t m_skyboxData = 0x540; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x5D0; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x5D4; // bool
    constexpr std::ptrdiff_t m_pNext = 0x5D8; // C_SkyCamera*
}

namespace C_SmokeGrenade { // C_BaseCSGrenade
}

namespace C_SmokeGrenadeProjectile { // C_BaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0x1108; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0x110C; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1110; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0x1114; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0x1120; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0x1130; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_bSmokeVolumeDataReceived = 0x1148; // bool
    constexpr std::ptrdiff_t m_bSmokeEffectSpawned = 0x1149; // bool
}

namespace C_SoundAreaEntityBase { // C_BaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x540; // bool
    constexpr std::ptrdiff_t m_bWasEnabled = 0x548; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x558; // Vector
}

namespace C_SoundAreaEntityOrientedBox { // C_SoundAreaEntityBase
    constexpr std::ptrdiff_t m_vMin = 0x568; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x574; // Vector
}

namespace C_SoundAreaEntitySphere { // C_SoundAreaEntityBase
    constexpr std::ptrdiff_t m_flRadius = 0x568; // float
}

namespace C_SoundOpvarSetAABBEntity { // C_SoundOpvarSetPointEntity
}

namespace C_SoundOpvarSetOBBEntity { // C_SoundOpvarSetAABBEntity
}

namespace C_SoundOpvarSetOBBWindEntity { // C_SoundOpvarSetPointBase
}

namespace C_SoundOpvarSetPathCornerEntity { // C_SoundOpvarSetPointEntity
}

namespace C_SoundOpvarSetPointBase { // C_BaseEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x548; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x55C; // bool
}

namespace C_SoundOpvarSetPointEntity { // C_SoundOpvarSetPointBase
}

namespace C_SpotlightEnd { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_flLightScale = 0xCC0; // float
    constexpr std::ptrdiff_t m_Radius = 0xCC4; // float
}

namespace C_Sprite { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0xCD8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0xCE0; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0xCE4; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0xCE8; // float
    constexpr std::ptrdiff_t m_flFrame = 0xCEC; // float
    constexpr std::ptrdiff_t m_flDieTime = 0xCF0; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0xD00; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0xD04; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0xD08; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0xD0C; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0xD10; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0xD14; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD18; // float
    constexpr std::ptrdiff_t m_flLastTime = 0xD1C; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0xD20; // float
    constexpr std::ptrdiff_t m_flStartScale = 0xD24; // float
    constexpr std::ptrdiff_t m_flDestScale = 0xD28; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0xD34; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_hOldSpriteMaterial = 0xD40; // CWeakHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nSpriteWidth = 0xDE8; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0xDEC; // int32_t
}

namespace C_SpriteOriented { // C_Sprite
}

namespace C_Sun { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_fxSSSunFlareEffectIndex = 0xCC0; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fxSunFlareEffectIndex = 0xCC4; // ParticleIndex_t
    constexpr std::ptrdiff_t m_fdistNormalize = 0xCC8; // float
    constexpr std::ptrdiff_t m_vSunPos = 0xCCC; // Vector
    constexpr std::ptrdiff_t m_vDirection = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_iszEffectName = 0xCE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0xCF0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_clrOverlay = 0xCF8; // Color
    constexpr std::ptrdiff_t m_bOn = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0xCFD; // bool
    constexpr std::ptrdiff_t m_flSize = 0xD00; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0xD04; // float
    constexpr std::ptrdiff_t m_flRotation = 0xD08; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0xD0C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0xD10; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0xD14; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0xD18; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0xD1C; // float
}

namespace C_SunGlowOverlay { // CGlowOverlay
    constexpr std::ptrdiff_t m_bModulateByDot = 0xD0; // bool
}

namespace C_Team { // C_BaseEntity
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x540; // C_NetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x558; // C_NetworkUtlVectorBase<CHandle<C_BasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x570; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x574; // char[129]
}

namespace C_TeamRoundTimer { // C_BaseEntity
    constexpr std::ptrdiff_t m_bTimerPaused = 0x540; // bool
    constexpr std::ptrdiff_t m_flTimeRemaining = 0x544; // float
    constexpr std::ptrdiff_t m_flTimerEndTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDisabled = 0x54C; // bool
    constexpr std::ptrdiff_t m_bShowInHUD = 0x54D; // bool
    constexpr std::ptrdiff_t m_nTimerLength = 0x550; // int32_t
    constexpr std::ptrdiff_t m_nTimerInitialLength = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nTimerMaxLength = 0x558; // int32_t
    constexpr std::ptrdiff_t m_bAutoCountdown = 0x55C; // bool
    constexpr std::ptrdiff_t m_nSetupTimeLength = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nState = 0x564; // int32_t
    constexpr std::ptrdiff_t m_bStartPaused = 0x568; // bool
    constexpr std::ptrdiff_t m_bInCaptureWatchState = 0x569; // bool
    constexpr std::ptrdiff_t m_flTotalTime = 0x56C; // float
    constexpr std::ptrdiff_t m_bStopWatchTimer = 0x570; // bool
    constexpr std::ptrdiff_t m_bFireFinished = 0x571; // bool
    constexpr std::ptrdiff_t m_bFire5MinRemain = 0x572; // bool
    constexpr std::ptrdiff_t m_bFire4MinRemain = 0x573; // bool
    constexpr std::ptrdiff_t m_bFire3MinRemain = 0x574; // bool
    constexpr std::ptrdiff_t m_bFire2MinRemain = 0x575; // bool
    constexpr std::ptrdiff_t m_bFire1MinRemain = 0x576; // bool
    constexpr std::ptrdiff_t m_bFire30SecRemain = 0x577; // bool
    constexpr std::ptrdiff_t m_bFire10SecRemain = 0x578; // bool
    constexpr std::ptrdiff_t m_bFire5SecRemain = 0x579; // bool
    constexpr std::ptrdiff_t m_bFire4SecRemain = 0x57A; // bool
    constexpr std::ptrdiff_t m_bFire3SecRemain = 0x57B; // bool
    constexpr std::ptrdiff_t m_bFire2SecRemain = 0x57C; // bool
    constexpr std::ptrdiff_t m_bFire1SecRemain = 0x57D; // bool
    constexpr std::ptrdiff_t m_nOldTimerLength = 0x580; // int32_t
    constexpr std::ptrdiff_t m_nOldTimerState = 0x584; // int32_t
}

namespace C_TeamplayRules { // C_MultiplayRules
}

namespace C_TextureBasedAnimatable { // C_BaseModelEntity
    constexpr std::ptrdiff_t m_bLoop = 0xCC0; // bool
    constexpr std::ptrdiff_t m_flFPS = 0xCC4; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0xCC8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0xCD0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0xCE4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0xCF0; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0xCF4; // float
}

namespace C_TintController { // C_BaseEntity
}

namespace C_TonemapController2 { // C_BaseEntity
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x540; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x544; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x548; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x54C; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x550; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x554; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x558; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x55C; // float
}

namespace C_TonemapController2Alias_env_tonemap_controller2 { // C_TonemapController2
}

namespace C_TriggerBuoyancy { // C_BaseTrigger
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0xCC8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0xCE8; // float
}

namespace C_TriggerLerpObject { // C_BaseTrigger
}

namespace C_TriggerMultiple { // C_BaseTrigger
}

namespace C_TriggerVolume { // C_BaseModelEntity
}

namespace C_ViewmodelAttachmentModel { // CBaseAnimGraph
}

namespace C_ViewmodelWeapon { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_worldModel = 0xE80; // char*
}

namespace C_VoteController { // C_BaseEntity
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x550; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x554; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x558; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bVotesDirty = 0x570; // bool
    constexpr std::ptrdiff_t m_bTypeDirty = 0x571; // bool
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x572; // bool
}

namespace C_WaterBullet { // CBaseAnimGraph
}

namespace C_WeaponAWP { // C_CSWeaponBaseGun
}

namespace C_WeaponAug { // C_CSWeaponBaseGun
}

namespace C_WeaponBaseItem { // C_CSWeaponBase
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0x19F0; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0x1A08; // bool
}

namespace C_WeaponBizon { // C_CSWeaponBaseGun
}

namespace C_WeaponCZ75a { // C_CSWeaponBaseGun
}

namespace C_WeaponElite { // C_CSWeaponBaseGun
}

namespace C_WeaponFamas { // C_CSWeaponBaseGun
}

namespace C_WeaponFiveSeven { // C_CSWeaponBaseGun
}

namespace C_WeaponG3SG1 { // C_CSWeaponBaseGun
}

namespace C_WeaponGalilAR { // C_CSWeaponBaseGun
}

namespace C_WeaponGlock { // C_CSWeaponBaseGun
}

namespace C_WeaponHKP2000 { // C_CSWeaponBaseGun
}

namespace C_WeaponM249 { // C_CSWeaponBaseGun
}

namespace C_WeaponM4A1 { // C_CSWeaponBaseGun
}

namespace C_WeaponM4A1Silencer { // C_CSWeaponBaseGun
}

namespace C_WeaponMAC10 { // C_CSWeaponBaseGun
}

namespace C_WeaponMP5SD { // C_CSWeaponBaseGun
}

namespace C_WeaponMP7 { // C_CSWeaponBaseGun
}

namespace C_WeaponMP9 { // C_CSWeaponBaseGun
}

namespace C_WeaponMag7 { // C_CSWeaponBaseGun
}

namespace C_WeaponNOVA { // C_CSWeaponBase
}

namespace C_WeaponNegev { // C_CSWeaponBaseGun
}

namespace C_WeaponP250 { // C_CSWeaponBaseGun
}

namespace C_WeaponP90 { // C_CSWeaponBaseGun
}

namespace C_WeaponRevolver { // C_CSWeaponBaseGun
}

namespace C_WeaponSCAR20 { // C_CSWeaponBaseGun
}

namespace C_WeaponSG556 { // C_CSWeaponBaseGun
}

namespace C_WeaponSSG08 { // C_CSWeaponBaseGun
}

namespace C_WeaponSawedoff { // C_CSWeaponBase
}

namespace C_WeaponShield { // C_CSWeaponBaseGun
    constexpr std::ptrdiff_t m_flDisplayHealth = 0x1A10; // float
}

namespace C_WeaponTaser { // C_CSWeaponBaseGun
    constexpr std::ptrdiff_t m_fFireTime = 0x1A10; // GameTime_t
}

namespace C_WeaponTec9 { // C_CSWeaponBaseGun
}

namespace C_WeaponUMP45 { // C_CSWeaponBaseGun
}

namespace C_WeaponUSPSilencer { // C_CSWeaponBaseGun
}

namespace C_WeaponXM1014 { // C_CSWeaponBase
}

namespace C_World { // C_BaseModelEntity
}

namespace C_WorldModelGloves { // CBaseAnimGraph
}

namespace C_WorldModelNametag { // CBaseAnimGraph
}

namespace C_WorldModelStattrak { // CBaseAnimGraph
}

namespace C_fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<C_FogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace CompMatMutatorCondition_t {
    constexpr std::ptrdiff_t m_nMutatorCondition = 0x0; // CompMatPropertyMutatorConditionType_t
    constexpr std::ptrdiff_t m_strMutatorConditionContainerName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strMutatorConditionContainerVarValue = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x20; // bool
}

namespace CompMatPropertyMutator_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nMutatorCommandType = 0x4; // CompMatPropertyMutatorType_t
    constexpr std::ptrdiff_t m_strInitWith_Container = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerSrc = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_InputContainerProperty = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_strCopyProperty_TargetProperty = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strRandomRollInputVars_SeedInputVar = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecRandomRollInputVars_InputVarsToRoll = 0x30; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_strCopyMatchingKeys_InputContainerSrc = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_InputContainerSrc = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_FindSuffix = 0x58; // CUtlString
    constexpr std::ptrdiff_t m_strCopyKeysWithSuffix_ReplaceSuffix = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_nSetValue_Value = 0x68; // CompositeMaterialInputLooseVariable_t
    constexpr std::ptrdiff_t m_strGenerateTexture_TargetParam = 0x2D8; // CUtlString
    constexpr std::ptrdiff_t m_strGenerateTexture_InitialContainer = 0x2E0; // CUtlString
    constexpr std::ptrdiff_t m_nResolution = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_bIsScratchTarget = 0x2EC; // bool
    constexpr std::ptrdiff_t m_bSplatDebugInfo = 0x2ED; // bool
    constexpr std::ptrdiff_t m_bCaptureInRenderDoc = 0x2EE; // bool
    constexpr std::ptrdiff_t m_vecTexGenInstructions = 0x2F0; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_vecConditionalMutators = 0x308; // CUtlVector<CompMatPropertyMutator_t>
    constexpr std::ptrdiff_t m_strPopInputQueue_Container = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerSrc = 0x328; // CUtlString
    constexpr std::ptrdiff_t m_strDrawText_InputContainerProperty = 0x330; // CUtlString
    constexpr std::ptrdiff_t m_vecDrawText_Position = 0x338; // Vector2D
    constexpr std::ptrdiff_t m_colDrawText_Color = 0x340; // Color
    constexpr std::ptrdiff_t m_strDrawText_Font = 0x348; // CUtlString
    constexpr std::ptrdiff_t m_vecConditions = 0x350; // CUtlVector<CompMatMutatorCondition_t>
}

namespace CompositeMaterialAssemblyProcedure_t {
    constexpr std::ptrdiff_t m_vecCompMatIncludes = 0x0; // CUtlVector<CResourceName>
    constexpr std::ptrdiff_t m_vecMatchFilters = 0x18; // CUtlVector<CompositeMaterialMatchFilter_t>
    constexpr std::ptrdiff_t m_vecCompositeInputContainers = 0x30; // CUtlVector<CompositeMaterialInputContainer_t>
    constexpr std::ptrdiff_t m_vecPropertyMutators = 0x48; // CUtlVector<CompMatPropertyMutator_t>
}

namespace CompositeMaterialEditorPoint_t {
    constexpr std::ptrdiff_t m_ModelName = 0x0; // CResourceName
    constexpr std::ptrdiff_t m_nSequenceIndex = 0xE0; // int32_t
    constexpr std::ptrdiff_t m_flCycle = 0xE4; // float
    constexpr std::ptrdiff_t m_KVModelStateChoices = 0xE8; // KeyValues3
    constexpr std::ptrdiff_t m_bEnableChildModel = 0xF8; // bool
    constexpr std::ptrdiff_t m_ChildModelName = 0x100; // CResourceName
    constexpr std::ptrdiff_t m_vecCompositeMaterialAssemblyProcedures = 0x1E0; // CUtlVector<CompositeMaterialAssemblyProcedure_t>
    constexpr std::ptrdiff_t m_vecCompositeMaterials = 0x1F8; // CUtlVector<CompositeMaterial_t>
}

namespace CompositeMaterialInputContainer_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_nCompositeMaterialInputContainerSourceType = 0x4; // CompositeMaterialInputContainerSourceType_t
    constexpr std::ptrdiff_t m_strSpecificContainerMaterial = 0x8; // CResourceName
    constexpr std::ptrdiff_t m_strAttrName = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_strAlias = 0xF0; // CUtlString
    constexpr std::ptrdiff_t m_vecLooseVariables = 0xF8; // CUtlVector<CompositeMaterialInputLooseVariable_t>
    constexpr std::ptrdiff_t m_strAttrNameForVar = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x118; // bool
}

namespace CompositeMaterialInputLooseVariable_t {
    constexpr std::ptrdiff_t m_strName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_bExposeExternally = 0x8; // bool
    constexpr std::ptrdiff_t m_strExposedFriendlyName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_strExposedFriendlyGroupName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_bExposedVariableIsFixedRange = 0x20; // bool
    constexpr std::ptrdiff_t m_strExposedVisibleWhenTrue = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strExposedHiddenWhenTrue = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_nVariableType = 0x38; // CompositeMaterialInputLooseVariableType_t
    constexpr std::ptrdiff_t m_bValueBoolean = 0x3C; // bool
    constexpr std::ptrdiff_t m_nValueIntX = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nValueIntY = 0x44; // int32_t
    constexpr std::ptrdiff_t m_nValueIntZ = 0x48; // int32_t
    constexpr std::ptrdiff_t m_nValueIntW = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_bHasFloatBounds = 0x50; // bool
    constexpr std::ptrdiff_t m_flValueFloatX = 0x54; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Min = 0x58; // float
    constexpr std::ptrdiff_t m_flValueFloatX_Max = 0x5C; // float
    constexpr std::ptrdiff_t m_flValueFloatY = 0x60; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Min = 0x64; // float
    constexpr std::ptrdiff_t m_flValueFloatY_Max = 0x68; // float
    constexpr std::ptrdiff_t m_flValueFloatZ = 0x6C; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Min = 0x70; // float
    constexpr std::ptrdiff_t m_flValueFloatZ_Max = 0x74; // float
    constexpr std::ptrdiff_t m_flValueFloatW = 0x78; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Min = 0x7C; // float
    constexpr std::ptrdiff_t m_flValueFloatW_Max = 0x80; // float
    constexpr std::ptrdiff_t m_cValueColor4 = 0x84; // Color
    constexpr std::ptrdiff_t m_nValueSystemVar = 0x88; // CompositeMaterialVarSystemVar_t
    constexpr std::ptrdiff_t m_strResourceMaterial = 0x90; // CResourceName
    constexpr std::ptrdiff_t m_strTextureContentAssetPath = 0x170; // CUtlString
    constexpr std::ptrdiff_t m_strTextureRuntimeResourcePath = 0x178; // CResourceName
    constexpr std::ptrdiff_t m_strTextureCompilationVtexTemplate = 0x258; // CUtlString
    constexpr std::ptrdiff_t m_nTextureType = 0x260; // CompositeMaterialInputTextureType_t
    constexpr std::ptrdiff_t m_strString = 0x268; // CUtlString
}

namespace CompositeMaterialMatchFilter_t {
    constexpr std::ptrdiff_t m_nCompositeMaterialMatchFilterType = 0x0; // CompositeMaterialMatchFilterType_t
    constexpr std::ptrdiff_t m_strMatchFilter = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_strMatchValue = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bPassWhenTrue = 0x18; // bool
}

namespace CompositeMaterial_t {
    constexpr std::ptrdiff_t m_TargetKVs = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_PreGenerationKVs = 0x18; // KeyValues3
    constexpr std::ptrdiff_t m_FinalKVs = 0x28; // KeyValues3
    constexpr std::ptrdiff_t m_vecGeneratedTextures = 0x40; // CUtlVector<GeneratedTextureHandle_t>
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace GeneratedTextureHandle_t {
    constexpr std::ptrdiff_t m_strBitmapName = 0x0; // CUtlString
}

namespace IClientAlphaProperty {
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // C_NetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<C_BaseEntity>
    constexpr std::ptrdiff_t m_bDirty = 0x68; // bool
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace TimedEvent {
    constexpr std::ptrdiff_t m_TimeBetweenEvents = 0x0; // float
    constexpr std::ptrdiff_t m_fNextEvent = 0x4; // float
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // C_UtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // C_NetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}
```

`HPCS2/offset/engine2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace CEmptyEntityInstance {
}

namespace CEntityComponent {
}

namespace CEntityComponentHelper {
    constexpr std::ptrdiff_t m_flags = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pInfo = 0x10; // EntComponentInfo_t*
    constexpr std::ptrdiff_t m_nPriority = 0x18; // int32_t
    constexpr std::ptrdiff_t m_pNext = 0x20; // CEntityComponentHelper*
}

namespace CEntityIOOutput {
    constexpr std::ptrdiff_t m_Value = 0x18; // CVariantBase<CVariantDefaultAllocator>
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CNetworkVarChainer {
    constexpr std::ptrdiff_t m_PathIndex = 0x20; // ChangeAccessorFieldPathIndex_t
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CVariantDefaultAllocator {
}

namespace EngineLoopState_t {
    constexpr std::ptrdiff_t m_nPlatWindowWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nPlatWindowHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nRenderWidth = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nRenderHeight = 0x24; // int32_t
}

namespace EntComponentInfo_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char*
    constexpr std::ptrdiff_t m_pCPPClassname = 0x8; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedDescription = 0x10; // char*
    constexpr std::ptrdiff_t m_pNetworkDataReferencedPtrPropDescription = 0x18; // char*
    constexpr std::ptrdiff_t m_nRuntimeIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nFlags = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_pBaseClassComponentHelper = 0x60; // CEntityComponentHelper*
}

namespace EntInput_t {
}

namespace EntOutput_t {
}

namespace EventAdvanceTick_t { // EventSimulate_t
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventAppShutdown_t {
    constexpr std::ptrdiff_t m_nDummy0 = 0x0; // int32_t
}

namespace EventClientAdvanceTick_t { // EventAdvanceTick_t
}

namespace EventClientFrameSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // float
    constexpr std::ptrdiff_t m_flRealTime = 0x2C; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x30; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x34; // bool
}

namespace EventClientPauseSimulate_t { // EventSimulate_t
}

namespace EventClientPollInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientPollNetworking_t {
    constexpr std::ptrdiff_t m_nTickCount = 0x0; // int32_t
}

namespace EventClientPostAdvanceTick_t { // EventPostAdvanceTick_t
}

namespace EventClientPostOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // float
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x34; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x38; // bool
}

namespace EventClientPostSimulate_t { // EventSimulate_t
}

namespace EventClientPreOutput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRenderTime = 0x28; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x38; // double
    constexpr std::ptrdiff_t m_flRealTime = 0x40; // float
    constexpr std::ptrdiff_t m_bRenderOnly = 0x44; // bool
}

namespace EventClientPreSimulate_t { // EventSimulate_t
}

namespace EventClientPredictionPostNetupdate_t {
}

namespace EventClientProcessGameInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventClientProcessInput_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
}

namespace EventClientProcessNetworking_t {
}

namespace EventClientSceneSystemThreadStateChange_t {
    constexpr std::ptrdiff_t m_bThreadsActive = 0x0; // bool
}

namespace EventClientSendInput_t {
    constexpr std::ptrdiff_t m_bFinalClientCommandTick = 0x0; // bool
    constexpr std::ptrdiff_t m_nAdditionalClientCommandsToCreate = 0x4; // int32_t
}

namespace EventClientSimulate_t { // EventSimulate_t
}

namespace EventFrameBoundary_t {
    constexpr std::ptrdiff_t m_flFrameTime = 0x0; // float
}

namespace EventHostTimescaleChanged_t {
    constexpr std::ptrdiff_t m_flOldValue = 0x0; // float
    constexpr std::ptrdiff_t m_flNewValue = 0x4; // float
}

namespace EventModInitialized_t {
}

namespace EventPostAdvanceTick_t { // EventSimulate_t
    constexpr std::ptrdiff_t m_nCurrentTick = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nCurrentTickThisFrame = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicksThisFrame = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nTotalTicks = 0x3C; // int32_t
}

namespace EventPostDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventPreDataUpdate_t {
    constexpr std::ptrdiff_t m_nCount = 0x0; // int32_t
}

namespace EventProfileStorageAvailable_t {
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x0; // CSplitScreenSlot
}

namespace EventServerAdvanceTick_t { // EventAdvanceTick_t
}

namespace EventServerPollNetworking_t { // EventSimulate_t
}

namespace EventServerPostAdvanceTick_t { // EventPostAdvanceTick_t
}

namespace EventServerPostSimulate_t { // EventSimulate_t
}

namespace EventServerProcessNetworking_t { // EventSimulate_t
}

namespace EventServerSimulate_t { // EventSimulate_t
}

namespace EventSetTime_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_nClientOutputFrames = 0x28; // int32_t
    constexpr std::ptrdiff_t m_flRealTime = 0x30; // double
    constexpr std::ptrdiff_t m_flRenderTime = 0x38; // double
    constexpr std::ptrdiff_t m_flRenderFrameTime = 0x40; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnbounded = 0x48; // double
    constexpr std::ptrdiff_t m_flRenderFrameTimeUnscaled = 0x50; // double
    constexpr std::ptrdiff_t m_flTickRemainder = 0x58; // double
}

namespace EventSimpleLoopFrameUpdate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_flRealTime = 0x28; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x2C; // float
}

namespace EventSimulate_t {
    constexpr std::ptrdiff_t m_LoopState = 0x0; // EngineLoopState_t
    constexpr std::ptrdiff_t m_bFirstTick = 0x28; // bool
    constexpr std::ptrdiff_t m_bLastTick = 0x29; // bool
}

namespace EventSplitScreenStateChanged_t {
}
```

`HPCS2/offset/host.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:53 +0000
 */

#pragma once

#include <cstddef>

namespace CAnimScriptBase {
    constexpr std::ptrdiff_t m_bIsValid = 0x8; // bool
}

namespace EmptyTestScript { // CAnimScriptBase
    constexpr std::ptrdiff_t m_hTest = 0x10; // CAnimScriptParam<float>
}
```

`HPCS2/offset/interfaces.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:53 +0000
 */

#pragma once

#include <cstddef>

namespace animationsystem_dll { // animationsystem.dll
    constexpr std::ptrdiff_t AnimationSystemUtils_001 = 0x64670;
    constexpr std::ptrdiff_t AnimationSystem_001 = 0x5F1D0;
}

namespace client_dll { // client.dll
    constexpr std::ptrdiff_t LegacyGameUI001 = 0x89C960;
    constexpr std::ptrdiff_t Source2ClientUI001 = 0x88B670;
    constexpr std::ptrdiff_t Source2ClientPrediction001 = 0x7A3990;
    constexpr std::ptrdiff_t ClientToolsInfo_001 = 0x72F780;
    constexpr std::ptrdiff_t Source2Client002 = 0x72F7A0;
    constexpr std::ptrdiff_t GameClientExports001 = 0x72F790;
    constexpr std::ptrdiff_t EmptyWorldService001_Client = 0x48FD90;
    constexpr std::ptrdiff_t Source2ClientConfig001 = 0x476CD0;
}

namespace engine2_dll { // engine2.dll
    constexpr std::ptrdiff_t SimpleEngineLoopService_001 = 0x1E4700;
    constexpr std::ptrdiff_t ClientServerEngineLoopService_001 = 0x1DA350;
    constexpr std::ptrdiff_t KeyValueCache001 = 0x1D6990;
    constexpr std::ptrdiff_t HostStateMgr001 = 0x1D4190;
    constexpr std::ptrdiff_t GameEventSystemServerV001 = 0x1CF830;
    constexpr std::ptrdiff_t GameEventSystemClientV001 = 0x1CF820;
    constexpr std::ptrdiff_t EngineServiceMgr001 = 0x1CB510;
    constexpr std::ptrdiff_t VProfService_001 = 0x1B8E80;
    constexpr std::ptrdiff_t ToolService_001 = 0x1B7BD0;
    constexpr std::ptrdiff_t StatsService_001 = 0x1B2E50;
    constexpr std::ptrdiff_t SplitScreenService_001 = 0x1B00C0;
    constexpr std::ptrdiff_t SoundService_001 = 0x1AAC00;
    constexpr std::ptrdiff_t ScreenshotService001 = 0x1A6AD0;
    constexpr std::ptrdiff_t RenderService_001 = 0x1A3E30;
    constexpr std::ptrdiff_t NetworkService_001 = 0x1A3940;
    constexpr std::ptrdiff_t NetworkServerService_001 = 0x19E7F0;
    constexpr std::ptrdiff_t NetworkP2PService_001 = 0x19A2E0;
    constexpr std::ptrdiff_t NetworkClientService_001 = 0x193F70;
    constexpr std::ptrdiff_t MapListService_001 = 0x18CF40;
    constexpr std::ptrdiff_t InputService_001 = 0x17ABB0;
    constexpr std::ptrdiff_t GameUIService_001 = 0x1753D0;
    constexpr std::ptrdiff_t GameResourceServiceServerV001 = 0x173130;
    constexpr std::ptrdiff_t GameResourceServiceClientV001 = 0x173120;
    constexpr std::ptrdiff_t BugService001 = 0x16C150;
    constexpr std::ptrdiff_t BenchmarkService001 = 0x16A920;
    constexpr std::ptrdiff_t VENGINE_GAMEUIFUNCS_VERSION005 = 0x118430;
    constexpr std::ptrdiff_t EngineGameUI001 = 0x1177C0;
    constexpr std::ptrdiff_t INETSUPPORT_001 = 0xE6E20;
    constexpr std::ptrdiff_t Source2EngineToServerStringTable001 = 0xA2410;
    constexpr std::ptrdiff_t Source2EngineToServer001 = 0x8B6F0;
    constexpr std::ptrdiff_t Source2EngineToClientStringTable001 = 0x841D0;
    constexpr std::ptrdiff_t Source2EngineToClient001 = 0x5A990;
}

namespace filesystem_stdio_dll { // filesystem_stdio.dll
    constexpr std::ptrdiff_t VAsyncFileSystem2_001 = 0x66D30;
    constexpr std::ptrdiff_t VFileSystem017 = 0x66D20;
}

namespace host_dll { // host.dll
    constexpr std::ptrdiff_t Source2Host001 = 0x18E10;
    constexpr std::ptrdiff_t SinglePlayerSharedMemory001 = 0x18A90;
    constexpr std::ptrdiff_t SaveRestoreDataVersion001 = 0x18A80;
    constexpr std::ptrdiff_t PredictionDiffManager001 = 0x16E20;
    constexpr std::ptrdiff_t HostUtils001 = 0x12550;
    constexpr std::ptrdiff_t GameSystem2HostHook = 0x11DA0;
    constexpr std::ptrdiff_t GameModelInfo001 = 0x11CC0;
    constexpr std::ptrdiff_t DebugDrawQueueManager001 = 0x11710;
}

namespace imemanager_dll { // imemanager.dll
    constexpr std::ptrdiff_t IMEManager001 = 0xC470;
}

namespace inputsystem_dll { // inputsystem.dll
    constexpr std::ptrdiff_t InputSystemVersion001 = 0x28D0;
    constexpr std::ptrdiff_t InputStackSystemVersion001 = 0x16F0;
}

namespace localize_dll { // localize.dll
    constexpr std::ptrdiff_t Localize_001 = 0x3830;
}

namespace matchmaking_dll { // matchmaking.dll
    constexpr std::ptrdiff_t GameTypes001 = 0x50270;
    constexpr std::ptrdiff_t MATCHFRAMEWORK_001 = 0x1012B0;
}

namespace materialsystem2_dll { // materialsystem2.dll
    constexpr std::ptrdiff_t MaterialUtils_001 = 0x4DB90;
    constexpr std::ptrdiff_t TextLayout_001 = 0x4A2E0;
    constexpr std::ptrdiff_t PostProcessingSystem_001 = 0x42A60;
    constexpr std::ptrdiff_t FontManager_001 = 0x37900;
    constexpr std::ptrdiff_t VMaterialSystem2_001 = 0x25EC0;
}

namespace meshsystem_dll { // meshsystem.dll
    constexpr std::ptrdiff_t MeshSystem001 = 0x7270;
}

namespace navsystem_dll { // navsystem.dll
    constexpr std::ptrdiff_t NavSystem001 = 0x76F0;
}

namespace networksystem_dll { // networksystem.dll
    constexpr std::ptrdiff_t SerializedEntitiesVersion001 = 0xD1EB0;
    constexpr std::ptrdiff_t NetworkSystemVersion001 = 0xBC6E0;
    constexpr std::ptrdiff_t NetworkMessagesVersion001 = 0x9C6D0;
    constexpr std::ptrdiff_t FlattenedSerializersVersion001 = 0x7C440;
}

namespace panorama_dll { // panorama.dll
    constexpr std::ptrdiff_t PanoramaUIEngine001 = 0x57EE0;
}

namespace panorama_text_pango_dll { // panorama_text_pango.dll
    constexpr std::ptrdiff_t PanoramaTextServices001 = 0x4CBD0;
}

namespace panoramauiclient_dll { // panoramauiclient.dll
    constexpr std::ptrdiff_t PanoramaUIClient001 = 0x12780;
}

namespace particles_dll { // particles.dll
    constexpr std::ptrdiff_t ParticleSystemMgr003 = 0x52D20;
}

namespace pulse_system_dll { // pulse_system.dll
    constexpr std::ptrdiff_t IPulseSystem_001 = 0x5B30;
}

namespace rendersystemdx11_dll { // rendersystemdx11.dll
    constexpr std::ptrdiff_t RenderUtils_001 = 0x530F0;
    constexpr std::ptrdiff_t VRenderDeviceMgrBackdoor001 = 0x4A690;
    constexpr std::ptrdiff_t RenderDeviceMgr001 = 0x4A680;
}

namespace resourcesystem_dll { // resourcesystem.dll
    constexpr std::ptrdiff_t ResourceSystem013 = 0x10650;
}

namespace scenefilecache_dll { // scenefilecache.dll
    constexpr std::ptrdiff_t SceneFileCache002 = 0x68E0;
    constexpr std::ptrdiff_t ResponseRulesCache001 = 0x3190;
}

namespace scenesystem_dll { // scenesystem.dll
    constexpr std::ptrdiff_t SceneUtils_001 = 0x13C9E0;
    constexpr std::ptrdiff_t SceneSystem_002 = 0xCAA30;
    constexpr std::ptrdiff_t RenderingPipelines_001 = 0x8E8A0;
}

namespace schemasystem_dll { // schemasystem.dll
    constexpr std::ptrdiff_t SchemaSystem_001 = 0xA930;
}

namespace server_dll { // server.dll
    constexpr std::ptrdiff_t NavGameTest001 = 0xA3A970;
    constexpr std::ptrdiff_t ServerToolsInfo_001 = 0x83D770;
    constexpr std::ptrdiff_t Source2GameClients001 = 0x83D780;
    constexpr std::ptrdiff_t Source2GameEntities001 = 0x83D790;
    constexpr std::ptrdiff_t Source2Server001 = 0x83D7A0;
    constexpr std::ptrdiff_t EmptyWorldService001_Server = 0x591C00;
    constexpr std::ptrdiff_t Source2ServerConfig001 = 0x571B30;
    constexpr std::ptrdiff_t EntitySubclassUtilsV001 = 0x2D08A0;
    constexpr std::ptrdiff_t customnavsystem001 = 0x24D620;
    constexpr std::ptrdiff_t Source2GameDirector001 = 0x1453E0;
}

namespace soundsystem_dll { // soundsystem.dll
    constexpr std::ptrdiff_t SoundOpSystem001 = 0x1567E0;
    constexpr std::ptrdiff_t SoundOpSystemEdit001 = 0x8BBC0;
    constexpr std::ptrdiff_t VMixEditTool001 = 0x71740;
    constexpr std::ptrdiff_t SoundSystem001 = 0x46540;
}

namespace steamaudio_dll { // steamaudio.dll
    constexpr std::ptrdiff_t SteamAudio001 = 0x12EE0;
}

namespace steamclient64_dll { // steamclient64.dll
    constexpr std::ptrdiff_t IVALIDATE001 = 0x84FD80;
    constexpr std::ptrdiff_t CLIENTENGINE_INTERFACE_VERSION005 = 0x84BC30;
    constexpr std::ptrdiff_t SteamClient021 = 0x6460C0;
    constexpr std::ptrdiff_t SteamClient020 = 0x6460B0;
    constexpr std::ptrdiff_t SteamClient019 = 0x6460A0;
    constexpr std::ptrdiff_t SteamClient018 = 0x646090;
    constexpr std::ptrdiff_t SteamClient017 = 0x646080;
    constexpr std::ptrdiff_t SteamClient016 = 0x646070;
    constexpr std::ptrdiff_t SteamClient015 = 0x646060;
    constexpr std::ptrdiff_t SteamClient014 = 0x646050;
    constexpr std::ptrdiff_t SteamClient013 = 0x646040;
    constexpr std::ptrdiff_t SteamClient012 = 0x646030;
    constexpr std::ptrdiff_t SteamClient011 = 0x646020;
    constexpr std::ptrdiff_t SteamClient010 = 0x646010;
    constexpr std::ptrdiff_t SteamClient009 = 0x646000;
    constexpr std::ptrdiff_t SteamClient008 = 0x645FF0;
    constexpr std::ptrdiff_t SteamClient007 = 0x645FE0;
    constexpr std::ptrdiff_t SteamClient006 = 0x645FD0;
    constexpr std::ptrdiff_t p2pvoice002 = 0xD97D0;
    constexpr std::ptrdiff_t p2pvoicesingleton002 = 0xD6200;
}

namespace tier0_dll { // tier0.dll
    constexpr std::ptrdiff_t VStringTokenSystem001 = 0x18C2B0;
    constexpr std::ptrdiff_t TestScriptMgr001 = 0x13F610;
    constexpr std::ptrdiff_t VProcessUtils002 = 0x12F790;
    constexpr std::ptrdiff_t VEngineCvar007 = 0x61920;
}

namespace v8system_dll { // v8system.dll
    constexpr std::ptrdiff_t Source2V8System001 = 0x1670;
}

namespace valve_avi_dll { // valve_avi.dll
    constexpr std::ptrdiff_t VAvi001 = 0x2F90;
}

namespace valve_wmf_dll { // valve_wmf.dll
    constexpr std::ptrdiff_t VMediaFoundation001 = 0x12D0;
}

namespace vphysics2_dll { // vphysics2.dll
    constexpr std::ptrdiff_t VPhysics2_Handle_Interface_001 = 0x61120;
    constexpr std::ptrdiff_t VPhysics2_Interface_001 = 0x5C740;
}

namespace vscript_dll { // vscript.dll
    constexpr std::ptrdiff_t VScriptManager010 = 0x31DA0;
}

namespace vstdlib_s64_dll { // vstdlib_s64.dll
    constexpr std::ptrdiff_t IVALIDATE001 = 0x25000;
    constexpr std::ptrdiff_t VEngineCvar002 = 0x5760;
}

namespace worldrenderer_dll { // worldrenderer.dll
    constexpr std::ptrdiff_t WorldRendererMgr001 = 0x21650;
}
```

`HPCS2/offset/materialsystem2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace MaterialParamBuffer_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlBinaryBlock
}

namespace MaterialParamFloat_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_flValue = 0x8; // float
}

namespace MaterialParamInt_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace MaterialParamString_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // CUtlString
}

namespace MaterialParamTexture_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_pValue = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace MaterialParamVector_t { // MaterialParam_t
    constexpr std::ptrdiff_t m_value = 0x8; // Vector4D
}

namespace MaterialParam_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace MaterialResourceData_t {
    constexpr std::ptrdiff_t m_materialName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_shaderName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_intParams = 0x10; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatParams = 0x28; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorParams = 0x40; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureParams = 0x58; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_dynamicParams = 0x70; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_dynamicTextureParams = 0x88; // CUtlVector<MaterialParamBuffer_t>
    constexpr std::ptrdiff_t m_intAttributes = 0xA0; // CUtlVector<MaterialParamInt_t>
    constexpr std::ptrdiff_t m_floatAttributes = 0xB8; // CUtlVector<MaterialParamFloat_t>
    constexpr std::ptrdiff_t m_vectorAttributes = 0xD0; // CUtlVector<MaterialParamVector_t>
    constexpr std::ptrdiff_t m_textureAttributes = 0xE8; // CUtlVector<MaterialParamTexture_t>
    constexpr std::ptrdiff_t m_stringAttributes = 0x100; // CUtlVector<MaterialParamString_t>
    constexpr std::ptrdiff_t m_renderAttributesUsed = 0x118; // CUtlVector<CUtlString>
}

namespace PostProcessingBloomParameters_t {
    constexpr std::ptrdiff_t m_blendMode = 0x0; // BloomBlendMode_t
    constexpr std::ptrdiff_t m_flBloomStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flScreenBloomStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flBlurBloomStrength = 0xC; // float
    constexpr std::ptrdiff_t m_flBloomThreshold = 0x10; // float
    constexpr std::ptrdiff_t m_flBloomThresholdWidth = 0x14; // float
    constexpr std::ptrdiff_t m_flSkyboxBloomStrength = 0x18; // float
    constexpr std::ptrdiff_t m_flBloomStartValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flBlurWeight = 0x20; // float[5]
    constexpr std::ptrdiff_t m_vBlurTint = 0x34; // Vector[5]
}

namespace PostProcessingLocalContrastParameters_t {
    constexpr std::ptrdiff_t m_flLocalContrastStrength = 0x0; // float
    constexpr std::ptrdiff_t m_flLocalContrastEdgeStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteStart = 0x8; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteEnd = 0xC; // float
    constexpr std::ptrdiff_t m_flLocalContrastVignetteBlur = 0x10; // float
}

namespace PostProcessingResource_t {
    constexpr std::ptrdiff_t m_bHasTonemapParams = 0x0; // bool
    constexpr std::ptrdiff_t m_toneMapParams = 0x4; // PostProcessingTonemapParameters_t
    constexpr std::ptrdiff_t m_bHasBloomParams = 0x40; // bool
    constexpr std::ptrdiff_t m_bloomParams = 0x44; // PostProcessingBloomParameters_t
    constexpr std::ptrdiff_t m_bHasVignetteParams = 0xB4; // bool
    constexpr std::ptrdiff_t m_vignetteParams = 0xB8; // PostProcessingVignetteParameters_t
    constexpr std::ptrdiff_t m_bHasLocalContrastParams = 0xDC; // bool
    constexpr std::ptrdiff_t m_localConstrastParams = 0xE0; // PostProcessingLocalContrastParameters_t
    constexpr std::ptrdiff_t m_nColorCorrectionVolumeDim = 0xF4; // int32_t
    constexpr std::ptrdiff_t m_colorCorrectionVolumeData = 0xF8; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_bHasColorCorrection = 0x110; // bool
}

namespace PostProcessingTonemapParameters_t {
    constexpr std::ptrdiff_t m_flExposureBias = 0x0; // float
    constexpr std::ptrdiff_t m_flShoulderStrength = 0x4; // float
    constexpr std::ptrdiff_t m_flLinearStrength = 0x8; // float
    constexpr std::ptrdiff_t m_flLinearAngle = 0xC; // float
    constexpr std::ptrdiff_t m_flToeStrength = 0x10; // float
    constexpr std::ptrdiff_t m_flToeNum = 0x14; // float
    constexpr std::ptrdiff_t m_flToeDenom = 0x18; // float
    constexpr std::ptrdiff_t m_flWhitePoint = 0x1C; // float
    constexpr std::ptrdiff_t m_flLuminanceSource = 0x20; // float
    constexpr std::ptrdiff_t m_flExposureBiasShadows = 0x24; // float
    constexpr std::ptrdiff_t m_flExposureBiasHighlights = 0x28; // float
    constexpr std::ptrdiff_t m_flMinShadowLum = 0x2C; // float
    constexpr std::ptrdiff_t m_flMaxShadowLum = 0x30; // float
    constexpr std::ptrdiff_t m_flMinHighlightLum = 0x34; // float
    constexpr std::ptrdiff_t m_flMaxHighlightLum = 0x38; // float
}

namespace PostProcessingVignetteParameters_t {
    constexpr std::ptrdiff_t m_flVignetteStrength = 0x0; // float
    constexpr std::ptrdiff_t m_vCenter = 0x4; // Vector2D
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
    constexpr std::ptrdiff_t m_flRoundness = 0x10; // float
    constexpr std::ptrdiff_t m_flFeather = 0x14; // float
    constexpr std::ptrdiff_t m_vColorTint = 0x18; // Vector
}
```

`HPCS2/offset/networksystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace ChangeAccessorFieldPathIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}
```

`HPCS2/offset/offsets.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Sat, 4 Nov 2023 21:18:24 +0000
 */

#pragma once

#include <cstddef>

namespace client_dll { // client.dll
    constexpr std::ptrdiff_t dwBaseEntityModel_setModel = 0x581530;
    constexpr std::ptrdiff_t dwEntityList = 0x17AB958;
    constexpr std::ptrdiff_t dwForceAttack = 0x16B02B0;
    constexpr std::ptrdiff_t dwForceAttack2 = 0x16B0340;
    constexpr std::ptrdiff_t dwForceBackward = 0x16B0580;
    constexpr std::ptrdiff_t dwForceCrouch = 0x16B0850;
    constexpr std::ptrdiff_t dwForceForward = 0x16B04F0;
    constexpr std::ptrdiff_t dwForceJump = 0x16B07C0;
    constexpr std::ptrdiff_t dwForceLeft = 0x16B0610;
    constexpr std::ptrdiff_t dwForceRight = 0x16B06A0;
    constexpr std::ptrdiff_t dwGameEntitySystem = 0x18D51A8;
    constexpr std::ptrdiff_t dwGameEntitySystem_getBaseEntity = 0x604B40;
    constexpr std::ptrdiff_t dwGameEntitySystem_getHighestEntityIndex = 0x5F6830;
    constexpr std::ptrdiff_t dwGameRules = 0x1807FA8;
    constexpr std::ptrdiff_t dwGlobalVars = 0x16AC100;
    constexpr std::ptrdiff_t dwGlowManager = 0x1807708;
    constexpr std::ptrdiff_t dwInterfaceLinkList = 0x1902EB8;
    constexpr std::ptrdiff_t dwLocalPlayerController = 0x17FAC68;
    constexpr std::ptrdiff_t dwLocalPlayerPawn = 0x16B7340;
    constexpr std::ptrdiff_t dwPlantedC4 = 0x180EB48;
    constexpr std::ptrdiff_t dwPrediction = 0x16B7210;
    constexpr std::ptrdiff_t dwViewAngles = 0x18690D8;
    constexpr std::ptrdiff_t dwViewMatrix = 0x180A0D0;
    constexpr std::ptrdiff_t dwViewRender = 0x180A090;
}

namespace engine2_dll { // engine2.dll
    constexpr std::ptrdiff_t dwBuildNumber = 0x488514;
    constexpr std::ptrdiff_t dwNetworkGameClient = 0x487AB0;
    constexpr std::ptrdiff_t dwNetworkGameClient_getLocalPlayer = 0xF0;
    constexpr std::ptrdiff_t dwNetworkGameClient_maxClients = 0x250;
    constexpr std::ptrdiff_t dwNetworkGameClient_signOnState = 0x240;
    constexpr std::ptrdiff_t dwWindowHeight = 0x5397DC;
    constexpr std::ptrdiff_t dwWindowWidth = 0x5397D8;
}

namespace inputsystem_dll { // inputsystem.dll
    constexpr std::ptrdiff_t dwInputSystem = 0x35770;
}
```

`HPCS2/offset/particles.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:51 +0000
 */

#pragma once

#include <cstddef>

namespace CBaseRendererSource2 { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x608; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x610; // CParticleCollectionRendererVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xC68; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nShaderType = 0xC6C; // SpriteCardShaderType_t
    constexpr std::ptrdiff_t m_strShaderOverride = 0xC70; // CUtlString
    constexpr std::ptrdiff_t m_flCenterXOffset = 0xC78; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flCenterYOffset = 0xDD0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flBumpStrength = 0xF28; // float
    constexpr std::ptrdiff_t m_nCropTextureOverride = 0xF2C; // ParticleSequenceCropOverride_t
    constexpr std::ptrdiff_t m_vecTexturesInput = 0xF30; // CUtlVector<TextureGroup_t>
    constexpr std::ptrdiff_t m_flAnimationRate = 0xF48; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0xF4C; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0xF50; // bool
    constexpr std::ptrdiff_t m_flSelfIllumAmount = 0xF58; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDiffuseAmount = 0x10B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nLightingControlPoint = 0x1208; // int32_t
    constexpr std::ptrdiff_t m_nSelfIllumPerParticle = 0x120C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nOutputBlendMode = 0x1210; // ParticleOutputBlendMode_t
    constexpr std::ptrdiff_t m_bGammaCorrectVertexColors = 0x1214; // bool
    constexpr std::ptrdiff_t m_bSaturateColorPreAlphaBlend = 0x1215; // bool
    constexpr std::ptrdiff_t m_flAddSelfAmount = 0x1218; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDesaturation = 0x1370; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flOverbrightFactor = 0x14C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x1620; // int32_t
    constexpr std::ptrdiff_t m_nFogType = 0x1624; // ParticleFogType_t
    constexpr std::ptrdiff_t m_flFogAmount = 0x1628; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bTintByFOW = 0x1780; // bool
    constexpr std::ptrdiff_t m_bTintByGlobalLight = 0x1781; // bool
    constexpr std::ptrdiff_t m_nPerParticleAlphaReference = 0x1784; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleAlphaRefWindow = 0x1788; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nAlphaReferenceType = 0x178C; // ParticleAlphaReferenceType_t
    constexpr std::ptrdiff_t m_flAlphaReferenceSoftness = 0x1790; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToZero = 0x18E8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flSourceAlphaValueToMapToOne = 0x1A40; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRefract = 0x1B98; // bool
    constexpr std::ptrdiff_t m_bRefractSolid = 0x1B99; // bool
    constexpr std::ptrdiff_t m_flRefractAmount = 0x1BA0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nRefractBlurRadius = 0x1CF8; // int32_t
    constexpr std::ptrdiff_t m_nRefractBlurType = 0x1CFC; // BlurFilterType_t
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x1D00; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x1D01; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x1D02; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x1D03; // bool
    constexpr std::ptrdiff_t m_stencilTestID = 0x1D04; // char[128]
    constexpr std::ptrdiff_t m_bStencilTestExclude = 0x1D84; // bool
    constexpr std::ptrdiff_t m_stencilWriteID = 0x1D85; // char[128]
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthPass = 0x1E05; // bool
    constexpr std::ptrdiff_t m_bWriteStencilOnDepthFail = 0x1E06; // bool
    constexpr std::ptrdiff_t m_bReverseZBuffering = 0x1E07; // bool
    constexpr std::ptrdiff_t m_bDisableZBuffering = 0x1E08; // bool
    constexpr std::ptrdiff_t m_nFeatheringMode = 0x1E0C; // ParticleDepthFeatheringMode_t
    constexpr std::ptrdiff_t m_flFeatheringMinDist = 0x1E10; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringMaxDist = 0x1F68; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFeatheringFilter = 0x20C0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDepthBias = 0x2218; // float
    constexpr std::ptrdiff_t m_nSortMethod = 0x221C; // ParticleSortingChoiceList_t
    constexpr std::ptrdiff_t m_bBlendFramesSeq0 = 0x2220; // bool
    constexpr std::ptrdiff_t m_bMaxLuminanceBlendingSequence0 = 0x2221; // bool
}

namespace CBaseTrailRenderer { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_nOrientationType = 0x2470; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x2474; // int32_t
    constexpr std::ptrdiff_t m_flMinSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x2480; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x25D8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bClampV = 0x2730; // bool
}

namespace CGeneralRandomRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDegrees = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDegreesMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDegreesMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flRotationRandExponent = 0x1D0; // float
    constexpr std::ptrdiff_t m_bRandomlyFlipDirection = 0x1D4; // bool
}

namespace CGeneralSpin { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSpinRateDegrees = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSpinRateMinDegrees = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_fSpinRateStopTime = 0x1CC; // float
}

namespace CNewParticleEffect { // IParticleEffect
    constexpr std::ptrdiff_t m_pNext = 0x10; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pPrev = 0x18; // CNewParticleEffect*
    constexpr std::ptrdiff_t m_pParticles = 0x20; // IParticleCollection*
    constexpr std::ptrdiff_t m_pDebugName = 0x28; // char*
    constexpr std::ptrdiff_t m_bDontRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bRemove = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNeedsBBoxUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsFirstFrame = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAutoUpdateBBox = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bAllocated = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bSimulate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldPerformCullCheck = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bForceNoDraw = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSave = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDisableAggregation = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldSimulateDuringGamePaused = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bShouldCheckFoW = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_vSortOrigin = 0x40; // Vector
    constexpr std::ptrdiff_t m_flScale = 0x4C; // float
    constexpr std::ptrdiff_t m_hOwner = 0x50; // PARTICLE_EHANDLE__*
    constexpr std::ptrdiff_t m_pOwningParticleProperty = 0x58; // CParticleProperty*
    constexpr std::ptrdiff_t m_flFreezeTransitionStart = 0x70; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x74; // float
    constexpr std::ptrdiff_t m_flFreezeTransitionOverride = 0x78; // float
    constexpr std::ptrdiff_t m_bFreezeTransitionActive = 0x7C; // bool
    constexpr std::ptrdiff_t m_bFreezeTargetState = 0x7D; // bool
    constexpr std::ptrdiff_t m_bCanFreeze = 0x7E; // bool
    constexpr std::ptrdiff_t m_LastMin = 0x80; // Vector
    constexpr std::ptrdiff_t m_LastMax = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nSplitScreenUser = 0x98; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_vecAggregationCenter = 0x9C; // Vector
    constexpr std::ptrdiff_t m_RefCount = 0xC0; // int32_t
}

namespace CParticleBindingRealPulse { // CParticleCollectionBindingInstance
}

namespace CParticleCollectionBindingInstance { // CBasePulseGraphInstance
}

namespace CParticleCollectionFloatInput { // CParticleFloatInput
}

namespace CParticleCollectionRendererFloatInput { // CParticleCollectionFloatInput
}

namespace CParticleCollectionRendererVecInput { // CParticleCollectionVecInput
}

namespace CParticleCollectionVecInput { // CParticleVecInput
}

namespace CParticleFloatInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleFloatType_t
    constexpr std::ptrdiff_t m_nMapType = 0x14; // ParticleFloatMapType_t
    constexpr std::ptrdiff_t m_flLiteralValue = 0x18; // float
    constexpr std::ptrdiff_t m_NamedValue = 0x20; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nScalarAttribute = 0x64; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x68; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorComponent = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_flRandomMin = 0x70; // float
    constexpr std::ptrdiff_t m_flRandomMax = 0x74; // float
    constexpr std::ptrdiff_t m_bHasRandomSignFlip = 0x78; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nRandomMode = 0x80; // ParticleFloatRandomMode_t
    constexpr std::ptrdiff_t m_flLOD0 = 0x88; // float
    constexpr std::ptrdiff_t m_flLOD1 = 0x8C; // float
    constexpr std::ptrdiff_t m_flLOD2 = 0x90; // float
    constexpr std::ptrdiff_t m_flLOD3 = 0x94; // float
    constexpr std::ptrdiff_t m_nNoiseInputVectorAttribute = 0x98; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flNoiseOutputMin = 0x9C; // float
    constexpr std::ptrdiff_t m_flNoiseOutputMax = 0xA0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0xA4; // float
    constexpr std::ptrdiff_t m_vecNoiseOffsetRate = 0xA8; // Vector
    constexpr std::ptrdiff_t m_flNoiseOffset = 0xB4; // float
    constexpr std::ptrdiff_t m_nNoiseOctaves = 0xB8; // int32_t
    constexpr std::ptrdiff_t m_nNoiseTurbulence = 0xBC; // PFNoiseTurbulence_t
    constexpr std::ptrdiff_t m_nNoiseType = 0xC0; // PFNoiseType_t
    constexpr std::ptrdiff_t m_nNoiseModifier = 0xC4; // PFNoiseModifier_t
    constexpr std::ptrdiff_t m_flNoiseTurbulenceScale = 0xC8; // float
    constexpr std::ptrdiff_t m_flNoiseTurbulenceMix = 0xCC; // float
    constexpr std::ptrdiff_t m_flNoiseImgPreviewScale = 0xD0; // float
    constexpr std::ptrdiff_t m_bNoiseImgPreviewLive = 0xD4; // bool
    constexpr std::ptrdiff_t m_flNoCameraFallback = 0xE0; // float
    constexpr std::ptrdiff_t m_bUseBoundsCenter = 0xE4; // bool
    constexpr std::ptrdiff_t m_nInputMode = 0xE8; // ParticleFloatInputMode_t
    constexpr std::ptrdiff_t m_flMultFactor = 0xEC; // float
    constexpr std::ptrdiff_t m_flInput0 = 0xF0; // float
    constexpr std::ptrdiff_t m_flInput1 = 0xF4; // float
    constexpr std::ptrdiff_t m_flOutput0 = 0xF8; // float
    constexpr std::ptrdiff_t m_flOutput1 = 0xFC; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMin = 0x100; // float
    constexpr std::ptrdiff_t m_flNotchedRangeMax = 0x104; // float
    constexpr std::ptrdiff_t m_flNotchedOutputOutside = 0x108; // float
    constexpr std::ptrdiff_t m_flNotchedOutputInside = 0x10C; // float
    constexpr std::ptrdiff_t m_nBiasType = 0x110; // ParticleFloatBiasType_t
    constexpr std::ptrdiff_t m_flBiasParameter = 0x114; // float
    constexpr std::ptrdiff_t m_Curve = 0x118; // CPiecewiseCurve
}

namespace CParticleFunction {
    constexpr std::ptrdiff_t m_flOpStrength = 0x8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOpEndCapState = 0x160; // ParticleEndcapMode_t
    constexpr std::ptrdiff_t m_flOpStartFadeInTime = 0x164; // float
    constexpr std::ptrdiff_t m_flOpEndFadeInTime = 0x168; // float
    constexpr std::ptrdiff_t m_flOpStartFadeOutTime = 0x16C; // float
    constexpr std::ptrdiff_t m_flOpEndFadeOutTime = 0x170; // float
    constexpr std::ptrdiff_t m_flOpFadeOscillatePeriod = 0x174; // float
    constexpr std::ptrdiff_t m_bNormalizeToStopTime = 0x178; // bool
    constexpr std::ptrdiff_t m_flOpTimeOffsetMin = 0x17C; // float
    constexpr std::ptrdiff_t m_flOpTimeOffsetMax = 0x180; // float
    constexpr std::ptrdiff_t m_nOpTimeOffsetSeed = 0x184; // int32_t
    constexpr std::ptrdiff_t m_nOpTimeScaleSeed = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flOpTimeScaleMin = 0x18C; // float
    constexpr std::ptrdiff_t m_flOpTimeScaleMax = 0x190; // float
    constexpr std::ptrdiff_t m_bDisableOperator = 0x196; // bool
    constexpr std::ptrdiff_t m_Notes = 0x198; // CUtlString
}

namespace CParticleFunctionConstraint { // CParticleFunction
}

namespace CParticleFunctionEmitter { // CParticleFunction
    constexpr std::ptrdiff_t m_nEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionForce { // CParticleFunction
}

namespace CParticleFunctionInitializer { // CParticleFunction
    constexpr std::ptrdiff_t m_nAssociatedEmitterIndex = 0x1B8; // int32_t
}

namespace CParticleFunctionOperator { // CParticleFunction
}

namespace CParticleFunctionPreEmission { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bRunOnce = 0x1C0; // bool
}

namespace CParticleFunctionRenderer { // CParticleFunction
    constexpr std::ptrdiff_t VisibilityInputs = 0x1B8; // CParticleVisibilityInputs
    constexpr std::ptrdiff_t m_bCannotBeRefracted = 0x1FC; // bool
    constexpr std::ptrdiff_t m_bSkipRenderingOnMobile = 0x1FD; // bool
}

namespace CParticleInput {
}

namespace CParticleModelInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleModelType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_nControlPoint = 0x58; // int32_t
}

namespace CParticleProperty {
}

namespace CParticleRemapFloatInput { // CParticleFloatInput
}

namespace CParticleSystemDefinition { // IParticleSystemDefinition
    constexpr std::ptrdiff_t m_nBehaviorVersion = 0x8; // int32_t
    constexpr std::ptrdiff_t m_PreEmissionOperators = 0x10; // CUtlVector<CParticleFunctionPreEmission*>
    constexpr std::ptrdiff_t m_Emitters = 0x28; // CUtlVector<CParticleFunctionEmitter*>
    constexpr std::ptrdiff_t m_Initializers = 0x40; // CUtlVector<CParticleFunctionInitializer*>
    constexpr std::ptrdiff_t m_Operators = 0x58; // CUtlVector<CParticleFunctionOperator*>
    constexpr std::ptrdiff_t m_ForceGenerators = 0x70; // CUtlVector<CParticleFunctionForce*>
    constexpr std::ptrdiff_t m_Constraints = 0x88; // CUtlVector<CParticleFunctionConstraint*>
    constexpr std::ptrdiff_t m_Renderers = 0xA0; // CUtlVector<CParticleFunctionRenderer*>
    constexpr std::ptrdiff_t m_Children = 0xB8; // CUtlVector<ParticleChildrenInfo_t>
    constexpr std::ptrdiff_t m_nFirstMultipleOverride_BackwardCompat = 0x178; // int32_t
    constexpr std::ptrdiff_t m_nInitialParticles = 0x210; // int32_t
    constexpr std::ptrdiff_t m_nMaxParticles = 0x214; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x218; // int32_t
    constexpr std::ptrdiff_t m_BoundingBoxMin = 0x21C; // Vector
    constexpr std::ptrdiff_t m_BoundingBoxMax = 0x228; // Vector
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x234; // float
    constexpr std::ptrdiff_t m_nSortOverridePositionCP = 0x238; // int32_t
    constexpr std::ptrdiff_t m_bInfiniteBounds = 0x23C; // bool
    constexpr std::ptrdiff_t m_bEnableNamedValues = 0x23D; // bool
    constexpr std::ptrdiff_t m_NamedValueDomain = 0x240; // CUtlString
    constexpr std::ptrdiff_t m_NamedValueLocals = 0x248; // CUtlVector<ParticleNamedValueSource_t*>
    constexpr std::ptrdiff_t m_ConstantColor = 0x260; // Color
    constexpr std::ptrdiff_t m_ConstantNormal = 0x264; // Vector
    constexpr std::ptrdiff_t m_flConstantRadius = 0x270; // float
    constexpr std::ptrdiff_t m_flConstantRotation = 0x274; // float
    constexpr std::ptrdiff_t m_flConstantRotationSpeed = 0x278; // float
    constexpr std::ptrdiff_t m_flConstantLifespan = 0x27C; // float
    constexpr std::ptrdiff_t m_nConstantSequenceNumber = 0x280; // int32_t
    constexpr std::ptrdiff_t m_nConstantSequenceNumber1 = 0x284; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x288; // int32_t
    constexpr std::ptrdiff_t m_hSnapshot = 0x290; // CStrongHandle<InfoForResourceTypeIParticleSnapshot>
    constexpr std::ptrdiff_t m_pszCullReplacementName = 0x298; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flCullRadius = 0x2A0; // float
    constexpr std::ptrdiff_t m_flCullFillCost = 0x2A4; // float
    constexpr std::ptrdiff_t m_nCullControlPoint = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_hFallback = 0x2B0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nFallbackMaxCount = 0x2B8; // int32_t
    constexpr std::ptrdiff_t m_hLowViolenceDef = 0x2C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_hReferenceReplacement = 0x2C8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flPreSimulationTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_flStopSimulationAfterTime = 0x2D4; // float
    constexpr std::ptrdiff_t m_flMaximumTimeStep = 0x2D8; // float
    constexpr std::ptrdiff_t m_flMaximumSimTime = 0x2DC; // float
    constexpr std::ptrdiff_t m_flMinimumSimTime = 0x2E0; // float
    constexpr std::ptrdiff_t m_flMinimumTimeStep = 0x2E4; // float
    constexpr std::ptrdiff_t m_nMinimumFrames = 0x2E8; // int32_t
    constexpr std::ptrdiff_t m_nMinCPULevel = 0x2EC; // int32_t
    constexpr std::ptrdiff_t m_nMinGPULevel = 0x2F0; // int32_t
    constexpr std::ptrdiff_t m_flNoDrawTimeToGoToSleep = 0x2F4; // float
    constexpr std::ptrdiff_t m_flMaxDrawDistance = 0x2F8; // float
    constexpr std::ptrdiff_t m_flStartFadeDistance = 0x2FC; // float
    constexpr std::ptrdiff_t m_flMaxCreationDistance = 0x300; // float
    constexpr std::ptrdiff_t m_nAggregationMinAvailableParticles = 0x304; // int32_t
    constexpr std::ptrdiff_t m_flAggregateRadius = 0x308; // float
    constexpr std::ptrdiff_t m_bShouldBatch = 0x30C; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToRenderBounds = 0x30D; // bool
    constexpr std::ptrdiff_t m_bShouldHitboxesFallbackToSnapshot = 0x30E; // bool
    constexpr std::ptrdiff_t m_nViewModelEffect = 0x310; // InheritableBoolType_t
    constexpr std::ptrdiff_t m_bScreenSpaceEffect = 0x314; // bool
    constexpr std::ptrdiff_t m_pszTargetLayerID = 0x318; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSkipRenderControlPoint = 0x320; // int32_t
    constexpr std::ptrdiff_t m_nAllowRenderControlPoint = 0x324; // int32_t
    constexpr std::ptrdiff_t m_bShouldSort = 0x328; // bool
    constexpr std::ptrdiff_t m_controlPointConfigurations = 0x370; // CUtlVector<ParticleControlPointConfiguration_t>
}

namespace CParticleTransformInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleTransformType_t
    constexpr std::ptrdiff_t m_NamedValue = 0x18; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x58; // bool
    constexpr std::ptrdiff_t m_bSupportsDisabled = 0x59; // bool
    constexpr std::ptrdiff_t m_bUseOrientation = 0x5A; // bool
    constexpr std::ptrdiff_t m_nControlPoint = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nControlPointRangeMax = 0x60; // int32_t
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0x64; // float
}

namespace CParticleVariableRef {
    constexpr std::ptrdiff_t m_variableName = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_variableType = 0x38; // PulseValueType_t
}

namespace CParticleVecInput { // CParticleInput
    constexpr std::ptrdiff_t m_nType = 0x10; // ParticleVecType_t
    constexpr std::ptrdiff_t m_vLiteralValue = 0x14; // Vector
    constexpr std::ptrdiff_t m_LiteralColor = 0x20; // Color
    constexpr std::ptrdiff_t m_NamedValue = 0x28; // CParticleNamedValueRef
    constexpr std::ptrdiff_t m_bFollowNamedValue = 0x68; // bool
    constexpr std::ptrdiff_t m_nVectorAttribute = 0x6C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vVectorAttributeScale = 0x70; // Vector
    constexpr std::ptrdiff_t m_nControlPoint = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_nDeltaControlPoint = 0x80; // int32_t
    constexpr std::ptrdiff_t m_vCPValueScale = 0x84; // Vector
    constexpr std::ptrdiff_t m_vCPRelativePosition = 0x90; // Vector
    constexpr std::ptrdiff_t m_vCPRelativeDir = 0x9C; // Vector
    constexpr std::ptrdiff_t m_FloatComponentX = 0xA8; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentY = 0x200; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatComponentZ = 0x358; // CParticleFloatInput
    constexpr std::ptrdiff_t m_FloatInterp = 0x4B0; // CParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpInput0 = 0x608; // float
    constexpr std::ptrdiff_t m_flInterpInput1 = 0x60C; // float
    constexpr std::ptrdiff_t m_vInterpOutput0 = 0x610; // Vector
    constexpr std::ptrdiff_t m_vInterpOutput1 = 0x61C; // Vector
    constexpr std::ptrdiff_t m_Gradient = 0x628; // CColorGradient
    constexpr std::ptrdiff_t m_vRandomMin = 0x640; // Vector
    constexpr std::ptrdiff_t m_vRandomMax = 0x64C; // Vector
}

namespace CParticleVisibilityInputs {
    constexpr std::ptrdiff_t m_flCameraBias = 0x0; // float
    constexpr std::ptrdiff_t m_nCPin = 0x4; // int32_t
    constexpr std::ptrdiff_t m_flProxyRadius = 0x8; // float
    constexpr std::ptrdiff_t m_flInputMin = 0xC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x10; // float
    constexpr std::ptrdiff_t m_flNoPixelVisibilityFallback = 0x14; // float
    constexpr std::ptrdiff_t m_flDistanceInputMin = 0x18; // float
    constexpr std::ptrdiff_t m_flDistanceInputMax = 0x1C; // float
    constexpr std::ptrdiff_t m_flDotInputMin = 0x20; // float
    constexpr std::ptrdiff_t m_flDotInputMax = 0x24; // float
    constexpr std::ptrdiff_t m_bDotCPAngles = 0x28; // bool
    constexpr std::ptrdiff_t m_bDotCameraAngles = 0x29; // bool
    constexpr std::ptrdiff_t m_flAlphaScaleMin = 0x2C; // float
    constexpr std::ptrdiff_t m_flAlphaScaleMax = 0x30; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMin = 0x34; // float
    constexpr std::ptrdiff_t m_flRadiusScaleMax = 0x38; // float
    constexpr std::ptrdiff_t m_flRadiusScaleFOVBase = 0x3C; // float
    constexpr std::ptrdiff_t m_bRightEye = 0x40; // bool
}

namespace CPathParameters {
    constexpr std::ptrdiff_t m_nStartControlPointNumber = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x4; // int32_t
    constexpr std::ptrdiff_t m_nBulgeControl = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flBulge = 0xC; // float
    constexpr std::ptrdiff_t m_flMidPoint = 0x10; // float
    constexpr std::ptrdiff_t m_vStartPointOffset = 0x14; // Vector
    constexpr std::ptrdiff_t m_vMidPointOffset = 0x20; // Vector
    constexpr std::ptrdiff_t m_vEndOffset = 0x2C; // Vector
}

namespace CPerParticleFloatInput { // CParticleFloatInput
}

namespace CPerParticleVecInput { // CParticleVecInput
}

namespace CRandomNumberGeneratorParameters {
    constexpr std::ptrdiff_t m_bDistributeEvenly = 0x0; // bool
    constexpr std::ptrdiff_t m_nSeed = 0x4; // int32_t
}

namespace CSpinUpdateBase { // CParticleFunctionOperator
}

namespace C_INIT_AddVectorToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vOffsetMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vOffsetMax = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1EC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_AgeNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C1; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C4; // float
    constexpr std::ptrdiff_t m_flAgeMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flAgeMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D4; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // Vector
}

namespace C_INIT_ChaoticAttractor { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flAParm = 0x1C0; // float
    constexpr std::ptrdiff_t m_flBParm = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCParm = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDParm = 0x1CC; // float
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSpeedMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nBaseCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bUniformSpeed = 0x1E0; // bool
}

namespace C_INIT_ColorLitPerParticle { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ColorMin = 0x1D8; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E4; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1E8; // float
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1EC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x1F0; // float
}

namespace C_INIT_CreateAlongPath { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_bUseRandomCPs = 0x210; // bool
    constexpr std::ptrdiff_t m_vEndOffset = 0x214; // Vector
    constexpr std::ptrdiff_t m_bSaveOffset = 0x220; // bool
}

namespace C_INIT_CreateFromCPs { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nIncrement = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMinCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMaxCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDynamicCPCount = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateFromParentParticles { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1C4; // float
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSubFrame = 0x1D0; // bool
}

namespace C_INIT_CreateFromPlaneCache { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecOffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecOffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseNormal = 0x1D9; // bool
}

namespace C_INIT_CreateInEpitrochoid { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nComponent1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nComponent2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticleDensity = 0x230; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x388; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius1 = 0x4E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadius2 = 0x638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseCount = 0x790; // bool
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x791; // bool
    constexpr std::ptrdiff_t m_bOffsetExistingPos = 0x792; // bool
}

namespace C_INIT_CreateOnGrid { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nXCount = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYCount = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZCount = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nXSpacing = 0x5C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nYSpacing = 0x720; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nZSpacing = 0x878; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x9D0; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D4; // bool
    constexpr std::ptrdiff_t m_bCenter = 0x9D5; // bool
    constexpr std::ptrdiff_t m_bHollow = 0x9D6; // bool
}

namespace C_INIT_CreateOnModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nForceInModel = 0x288; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x28C; // int32_t
    constexpr std::ptrdiff_t m_nHitboxValueFromControlPointIndex = 0x290; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x298; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x8F0; // float
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x8F4; // float
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x8F8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xF50; // char[128]
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFD0; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0xFD1; // bool
    constexpr std::ptrdiff_t m_flShellSize = 0xFD8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateOnModelAtHeight { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bUseBones = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForceZ = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nHeightCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseWaterHeight = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flDesiredHeight = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x328; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x980; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nBiasType = 0xFD8; // ParticleHitboxBiasType_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0xFDC; // bool
    constexpr std::ptrdiff_t m_bPreferMovingBoxes = 0xFDD; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0xFDE; // char[128]
    constexpr std::ptrdiff_t m_flHitboxVelocityScale = 0x1060; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxBoneVelocity = 0x11B8; // CParticleCollectionFloatInput
}

namespace C_INIT_CreateParticleImpulse { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputRadius = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_InputMagnitude = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFalloffFunction = 0x470; // ParticleFalloffFunction_t
    constexpr std::ptrdiff_t m_InputFalloffExp = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nImpulseType = 0x5D0; // ParticleImpulseType_t
}

namespace C_INIT_CreatePhyllotaxis { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_fRadCentCore = 0x1CC; // float
    constexpr std::ptrdiff_t m_fRadPerPoint = 0x1D0; // float
    constexpr std::ptrdiff_t m_fRadPerPointTo = 0x1D4; // float
    constexpr std::ptrdiff_t m_fpointAngle = 0x1D8; // float
    constexpr std::ptrdiff_t m_fsizeOverall = 0x1DC; // float
    constexpr std::ptrdiff_t m_fRadBias = 0x1E0; // float
    constexpr std::ptrdiff_t m_fMinRad = 0x1E4; // float
    constexpr std::ptrdiff_t m_fDistBias = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseLocalCoords = 0x1EC; // bool
    constexpr std::ptrdiff_t m_bUseWithContEmit = 0x1ED; // bool
    constexpr std::ptrdiff_t m_bUseOrigRadius = 0x1EE; // bool
}

namespace C_INIT_CreateSequentialPath { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C9; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x1CA; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_INIT_CreateSequentialPathV2 { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNumToAssign = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLoop = 0x470; // bool
    constexpr std::ptrdiff_t m_bCPPairs = 0x471; // bool
    constexpr std::ptrdiff_t m_bSaveOffset = 0x472; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x480; // CPathParameters
}

namespace C_INIT_CreateSpiralSphere { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDensity = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInitialRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D8; // bool
}

namespace C_INIT_CreateWithinBox { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xE78; // CRandomNumberGeneratorParameters
}

namespace C_INIT_CreateWithinSphereTransform { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fRadiusMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fRadiusMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecDistanceBias = 0x470; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecDistanceBiasAbs = 0xAC8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0xAD8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fSpeedMin = 0xB40; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0xC98; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedRandExp = 0xDF0; // float
    constexpr std::ptrdiff_t m_bLocalCoords = 0xDF4; // bool
    constexpr std::ptrdiff_t m_flEndCPGrowthTime = 0xDF8; // float
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0xE00; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0x1458; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1AB0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldVelocity = 0x1AB4; // ParticleAttributeIndex_t
}

namespace C_INIT_CreationNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1C5; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1D8; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1E8; // float
}

namespace C_INIT_DistanceCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_DistanceToCPInit { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nStartCP = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bLOS = 0x72C; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x72D; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x7B0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7B8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLOSScale = 0x910; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x914; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x918; // bool
    constexpr std::ptrdiff_t m_vecDistanceScale = 0x91C; // Vector
    constexpr std::ptrdiff_t m_flRemapBias = 0x928; // float
}

namespace C_INIT_DistanceToNeighborCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flDistance = 0x1C0; // CPerParticleFloatInput
}

namespace C_INIT_GlobalScale { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bScaleRadius = 0x1CC; // bool
    constexpr std::ptrdiff_t m_bScalePosition = 0x1CD; // bool
    constexpr std::ptrdiff_t m_bScaleVelocity = 0x1CE; // bool
}

namespace C_INIT_InheritFromParentParticles { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D0; // int32_t
}

namespace C_INIT_InheritVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flVelocityScale = 0x1C4; // float
}

namespace C_INIT_InitFloat { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_InputStrength = 0x320; // CPerParticleFloatInput
}

namespace C_INIT_InitFloatCollection { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromCPSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nManualSnapshotIndex = 0x330; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nRandomSeed = 0x488; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpaceAngles = 0x48C; // bool
}

namespace C_INIT_InitFromParentKilled { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nAttributeToCopy = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_INIT_InitFromVectorFieldSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nWeightUpdateCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bUseVerticalVelocity = 0x1CC; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x1D0; // CPerParticleVecInput
}

namespace C_INIT_InitSkinnedPositionFromCPSnapshot { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRigid = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1D2; // bool
    constexpr std::ptrdiff_t m_flMinNormalVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_flMaxNormalVelocity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flIncrement = 0x1DC; // float
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_flBoneVelocity = 0x1E8; // float
    constexpr std::ptrdiff_t m_flBoneVelocityMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bCopyColor = 0x1F0; // bool
    constexpr std::ptrdiff_t m_bCopyAlpha = 0x1F1; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1F2; // bool
}

namespace C_INIT_InitVec { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x820; // bool
    constexpr std::ptrdiff_t m_bWritePreviousPosition = 0x821; // bool
}

namespace C_INIT_InitVecCollection { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
}

namespace C_INIT_InitialRepulsionVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x240; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x244; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x250; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x260; // bool
    constexpr std::ptrdiff_t m_bTranslate = 0x261; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x262; // bool
    constexpr std::ptrdiff_t m_flTraceLength = 0x264; // float
    constexpr std::ptrdiff_t m_bPerParticleTR = 0x268; // bool
    constexpr std::ptrdiff_t m_bInherit = 0x269; // bool
    constexpr std::ptrdiff_t m_nChildCP = 0x26C; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x270; // int32_t
}

namespace C_INIT_InitialSequenceFromModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_INIT_InitialVelocityFromHitbox { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flVelocityMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flVelocityMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1CC; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x24C; // bool
}

namespace C_INIT_InitialVelocityNoise { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecAbsVal = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecAbsValInv = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOffset = 0x830; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecOutputMin = 0x988; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0xFE0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1638; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flNoiseScaleLoc = 0x1790; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x18E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1950; // bool
}

namespace C_INIT_LifespanFromVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1D0; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x1D4; // float
    constexpr std::ptrdiff_t m_nMaxPlanes = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1E0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x260; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x270; // bool
}

namespace C_INIT_ModelCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_INIT_MoveBetweenPoints { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flSpeedMin = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSpeedMax = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndSpread = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flEndOffset = 0x720; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEndControlPointNumber = 0x878; // int32_t
    constexpr std::ptrdiff_t m_bTrailBias = 0x87C; // bool
}

namespace C_INIT_NormalAlignToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_transformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nControlPointAxis = 0x228; // ParticleControlPointAxis_t
}

namespace C_INIT_NormalOffset { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_OffsetMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bNormalize = 0x1DD; // bool
}

namespace C_INIT_OffsetVectorToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1E0; // CRandomNumberGeneratorParameters
}

namespace C_INIT_Orient2DRelToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C8; // float
}

namespace C_INIT_PlaneCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCullInside = 0x320; // bool
}

namespace C_INIT_PointList { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_INIT_PositionOffset { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_OffsetMin = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_OffsetMax = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_TransformInput = 0xE70; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalCoords = 0xED8; // bool
    constexpr std::ptrdiff_t m_bProportional = 0xED9; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0xEDC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_PositionOffsetToCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumberStart = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumberEnd = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1C8; // bool
}

namespace C_INIT_PositionPlaceOnGround { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x470; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x4F0; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x500; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x504; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x505; // bool
    constexpr std::ptrdiff_t m_bSetPXYZOnly = 0x506; // bool
    constexpr std::ptrdiff_t m_bTraceAlongNormal = 0x507; // bool
    constexpr std::ptrdiff_t m_bOffsetonColOnly = 0x508; // bool
    constexpr std::ptrdiff_t m_flOffsetByRadiusFactor = 0x50C; // float
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x510; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x514; // int32_t
}

namespace C_INIT_PositionWarp { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecWarpMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xE74; // int32_t
    constexpr std::ptrdiff_t m_nRadiusComponent = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flWarpTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flWarpStartTime = 0xE80; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0xE84; // float
    constexpr std::ptrdiff_t m_bInvertWarp = 0xE88; // bool
    constexpr std::ptrdiff_t m_bUseCount = 0xE89; // bool
}

namespace C_INIT_PositionWarpScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecWarpMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecWarpMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_InputValue = 0x1D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x330; // float
    constexpr std::ptrdiff_t m_nScaleControlPointNumber = 0x334; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x338; // int32_t
}

namespace C_INIT_QuantizeFloat { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_INIT_RadiusFromCPObject { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
}

namespace C_INIT_RandomAlpha { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nAlphaMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flAlphaRandExponent = 0x1D4; // float
}

namespace C_INIT_RandomAlphaWindowThreshold { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
}

namespace C_INIT_RandomColor { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ColorMin = 0x1DC; // Color
    constexpr std::ptrdiff_t m_ColorMax = 0x1E0; // Color
    constexpr std::ptrdiff_t m_TintMin = 0x1E4; // Color
    constexpr std::ptrdiff_t m_TintMax = 0x1E8; // Color
    constexpr std::ptrdiff_t m_flTintPerc = 0x1EC; // float
    constexpr std::ptrdiff_t m_flUpdateThreshold = 0x1F0; // float
    constexpr std::ptrdiff_t m_nTintCP = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTintBlendMode = 0x1FC; // ParticleColorBlendMode_t
    constexpr std::ptrdiff_t m_flLightAmplification = 0x200; // float
}

namespace C_INIT_RandomLifeTime { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fLifetimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fLifetimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_fLifetimeRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomModelSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_ActivityName = 0x1C0; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x2C0; // char[256]
    constexpr std::ptrdiff_t m_hModel = 0x3C0; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace C_INIT_RandomNamedModelBodyPart { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomNamedModelElement { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bShuffle = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x1E2; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E4; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomNamedModelMeshGroup { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomNamedModelSequence { // C_INIT_RandomNamedModelElement
}

namespace C_INIT_RandomRadius { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flRadiusMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flRadiusMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomRotation { // CGeneralRandomRotation
}

namespace C_INIT_RandomRotationSpeed { // CGeneralRandomRotation
}

namespace C_INIT_RandomScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flExponent = 0x1C8; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_INIT_RandomSecondSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
}

namespace C_INIT_RandomSequence { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nSequenceMin = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSequenceMax = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bShuffle = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bLinear = 0x1C9; // bool
    constexpr std::ptrdiff_t m_WeightedList = 0x1D0; // CUtlVector<SequenceWeightedList_t>
}

namespace C_INIT_RandomTrailLength { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMinLength = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLengthRandExponent = 0x1C8; // float
}

namespace C_INIT_RandomVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_randomnessParameters = 0x1DC; // CRandomNumberGeneratorParameters
}

namespace C_INIT_RandomVectorComponent { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_INIT_RandomYaw { // CGeneralRandomRotation
}

namespace C_INIT_RandomYawFlip { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flPercent = 0x1C0; // float
}

namespace C_INIT_RemapCPtoScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapInitialDirectionToTransformToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x22C; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x230; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x234; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x240; // bool
}

namespace C_INIT_RemapInitialTransformDirectionToRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x22C; // float
    constexpr std::ptrdiff_t m_nComponent = 0x230; // int32_t
}

namespace C_INIT_RemapInitialVisibilityScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_INIT_RemapNamedModelBodyPartToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapNamedModelElementToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_names = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_values = 0x1E0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFieldInput = 0x1F8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1FC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x200; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x204; // bool
}

namespace C_INIT_RemapNamedModelMeshGroupToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapNamedModelSequenceToScalar { // C_INIT_RemapNamedModelElementToScalar
}

namespace C_INIT_RemapParticleCountToNamedModelBodyPartScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToNamedModelElementScalar { // C_INIT_RemapParticleCountToScalar
    constexpr std::ptrdiff_t m_hModel = 0x1F0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_outputMinName = 0x1F8; // CUtlString
    constexpr std::ptrdiff_t m_outputMaxName = 0x200; // CUtlString
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x208; // bool
}

namespace C_INIT_RemapParticleCountToNamedModelMeshGroupScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToNamedModelSequenceScalar { // C_INIT_RemapParticleCountToNamedModelElementScalar
}

namespace C_INIT_RemapParticleCountToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bInvert = 0x1E1; // bool
    constexpr std::ptrdiff_t m_bWrap = 0x1E2; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E4; // float
}

namespace C_INIT_RemapQAnglesToRotation { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_INIT_RemapScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1D8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1E8; // float
}

namespace C_INIT_RemapScalarToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1E8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1F0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1F4; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x1F8; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x1FC; // float
}

namespace C_INIT_RemapSpeedToScalar { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flStartTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bPerParticle = 0x1E4; // bool
}

namespace C_INIT_RemapTransformOrientationToRotations { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_INIT_RemapTransformToVector { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_TransformInput = 0x1F8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_LocalSpaceTransform = 0x260; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime = 0x2C8; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x2CC; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x2D0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x2D4; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x2D5; // bool
    constexpr std::ptrdiff_t m_flRemapBias = 0x2D8; // float
}

namespace C_INIT_RingWave { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flParticlesPerOrbit = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitialRadius = 0x380; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0x4D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMin = 0x630; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInitialSpeedMax = 0x788; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRoll = 0x8E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flPitch = 0xA38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flYaw = 0xB90; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bEvenDistribution = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bXYVelocityOnly = 0xCE9; // bool
}

namespace C_INIT_RtEnvCull { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bUseVelocity = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D9; // bool
    constexpr std::ptrdiff_t m_bLifeAdjust = 0x1DA; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DB; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_INIT_ScaleVelocity { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_vecScale = 0x1C0; // CParticleCollectionVecInput
}

namespace C_INIT_SequenceFromCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_bKillUnused = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // Vector
}

namespace C_INIT_SequenceLifeTime { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flFramerate = 0x1C0; // float
}

namespace C_INIT_SetHitboxToClosest { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0x820; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x8A0; // bool
    constexpr std::ptrdiff_t m_bUseClosestPointOnHitbox = 0x8A1; // bool
    constexpr std::ptrdiff_t m_nTestType = 0x8A4; // ClosestPointTestType_t
    constexpr std::ptrdiff_t m_flHybridRatio = 0x8A8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bUpdatePosition = 0xA00; // bool
}

namespace C_INIT_SetHitboxToModel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nForceInModel = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nDesiredHitbox = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vecHitBoxScale = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecDirectionBias = 0x828; // Vector
    constexpr std::ptrdiff_t m_bMaintainHitbox = 0x834; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x835; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x836; // char[128]
    constexpr std::ptrdiff_t m_flShellSize = 0x8B8; // CParticleCollectionFloatInput
}

namespace C_INIT_SetRigidAttachment { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1CC; // bool
}

namespace C_INIT_SetVectorAttributeToVectorExpression { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_INIT_StatusEffect { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nDetail2Combo = 0x1C0; // Detail2Combo_t
    constexpr std::ptrdiff_t m_flDetail2Rotation = 0x1C4; // float
    constexpr std::ptrdiff_t m_flDetail2Scale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDetail2BlendFactor = 0x1CC; // float
    constexpr std::ptrdiff_t m_flColorWarpIntensity = 0x1D0; // float
    constexpr std::ptrdiff_t m_flDiffuseWarpBlendToFull = 0x1D4; // float
    constexpr std::ptrdiff_t m_flEnvMapIntensity = 0x1D8; // float
    constexpr std::ptrdiff_t m_flAmbientScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_specularColor = 0x1E0; // Color
    constexpr std::ptrdiff_t m_flSpecularScale = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSpecularExponent = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSpecularExponentBlendToFull = 0x1EC; // float
    constexpr std::ptrdiff_t m_flSpecularBlendToFull = 0x1F0; // float
    constexpr std::ptrdiff_t m_rimLightColor = 0x1F4; // Color
    constexpr std::ptrdiff_t m_flRimLightScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flReflectionsTintByBaseBlendToNone = 0x1FC; // float
    constexpr std::ptrdiff_t m_flMetalnessBlendToFull = 0x200; // float
    constexpr std::ptrdiff_t m_flSelfIllumBlendToFull = 0x204; // float
}

namespace C_INIT_StatusEffectCitadel { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_flSFXColorWarpAmount = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSFXNormalAmount = 0x1C4; // float
    constexpr std::ptrdiff_t m_flSFXMetalnessAmount = 0x1C8; // float
    constexpr std::ptrdiff_t m_flSFXRoughnessAmount = 0x1CC; // float
    constexpr std::ptrdiff_t m_flSFXSelfIllumAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_flSFXSScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flSFXSScrollX = 0x1D8; // float
    constexpr std::ptrdiff_t m_flSFXSScrollY = 0x1DC; // float
    constexpr std::ptrdiff_t m_flSFXSScrollZ = 0x1E0; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetX = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetY = 0x1E8; // float
    constexpr std::ptrdiff_t m_flSFXSOffsetZ = 0x1EC; // float
    constexpr std::ptrdiff_t m_nDetailCombo = 0x1F0; // DetailCombo_t
    constexpr std::ptrdiff_t m_flSFXSDetailAmount = 0x1F4; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollX = 0x1FC; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollY = 0x200; // float
    constexpr std::ptrdiff_t m_flSFXSDetailScrollZ = 0x204; // float
    constexpr std::ptrdiff_t m_flSFXSUseModelUVs = 0x208; // float
}

namespace C_INIT_VelocityFromCP { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_velocityInput = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x818; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flVelocityScale = 0x880; // float
    constexpr std::ptrdiff_t m_bDirectionOnly = 0x884; // bool
}

namespace C_INIT_VelocityFromNormal { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_bIgnoreDt = 0x1C8; // bool
}

namespace C_INIT_VelocityRadialRandom { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_fSpeedMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecLocalCoordinateSystemSpeedScale = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D9; // bool
}

namespace C_INIT_VelocityRandom { // CParticleFunctionInitializer
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_fSpeedMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fSpeedMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMin = 0x478; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_LocalCoordinateSystemSpeedMax = 0xAD0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1128; // bool
    constexpr std::ptrdiff_t m_randomnessParameters = 0x112C; // CRandomNumberGeneratorParameters
}

namespace C_OP_AlphaDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinAlpha = 0x1C0; // float
}

namespace C_OP_AttractToControlPoint { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vecComponentScale = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fForceAmount = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_fFalloffPower = 0x338; // float
    constexpr std::ptrdiff_t m_TransformInput = 0x340; // CParticleTransformInput
    constexpr std::ptrdiff_t m_fForceAmountMin = 0x3A8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bApplyMinForce = 0x500; // bool
}

namespace C_OP_BasicMovement { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_BoxConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_vecMin = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecMax = 0x818; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nCP = 0xE70; // int32_t
    constexpr std::ptrdiff_t m_bLocalSpace = 0xE74; // bool
    constexpr std::ptrdiff_t m_bAccountForRadius = 0xE75; // bool
}

namespace C_OP_CPOffsetToPercentageBetweenCPs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInputMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputBias = 0x1C8; // float
    constexpr std::ptrdiff_t m_nStartCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOffsetCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOuputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nInputCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bRadialCheck = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_vecOffset = 0x1E4; // Vector
}

namespace C_OP_CPVelocityForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CPerParticleFloatInput
}

namespace C_OP_CalculateVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vStartValue = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nFieldInput1 = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale1 = 0x1D0; // float
    constexpr std::ptrdiff_t m_nFieldInput2 = 0x1D4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_nControlPointInput1 = 0x1DC; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale1 = 0x1F0; // float
    constexpr std::ptrdiff_t m_nControlPointInput2 = 0x1F4; // ControlPointReference_t
    constexpr std::ptrdiff_t m_flControlPointScale2 = 0x208; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vFinalOutputScale = 0x210; // Vector
}

namespace C_OP_Callback { // CParticleFunctionRenderer
}

namespace C_OP_ChladniWave { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecWaveLength = 0x728; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecHarmonics = 0xD80; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_nLocalSpaceControlPoint = 0x13DC; // int32_t
    constexpr std::ptrdiff_t m_b3D = 0x13E0; // bool
}

namespace C_OP_ChooseRandomChildrenInGroup { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flNumberOfChildren = 0x1D8; // CParticleCollectionFloatInput
}

namespace C_OP_ClampScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x320; // CPerParticleFloatInput
}

namespace C_OP_ClampVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOutputMax = 0x820; // CPerParticleVecInput
}

namespace C_OP_CollideWithParentParticles { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flParentRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusScale = 0x318; // CPerParticleFloatInput
}

namespace C_OP_CollideWithSelf { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinimumSpeed = 0x318; // CPerParticleFloatInput
}

namespace C_OP_ColorAdjustHSL { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flHueAdjust = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSaturationAdjust = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLightnessAdjust = 0x470; // CPerParticleFloatInput
}

namespace C_OP_ColorInterpolate { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_ColorFade = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bUseNewCode = 0x1DD; // bool
}

namespace C_OP_ColorInterpolateRandom { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_ColorFadeMin = 0x1C0; // Color
    constexpr std::ptrdiff_t m_ColorFadeMax = 0x1DC; // Color
    constexpr std::ptrdiff_t m_flFadeStartTime = 0x1EC; // float
    constexpr std::ptrdiff_t m_flFadeEndTime = 0x1F0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1F4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseInOut = 0x1F8; // bool
}

namespace C_OP_ConnectParentParticleToNearest { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSecondControlPoint = 0x1C4; // int32_t
}

namespace C_OP_ConstrainDistance { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_fMaxDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x470; // int32_t
    constexpr std::ptrdiff_t m_CenterOffset = 0x474; // Vector
    constexpr std::ptrdiff_t m_bGlobalCenter = 0x480; // bool
}

namespace C_OP_ConstrainDistanceToPath { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance0 = 0x1C4; // float
    constexpr std::ptrdiff_t m_flMaxDistanceMid = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxDistance1 = 0x1CC; // float
    constexpr std::ptrdiff_t m_PathParameters = 0x1D0; // CPathParameters
    constexpr std::ptrdiff_t m_flTravelTime = 0x210; // float
    constexpr std::ptrdiff_t m_nFieldScale = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualTField = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_ConstrainDistanceToUserSpecifiedPath { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_fMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bLoopedPath = 0x1CC; // bool
    constexpr std::ptrdiff_t m_pointList = 0x1D0; // CUtlVector<PointDefinitionWithTimeValues_t>
}

namespace C_OP_ConstrainLineLength { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxDistance = 0x1C4; // float
}

namespace C_OP_ContinuousEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmitRate = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flScalePerParentParticle = 0x5CC; // float
    constexpr std::ptrdiff_t m_bInitFromKilledParentParticles = 0x5D0; // bool
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
    constexpr std::ptrdiff_t m_nLimitPerUpdate = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_bForceEmitOnFirstUpdate = 0x5DC; // bool
    constexpr std::ptrdiff_t m_bForceEmitOnLastUpdate = 0x5DD; // bool
}

namespace C_OP_ControlPointToRadialScreenSpace { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPIn = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nCPOut = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutField = 0x1E4; // int32_t
    constexpr std::ptrdiff_t m_nCPSSPosOut = 0x1E8; // int32_t
}

namespace C_OP_ControlpointLight { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nControlPoint1 = 0x650; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint2 = 0x654; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint3 = 0x658; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint4 = 0x65C; // int32_t
    constexpr std::ptrdiff_t m_vecCPOffset1 = 0x660; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset2 = 0x66C; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset3 = 0x678; // Vector
    constexpr std::ptrdiff_t m_vecCPOffset4 = 0x684; // Vector
    constexpr std::ptrdiff_t m_LightFiftyDist1 = 0x690; // float
    constexpr std::ptrdiff_t m_LightZeroDist1 = 0x694; // float
    constexpr std::ptrdiff_t m_LightFiftyDist2 = 0x698; // float
    constexpr std::ptrdiff_t m_LightZeroDist2 = 0x69C; // float
    constexpr std::ptrdiff_t m_LightFiftyDist3 = 0x6A0; // float
    constexpr std::ptrdiff_t m_LightZeroDist3 = 0x6A4; // float
    constexpr std::ptrdiff_t m_LightFiftyDist4 = 0x6A8; // float
    constexpr std::ptrdiff_t m_LightZeroDist4 = 0x6AC; // float
    constexpr std::ptrdiff_t m_LightColor1 = 0x6B0; // Color
    constexpr std::ptrdiff_t m_LightColor2 = 0x6B4; // Color
    constexpr std::ptrdiff_t m_LightColor3 = 0x6B8; // Color
    constexpr std::ptrdiff_t m_LightColor4 = 0x6BC; // Color
    constexpr std::ptrdiff_t m_bLightType1 = 0x6C0; // bool
    constexpr std::ptrdiff_t m_bLightType2 = 0x6C1; // bool
    constexpr std::ptrdiff_t m_bLightType3 = 0x6C2; // bool
    constexpr std::ptrdiff_t m_bLightType4 = 0x6C3; // bool
    constexpr std::ptrdiff_t m_bLightDynamic1 = 0x6C4; // bool
    constexpr std::ptrdiff_t m_bLightDynamic2 = 0x6C5; // bool
    constexpr std::ptrdiff_t m_bLightDynamic3 = 0x6C6; // bool
    constexpr std::ptrdiff_t m_bLightDynamic4 = 0x6C7; // bool
    constexpr std::ptrdiff_t m_bUseNormal = 0x6C8; // bool
    constexpr std::ptrdiff_t m_bUseHLambert = 0x6C9; // bool
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x6CE; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x6CF; // bool
}

namespace C_OP_Cull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flCullPerc = 0x1C0; // float
    constexpr std::ptrdiff_t m_flCullStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCullEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCullExp = 0x1CC; // float
}

namespace C_OP_CurlNoiseForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nNoiseType = 0x1D0; // ParticleDirectionNoiseType_t
    constexpr std::ptrdiff_t m_vecNoiseFreq = 0x1D8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecNoiseScale = 0x830; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffset = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecOffsetRate = 0x14E0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flWorleySeed = 0x1B38; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flWorleyJitter = 0x1C90; // CPerParticleFloatInput
}

namespace C_OP_CycleScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nDestField = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStartValue = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flCycleTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_bDoNotRepeatCycle = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSynchronizeParticles = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCPScale = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMin = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCPFieldMax = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
}

namespace C_OP_CylindricalDistanceToTransform { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x790; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x7F8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x7FC; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x7FD; // bool
    constexpr std::ptrdiff_t m_bCapsule = 0x7FE; // bool
}

namespace C_OP_DampenToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flRange = 0x1C4; // float
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
}

namespace C_OP_Decay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bRopeDecay = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1C1; // bool
}

namespace C_OP_DecayClampCount { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCount = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DecayMaintainCount { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDecayDelay = 0x1C4; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bLifespanDecay = 0x1CC; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bKillNewest = 0x328; // bool
}

namespace C_OP_DecayOffscreen { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flOffscreenTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_DensityForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_flForceScale = 0x1D4; // float
    constexpr std::ptrdiff_t m_flTargetDensity = 0x1D8; // float
}

namespace C_OP_DifferencePreviousParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bSetPreviousParticle = 0x1DD; // bool
}

namespace C_OP_Diffusion { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1C8; // int32_t
}

namespace C_OP_DirectionBetweenVecsToVec { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
}

namespace C_OP_DistanceBetweenCPsToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nStartCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nEndCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputCPField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOnce = 0x1E0; // bool
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1F4; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x1F8; // float
    constexpr std::ptrdiff_t m_bLOS = 0x1FC; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1FD; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x280; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nSetParent = 0x284; // ParticleParentSetMode_t
}

namespace C_OP_DistanceBetweenTransforms { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_TransformStart = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x230; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flInputMin = 0x298; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x3F0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x548; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x6A0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x7F8; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x7FC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x800; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x880; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bLOS = 0x884; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x888; // ParticleSetMethod_t
}

namespace C_OP_DistanceBetweenVecs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecPoint1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecPoint2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flInputMin = 0xE78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0xFD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x1128; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x1280; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x13D8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bDeltaTime = 0x13DC; // bool
}

namespace C_OP_DistanceCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPointOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0x1D0; // float
    constexpr std::ptrdiff_t m_bCullInside = 0x1D4; // bool
}

namespace C_OP_DistanceToTransform { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_TransformStart = 0x728; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLOS = 0x790; // bool
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x791; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x814; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x818; // float
    constexpr std::ptrdiff_t m_flLOSScale = 0x81C; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x820; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x824; // bool
    constexpr std::ptrdiff_t m_bAdditive = 0x825; // bool
    constexpr std::ptrdiff_t m_vecComponentScale = 0x828; // CPerParticleVecInput
}

namespace C_OP_DragRelativeToPlane { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDragAtPlane = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFalloff = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDirectional = 0x470; // bool
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x478; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nControlPointNumber = 0xAD0; // int32_t
}

namespace C_OP_DriveCPFromGlobalSoundFloat { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_StackName = 0x1E8; // CUtlString
    constexpr std::ptrdiff_t m_OperatorName = 0x1F0; // CUtlString
    constexpr std::ptrdiff_t m_FieldName = 0x1F8; // CUtlString
}

namespace C_OP_EnableChildrenFromParentParticleCount { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nFirstChild = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDisableChildren = 0x330; // bool
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x331; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x332; // bool
}

namespace C_OP_EndCapDecay { // CParticleFunctionOperator
}

namespace C_OP_EndCapTimedDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDecayTime = 0x1C0; // float
}

namespace C_OP_EndCapTimedFreeze { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFreezeTime = 0x1C0; // CParticleCollectionFloatInput
}

namespace C_OP_ExternalGameImpulseForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bRopes = 0x328; // bool
    constexpr std::ptrdiff_t m_bRopesZOnly = 0x329; // bool
    constexpr std::ptrdiff_t m_bExplosions = 0x32A; // bool
    constexpr std::ptrdiff_t m_bParticles = 0x32B; // bool
}

namespace C_OP_ExternalWindForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vecSamplePosition = 0x1D0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecScale = 0x828; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bSampleWind = 0xE80; // bool
    constexpr std::ptrdiff_t m_bSampleWater = 0xE81; // bool
    constexpr std::ptrdiff_t m_bDampenNearWaterPlane = 0xE82; // bool
    constexpr std::ptrdiff_t m_bSampleGravity = 0xE83; // bool
    constexpr std::ptrdiff_t m_vecGravityForce = 0xE88; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bUseBasicMovementGravity = 0x14E0; // bool
    constexpr std::ptrdiff_t m_flLocalGravityScale = 0x14E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flLocalBuoyancyScale = 0x1640; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecBuoyancyForce = 0x1798; // CPerParticleVecInput
}

namespace C_OP_FadeAndKill { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
    constexpr std::ptrdiff_t m_bForcePreserveParticleOrder = 0x1D8; // bool
}

namespace C_OP_FadeAndKillForTracers { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndFadeInTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartFadeOutTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndFadeOutTime = 0x1CC; // float
    constexpr std::ptrdiff_t m_flStartAlpha = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndAlpha = 0x1D4; // float
}

namespace C_OP_FadeIn { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeInTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeInTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeInTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_bProportional = 0x1CC; // bool
}

namespace C_OP_FadeInSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeInTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_FadeOut { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeOutTimeMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeOutTimeExp = 0x1C8; // float
    constexpr std::ptrdiff_t m_flFadeBias = 0x1CC; // float
    constexpr std::ptrdiff_t m_bProportional = 0x200; // bool
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x201; // bool
}

namespace C_OP_FadeOutSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeOutTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_ForceBasedOnDistanceToPlane { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flMinDist = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecForceAtMinDist = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flMaxDist = 0x1E0; // float
    constexpr std::ptrdiff_t m_vecForceAtMaxDist = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecPlaneNormal = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_flExponent = 0x200; // float
}

namespace C_OP_ForceControlPointStub { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_ControlPoint = 0x1D0; // int32_t
}

namespace C_OP_GlobalLight { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_bClampLowerRange = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bClampUpperRange = 0x1C5; // bool
}

namespace C_OP_HSVShiftToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nColorCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nColorGemEnableCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_DefaultHSVColor = 0x1DC; // Color
}

namespace C_OP_InheritFromParentParticles { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
}

namespace C_OP_InheritFromParentParticlesV2 { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_bRandomDistribution = 0x1CC; // bool
    constexpr std::ptrdiff_t m_nMissingParentBehavior = 0x1D0; // MissingParentInheritBehavior_t
}

namespace C_OP_InheritFromPeerSystem { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nGroupID = 0x1CC; // int32_t
}

namespace C_OP_InstantaneousEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_nParticlesToEmit = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInitFromKilledParentParticles = 0x470; // float
    constexpr std::ptrdiff_t m_flParentParticleScale = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxEmittedPerFrame = 0x5D0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x5D4; // int32_t
}

namespace C_OP_InterpolateRadius { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flStartTime = 0x1C0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flEndScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bEaseInAndOut = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flBias = 0x1D4; // float
}

namespace C_OP_LagCompensation { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nDesiredVelocityCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCP = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nLatencyCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nDesiredVelocityCPField = 0x1CC; // int32_t
}

namespace C_OP_LerpEndCapScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C4; // float
    constexpr std::ptrdiff_t m_flLerpTime = 0x1C8; // float
}

namespace C_OP_LerpEndCapVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flLerpTime = 0x1D0; // float
}

namespace C_OP_LerpScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutput = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x320; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x324; // float
}

namespace C_OP_LerpToInitialPosition { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nCacheField = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x480; // CParticleCollectionVecInput
}

namespace C_OP_LerpToOtherAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nFieldInputFrom = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x320; // ParticleAttributeIndex_t
}

namespace C_OP_LerpVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutput = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1D4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_LightningSnapshotGenerator { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPSnapshot = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPStartPnt = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPEndPnt = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flSegments = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffset = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOffsetDecay = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRecalcRate = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVScale = 0x740; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flUVOffset = 0x898; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flSplitRate = 0x9F0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBranchTwist = 0xB48; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBranchBehavior = 0xCA0; // ParticleLightnintBranchBehavior_t
    constexpr std::ptrdiff_t m_flRadiusStart = 0xCA8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusEnd = 0xE00; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flDedicatedPool = 0xF58; // CParticleCollectionFloatInput
}

namespace C_OP_LocalAccelerationForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecAccel = 0x1D8; // CParticleCollectionVecInput
}

namespace C_OP_LockPoints { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nMinCol = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCol = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nMinRow = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxRow = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flBlendValue = 0x1D4; // float
}

namespace C_OP_LockToBone { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x288; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x28C; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bRigid = 0x318; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x319; // bool
    constexpr std::ptrdiff_t m_nFieldOutput = 0x31C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0x320; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nRotationSetType = 0x324; // ParticleRotationLockType_t
    constexpr std::ptrdiff_t m_bRigidRotationLock = 0x328; // bool
    constexpr std::ptrdiff_t m_vecRotation = 0x330; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flRotLerp = 0x988; // CPerParticleFloatInput
}

namespace C_OP_LockToPointList { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_pointList = 0x1C8; // CUtlVector<PointDefinition_t>
    constexpr std::ptrdiff_t m_bPlaceAlongPath = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1E1; // bool
    constexpr std::ptrdiff_t m_nNumPointsAlongPath = 0x1E4; // int32_t
}

namespace C_OP_LockToSavedSequentialPath { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C4; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C8; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1CC; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_LockToSavedSequentialPathV2 { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flFadeStart = 0x1C0; // float
    constexpr std::ptrdiff_t m_flFadeEnd = 0x1C4; // float
    constexpr std::ptrdiff_t m_bCPPairs = 0x1C8; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1D0; // CPathParameters
}

namespace C_OP_MaintainEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_nParticlesToMaintain = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartTime = 0x318; // float
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flEmissionRate = 0x478; // float
    constexpr std::ptrdiff_t m_nSnapshotControlPoint = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bEmitInstantaneously = 0x480; // bool
    constexpr std::ptrdiff_t m_bFinalEmitOnStop = 0x481; // bool
    constexpr std::ptrdiff_t m_flScale = 0x488; // CParticleCollectionFloatInput
}

namespace C_OP_MaintainSequentialPath { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_fMaxDistance = 0x1C0; // float
    constexpr std::ptrdiff_t m_flNumToAssign = 0x1C4; // float
    constexpr std::ptrdiff_t m_flCohesionStrength = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1CC; // float
    constexpr std::ptrdiff_t m_bLoop = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bUseParticleCount = 0x1D1; // bool
    constexpr std::ptrdiff_t m_PathParams = 0x1E0; // CPathParameters
}

namespace C_OP_MaxVelocity { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMaxVelocity = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C4; // float
    constexpr std::ptrdiff_t m_nOverrideCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nOverrideCPField = 0x1CC; // int32_t
}

namespace C_OP_ModelCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bCullOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
}

namespace C_OP_ModelDampenMovement { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_bBoundBox = 0x1C4; // bool
    constexpr std::ptrdiff_t m_bOutside = 0x1C5; // bool
    constexpr std::ptrdiff_t m_bUseBones = 0x1C6; // bool
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C7; // char[128]
    constexpr std::ptrdiff_t m_vecPosOffset = 0x248; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x8A0; // float
}

namespace C_OP_MoveToHitbox { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_modelInput = 0x1C0; // CParticleModelInput
    constexpr std::ptrdiff_t m_transformInput = 0x220; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flLifeTimeLerpStart = 0x28C; // float
    constexpr std::ptrdiff_t m_flLifeTimeLerpEnd = 0x290; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x294; // float
    constexpr std::ptrdiff_t m_HitboxSetName = 0x298; // char[128]
    constexpr std::ptrdiff_t m_bUseBones = 0x318; // bool
    constexpr std::ptrdiff_t m_nLerpType = 0x31C; // HitboxLerpType_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x320; // CPerParticleFloatInput
}

namespace C_OP_MovementLoopInsideSphere { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x320; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nDistSqrAttr = 0x978; // ParticleAttributeIndex_t
}

namespace C_OP_MovementMaintainOffset { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecOffset = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_nCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRadiusScale = 0x1D0; // bool
}

namespace C_OP_MovementMoveAlongSkinnedCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1C8; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1C9; // bool
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flTValue = 0x328; // CPerParticleFloatInput
}

namespace C_OP_MovementPlaceOnGround { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flOffset = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x318; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x31C; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x320; // float
    constexpr std::ptrdiff_t m_flLerpRate = 0x324; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x328; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3A8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nRefCP1 = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_nRefCP2 = 0x3B0; // int32_t
    constexpr std::ptrdiff_t m_nLerpCP = 0x3B4; // int32_t
    constexpr std::ptrdiff_t m_nTraceMissBehavior = 0x3C0; // ParticleTraceMissBehavior_t
    constexpr std::ptrdiff_t m_bIncludeShotHull = 0x3C4; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3C5; // bool
    constexpr std::ptrdiff_t m_bSetNormal = 0x3C8; // bool
    constexpr std::ptrdiff_t m_bScaleOffset = 0x3C9; // bool
    constexpr std::ptrdiff_t m_nPreserveOffsetCP = 0x3CC; // int32_t
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x3D0; // int32_t
}

namespace C_OP_MovementRigidAttachToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nScaleCPField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1CC; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D4; // bool
}

namespace C_OP_MovementRotateParticleAroundAxis { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_TransformInput = 0x970; // CParticleTransformInput
    constexpr std::ptrdiff_t m_bLocalSpace = 0x9D8; // bool
}

namespace C_OP_MovementSkinnedPositionFromCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSnapshotControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1C8; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetNormal = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bSetRadius = 0x1D1; // bool
    constexpr std::ptrdiff_t m_flIncrement = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFullLoopIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x5E0; // CPerParticleFloatInput
}

namespace C_OP_Noise { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1CC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1D4; // float
}

namespace C_OP_NoiseEmitter { // CParticleFunctionEmitter
    constexpr std::ptrdiff_t m_flEmissionDuration = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEmissionScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_nScaleControlPoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nScaleControlPointField = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nWorldNoisePoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bAbsVal = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bAbsValInv = 0x1D9; // bool
    constexpr std::ptrdiff_t m_flOffset = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flNoiseScale = 0x1E8; // float
    constexpr std::ptrdiff_t m_flWorldNoiseScale = 0x1EC; // float
    constexpr std::ptrdiff_t m_vecOffsetLoc = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flWorldTimeScale = 0x1FC; // float
}

namespace C_OP_NormalLock { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
}

namespace C_OP_NormalizeVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
}

namespace C_OP_Orient2DRelToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1CC; // ParticleAttributeIndex_t
}

namespace C_OP_OrientTo2dDirection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRotOffset = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x1C4; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
}

namespace C_OP_OscillateScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_nField = 0x1D0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1D4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1D5; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1E0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1EC; // float
}

namespace C_OP_OscillateScalarSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_Frequency = 0x1C4; // float
    constexpr std::ptrdiff_t m_nField = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1D0; // float
}

namespace C_OP_OscillateVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_RateMax = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_FrequencyMin = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_FrequencyMax = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportional = 0x1F4; // bool
    constexpr std::ptrdiff_t m_bProportionalOp = 0x1F5; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1F6; // bool
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1F8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x200; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x204; // float
    constexpr std::ptrdiff_t m_flOscMult = 0x208; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOscAdd = 0x360; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRateScale = 0x4B8; // CPerParticleFloatInput
}

namespace C_OP_OscillateVectorSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_Frequency = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOscMult = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOscAdd = 0x1E0; // float
    constexpr std::ptrdiff_t m_bOffset = 0x1E4; // bool
}

namespace C_OP_ParentVortices { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
    constexpr std::ptrdiff_t m_vecTwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bFlipBasedOnYaw = 0x1E0; // bool
}

namespace C_OP_ParticlePhysics { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Gravity = 0x1C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_fDrag = 0x818; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxConstraintPasses = 0x970; // int32_t
}

namespace C_OP_PerParticleForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vForce = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
}

namespace C_OP_PercentageBetweenTransformLerpCPs { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x238; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nOutputStartCP = 0x2A0; // int32_t
    constexpr std::ptrdiff_t m_nOutputStartField = 0x2A4; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndCP = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_nOutputEndField = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2B4; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2B5; // bool
}

namespace C_OP_PercentageBetweenTransforms { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_TransformStart = 0x1D8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x240; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2A8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2AC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2AD; // bool
}

namespace C_OP_PercentageBetweenTransformsVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_TransformStart = 0x1E8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_TransformEnd = 0x250; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nSetMethod = 0x2B8; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x2BC; // bool
    constexpr std::ptrdiff_t m_bRadialCheck = 0x2BD; // bool
}

namespace C_OP_PinParticleToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x820; // bool
    constexpr std::ptrdiff_t m_nParticleSelection = 0x824; // ParticleSelection_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nPinBreakType = 0x980; // ParticlePinDistance_t
    constexpr std::ptrdiff_t m_flBreakDistance = 0x988; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flBreakSpeed = 0xAE0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAge = 0xC38; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nBreakControlPointNumber = 0xD90; // int32_t
    constexpr std::ptrdiff_t m_nBreakControlPointNumber2 = 0xD94; // int32_t
    constexpr std::ptrdiff_t m_flBreakValue = 0xD98; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0xEF0; // CPerParticleFloatInput
}

namespace C_OP_PlanarConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_PointOnPlane = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_PlaneNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_bGlobalOrigin = 0x1DC; // bool
    constexpr std::ptrdiff_t m_bGlobalNormal = 0x1DD; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1E0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaximumDistanceToCP = 0x338; // CParticleCollectionFloatInput
}

namespace C_OP_PlaneCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nPlaneControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecPlaneDirection = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1D0; // bool
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x1D4; // float
}

namespace C_OP_PlayEndCapWhenFinished { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bFireOnEmissionEnd = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bIncludeChildren = 0x1D1; // bool
}

namespace C_OP_PointVectorAtNextParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1C8; // CPerParticleFloatInput
}

namespace C_OP_PositionLock { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_flStartTime_min = 0x228; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x22C; // float
    constexpr std::ptrdiff_t m_flStartTime_exp = 0x230; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x234; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x238; // float
    constexpr std::ptrdiff_t m_flEndTime_exp = 0x23C; // float
    constexpr std::ptrdiff_t m_flRange = 0x240; // float
    constexpr std::ptrdiff_t m_flRangeBias = 0x248; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x3A0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x3A4; // float
    constexpr std::ptrdiff_t m_bLockRot = 0x3A8; // bool
    constexpr std::ptrdiff_t m_vecScale = 0x3B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xA08; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputPrev = 0xA0C; // ParticleAttributeIndex_t
}

namespace C_OP_QuantizeCPComponent { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flInputValue = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCPOutput = 0x328; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x32C; // int32_t
    constexpr std::ptrdiff_t m_flQuantizeValue = 0x330; // CParticleCollectionFloatInput
}

namespace C_OP_QuantizeFloat { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
}

namespace C_OP_RadiusDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinRadius = 0x1C0; // float
}

namespace C_OP_RampCPLinearRandom { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecRateMin = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_vecRateMax = 0x1E0; // Vector
}

namespace C_OP_RampScalarLinear { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
}

namespace C_OP_RampScalarLinearSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
}

namespace C_OP_RampScalarSpline { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_RateMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_RateMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_flStartTime_min = 0x1C8; // float
    constexpr std::ptrdiff_t m_flStartTime_max = 0x1CC; // float
    constexpr std::ptrdiff_t m_flEndTime_min = 0x1D0; // float
    constexpr std::ptrdiff_t m_flEndTime_max = 0x1D4; // float
    constexpr std::ptrdiff_t m_flBias = 0x1D8; // float
    constexpr std::ptrdiff_t m_nField = 0x200; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bProportionalOp = 0x204; // bool
    constexpr std::ptrdiff_t m_bEaseOut = 0x205; // bool
}

namespace C_OP_RampScalarSplineSimple { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_Rate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1C4; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1C8; // float
    constexpr std::ptrdiff_t m_nField = 0x1F0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bEaseOut = 0x1F4; // bool
}

namespace C_OP_RandomForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_MinForce = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_MaxForce = 0x1DC; // Vector
}

namespace C_OP_ReadFromNeighboringParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nIncrement = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_DistanceCheck = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x328; // CPerParticleFloatInput
}

namespace C_OP_ReinitializeScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1C8; // float
}

namespace C_OP_RemapAverageHitboxSpeedtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nHitboxDataType = 0x1DC; // ParticleHitboxDataSelection_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nHeightControlPointNumber = 0x740; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x748; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_HitboxSetName = 0xDA0; // char[128]
}

namespace C_OP_RemapAverageScalarValuetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
}

namespace C_OP_RemapBoundingVolumetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E0; // float
}

namespace C_OP_RemapCPVelocityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1CC; // bool
}

namespace C_OP_RemapCPtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nInputField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1EC; // float
    constexpr std::ptrdiff_t m_bDerivative = 0x1F0; // bool
    constexpr std::ptrdiff_t m_flInterpRate = 0x1F4; // float
}

namespace C_OP_RemapCPtoScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nField = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x1DC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x1E4; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E8; // ParticleSetMethod_t
}

namespace C_OP_RemapCPtoVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_vInputMin = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vInputMax = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_vOutputMin = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vOutputMax = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x1FC; // float
    constexpr std::ptrdiff_t m_flEndTime = 0x200; // float
    constexpr std::ptrdiff_t m_flInterpRate = 0x204; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x208; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bOffset = 0x20C; // bool
    constexpr std::ptrdiff_t m_bAccelerate = 0x20D; // bool
}

namespace C_OP_RemapControlPointDirectionToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapControlPointOrientationToRotation { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1C8; // float
    constexpr std::ptrdiff_t m_nComponent = 0x1CC; // int32_t
}

namespace C_OP_RemapCrossProductOfTwoVectorsToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputVec1 = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_InputVec2 = 0x818; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0xE70; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNormalize = 0xE74; // bool
}

namespace C_OP_RemapDensityGradientToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDensityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flDensityMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flDensityMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1DC; // Vector
    constexpr std::ptrdiff_t m_bUseParentDensity = 0x1E8; // bool
    constexpr std::ptrdiff_t m_nVoxelGridResolution = 0x1EC; // int32_t
}

namespace C_OP_RemapDirectionToCPToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOffsetRot = 0x1CC; // float
    constexpr std::ptrdiff_t m_vecOffsetAxis = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_bNormalize = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nFieldStrength = 0x1E0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapDistanceToLineSegmentBase { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCP0 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCP1 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flMinInputValue = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMaxInputValue = 0x1CC; // float
    constexpr std::ptrdiff_t m_bInfiniteLine = 0x1D0; // bool
}

namespace C_OP_RemapDistanceToLineSegmentToScalar { // C_OP_RemapDistanceToLineSegmentBase
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinOutputValue = 0x1E4; // float
    constexpr std::ptrdiff_t m_flMaxOutputValue = 0x1E8; // float
}

namespace C_OP_RemapDistanceToLineSegmentToVector { // C_OP_RemapDistanceToLineSegmentBase
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1E0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vMinOutputValue = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vMaxOutputValue = 0x1F0; // Vector
}

namespace C_OP_RemapDotProductToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInputMax = 0x338; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x490; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5E8; // CParticleCollectionFloatInput
}

namespace C_OP_RemapDotProductToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nInputCP1 = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nInputCP2 = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_bUseParticleVelocity = 0x1DC; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1E0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bActiveRange = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bUseParticleNormal = 0x1E5; // bool
}

namespace C_OP_RemapExternalWindToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecScale = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bSetMagnitude = 0x830; // bool
    constexpr std::ptrdiff_t m_nOutVectorField = 0x834; // int32_t
}

namespace C_OP_RemapModelVolumetoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nBBoxType = 0x1D0; // BBoxVolumeType_t
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointMaxNumber = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1EC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1F0; // float
}

namespace C_OP_RemapNamedModelBodyPartEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelBodyPartOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapNamedModelElementEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
}

namespace C_OP_RemapNamedModelElementOnceTimed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_hModel = 0x1C0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_inNames = 0x1C8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_outNames = 0x1E0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_fallbackNames = 0x1F8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bModelFromRenderer = 0x210; // bool
    constexpr std::ptrdiff_t m_bProportional = 0x211; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRemapTime = 0x21C; // float
}

namespace C_OP_RemapNamedModelMeshGroupEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelMeshGroupOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapNamedModelSequenceEndCap { // C_OP_RemapNamedModelElementEndCap
}

namespace C_OP_RemapNamedModelSequenceOnceTimed { // C_OP_RemapNamedModelElementOnceTimed
}

namespace C_OP_RemapParticleCountOnScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nInputMax = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_bBackwards = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D8; // ParticleSetMethod_t
}

namespace C_OP_RemapParticleCountToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nInputMin = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nInputMax = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputMax = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bActiveRange = 0x728; // bool
    constexpr std::ptrdiff_t m_nSetMethod = 0x72C; // ParticleSetMethod_t
}

namespace C_OP_RemapSDFDistanceToScalarAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueBelowMin = 0x478; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMin = 0x5D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAtMax = 0x728; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flValueAboveMax = 0x880; // CParticleCollectionFloatInput
}

namespace C_OP_RemapSDFDistanceToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nVectorFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVectorFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMinDistance = 0x1C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x320; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vValueBelowMin = 0x478; // Vector
    constexpr std::ptrdiff_t m_vValueAtMin = 0x484; // Vector
    constexpr std::ptrdiff_t m_vValueAtMax = 0x490; // Vector
    constexpr std::ptrdiff_t m_vValueAboveMax = 0x49C; // Vector
}

namespace C_OP_RemapSDFGradientToVectorAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
}

namespace C_OP_RemapScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_bOldCode = 0x1D8; // bool
}

namespace C_OP_RemapScalarEndCap { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
}

namespace C_OP_RemapScalarOnceTimed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bProportional = 0x1C0; // bool
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_flRemapTime = 0x1DC; // float
}

namespace C_OP_RemapSpeed { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C4; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1C8; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1D4; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bIgnoreDelta = 0x1D8; // bool
}

namespace C_OP_RemapSpeedtoCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nField = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1E4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1E8; // float
    constexpr std::ptrdiff_t m_bUseDeltaV = 0x1EC; // bool
}

namespace C_OP_RemapTransformOrientationToRotations { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_vecRotation = 0x228; // Vector
    constexpr std::ptrdiff_t m_bUseQuat = 0x234; // bool
    constexpr std::ptrdiff_t m_bWriteNormal = 0x235; // bool
}

namespace C_OP_RemapTransformOrientationToYaw { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRotOffset = 0x22C; // float
    constexpr std::ptrdiff_t m_flSpinStrength = 0x230; // float
}

namespace C_OP_RemapTransformToVelocity { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_TransformInput = 0x1C0; // CParticleTransformInput
}

namespace C_OP_RemapTransformVisibilityToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x23C; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x240; // float
    constexpr std::ptrdiff_t m_flRadius = 0x244; // float
}

namespace C_OP_RemapTransformVisibilityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nSetMethod = 0x1C0; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_TransformInput = 0x1C8; // CParticleTransformInput
    constexpr std::ptrdiff_t m_nFieldOutput = 0x230; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x234; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x238; // float
    constexpr std::ptrdiff_t m_vecOutputMin = 0x23C; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x248; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x254; // float
}

namespace C_OP_RemapVectorComponentToScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nComponent = 0x1C8; // int32_t
}

namespace C_OP_RemapVectortoCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nOutControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nParticleNumber = 0x1C8; // int32_t
}

namespace C_OP_RemapVelocityToVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1C8; // bool
}

namespace C_OP_RemapVisibilityScalar { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldInput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1C8; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1CC; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1D8; // float
}

namespace C_OP_RenderAsModels { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_ModelList = 0x200; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_flModelScale = 0x21C; // float
    constexpr std::ptrdiff_t m_bFitToModelSize = 0x220; // bool
    constexpr std::ptrdiff_t m_bNonUniformScaling = 0x221; // bool
    constexpr std::ptrdiff_t m_nXAxisScalingAttribute = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nYAxisScalingAttribute = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nZAxisScalingAttribute = 0x22C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x230; // int32_t
}

namespace C_OP_RenderBlobs { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_cubeWidth = 0x200; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_cutoffRadius = 0x358; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_renderRadius = 0x4B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x608; // int32_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x610; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hMaterial = 0x640; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderCables { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRadiusScale = 0x200; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x358; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x4B0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB08; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_hMaterial = 0xB10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nTextureRepetitionMode = 0xB18; // TextureRepetitionMode_t
    constexpr std::ptrdiff_t m_flTextureRepeatsPerSegment = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flTextureRepeatsCircumference = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetV = 0xDD0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flColorMapOffsetU = 0xF28; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetV = 0x1080; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flNormalMapOffsetU = 0x11D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDrawCableCaps = 0x1330; // bool
    constexpr std::ptrdiff_t m_flCapRoundness = 0x1334; // float
    constexpr std::ptrdiff_t m_flCapOffsetAmount = 0x1338; // float
    constexpr std::ptrdiff_t m_flTessScale = 0x133C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x1340; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x1344; // int32_t
    constexpr std::ptrdiff_t m_nRoundness = 0x1348; // int32_t
    constexpr std::ptrdiff_t m_LightingTransform = 0x1350; // CParticleTransformInput
    constexpr std::ptrdiff_t m_MaterialFloatVars = 0x13B8; // CUtlVector<FloatInputMaterialVariable_t>
    constexpr std::ptrdiff_t m_MaterialVecVars = 0x13E8; // CUtlVector<VecInputMaterialVariable_t>
}

namespace C_OP_RenderClothForce { // CParticleFunctionRenderer
}

namespace C_OP_RenderDeferredLight { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bUseAlphaTestWindow = 0x200; // bool
    constexpr std::ptrdiff_t m_bUseTexture = 0x201; // bool
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x208; // float
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x210; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x868; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flLightDistance = 0x86C; // float
    constexpr std::ptrdiff_t m_flStartFalloff = 0x870; // float
    constexpr std::ptrdiff_t m_flDistanceFalloff = 0x874; // float
    constexpr std::ptrdiff_t m_flSpotFoV = 0x878; // float
    constexpr std::ptrdiff_t m_nAlphaTestPointField = 0x87C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestRangeField = 0x880; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAlphaTestSharpnessField = 0x884; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_hTexture = 0x888; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nHSVShiftControlPoint = 0x890; // int32_t
}

namespace C_OP_RenderFlattenGrass { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flFlattenStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadiusScale = 0x208; // float
}

namespace C_OP_RenderGpuImplicit { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bUsePerParticleRadius = 0x200; // bool
    constexpr std::ptrdiff_t m_fGridSize = 0x208; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fRadiusScale = 0x360; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_fIsosurfaceThreshold = 0x4B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nScaleCP = 0x610; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x618; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderLightBeam { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_vColorBlend = 0x200; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x858; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flBrightnessLumensPerMeter = 0x860; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9B8; // bool
    constexpr std::ptrdiff_t m_flSkirt = 0x9C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xB18; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flThickness = 0xC70; // CParticleCollectionFloatInput
}

namespace C_OP_RenderLights { // C_OP_RenderPoints
    constexpr std::ptrdiff_t m_flAnimationRate = 0x210; // float
    constexpr std::ptrdiff_t m_nAnimationType = 0x214; // AnimationType_t
    constexpr std::ptrdiff_t m_bAnimateInFPS = 0x218; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x21C; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x220; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x224; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x228; // float
}

namespace C_OP_RenderMaterialProxy { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nMaterialControlPoint = 0x200; // int32_t
    constexpr std::ptrdiff_t m_nProxyType = 0x204; // MaterialProxyType_t
    constexpr std::ptrdiff_t m_MaterialVars = 0x208; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x220; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flMaterialOverrideEnabled = 0x228; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecColorScale = 0x380; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flAlpha = 0x9D8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0xB30; // ParticleColorBlendType_t
}

namespace C_OP_RenderModels { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsBloomPass = 0x200; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffectsWaterPass = 0x201; // bool
    constexpr std::ptrdiff_t m_bUseMixedResolutionRendering = 0x202; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderInEffecsGameOverlay = 0x203; // bool
    constexpr std::ptrdiff_t m_ModelList = 0x208; // CUtlVector<ModelReference_t>
    constexpr std::ptrdiff_t m_nBodyGroupField = 0x224; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSubModelField = 0x228; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bIgnoreNormal = 0x22C; // bool
    constexpr std::ptrdiff_t m_bOrientZ = 0x22D; // bool
    constexpr std::ptrdiff_t m_bCenterOffset = 0x22E; // bool
    constexpr std::ptrdiff_t m_vecLocalOffset = 0x230; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vecLocalRotation = 0x888; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bIgnoreRadius = 0xEE0; // bool
    constexpr std::ptrdiff_t m_nModelScaleCP = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_vecComponentScale = 0xEE8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_bLocalScale = 0x1540; // bool
    constexpr std::ptrdiff_t m_nSizeCullBloat = 0x1544; // int32_t
    constexpr std::ptrdiff_t m_bAnimated = 0x1548; // bool
    constexpr std::ptrdiff_t m_flAnimationRate = 0x154C; // float
    constexpr std::ptrdiff_t m_bScaleAnimationRate = 0x1550; // bool
    constexpr std::ptrdiff_t m_bForceLoopingAnimation = 0x1551; // bool
    constexpr std::ptrdiff_t m_bResetAnimOnStop = 0x1552; // bool
    constexpr std::ptrdiff_t m_bManualAnimFrame = 0x1553; // bool
    constexpr std::ptrdiff_t m_nAnimationScaleField = 0x1554; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAnimationField = 0x1558; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nManualFrameField = 0x155C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_ActivityName = 0x1560; // char[256]
    constexpr std::ptrdiff_t m_SequenceName = 0x1660; // char[256]
    constexpr std::ptrdiff_t m_bEnableClothSimulation = 0x1760; // bool
    constexpr std::ptrdiff_t m_hOverrideMaterial = 0x1768; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bOverrideTranslucentMaterials = 0x1770; // bool
    constexpr std::ptrdiff_t m_nSkin = 0x1778; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_MaterialVars = 0x18D0; // CUtlVector<MaterialVariable_t>
    constexpr std::ptrdiff_t m_modelInput = 0x18E8; // CParticleModelInput
    constexpr std::ptrdiff_t m_nLOD = 0x1948; // int32_t
    constexpr std::ptrdiff_t m_EconSlotName = 0x194C; // char[256]
    constexpr std::ptrdiff_t m_bOriginalModel = 0x1A4C; // bool
    constexpr std::ptrdiff_t m_bSuppressTint = 0x1A4D; // bool
    constexpr std::ptrdiff_t m_bUseRawMeshGroup = 0x1A4E; // bool
    constexpr std::ptrdiff_t m_bDisableShadows = 0x1A4F; // bool
    constexpr std::ptrdiff_t m_bAcceptsDecals = 0x1A50; // bool
    constexpr std::ptrdiff_t m_bForceDrawInterlevedWithSiblings = 0x1A51; // bool
    constexpr std::ptrdiff_t m_bDoNotDrawInParticlePass = 0x1A52; // bool
    constexpr std::ptrdiff_t m_szRenderAttribute = 0x1A53; // char[260]
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1B58; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAlphaScale = 0x1CB0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRollScale = 0x1E08; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAlpha2Field = 0x1F60; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x1F68; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x25C0; // ParticleColorBlendType_t
}

namespace C_OP_RenderOmni2Light { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleOmni2LightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vColorBlend = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_nBrightnessUnit = 0x864; // ParticleLightUnitChoiceList_t
    constexpr std::ptrdiff_t m_flBrightnessLumens = 0x868; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBrightnessCandelas = 0x9C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0xB18; // bool
    constexpr std::ptrdiff_t m_flLuminaireRadius = 0xB20; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSkirt = 0xC78; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRange = 0xDD0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInnerConeAngle = 0xF28; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flOuterConeAngle = 0x1080; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hLightCookie = 0x11D8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bSphericalCookie = 0x11E0; // bool
}

namespace C_OP_RenderPoints { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_hMaterial = 0x200; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace C_OP_RenderPostProcessing { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flPostProcessStrength = 0x200; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_hPostTexture = 0x358; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_nPriority = 0x360; // ParticlePostProcessPriorityGroup_t
}

namespace C_OP_RenderProjected { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_bProjectCharacter = 0x200; // bool
    constexpr std::ptrdiff_t m_bProjectWorld = 0x201; // bool
    constexpr std::ptrdiff_t m_bProjectWater = 0x202; // bool
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x203; // bool
    constexpr std::ptrdiff_t m_bEnableProjectedDepthControls = 0x204; // bool
    constexpr std::ptrdiff_t m_flMinProjectionDepth = 0x208; // float
    constexpr std::ptrdiff_t m_flMaxProjectionDepth = 0x20C; // float
    constexpr std::ptrdiff_t m_hProjectedMaterial = 0x210; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flAnimationTimeScale = 0x218; // float
    constexpr std::ptrdiff_t m_bOrientToNormal = 0x21C; // bool
    constexpr std::ptrdiff_t m_MaterialVars = 0x220; // CUtlVector<MaterialVariable_t>
}

namespace C_OP_RenderRopes { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2470; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x2474; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x2478; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x247C; // float
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2480; // float
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2484; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2488; // float
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x248C; // float
    constexpr std::ptrdiff_t m_nMinTesselation = 0x2490; // int32_t
    constexpr std::ptrdiff_t m_nMaxTesselation = 0x2494; // int32_t
    constexpr std::ptrdiff_t m_flTessScale = 0x2498; // float
    constexpr std::ptrdiff_t m_flTextureVWorldSize = 0x24A0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVScrollRate = 0x25F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flTextureVOffset = 0x2750; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nTextureVParamsCP = 0x28A8; // int32_t
    constexpr std::ptrdiff_t m_bClampV = 0x28AC; // bool
    constexpr std::ptrdiff_t m_nScaleCP1 = 0x28B0; // int32_t
    constexpr std::ptrdiff_t m_nScaleCP2 = 0x28B4; // int32_t
    constexpr std::ptrdiff_t m_flScaleVSizeByControlPointDistance = 0x28B8; // float
    constexpr std::ptrdiff_t m_flScaleVScrollByControlPointDistance = 0x28BC; // float
    constexpr std::ptrdiff_t m_flScaleVOffsetByControlPointDistance = 0x28C0; // float
    constexpr std::ptrdiff_t m_bUseScalarForTextureCoordinate = 0x28C5; // bool
    constexpr std::ptrdiff_t m_nScalarFieldForTextureCoordinate = 0x28C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScalarAttributeTextureCoordScale = 0x28CC; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x28D0; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x28D1; // bool
    constexpr std::ptrdiff_t m_nOrientationType = 0x28D4; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nVectorFieldForOrientation = 0x28D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bDrawAsOpaque = 0x28DC; // bool
    constexpr std::ptrdiff_t m_bGenerateNormals = 0x28DD; // bool
}

namespace C_OP_RenderScreenShake { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x204; // float
    constexpr std::ptrdiff_t m_flFrequencyScale = 0x208; // float
    constexpr std::ptrdiff_t m_flAmplitudeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nRadiusField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFrequencyField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAmplitudeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFilterCP = 0x220; // int32_t
}

namespace C_OP_RenderScreenVelocityRotate { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flRotateRateDegrees = 0x200; // float
    constexpr std::ptrdiff_t m_flForwardDegrees = 0x204; // float
}

namespace C_OP_RenderSound { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flDurationScale = 0x200; // float
    constexpr std::ptrdiff_t m_flSndLvlScale = 0x204; // float
    constexpr std::ptrdiff_t m_flPitchScale = 0x208; // float
    constexpr std::ptrdiff_t m_flVolumeScale = 0x20C; // float
    constexpr std::ptrdiff_t m_nSndLvlField = 0x210; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nDurationField = 0x214; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nPitchField = 0x218; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVolumeField = 0x21C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nChannel = 0x220; // int32_t
    constexpr std::ptrdiff_t m_nCPReference = 0x224; // int32_t
    constexpr std::ptrdiff_t m_pszSoundName = 0x228; // char[256]
    constexpr std::ptrdiff_t m_bSuppressStopSoundEvent = 0x328; // bool
}

namespace C_OP_RenderSprites { // CBaseRendererSource2
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x2470; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nOrientationType = 0x25C8; // ParticleOrientationChoiceList_t
    constexpr std::ptrdiff_t m_nOrientationControlPoint = 0x25CC; // int32_t
    constexpr std::ptrdiff_t m_bUseYawWithNormalAligned = 0x25D0; // bool
    constexpr std::ptrdiff_t m_flMinSize = 0x25D4; // float
    constexpr std::ptrdiff_t m_flMaxSize = 0x25D8; // float
    constexpr std::ptrdiff_t m_flAlphaAdjustWithSizeAdjust = 0x25DC; // float
    constexpr std::ptrdiff_t m_flStartFadeSize = 0x25E0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flEndFadeSize = 0x2738; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2890; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2894; // float
    constexpr std::ptrdiff_t m_bDistanceAlpha = 0x2898; // bool
    constexpr std::ptrdiff_t m_bSoftEdges = 0x2899; // bool
    constexpr std::ptrdiff_t m_flEdgeSoftnessStart = 0x289C; // float
    constexpr std::ptrdiff_t m_flEdgeSoftnessEnd = 0x28A0; // float
    constexpr std::ptrdiff_t m_bOutline = 0x28A4; // bool
    constexpr std::ptrdiff_t m_OutlineColor = 0x28A5; // Color
    constexpr std::ptrdiff_t m_nOutlineAlpha = 0x28AC; // int32_t
    constexpr std::ptrdiff_t m_flOutlineStart0 = 0x28B0; // float
    constexpr std::ptrdiff_t m_flOutlineStart1 = 0x28B4; // float
    constexpr std::ptrdiff_t m_flOutlineEnd0 = 0x28B8; // float
    constexpr std::ptrdiff_t m_flOutlineEnd1 = 0x28BC; // float
    constexpr std::ptrdiff_t m_nLightingMode = 0x28C0; // ParticleLightingQuality_t
    constexpr std::ptrdiff_t m_flLightingTessellation = 0x28C8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flLightingDirectionality = 0x2A20; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bParticleShadows = 0x2B78; // bool
    constexpr std::ptrdiff_t m_flShadowDensity = 0x2B7C; // float
}

namespace C_OP_RenderStandardLight { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nLightType = 0x200; // ParticleLightTypeChoiceList_t
    constexpr std::ptrdiff_t m_vecColorScale = 0x208; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_nColorBlendType = 0x860; // ParticleColorBlendType_t
    constexpr std::ptrdiff_t m_flIntensity = 0x868; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bCastShadows = 0x9C0; // bool
    constexpr std::ptrdiff_t m_flTheta = 0x9C8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flPhi = 0xB20; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flRadiusMultiplier = 0xC78; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nAttenuationStyle = 0xDD0; // StandardLightingAttenuationStyle_t
    constexpr std::ptrdiff_t m_flFalloffLinearity = 0xDD8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flFiftyPercentFalloff = 0xF30; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flZeroPercentFalloff = 0x1088; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0x11E0; // bool
    constexpr std::ptrdiff_t m_bRenderSpecular = 0x11E1; // bool
    constexpr std::ptrdiff_t m_lightCookie = 0x11E8; // CUtlString
    constexpr std::ptrdiff_t m_nPriority = 0x11F0; // int32_t
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x11F4; // ParticleLightFogLightingMode_t
    constexpr std::ptrdiff_t m_flFogContribution = 0x11F8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_nCapsuleLightBehavior = 0x1350; // ParticleLightBehaviorChoiceList_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1354; // float
    constexpr std::ptrdiff_t m_bReverseOrder = 0x1358; // bool
    constexpr std::ptrdiff_t m_bClosedLoop = 0x1359; // bool
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x135C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x1360; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x1364; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x1368; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x136C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x1370; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x1374; // float
}

namespace C_OP_RenderStatusEffect { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail2 = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDiffuseWarp = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelColorWarp = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureFresnelWarp = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSpecularWarp = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureEnvMap = 0x230; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderStatusEffectCitadel { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_pTextureColorWarp = 0x200; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureNormal = 0x208; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureMetalness = 0x210; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureRoughness = 0x218; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureSelfIllum = 0x220; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_pTextureDetail = 0x228; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace C_OP_RenderText { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_OutlineColor = 0x200; // Color
    constexpr std::ptrdiff_t m_DefaultText = 0x208; // CUtlString
}

namespace C_OP_RenderTonemapController { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flTonemapLevel = 0x200; // float
    constexpr std::ptrdiff_t m_flTonemapWeight = 0x204; // float
    constexpr std::ptrdiff_t m_nTonemapLevelField = 0x208; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nTonemapWeightField = 0x20C; // ParticleAttributeIndex_t
}

namespace C_OP_RenderTrails { // CBaseTrailRenderer
    constexpr std::ptrdiff_t m_bEnableFadingAndClamping = 0x2740; // bool
    constexpr std::ptrdiff_t m_flStartFadeDot = 0x2744; // float
    constexpr std::ptrdiff_t m_flEndFadeDot = 0x2748; // float
    constexpr std::ptrdiff_t m_nPrevPntSource = 0x274C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flMaxLength = 0x2750; // float
    constexpr std::ptrdiff_t m_flMinLength = 0x2754; // float
    constexpr std::ptrdiff_t m_bIgnoreDT = 0x2758; // bool
    constexpr std::ptrdiff_t m_flConstrainRadiusToLengthRatio = 0x275C; // float
    constexpr std::ptrdiff_t m_flLengthScale = 0x2760; // float
    constexpr std::ptrdiff_t m_flLengthFadeInTime = 0x2764; // float
    constexpr std::ptrdiff_t m_flRadiusHeadTaper = 0x2768; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecHeadColorScale = 0x28C0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flHeadAlphaScale = 0x2F18; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRadiusTaper = 0x3070; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecTailColorScale = 0x31C8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flTailAlphaScale = 0x3820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nHorizCropField = 0x3978; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nVertCropField = 0x397C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flForwardShift = 0x3980; // float
    constexpr std::ptrdiff_t m_bFlipUVBasedOnPitchYaw = 0x3984; // bool
}

namespace C_OP_RenderTreeShake { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_flPeakStrength = 0x200; // float
    constexpr std::ptrdiff_t m_nPeakStrengthFieldOverride = 0x204; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flRadius = 0x208; // float
    constexpr std::ptrdiff_t m_nRadiusFieldOverride = 0x20C; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flShakeDuration = 0x210; // float
    constexpr std::ptrdiff_t m_flTransitionTime = 0x214; // float
    constexpr std::ptrdiff_t m_flTwistAmount = 0x218; // float
    constexpr std::ptrdiff_t m_flRadialAmount = 0x21C; // float
    constexpr std::ptrdiff_t m_flControlPointOrientationAmount = 0x220; // float
    constexpr std::ptrdiff_t m_nControlPointForLinearDirection = 0x224; // int32_t
}

namespace C_OP_RenderVRHapticEvent { // CParticleFunctionRenderer
    constexpr std::ptrdiff_t m_nHand = 0x200; // ParticleVRHandChoiceList_t
    constexpr std::ptrdiff_t m_nOutputHandCP = 0x204; // int32_t
    constexpr std::ptrdiff_t m_nOutputField = 0x208; // int32_t
    constexpr std::ptrdiff_t m_flAmplitude = 0x210; // CPerParticleFloatInput
}

namespace C_OP_RepeatedTriggerChildGroup { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_flClusterRefireTime = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterSize = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flClusterCooldown = 0x488; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bLimitChildCount = 0x5E0; // bool
}

namespace C_OP_RestartAfterDuration { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDurationMin = 0x1C0; // float
    constexpr std::ptrdiff_t m_flDurationMax = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bOnlyChildren = 0x1D4; // bool
}

namespace C_OP_RopeSpringConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flAdjustmentScale = 0x5C8; // float
    constexpr std::ptrdiff_t m_flInitialRestingLength = 0x5D0; // CParticleCollectionFloatInput
}

namespace C_OP_RotateVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecRotAxisMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecRotAxisMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_flRotRateMin = 0x1DC; // float
    constexpr std::ptrdiff_t m_flRotRateMax = 0x1E0; // float
    constexpr std::ptrdiff_t m_bNormalize = 0x1E4; // bool
    constexpr std::ptrdiff_t m_flScale = 0x1E8; // CPerParticleFloatInput
}

namespace C_OP_RtEnvCull { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vecTestDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vecTestNormal = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_bCullOnMiss = 0x1D8; // bool
    constexpr std::ptrdiff_t m_bStickInsteadOfCull = 0x1D9; // bool
    constexpr std::ptrdiff_t m_RtEnvName = 0x1DA; // char[128]
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x25C; // int32_t
    constexpr std::ptrdiff_t m_nComponent = 0x260; // int32_t
}

namespace C_OP_SDFConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flMinDist = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flMaxDist = 0x318; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nMaxIterations = 0x470; // int32_t
}

namespace C_OP_SDFForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flForceScale = 0x1D0; // float
}

namespace C_OP_SDFLighting { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vLightingDir = 0x1C0; // Vector
    constexpr std::ptrdiff_t m_vTint_0 = 0x1CC; // Vector
    constexpr std::ptrdiff_t m_vTint_1 = 0x1D8; // Vector
}

namespace C_OP_SelectivelyEnableChildren { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstChild = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nNumChildrenToEnable = 0x480; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bPlayEndcapOnStop = 0x5D8; // bool
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x5D9; // bool
}

namespace C_OP_SequenceFromModel { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nFieldOutputAnim = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flInputMin = 0x1CC; // float
    constexpr std::ptrdiff_t m_flInputMax = 0x1D0; // float
    constexpr std::ptrdiff_t m_flOutputMin = 0x1D4; // float
    constexpr std::ptrdiff_t m_flOutputMax = 0x1D8; // float
    constexpr std::ptrdiff_t m_nSetMethod = 0x1DC; // ParticleSetMethod_t
}

namespace C_OP_SetAttributeToScalarExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x478; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x47C; // ParticleSetMethod_t
}

namespace C_OP_SetCPOrientationToDirection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nInputControlPoint = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nOutputControlPoint = 0x1C4; // int32_t
}

namespace C_OP_SetCPOrientationToGroundNormal { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flInterpRate = 0x1C0; // float
    constexpr std::ptrdiff_t m_flMaxTraceLength = 0x1C4; // float
    constexpr std::ptrdiff_t m_flTolerance = 0x1C8; // float
    constexpr std::ptrdiff_t m_flTraceOffset = 0x1CC; // float
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1D0; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x250; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_nInputCP = 0x254; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x258; // int32_t
    constexpr std::ptrdiff_t m_bIncludeWater = 0x268; // bool
}

namespace C_OP_SetCPOrientationToPointAtCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nInputCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_b2DOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bAvoidSingularity = 0x331; // bool
    constexpr std::ptrdiff_t m_bPointAway = 0x332; // bool
}

namespace C_OP_SetCPtoVector { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPInput = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C4; // ParticleAttributeIndex_t
}

namespace C_OP_SetChildControlPoints { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bReverse = 0x328; // bool
    constexpr std::ptrdiff_t m_bSetOrientation = 0x329; // bool
}

namespace C_OP_SetControlPointFieldFromVectorExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vecInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vecInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE88; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0xFE0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0xFE4; // int32_t
}

namespace C_OP_SetControlPointFieldToScalarExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // ScalarExpressionType_t
    constexpr std::ptrdiff_t m_flInput1 = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInput2 = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0x488; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputCP = 0x5E0; // int32_t
    constexpr std::ptrdiff_t m_nOutVectorField = 0x5E4; // int32_t
}

namespace C_OP_SetControlPointFieldToWater { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1D8; // int32_t
}

namespace C_OP_SetControlPointFromObjectScale { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointOrientation { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bRandomize = 0x1D2; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D3; // bool
    constexpr std::ptrdiff_t m_nCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_vecRotation = 0x1DC; // QAngle
    constexpr std::ptrdiff_t m_vecRotationB = 0x1E8; // QAngle
    constexpr std::ptrdiff_t m_flInterpolation = 0x1F8; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointOrientationToCPVelocity { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
}

namespace C_OP_SetControlPointPositionToRandomActiveCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMin = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocationMax = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flResetRate = 0x1E0; // CParticleCollectionFloatInput
}

namespace C_OP_SetControlPointPositionToTimeOfDayValue { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_pszTimeOfDayParameter = 0x1D4; // char[128]
    constexpr std::ptrdiff_t m_vecDefaultValue = 0x254; // Vector
}

namespace C_OP_SetControlPointPositions { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D2; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nCP2 = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nCP3 = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCP4 = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1E4; // Vector
    constexpr std::ptrdiff_t m_vecCP2Pos = 0x1F0; // Vector
    constexpr std::ptrdiff_t m_vecCP3Pos = 0x1FC; // Vector
    constexpr std::ptrdiff_t m_vecCP4Pos = 0x208; // Vector
    constexpr std::ptrdiff_t m_nHeadLocation = 0x214; // int32_t
}

namespace C_OP_SetControlPointRotation { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_vecRotAxis = 0x1D0; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_flRotRate = 0x828; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nCP = 0x980; // int32_t
    constexpr std::ptrdiff_t m_nLocalCP = 0x984; // int32_t
}

namespace C_OP_SetControlPointToCPVelocity { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutputVel = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_bNormalize = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCPOutputMag = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_vecComparisonVelocity = 0x1E8; // CParticleCollectionVecInput
}

namespace C_OP_SetControlPointToCenter { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_nSetParent = 0x1E0; // ParticleParentSetMode_t
}

namespace C_OP_SetControlPointToHMD { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToHMD = 0x1E0; // bool
}

namespace C_OP_SetControlPointToHand { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nHand = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_bOrientToHand = 0x1E4; // bool
}

namespace C_OP_SetControlPointToImpactPoint { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPOut = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPIn = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flUpdateRate = 0x1D8; // float
    constexpr std::ptrdiff_t m_flTraceLength = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flStartOffset = 0x338; // float
    constexpr std::ptrdiff_t m_flOffset = 0x33C; // float
    constexpr std::ptrdiff_t m_vecTraceDir = 0x340; // Vector
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x34C; // char[128]
    constexpr std::ptrdiff_t m_nTraceSet = 0x3CC; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_bSetToEndpoint = 0x3D0; // bool
    constexpr std::ptrdiff_t m_bTraceToClosestSurface = 0x3D1; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x3D2; // bool
}

namespace C_OP_SetControlPointToPlayer { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCP1 = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bOrientToEyes = 0x1E0; // bool
}

namespace C_OP_SetControlPointToVectorExpression { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nExpression = 0x1D0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_nOutputCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x830; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE88; // bool
}

namespace C_OP_SetControlPointToWaterSurface { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nSourceCP = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nDestCP = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nFlowCP = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nActiveCP = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_nActiveCPField = 0x1E0; // int32_t
    constexpr std::ptrdiff_t m_flRetestRate = 0x1E8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bAdaptiveThreshold = 0x340; // bool
}

namespace C_OP_SetControlPointsToModelParticles { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_HitboxSetName = 0x1C0; // char[128]
    constexpr std::ptrdiff_t m_AttachmentName = 0x240; // char[128]
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x2C0; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x2C4; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x2C8; // int32_t
    constexpr std::ptrdiff_t m_bSkin = 0x2CC; // bool
    constexpr std::ptrdiff_t m_bAttachment = 0x2CD; // bool
}

namespace C_OP_SetControlPointsToParticle { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nOrientationMode = 0x1D4; // ParticleOrientationSetMode_t
    constexpr std::ptrdiff_t m_nSetParent = 0x1D8; // ParticleParentSetMode_t
}

namespace C_OP_SetFloat { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bUseNewCode = 0x478; // bool
}

namespace C_OP_SetFloatAttributeToVectorExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorFloatExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flOutputRemap = 0xE78; // CParticleRemapFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0xFD0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xFD4; // ParticleSetMethod_t
}

namespace C_OP_SetFloatCollection { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nOutputField = 0x318; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x31C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x320; // CParticleCollectionFloatInput
}

namespace C_OP_SetFromCPSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_bRandom = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bReverse = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nSnapShotStartPoint = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nSnapShotIncrement = 0x330; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_flInterpolation = 0x488; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bSubSample = 0x5E0; // bool
}

namespace C_OP_SetGravityToCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nCPInput = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPOutput = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_flScale = 0x1D8; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x330; // bool
    constexpr std::ptrdiff_t m_bSetZDown = 0x331; // bool
}

namespace C_OP_SetParentControlPointsToChildCP { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nChildControlPoint = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1DC; // int32_t
    constexpr std::ptrdiff_t m_bSetOrientation = 0x1E0; // bool
}

namespace C_OP_SetPerChildControlPoint { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x328; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bSetOrientation = 0x480; // bool
    constexpr std::ptrdiff_t m_nOrientationField = 0x484; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x488; // bool
}

namespace C_OP_SetPerChildControlPointFromAttribute { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nChildGroupID = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nFirstControlPoint = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nNumControlPoints = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nParticleIncrement = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nFirstSourcePoint = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_bNumBasedOnParticleCount = 0x1D4; // bool
    constexpr std::ptrdiff_t m_nAttributeToRead = 0x1D8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nCPField = 0x1DC; // int32_t
}

namespace C_OP_SetRandomControlPointPosition { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bUseWorldLocation = 0x1D0; // bool
    constexpr std::ptrdiff_t m_bOrient = 0x1D1; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_nHeadLocation = 0x1D8; // int32_t
    constexpr std::ptrdiff_t m_flReRandomRate = 0x1E0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_vecCPMinPos = 0x338; // Vector
    constexpr std::ptrdiff_t m_vecCPMaxPos = 0x344; // Vector
    constexpr std::ptrdiff_t m_flInterpolation = 0x350; // CParticleCollectionFloatInput
}

namespace C_OP_SetSimulationRate { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flSimulationScale = 0x1D0; // CParticleCollectionFloatInput
}

namespace C_OP_SetSingleControlPointPosition { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_bSetOnce = 0x1D0; // bool
    constexpr std::ptrdiff_t m_nCP1 = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vecCP1Pos = 0x1D8; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_transformInput = 0x830; // CParticleTransformInput
}

namespace C_OP_SetToCP { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_bOffsetLocal = 0x1D0; // bool
}

namespace C_OP_SetVariable { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_variableReference = 0x1D0; // CParticleVariableRef
    constexpr std::ptrdiff_t m_transformInput = 0x210; // CParticleTransformInput
    constexpr std::ptrdiff_t m_positionOffset = 0x278; // Vector
    constexpr std::ptrdiff_t m_rotationOffset = 0x284; // QAngle
    constexpr std::ptrdiff_t m_vecInput = 0x290; // CParticleCollectionVecInput
    constexpr std::ptrdiff_t m_floatInput = 0x8E8; // CParticleCollectionFloatInput
}

namespace C_OP_SetVec { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_InputValue = 0x1C0; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0x818; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0x81C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_Lerp = 0x820; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0x978; // bool
}

namespace C_OP_SetVectorAttributeToVectorExpression { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nExpression = 0x1C0; // VectorExpressionType_t
    constexpr std::ptrdiff_t m_vInput1 = 0x1C8; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_vInput2 = 0x820; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_nOutputField = 0xE78; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nSetMethod = 0xE7C; // ParticleSetMethod_t
    constexpr std::ptrdiff_t m_bNormalizedOutput = 0xE80; // bool
}

namespace C_OP_ShapeMatchingConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flShapeRestorationTime = 0x1C0; // float
}

namespace C_OP_SnapshotRigidSkinToBones { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
}

namespace C_OP_SnapshotSkinToBones { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_bTransformNormals = 0x1C0; // bool
    constexpr std::ptrdiff_t m_bTransformRadii = 0x1C1; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_flLifeTimeFadeStart = 0x1C8; // float
    constexpr std::ptrdiff_t m_flLifeTimeFadeEnd = 0x1CC; // float
    constexpr std::ptrdiff_t m_flJumpThreshold = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPrevPosScale = 0x1D4; // float
}

namespace C_OP_Spin { // CGeneralSpin
}

namespace C_OP_SpinUpdate { // CSpinUpdateBase
}

namespace C_OP_SpinYaw { // CGeneralSpin
}

namespace C_OP_SpringToVectorConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_flRestLength = 0x1C0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMinDistance = 0x318; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flMaxDistance = 0x470; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRestingLength = 0x5C8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecAnchorVector = 0x720; // CPerParticleVecInput
}

namespace C_OP_StopAfterCPDuration { // CParticleFunctionPreEmission
    constexpr std::ptrdiff_t m_flDuration = 0x1D0; // CParticleCollectionFloatInput
    constexpr std::ptrdiff_t m_bDestroyImmediately = 0x328; // bool
    constexpr std::ptrdiff_t m_bPlayEndCap = 0x329; // bool
}

namespace C_OP_TeleportBeam { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nCPPosition = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nCPVelocity = 0x1C4; // int32_t
    constexpr std::ptrdiff_t m_nCPMisc = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_nCPColor = 0x1CC; // int32_t
    constexpr std::ptrdiff_t m_nCPInvalidColor = 0x1D0; // int32_t
    constexpr std::ptrdiff_t m_nCPExtraArcData = 0x1D4; // int32_t
    constexpr std::ptrdiff_t m_vGravity = 0x1D8; // Vector
    constexpr std::ptrdiff_t m_flArcMaxDuration = 0x1E4; // float
    constexpr std::ptrdiff_t m_flSegmentBreak = 0x1E8; // float
    constexpr std::ptrdiff_t m_flArcSpeed = 0x1EC; // float
    constexpr std::ptrdiff_t m_flAlpha = 0x1F0; // float
}

namespace C_OP_TimeVaryingForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flStartLerpTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_StartingForce = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_flEndLerpTime = 0x1E0; // float
    constexpr std::ptrdiff_t m_EndingForce = 0x1E4; // Vector
}

namespace C_OP_TurbulenceForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_flNoiseCoordScale0 = 0x1D0; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale1 = 0x1D4; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale2 = 0x1D8; // float
    constexpr std::ptrdiff_t m_flNoiseCoordScale3 = 0x1DC; // float
    constexpr std::ptrdiff_t m_vecNoiseAmount0 = 0x1E0; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount1 = 0x1EC; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount2 = 0x1F8; // Vector
    constexpr std::ptrdiff_t m_vecNoiseAmount3 = 0x204; // Vector
}

namespace C_OP_TwistAroundAxis { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_fForceAmount = 0x1D0; // float
    constexpr std::ptrdiff_t m_TwistAxis = 0x1D4; // Vector
    constexpr std::ptrdiff_t m_bLocalSpace = 0x1E0; // bool
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1E4; // int32_t
}

namespace C_OP_UpdateLightSource { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_vColorTint = 0x1C0; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x1C8; // float
    constexpr std::ptrdiff_t m_flMinimumLightingRadius = 0x1CC; // float
    constexpr std::ptrdiff_t m_flMaximumLightingRadius = 0x1D0; // float
    constexpr std::ptrdiff_t m_flPositionDampingConstant = 0x1D4; // float
}

namespace C_OP_VectorFieldSnapshot { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nControlPointNumber = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_nAttributeToWrite = 0x1C4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nLocalSpaceCP = 0x1C8; // int32_t
    constexpr std::ptrdiff_t m_flInterpolation = 0x1D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_vecScale = 0x328; // CPerParticleVecInput
    constexpr std::ptrdiff_t m_flBoundaryDampening = 0x980; // float
    constexpr std::ptrdiff_t m_bSetVelocity = 0x984; // bool
    constexpr std::ptrdiff_t m_bLockToSurface = 0x985; // bool
    constexpr std::ptrdiff_t m_flGridSpacing = 0x988; // float
}

namespace C_OP_VectorNoise { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_nFieldOutput = 0x1C0; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_vecOutputMin = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_vecOutputMax = 0x1D0; // Vector
    constexpr std::ptrdiff_t m_fl4NoiseScale = 0x1DC; // float
    constexpr std::ptrdiff_t m_bAdditive = 0x1E0; // bool
    constexpr std::ptrdiff_t m_bOffset = 0x1E1; // bool
    constexpr std::ptrdiff_t m_flNoiseAnimationTimeScale = 0x1E4; // float
}

namespace C_OP_VelocityDecay { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flMinVelocity = 0x1C0; // float
}

namespace C_OP_VelocityMatchingForce { // CParticleFunctionOperator
    constexpr std::ptrdiff_t m_flDirScale = 0x1C0; // float
    constexpr std::ptrdiff_t m_flSpdScale = 0x1C4; // float
    constexpr std::ptrdiff_t m_nCPBroadcast = 0x1C8; // int32_t
}

namespace C_OP_WindForce { // CParticleFunctionForce
    constexpr std::ptrdiff_t m_vForce = 0x1D0; // Vector
}

namespace C_OP_WorldCollideConstraint { // CParticleFunctionConstraint
}

namespace C_OP_WorldTraceConstraint { // CParticleFunctionConstraint
    constexpr std::ptrdiff_t m_nCP = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_vecCpOffset = 0x1C4; // Vector
    constexpr std::ptrdiff_t m_nCollisionMode = 0x1D0; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nCollisionModeMin = 0x1D4; // ParticleCollisionMode_t
    constexpr std::ptrdiff_t m_nTraceSet = 0x1D8; // ParticleTraceSet_t
    constexpr std::ptrdiff_t m_CollisionGroupName = 0x1DC; // char[128]
    constexpr std::ptrdiff_t m_bWorldOnly = 0x25C; // bool
    constexpr std::ptrdiff_t m_bBrushOnly = 0x25D; // bool
    constexpr std::ptrdiff_t m_bIncludeWater = 0x25E; // bool
    constexpr std::ptrdiff_t m_nIgnoreCP = 0x260; // int32_t
    constexpr std::ptrdiff_t m_flCpMovementTolerance = 0x264; // float
    constexpr std::ptrdiff_t m_flRetestRate = 0x268; // float
    constexpr std::ptrdiff_t m_flTraceTolerance = 0x26C; // float
    constexpr std::ptrdiff_t m_flCollisionConfirmationSpeed = 0x270; // float
    constexpr std::ptrdiff_t m_nMaxTracesPerFrame = 0x274; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0x278; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flBounceAmount = 0x3D0; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flSlideAmount = 0x528; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_flRandomDirScale = 0x680; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_bDecayBounce = 0x7D8; // bool
    constexpr std::ptrdiff_t m_bKillonContact = 0x7D9; // bool
    constexpr std::ptrdiff_t m_flMinSpeed = 0x7DC; // float
    constexpr std::ptrdiff_t m_bSetNormal = 0x7E0; // bool
    constexpr std::ptrdiff_t m_nStickOnCollisionField = 0x7E4; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flStopSpeed = 0x7E8; // CPerParticleFloatInput
    constexpr std::ptrdiff_t m_nEntityStickDataField = 0x940; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_nEntityStickNormalField = 0x944; // ParticleAttributeIndex_t
}

namespace CollisionGroupContext_t {
    constexpr std::ptrdiff_t m_nCollisionGroupNumber = 0x0; // int32_t
}

namespace ControlPointReference_t {
    constexpr std::ptrdiff_t m_controlPointNameString = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOffsetFromControlPoint = 0x4; // Vector
    constexpr std::ptrdiff_t m_bOffsetInLocalSpace = 0x10; // bool
}

namespace FloatInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flInput = 0x8; // CParticleCollectionFloatInput
}

namespace IControlPointEditorData {
}

namespace IParticleCollection {
}

namespace IParticleEffect {
}

namespace IParticleSystemDefinition {
}

namespace MaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nVariableField = 0x8; // ParticleAttributeIndex_t
    constexpr std::ptrdiff_t m_flScale = 0xC; // float
}

namespace ModelReference_t {
    constexpr std::ptrdiff_t m_model = 0x0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_flRelativeProbabilityOfSpawn = 0x8; // float
}

namespace PARTICLE_EHANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace PARTICLE_WORLD_HANDLE__ {
    constexpr std::ptrdiff_t unused = 0x0; // int32_t
}

namespace ParticleAttributeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace ParticleChildrenInfo_t {
    constexpr std::ptrdiff_t m_ChildRef = 0x0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flDelay = 0x8; // float
    constexpr std::ptrdiff_t m_bEndCap = 0xC; // bool
    constexpr std::ptrdiff_t m_bDisableChild = 0xD; // bool
    constexpr std::ptrdiff_t m_nDetailLevel = 0x10; // ParticleDetailLevel_t
}

namespace ParticleControlPointConfiguration_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_drivers = 0x8; // CUtlVector<ParticleControlPointDriver_t>
    constexpr std::ptrdiff_t m_previewState = 0x20; // ParticlePreviewState_t
}

namespace ParticleControlPointDriver_t {
    constexpr std::ptrdiff_t m_iControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iAttachType = 0x4; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_attachmentName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_vecOffset = 0x10; // Vector
    constexpr std::ptrdiff_t m_angOffset = 0x1C; // QAngle
    constexpr std::ptrdiff_t m_entityName = 0x28; // CUtlString
}

namespace ParticleNamedValueConfiguration_t {
    constexpr std::ptrdiff_t m_ConfigName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_ConfigValue = 0x8; // KeyValues3
    constexpr std::ptrdiff_t m_iAttachType = 0x18; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_BoundEntityPath = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_strEntityScope = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_strAttachmentName = 0x30; // CUtlString
}

namespace ParticleNamedValueSource_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_IsPublic = 0x8; // bool
    constexpr std::ptrdiff_t m_ValueType = 0xC; // PulseValueType_t
    constexpr std::ptrdiff_t m_DefaultConfig = 0x10; // ParticleNamedValueConfiguration_t
    constexpr std::ptrdiff_t m_NamedConfigs = 0x48; // CUtlVector<ParticleNamedValueConfiguration_t>
}

namespace ParticlePreviewBodyGroup_t {
    constexpr std::ptrdiff_t m_bodyGroupName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nValue = 0x8; // int32_t
}

namespace ParticlePreviewState_t {
    constexpr std::ptrdiff_t m_previewModel = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nModSpecificData = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_groundType = 0xC; // PetGroundType_t
    constexpr std::ptrdiff_t m_sequenceName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nFireParticleOnSequenceFrame = 0x18; // int32_t
    constexpr std::ptrdiff_t m_hitboxSetName = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_materialGroupName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_vecBodyGroups = 0x30; // CUtlVector<ParticlePreviewBodyGroup_t>
    constexpr std::ptrdiff_t m_flPlaybackSpeed = 0x48; // float
    constexpr std::ptrdiff_t m_flParticleSimulationRate = 0x4C; // float
    constexpr std::ptrdiff_t m_bShouldDrawHitboxes = 0x50; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachments = 0x51; // bool
    constexpr std::ptrdiff_t m_bShouldDrawAttachmentNames = 0x52; // bool
    constexpr std::ptrdiff_t m_bShouldDrawControlPointAxes = 0x53; // bool
    constexpr std::ptrdiff_t m_bAnimationNonLooping = 0x54; // bool
    constexpr std::ptrdiff_t m_vecPreviewGravity = 0x58; // Vector
}

namespace PointDefinitionWithTimeValues_t { // PointDefinition_t
    constexpr std::ptrdiff_t m_flTimeDuration = 0x14; // float
}

namespace PointDefinition_t {
    constexpr std::ptrdiff_t m_nControlPoint = 0x0; // int32_t
    constexpr std::ptrdiff_t m_bLocalCoords = 0x4; // bool
    constexpr std::ptrdiff_t m_vOffset = 0x8; // Vector
}

namespace SequenceWeightedList_t {
    constexpr std::ptrdiff_t m_nSequence = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flRelativeWeight = 0x4; // float
}

namespace TextureControls_t {
    constexpr std::ptrdiff_t m_flFinalTextureScaleU = 0x0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureScaleV = 0x158; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetU = 0x2B0; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureOffsetV = 0x408; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flFinalTextureUVRotation = 0x560; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flZoomScale = 0x6B8; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_flDistortion = 0x810; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_bRandomizeOffsets = 0x968; // bool
    constexpr std::ptrdiff_t m_bClampUVs = 0x969; // bool
    constexpr std::ptrdiff_t m_nPerParticleBlend = 0x96C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleScale = 0x970; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetU = 0x974; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleOffsetV = 0x978; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleRotation = 0x97C; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleZoom = 0x980; // SpriteCardPerParticleScale_t
    constexpr std::ptrdiff_t m_nPerParticleDistortion = 0x984; // SpriteCardPerParticleScale_t
}

namespace TextureGroup_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bReplaceTextureWithGradient = 0x1; // bool
    constexpr std::ptrdiff_t m_hTexture = 0x8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_Gradient = 0x10; // CColorGradient
    constexpr std::ptrdiff_t m_nTextureType = 0x28; // SpriteCardTextureType_t
    constexpr std::ptrdiff_t m_nTextureChannels = 0x2C; // SpriteCardTextureChannel_t
    constexpr std::ptrdiff_t m_nTextureBlendMode = 0x30; // ParticleTextureLayerBlendType_t
    constexpr std::ptrdiff_t m_flTextureBlend = 0x38; // CParticleCollectionRendererFloatInput
    constexpr std::ptrdiff_t m_TextureControls = 0x190; // TextureControls_t
}

namespace VecInputMaterialVariable_t {
    constexpr std::ptrdiff_t m_strVariable = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vecInput = 0x8; // CParticleCollectionVecInput
}
```

`HPCS2/offset/pulse_system.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:51 +0000
 */

#pragma once

#include <cstddef>

namespace CBasePulseGraphInstance {
}

namespace CPulseCell_Base {
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
}

namespace CPulseCell_BaseFlow { // CPulseCell_Base
}

namespace CPulseCell_BaseValue { // CPulseCell_Base
}

namespace CPulseCell_BaseYieldingInflow { // CPulseCell_BaseFlow
}

namespace CPulseCell_Inflow_BaseEntrypoint { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_EntryChunk = 0x48; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x50; // PulseRegisterMap_t
}

namespace CPulseCell_Inflow_EntOutputHandler { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_SourceEntity = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SourceOutput = 0x78; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x80; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedParamType = 0x88; // CPulseValueFullType
}

namespace CPulseCell_Inflow_EventHandler { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_EventName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_GraphHook { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_HookName = 0x70; // CUtlSymbolLarge
}

namespace CPulseCell_Inflow_Method { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_MethodName = 0x70; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x78; // CUtlString
    constexpr std::ptrdiff_t m_bIsPublic = 0x80; // bool
    constexpr std::ptrdiff_t m_ReturnType = 0x88; // CPulseValueFullType
    constexpr std::ptrdiff_t m_Args = 0x98; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Inflow_Wait { // CPulseCell_BaseYieldingInflow
    constexpr std::ptrdiff_t m_WakeResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Inflow_Yield { // CPulseCell_BaseYieldingInflow
    constexpr std::ptrdiff_t m_UnyieldResume = 0x48; // CPulse_ResumePoint
}

namespace CPulseCell_Outflow_CycleOrdered { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleOrdered_InstanceState_t {
    constexpr std::ptrdiff_t m_nNextIndex = 0x0; // int32_t
}

namespace CPulseCell_Outflow_CycleRandom { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_CycleShuffled_InstanceState_t {
    constexpr std::ptrdiff_t m_Shuffle = 0x0; // CUtlVectorFixedGrowable<uint8_t>
    constexpr std::ptrdiff_t m_nNextShuffle = 0x20; // int32_t
}

namespace CPulseCell_Outflow_IntSwitch { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_SimultaneousParallel { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Outputs = 0x48; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_StringSwitch { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_DefaultCaseOutflow = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_CaseOutflows = 0x58; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_Outflow_TestExplicitYesNo { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Outflow_TestRandomYesNo { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Yes = 0x48; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_No = 0x58; // CPulse_OutflowConnection
}

namespace CPulseCell_Step_CallExternalMethod { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_MethodName = 0x48; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExpectedArgs = 0x50; // CUtlVector<CPulseRuntimeMethodArg>
}

namespace CPulseCell_Step_DebugLog { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_PublicOutput { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_OutputIndex = 0x48; // PulseRuntimeOutputIndex_t
}

namespace CPulseCell_Step_TestDomainCreateFakeEntity { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_TestDomainDestroyFakeEntity { // CPulseCell_BaseFlow
}

namespace CPulseCell_Step_TestDomainEntFire { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseCell_Step_TestDomainTracepoint { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_MultiInflow_NoDefault { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_MultiInflow_WithDefault { // CPulseCell_BaseFlow
}

namespace CPulseCell_Test_NoInflow { // CPulseCell_BaseFlow
}

namespace CPulseCell_Val_TestDomainFindEntityByName { // CPulseCell_BaseValue
}

namespace CPulseCell_Val_TestDomainGetEntityName { // CPulseCell_BaseValue
}

namespace CPulseCell_Value_RandomInt { // CPulseCell_BaseValue
}

namespace CPulseCell_Value_TestValue50 { // CPulseCell_BaseValue
}

namespace CPulseExecCursor {
}

namespace CPulseGraphDef {
    constexpr std::ptrdiff_t m_DomainIdentifier = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ParentMapName = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Chunks = 0x18; // CUtlVector<CPulse_Chunk*>
    constexpr std::ptrdiff_t m_Cells = 0x30; // CUtlVector<CPulseCell_Base*>
    constexpr std::ptrdiff_t m_Vars = 0x48; // CUtlVector<CPulse_Variable>
    constexpr std::ptrdiff_t m_PublicOutputs = 0x60; // CUtlVector<CPulse_PublicOutput>
    constexpr std::ptrdiff_t m_InvokeBindings = 0x78; // CUtlVector<CPulse_InvokeBinding*>
    constexpr std::ptrdiff_t m_CallInfos = 0x90; // CUtlVector<CPulse_CallInfo*>
    constexpr std::ptrdiff_t m_OutputConnections = 0xA8; // CUtlVector<CPulse_OutputConnection*>
}

namespace CPulseGraphInstance_TestDomain { // CBasePulseGraphInstance
    constexpr std::ptrdiff_t m_bIsRunningUnitTests = 0xD0; // bool
    constexpr std::ptrdiff_t m_bExplicitTimeStepping = 0xD1; // bool
    constexpr std::ptrdiff_t m_bExpectingToDestroyWithYieldedCursors = 0xD2; // bool
    constexpr std::ptrdiff_t m_nNextValidateIndex = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_Tracepoints = 0xD8; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_bTestYesOrNoPath = 0xF0; // bool
}

namespace CPulseGraphInstance_TestDomain_Derived { // CPulseGraphInstance_TestDomain
    constexpr std::ptrdiff_t m_nInstanceValueX = 0xF8; // int32_t
}

namespace CPulseGraphInstance_TurtleGraphics { // CBasePulseGraphInstance
}

namespace CPulseMathlib {
}

namespace CPulseRuntimeMethodArg {
    constexpr std::ptrdiff_t m_Name = 0x0; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_Description = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x40; // CPulseValueFullType
}

namespace CPulseTestFuncs_DerivedDomain {
}

namespace CPulseTestFuncs_LibraryA {
}

namespace CPulseTestScriptLib {
}

namespace CPulseTurtleGraphicsCursor { // CPulseExecCursor
    constexpr std::ptrdiff_t m_Color = 0x188; // Color
    constexpr std::ptrdiff_t m_vPos = 0x18C; // Vector2D
    constexpr std::ptrdiff_t m_flHeadingDeg = 0x194; // float
    constexpr std::ptrdiff_t m_bPenUp = 0x198; // bool
}

namespace CPulse_CallInfo {
    constexpr std::ptrdiff_t m_PortName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nEditorNodeID = 0x8; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_RegisterMap = 0x10; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_CallMethodID = 0x30; // PulseDocNodeID_t
    constexpr std::ptrdiff_t m_nSrcChunk = 0x34; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x38; // int32_t
}

namespace CPulse_Chunk {
    constexpr std::ptrdiff_t m_Instructions = 0x0; // CUtlLeanVector<PGDInstruction_t>
    constexpr std::ptrdiff_t m_Registers = 0x10; // CUtlLeanVector<CPulse_RegisterInfo>
    constexpr std::ptrdiff_t m_InstructionEditorIDs = 0x20; // CUtlLeanVector<PulseDocNodeID_t>
}

namespace CPulse_InvokeBinding {
    constexpr std::ptrdiff_t m_RegisterMap = 0x0; // PulseRegisterMap_t
    constexpr std::ptrdiff_t m_FuncName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nCellIndex = 0x28; // PulseRuntimeCellIndex_t
    constexpr std::ptrdiff_t m_InstanceType = 0x30; // CPulseValueFullType
    constexpr std::ptrdiff_t m_nSrcChunk = 0x40; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nSrcInstruction = 0x44; // int32_t
}

namespace CPulse_OutflowConnection {
    constexpr std::ptrdiff_t m_SourceOutflowName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDestChunk = 0x8; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nInstruction = 0xC; // int32_t
}

namespace CPulse_OutputConnection {
    constexpr std::ptrdiff_t m_SourceOutput = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntity = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetInput = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Param = 0x18; // CUtlSymbolLarge
}

namespace CPulse_PublicOutput {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ParamType = 0x10; // CPulseValueFullType
}

namespace CPulse_RegisterInfo {
    constexpr std::ptrdiff_t m_nReg = 0x0; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_Type = 0x8; // CPulseValueFullType
    constexpr std::ptrdiff_t m_OriginName = 0x18; // CKV3MemberNameWithStorage
    constexpr std::ptrdiff_t m_nWrittenByInstruction = 0x50; // int32_t
    constexpr std::ptrdiff_t m_nLastReadByInstruction = 0x54; // int32_t
}

namespace CPulse_ResumePoint { // CPulse_OutflowConnection
}

namespace CPulse_Variable {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Description = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Type = 0x10; // CPulseValueFullType
    constexpr std::ptrdiff_t m_DefaultValue = 0x20; // KeyValues3
    constexpr std::ptrdiff_t m_bIsPublic = 0x32; // bool
}

namespace CTestDomainDerived_Cursor { // CPulseExecCursor
    constexpr std::ptrdiff_t m_nCursorValueA = 0x188; // int32_t
    constexpr std::ptrdiff_t m_nCursorValueB = 0x18C; // int32_t
}

namespace FakeEntity_t {
    constexpr std::ptrdiff_t m_nHandle = 0x0; // PulseTestEHandle_t
    constexpr std::ptrdiff_t m_Name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_Class = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_bDestroyed = 0x18; // bool
    constexpr std::ptrdiff_t m_pAssociatedGraphInstance = 0x20; // CPulseGraphInstance_TestDomain*
    constexpr std::ptrdiff_t m_bFuncWasCalled = 0x28; // bool
    constexpr std::ptrdiff_t m_fValue = 0x2C; // float
}

namespace PGDInstruction_t {
    constexpr std::ptrdiff_t m_nCode = 0x0; // PulseInstructionCode_t
    constexpr std::ptrdiff_t m_nVar = 0x4; // PulseRuntimeVarIndex_t
    constexpr std::ptrdiff_t m_nReg0 = 0x8; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg1 = 0xA; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nReg2 = 0xC; // PulseRuntimeRegisterIndex_t
    constexpr std::ptrdiff_t m_nInvokeBindingIndex = 0x10; // PulseRuntimeInvokeIndex_t
    constexpr std::ptrdiff_t m_nChunk = 0x14; // PulseRuntimeChunkIndex_t
    constexpr std::ptrdiff_t m_nDestInstruction = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nCallInfoIndex = 0x1C; // PulseRuntimeCallInfoIndex_t
    constexpr std::ptrdiff_t m_Arg0Name = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Arg1Name = 0x28; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLiteralBool = 0x30; // bool
    constexpr std::ptrdiff_t m_nLiteralInt = 0x34; // int32_t
    constexpr std::ptrdiff_t m_flLiteralFloat = 0x38; // float
    constexpr std::ptrdiff_t m_LiteralString = 0x40; // CBufferString
    constexpr std::ptrdiff_t m_vLiteralVec3 = 0x50; // Vector
}

namespace PulseDocNodeID_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRegisterMap_t {
    constexpr std::ptrdiff_t m_Inparams = 0x0; // KeyValues3
    constexpr std::ptrdiff_t m_Outparams = 0x10; // KeyValues3
}

namespace PulseRuntimeCallInfoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeCellIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeChunkIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeEntrypointIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeInvokeIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeOutputIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseRuntimeRegisterIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int16_t
}

namespace PulseRuntimeStateOffset_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace PulseRuntimeVarIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PulseTestEHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}
```

`HPCS2/offset/rendersystemdx11.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace RenderInputLayoutField_t {
    constexpr std::ptrdiff_t m_pSemanticName = 0x0; // uint8_t[32]
    constexpr std::ptrdiff_t m_nSemanticIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_Format = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nOffset = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nSlot = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_nSlotType = 0x30; // RenderSlotType_t
    constexpr std::ptrdiff_t m_nInstanceStepRate = 0x34; // int32_t
}

namespace VsInputSignatureElement_t {
    constexpr std::ptrdiff_t m_pName = 0x0; // char[64]
    constexpr std::ptrdiff_t m_pSemantic = 0x40; // char[64]
    constexpr std::ptrdiff_t m_pD3DSemanticName = 0x80; // char[64]
    constexpr std::ptrdiff_t m_nD3DSemanticIndex = 0xC0; // int32_t
}

namespace VsInputSignature_t {
    constexpr std::ptrdiff_t m_elems = 0x0; // CUtlVector<VsInputSignatureElement_t>
}
```

`HPCS2/offset/resourcesystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace AABB_t {
    constexpr std::ptrdiff_t m_vMinBounds = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0xC; // Vector
}

namespace CFuseProgram {
    constexpr std::ptrdiff_t m_programBuffer = 0x0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_variablesRead = 0x18; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_variablesWritten = 0x30; // CUtlVector<FuseVariableIndex_t>
    constexpr std::ptrdiff_t m_nMaxTempVarsUsed = 0x48; // int32_t
}

namespace CFuseSymbolTable {
    constexpr std::ptrdiff_t m_constants = 0x0; // CUtlVector<ConstantInfo_t>
    constexpr std::ptrdiff_t m_variables = 0x18; // CUtlVector<VariableInfo_t>
    constexpr std::ptrdiff_t m_functions = 0x30; // CUtlVector<FunctionInfo_t>
    constexpr std::ptrdiff_t m_constantMap = 0x48; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_variableMap = 0x68; // CUtlHashtable<CUtlStringToken,int32_t>
    constexpr std::ptrdiff_t m_functionMap = 0x88; // CUtlHashtable<CUtlStringToken,int32_t>
}

namespace ConstantInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_flValue = 0xC; // float
}

namespace FourQuaternions {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
    constexpr std::ptrdiff_t z = 0x20; // fltx4
    constexpr std::ptrdiff_t w = 0x30; // fltx4
}

namespace FunctionInfo_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nParamCount = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nIndex = 0x18; // FuseFunctionIndex_t
    constexpr std::ptrdiff_t m_bIsPure = 0x1A; // bool
}

namespace FuseFunctionIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace FuseVariableIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint16_t
}

namespace InfoForResourceTypeCAnimData {
}

namespace InfoForResourceTypeCAnimationGroup {
}

namespace InfoForResourceTypeCCSGOEconItem {
}

namespace InfoForResourceTypeCChoreoSceneFileData {
}

namespace InfoForResourceTypeCCompositeMaterialKit {
}

namespace InfoForResourceTypeCDACGameDefsData {
}

namespace InfoForResourceTypeCDOTANovelsList {
}

namespace InfoForResourceTypeCDOTAPatchNotesList {
}

namespace InfoForResourceTypeCDotaItemDefinitionResource {
}

namespace InfoForResourceTypeCEntityLump {
}

namespace InfoForResourceTypeCJavaScriptResource {
}

namespace InfoForResourceTypeCModel {
}

namespace InfoForResourceTypeCMorphSetData {
}

namespace InfoForResourceTypeCNmClip {
}

namespace InfoForResourceTypeCNmSkeleton {
}

namespace InfoForResourceTypeCPanoramaDynamicImages {
}

namespace InfoForResourceTypeCPanoramaLayout {
}

namespace InfoForResourceTypeCPanoramaStyle {
}

namespace InfoForResourceTypeCPhysAggregateData {
}

namespace InfoForResourceTypeCPostProcessingResource {
}

namespace InfoForResourceTypeCRenderMesh {
}

namespace InfoForResourceTypeCResponseRulesList {
}

namespace InfoForResourceTypeCSequenceGroupData {
}

namespace InfoForResourceTypeCSmartProp {
}

namespace InfoForResourceTypeCTextureBase {
}

namespace InfoForResourceTypeCTypeScriptResource {
}

namespace InfoForResourceTypeCVDataResource {
}

namespace InfoForResourceTypeCVMixListResource {
}

namespace InfoForResourceTypeCVPhysXSurfacePropertiesList {
}

namespace InfoForResourceTypeCVSoundEventScriptList {
}

namespace InfoForResourceTypeCVSoundStackScriptList {
}

namespace InfoForResourceTypeCVoxelVisibility {
}

namespace InfoForResourceTypeCWorldNode {
}

namespace InfoForResourceTypeIAnimGraphModelBinding {
}

namespace InfoForResourceTypeIMaterial2 {
}

namespace InfoForResourceTypeIParticleSnapshot {
}

namespace InfoForResourceTypeIParticleSystemDefinition {
}

namespace InfoForResourceTypeIPulseGraphDef {
}

namespace InfoForResourceTypeIVectorGraphic {
}

namespace InfoForResourceTypeManifestTestResource_t {
}

namespace InfoForResourceTypeProceduralTestResource_t {
}

namespace InfoForResourceTypeTestResource_t {
}

namespace InfoForResourceTypeVSound_t {
}

namespace InfoForResourceTypeWorld_t {
}

namespace ManifestTestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_child = 0x8; // CStrongHandle<InfoForResourceTypeManifestTestResource_t>
}

namespace PackedAABB_t {
    constexpr std::ptrdiff_t m_nPackedMin = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nPackedMax = 0x4; // uint32_t
}

namespace TestResource_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
}

namespace VariableInfo_t {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nameToken = 0x8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nIndex = 0xC; // FuseVariableIndex_t
    constexpr std::ptrdiff_t m_nNumComponents = 0xE; // uint8_t
    constexpr std::ptrdiff_t m_eVarType = 0xF; // FuseVariableType_t
    constexpr std::ptrdiff_t m_eAccess = 0x10; // FuseVariableAccess_t
}
```

`HPCS2/offset/scenesystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:51 +0000
 */

#pragma once

#include <cstddef>

namespace CSSDSEndFrameViewInfo {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_ViewName = 0x8; // CUtlString
}

namespace CSSDSMsg_EndFrame {
    constexpr std::ptrdiff_t m_Views = 0x0; // CUtlVector<CSSDSEndFrameViewInfo>
}

namespace CSSDSMsg_LayerBase {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_nLayerIndex = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nLayerId = 0x20; // uint64_t
    constexpr std::ptrdiff_t m_LayerName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_displayText = 0x30; // CUtlString
}

namespace CSSDSMsg_PostLayer { // CSSDSMsg_LayerBase
}

namespace CSSDSMsg_PreLayer { // CSSDSMsg_LayerBase
}

namespace CSSDSMsg_ViewRender {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
}

namespace CSSDSMsg_ViewTarget {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_TextureId = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nWidth = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nHeight = 0x14; // int32_t
    constexpr std::ptrdiff_t m_nRequestedWidth = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nRequestedHeight = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_nNumMipLevels = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nDepth = 0x24; // int32_t
    constexpr std::ptrdiff_t m_nMultisampleNumSamples = 0x28; // int32_t
    constexpr std::ptrdiff_t m_nFormat = 0x2C; // int32_t
}

namespace CSSDSMsg_ViewTargetList {
    constexpr std::ptrdiff_t m_viewId = 0x0; // SceneViewId_t
    constexpr std::ptrdiff_t m_ViewName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_Targets = 0x18; // CUtlVector<CSSDSMsg_ViewTarget>
}

namespace SceneViewId_t {
    constexpr std::ptrdiff_t m_nViewId = 0x0; // uint64_t
    constexpr std::ptrdiff_t m_nFrameCount = 0x8; // uint64_t
}
```

`HPCS2/offset/schemasystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace CExampleSchemaVData_Monomorphic {
    constexpr std::ptrdiff_t m_nExample1 = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nExample2 = 0x4; // int32_t
}

namespace CExampleSchemaVData_PolymorphicBase {
    constexpr std::ptrdiff_t m_nBase = 0x8; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedA { // CExampleSchemaVData_PolymorphicBase
    constexpr std::ptrdiff_t m_nDerivedA = 0x10; // int32_t
}

namespace CExampleSchemaVData_PolymorphicDerivedB { // CExampleSchemaVData_PolymorphicBase
    constexpr std::ptrdiff_t m_nDerivedB = 0x10; // int32_t
}

namespace CSchemaSystemInternalRegistration {
    constexpr std::ptrdiff_t m_Vector2D = 0x0; // Vector2D
    constexpr std::ptrdiff_t m_Vector = 0x8; // Vector
    constexpr std::ptrdiff_t m_VectorAligned = 0x20; // VectorAligned
    constexpr std::ptrdiff_t m_Quaternion = 0x30; // Quaternion
    constexpr std::ptrdiff_t m_QAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_RotationVector = 0x4C; // RotationVector
    constexpr std::ptrdiff_t m_RadianEuler = 0x58; // RadianEuler
    constexpr std::ptrdiff_t m_DegreeEuler = 0x64; // DegreeEuler
    constexpr std::ptrdiff_t m_QuaternionStorage = 0x70; // QuaternionStorage
    constexpr std::ptrdiff_t m_matrix3x4_t = 0x80; // matrix3x4_t
    constexpr std::ptrdiff_t m_matrix3x4a_t = 0xB0; // matrix3x4a_t
    constexpr std::ptrdiff_t m_Color = 0xE0; // Color
    constexpr std::ptrdiff_t m_Vector4D = 0xE4; // Vector4D
    constexpr std::ptrdiff_t m_CTransform = 0x100; // CTransform
    constexpr std::ptrdiff_t m_pKeyValues = 0x120; // KeyValues*
    constexpr std::ptrdiff_t m_CUtlBinaryBlock = 0x128; // CUtlBinaryBlock
    constexpr std::ptrdiff_t m_CUtlString = 0x140; // CUtlString
    constexpr std::ptrdiff_t m_CUtlSymbol = 0x148; // CUtlSymbol
    constexpr std::ptrdiff_t m_stringToken = 0x14C; // CUtlStringToken
    constexpr std::ptrdiff_t m_stringTokenWithStorage = 0x150; // CUtlStringTokenWithStorage
    constexpr std::ptrdiff_t m_ResourceTypes = 0x168; // CResourceArray<CResourcePointer<CResourceString>>
    constexpr std::ptrdiff_t m_KV3 = 0x170; // KeyValues3
}

namespace InfoForResourceTypeCResourceManifestInternal {
}

namespace ResourceId_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint64_t
}
```

`HPCS2/offset/server.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:51 +0000
 */

#pragma once

#include <cstddef>

namespace ActiveModelConfig_t {
    constexpr std::ptrdiff_t m_Handle = 0x28; // ModelConfigHandle_t
    constexpr std::ptrdiff_t m_Name = 0x30; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AssociatedEntities = 0x38; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_AssociatedEntityNames = 0x50; // CNetworkUtlVectorBase<CUtlSymbolLarge>
}

namespace AmmoIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int8_t
}

namespace AmmoTypeInfo_t {
    constexpr std::ptrdiff_t m_nMaxCarry = 0x10; // int32_t
    constexpr std::ptrdiff_t m_nSplashSize = 0x1C; // CRangeInt
    constexpr std::ptrdiff_t m_nFlags = 0x24; // AmmoFlags_t
    constexpr std::ptrdiff_t m_flMass = 0x28; // float
    constexpr std::ptrdiff_t m_flSpeed = 0x2C; // CRangeFloat
}

namespace AnimationUpdateListHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace CAISound { // CPointEntity
    constexpr std::ptrdiff_t m_iSoundType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iSoundContext = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_iVolume = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_iSoundIndex = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszProxyEntityName = 0x4C8; // CUtlSymbolLarge
}

namespace CAI_ChangeHintGroup { // CBaseEntity
    constexpr std::ptrdiff_t m_iSearchType = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_strSearchName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strNewHintGroup = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
}

namespace CAI_ChangeTarget { // CBaseEntity
    constexpr std::ptrdiff_t m_iszNewTarget = 0x4B0; // CUtlSymbolLarge
}

namespace CAI_Expresser {
    constexpr std::ptrdiff_t m_flStopTalkTime = 0x38; // GameTime_t
    constexpr std::ptrdiff_t m_flStopTalkTimeWithoutDelay = 0x3C; // GameTime_t
    constexpr std::ptrdiff_t m_flBlockedTalkTime = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_voicePitch = 0x44; // int32_t
    constexpr std::ptrdiff_t m_flLastTimeAcceptedSpeak = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_bAllowSpeakingInterrupts = 0x4C; // bool
    constexpr std::ptrdiff_t m_bConsiderSceneInvolvementAsSpeech = 0x4D; // bool
    constexpr std::ptrdiff_t m_nLastSpokenPriority = 0x50; // int32_t
    constexpr std::ptrdiff_t m_pOuter = 0x58; // CBaseFlex*
}

namespace CAI_ExpresserWithFollowup { // CAI_Expresser
    constexpr std::ptrdiff_t m_pPostponedFollowup = 0x60; // ResponseFollowup*
}

namespace CAK47 { // CCSWeaponBaseGun
}

namespace CAmbientGeneric { // CPointEntity
    constexpr std::ptrdiff_t m_radius = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMaxRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iSoundLevel = 0x4B8; // soundlevel_t
    constexpr std::ptrdiff_t m_dpv = 0x4BC; // dynpitchvol_t
    constexpr std::ptrdiff_t m_fActive = 0x520; // bool
    constexpr std::ptrdiff_t m_fLooping = 0x521; // bool
    constexpr std::ptrdiff_t m_iszSound = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sSourceEntName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSoundSource = 0x538; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundSourceEntIndex = 0x53C; // CEntityIndex
}

namespace CAnimEventListener { // CAnimEventListenerBase
}

namespace CAnimEventListenerBase {
}

namespace CAnimEventQueueListener { // CAnimEventListenerBase
}

namespace CAnimGraphControllerBase {
}

namespace CAnimGraphNetworkedVariables {
    constexpr std::ptrdiff_t m_PredNetBoolVariables = 0x8; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetByteVariables = 0x20; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_PredNetUInt16Variables = 0x38; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_PredNetIntVariables = 0x50; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_PredNetUInt32Variables = 0x68; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_PredNetUInt64Variables = 0x80; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_PredNetFloatVariables = 0x98; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_PredNetVectorVariables = 0xB0; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PredNetQuaternionVariables = 0xC8; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetBoolVariables = 0xE0; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetByteVariables = 0xF8; // CNetworkUtlVectorBase<uint8_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt16Variables = 0x110; // CNetworkUtlVectorBase<uint16_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetIntVariables = 0x128; // CNetworkUtlVectorBase<int32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt32Variables = 0x140; // CNetworkUtlVectorBase<uint32_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetUInt64Variables = 0x158; // CNetworkUtlVectorBase<uint64_t>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetFloatVariables = 0x170; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetVectorVariables = 0x188; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_OwnerOnlyPredNetQuaternionVariables = 0x1A0; // CNetworkUtlVectorBase<Quaternion>
    constexpr std::ptrdiff_t m_nBoolVariablesCount = 0x1B8; // int32_t
    constexpr std::ptrdiff_t m_nOwnerOnlyBoolVariablesCount = 0x1BC; // int32_t
    constexpr std::ptrdiff_t m_nRandomSeedOffset = 0x1C0; // int32_t
    constexpr std::ptrdiff_t m_flLastTeleportTime = 0x1C4; // float
}

namespace CAnimGraphTagRef {
    constexpr std::ptrdiff_t m_nTagIndex = 0x0; // int32_t
    constexpr std::ptrdiff_t m_tagName = 0x10; // CGlobalSymbol
}

namespace CAttributeContainer { // CAttributeManager
    constexpr std::ptrdiff_t m_Item = 0x50; // CEconItemView
}

namespace CAttributeList {
    constexpr std::ptrdiff_t m_Attributes = 0x8; // CUtlVectorEmbeddedNetworkVar<CEconItemAttribute>
    constexpr std::ptrdiff_t m_pManager = 0x58; // CAttributeManager*
}

namespace CAttributeManager {
    constexpr std::ptrdiff_t m_Providers = 0x8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_iReapplyProvisionParity = 0x20; // int32_t
    constexpr std::ptrdiff_t m_hOuter = 0x24; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventLoopback = 0x28; // bool
    constexpr std::ptrdiff_t m_ProviderType = 0x2C; // attributeprovidertypes_t
    constexpr std::ptrdiff_t m_CachedResults = 0x30; // CUtlVector<CAttributeManager::cached_attribute_float_t>
}

namespace CAttributeManager_cached_attribute_float_t {
    constexpr std::ptrdiff_t flIn = 0x0; // float
    constexpr std::ptrdiff_t iAttribHook = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flOut = 0x10; // float
}

namespace CBarnLight { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nColorMode = 0x704; // int32_t
    constexpr std::ptrdiff_t m_Color = 0x708; // Color
    constexpr std::ptrdiff_t m_flColorTemperature = 0x70C; // float
    constexpr std::ptrdiff_t m_flBrightness = 0x710; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_nDirectLight = 0x718; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_nLuminaireShape = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flLuminaireSize = 0x724; // float
    constexpr std::ptrdiff_t m_flLuminaireAnisotropy = 0x728; // float
    constexpr std::ptrdiff_t m_LightStyleString = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x738; // GameTime_t
    constexpr std::ptrdiff_t m_QueuedLightStyleStrings = 0x740; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleEvents = 0x758; // CNetworkUtlVectorBase<CUtlString>
    constexpr std::ptrdiff_t m_LightStyleTargets = 0x770; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_StyleEvent = 0x788; // CEntityIOOutput[4]
    constexpr std::ptrdiff_t m_hLightCookie = 0x848; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flShape = 0x850; // float
    constexpr std::ptrdiff_t m_flSoftX = 0x854; // float
    constexpr std::ptrdiff_t m_flSoftY = 0x858; // float
    constexpr std::ptrdiff_t m_flSkirt = 0x85C; // float
    constexpr std::ptrdiff_t m_flSkirtNear = 0x860; // float
    constexpr std::ptrdiff_t m_vSizeParams = 0x864; // Vector
    constexpr std::ptrdiff_t m_flRange = 0x870; // float
    constexpr std::ptrdiff_t m_vShear = 0x874; // Vector
    constexpr std::ptrdiff_t m_nBakeSpecularToCubemaps = 0x880; // int32_t
    constexpr std::ptrdiff_t m_vBakeSpecularToCubemapsSize = 0x884; // Vector
    constexpr std::ptrdiff_t m_nCastShadows = 0x890; // int32_t
    constexpr std::ptrdiff_t m_nShadowMapSize = 0x894; // int32_t
    constexpr std::ptrdiff_t m_nShadowPriority = 0x898; // int32_t
    constexpr std::ptrdiff_t m_bContactShadow = 0x89C; // bool
    constexpr std::ptrdiff_t m_nBounceLight = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_flBounceScale = 0x8A4; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x8A8; // float
    constexpr std::ptrdiff_t m_vAlternateColor = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_fAlternateColorBrightness = 0x8B8; // float
    constexpr std::ptrdiff_t m_nFog = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_flFogStrength = 0x8C0; // float
    constexpr std::ptrdiff_t m_nFogShadows = 0x8C4; // int32_t
    constexpr std::ptrdiff_t m_flFogScale = 0x8C8; // float
    constexpr std::ptrdiff_t m_flFadeSizeStart = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFadeSizeEnd = 0x8D0; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeStart = 0x8D4; // float
    constexpr std::ptrdiff_t m_flShadowFadeSizeEnd = 0x8D8; // float
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x8DC; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x8E0; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x8EC; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x904; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x910; // Vector
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x91C; // bool
}

namespace CBaseAnimGraph { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bInitiallyPopulateInterpHistory = 0x700; // bool
    constexpr std::ptrdiff_t m_bShouldAnimateDuringGameplayPause = 0x701; // bool
    constexpr std::ptrdiff_t m_pChoreoServices = 0x708; // IChoreoServices*
    constexpr std::ptrdiff_t m_bAnimGraphUpdateEnabled = 0x710; // bool
    constexpr std::ptrdiff_t m_flMaxSlopeDistance = 0x714; // float
    constexpr std::ptrdiff_t m_vLastSlopeCheckPos = 0x718; // Vector
    constexpr std::ptrdiff_t m_bAnimGraphDirty = 0x724; // bool
    constexpr std::ptrdiff_t m_vecForce = 0x728; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0x734; // int32_t
    constexpr std::ptrdiff_t m_pRagdollPose = 0x748; // PhysicsRagdollPose_t*
    constexpr std::ptrdiff_t m_bClientRagdoll = 0x750; // bool
}

namespace CBaseAnimGraphController { // CSkeletonAnimationController
    constexpr std::ptrdiff_t m_baseLayer = 0x18; // CNetworkedSequenceOperation
    constexpr std::ptrdiff_t m_animGraphNetworkedVars = 0x40; // CAnimGraphNetworkedVariables
    constexpr std::ptrdiff_t m_bSequenceFinished = 0x218; // bool
    constexpr std::ptrdiff_t m_flLastEventCycle = 0x21C; // float
    constexpr std::ptrdiff_t m_flLastEventAnimTime = 0x220; // float
    constexpr std::ptrdiff_t m_flPlaybackRate = 0x224; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_flPrevAnimTime = 0x22C; // float
    constexpr std::ptrdiff_t m_bClientSideAnimation = 0x230; // bool
    constexpr std::ptrdiff_t m_bNetworkedAnimationInputsChanged = 0x231; // bool
    constexpr std::ptrdiff_t m_nNewSequenceParity = 0x234; // int32_t
    constexpr std::ptrdiff_t m_nResetEventsParity = 0x238; // int32_t
    constexpr std::ptrdiff_t m_nAnimLoopMode = 0x23C; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_hAnimationUpdate = 0x2DC; // AnimationUpdateListHandle_t
}

namespace CBaseButton { // CBaseToggle
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x780; // QAngle
    constexpr std::ptrdiff_t m_fStayPushed = 0x78C; // bool
    constexpr std::ptrdiff_t m_fRotating = 0x78D; // bool
    constexpr std::ptrdiff_t m_ls = 0x790; // locksound_t
    constexpr std::ptrdiff_t m_sUseSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sLockedSound = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sUnlockedSound = 0x7C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bLocked = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x7C9; // bool
    constexpr std::ptrdiff_t m_flUseLockedTime = 0x7CC; // GameTime_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x7D0; // bool
    constexpr std::ptrdiff_t m_OnDamaged = 0x7D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPressed = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUseLocked = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnIn = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOut = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nState = 0x8A0; // int32_t
    constexpr std::ptrdiff_t m_hConstraint = 0x8A4; // CEntityHandle
    constexpr std::ptrdiff_t m_hConstraintParent = 0x8A8; // CEntityHandle
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0x8AC; // bool
    constexpr std::ptrdiff_t m_sGlowEntity = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_glowEntity = 0x8B8; // CHandle<CBaseModelEntity>
    constexpr std::ptrdiff_t m_usable = 0x8BC; // bool
    constexpr std::ptrdiff_t m_szDisplayText = 0x8C0; // CUtlSymbolLarge
}

namespace CBaseCSGrenade { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bRedraw = 0xE20; // bool
    constexpr std::ptrdiff_t m_bIsHeldByPlayer = 0xE21; // bool
    constexpr std::ptrdiff_t m_bPinPulled = 0xE22; // bool
    constexpr std::ptrdiff_t m_bJumpThrow = 0xE23; // bool
    constexpr std::ptrdiff_t m_eThrowStatus = 0xE24; // EGrenadeThrowState
    constexpr std::ptrdiff_t m_fThrowTime = 0xE28; // GameTime_t
    constexpr std::ptrdiff_t m_flThrowStrength = 0xE2C; // float
    constexpr std::ptrdiff_t m_flThrowStrengthApproach = 0xE30; // float
    constexpr std::ptrdiff_t m_fDropTime = 0xE34; // GameTime_t
}

namespace CBaseCSGrenadeProjectile { // CBaseGrenade
    constexpr std::ptrdiff_t m_vInitialPosition = 0x9C8; // Vector
    constexpr std::ptrdiff_t m_vInitialVelocity = 0x9D4; // Vector
    constexpr std::ptrdiff_t m_nBounces = 0x9E0; // int32_t
    constexpr std::ptrdiff_t m_nExplodeEffectIndex = 0x9E8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nExplodeEffectTickBegin = 0x9F0; // int32_t
    constexpr std::ptrdiff_t m_vecExplodeEffectOrigin = 0x9F4; // Vector
    constexpr std::ptrdiff_t m_flSpawnTime = 0xA00; // GameTime_t
    constexpr std::ptrdiff_t m_unOGSExtraFlags = 0xA04; // uint8_t
    constexpr std::ptrdiff_t m_bDetonationRecorded = 0xA05; // bool
    constexpr std::ptrdiff_t m_flDetonateTime = 0xA08; // GameTime_t
    constexpr std::ptrdiff_t m_nItemIndex = 0xA0C; // uint16_t
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0xA10; // Vector
    constexpr std::ptrdiff_t m_flLastBounceSoundTime = 0xA1C; // GameTime_t
    constexpr std::ptrdiff_t m_vecGrenadeSpin = 0xA20; // RotationVector
    constexpr std::ptrdiff_t m_vecLastHitSurfaceNormal = 0xA2C; // Vector
    constexpr std::ptrdiff_t m_nTicksAtZeroVelocity = 0xA38; // int32_t
    constexpr std::ptrdiff_t m_bHasEverHitPlayer = 0xA3C; // bool
    constexpr std::ptrdiff_t m_bClearFromPlayers = 0xA3D; // bool
}

namespace CBaseClientUIEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
    constexpr std::ptrdiff_t m_DialogXMLName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelClassName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PanelID = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_CustomOutput0 = 0x720; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput1 = 0x748; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput2 = 0x770; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput3 = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput4 = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput5 = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput6 = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput7 = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput8 = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_CustomOutput9 = 0x888; // CEntityIOOutput
}

namespace CBaseCombatCharacter { // CBaseFlex
    constexpr std::ptrdiff_t m_bForceServerRagdoll = 0x920; // bool
    constexpr std::ptrdiff_t m_hMyWearables = 0x928; // CNetworkUtlVectorBase<CHandle<CEconWearable>>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x940; // float
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x944; // float
    constexpr std::ptrdiff_t m_LastHitGroup = 0x948; // HitGroup_t
    constexpr std::ptrdiff_t m_bApplyStressDamage = 0x94C; // bool
    constexpr std::ptrdiff_t m_bloodColor = 0x950; // int32_t
    constexpr std::ptrdiff_t m_navMeshID = 0x9B0; // int32_t
    constexpr std::ptrdiff_t m_iDamageCount = 0x9B4; // int32_t
    constexpr std::ptrdiff_t m_pVecRelationships = 0x9B8; // CUtlVector<RelationshipOverride_t>*
    constexpr std::ptrdiff_t m_strRelationships = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_eHull = 0x9C8; // Hull_t
    constexpr std::ptrdiff_t m_nNavHullIdx = 0x9CC; // uint32_t
}

namespace CBaseDMStart { // CPointEntity
    constexpr std::ptrdiff_t m_Master = 0x4B0; // CUtlSymbolLarge
}

namespace CBaseDoor { // CBaseToggle
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x790; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x79C; // Vector
    constexpr std::ptrdiff_t m_ls = 0x7A8; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0x7C8; // bool
    constexpr std::ptrdiff_t m_bDoorGroup = 0x7C9; // bool
    constexpr std::ptrdiff_t m_bLocked = 0x7CA; // bool
    constexpr std::ptrdiff_t m_bIgnoreDebris = 0x7CB; // bool
    constexpr std::ptrdiff_t m_eSpawnPosition = 0x7CC; // FuncDoorSpawnPos_t
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7D0; // float
    constexpr std::ptrdiff_t m_NoiseMoving = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseMovingClosed = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrivedClosed = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ChainTarget = 0x7F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0x800; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0x850; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0x878; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bLoopMoveSound = 0x968; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x980; // bool
    constexpr std::ptrdiff_t m_isChaining = 0x981; // bool
    constexpr std::ptrdiff_t m_bIsUsable = 0x982; // bool
}

namespace CBaseEntity { // CEntityInstance
    constexpr std::ptrdiff_t m_CBodyComponent = 0x30; // CBodyComponent*
    constexpr std::ptrdiff_t m_NetworkTransmitComponent = 0x38; // CNetworkTransmitComponent
    constexpr std::ptrdiff_t m_aThinkFunctions = 0x228; // CUtlVector<thinkfunc_t>
    constexpr std::ptrdiff_t m_iCurrentThinkContext = 0x240; // int32_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x244; // GameTick_t
    constexpr std::ptrdiff_t m_isSteadyState = 0x250; // CBitVec<64>
    constexpr std::ptrdiff_t m_lastNetworkChange = 0x258; // float
    constexpr std::ptrdiff_t m_ResponseContexts = 0x268; // CUtlVector<ResponseContext_t>
    constexpr std::ptrdiff_t m_iszResponseContext = 0x280; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iHealth = 0x2A8; // int32_t
    constexpr std::ptrdiff_t m_iMaxHealth = 0x2AC; // int32_t
    constexpr std::ptrdiff_t m_lifeState = 0x2B0; // uint8_t
    constexpr std::ptrdiff_t m_flDamageAccumulator = 0x2B4; // float
    constexpr std::ptrdiff_t m_bTakesDamage = 0x2B8; // bool
    constexpr std::ptrdiff_t m_nTakeDamageFlags = 0x2BC; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_MoveCollide = 0x2C1; // MoveCollide_t
    constexpr std::ptrdiff_t m_MoveType = 0x2C2; // MoveType_t
    constexpr std::ptrdiff_t m_nWaterTouch = 0x2C3; // uint8_t
    constexpr std::ptrdiff_t m_nSlimeTouch = 0x2C4; // uint8_t
    constexpr std::ptrdiff_t m_bRestoreInHierarchy = 0x2C5; // bool
    constexpr std::ptrdiff_t m_target = 0x2C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveDoneTime = 0x2D0; // float
    constexpr std::ptrdiff_t m_hDamageFilter = 0x2D4; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iszDamageFilterName = 0x2D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nSubclassID = 0x2E0; // CUtlStringToken
    constexpr std::ptrdiff_t m_flAnimTime = 0x2F0; // float
    constexpr std::ptrdiff_t m_flSimulationTime = 0x2F4; // float
    constexpr std::ptrdiff_t m_flCreateTime = 0x2F8; // GameTime_t
    constexpr std::ptrdiff_t m_bClientSideRagdoll = 0x2FC; // bool
    constexpr std::ptrdiff_t m_ubInterpolationFrame = 0x2FD; // uint8_t
    constexpr std::ptrdiff_t m_vPrevVPhysicsUpdatePos = 0x300; // Vector
    constexpr std::ptrdiff_t m_iTeamNum = 0x30C; // uint8_t
    constexpr std::ptrdiff_t m_iGlobalname = 0x310; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iSentToClients = 0x318; // int32_t
    constexpr std::ptrdiff_t m_flSpeed = 0x31C; // float
    constexpr std::ptrdiff_t m_sUniqueHammerID = 0x320; // CUtlString
    constexpr std::ptrdiff_t m_spawnflags = 0x328; // uint32_t
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x32C; // GameTick_t
    constexpr std::ptrdiff_t m_nSimulationTick = 0x330; // int32_t
    constexpr std::ptrdiff_t m_OnKilled = 0x338; // CEntityIOOutput
    constexpr std::ptrdiff_t m_fFlags = 0x360; // uint32_t
    constexpr std::ptrdiff_t m_vecAbsVelocity = 0x364; // Vector
    constexpr std::ptrdiff_t m_vecVelocity = 0x370; // CNetworkVelocityVector
    constexpr std::ptrdiff_t m_vecBaseVelocity = 0x3A0; // Vector
    constexpr std::ptrdiff_t m_nPushEnumCount = 0x3AC; // int32_t
    constexpr std::ptrdiff_t m_pCollision = 0x3B0; // CCollisionProperty*
    constexpr std::ptrdiff_t m_hEffectEntity = 0x3B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hOwnerEntity = 0x3BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_fEffects = 0x3C0; // uint32_t
    constexpr std::ptrdiff_t m_hGroundEntity = 0x3C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFriction = 0x3C8; // float
    constexpr std::ptrdiff_t m_flElasticity = 0x3CC; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0x3D0; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x3D4; // float
    constexpr std::ptrdiff_t m_flWaterLevel = 0x3D8; // float
    constexpr std::ptrdiff_t m_bSimulatedEveryTick = 0x3DC; // bool
    constexpr std::ptrdiff_t m_bAnimatedEveryTick = 0x3DD; // bool
    constexpr std::ptrdiff_t m_bDisableLowViolence = 0x3DE; // bool
    constexpr std::ptrdiff_t m_nWaterType = 0x3DF; // uint8_t
    constexpr std::ptrdiff_t m_iEFlags = 0x3E0; // int32_t
    constexpr std::ptrdiff_t m_OnUser1 = 0x3E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser2 = 0x410; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser3 = 0x438; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUser4 = 0x460; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInitialTeamNum = 0x488; // int32_t
    constexpr std::ptrdiff_t m_flNavIgnoreUntilTime = 0x48C; // GameTime_t
    constexpr std::ptrdiff_t m_vecAngVelocity = 0x490; // QAngle
    constexpr std::ptrdiff_t m_bNetworkQuantizeOriginAndAngles = 0x49C; // bool
    constexpr std::ptrdiff_t m_bLagCompensate = 0x49D; // bool
    constexpr std::ptrdiff_t m_flOverriddenFriction = 0x4A0; // float
    constexpr std::ptrdiff_t m_pBlocker = 0x4A4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLocalTime = 0x4A8; // float
    constexpr std::ptrdiff_t m_flVPhysicsUpdateLocalTime = 0x4AC; // float
}

namespace CBaseFilter { // CLogicalEntity
    constexpr std::ptrdiff_t m_bNegated = 0x4B0; // bool
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFail = 0x4E0; // CEntityIOOutput
}

namespace CBaseFire { // CBaseEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x4B4; // float
    constexpr std::ptrdiff_t m_flScaleTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_nFlags = 0x4BC; // uint32_t
}

namespace CBaseFlex { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_flexWeight = 0x890; // CNetworkUtlVectorBase<float>
    constexpr std::ptrdiff_t m_vLookTargetPosition = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_blinktoggle = 0x8B4; // bool
    constexpr std::ptrdiff_t m_flAllowResponsesEndTime = 0x908; // GameTime_t
    constexpr std::ptrdiff_t m_flLastFlexAnimationTime = 0x90C; // GameTime_t
    constexpr std::ptrdiff_t m_nNextSceneEventId = 0x910; // uint32_t
    constexpr std::ptrdiff_t m_bUpdateLayerPriorities = 0x914; // bool
}

namespace CBaseFlexAlias_funCBaseFlex { // CBaseFlex
}

namespace CBaseGrenade { // CBaseFlex
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x928; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExplode = 0x950; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bHasWarnedAI = 0x978; // bool
    constexpr std::ptrdiff_t m_bIsSmokeGrenade = 0x979; // bool
    constexpr std::ptrdiff_t m_bIsLive = 0x97A; // bool
    constexpr std::ptrdiff_t m_DmgRadius = 0x97C; // float
    constexpr std::ptrdiff_t m_flDetonateTime = 0x980; // GameTime_t
    constexpr std::ptrdiff_t m_flWarnAITime = 0x984; // float
    constexpr std::ptrdiff_t m_flDamage = 0x988; // float
    constexpr std::ptrdiff_t m_iszBounceSound = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_ExplosionSound = 0x998; // CUtlString
    constexpr std::ptrdiff_t m_hThrower = 0x9A4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_flNextAttack = 0x9BC; // GameTime_t
    constexpr std::ptrdiff_t m_hOriginalThrower = 0x9C0; // CHandle<CCSPlayerPawn>
}

namespace CBaseIssue {
    constexpr std::ptrdiff_t m_szTypeString = 0x20; // char[64]
    constexpr std::ptrdiff_t m_szDetailsString = 0x60; // char[260]
    constexpr std::ptrdiff_t m_iNumYesVotes = 0x164; // int32_t
    constexpr std::ptrdiff_t m_iNumNoVotes = 0x168; // int32_t
    constexpr std::ptrdiff_t m_iNumPotentialVotes = 0x16C; // int32_t
    constexpr std::ptrdiff_t m_pVoteController = 0x170; // CVoteController*
}

namespace CBaseModelEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_CRenderComponent = 0x4B0; // CRenderComponent*
    constexpr std::ptrdiff_t m_CHitboxComponent = 0x4B8; // CHitboxComponent
    constexpr std::ptrdiff_t m_flDissolveStartTime = 0x4E0; // GameTime_t
    constexpr std::ptrdiff_t m_OnIgnite = 0x4E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nRenderMode = 0x510; // RenderMode_t
    constexpr std::ptrdiff_t m_nRenderFX = 0x511; // RenderFx_t
    constexpr std::ptrdiff_t m_bAllowFadeInView = 0x512; // bool
    constexpr std::ptrdiff_t m_clrRender = 0x513; // Color
    constexpr std::ptrdiff_t m_vecRenderAttributes = 0x518; // CUtlVectorEmbeddedNetworkVar<EntityRenderAttribute_t>
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x568; // bool
    constexpr std::ptrdiff_t m_Collision = 0x570; // CCollisionProperty
    constexpr std::ptrdiff_t m_Glow = 0x620; // CGlowProperty
    constexpr std::ptrdiff_t m_flGlowBackfaceMult = 0x678; // float
    constexpr std::ptrdiff_t m_fadeMinDist = 0x67C; // float
    constexpr std::ptrdiff_t m_fadeMaxDist = 0x680; // float
    constexpr std::ptrdiff_t m_flFadeScale = 0x684; // float
    constexpr std::ptrdiff_t m_flShadowStrength = 0x688; // float
    constexpr std::ptrdiff_t m_nObjectCulling = 0x68C; // uint8_t
    constexpr std::ptrdiff_t m_nAddDecal = 0x690; // int32_t
    constexpr std::ptrdiff_t m_vDecalPosition = 0x694; // Vector
    constexpr std::ptrdiff_t m_vDecalForwardAxis = 0x6A0; // Vector
    constexpr std::ptrdiff_t m_flDecalHealBloodRate = 0x6AC; // float
    constexpr std::ptrdiff_t m_flDecalHealHeightRate = 0x6B0; // float
    constexpr std::ptrdiff_t m_ConfigEntitiesToPropagateMaterialDecalsTo = 0x6B8; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_vecViewOffset = 0x6D0; // CNetworkViewOffsetVector
}

namespace CBaseMoveBehavior { // CPathKeyFrame
    constexpr std::ptrdiff_t m_iPositionInterpolator = 0x510; // int32_t
    constexpr std::ptrdiff_t m_iRotationInterpolator = 0x514; // int32_t
    constexpr std::ptrdiff_t m_flAnimStartTime = 0x518; // float
    constexpr std::ptrdiff_t m_flAnimEndTime = 0x51C; // float
    constexpr std::ptrdiff_t m_flAverageSpeedAcrossFrame = 0x520; // float
    constexpr std::ptrdiff_t m_pCurrentKeyFrame = 0x528; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pTargetKeyFrame = 0x530; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPreKeyFrame = 0x538; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPostKeyFrame = 0x540; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flTimeIntoFrame = 0x548; // float
    constexpr std::ptrdiff_t m_iDirection = 0x54C; // int32_t
}

namespace CBasePlatTrain { // CBaseToggle
    constexpr std::ptrdiff_t m_NoiseMoving = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_NoiseArrived = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_volume = 0x798; // float
    constexpr std::ptrdiff_t m_flTWidth = 0x79C; // float
    constexpr std::ptrdiff_t m_flTLength = 0x7A0; // float
}

namespace CBasePlayerController { // CBaseEntity
    constexpr std::ptrdiff_t m_nInButtonsWhichAreToggles = 0x4B8; // uint64_t
    constexpr std::ptrdiff_t m_nTickBase = 0x4C0; // uint32_t
    constexpr std::ptrdiff_t m_hPawn = 0x4F0; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_nSplitScreenSlot = 0x4F4; // CSplitScreenSlot
    constexpr std::ptrdiff_t m_hSplitOwner = 0x4F8; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_hSplitScreenPlayers = 0x500; // CUtlVector<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_bIsHLTV = 0x518; // bool
    constexpr std::ptrdiff_t m_iConnected = 0x51C; // PlayerConnectedState
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // char[128]
    constexpr std::ptrdiff_t m_szNetworkIDString = 0x5A0; // CUtlString
    constexpr std::ptrdiff_t m_fLerpTime = 0x5A8; // float
    constexpr std::ptrdiff_t m_bLagCompensation = 0x5AC; // bool
    constexpr std::ptrdiff_t m_bPredict = 0x5AD; // bool
    constexpr std::ptrdiff_t m_bAutoKickDisabled = 0x5AE; // bool
    constexpr std::ptrdiff_t m_bIsLowViolence = 0x5AF; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0x5B0; // bool
    constexpr std::ptrdiff_t m_nUsecTimestampLastUserCmdReceived = 0x648; // int64_t
    constexpr std::ptrdiff_t m_iIgnoreGlobalChat = 0x660; // ChatIgnoreType_t
    constexpr std::ptrdiff_t m_flLastPlayerTalkTime = 0x664; // float
    constexpr std::ptrdiff_t m_flLastEntitySteadyState = 0x668; // float
    constexpr std::ptrdiff_t m_nAvailableEntitySteadyState = 0x66C; // int32_t
    constexpr std::ptrdiff_t m_bHasAnySteadyStateEnts = 0x670; // bool
    constexpr std::ptrdiff_t m_steamID = 0x680; // uint64_t
    constexpr std::ptrdiff_t m_iDesiredFOV = 0x688; // uint32_t
}

namespace CBasePlayerPawn { // CBaseCombatCharacter
    constexpr std::ptrdiff_t m_pWeaponServices = 0x9D0; // CPlayer_WeaponServices*
    constexpr std::ptrdiff_t m_pItemServices = 0x9D8; // CPlayer_ItemServices*
    constexpr std::ptrdiff_t m_pAutoaimServices = 0x9E0; // CPlayer_AutoaimServices*
    constexpr std::ptrdiff_t m_pObserverServices = 0x9E8; // CPlayer_ObserverServices*
    constexpr std::ptrdiff_t m_pWaterServices = 0x9F0; // CPlayer_WaterServices*
    constexpr std::ptrdiff_t m_pUseServices = 0x9F8; // CPlayer_UseServices*
    constexpr std::ptrdiff_t m_pFlashlightServices = 0xA00; // CPlayer_FlashlightServices*
    constexpr std::ptrdiff_t m_pCameraServices = 0xA08; // CPlayer_CameraServices*
    constexpr std::ptrdiff_t m_pMovementServices = 0xA10; // CPlayer_MovementServices*
    constexpr std::ptrdiff_t m_ServerViewAngleChanges = 0xA20; // CUtlVectorEmbeddedNetworkVar<ViewAngleServerChange_t>
    constexpr std::ptrdiff_t m_nHighestGeneratedServerViewAngleChangeIndex = 0xA70; // uint32_t
    constexpr std::ptrdiff_t v_angle = 0xA74; // QAngle
    constexpr std::ptrdiff_t v_anglePrevious = 0xA80; // QAngle
    constexpr std::ptrdiff_t m_iHideHUD = 0xA8C; // uint32_t
    constexpr std::ptrdiff_t m_skybox3d = 0xA90; // sky3dparams_t
    constexpr std::ptrdiff_t m_fTimeLastHurt = 0xB20; // GameTime_t
    constexpr std::ptrdiff_t m_flDeathTime = 0xB24; // GameTime_t
    constexpr std::ptrdiff_t m_fNextSuicideTime = 0xB28; // GameTime_t
    constexpr std::ptrdiff_t m_fInitHUD = 0xB2C; // bool
    constexpr std::ptrdiff_t m_pExpresser = 0xB30; // CAI_Expresser*
    constexpr std::ptrdiff_t m_hController = 0xB38; // CHandle<CBasePlayerController>
    constexpr std::ptrdiff_t m_fHltvReplayDelay = 0xB40; // float
    constexpr std::ptrdiff_t m_fHltvReplayEnd = 0xB44; // float
    constexpr std::ptrdiff_t m_iHltvReplayEntity = 0xB48; // CEntityIndex
}

namespace CBasePlayerVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_sModelName = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_flHeadDamageMultiplier = 0x108; // CSkillFloat
    constexpr std::ptrdiff_t m_flChestDamageMultiplier = 0x118; // CSkillFloat
    constexpr std::ptrdiff_t m_flStomachDamageMultiplier = 0x128; // CSkillFloat
    constexpr std::ptrdiff_t m_flArmDamageMultiplier = 0x138; // CSkillFloat
    constexpr std::ptrdiff_t m_flLegDamageMultiplier = 0x148; // CSkillFloat
    constexpr std::ptrdiff_t m_flHoldBreathTime = 0x158; // float
    constexpr std::ptrdiff_t m_flDrowningDamageInterval = 0x15C; // float
    constexpr std::ptrdiff_t m_nDrowningDamageInitial = 0x160; // int32_t
    constexpr std::ptrdiff_t m_nDrowningDamageMax = 0x164; // int32_t
    constexpr std::ptrdiff_t m_nWaterSpeed = 0x168; // int32_t
    constexpr std::ptrdiff_t m_flUseRange = 0x16C; // float
    constexpr std::ptrdiff_t m_flUseAngleTolerance = 0x170; // float
    constexpr std::ptrdiff_t m_flCrouchTime = 0x174; // float
}

namespace CBasePlayerWeapon { // CEconEntity
    constexpr std::ptrdiff_t m_nNextPrimaryAttackTick = 0xC18; // GameTick_t
    constexpr std::ptrdiff_t m_flNextPrimaryAttackTickRatio = 0xC1C; // float
    constexpr std::ptrdiff_t m_nNextSecondaryAttackTick = 0xC20; // GameTick_t
    constexpr std::ptrdiff_t m_flNextSecondaryAttackTickRatio = 0xC24; // float
    constexpr std::ptrdiff_t m_iClip1 = 0xC28; // int32_t
    constexpr std::ptrdiff_t m_iClip2 = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_pReserveAmmo = 0xC30; // int32_t[2]
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xC38; // CEntityIOOutput
}

namespace CBasePlayerWeaponVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szWorldModel = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_bBuiltRightHanded = 0x108; // bool
    constexpr std::ptrdiff_t m_bAllowFlipping = 0x109; // bool
    constexpr std::ptrdiff_t m_bIsFullAuto = 0x10A; // bool
    constexpr std::ptrdiff_t m_nNumBullets = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_sMuzzleAttachment = 0x110; // CUtlString
    constexpr std::ptrdiff_t m_szMuzzleFlashParticle = 0x118; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_iFlags = 0x1F8; // ItemFlagTypes_t
    constexpr std::ptrdiff_t m_nPrimaryAmmoType = 0x1F9; // AmmoIndex_t
    constexpr std::ptrdiff_t m_nSecondaryAmmoType = 0x1FA; // AmmoIndex_t
    constexpr std::ptrdiff_t m_iMaxClip1 = 0x1FC; // int32_t
    constexpr std::ptrdiff_t m_iMaxClip2 = 0x200; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip1 = 0x204; // int32_t
    constexpr std::ptrdiff_t m_iDefaultClip2 = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iWeight = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_bAutoSwitchTo = 0x210; // bool
    constexpr std::ptrdiff_t m_bAutoSwitchFrom = 0x211; // bool
    constexpr std::ptrdiff_t m_iRumbleEffect = 0x214; // RumbleEffect_t
    constexpr std::ptrdiff_t m_aShootSounds = 0x218; // CUtlMap<WeaponSound_t,CSoundEventName>
    constexpr std::ptrdiff_t m_iSlot = 0x238; // int32_t
    constexpr std::ptrdiff_t m_iPosition = 0x23C; // int32_t
}

namespace CBaseProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bModelOverrodeBlockLOS = 0x890; // bool
    constexpr std::ptrdiff_t m_iShapeType = 0x894; // int32_t
    constexpr std::ptrdiff_t m_bConformToCollisionBounds = 0x898; // bool
    constexpr std::ptrdiff_t m_mPreferredCatchTransform = 0x89C; // matrix3x4_t
}

namespace CBasePropDoor { // CDynamicProp
    constexpr std::ptrdiff_t m_flAutoReturnDelay = 0xB18; // float
    constexpr std::ptrdiff_t m_hDoorList = 0xB20; // CUtlVector<CHandle<CBasePropDoor>>
    constexpr std::ptrdiff_t m_nHardwareType = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_bNeedsHardware = 0xB3C; // bool
    constexpr std::ptrdiff_t m_eDoorState = 0xB40; // DoorState_t
    constexpr std::ptrdiff_t m_bLocked = 0xB44; // bool
    constexpr std::ptrdiff_t m_closedPosition = 0xB48; // Vector
    constexpr std::ptrdiff_t m_closedAngles = 0xB54; // QAngle
    constexpr std::ptrdiff_t m_hBlocker = 0xB60; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFirstBlocked = 0xB64; // bool
    constexpr std::ptrdiff_t m_ls = 0xB68; // locksound_t
    constexpr std::ptrdiff_t m_bForceClosed = 0xB88; // bool
    constexpr std::ptrdiff_t m_vecLatchWorldPosition = 0xB8C; // Vector
    constexpr std::ptrdiff_t m_hActivator = 0xB98; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_SoundMoving = 0xBA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundOpen = 0xBB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundClose = 0xBB8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLock = 0xBC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundUnlock = 0xBC8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLatch = 0xBD0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundPound = 0xBD8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundJiggle = 0xBE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_SoundLockedAnim = 0xBE8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_numCloseAttempts = 0xBF0; // int32_t
    constexpr std::ptrdiff_t m_nPhysicsMaterial = 0xBF4; // CUtlStringToken
    constexpr std::ptrdiff_t m_SlaveName = 0xBF8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMaster = 0xC00; // CHandle<CBasePropDoor>
    constexpr std::ptrdiff_t m_OnBlockedClosing = 0xC08; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBlockedOpening = 0xC30; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedClosing = 0xC58; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUnblockedOpening = 0xC80; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0xCA8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0xCD0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnClose = 0xCF8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOpen = 0xD20; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLockedUse = 0xD48; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAjarOpen = 0xD70; // CEntityIOOutput
}

namespace CBaseToggle { // CBaseModelEntity
    constexpr std::ptrdiff_t m_toggle_state = 0x700; // TOGGLE_STATE
    constexpr std::ptrdiff_t m_flMoveDistance = 0x704; // float
    constexpr std::ptrdiff_t m_flWait = 0x708; // float
    constexpr std::ptrdiff_t m_flLip = 0x70C; // float
    constexpr std::ptrdiff_t m_bAlwaysFireBlockedOutputs = 0x710; // bool
    constexpr std::ptrdiff_t m_vecPosition1 = 0x714; // Vector
    constexpr std::ptrdiff_t m_vecPosition2 = 0x720; // Vector
    constexpr std::ptrdiff_t m_vecMoveAng = 0x72C; // QAngle
    constexpr std::ptrdiff_t m_vecAngle1 = 0x738; // QAngle
    constexpr std::ptrdiff_t m_vecAngle2 = 0x744; // QAngle
    constexpr std::ptrdiff_t m_flHeight = 0x750; // float
    constexpr std::ptrdiff_t m_hActivator = 0x754; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecFinalDest = 0x758; // Vector
    constexpr std::ptrdiff_t m_vecFinalAngle = 0x764; // QAngle
    constexpr std::ptrdiff_t m_movementType = 0x770; // int32_t
    constexpr std::ptrdiff_t m_sMaster = 0x778; // CUtlSymbolLarge
}

namespace CBaseTrigger { // CBaseToggle
    constexpr std::ptrdiff_t m_bDisabled = 0x780; // bool
    constexpr std::ptrdiff_t m_iFilterName = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x790; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnStartTouch = 0x798; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouchAll = 0x7C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouchAll = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTouching = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotTouching = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hTouchingEntities = 0x888; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_bClientSidePredicted = 0x8A0; // bool
}

namespace CBaseViewModel { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_vecLastFacing = 0x898; // Vector
    constexpr std::ptrdiff_t m_nViewModelIndex = 0x8A4; // uint32_t
    constexpr std::ptrdiff_t m_nAnimationParity = 0x8A8; // uint32_t
    constexpr std::ptrdiff_t m_flAnimationStartTime = 0x8AC; // float
    constexpr std::ptrdiff_t m_hWeapon = 0x8B0; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_sVMName = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sAnimationPrefix = 0x8C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOldLayerSequence = 0x8C8; // HSequence
    constexpr std::ptrdiff_t m_oldLayer = 0x8CC; // int32_t
    constexpr std::ptrdiff_t m_oldLayerStartTime = 0x8D0; // float
    constexpr std::ptrdiff_t m_hControlPanel = 0x8D4; // CHandle<CBaseEntity>
}

namespace CBeam { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flFrameRate = 0x700; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x704; // float
    constexpr std::ptrdiff_t m_flFireTime = 0x708; // GameTime_t
    constexpr std::ptrdiff_t m_flDamage = 0x70C; // float
    constexpr std::ptrdiff_t m_nNumBeamEnts = 0x710; // uint8_t
    constexpr std::ptrdiff_t m_hBaseMaterial = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nHaloIndex = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nBeamType = 0x728; // BeamType_t
    constexpr std::ptrdiff_t m_nBeamFlags = 0x72C; // uint32_t
    constexpr std::ptrdiff_t m_hAttachEntity = 0x730; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nAttachIndex = 0x758; // AttachmentHandle_t[10]
    constexpr std::ptrdiff_t m_fWidth = 0x764; // float
    constexpr std::ptrdiff_t m_fEndWidth = 0x768; // float
    constexpr std::ptrdiff_t m_fFadeLength = 0x76C; // float
    constexpr std::ptrdiff_t m_fHaloScale = 0x770; // float
    constexpr std::ptrdiff_t m_fAmplitude = 0x774; // float
    constexpr std::ptrdiff_t m_fStartFrame = 0x778; // float
    constexpr std::ptrdiff_t m_fSpeed = 0x77C; // float
    constexpr std::ptrdiff_t m_flFrame = 0x780; // float
    constexpr std::ptrdiff_t m_nClipStyle = 0x784; // BeamClipStyle_t
    constexpr std::ptrdiff_t m_bTurnedOff = 0x788; // bool
    constexpr std::ptrdiff_t m_vecEndPos = 0x78C; // Vector
    constexpr std::ptrdiff_t m_hEndEntity = 0x798; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nDissolveType = 0x79C; // int32_t
}

namespace CBlood { // CPointEntity
    constexpr std::ptrdiff_t m_vecSprayAngles = 0x4B0; // QAngle
    constexpr std::ptrdiff_t m_vecSprayDir = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_flAmount = 0x4C8; // float
    constexpr std::ptrdiff_t m_Color = 0x4CC; // int32_t
}

namespace CBodyComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_pSceneNode = 0x8; // CGameSceneNode*
    constexpr std::ptrdiff_t __m_pChainEntity = 0x20; // CNetworkVarChainer
}

namespace CBodyComponentBaseAnimGraph { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t m_animationController = 0x480; // CBaseAnimGraphController
    constexpr std::ptrdiff_t __m_pChainEntity = 0x760; // CNetworkVarChainer
}

namespace CBodyComponentBaseModelEntity { // CBodyComponentSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x480; // CNetworkVarChainer
}

namespace CBodyComponentPoint { // CBodyComponent
    constexpr std::ptrdiff_t m_sceneNode = 0x50; // CGameSceneNode
    constexpr std::ptrdiff_t __m_pChainEntity = 0x1A0; // CNetworkVarChainer
}

namespace CBodyComponentSkeletonInstance { // CBodyComponent
    constexpr std::ptrdiff_t m_skeletonInstance = 0x50; // CSkeletonInstance
    constexpr std::ptrdiff_t __m_pChainEntity = 0x450; // CNetworkVarChainer
}

namespace CBombTarget { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnBombExplode = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombPlanted = 0x8D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsBombSiteB = 0x920; // bool
    constexpr std::ptrdiff_t m_bIsHeistBombTarget = 0x921; // bool
    constexpr std::ptrdiff_t m_bBombPlantedHere = 0x922; // bool
    constexpr std::ptrdiff_t m_szMountTarget = 0x928; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hInstructorHint = 0x930; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nBombSiteDesignation = 0x934; // int32_t
}

namespace CBot {
    constexpr std::ptrdiff_t m_pController = 0x10; // CCSPlayerController*
    constexpr std::ptrdiff_t m_pPlayer = 0x18; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_bHasSpawned = 0x20; // bool
    constexpr std::ptrdiff_t m_id = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_isRunning = 0xB8; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xB9; // bool
    constexpr std::ptrdiff_t m_forwardSpeed = 0xBC; // float
    constexpr std::ptrdiff_t m_leftSpeed = 0xC0; // float
    constexpr std::ptrdiff_t m_verticalSpeed = 0xC4; // float
    constexpr std::ptrdiff_t m_buttonFlags = 0xC8; // uint64_t
    constexpr std::ptrdiff_t m_jumpTimestamp = 0xD0; // float
    constexpr std::ptrdiff_t m_viewForward = 0xD4; // Vector
    constexpr std::ptrdiff_t m_postureStackIndex = 0xF0; // int32_t
}

namespace CBreachCharge { // CCSWeaponBase
}

namespace CBreachChargeProjectile { // CBaseGrenade
}

namespace CBreakable { // CBaseModelEntity
    constexpr std::ptrdiff_t m_Material = 0x710; // Materials
    constexpr std::ptrdiff_t m_hBreaker = 0x714; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Explosion = 0x718; // Explosions
    constexpr std::ptrdiff_t m_iszSpawnObject = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPressureDelay = 0x728; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_iszPropData = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x738; // float
    constexpr std::ptrdiff_t m_nOverrideBlockLOS = 0x73C; // EOverrideBlockLOS_t
    constexpr std::ptrdiff_t m_OnBreak = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x768; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x790; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x794; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x798; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x79C; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x7B0; // int32_t
    constexpr std::ptrdiff_t m_PerformanceMode = 0x7B4; // PerformanceMode_t
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x7B8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x7BC; // GameTime_t
}

namespace CBreakableProp { // CBaseProp
    constexpr std::ptrdiff_t m_OnBreak = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHealthChanged = 0x908; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnTakeDamage = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_impactEnergyScale = 0x958; // float
    constexpr std::ptrdiff_t m_iMinHealthDmg = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_preferredCarryAngles = 0x960; // QAngle
    constexpr std::ptrdiff_t m_flPressureDelay = 0x96C; // float
    constexpr std::ptrdiff_t m_hBreaker = 0x970; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PerformanceMode = 0x974; // PerformanceMode_t
    constexpr std::ptrdiff_t m_flDmgModBullet = 0x978; // float
    constexpr std::ptrdiff_t m_flDmgModClub = 0x97C; // float
    constexpr std::ptrdiff_t m_flDmgModExplosive = 0x980; // float
    constexpr std::ptrdiff_t m_flDmgModFire = 0x984; // float
    constexpr std::ptrdiff_t m_iszPhysicsDamageTableName = 0x988; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszBasePropData = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iInteractions = 0x998; // int32_t
    constexpr std::ptrdiff_t m_flPreventDamageBeforeTime = 0x99C; // GameTime_t
    constexpr std::ptrdiff_t m_bHasBreakPiecesOrCommands = 0x9A0; // bool
    constexpr std::ptrdiff_t m_explodeDamage = 0x9A4; // float
    constexpr std::ptrdiff_t m_explodeRadius = 0x9A8; // float
    constexpr std::ptrdiff_t m_explosionDelay = 0x9B0; // float
    constexpr std::ptrdiff_t m_explosionBuildupSound = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomEffect = 0x9C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionCustomSound = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_explosionModifier = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x9D8; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x9DC; // GameTime_t
    constexpr std::ptrdiff_t m_bOriginalBlockLOS = 0x9E0; // bool
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x9E4; // float
    constexpr std::ptrdiff_t m_hLastAttacker = 0x9E8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hFlareEnt = 0x9EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bUsePuntSound = 0x9F0; // bool
    constexpr std::ptrdiff_t m_iszPuntSound = 0x9F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_noGhostCollision = 0xA00; // bool
}

namespace CBreakableStageHelper {
    constexpr std::ptrdiff_t m_nCurrentStage = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nStageCount = 0xC; // int32_t
}

namespace CBtActionAim { // CBtNode
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szAimReadyKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_flZoomCooldownTimestamp = 0x88; // float
    constexpr std::ptrdiff_t m_bDoneAiming = 0x8C; // bool
    constexpr std::ptrdiff_t m_flLerpStartTime = 0x90; // float
    constexpr std::ptrdiff_t m_flNextLookTargetLerpTime = 0x94; // float
    constexpr std::ptrdiff_t m_flPenaltyReductionRatio = 0x98; // float
    constexpr std::ptrdiff_t m_NextLookTarget = 0x9C; // QAngle
    constexpr std::ptrdiff_t m_AimTimer = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_SniperHoldTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_FocusIntervalTimer = 0xD8; // CountdownTimer
    constexpr std::ptrdiff_t m_bAcquired = 0xF0; // bool
}

namespace CBtActionCombatPositioning { // CBtNode
    constexpr std::ptrdiff_t m_szSensorInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szIsAttackingKey = 0x80; // CUtlString
    constexpr std::ptrdiff_t m_ActionTimer = 0x88; // CountdownTimer
    constexpr std::ptrdiff_t m_bCrouching = 0xA0; // bool
}

namespace CBtActionMoveTo { // CBtNode
    constexpr std::ptrdiff_t m_szDestinationInputKey = 0x60; // CUtlString
    constexpr std::ptrdiff_t m_szHidingSpotInputKey = 0x68; // CUtlString
    constexpr std::ptrdiff_t m_szThreatInputKey = 0x70; // CUtlString
    constexpr std::ptrdiff_t m_vecDestination = 0x78; // Vector
    constexpr std::ptrdiff_t m_bAutoLookAdjust = 0x84; // bool
    constexpr std::ptrdiff_t m_bComputePath = 0x85; // bool
    constexpr std::ptrdiff_t m_flDamagingAreasPenaltyCost = 0x88; // float
    constexpr std::ptrdiff_t m_CheckApproximateCornersTimer = 0x90; // CountdownTimer
    constexpr std::ptrdiff_t m_CheckHighPriorityItem = 0xA8; // CountdownTimer
    constexpr std::ptrdiff_t m_RepathTimer = 0xC0; // CountdownTimer
    constexpr std::ptrdiff_t m_flArrivalEpsilon = 0xD8; // float
    constexpr std::ptrdiff_t m_flAdditionalArrivalEpsilon2D = 0xDC; // float
    constexpr std::ptrdiff_t m_flHidingSpotCheckDistanceThreshold = 0xE0; // float
    constexpr std::ptrdiff_t m_flNearestAreaDistanceThreshold = 0xE4; // float
}

namespace CBtActionParachutePositioning { // CBtNode
    constexpr std::ptrdiff_t m_ActionTimer = 0x58; // CountdownTimer
}

namespace CBtNode {
}

namespace CBtNodeComposite { // CBtNode
}

namespace CBtNodeCondition { // CBtNodeDecorator
    constexpr std::ptrdiff_t m_bNegated = 0x58; // bool
}

namespace CBtNodeConditionInactive { // CBtNodeCondition
    constexpr std::ptrdiff_t m_flRoundStartThresholdSeconds = 0x78; // float
    constexpr std::ptrdiff_t m_flSensorInactivityThresholdSeconds = 0x7C; // float
    constexpr std::ptrdiff_t m_SensorInactivityTimer = 0x80; // CountdownTimer
}

namespace CBtNodeDecorator { // CBtNode
}

namespace CBubbling { // CBaseModelEntity
    constexpr std::ptrdiff_t m_density = 0x700; // int32_t
    constexpr std::ptrdiff_t m_frequency = 0x704; // int32_t
    constexpr std::ptrdiff_t m_state = 0x708; // int32_t
}

namespace CBumpMine { // CCSWeaponBase
}

namespace CBumpMineProjectile { // CBaseGrenade
}

namespace CBuoyancyHelper {
    constexpr std::ptrdiff_t m_flFluidDensity = 0x18; // float
}

namespace CBuyZone { // CBaseTrigger
    constexpr std::ptrdiff_t m_LegacyTeamNum = 0x8A8; // int32_t
}

namespace CC4 { // CCSWeaponBase
    constexpr std::ptrdiff_t m_vecLastValidPlayerHeldPosition = 0xE20; // Vector
    constexpr std::ptrdiff_t m_vecLastValidDroppedPosition = 0xE2C; // Vector
    constexpr std::ptrdiff_t m_bDoValidDroppedPositionCheck = 0xE38; // bool
    constexpr std::ptrdiff_t m_bStartedArming = 0xE39; // bool
    constexpr std::ptrdiff_t m_fArmedTime = 0xE3C; // GameTime_t
    constexpr std::ptrdiff_t m_bBombPlacedAnimation = 0xE40; // bool
    constexpr std::ptrdiff_t m_bIsPlantingViaUse = 0xE41; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0xE48; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xE60; // int32_t
    constexpr std::ptrdiff_t m_bPlayedArmingBeeps = 0xE64; // bool[7]
    constexpr std::ptrdiff_t m_bBombPlanted = 0xE6B; // bool
    constexpr std::ptrdiff_t m_bDroppedFromDeath = 0xE6C; // bool
}

namespace CCSBot { // CBot
    constexpr std::ptrdiff_t m_lastCoopSpawnPoint = 0xF8; // CHandle<SpawnPointCoopEnemy>
    constexpr std::ptrdiff_t m_eyePosition = 0x108; // Vector
    constexpr std::ptrdiff_t m_name = 0x114; // char[64]
    constexpr std::ptrdiff_t m_combatRange = 0x154; // float
    constexpr std::ptrdiff_t m_isRogue = 0x158; // bool
    constexpr std::ptrdiff_t m_rogueTimer = 0x160; // CountdownTimer
    constexpr std::ptrdiff_t m_diedLastRound = 0x17C; // bool
    constexpr std::ptrdiff_t m_safeTime = 0x180; // float
    constexpr std::ptrdiff_t m_wasSafe = 0x184; // bool
    constexpr std::ptrdiff_t m_blindFire = 0x18C; // bool
    constexpr std::ptrdiff_t m_surpriseTimer = 0x190; // CountdownTimer
    constexpr std::ptrdiff_t m_bAllowActive = 0x1A8; // bool
    constexpr std::ptrdiff_t m_isFollowing = 0x1A9; // bool
    constexpr std::ptrdiff_t m_leader = 0x1AC; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_followTimestamp = 0x1B0; // float
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0x1B4; // float
    constexpr std::ptrdiff_t m_hurryTimer = 0x1B8; // CountdownTimer
    constexpr std::ptrdiff_t m_alertTimer = 0x1D0; // CountdownTimer
    constexpr std::ptrdiff_t m_sneakTimer = 0x1E8; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x200; // CountdownTimer
    constexpr std::ptrdiff_t m_stateTimestamp = 0x4D0; // float
    constexpr std::ptrdiff_t m_isAttacking = 0x4D4; // bool
    constexpr std::ptrdiff_t m_isOpeningDoor = 0x4D5; // bool
    constexpr std::ptrdiff_t m_taskEntity = 0x4DC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_goalPosition = 0x4EC; // Vector
    constexpr std::ptrdiff_t m_goalEntity = 0x4F8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoid = 0x4FC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_avoidTimestamp = 0x500; // float
    constexpr std::ptrdiff_t m_isStopping = 0x504; // bool
    constexpr std::ptrdiff_t m_hasVisitedEnemySpawn = 0x505; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0x508; // IntervalTimer
    constexpr std::ptrdiff_t m_bEyeAnglesUnderPathFinderControl = 0x518; // bool
    constexpr std::ptrdiff_t m_pathIndex = 0x6610; // int32_t
    constexpr std::ptrdiff_t m_areaEnteredTimestamp = 0x6614; // GameTime_t
    constexpr std::ptrdiff_t m_repathTimer = 0x6618; // CountdownTimer
    constexpr std::ptrdiff_t m_avoidFriendTimer = 0x6630; // CountdownTimer
    constexpr std::ptrdiff_t m_isFriendInTheWay = 0x6648; // bool
    constexpr std::ptrdiff_t m_politeTimer = 0x6650; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingBehindFriend = 0x6668; // bool
    constexpr std::ptrdiff_t m_pathLadderEnd = 0x6694; // float
    constexpr std::ptrdiff_t m_mustRunTimer = 0x66E0; // CountdownTimer
    constexpr std::ptrdiff_t m_waitTimer = 0x66F8; // CountdownTimer
    constexpr std::ptrdiff_t m_updateTravelDistanceTimer = 0x6710; // CountdownTimer
    constexpr std::ptrdiff_t m_playerTravelDistance = 0x6728; // float[64]
    constexpr std::ptrdiff_t m_travelDistancePhase = 0x6828; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCount = 0x69C0; // uint8_t
    constexpr std::ptrdiff_t m_hostageEscortCountTimestamp = 0x69C4; // float
    constexpr std::ptrdiff_t m_desiredTeam = 0x69C8; // int32_t
    constexpr std::ptrdiff_t m_hasJoined = 0x69CC; // bool
    constexpr std::ptrdiff_t m_isWaitingForHostage = 0x69CD; // bool
    constexpr std::ptrdiff_t m_inhibitWaitingForHostageTimer = 0x69D0; // CountdownTimer
    constexpr std::ptrdiff_t m_waitForHostageTimer = 0x69E8; // CountdownTimer
    constexpr std::ptrdiff_t m_noisePosition = 0x6A00; // Vector
    constexpr std::ptrdiff_t m_noiseTravelDistance = 0x6A0C; // float
    constexpr std::ptrdiff_t m_noiseTimestamp = 0x6A10; // float
    constexpr std::ptrdiff_t m_noiseSource = 0x6A18; // CCSPlayerPawn*
    constexpr std::ptrdiff_t m_noiseBendTimer = 0x6A30; // CountdownTimer
    constexpr std::ptrdiff_t m_bentNoisePosition = 0x6A48; // Vector
    constexpr std::ptrdiff_t m_bendNoisePositionValid = 0x6A54; // bool
    constexpr std::ptrdiff_t m_lookAroundStateTimestamp = 0x6A58; // float
    constexpr std::ptrdiff_t m_lookAheadAngle = 0x6A5C; // float
    constexpr std::ptrdiff_t m_forwardAngle = 0x6A60; // float
    constexpr std::ptrdiff_t m_inhibitLookAroundTimestamp = 0x6A64; // float
    constexpr std::ptrdiff_t m_lookAtSpot = 0x6A6C; // Vector
    constexpr std::ptrdiff_t m_lookAtSpotDuration = 0x6A7C; // float
    constexpr std::ptrdiff_t m_lookAtSpotTimestamp = 0x6A80; // float
    constexpr std::ptrdiff_t m_lookAtSpotAngleTolerance = 0x6A84; // float
    constexpr std::ptrdiff_t m_lookAtSpotClearIfClose = 0x6A88; // bool
    constexpr std::ptrdiff_t m_lookAtSpotAttack = 0x6A89; // bool
    constexpr std::ptrdiff_t m_lookAtDesc = 0x6A90; // char*
    constexpr std::ptrdiff_t m_peripheralTimestamp = 0x6A98; // float
    constexpr std::ptrdiff_t m_approachPointCount = 0x6C20; // uint8_t
    constexpr std::ptrdiff_t m_approachPointViewPosition = 0x6C24; // Vector
    constexpr std::ptrdiff_t m_viewSteadyTimer = 0x6C30; // IntervalTimer
    constexpr std::ptrdiff_t m_tossGrenadeTimer = 0x6C48; // CountdownTimer
    constexpr std::ptrdiff_t m_isAvoidingGrenade = 0x6C68; // CountdownTimer
    constexpr std::ptrdiff_t m_spotCheckTimestamp = 0x6C88; // float
    constexpr std::ptrdiff_t m_checkedHidingSpotCount = 0x7090; // int32_t
    constexpr std::ptrdiff_t m_lookPitch = 0x7094; // float
    constexpr std::ptrdiff_t m_lookPitchVel = 0x7098; // float
    constexpr std::ptrdiff_t m_lookYaw = 0x709C; // float
    constexpr std::ptrdiff_t m_lookYawVel = 0x70A0; // float
    constexpr std::ptrdiff_t m_targetSpot = 0x70A4; // Vector
    constexpr std::ptrdiff_t m_targetSpotVelocity = 0x70B0; // Vector
    constexpr std::ptrdiff_t m_targetSpotPredicted = 0x70BC; // Vector
    constexpr std::ptrdiff_t m_aimError = 0x70C8; // QAngle
    constexpr std::ptrdiff_t m_aimGoal = 0x70D4; // QAngle
    constexpr std::ptrdiff_t m_targetSpotTime = 0x70E0; // GameTime_t
    constexpr std::ptrdiff_t m_aimFocus = 0x70E4; // float
    constexpr std::ptrdiff_t m_aimFocusInterval = 0x70E8; // float
    constexpr std::ptrdiff_t m_aimFocusNextUpdate = 0x70EC; // GameTime_t
    constexpr std::ptrdiff_t m_ignoreEnemiesTimer = 0x70F8; // CountdownTimer
    constexpr std::ptrdiff_t m_enemy = 0x7110; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_isEnemyVisible = 0x7114; // bool
    constexpr std::ptrdiff_t m_visibleEnemyParts = 0x7115; // uint8_t
    constexpr std::ptrdiff_t m_lastEnemyPosition = 0x7118; // Vector
    constexpr std::ptrdiff_t m_lastSawEnemyTimestamp = 0x7124; // float
    constexpr std::ptrdiff_t m_firstSawEnemyTimestamp = 0x7128; // float
    constexpr std::ptrdiff_t m_currentEnemyAcquireTimestamp = 0x712C; // float
    constexpr std::ptrdiff_t m_enemyDeathTimestamp = 0x7130; // float
    constexpr std::ptrdiff_t m_friendDeathTimestamp = 0x7134; // float
    constexpr std::ptrdiff_t m_isLastEnemyDead = 0x7138; // bool
    constexpr std::ptrdiff_t m_nearbyEnemyCount = 0x713C; // int32_t
    constexpr std::ptrdiff_t m_bomber = 0x7348; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nearbyFriendCount = 0x734C; // int32_t
    constexpr std::ptrdiff_t m_closestVisibleFriend = 0x7350; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_closestVisibleHumanFriend = 0x7354; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attentionInterval = 0x7358; // IntervalTimer
    constexpr std::ptrdiff_t m_attacker = 0x7368; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_attackedTimestamp = 0x736C; // float
    constexpr std::ptrdiff_t m_burnedByFlamesTimer = 0x7370; // IntervalTimer
    constexpr std::ptrdiff_t m_lastVictimID = 0x7380; // int32_t
    constexpr std::ptrdiff_t m_isAimingAtEnemy = 0x7384; // bool
    constexpr std::ptrdiff_t m_isRapidFiring = 0x7385; // bool
    constexpr std::ptrdiff_t m_equipTimer = 0x7388; // IntervalTimer
    constexpr std::ptrdiff_t m_zoomTimer = 0x7398; // CountdownTimer
    constexpr std::ptrdiff_t m_fireWeaponTimestamp = 0x73B0; // GameTime_t
    constexpr std::ptrdiff_t m_lookForWeaponsOnGroundTimer = 0x73B8; // CountdownTimer
    constexpr std::ptrdiff_t m_bIsSleeping = 0x73D0; // bool
    constexpr std::ptrdiff_t m_isEnemySniperVisible = 0x73D1; // bool
    constexpr std::ptrdiff_t m_sawEnemySniperTimer = 0x73D8; // CountdownTimer
    constexpr std::ptrdiff_t m_enemyQueueIndex = 0x7490; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueCount = 0x7491; // uint8_t
    constexpr std::ptrdiff_t m_enemyQueueAttendIndex = 0x7492; // uint8_t
    constexpr std::ptrdiff_t m_isStuck = 0x7493; // bool
    constexpr std::ptrdiff_t m_stuckTimestamp = 0x7494; // GameTime_t
    constexpr std::ptrdiff_t m_stuckSpot = 0x7498; // Vector
    constexpr std::ptrdiff_t m_wiggleTimer = 0x74A8; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckJumpTimer = 0x74C0; // CountdownTimer
    constexpr std::ptrdiff_t m_nextCleanupCheckTimestamp = 0x74D8; // GameTime_t
    constexpr std::ptrdiff_t m_avgVel = 0x74DC; // float[10]
    constexpr std::ptrdiff_t m_avgVelIndex = 0x7504; // int32_t
    constexpr std::ptrdiff_t m_avgVelCount = 0x7508; // int32_t
    constexpr std::ptrdiff_t m_lastOrigin = 0x750C; // Vector
    constexpr std::ptrdiff_t m_lastRadioRecievedTimestamp = 0x751C; // float
    constexpr std::ptrdiff_t m_lastRadioSentTimestamp = 0x7520; // float
    constexpr std::ptrdiff_t m_radioSubject = 0x7524; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_radioPosition = 0x7528; // Vector
    constexpr std::ptrdiff_t m_voiceEndTimestamp = 0x7534; // float
    constexpr std::ptrdiff_t m_lastValidReactionQueueFrame = 0x7540; // int32_t
}

namespace CCSGOPlayerAnimGraphState {
}

namespace CCSGOViewModel { // CPredictedViewModel
    constexpr std::ptrdiff_t m_bShouldIgnoreOffsetAndAccuracy = 0x8D8; // bool
    constexpr std::ptrdiff_t m_nWeaponParity = 0x8DC; // uint32_t
    constexpr std::ptrdiff_t m_nOldWeaponParity = 0x8E0; // uint32_t
}

namespace CCSGO_TeamIntroCharacterPosition { // CCSGO_TeamPreviewCharacterPosition
}

namespace CCSGO_TeamIntroCounterTerroristPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_TeamIntroTerroristPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_TeamPreviewCharacterPosition { // CBaseEntity
    constexpr std::ptrdiff_t m_nVariant = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_nRandom = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nOrdinal = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_sWeaponName = 0x4C0; // CUtlString
    constexpr std::ptrdiff_t m_xuid = 0x4C8; // uint64_t
    constexpr std::ptrdiff_t m_agentItem = 0x4D0; // CEconItemView
    constexpr std::ptrdiff_t m_glovesItem = 0x748; // CEconItemView
    constexpr std::ptrdiff_t m_weaponItem = 0x9C0; // CEconItemView
}

namespace CCSGO_TeamSelectCharacterPosition { // CCSGO_TeamPreviewCharacterPosition
}

namespace CCSGO_TeamSelectCounterTerroristPosition { // CCSGO_TeamSelectCharacterPosition
}

namespace CCSGO_TeamSelectTerroristPosition { // CCSGO_TeamSelectCharacterPosition
}

namespace CCSGO_WingmanIntroCharacterPosition { // CCSGO_TeamIntroCharacterPosition
}

namespace CCSGO_WingmanIntroCounterTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGO_WingmanIntroTerroristPosition { // CCSGO_WingmanIntroCharacterPosition
}

namespace CCSGameModeRules {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CCSGameModeRules_Deathmatch { // CCSGameModeRules
    constexpr std::ptrdiff_t m_bFirstThink = 0x30; // bool
    constexpr std::ptrdiff_t m_bFirstThinkAfterConnected = 0x31; // bool
    constexpr std::ptrdiff_t m_flDMBonusStartTime = 0x34; // GameTime_t
    constexpr std::ptrdiff_t m_flDMBonusTimeLength = 0x38; // float
    constexpr std::ptrdiff_t m_nDMBonusWeaponLoadoutSlot = 0x3C; // int16_t
}

namespace CCSGameModeRules_Noop { // CCSGameModeRules
}

namespace CCSGameModeRules_Scripted { // CCSGameModeRules
}

namespace CCSGameModeScript { // CBasePulseGraphInstance
}

namespace CCSGameRules { // CTeamplayRules
    constexpr std::ptrdiff_t __m_pChainEntity = 0x98; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_coopMissionManager = 0xC0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bFreezePeriod = 0xC4; // bool
    constexpr std::ptrdiff_t m_bWarmupPeriod = 0xC5; // bool
    constexpr std::ptrdiff_t m_fWarmupPeriodEnd = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_fWarmupPeriodStart = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_nTotalPausedTicks = 0xD0; // int32_t
    constexpr std::ptrdiff_t m_nPauseStartTick = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bServerPaused = 0xD8; // bool
    constexpr std::ptrdiff_t m_bGamePaused = 0xD9; // bool
    constexpr std::ptrdiff_t m_bTerroristTimeOutActive = 0xDA; // bool
    constexpr std::ptrdiff_t m_bCTTimeOutActive = 0xDB; // bool
    constexpr std::ptrdiff_t m_flTerroristTimeOutRemaining = 0xDC; // float
    constexpr std::ptrdiff_t m_flCTTimeOutRemaining = 0xE0; // float
    constexpr std::ptrdiff_t m_nTerroristTimeOuts = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_nCTTimeOuts = 0xE8; // int32_t
    constexpr std::ptrdiff_t m_bTechnicalTimeOut = 0xEC; // bool
    constexpr std::ptrdiff_t m_bMatchWaitingForResume = 0xED; // bool
    constexpr std::ptrdiff_t m_iRoundTime = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_fMatchStartTime = 0xF4; // float
    constexpr std::ptrdiff_t m_fRoundStartTime = 0xF8; // GameTime_t
    constexpr std::ptrdiff_t m_flRestartRoundTime = 0xFC; // GameTime_t
    constexpr std::ptrdiff_t m_bGameRestart = 0x100; // bool
    constexpr std::ptrdiff_t m_flGameStartTime = 0x104; // float
    constexpr std::ptrdiff_t m_timeUntilNextPhaseStarts = 0x108; // float
    constexpr std::ptrdiff_t m_gamePhase = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_totalRoundsPlayed = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nRoundsPlayedThisPhase = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nOvertimePlaying = 0x118; // int32_t
    constexpr std::ptrdiff_t m_iHostagesRemaining = 0x11C; // int32_t
    constexpr std::ptrdiff_t m_bAnyHostageReached = 0x120; // bool
    constexpr std::ptrdiff_t m_bMapHasBombTarget = 0x121; // bool
    constexpr std::ptrdiff_t m_bMapHasRescueZone = 0x122; // bool
    constexpr std::ptrdiff_t m_bMapHasBuyZone = 0x123; // bool
    constexpr std::ptrdiff_t m_bIsQueuedMatchmaking = 0x124; // bool
    constexpr std::ptrdiff_t m_nQueuedMatchmakingMode = 0x128; // int32_t
    constexpr std::ptrdiff_t m_bIsValveDS = 0x12C; // bool
    constexpr std::ptrdiff_t m_bLogoMap = 0x12D; // bool
    constexpr std::ptrdiff_t m_bPlayAllStepSoundsOnServer = 0x12E; // bool
    constexpr std::ptrdiff_t m_iSpectatorSlotCount = 0x130; // int32_t
    constexpr std::ptrdiff_t m_MatchDevice = 0x134; // int32_t
    constexpr std::ptrdiff_t m_bHasMatchStarted = 0x138; // bool
    constexpr std::ptrdiff_t m_nNextMapInMapgroup = 0x13C; // int32_t
    constexpr std::ptrdiff_t m_szTournamentEventName = 0x140; // char[512]
    constexpr std::ptrdiff_t m_szTournamentEventStage = 0x340; // char[512]
    constexpr std::ptrdiff_t m_szMatchStatTxt = 0x540; // char[512]
    constexpr std::ptrdiff_t m_szTournamentPredictionsTxt = 0x740; // char[512]
    constexpr std::ptrdiff_t m_nTournamentPredictionsPct = 0x940; // int32_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealStartTime = 0x944; // GameTime_t
    constexpr std::ptrdiff_t m_flCMMItemDropRevealEndTime = 0x948; // GameTime_t
    constexpr std::ptrdiff_t m_bIsDroppingItems = 0x94C; // bool
    constexpr std::ptrdiff_t m_bIsQuestEligible = 0x94D; // bool
    constexpr std::ptrdiff_t m_bIsHltvActive = 0x94E; // bool
    constexpr std::ptrdiff_t m_nGuardianModeWaveNumber = 0x950; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialKillsRemaining = 0x954; // int32_t
    constexpr std::ptrdiff_t m_nGuardianModeSpecialWeaponNeeded = 0x958; // int32_t
    constexpr std::ptrdiff_t m_nGuardianGrenadesToGiveBots = 0x95C; // int32_t
    constexpr std::ptrdiff_t m_nNumHeaviesToSpawn = 0x960; // int32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsGiven = 0x964; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGifters = 0x968; // uint32_t
    constexpr std::ptrdiff_t m_numGlobalGiftsPeriodSeconds = 0x96C; // uint32_t
    constexpr std::ptrdiff_t m_arrFeaturedGiftersAccounts = 0x970; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrFeaturedGiftersGifts = 0x980; // uint32_t[4]
    constexpr std::ptrdiff_t m_arrProhibitedItemIndices = 0x990; // uint16_t[100]
    constexpr std::ptrdiff_t m_arrTournamentActiveCasterAccounts = 0xA58; // uint32_t[4]
    constexpr std::ptrdiff_t m_numBestOfMaps = 0xA68; // int32_t
    constexpr std::ptrdiff_t m_nHalloweenMaskListSeed = 0xA6C; // int32_t
    constexpr std::ptrdiff_t m_bBombDropped = 0xA70; // bool
    constexpr std::ptrdiff_t m_bBombPlanted = 0xA71; // bool
    constexpr std::ptrdiff_t m_iRoundWinStatus = 0xA74; // int32_t
    constexpr std::ptrdiff_t m_eRoundWinReason = 0xA78; // int32_t
    constexpr std::ptrdiff_t m_bTCantBuy = 0xA7C; // bool
    constexpr std::ptrdiff_t m_bCTCantBuy = 0xA7D; // bool
    constexpr std::ptrdiff_t m_flGuardianBuyUntilTime = 0xA80; // GameTime_t
    constexpr std::ptrdiff_t m_iMatchStats_RoundResults = 0xA84; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_CT = 0xAFC; // int32_t[30]
    constexpr std::ptrdiff_t m_iMatchStats_PlayersAlive_T = 0xB74; // int32_t[30]
    constexpr std::ptrdiff_t m_TeamRespawnWaveTimes = 0xBEC; // float[32]
    constexpr std::ptrdiff_t m_flNextRespawnWave = 0xC6C; // GameTime_t[32]
    constexpr std::ptrdiff_t m_nServerQuestID = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_vMinimapMins = 0xCF0; // Vector
    constexpr std::ptrdiff_t m_vMinimapMaxs = 0xCFC; // Vector
    constexpr std::ptrdiff_t m_MinimapVerticalSectionHeights = 0xD08; // float[8]
    constexpr std::ptrdiff_t m_bDontIncrementCoopWave = 0xD28; // bool
    constexpr std::ptrdiff_t m_bSpawnedTerrorHuntHeavy = 0xD29; // bool
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteTypes = 0xD2C; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapGroupVoteOptions = 0xD54; // int32_t[10]
    constexpr std::ptrdiff_t m_nEndMatchMapVoteWinner = 0xD7C; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveCTLoses = 0xD80; // int32_t
    constexpr std::ptrdiff_t m_iNumConsecutiveTerroristLoses = 0xD84; // int32_t
    constexpr std::ptrdiff_t m_bHasHostageBeenTouched = 0xDA0; // bool
    constexpr std::ptrdiff_t m_flIntermissionStartTime = 0xDA4; // GameTime_t
    constexpr std::ptrdiff_t m_flIntermissionEndTime = 0xDA8; // GameTime_t
    constexpr std::ptrdiff_t m_bLevelInitialized = 0xDAC; // bool
    constexpr std::ptrdiff_t m_iTotalRoundsPlayed = 0xDB0; // int32_t
    constexpr std::ptrdiff_t m_iUnBalancedRounds = 0xDB4; // int32_t
    constexpr std::ptrdiff_t m_endMatchOnRoundReset = 0xDB8; // bool
    constexpr std::ptrdiff_t m_endMatchOnThink = 0xDB9; // bool
    constexpr std::ptrdiff_t m_iFreezeTime = 0xDBC; // int32_t
    constexpr std::ptrdiff_t m_iNumTerrorist = 0xDC0; // int32_t
    constexpr std::ptrdiff_t m_iNumCT = 0xDC4; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableTerrorist = 0xDC8; // int32_t
    constexpr std::ptrdiff_t m_iNumSpawnableCT = 0xDCC; // int32_t
    constexpr std::ptrdiff_t m_arrSelectedHostageSpawnIndices = 0xDD0; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bFirstConnected = 0xDE8; // bool
    constexpr std::ptrdiff_t m_bCompleteReset = 0xDE9; // bool
    constexpr std::ptrdiff_t m_bPickNewTeamsOnReset = 0xDEA; // bool
    constexpr std::ptrdiff_t m_bScrambleTeamsOnRestart = 0xDEB; // bool
    constexpr std::ptrdiff_t m_bSwapTeamsOnRestart = 0xDEC; // bool
    constexpr std::ptrdiff_t m_nEndMatchTiedVotes = 0xDF8; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_bNeedToAskPlayersForContinueVote = 0xE14; // bool
    constexpr std::ptrdiff_t m_numQueuedMatchmakingAccounts = 0xE18; // uint32_t
    constexpr std::ptrdiff_t m_pQueuedMatchmakingReservationString = 0xE20; // char*
    constexpr std::ptrdiff_t m_numTotalTournamentDrops = 0xE28; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMax = 0xE2C; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxTV = 0xE30; // uint32_t
    constexpr std::ptrdiff_t m_numSpectatorsCountMaxLnk = 0xE34; // uint32_t
    constexpr std::ptrdiff_t m_bForceTeamChangeSilent = 0xE40; // bool
    constexpr std::ptrdiff_t m_bLoadingRoundBackupData = 0xE41; // bool
    constexpr std::ptrdiff_t m_nMatchInfoShowType = 0xE78; // int32_t
    constexpr std::ptrdiff_t m_flMatchInfoDecidedTime = 0xE7C; // float
    constexpr std::ptrdiff_t m_flCoopRespawnAndHealTime = 0xE98; // float
    constexpr std::ptrdiff_t m_coopBonusCoinsFound = 0xE9C; // int32_t
    constexpr std::ptrdiff_t m_coopBonusPistolsOnly = 0xEA0; // bool
    constexpr std::ptrdiff_t m_coopPlayersInDeploymentZone = 0xEA1; // bool
    constexpr std::ptrdiff_t m_coopMissionDeadPlayerRespawnEnabled = 0xEA2; // bool
    constexpr std::ptrdiff_t mTeamDMLastWinningTeamNumber = 0xEA4; // int32_t
    constexpr std::ptrdiff_t mTeamDMLastThinkTime = 0xEA8; // float
    constexpr std::ptrdiff_t m_flTeamDMLastAnnouncementTime = 0xEAC; // float
    constexpr std::ptrdiff_t m_iAccountTerrorist = 0xEB0; // int32_t
    constexpr std::ptrdiff_t m_iAccountCT = 0xEB4; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_Terrorist = 0xEB8; // int32_t
    constexpr std::ptrdiff_t m_iSpawnPointCount_CT = 0xEBC; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumTerrorists = 0xEC0; // int32_t
    constexpr std::ptrdiff_t m_iMaxNumCTs = 0xEC4; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonus = 0xEC8; // int32_t
    constexpr std::ptrdiff_t m_iLoserBonusMostRecentTeam = 0xECC; // int32_t
    constexpr std::ptrdiff_t m_tmNextPeriodicThink = 0xED0; // float
    constexpr std::ptrdiff_t m_bVoiceWonMatchBragFired = 0xED4; // bool
    constexpr std::ptrdiff_t m_fWarmupNextChatNoticeTime = 0xED8; // float
    constexpr std::ptrdiff_t m_iHostagesRescued = 0xEE0; // int32_t
    constexpr std::ptrdiff_t m_iHostagesTouched = 0xEE4; // int32_t
    constexpr std::ptrdiff_t m_flNextHostageAnnouncement = 0xEE8; // float
    constexpr std::ptrdiff_t m_bNoTerroristsKilled = 0xEEC; // bool
    constexpr std::ptrdiff_t m_bNoCTsKilled = 0xEED; // bool
    constexpr std::ptrdiff_t m_bNoEnemiesKilled = 0xEEE; // bool
    constexpr std::ptrdiff_t m_bCanDonateWeapons = 0xEEF; // bool
    constexpr std::ptrdiff_t m_firstKillTime = 0xEF4; // float
    constexpr std::ptrdiff_t m_firstBloodTime = 0xEFC; // float
    constexpr std::ptrdiff_t m_hostageWasInjured = 0xF18; // bool
    constexpr std::ptrdiff_t m_hostageWasKilled = 0xF19; // bool
    constexpr std::ptrdiff_t m_bVoteCalled = 0xF28; // bool
    constexpr std::ptrdiff_t m_bServerVoteOnReset = 0xF29; // bool
    constexpr std::ptrdiff_t m_flVoteCheckThrottle = 0xF2C; // float
    constexpr std::ptrdiff_t m_bBuyTimeEnded = 0xF30; // bool
    constexpr std::ptrdiff_t m_nLastFreezeEndBeep = 0xF34; // int32_t
    constexpr std::ptrdiff_t m_bTargetBombed = 0xF38; // bool
    constexpr std::ptrdiff_t m_bBombDefused = 0xF39; // bool
    constexpr std::ptrdiff_t m_bMapHasBombZone = 0xF3A; // bool
    constexpr std::ptrdiff_t m_vecMainCTSpawnPos = 0xF58; // Vector
    constexpr std::ptrdiff_t m_CTSpawnPointsMasterList = 0xF68; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPointsMasterList = 0xF80; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_iNextCTSpawnPoint = 0xF98; // int32_t
    constexpr std::ptrdiff_t m_iNextTerroristSpawnPoint = 0xF9C; // int32_t
    constexpr std::ptrdiff_t m_CTSpawnPoints = 0xFA0; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_TerroristSpawnPoints = 0xFB8; // CUtlVector<SpawnPoint*>
    constexpr std::ptrdiff_t m_bIsUnreservedGameServer = 0xFD0; // bool
    constexpr std::ptrdiff_t m_fAutobalanceDisplayTime = 0xFD4; // float
    constexpr std::ptrdiff_t m_bAllowWeaponSwitch = 0x1240; // bool
    constexpr std::ptrdiff_t m_bRoundTimeWarningTriggered = 0x1241; // bool
    constexpr std::ptrdiff_t m_phaseChangeAnnouncementTime = 0x1244; // GameTime_t
    constexpr std::ptrdiff_t m_fNextUpdateTeamClanNamesTime = 0x1248; // float
    constexpr std::ptrdiff_t m_flLastThinkTime = 0x124C; // GameTime_t
    constexpr std::ptrdiff_t m_fAccumulatedRoundOffDamage = 0x1250; // float
    constexpr std::ptrdiff_t m_nShorthandedBonusLastEvalRound = 0x1254; // int32_t
    constexpr std::ptrdiff_t m_nMatchAbortedEarlyReason = 0x14D0; // int32_t
    constexpr std::ptrdiff_t m_bHasTriggeredRoundStartMusic = 0x14D4; // bool
    constexpr std::ptrdiff_t m_bHasTriggeredCoopSpawnReset = 0x14D5; // bool
    constexpr std::ptrdiff_t m_bSwitchingTeamsAtRoundReset = 0x14D6; // bool
    constexpr std::ptrdiff_t m_pGameModeRules = 0x14F0; // CCSGameModeRules*
    constexpr std::ptrdiff_t m_BtGlobalBlackboard = 0x14F8; // KeyValues3
    constexpr std::ptrdiff_t m_hPlayerResource = 0x1560; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_RetakeRules = 0x1568; // CRetakeGameRules
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMax = 0x174C; // int32_t
    constexpr std::ptrdiff_t m_GuardianBotSkillLevelMin = 0x1750; // int32_t
    constexpr std::ptrdiff_t m_arrTeamUniqueKillWeaponsMatch = 0x1758; // CUtlVector<int32_t>[4]
    constexpr std::ptrdiff_t m_bTeamLastKillUsedUniqueWeaponMatch = 0x17B8; // bool[4]
    constexpr std::ptrdiff_t m_nMatchEndCount = 0x17E0; // uint8_t
    constexpr std::ptrdiff_t m_nTTeamIntroVariant = 0x17E4; // int32_t
    constexpr std::ptrdiff_t m_nCTTeamIntroVariant = 0x17E8; // int32_t
    constexpr std::ptrdiff_t m_bTeamIntroPeriod = 0x17EC; // bool
    constexpr std::ptrdiff_t m_fTeamIntroPeriodEnd = 0x17F0; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayedTeamIntroVO = 0x17F4; // bool
    constexpr std::ptrdiff_t m_flLastPerfSampleTime = 0x5800; // double
    constexpr std::ptrdiff_t m_bSkipNextServerPerfSample = 0x5808; // bool
}

namespace CCSGameRulesProxy { // CGameRulesProxy
    constexpr std::ptrdiff_t m_pGameRules = 0x4B0; // CCSGameRules*
}

namespace CCSMinimapBoundary { // CBaseEntity
}

namespace CCSObserverPawn { // CCSPlayerPawnBase
}

namespace CCSObserver_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSObserver_MovementServices { // CPlayer_MovementServices
}

namespace CCSObserver_ObserverServices { // CPlayer_ObserverServices
}

namespace CCSObserver_UseServices { // CPlayer_UseServices
}

namespace CCSObserver_ViewModelServices { // CPlayer_ViewModelServices
}

namespace CCSPlace { // CServerOnlyModelEntity
    constexpr std::ptrdiff_t m_name = 0x708; // CUtlSymbolLarge
}

namespace CCSPlayerBase_CameraServices { // CPlayer_CameraServices
    constexpr std::ptrdiff_t m_iFOV = 0x170; // uint32_t
    constexpr std::ptrdiff_t m_iFOVStart = 0x174; // uint32_t
    constexpr std::ptrdiff_t m_flFOVTime = 0x178; // GameTime_t
    constexpr std::ptrdiff_t m_flFOVRate = 0x17C; // float
    constexpr std::ptrdiff_t m_hZoomOwner = 0x180; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTriggerFogList = 0x188; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_hLastFogTrigger = 0x1A0; // CHandle<CBaseEntity>
}

namespace CCSPlayerController { // CBasePlayerController
    constexpr std::ptrdiff_t m_pInGameMoneyServices = 0x6B8; // CCSPlayerController_InGameMoneyServices*
    constexpr std::ptrdiff_t m_pInventoryServices = 0x6C0; // CCSPlayerController_InventoryServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x6C8; // CCSPlayerController_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pDamageServices = 0x6D0; // CCSPlayerController_DamageServices*
    constexpr std::ptrdiff_t m_iPing = 0x6D8; // uint32_t
    constexpr std::ptrdiff_t m_bHasCommunicationAbuseMute = 0x6DC; // bool
    constexpr std::ptrdiff_t m_szCrosshairCodes = 0x6E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iPendingTeamNum = 0x6E8; // uint8_t
    constexpr std::ptrdiff_t m_flForceTeamTime = 0x6EC; // GameTime_t
    constexpr std::ptrdiff_t m_iCompTeammateColor = 0x6F0; // int32_t
    constexpr std::ptrdiff_t m_bEverPlayedOnTeam = 0x6F4; // bool
    constexpr std::ptrdiff_t m_bAttemptedToGetColor = 0x6F5; // bool
    constexpr std::ptrdiff_t m_iTeammatePreferredColor = 0x6F8; // int32_t
    constexpr std::ptrdiff_t m_bTeamChanged = 0x6FC; // bool
    constexpr std::ptrdiff_t m_bInSwitchTeam = 0x6FD; // bool
    constexpr std::ptrdiff_t m_bHasSeenJoinGame = 0x6FE; // bool
    constexpr std::ptrdiff_t m_bJustBecameSpectator = 0x6FF; // bool
    constexpr std::ptrdiff_t m_bSwitchTeamsOnNextRoundReset = 0x700; // bool
    constexpr std::ptrdiff_t m_bRemoveAllItemsOnNextRoundReset = 0x701; // bool
    constexpr std::ptrdiff_t m_szClan = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szClanName = 0x710; // char[32]
    constexpr std::ptrdiff_t m_iCoachingTeam = 0x730; // int32_t
    constexpr std::ptrdiff_t m_nPlayerDominated = 0x738; // uint64_t
    constexpr std::ptrdiff_t m_nPlayerDominatingMe = 0x740; // uint64_t
    constexpr std::ptrdiff_t m_iCompetitiveRanking = 0x748; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveWins = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankType = 0x750; // int8_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Win = 0x754; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Loss = 0x758; // int32_t
    constexpr std::ptrdiff_t m_iCompetitiveRankingPredicted_Tie = 0x75C; // int32_t
    constexpr std::ptrdiff_t m_nEndMatchNextMapVote = 0x760; // int32_t
    constexpr std::ptrdiff_t m_unActiveQuestId = 0x764; // uint16_t
    constexpr std::ptrdiff_t m_nQuestProgressReason = 0x768; // QuestProgress::Reason
    constexpr std::ptrdiff_t m_unPlayerTvControlFlags = 0x76C; // uint32_t
    constexpr std::ptrdiff_t m_iDraftIndex = 0x798; // int32_t
    constexpr std::ptrdiff_t m_msQueuedModeDisconnectionTimestamp = 0x79C; // uint32_t
    constexpr std::ptrdiff_t m_uiAbandonRecordedReason = 0x7A0; // uint32_t
    constexpr std::ptrdiff_t m_bCannotBeKicked = 0x7A4; // bool
    constexpr std::ptrdiff_t m_bEverFullyConnected = 0x7A5; // bool
    constexpr std::ptrdiff_t m_bAbandonAllowsSurrender = 0x7A6; // bool
    constexpr std::ptrdiff_t m_bAbandonOffersInstantSurrender = 0x7A7; // bool
    constexpr std::ptrdiff_t m_bDisconnection1MinWarningPrinted = 0x7A8; // bool
    constexpr std::ptrdiff_t m_bScoreReported = 0x7A9; // bool
    constexpr std::ptrdiff_t m_nDisconnectionTick = 0x7AC; // int32_t
    constexpr std::ptrdiff_t m_bControllingBot = 0x7B8; // bool
    constexpr std::ptrdiff_t m_bHasControlledBotThisRound = 0x7B9; // bool
    constexpr std::ptrdiff_t m_bHasBeenControlledByPlayerThisRound = 0x7BA; // bool
    constexpr std::ptrdiff_t m_nBotsControlledThisRound = 0x7BC; // int32_t
    constexpr std::ptrdiff_t m_bCanControlObservedBot = 0x7C0; // bool
    constexpr std::ptrdiff_t m_hPlayerPawn = 0x7C4; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hObserverPawn = 0x7C8; // CHandle<CCSObserverPawn>
    constexpr std::ptrdiff_t m_DesiredObserverMode = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_hDesiredObserverTarget = 0x7D0; // CEntityHandle
    constexpr std::ptrdiff_t m_bPawnIsAlive = 0x7D4; // bool
    constexpr std::ptrdiff_t m_iPawnHealth = 0x7D8; // uint32_t
    constexpr std::ptrdiff_t m_iPawnArmor = 0x7DC; // int32_t
    constexpr std::ptrdiff_t m_bPawnHasDefuser = 0x7E0; // bool
    constexpr std::ptrdiff_t m_bPawnHasHelmet = 0x7E1; // bool
    constexpr std::ptrdiff_t m_nPawnCharacterDefIndex = 0x7E2; // uint16_t
    constexpr std::ptrdiff_t m_iPawnLifetimeStart = 0x7E4; // int32_t
    constexpr std::ptrdiff_t m_iPawnLifetimeEnd = 0x7E8; // int32_t
    constexpr std::ptrdiff_t m_iPawnBotDifficulty = 0x7EC; // int32_t
    constexpr std::ptrdiff_t m_hOriginalControllerOfCurrentPawn = 0x7F0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_iScore = 0x7F4; // int32_t
    constexpr std::ptrdiff_t m_iRoundScore = 0x7F8; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWon = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_vecKills = 0x800; // CNetworkUtlVectorBase<EKillTypes_t>
    constexpr std::ptrdiff_t m_iMVPs = 0x818; // int32_t
    constexpr std::ptrdiff_t m_nUpdateCounter = 0x81C; // int32_t
    constexpr std::ptrdiff_t m_flSmoothedPing = 0x820; // float
    constexpr std::ptrdiff_t m_lastHeldVoteTimer = 0xF8C8; // IntervalTimer
    constexpr std::ptrdiff_t m_bShowHints = 0xF8E0; // bool
    constexpr std::ptrdiff_t m_iNextTimeCheck = 0xF8E4; // int32_t
    constexpr std::ptrdiff_t m_bJustDidTeamKill = 0xF8E8; // bool
    constexpr std::ptrdiff_t m_bPunishForTeamKill = 0xF8E9; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarning = 0xF8EA; // bool
    constexpr std::ptrdiff_t m_bGaveTeamDamageWarningThisRound = 0xF8EB; // bool
    constexpr std::ptrdiff_t m_dblLastReceivedPacketPlatFloatTime = 0xF8F0; // double
    constexpr std::ptrdiff_t m_LastTeamDamageWarningTime = 0xF8F8; // GameTime_t
    constexpr std::ptrdiff_t m_LastTimePlayerWasDisconnectedForPawnsRemove = 0xF8FC; // GameTime_t
}

namespace CCSPlayerController_ActionTrackingServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_perRoundStats = 0x40; // CUtlVectorEmbeddedNetworkVar<CSPerRoundStats_t>
    constexpr std::ptrdiff_t m_matchStats = 0x90; // CSMatchStats_t
    constexpr std::ptrdiff_t m_iNumRoundKills = 0x148; // int32_t
    constexpr std::ptrdiff_t m_iNumRoundKillsHeadshots = 0x14C; // int32_t
    constexpr std::ptrdiff_t m_unTotalRoundDamageDealt = 0x150; // uint32_t
}

namespace CCSPlayerController_DamageServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_nSendUpdate = 0x40; // int32_t
    constexpr std::ptrdiff_t m_DamageList = 0x48; // CUtlVectorEmbeddedNetworkVar<CDamageRecord>
}

namespace CCSPlayerController_InGameMoneyServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_bReceivesMoneyNextRound = 0x40; // bool
    constexpr std::ptrdiff_t m_iAccountMoneyEarnedForNextRound = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iAccount = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iStartAccount = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iTotalCashSpent = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iCashSpentThisRound = 0x54; // int32_t
}

namespace CCSPlayerController_InventoryServices { // CPlayerControllerComponent
    constexpr std::ptrdiff_t m_unMusicID = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_rank = 0x44; // MedalRank_t[6]
    constexpr std::ptrdiff_t m_nPersonaDataPublicLevel = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsLeader = 0x60; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsTeacher = 0x64; // int32_t
    constexpr std::ptrdiff_t m_nPersonaDataPublicCommendsFriendly = 0x68; // int32_t
    constexpr std::ptrdiff_t m_unEquippedPlayerSprayIDs = 0xF48; // uint32_t[1]
    constexpr std::ptrdiff_t m_vecServerAuthoritativeWeaponSlots = 0xF50; // CUtlVectorEmbeddedNetworkVar<ServerAuthoritativeWeaponSlot_t>
}

namespace CCSPlayerPawn { // CCSPlayerPawnBase
    constexpr std::ptrdiff_t m_pBulletServices = 0x1550; // CCSPlayer_BulletServices*
    constexpr std::ptrdiff_t m_pHostageServices = 0x1558; // CCSPlayer_HostageServices*
    constexpr std::ptrdiff_t m_pBuyServices = 0x1560; // CCSPlayer_BuyServices*
    constexpr std::ptrdiff_t m_pActionTrackingServices = 0x1568; // CCSPlayer_ActionTrackingServices*
    constexpr std::ptrdiff_t m_pRadioServices = 0x1570; // CCSPlayer_RadioServices*
    constexpr std::ptrdiff_t m_pDamageReactServices = 0x1578; // CCSPlayer_DamageReactServices*
    constexpr std::ptrdiff_t m_nCharacterDefIndex = 0x1580; // uint16_t
    constexpr std::ptrdiff_t m_hPreviousModel = 0x1588; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_bHasFemaleVoice = 0x1590; // bool
    constexpr std::ptrdiff_t m_strVOPrefix = 0x1598; // CUtlString
    constexpr std::ptrdiff_t m_szLastPlaceName = 0x15A0; // char[18]
    constexpr std::ptrdiff_t m_bInHostageResetZone = 0x1660; // bool
    constexpr std::ptrdiff_t m_bInBuyZone = 0x1661; // bool
    constexpr std::ptrdiff_t m_bWasInBuyZone = 0x1662; // bool
    constexpr std::ptrdiff_t m_bInHostageRescueZone = 0x1663; // bool
    constexpr std::ptrdiff_t m_bInBombZone = 0x1664; // bool
    constexpr std::ptrdiff_t m_bWasInHostageRescueZone = 0x1665; // bool
    constexpr std::ptrdiff_t m_iRetakesOffering = 0x1668; // int32_t
    constexpr std::ptrdiff_t m_iRetakesOfferingCard = 0x166C; // int32_t
    constexpr std::ptrdiff_t m_bRetakesHasDefuseKit = 0x1670; // bool
    constexpr std::ptrdiff_t m_bRetakesMVPLastRound = 0x1671; // bool
    constexpr std::ptrdiff_t m_iRetakesMVPBoostItem = 0x1674; // int32_t
    constexpr std::ptrdiff_t m_RetakesMVPBoostExtraUtility = 0x1678; // loadout_slot_t
    constexpr std::ptrdiff_t m_flHealthShotBoostExpirationTime = 0x167C; // GameTime_t
    constexpr std::ptrdiff_t m_flLandseconds = 0x1680; // float
    constexpr std::ptrdiff_t m_aimPunchAngle = 0x1684; // QAngle
    constexpr std::ptrdiff_t m_aimPunchAngleVel = 0x1690; // QAngle
    constexpr std::ptrdiff_t m_aimPunchTickBase = 0x169C; // int32_t
    constexpr std::ptrdiff_t m_aimPunchTickFraction = 0x16A0; // float
    constexpr std::ptrdiff_t m_aimPunchCache = 0x16A8; // CUtlVector<QAngle>
    constexpr std::ptrdiff_t m_bIsBuyMenuOpen = 0x16C0; // bool
    constexpr std::ptrdiff_t m_xLastHeadBoneTransform = 0x1C40; // CTransform
    constexpr std::ptrdiff_t m_bLastHeadBoneTransformIsValid = 0x1C60; // bool
    constexpr std::ptrdiff_t m_lastLandTime = 0x1C64; // GameTime_t
    constexpr std::ptrdiff_t m_bOnGroundLastTick = 0x1C68; // bool
    constexpr std::ptrdiff_t m_iPlayerLocked = 0x1C6C; // int32_t
    constexpr std::ptrdiff_t m_flTimeOfLastInjury = 0x1C74; // GameTime_t
    constexpr std::ptrdiff_t m_flNextSprayDecalTime = 0x1C78; // GameTime_t
    constexpr std::ptrdiff_t m_bNextSprayDecalTimeExpedited = 0x1C7C; // bool
    constexpr std::ptrdiff_t m_nRagdollDamageBone = 0x1C80; // int32_t
    constexpr std::ptrdiff_t m_vRagdollDamageForce = 0x1C84; // Vector
    constexpr std::ptrdiff_t m_vRagdollDamagePosition = 0x1C90; // Vector
    constexpr std::ptrdiff_t m_szRagdollDamageWeaponName = 0x1C9C; // char[64]
    constexpr std::ptrdiff_t m_bRagdollDamageHeadshot = 0x1CDC; // bool
    constexpr std::ptrdiff_t m_vRagdollServerOrigin = 0x1CE0; // Vector
    constexpr std::ptrdiff_t m_EconGloves = 0x1CF0; // CEconItemView
    constexpr std::ptrdiff_t m_qDeathEyeAngles = 0x1F68; // QAngle
    constexpr std::ptrdiff_t m_bSkipOneHeadConstraintUpdate = 0x1F74; // bool
}

namespace CCSPlayerPawnBase { // CBasePlayerPawn
    constexpr std::ptrdiff_t m_CTouchExpansionComponent = 0xB68; // CTouchExpansionComponent
    constexpr std::ptrdiff_t m_pPingServices = 0xBB8; // CCSPlayer_PingServices*
    constexpr std::ptrdiff_t m_pViewModelServices = 0xBC0; // CPlayer_ViewModelServices*
    constexpr std::ptrdiff_t m_iDisplayHistoryBits = 0xBC8; // uint32_t
    constexpr std::ptrdiff_t m_flLastAttackedTeammate = 0xBCC; // float
    constexpr std::ptrdiff_t m_hOriginalController = 0xBD0; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_blindUntilTime = 0xBD4; // GameTime_t
    constexpr std::ptrdiff_t m_blindStartTime = 0xBD8; // GameTime_t
    constexpr std::ptrdiff_t m_allowAutoFollowTime = 0xBDC; // GameTime_t
    constexpr std::ptrdiff_t m_entitySpottedState = 0xBE0; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xBF8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerState = 0xBFC; // CSPlayerState
    constexpr std::ptrdiff_t m_chickenIdleSoundTimer = 0xC08; // CountdownTimer
    constexpr std::ptrdiff_t m_chickenJumpSoundTimer = 0xC20; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastBookmarkedPosition = 0xCD8; // Vector
    constexpr std::ptrdiff_t m_flLastDistanceTraveledNotice = 0xCE4; // float
    constexpr std::ptrdiff_t m_flAccumulatedDistanceTraveled = 0xCE8; // float
    constexpr std::ptrdiff_t m_flLastFriendlyFireDamageReductionRatio = 0xCEC; // float
    constexpr std::ptrdiff_t m_bRespawning = 0xCF0; // bool
    constexpr std::ptrdiff_t m_nLastPickupPriority = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flLastPickupPriorityTime = 0xCF8; // float
    constexpr std::ptrdiff_t m_bIsScoped = 0xCFC; // bool
    constexpr std::ptrdiff_t m_bIsWalking = 0xCFD; // bool
    constexpr std::ptrdiff_t m_bResumeZoom = 0xCFE; // bool
    constexpr std::ptrdiff_t m_bIsDefusing = 0xCFF; // bool
    constexpr std::ptrdiff_t m_bIsGrabbingHostage = 0xD00; // bool
    constexpr std::ptrdiff_t m_iBlockingUseActionInProgress = 0xD04; // CSPlayerBlockingUseAction_t
    constexpr std::ptrdiff_t m_fImmuneToGunGameDamageTime = 0xD08; // GameTime_t
    constexpr std::ptrdiff_t m_bGunGameImmunity = 0xD0C; // bool
    constexpr std::ptrdiff_t m_fMolotovDamageTime = 0xD10; // float
    constexpr std::ptrdiff_t m_bHasMovedSinceSpawn = 0xD14; // bool
    constexpr std::ptrdiff_t m_bCanMoveDuringFreezePeriod = 0xD15; // bool
    constexpr std::ptrdiff_t m_flGuardianTooFarDistFrac = 0xD18; // float
    constexpr std::ptrdiff_t m_flNextGuardianTooFarHurtTime = 0xD1C; // float
    constexpr std::ptrdiff_t m_flDetectedByEnemySensorTime = 0xD20; // GameTime_t
    constexpr std::ptrdiff_t m_flDealtDamageToEnemyMostRecentTimestamp = 0xD24; // float
    constexpr std::ptrdiff_t m_flLastEquippedHelmetTime = 0xD28; // GameTime_t
    constexpr std::ptrdiff_t m_flLastEquippedArmorTime = 0xD2C; // GameTime_t
    constexpr std::ptrdiff_t m_nHeavyAssaultSuitCooldownRemaining = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_bResetArmorNextSpawn = 0xD34; // bool
    constexpr std::ptrdiff_t m_flLastBumpMineBumpTime = 0xD38; // GameTime_t
    constexpr std::ptrdiff_t m_flEmitSoundTime = 0xD3C; // GameTime_t
    constexpr std::ptrdiff_t m_iNumSpawns = 0xD40; // int32_t
    constexpr std::ptrdiff_t m_iShouldHaveCash = 0xD44; // int32_t
    constexpr std::ptrdiff_t m_bInvalidSteamLogonDelayed = 0xD48; // bool
    constexpr std::ptrdiff_t m_flLastAction = 0xD4C; // GameTime_t
    constexpr std::ptrdiff_t m_flNameChangeHistory = 0xD50; // float[5]
    constexpr std::ptrdiff_t m_fLastGivenDefuserTime = 0xD64; // float
    constexpr std::ptrdiff_t m_fLastGivenBombTime = 0xD68; // float
    constexpr std::ptrdiff_t m_bHasNightVision = 0xD6C; // bool
    constexpr std::ptrdiff_t m_bNightVisionOn = 0xD6D; // bool
    constexpr std::ptrdiff_t m_fNextRadarUpdateTime = 0xD70; // float
    constexpr std::ptrdiff_t m_flLastMoneyUpdateTime = 0xD74; // float
    constexpr std::ptrdiff_t m_MenuStringBuffer = 0xD78; // char[1024]
    constexpr std::ptrdiff_t m_fIntroCamTime = 0x1178; // float
    constexpr std::ptrdiff_t m_nMyCollisionGroup = 0x117C; // int32_t
    constexpr std::ptrdiff_t m_bInNoDefuseArea = 0x1180; // bool
    constexpr std::ptrdiff_t m_bKilledByTaser = 0x1181; // bool
    constexpr std::ptrdiff_t m_iMoveState = 0x1184; // int32_t
    constexpr std::ptrdiff_t m_grenadeParameterStashTime = 0x1188; // GameTime_t
    constexpr std::ptrdiff_t m_bGrenadeParametersStashed = 0x118C; // bool
    constexpr std::ptrdiff_t m_angStashedShootAngles = 0x1190; // QAngle
    constexpr std::ptrdiff_t m_vecStashedGrenadeThrowPosition = 0x119C; // Vector
    constexpr std::ptrdiff_t m_vecStashedVelocity = 0x11A8; // Vector
    constexpr std::ptrdiff_t m_angShootAngleHistory = 0x11B4; // QAngle[2]
    constexpr std::ptrdiff_t m_vecThrowPositionHistory = 0x11CC; // Vector[2]
    constexpr std::ptrdiff_t m_vecVelocityHistory = 0x11E4; // Vector[2]
    constexpr std::ptrdiff_t m_bDiedAirborne = 0x11FC; // bool
    constexpr std::ptrdiff_t m_iBombSiteIndex = 0x1200; // CEntityIndex
    constexpr std::ptrdiff_t m_nWhichBombZone = 0x1204; // int32_t
    constexpr std::ptrdiff_t m_bInBombZoneTrigger = 0x1208; // bool
    constexpr std::ptrdiff_t m_bWasInBombZoneTrigger = 0x1209; // bool
    constexpr std::ptrdiff_t m_iDirection = 0x120C; // int32_t
    constexpr std::ptrdiff_t m_iShotsFired = 0x1210; // int32_t
    constexpr std::ptrdiff_t m_ArmorValue = 0x1214; // int32_t
    constexpr std::ptrdiff_t m_flFlinchStack = 0x1218; // float
    constexpr std::ptrdiff_t m_flVelocityModifier = 0x121C; // float
    constexpr std::ptrdiff_t m_flHitHeading = 0x1220; // float
    constexpr std::ptrdiff_t m_nHitBodyPart = 0x1224; // int32_t
    constexpr std::ptrdiff_t m_iHostagesKilled = 0x1228; // int32_t
    constexpr std::ptrdiff_t m_vecTotalBulletForce = 0x122C; // Vector
    constexpr std::ptrdiff_t m_flFlashDuration = 0x1238; // float
    constexpr std::ptrdiff_t m_flFlashMaxAlpha = 0x123C; // float
    constexpr std::ptrdiff_t m_flProgressBarStartTime = 0x1240; // float
    constexpr std::ptrdiff_t m_iProgressBarDuration = 0x1244; // int32_t
    constexpr std::ptrdiff_t m_bWaitForNoAttack = 0x1248; // bool
    constexpr std::ptrdiff_t m_flLowerBodyYawTarget = 0x124C; // float
    constexpr std::ptrdiff_t m_bStrafing = 0x1250; // bool
    constexpr std::ptrdiff_t m_lastStandingPos = 0x1254; // Vector
    constexpr std::ptrdiff_t m_ignoreLadderJumpTime = 0x1260; // float
    constexpr std::ptrdiff_t m_ladderSurpressionTimer = 0x1268; // CountdownTimer
    constexpr std::ptrdiff_t m_lastLadderNormal = 0x1280; // Vector
    constexpr std::ptrdiff_t m_lastLadderPos = 0x128C; // Vector
    constexpr std::ptrdiff_t m_thirdPersonHeading = 0x1298; // QAngle
    constexpr std::ptrdiff_t m_flSlopeDropOffset = 0x12A4; // float
    constexpr std::ptrdiff_t m_flSlopeDropHeight = 0x12A8; // float
    constexpr std::ptrdiff_t m_vHeadConstraintOffset = 0x12AC; // Vector
    constexpr std::ptrdiff_t m_iLastWeaponFireUsercmd = 0x12C0; // int32_t
    constexpr std::ptrdiff_t m_angEyeAngles = 0x12C4; // QAngle
    constexpr std::ptrdiff_t m_bVCollisionInitted = 0x12D0; // bool
    constexpr std::ptrdiff_t m_storedSpawnPosition = 0x12D4; // Vector
    constexpr std::ptrdiff_t m_storedSpawnAngle = 0x12E0; // QAngle
    constexpr std::ptrdiff_t m_bIsSpawning = 0x12EC; // bool
    constexpr std::ptrdiff_t m_bHideTargetID = 0x12ED; // bool
    constexpr std::ptrdiff_t m_nNumDangerZoneDamageHits = 0x12F0; // int32_t
    constexpr std::ptrdiff_t m_bHud_MiniScoreHidden = 0x12F4; // bool
    constexpr std::ptrdiff_t m_bHud_RadarHidden = 0x12F5; // bool
    constexpr std::ptrdiff_t m_nLastKillerIndex = 0x12F8; // CEntityIndex
    constexpr std::ptrdiff_t m_nLastConcurrentKilled = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_nDeathCamMusic = 0x1300; // int32_t
    constexpr std::ptrdiff_t m_iAddonBits = 0x1304; // int32_t
    constexpr std::ptrdiff_t m_iPrimaryAddon = 0x1308; // int32_t
    constexpr std::ptrdiff_t m_iSecondaryAddon = 0x130C; // int32_t
    constexpr std::ptrdiff_t m_currentDeafnessFilter = 0x1310; // CUtlStringToken
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisSpawn = 0x1314; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesKilledThisRound = 0x1318; // int32_t
    constexpr std::ptrdiff_t m_NumEnemiesAtRoundStart = 0x131C; // int32_t
    constexpr std::ptrdiff_t m_wasNotKilledNaturally = 0x1320; // bool
    constexpr std::ptrdiff_t m_vecPlayerPatchEconIndices = 0x1324; // uint32_t[5]
    constexpr std::ptrdiff_t m_iDeathFlags = 0x1338; // int32_t
    constexpr std::ptrdiff_t m_hPet = 0x133C; // CHandle<CChicken>
    constexpr std::ptrdiff_t m_unCurrentEquipmentValue = 0x1508; // uint16_t
    constexpr std::ptrdiff_t m_unRoundStartEquipmentValue = 0x150A; // uint16_t
    constexpr std::ptrdiff_t m_unFreezetimeEndEquipmentValue = 0x150C; // uint16_t
    constexpr std::ptrdiff_t m_nSurvivalTeamNumber = 0x1510; // int32_t
    constexpr std::ptrdiff_t m_bHasDeathInfo = 0x1514; // bool
    constexpr std::ptrdiff_t m_flDeathInfoTime = 0x1518; // float
    constexpr std::ptrdiff_t m_vecDeathInfoOrigin = 0x151C; // Vector
    constexpr std::ptrdiff_t m_bKilledByHeadshot = 0x1528; // bool
    constexpr std::ptrdiff_t m_LastHitBox = 0x152C; // int32_t
    constexpr std::ptrdiff_t m_LastHealth = 0x1530; // int32_t
    constexpr std::ptrdiff_t m_flLastCollisionCeiling = 0x1534; // float
    constexpr std::ptrdiff_t m_flLastCollisionCeilingChangeTime = 0x1538; // float
    constexpr std::ptrdiff_t m_pBot = 0x1540; // CCSBot*
    constexpr std::ptrdiff_t m_bBotAllowActive = 0x1548; // bool
    constexpr std::ptrdiff_t m_bCommittingSuicideOnTeamChange = 0x1549; // bool
}

namespace CCSPlayerResource { // CBaseEntity
    constexpr std::ptrdiff_t m_bHostageAlive = 0x4B0; // bool[12]
    constexpr std::ptrdiff_t m_isHostageFollowingSomeone = 0x4BC; // bool[12]
    constexpr std::ptrdiff_t m_iHostageEntityIDs = 0x4C8; // CEntityIndex[12]
    constexpr std::ptrdiff_t m_bombsiteCenterA = 0x4F8; // Vector
    constexpr std::ptrdiff_t m_bombsiteCenterB = 0x504; // Vector
    constexpr std::ptrdiff_t m_hostageRescueX = 0x510; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueY = 0x520; // int32_t[4]
    constexpr std::ptrdiff_t m_hostageRescueZ = 0x530; // int32_t[4]
    constexpr std::ptrdiff_t m_bEndMatchNextMapAllVoted = 0x540; // bool
    constexpr std::ptrdiff_t m_foundGoalPositions = 0x541; // bool
}

namespace CCSPlayer_ActionTrackingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hLastWeaponBeforeC4AutoSwitch = 0x208; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bIsRescuing = 0x23C; // bool
    constexpr std::ptrdiff_t m_weaponPurchasesThisMatch = 0x240; // WeaponPurchaseTracker_t
    constexpr std::ptrdiff_t m_weaponPurchasesThisRound = 0x298; // WeaponPurchaseTracker_t
}

namespace CCSPlayer_BulletServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_totalHitsOnServer = 0x40; // int32_t
}

namespace CCSPlayer_BuyServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecSellbackPurchaseEntries = 0xC8; // CUtlVectorEmbeddedNetworkVar<SellbackPurchaseEntry_t>
}

namespace CCSPlayer_CameraServices { // CCSPlayerBase_CameraServices
}

namespace CCSPlayer_DamageReactServices { // CPlayerPawnComponent
}

namespace CCSPlayer_HostageServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_hCarriedHostage = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCarriedHostageProp = 0x44; // CHandle<CBaseEntity>
}

namespace CCSPlayer_ItemServices { // CPlayer_ItemServices
    constexpr std::ptrdiff_t m_bHasDefuser = 0x40; // bool
    constexpr std::ptrdiff_t m_bHasHelmet = 0x41; // bool
    constexpr std::ptrdiff_t m_bHasHeavyArmor = 0x42; // bool
}

namespace CCSPlayer_MovementServices { // CPlayer_MovementServices_Humanoid
    constexpr std::ptrdiff_t m_flMaxFallVelocity = 0x220; // float
    constexpr std::ptrdiff_t m_vecLadderNormal = 0x224; // Vector
    constexpr std::ptrdiff_t m_nLadderSurfacePropIndex = 0x230; // int32_t
    constexpr std::ptrdiff_t m_flDuckAmount = 0x234; // float
    constexpr std::ptrdiff_t m_flDuckSpeed = 0x238; // float
    constexpr std::ptrdiff_t m_bDuckOverride = 0x23C; // bool
    constexpr std::ptrdiff_t m_bDesiresDuck = 0x23D; // bool
    constexpr std::ptrdiff_t m_flDuckOffset = 0x240; // float
    constexpr std::ptrdiff_t m_nDuckTimeMsecs = 0x244; // uint32_t
    constexpr std::ptrdiff_t m_nDuckJumpTimeMsecs = 0x248; // uint32_t
    constexpr std::ptrdiff_t m_nJumpTimeMsecs = 0x24C; // uint32_t
    constexpr std::ptrdiff_t m_flLastDuckTime = 0x250; // float
    constexpr std::ptrdiff_t m_vecLastPositionAtFullCrouchSpeed = 0x260; // Vector2D
    constexpr std::ptrdiff_t m_duckUntilOnGround = 0x268; // bool
    constexpr std::ptrdiff_t m_bHasWalkMovedSinceLastJump = 0x269; // bool
    constexpr std::ptrdiff_t m_bInStuckTest = 0x26A; // bool
    constexpr std::ptrdiff_t m_flStuckCheckTime = 0x278; // float[64][2]
    constexpr std::ptrdiff_t m_nTraceCount = 0x478; // int32_t
    constexpr std::ptrdiff_t m_StuckLast = 0x47C; // int32_t
    constexpr std::ptrdiff_t m_bSpeedCropped = 0x480; // bool
    constexpr std::ptrdiff_t m_nOldWaterLevel = 0x484; // int32_t
    constexpr std::ptrdiff_t m_flWaterEntryTime = 0x488; // float
    constexpr std::ptrdiff_t m_vecForward = 0x48C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x498; // Vector
    constexpr std::ptrdiff_t m_vecUp = 0x4A4; // Vector
    constexpr std::ptrdiff_t m_vecPreviouslyPredictedOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_bMadeFootstepNoise = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iFootsteps = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bOldJumpPressed = 0x4C4; // bool
    constexpr std::ptrdiff_t m_flJumpPressedTime = 0x4C8; // float
    constexpr std::ptrdiff_t m_flJumpUntil = 0x4CC; // float
    constexpr std::ptrdiff_t m_flJumpVel = 0x4D0; // float
    constexpr std::ptrdiff_t m_fStashGrenadeParameterWhen = 0x4D4; // GameTime_t
    constexpr std::ptrdiff_t m_nButtonDownMaskPrev = 0x4D8; // uint64_t
    constexpr std::ptrdiff_t m_flOffsetTickCompleteTime = 0x4E0; // float
    constexpr std::ptrdiff_t m_flOffsetTickStashedSpeed = 0x4E4; // float
    constexpr std::ptrdiff_t m_flStamina = 0x4E8; // float
    constexpr std::ptrdiff_t m_flHeightAtJumpStart = 0x4EC; // float
    constexpr std::ptrdiff_t m_flMaxJumpHeightThisJump = 0x4F0; // float
}

namespace CCSPlayer_PingServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_flPlayerPingTokens = 0x40; // GameTime_t[5]
    constexpr std::ptrdiff_t m_hPlayerPing = 0x54; // CHandle<CBaseEntity>
}

namespace CCSPlayer_RadioServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_flGotHostageTalkTimer = 0x40; // GameTime_t
    constexpr std::ptrdiff_t m_flDefusingTalkTimer = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flC4PlantTalkTimer = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flRadioTokenSlots = 0x4C; // GameTime_t[3]
    constexpr std::ptrdiff_t m_bIgnoreRadio = 0x58; // bool
}

namespace CCSPlayer_UseServices { // CPlayer_UseServices
    constexpr std::ptrdiff_t m_hLastKnownUseEntity = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flLastUseTimeStamp = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartedHoldingUse = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeLastUsedWindow = 0x4C; // GameTime_t
}

namespace CCSPlayer_ViewModelServices { // CPlayer_ViewModelServices
    constexpr std::ptrdiff_t m_hViewModel = 0x40; // CHandle<CBaseViewModel>[3]
}

namespace CCSPlayer_WaterServices { // CPlayer_WaterServices
    constexpr std::ptrdiff_t m_NextDrownDamageTime = 0x40; // float
    constexpr std::ptrdiff_t m_nDrownDmgRate = 0x44; // int32_t
    constexpr std::ptrdiff_t m_AirFinishedTime = 0x48; // GameTime_t
    constexpr std::ptrdiff_t m_flWaterJumpTime = 0x4C; // float
    constexpr std::ptrdiff_t m_vecWaterJumpVel = 0x50; // Vector
    constexpr std::ptrdiff_t m_flSwimSoundTime = 0x5C; // float
}

namespace CCSPlayer_WeaponServices { // CPlayer_WeaponServices
    constexpr std::ptrdiff_t m_flNextAttack = 0xB0; // GameTime_t
    constexpr std::ptrdiff_t m_bIsLookingAtWeapon = 0xB4; // bool
    constexpr std::ptrdiff_t m_bIsHoldingLookAtWeapon = 0xB5; // bool
    constexpr std::ptrdiff_t m_hSavedWeapon = 0xB8; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_nTimeToMelee = 0xBC; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSecondary = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nTimeToPrimary = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nTimeToSniperRifle = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_bIsBeingGivenItem = 0xCC; // bool
    constexpr std::ptrdiff_t m_bIsPickingUpItemWithUse = 0xCD; // bool
    constexpr std::ptrdiff_t m_bPickedUpWeapon = 0xCE; // bool
}

namespace CCSPulseServerFuncs_Globals {
}

namespace CCSSprite { // CSprite
}

namespace CCSTeam { // CTeam
    constexpr std::ptrdiff_t m_nLastRecievedShorthandedRoundBonus = 0x568; // int32_t
    constexpr std::ptrdiff_t m_nShorthandedRoundBonusStartRound = 0x56C; // int32_t
    constexpr std::ptrdiff_t m_bSurrendered = 0x570; // bool
    constexpr std::ptrdiff_t m_szTeamMatchStat = 0x571; // char[512]
    constexpr std::ptrdiff_t m_numMapVictories = 0x774; // int32_t
    constexpr std::ptrdiff_t m_scoreFirstHalf = 0x778; // int32_t
    constexpr std::ptrdiff_t m_scoreSecondHalf = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_scoreOvertime = 0x780; // int32_t
    constexpr std::ptrdiff_t m_szClanTeamname = 0x784; // char[129]
    constexpr std::ptrdiff_t m_iClanID = 0x808; // uint32_t
    constexpr std::ptrdiff_t m_szTeamFlagImage = 0x80C; // char[8]
    constexpr std::ptrdiff_t m_szTeamLogoImage = 0x814; // char[8]
    constexpr std::ptrdiff_t m_flNextResourceTime = 0x81C; // float
    constexpr std::ptrdiff_t m_iLastUpdateSentAt = 0x820; // int32_t
}

namespace CCSWeaponBase { // CBasePlayerWeapon
    constexpr std::ptrdiff_t m_bRemoveable = 0xC88; // bool
    constexpr std::ptrdiff_t m_flFireSequenceStartTime = 0xC90; // float
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeChange = 0xC94; // int32_t
    constexpr std::ptrdiff_t m_nFireSequenceStartTimeAck = 0xC98; // int32_t
    constexpr std::ptrdiff_t m_bPlayerFireEventIsPrimary = 0xC9C; // bool
    constexpr std::ptrdiff_t m_seqIdle = 0xCA0; // HSequence
    constexpr std::ptrdiff_t m_seqFirePrimary = 0xCA4; // HSequence
    constexpr std::ptrdiff_t m_seqFireSecondary = 0xCA8; // HSequence
    constexpr std::ptrdiff_t m_thirdPersonFireSequences = 0xCB0; // CUtlVector<HSequence>
    constexpr std::ptrdiff_t m_hCurrentThirdPersonSequence = 0xCC8; // HSequence
    constexpr std::ptrdiff_t m_nSilencerBoneIndex = 0xCCC; // int32_t
    constexpr std::ptrdiff_t m_thirdPersonSequences = 0xCD0; // HSequence[6]
    constexpr std::ptrdiff_t m_bPlayerAmmoStockOnPickup = 0xCF0; // bool
    constexpr std::ptrdiff_t m_bRequireUseToTouch = 0xCF1; // bool
    constexpr std::ptrdiff_t m_iState = 0xCF4; // CSWeaponState_t
    constexpr std::ptrdiff_t m_flLastTimeInAir = 0xCF8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastDeployTime = 0xCFC; // GameTime_t
    constexpr std::ptrdiff_t m_nViewModelIndex = 0xD00; // uint32_t
    constexpr std::ptrdiff_t m_bReloadsWithClips = 0xD04; // bool
    constexpr std::ptrdiff_t m_flTimeWeaponIdle = 0xD20; // GameTime_t
    constexpr std::ptrdiff_t m_bFireOnEmpty = 0xD24; // bool
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xD28; // CEntityIOOutput
    constexpr std::ptrdiff_t m_weaponMode = 0xD50; // CSWeaponMode
    constexpr std::ptrdiff_t m_flTurningInaccuracyDelta = 0xD54; // float
    constexpr std::ptrdiff_t m_vecTurningInaccuracyEyeDirLast = 0xD58; // Vector
    constexpr std::ptrdiff_t m_flTurningInaccuracy = 0xD64; // float
    constexpr std::ptrdiff_t m_fAccuracyPenalty = 0xD68; // float
    constexpr std::ptrdiff_t m_flLastAccuracyUpdateTime = 0xD6C; // GameTime_t
    constexpr std::ptrdiff_t m_fAccuracySmoothedForZoom = 0xD70; // float
    constexpr std::ptrdiff_t m_fScopeZoomEndTime = 0xD74; // GameTime_t
    constexpr std::ptrdiff_t m_iRecoilIndex = 0xD78; // int32_t
    constexpr std::ptrdiff_t m_flRecoilIndex = 0xD7C; // float
    constexpr std::ptrdiff_t m_bBurstMode = 0xD80; // bool
    constexpr std::ptrdiff_t m_flPostponeFireReadyTime = 0xD84; // GameTime_t
    constexpr std::ptrdiff_t m_bInReload = 0xD88; // bool
    constexpr std::ptrdiff_t m_bReloadVisuallyComplete = 0xD89; // bool
    constexpr std::ptrdiff_t m_flDroppedAtTime = 0xD8C; // GameTime_t
    constexpr std::ptrdiff_t m_bIsHauledBack = 0xD90; // bool
    constexpr std::ptrdiff_t m_bSilencerOn = 0xD91; // bool
    constexpr std::ptrdiff_t m_flTimeSilencerSwitchComplete = 0xD94; // GameTime_t
    constexpr std::ptrdiff_t m_iOriginalTeamNumber = 0xD98; // int32_t
    constexpr std::ptrdiff_t m_flNextAttackRenderTimeOffset = 0xD9C; // float
    constexpr std::ptrdiff_t m_bCanBePickedUp = 0xDB0; // bool
    constexpr std::ptrdiff_t m_bUseCanOverrideNextOwnerTouchTime = 0xDB1; // bool
    constexpr std::ptrdiff_t m_nextOwnerTouchTime = 0xDB4; // GameTime_t
    constexpr std::ptrdiff_t m_nextPrevOwnerTouchTime = 0xDB8; // GameTime_t
    constexpr std::ptrdiff_t m_hPrevOwner = 0xDBC; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_nDropTick = 0xDC0; // GameTick_t
    constexpr std::ptrdiff_t m_donated = 0xDE4; // bool
    constexpr std::ptrdiff_t m_fLastShotTime = 0xDE8; // GameTime_t
    constexpr std::ptrdiff_t m_bWasOwnedByCT = 0xDEC; // bool
    constexpr std::ptrdiff_t m_bWasOwnedByTerrorist = 0xDED; // bool
    constexpr std::ptrdiff_t m_bFiredOutOfAmmoEvent = 0xDEE; // bool
    constexpr std::ptrdiff_t m_numRemoveUnownedWeaponThink = 0xDF0; // int32_t
    constexpr std::ptrdiff_t m_IronSightController = 0xDF8; // CIronSightController
    constexpr std::ptrdiff_t m_iIronSightMode = 0xE10; // int32_t
    constexpr std::ptrdiff_t m_flLastLOSTraceFailureTime = 0xE14; // GameTime_t
    constexpr std::ptrdiff_t m_iNumEmptyAttacks = 0xE18; // int32_t
}

namespace CCSWeaponBaseGun { // CCSWeaponBase
    constexpr std::ptrdiff_t m_zoomLevel = 0xE20; // int32_t
    constexpr std::ptrdiff_t m_iBurstShotsRemaining = 0xE24; // int32_t
    constexpr std::ptrdiff_t m_silencedModelIndex = 0xE30; // int32_t
    constexpr std::ptrdiff_t m_inPrecache = 0xE34; // bool
    constexpr std::ptrdiff_t m_bNeedsBoltAction = 0xE35; // bool
    constexpr std::ptrdiff_t m_bSkillReloadAvailable = 0xE36; // bool
    constexpr std::ptrdiff_t m_bSkillReloadLiftedReloadKey = 0xE37; // bool
    constexpr std::ptrdiff_t m_bSkillBoltInterruptAvailable = 0xE38; // bool
    constexpr std::ptrdiff_t m_bSkillBoltLiftedFireKey = 0xE39; // bool
}

namespace CCSWeaponBaseVData { // CBasePlayerWeaponVData
    constexpr std::ptrdiff_t m_WeaponType = 0x240; // CSWeaponType
    constexpr std::ptrdiff_t m_WeaponCategory = 0x244; // CSWeaponCategory
    constexpr std::ptrdiff_t m_szViewModel = 0x248; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szPlayerModel = 0x328; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szWorldDroppedModel = 0x408; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szAimsightLensMaskModel = 0x4E8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szMagazineModel = 0x5C8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeCModel>>
    constexpr std::ptrdiff_t m_szHeatEffect = 0x6A8; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szEjectBrassEffect = 0x788; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashParticleAlt = 0x868; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticle = 0x948; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szMuzzleFlashThirdPersonParticleAlt = 0xA28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_szTracerParticle = 0xB08; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_GearSlot = 0xBE8; // gear_slot_t
    constexpr std::ptrdiff_t m_GearSlotPosition = 0xBEC; // int32_t
    constexpr std::ptrdiff_t m_DefaultLoadoutSlot = 0xBF0; // loadout_slot_t
    constexpr std::ptrdiff_t m_sWrongTeamMsg = 0xBF8; // CUtlString
    constexpr std::ptrdiff_t m_nPrice = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nKillAward = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_nPrimaryReserveAmmoMax = 0xC08; // int32_t
    constexpr std::ptrdiff_t m_nSecondaryReserveAmmoMax = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_bMeleeWeapon = 0xC10; // bool
    constexpr std::ptrdiff_t m_bHasBurstMode = 0xC11; // bool
    constexpr std::ptrdiff_t m_bIsRevolver = 0xC12; // bool
    constexpr std::ptrdiff_t m_bCannotShootUnderwater = 0xC13; // bool
    constexpr std::ptrdiff_t m_szName = 0xC18; // CUtlString
    constexpr std::ptrdiff_t m_szAnimExtension = 0xC20; // CUtlString
    constexpr std::ptrdiff_t m_eSilencerType = 0xC28; // CSWeaponSilencerType
    constexpr std::ptrdiff_t m_nCrosshairMinDistance = 0xC2C; // int32_t
    constexpr std::ptrdiff_t m_nCrosshairDeltaDistance = 0xC30; // int32_t
    constexpr std::ptrdiff_t m_flCycleTime = 0xC34; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flMaxSpeed = 0xC3C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flSpread = 0xC44; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyCrouch = 0xC4C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyStand = 0xC54; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyJump = 0xC5C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLand = 0xC64; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyLadder = 0xC6C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyFire = 0xC74; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flInaccuracyMove = 0xC7C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngle = 0xC84; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilAngleVariance = 0xC8C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitude = 0xC94; // CFiringModeFloat
    constexpr std::ptrdiff_t m_flRecoilMagnitudeVariance = 0xC9C; // CFiringModeFloat
    constexpr std::ptrdiff_t m_nTracerFrequency = 0xCA4; // CFiringModeInt
    constexpr std::ptrdiff_t m_flInaccuracyJumpInitial = 0xCAC; // float
    constexpr std::ptrdiff_t m_flInaccuracyJumpApex = 0xCB0; // float
    constexpr std::ptrdiff_t m_flInaccuracyReload = 0xCB4; // float
    constexpr std::ptrdiff_t m_nRecoilSeed = 0xCB8; // int32_t
    constexpr std::ptrdiff_t m_nSpreadSeed = 0xCBC; // int32_t
    constexpr std::ptrdiff_t m_flTimeToIdleAfterFire = 0xCC0; // float
    constexpr std::ptrdiff_t m_flIdleInterval = 0xCC4; // float
    constexpr std::ptrdiff_t m_flAttackMovespeedFactor = 0xCC8; // float
    constexpr std::ptrdiff_t m_flHeatPerShot = 0xCCC; // float
    constexpr std::ptrdiff_t m_flInaccuracyPitchShift = 0xCD0; // float
    constexpr std::ptrdiff_t m_flInaccuracyAltSoundThreshold = 0xCD4; // float
    constexpr std::ptrdiff_t m_flBotAudibleRange = 0xCD8; // float
    constexpr std::ptrdiff_t m_szUseRadioSubtitle = 0xCE0; // CUtlString
    constexpr std::ptrdiff_t m_bUnzoomsAfterShot = 0xCE8; // bool
    constexpr std::ptrdiff_t m_bHideViewModelWhenZoomed = 0xCE9; // bool
    constexpr std::ptrdiff_t m_nZoomLevels = 0xCEC; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV1 = 0xCF0; // int32_t
    constexpr std::ptrdiff_t m_nZoomFOV2 = 0xCF4; // int32_t
    constexpr std::ptrdiff_t m_flZoomTime0 = 0xCF8; // float
    constexpr std::ptrdiff_t m_flZoomTime1 = 0xCFC; // float
    constexpr std::ptrdiff_t m_flZoomTime2 = 0xD00; // float
    constexpr std::ptrdiff_t m_flIronSightPullUpSpeed = 0xD04; // float
    constexpr std::ptrdiff_t m_flIronSightPutDownSpeed = 0xD08; // float
    constexpr std::ptrdiff_t m_flIronSightFOV = 0xD0C; // float
    constexpr std::ptrdiff_t m_flIronSightPivotForward = 0xD10; // float
    constexpr std::ptrdiff_t m_flIronSightLooseness = 0xD14; // float
    constexpr std::ptrdiff_t m_angPivotAngle = 0xD18; // QAngle
    constexpr std::ptrdiff_t m_vecIronSightEyePos = 0xD24; // Vector
    constexpr std::ptrdiff_t m_nDamage = 0xD30; // int32_t
    constexpr std::ptrdiff_t m_flHeadshotMultiplier = 0xD34; // float
    constexpr std::ptrdiff_t m_flArmorRatio = 0xD38; // float
    constexpr std::ptrdiff_t m_flPenetration = 0xD3C; // float
    constexpr std::ptrdiff_t m_flRange = 0xD40; // float
    constexpr std::ptrdiff_t m_flRangeModifier = 0xD44; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierLarge = 0xD48; // float
    constexpr std::ptrdiff_t m_flFlinchVelocityModifierSmall = 0xD4C; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouch = 0xD50; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStand = 0xD54; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeCrouchFinal = 0xD58; // float
    constexpr std::ptrdiff_t m_flRecoveryTimeStandFinal = 0xD5C; // float
    constexpr std::ptrdiff_t m_nRecoveryTransitionStartBullet = 0xD60; // int32_t
    constexpr std::ptrdiff_t m_nRecoveryTransitionEndBullet = 0xD64; // int32_t
    constexpr std::ptrdiff_t m_flThrowVelocity = 0xD68; // float
    constexpr std::ptrdiff_t m_vSmokeColor = 0xD6C; // Vector
    constexpr std::ptrdiff_t m_szAnimClass = 0xD78; // CUtlString
}

namespace CChangeLevel { // CBaseTrigger
    constexpr std::ptrdiff_t m_sMapName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_sLandmarkName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_OnChangeLevel = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bTouched = 0x8E0; // bool
    constexpr std::ptrdiff_t m_bNoTouch = 0x8E1; // bool
    constexpr std::ptrdiff_t m_bNewChapter = 0x8E2; // bool
    constexpr std::ptrdiff_t m_bOnChangeLevelFired = 0x8E3; // bool
}

namespace CChicken { // CDynamicProp
    constexpr std::ptrdiff_t m_AttributeManager = 0xB28; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xDF0; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xDF4; // uint32_t
    constexpr std::ptrdiff_t m_updateTimer = 0xDF8; // CountdownTimer
    constexpr std::ptrdiff_t m_stuckAnchor = 0xE10; // Vector
    constexpr std::ptrdiff_t m_stuckTimer = 0xE20; // CountdownTimer
    constexpr std::ptrdiff_t m_collisionStuckTimer = 0xE38; // CountdownTimer
    constexpr std::ptrdiff_t m_isOnGround = 0xE50; // bool
    constexpr std::ptrdiff_t m_vFallVelocity = 0xE54; // Vector
    constexpr std::ptrdiff_t m_activity = 0xE60; // ChickenActivity
    constexpr std::ptrdiff_t m_activityTimer = 0xE68; // CountdownTimer
    constexpr std::ptrdiff_t m_turnRate = 0xE80; // float
    constexpr std::ptrdiff_t m_fleeFrom = 0xE84; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_moveRateThrottleTimer = 0xE88; // CountdownTimer
    constexpr std::ptrdiff_t m_startleTimer = 0xEA0; // CountdownTimer
    constexpr std::ptrdiff_t m_vocalizeTimer = 0xEB8; // CountdownTimer
    constexpr std::ptrdiff_t m_flWhenZombified = 0xED0; // GameTime_t
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xED4; // bool
    constexpr std::ptrdiff_t m_leader = 0xED8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_reuseTimer = 0xEE0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xEF8; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xF00; // CountdownTimer
    constexpr std::ptrdiff_t m_flLastJumpTime = 0xF18; // float
    constexpr std::ptrdiff_t m_bInJump = 0xF1C; // bool
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xF1D; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2F28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2F40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2FD0; // CountdownTimer
    constexpr std::ptrdiff_t m_vecPathGoal = 0x2FF0; // Vector
    constexpr std::ptrdiff_t m_flActiveFollowStartTime = 0x2FFC; // GameTime_t
    constexpr std::ptrdiff_t m_followMinuteTimer = 0x3000; // CountdownTimer
    constexpr std::ptrdiff_t m_vecLastEggPoopPosition = 0x3018; // Vector
    constexpr std::ptrdiff_t m_vecEggsPooped = 0x3028; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_BlockDirectionTimer = 0x3048; // CountdownTimer
}

namespace CCollisionProperty {
    constexpr std::ptrdiff_t m_collisionAttribute = 0x10; // VPhysicsCollisionAttribute_t
    constexpr std::ptrdiff_t m_vecMins = 0x40; // Vector
    constexpr std::ptrdiff_t m_vecMaxs = 0x4C; // Vector
    constexpr std::ptrdiff_t m_usSolidFlags = 0x5A; // uint8_t
    constexpr std::ptrdiff_t m_nSolidType = 0x5B; // SolidType_t
    constexpr std::ptrdiff_t m_triggerBloat = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nSurroundType = 0x5D; // SurroundingBoundsType_t
    constexpr std::ptrdiff_t m_CollisionGroup = 0x5E; // uint8_t
    constexpr std::ptrdiff_t m_nEnablePhysics = 0x5F; // uint8_t
    constexpr std::ptrdiff_t m_flBoundingRadius = 0x60; // float
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMins = 0x64; // Vector
    constexpr std::ptrdiff_t m_vecSpecifiedSurroundingMaxs = 0x70; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMaxs = 0x7C; // Vector
    constexpr std::ptrdiff_t m_vecSurroundingMins = 0x88; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter1 = 0x94; // Vector
    constexpr std::ptrdiff_t m_vCapsuleCenter2 = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flCapsuleRadius = 0xAC; // float
}

namespace CColorCorrection { // CBaseEntity
    constexpr std::ptrdiff_t m_flFadeInDuration = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeOutDuration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flStartFadeInWeight = 0x4B8; // float
    constexpr std::ptrdiff_t m_flStartFadeOutWeight = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTimeStartFadeIn = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeStartFadeOut = 0x4C4; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxWeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4CD; // bool
    constexpr std::ptrdiff_t m_bMaster = 0x4CE; // bool
    constexpr std::ptrdiff_t m_bClientSide = 0x4CF; // bool
    constexpr std::ptrdiff_t m_bExclusive = 0x4D0; // bool
    constexpr std::ptrdiff_t m_MinFalloff = 0x4D4; // float
    constexpr std::ptrdiff_t m_MaxFalloff = 0x4D8; // float
    constexpr std::ptrdiff_t m_flCurWeight = 0x4DC; // float
    constexpr std::ptrdiff_t m_netlookupFilename = 0x4E0; // char[512]
    constexpr std::ptrdiff_t m_lookupFilename = 0x6E0; // CUtlSymbolLarge
}

namespace CColorCorrectionVolume { // CBaseTrigger
    constexpr std::ptrdiff_t m_bEnabled = 0x8A8; // bool
    constexpr std::ptrdiff_t m_MaxWeight = 0x8AC; // float
    constexpr std::ptrdiff_t m_FadeDuration = 0x8B0; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8B4; // bool
    constexpr std::ptrdiff_t m_Weight = 0x8B8; // float
    constexpr std::ptrdiff_t m_lookupFilename = 0x8BC; // char[512]
    constexpr std::ptrdiff_t m_LastEnterWeight = 0xABC; // float
    constexpr std::ptrdiff_t m_LastEnterTime = 0xAC0; // GameTime_t
    constexpr std::ptrdiff_t m_LastExitWeight = 0xAC4; // float
    constexpr std::ptrdiff_t m_LastExitTime = 0xAC8; // GameTime_t
}

namespace CCommentaryAuto { // CBaseEntity
    constexpr std::ptrdiff_t m_OnCommentaryNewGame = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMidGame = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCommentaryMultiplayerSpawn = 0x500; // CEntityIOOutput
}

namespace CCommentarySystem {
    constexpr std::ptrdiff_t m_bCommentaryConvarsChanging = 0x11; // bool
    constexpr std::ptrdiff_t m_bCommentaryEnabledMidGame = 0x12; // bool
    constexpr std::ptrdiff_t m_flNextTeleportTime = 0x14; // GameTime_t
    constexpr std::ptrdiff_t m_iTeleportStage = 0x18; // int32_t
    constexpr std::ptrdiff_t m_bCheatState = 0x1C; // bool
    constexpr std::ptrdiff_t m_bIsFirstSpawnGroupToLoad = 0x1D; // bool
    constexpr std::ptrdiff_t m_hCurrentNode = 0x38; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hActiveCommentaryNode = 0x3C; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_hLastCommentaryNode = 0x40; // CHandle<CPointCommentaryNode>
    constexpr std::ptrdiff_t m_vecNodes = 0x48; // CUtlVector<CHandle<CPointCommentaryNode>>
}

namespace CCommentaryViewPosition { // CSprite
}

namespace CConstantForceController {
    constexpr std::ptrdiff_t m_linear = 0xC; // Vector
    constexpr std::ptrdiff_t m_angular = 0x18; // RotationVector
    constexpr std::ptrdiff_t m_linearSave = 0x24; // Vector
    constexpr std::ptrdiff_t m_angularSave = 0x30; // RotationVector
}

namespace CConstraintAnchor { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_massScale = 0x890; // float
}

namespace CCoopBonusCoin { // CDynamicProp
}

namespace CCopyRecipientFilter {
    constexpr std::ptrdiff_t m_Flags = 0x8; // int32_t
    constexpr std::ptrdiff_t m_Recipients = 0x10; // CUtlVector<CPlayerSlot>
}

namespace CCredits { // CPointEntity
    constexpr std::ptrdiff_t m_OnCreditsDone = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bRolledOutroCredits = 0x4D8; // bool
    constexpr std::ptrdiff_t m_flLogoLength = 0x4DC; // float
}

namespace CDEagle { // CCSWeaponBaseGun
}

namespace CDamageRecord {
    constexpr std::ptrdiff_t m_PlayerDamager = 0x28; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_PlayerRecipient = 0x2C; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_hPlayerControllerDamager = 0x30; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_hPlayerControllerRecipient = 0x34; // CHandle<CCSPlayerController>
    constexpr std::ptrdiff_t m_szPlayerDamagerName = 0x38; // CUtlString
    constexpr std::ptrdiff_t m_szPlayerRecipientName = 0x40; // CUtlString
    constexpr std::ptrdiff_t m_DamagerXuid = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_RecipientXuid = 0x50; // uint64_t
    constexpr std::ptrdiff_t m_iDamage = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iActualHealthRemoved = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iNumHits = 0x60; // int32_t
    constexpr std::ptrdiff_t m_iLastBulletUpdate = 0x64; // int32_t
    constexpr std::ptrdiff_t m_bIsOtherEnemy = 0x68; // bool
    constexpr std::ptrdiff_t m_killType = 0x69; // EKillTypes_t
}

namespace CDebugHistory { // CBaseEntity
    constexpr std::ptrdiff_t m_nNpcEvents = 0x44F0; // int32_t
}

namespace CDecoyGrenade { // CBaseCSGrenade
}

namespace CDecoyProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nDecoyShotTick = 0xA48; // int32_t
    constexpr std::ptrdiff_t m_shotsRemaining = 0xA4C; // int32_t
    constexpr std::ptrdiff_t m_fExpireTime = 0xA50; // GameTime_t
    constexpr std::ptrdiff_t m_decoyWeaponDefIndex = 0xA60; // uint16_t
}

namespace CDynamicLight { // CBaseModelEntity
    constexpr std::ptrdiff_t m_ActualFlags = 0x700; // uint8_t
    constexpr std::ptrdiff_t m_Flags = 0x701; // uint8_t
    constexpr std::ptrdiff_t m_LightStyle = 0x702; // uint8_t
    constexpr std::ptrdiff_t m_On = 0x703; // bool
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_Exponent = 0x708; // int32_t
    constexpr std::ptrdiff_t m_InnerAngle = 0x70C; // float
    constexpr std::ptrdiff_t m_OuterAngle = 0x710; // float
    constexpr std::ptrdiff_t m_SpotRadius = 0x714; // float
}

namespace CDynamicProp { // CBreakableProp
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0xA10; // bool
    constexpr std::ptrdiff_t m_bUseHitboxesForRenderBox = 0xA11; // bool
    constexpr std::ptrdiff_t m_bUseAnimGraph = 0xA12; // bool
    constexpr std::ptrdiff_t m_pOutputAnimBegun = 0xA18; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimOver = 0xA40; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputAnimLoopCycleOver = 0xA68; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedStart = 0xA90; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAnimReachedEnd = 0xAB8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszDefaultAnim = 0xAE0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nDefaultAnimLoopMode = 0xAE8; // AnimLoopMode_t
    constexpr std::ptrdiff_t m_bAnimateOnServer = 0xAEC; // bool
    constexpr std::ptrdiff_t m_bRandomizeCycle = 0xAED; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0xAEE; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0xAEF; // bool
    constexpr std::ptrdiff_t m_bFiredStartEndOutput = 0xAF0; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xAF1; // bool
    constexpr std::ptrdiff_t m_bCreateNonSolid = 0xAF2; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xAF3; // bool
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xAF4; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xAF8; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xAFC; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB00; // Color
    constexpr std::ptrdiff_t m_nGlowTeam = 0xB04; // int32_t
}

namespace CDynamicPropAlias_cable_dynamic { // CDynamicProp
}

namespace CDynamicPropAlias_dynamic_prop { // CDynamicProp
}

namespace CDynamicPropAlias_prop_dynamic_override { // CDynamicProp
}

namespace CEconEntity { // CBaseFlex
    constexpr std::ptrdiff_t m_AttributeManager = 0x930; // CAttributeContainer
    constexpr std::ptrdiff_t m_OriginalOwnerXuidLow = 0xBF8; // uint32_t
    constexpr std::ptrdiff_t m_OriginalOwnerXuidHigh = 0xBFC; // uint32_t
    constexpr std::ptrdiff_t m_nFallbackPaintKit = 0xC00; // int32_t
    constexpr std::ptrdiff_t m_nFallbackSeed = 0xC04; // int32_t
    constexpr std::ptrdiff_t m_flFallbackWear = 0xC08; // float
    constexpr std::ptrdiff_t m_nFallbackStatTrak = 0xC0C; // int32_t
    constexpr std::ptrdiff_t m_hOldProvidee = 0xC10; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iOldOwnerClass = 0xC14; // int32_t
}

namespace CEconItemAttribute {
    constexpr std::ptrdiff_t m_iAttributeDefinitionIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_flValue = 0x34; // float
    constexpr std::ptrdiff_t m_flInitialValue = 0x38; // float
    constexpr std::ptrdiff_t m_nRefundableCurrency = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_bSetBonus = 0x40; // bool
}

namespace CEconItemView { // IEconItemInterface
    constexpr std::ptrdiff_t m_iItemDefinitionIndex = 0x38; // uint16_t
    constexpr std::ptrdiff_t m_iEntityQuality = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEntityLevel = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_iItemID = 0x48; // uint64_t
    constexpr std::ptrdiff_t m_iItemIDHigh = 0x50; // uint32_t
    constexpr std::ptrdiff_t m_iItemIDLow = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_iAccountID = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_iInventoryPosition = 0x5C; // uint32_t
    constexpr std::ptrdiff_t m_bInitialized = 0x68; // bool
    constexpr std::ptrdiff_t m_AttributeList = 0x70; // CAttributeList
    constexpr std::ptrdiff_t m_NetworkedDynamicAttributes = 0xD0; // CAttributeList
    constexpr std::ptrdiff_t m_szCustomName = 0x130; // char[161]
    constexpr std::ptrdiff_t m_szCustomNameOverride = 0x1D1; // char[161]
}

namespace CEconWearable { // CEconEntity
    constexpr std::ptrdiff_t m_nForceSkin = 0xC18; // int32_t
    constexpr std::ptrdiff_t m_bAlwaysAllow = 0xC1C; // bool
}

namespace CEffectData {
    constexpr std::ptrdiff_t m_vOrigin = 0x8; // Vector
    constexpr std::ptrdiff_t m_vStart = 0x14; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0x20; // Vector
    constexpr std::ptrdiff_t m_vAngles = 0x2C; // QAngle
    constexpr std::ptrdiff_t m_hEntity = 0x38; // CEntityHandle
    constexpr std::ptrdiff_t m_hOtherEntity = 0x3C; // CEntityHandle
    constexpr std::ptrdiff_t m_flScale = 0x40; // float
    constexpr std::ptrdiff_t m_flMagnitude = 0x44; // float
    constexpr std::ptrdiff_t m_flRadius = 0x48; // float
    constexpr std::ptrdiff_t m_nSurfaceProp = 0x4C; // CUtlStringToken
    constexpr std::ptrdiff_t m_nEffectIndex = 0x50; // CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_nDamageType = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_nPenetrate = 0x5C; // uint8_t
    constexpr std::ptrdiff_t m_nMaterial = 0x5E; // uint16_t
    constexpr std::ptrdiff_t m_nHitBox = 0x60; // uint16_t
    constexpr std::ptrdiff_t m_nColor = 0x62; // uint8_t
    constexpr std::ptrdiff_t m_fFlags = 0x63; // uint8_t
    constexpr std::ptrdiff_t m_nAttachmentIndex = 0x64; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_nAttachmentName = 0x68; // CUtlStringToken
    constexpr std::ptrdiff_t m_iEffectName = 0x6C; // uint16_t
    constexpr std::ptrdiff_t m_nExplosionType = 0x6E; // uint8_t
}

namespace CEnableMotionFixup { // CBaseEntity
}

namespace CEntityBlocker { // CBaseModelEntity
}

namespace CEntityComponent {
}

namespace CEntityDissolve { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flFadeInStart = 0x700; // float
    constexpr std::ptrdiff_t m_flFadeInLength = 0x704; // float
    constexpr std::ptrdiff_t m_flFadeOutModelStart = 0x708; // float
    constexpr std::ptrdiff_t m_flFadeOutModelLength = 0x70C; // float
    constexpr std::ptrdiff_t m_flFadeOutStart = 0x710; // float
    constexpr std::ptrdiff_t m_flFadeOutLength = 0x714; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nDissolveType = 0x71C; // EntityDisolveType_t
    constexpr std::ptrdiff_t m_vDissolverOrigin = 0x720; // Vector
    constexpr std::ptrdiff_t m_nMagnitude = 0x72C; // uint32_t
}

namespace CEntityFlame { // CBaseEntity
    constexpr std::ptrdiff_t m_hEntAttached = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bCheapEffect = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSize = 0x4B8; // float
    constexpr std::ptrdiff_t m_bUseHitboxes = 0x4BC; // bool
    constexpr std::ptrdiff_t m_iNumHitboxFires = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flHitboxFireScale = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLifetime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_hAttacker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iDangerSound = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_flDirectDamagePerSecond = 0x4D4; // float
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x4D8; // int32_t
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CEntitySubclassVDataBase {
}

namespace CEnvBeam { // CBeam
    constexpr std::ptrdiff_t m_active = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_spriteTexture = 0x7A8; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszStartEntity = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEndEntity = 0x7B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_life = 0x7C0; // float
    constexpr std::ptrdiff_t m_boltWidth = 0x7C4; // float
    constexpr std::ptrdiff_t m_noiseAmplitude = 0x7C8; // float
    constexpr std::ptrdiff_t m_speed = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_restrike = 0x7D0; // float
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_frameStart = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_vEndPointWorld = 0x7E4; // Vector
    constexpr std::ptrdiff_t m_vEndPointRelative = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_radius = 0x7FC; // float
    constexpr std::ptrdiff_t m_TouchType = 0x800; // Touch_t
    constexpr std::ptrdiff_t m_iFilterName = 0x808; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x810; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszDecal = 0x818; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnTouchedByEntity = 0x820; // CEntityIOOutput
}

namespace CEnvBeverage { // CBaseEntity
    constexpr std::ptrdiff_t m_CanInDispenser = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nBeverageType = 0x4B4; // int32_t
}

namespace CEnvCombinedLightProbeVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_Color = 0x1508; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x150C; // float
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x1510; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x1518; // bool
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1528; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x1538; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x1540; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x154C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x1558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x155C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x1560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x1564; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x1568; // bool
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x156C; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x1570; // Vector
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x157C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x1580; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x1584; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x1588; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x158C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x1590; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x15A9; // bool
}

namespace CEnvCubemap { // CBaseEntity
    constexpr std::ptrdiff_t m_hCubemapTexture = 0x530; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bCustomCubemapTexture = 0x538; // bool
    constexpr std::ptrdiff_t m_flInfluenceRadius = 0x53C; // float
    constexpr std::ptrdiff_t m_vBoxProjectMins = 0x540; // Vector
    constexpr std::ptrdiff_t m_vBoxProjectMaxs = 0x54C; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x558; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x55C; // int32_t
    constexpr std::ptrdiff_t m_nEnvCubeMapArrayIndex = 0x560; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x564; // int32_t
    constexpr std::ptrdiff_t m_flEdgeFadeDist = 0x568; // float
    constexpr std::ptrdiff_t m_vEdgeFadeDists = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flDiffuseScale = 0x578; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x57C; // bool
    constexpr std::ptrdiff_t m_bDefaultEnvMap = 0x57D; // bool
    constexpr std::ptrdiff_t m_bDefaultSpecEnvMap = 0x57E; // bool
    constexpr std::ptrdiff_t m_bIndoorCubeMap = 0x57F; // bool
    constexpr std::ptrdiff_t m_bCopyDiffuseFromDefaultCubemap = 0x580; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x590; // bool
}

namespace CEnvCubemapBox { // CEnvCubemap
}

namespace CEnvCubemapFog { // CBaseEntity
    constexpr std::ptrdiff_t m_flEndDistance = 0x4B0; // float
    constexpr std::ptrdiff_t m_flStartDistance = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4B8; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4BC; // bool
    constexpr std::ptrdiff_t m_flFogHeightWidth = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogHeightEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogHeightStart = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFogHeightExponent = 0x4CC; // float
    constexpr std::ptrdiff_t m_flLODBias = 0x4D0; // float
    constexpr std::ptrdiff_t m_bActive = 0x4D4; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4D5; // bool
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D8; // float
    constexpr std::ptrdiff_t m_nCubemapSourceType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x4E0; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_iszSkyEntity = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFogCubemapTexture = 0x4F0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_bHasHeightFogEnd = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bFirstTime = 0x4F9; // bool
}

namespace CEnvDecal { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hDecalMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_flWidth = 0x708; // float
    constexpr std::ptrdiff_t m_flHeight = 0x70C; // float
    constexpr std::ptrdiff_t m_flDepth = 0x710; // float
    constexpr std::ptrdiff_t m_nRenderOrder = 0x714; // uint32_t
    constexpr std::ptrdiff_t m_bProjectOnWorld = 0x718; // bool
    constexpr std::ptrdiff_t m_bProjectOnCharacters = 0x719; // bool
    constexpr std::ptrdiff_t m_bProjectOnWater = 0x71A; // bool
    constexpr std::ptrdiff_t m_flDepthSortBias = 0x71C; // float
}

namespace CEnvDetailController { // CBaseEntity
    constexpr std::ptrdiff_t m_flFadeStartDist = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFadeEndDist = 0x4B4; // float
}

namespace CEnvEntityIgniter { // CBaseEntity
    constexpr std::ptrdiff_t m_flLifetime = 0x4B0; // float
}

namespace CEnvEntityMaker { // CPointEntity
    constexpr std::ptrdiff_t m_vecEntityMins = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vecEntityMaxs = 0x4BC; // Vector
    constexpr std::ptrdiff_t m_hCurrentInstance = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hCurrentBlocker = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecBlockerOrigin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_angPostSpawnDirection = 0x4DC; // QAngle
    constexpr std::ptrdiff_t m_flPostSpawnDirectionVariance = 0x4E8; // float
    constexpr std::ptrdiff_t m_flPostSpawnSpeed = 0x4EC; // float
    constexpr std::ptrdiff_t m_bPostSpawnUseAngles = 0x4F0; // bool
    constexpr std::ptrdiff_t m_iszTemplate = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOutputOnFailedSpawn = 0x528; // CEntityIOOutput
}

namespace CEnvExplosion { // CModelPointEntity
    constexpr std::ptrdiff_t m_iMagnitude = 0x700; // int32_t
    constexpr std::ptrdiff_t m_flPlayerDamage = 0x704; // float
    constexpr std::ptrdiff_t m_iRadiusOverride = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flInnerRadius = 0x70C; // float
    constexpr std::ptrdiff_t m_spriteScale = 0x710; // int32_t
    constexpr std::ptrdiff_t m_flDamageForce = 0x714; // float
    constexpr std::ptrdiff_t m_hInflictor = 0x718; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iCustomDamageType = 0x71C; // int32_t
    constexpr std::ptrdiff_t m_iszExplosionType = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomEffectName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCustomSoundName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iClassIgnore = 0x740; // Class_T
    constexpr std::ptrdiff_t m_iClassIgnore2 = 0x744; // Class_T
    constexpr std::ptrdiff_t m_iszEntityIgnoreName = 0x748; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEntityIgnore = 0x750; // CHandle<CBaseEntity>
}

namespace CEnvFade { // CLogicalEntity
    constexpr std::ptrdiff_t m_fadeColor = 0x4B0; // Color
    constexpr std::ptrdiff_t m_Duration = 0x4B4; // float
    constexpr std::ptrdiff_t m_HoldDuration = 0x4B8; // float
    constexpr std::ptrdiff_t m_OnBeginFade = 0x4C0; // CEntityIOOutput
}

namespace CEnvFireSensor { // CBaseEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bHeatAtLevel = 0x4B1; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_targetLevel = 0x4B8; // float
    constexpr std::ptrdiff_t m_targetTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_levelTime = 0x4C0; // float
    constexpr std::ptrdiff_t m_OnHeatLevelStart = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeatLevelEnd = 0x4F0; // CEntityIOOutput
}

namespace CEnvFireSource { // CBaseEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_damage = 0x4B8; // float
}

namespace CEnvFunnel { // CBaseEntity
}

namespace CEnvGlobal { // CLogicalEntity
    constexpr std::ptrdiff_t m_outCounter = 0x4B0; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_globalstate = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_triggermode = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_initialstate = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_counter = 0x4E8; // int32_t
}

namespace CEnvHudHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
}

namespace CEnvInstructorHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReplace_Key = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C8; // int32_t
    constexpr std::ptrdiff_t m_iDisplayLimit = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_iszIcon_Onscreen = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszIcon_Offscreen = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCaption = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszActivatorCaption = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Color = 0x4F0; // Color
    constexpr std::ptrdiff_t m_fIconOffset = 0x4F4; // float
    constexpr std::ptrdiff_t m_fRange = 0x4F8; // float
    constexpr std::ptrdiff_t m_iPulseOption = 0x4FC; // uint8_t
    constexpr std::ptrdiff_t m_iAlphaOption = 0x4FD; // uint8_t
    constexpr std::ptrdiff_t m_iShakeOption = 0x4FE; // uint8_t
    constexpr std::ptrdiff_t m_bStatic = 0x4FF; // bool
    constexpr std::ptrdiff_t m_bNoOffscreen = 0x500; // bool
    constexpr std::ptrdiff_t m_bForceCaption = 0x501; // bool
    constexpr std::ptrdiff_t m_iInstanceType = 0x504; // int32_t
    constexpr std::ptrdiff_t m_bSuppressRest = 0x508; // bool
    constexpr std::ptrdiff_t m_iszBinding = 0x510; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAllowNoDrawTarget = 0x518; // bool
    constexpr std::ptrdiff_t m_bAutoStart = 0x519; // bool
    constexpr std::ptrdiff_t m_bLocalPlayerOnly = 0x51A; // bool
}

namespace CEnvInstructorVRHint { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iTimeout = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_iszCaption = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszStartSound = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iLayoutFileType = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszCustomLayoutFile = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iAttachType = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_flHeightOffset = 0x4EC; // float
}

namespace CEnvLaser { // CBeam
    constexpr std::ptrdiff_t m_iszLaserTarget = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pSprite = 0x7A8; // CSprite*
    constexpr std::ptrdiff_t m_iszSpriteName = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_firePosition = 0x7B8; // Vector
    constexpr std::ptrdiff_t m_flStartFrame = 0x7C4; // float
}

namespace CEnvLightProbeVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_hLightProbeTexture = 0x1488; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightIndicesTexture = 0x1490; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightScalarsTexture = 0x1498; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hLightProbeDirectLightShadowsTexture = 0x14A0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vBoxMins = 0x14A8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x14B4; // Vector
    constexpr std::ptrdiff_t m_bMoveable = 0x14C0; // bool
    constexpr std::ptrdiff_t m_nHandshake = 0x14C4; // int32_t
    constexpr std::ptrdiff_t m_nPriority = 0x14C8; // int32_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x14CC; // bool
    constexpr std::ptrdiff_t m_nLightProbeSizeX = 0x14D0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeY = 0x14D4; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeSizeZ = 0x14D8; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasX = 0x14DC; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasY = 0x14E0; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeAtlasZ = 0x14E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x14F1; // bool
}

namespace CEnvMicrophone { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSoundMask = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_flSensitivity = 0x4BC; // float
    constexpr std::ptrdiff_t m_flSmoothFactor = 0x4C0; // float
    constexpr std::ptrdiff_t m_flMaxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_iszSpeakerName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSpeaker = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bAvoidFeedback = 0x4D4; // bool
    constexpr std::ptrdiff_t m_iSpeakerDSPPreset = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iszListenFilter = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hListenFilter = 0x4E8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_SoundLevel = 0x4F0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoutedSound = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHeardSound = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_szLastSound = 0x568; // char[256]
    constexpr std::ptrdiff_t m_iLastRoutedFrame = 0x668; // int32_t
}

namespace CEnvMuzzleFlash { // CPointEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
    constexpr std::ptrdiff_t m_iszParentAttachment = 0x4B8; // CUtlSymbolLarge
}

namespace CEnvParticleGlow { // CParticleSystem
    constexpr std::ptrdiff_t m_flAlphaScale = 0xC78; // float
    constexpr std::ptrdiff_t m_flRadiusScale = 0xC7C; // float
    constexpr std::ptrdiff_t m_flSelfIllumScale = 0xC80; // float
    constexpr std::ptrdiff_t m_ColorTint = 0xC84; // Color
    constexpr std::ptrdiff_t m_hTextureOverride = 0xC88; // CStrongHandle<InfoForResourceTypeCTextureBase>
}

namespace CEnvProjectedTexture { // CModelPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x700; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bState = 0x704; // bool
    constexpr std::ptrdiff_t m_bAlwaysUpdate = 0x705; // bool
    constexpr std::ptrdiff_t m_flLightFOV = 0x708; // float
    constexpr std::ptrdiff_t m_bEnableShadows = 0x70C; // bool
    constexpr std::ptrdiff_t m_bSimpleProjection = 0x70D; // bool
    constexpr std::ptrdiff_t m_bLightOnlyTarget = 0x70E; // bool
    constexpr std::ptrdiff_t m_bLightWorld = 0x70F; // bool
    constexpr std::ptrdiff_t m_bCameraSpace = 0x710; // bool
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x714; // float
    constexpr std::ptrdiff_t m_LightColor = 0x718; // Color
    constexpr std::ptrdiff_t m_flIntensity = 0x71C; // float
    constexpr std::ptrdiff_t m_flLinearAttenuation = 0x720; // float
    constexpr std::ptrdiff_t m_flQuadraticAttenuation = 0x724; // float
    constexpr std::ptrdiff_t m_bVolumetric = 0x728; // bool
    constexpr std::ptrdiff_t m_flNoiseStrength = 0x72C; // float
    constexpr std::ptrdiff_t m_flFlashlightTime = 0x730; // float
    constexpr std::ptrdiff_t m_nNumPlanes = 0x734; // uint32_t
    constexpr std::ptrdiff_t m_flPlaneOffset = 0x738; // float
    constexpr std::ptrdiff_t m_flVolumetricIntensity = 0x73C; // float
    constexpr std::ptrdiff_t m_flColorTransitionTime = 0x740; // float
    constexpr std::ptrdiff_t m_flAmbient = 0x744; // float
    constexpr std::ptrdiff_t m_SpotlightTextureName = 0x748; // char[512]
    constexpr std::ptrdiff_t m_nSpotlightTextureFrame = 0x948; // int32_t
    constexpr std::ptrdiff_t m_nShadowQuality = 0x94C; // uint32_t
    constexpr std::ptrdiff_t m_flNearZ = 0x950; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x954; // float
    constexpr std::ptrdiff_t m_flProjectionSize = 0x958; // float
    constexpr std::ptrdiff_t m_flRotation = 0x95C; // float
    constexpr std::ptrdiff_t m_bFlipHorizontal = 0x960; // bool
}

namespace CEnvScreenOverlay { // CPointEntity
    constexpr std::ptrdiff_t m_iszOverlayNames = 0x4B0; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_flOverlayTimes = 0x500; // float[10]
    constexpr std::ptrdiff_t m_flStartTime = 0x528; // GameTime_t
    constexpr std::ptrdiff_t m_iDesiredOverlay = 0x52C; // int32_t
    constexpr std::ptrdiff_t m_bIsActive = 0x530; // bool
}

namespace CEnvShake { // CPointEntity
    constexpr std::ptrdiff_t m_limitToEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Amplitude = 0x4B8; // float
    constexpr std::ptrdiff_t m_Frequency = 0x4BC; // float
    constexpr std::ptrdiff_t m_Duration = 0x4C0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4C4; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_nextShake = 0x4CC; // GameTime_t
    constexpr std::ptrdiff_t m_currentAmp = 0x4D0; // float
    constexpr std::ptrdiff_t m_maxForce = 0x4D4; // Vector
    constexpr std::ptrdiff_t m_shakeCallback = 0x4E8; // CPhysicsShake
}

namespace CEnvSky { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hSkyMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hSkyMaterialLightingOnly = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_bStartDisabled = 0x710; // bool
    constexpr std::ptrdiff_t m_vTintColor = 0x711; // Color
    constexpr std::ptrdiff_t m_vTintColorLightingOnly = 0x715; // Color
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x71C; // float
    constexpr std::ptrdiff_t m_nFogType = 0x720; // int32_t
    constexpr std::ptrdiff_t m_flFogMinStart = 0x724; // float
    constexpr std::ptrdiff_t m_flFogMinEnd = 0x728; // float
    constexpr std::ptrdiff_t m_flFogMaxStart = 0x72C; // float
    constexpr std::ptrdiff_t m_flFogMaxEnd = 0x730; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x734; // bool
}

namespace CEnvSoundscape { // CServerOnlyEntity
    constexpr std::ptrdiff_t m_OnPlay = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flRadius = 0x4D8; // float
    constexpr std::ptrdiff_t m_soundscapeName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOverrideWithEvent = 0x4F0; // bool
    constexpr std::ptrdiff_t m_soundscapeIndex = 0x4F4; // int32_t
    constexpr std::ptrdiff_t m_soundscapeEntityListId = 0x4F8; // int32_t
    constexpr std::ptrdiff_t m_soundEventHash = 0x4FC; // uint32_t
    constexpr std::ptrdiff_t m_positionNames = 0x500; // CUtlSymbolLarge[8]
    constexpr std::ptrdiff_t m_hProxySoundscape = 0x540; // CHandle<CEnvSoundscape>
    constexpr std::ptrdiff_t m_bDisabled = 0x544; // bool
}

namespace CEnvSoundscapeAlias_snd_soundscape { // CEnvSoundscape
}

namespace CEnvSoundscapeProxy { // CEnvSoundscape
    constexpr std::ptrdiff_t m_MainSoundscapeName = 0x548; // CUtlSymbolLarge
}

namespace CEnvSoundscapeProxyAlias_snd_soundscape_proxy { // CEnvSoundscapeProxy
}

namespace CEnvSoundscapeTriggerable { // CEnvSoundscape
}

namespace CEnvSoundscapeTriggerableAlias_snd_soundscape_triggerable { // CEnvSoundscapeTriggerable
}

namespace CEnvSpark { // CPointEntity
    constexpr std::ptrdiff_t m_flDelay = 0x4B0; // float
    constexpr std::ptrdiff_t m_nMagnitude = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nTrailLength = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nType = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_OnSpark = 0x4C0; // CEntityIOOutput
}

namespace CEnvSplash { // CPointEntity
    constexpr std::ptrdiff_t m_flScale = 0x4B0; // float
}

namespace CEnvTilt { // CPointEntity
    constexpr std::ptrdiff_t m_Duration = 0x4B0; // float
    constexpr std::ptrdiff_t m_Radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_TiltTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_stopTime = 0x4BC; // GameTime_t
}

namespace CEnvTracer { // CPointEntity
    constexpr std::ptrdiff_t m_vecEnd = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
}

namespace CEnvViewPunch { // CPointEntity
    constexpr std::ptrdiff_t m_flRadius = 0x4B0; // float
    constexpr std::ptrdiff_t m_angViewPunch = 0x4B4; // QAngle
}

namespace CEnvVolumetricFogController { // CBaseEntity
    constexpr std::ptrdiff_t m_flScattering = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAnisotropy = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFadeSpeed = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDrawDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_flFadeInStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFadeInEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flIndirectStrength = 0x4C8; // float
    constexpr std::ptrdiff_t m_nIndirectTextureDimX = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimY = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nIndirectTextureDimZ = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_vBoxMins = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_bActive = 0x4F0; // bool
    constexpr std::ptrdiff_t m_flStartAnisoTime = 0x4F4; // GameTime_t
    constexpr std::ptrdiff_t m_flStartScatterTime = 0x4F8; // GameTime_t
    constexpr std::ptrdiff_t m_flStartDrawDistanceTime = 0x4FC; // GameTime_t
    constexpr std::ptrdiff_t m_flStartAnisotropy = 0x500; // float
    constexpr std::ptrdiff_t m_flStartScattering = 0x504; // float
    constexpr std::ptrdiff_t m_flStartDrawDistance = 0x508; // float
    constexpr std::ptrdiff_t m_flDefaultAnisotropy = 0x50C; // float
    constexpr std::ptrdiff_t m_flDefaultScattering = 0x510; // float
    constexpr std::ptrdiff_t m_flDefaultDrawDistance = 0x514; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableIndirect = 0x519; // bool
    constexpr std::ptrdiff_t m_bIsMaster = 0x51A; // bool
    constexpr std::ptrdiff_t m_hFogIndirectTexture = 0x520; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nForceRefreshCount = 0x528; // int32_t
    constexpr std::ptrdiff_t m_bFirstTime = 0x52C; // bool
}

namespace CEnvVolumetricFogVolume { // CBaseEntity
    constexpr std::ptrdiff_t m_bActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_vBoxMins = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4C0; // Vector
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4CC; // bool
    constexpr std::ptrdiff_t m_flStrength = 0x4D0; // float
    constexpr std::ptrdiff_t m_nFalloffShape = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flFalloffExponent = 0x4D8; // float
}

namespace CEnvWind { // CBaseEntity
    constexpr std::ptrdiff_t m_EnvWindShared = 0x4B0; // CEnvWindShared
}

namespace CEnvWindShared {
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_iWindSeed = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_iMinWind = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_iMaxWind = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_windRadius = 0x14; // int32_t
    constexpr std::ptrdiff_t m_iMinGust = 0x18; // uint16_t
    constexpr std::ptrdiff_t m_iMaxGust = 0x1A; // uint16_t
    constexpr std::ptrdiff_t m_flMinGustDelay = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxGustDelay = 0x20; // float
    constexpr std::ptrdiff_t m_flGustDuration = 0x24; // float
    constexpr std::ptrdiff_t m_iGustDirChange = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_location = 0x2C; // Vector
    constexpr std::ptrdiff_t m_iszGustSound = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iWindDir = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_flWindSpeed = 0x40; // float
    constexpr std::ptrdiff_t m_currentWindVector = 0x44; // Vector
    constexpr std::ptrdiff_t m_CurrentSwayVector = 0x50; // Vector
    constexpr std::ptrdiff_t m_PrevSwayVector = 0x5C; // Vector
    constexpr std::ptrdiff_t m_iInitialWindDir = 0x68; // uint16_t
    constexpr std::ptrdiff_t m_flInitialWindSpeed = 0x6C; // float
    constexpr std::ptrdiff_t m_OnGustStart = 0x70; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGustEnd = 0x98; // CEntityIOOutput
    constexpr std::ptrdiff_t m_flVariationTime = 0xC0; // GameTime_t
    constexpr std::ptrdiff_t m_flSwayTime = 0xC4; // GameTime_t
    constexpr std::ptrdiff_t m_flSimTime = 0xC8; // GameTime_t
    constexpr std::ptrdiff_t m_flSwitchTime = 0xCC; // GameTime_t
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0xD0; // float
    constexpr std::ptrdiff_t m_bGusting = 0xD4; // bool
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0xD8; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0xDC; // float
    constexpr std::ptrdiff_t m_iEntIndex = 0xE0; // CEntityIndex
}

namespace CEnvWindShared_WindAveEvent_t {
    constexpr std::ptrdiff_t m_flStartWindSpeed = 0x0; // float
    constexpr std::ptrdiff_t m_flAveWindSpeed = 0x4; // float
}

namespace CEnvWindShared_WindVariationEvent_t {
    constexpr std::ptrdiff_t m_flWindAngleVariation = 0x0; // float
    constexpr std::ptrdiff_t m_flWindSpeedVariation = 0x4; // float
}

namespace CFilterAttributeInt { // CBaseFilter
    constexpr std::ptrdiff_t m_sAttributeName = 0x508; // CUtlStringToken
}

namespace CFilterClass { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterClass = 0x508; // CUtlSymbolLarge
}

namespace CFilterContext { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterContext = 0x508; // CUtlSymbolLarge
}

namespace CFilterEnemy { // CBaseFilter
    constexpr std::ptrdiff_t m_iszEnemyName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRadius = 0x510; // float
    constexpr std::ptrdiff_t m_flOuterRadius = 0x514; // float
    constexpr std::ptrdiff_t m_nMaxSquadmatesPerEnemy = 0x518; // int32_t
    constexpr std::ptrdiff_t m_iszPlayerName = 0x520; // CUtlSymbolLarge
}

namespace CFilterLOS { // CBaseFilter
}

namespace CFilterMassGreater { // CBaseFilter
    constexpr std::ptrdiff_t m_fFilterMass = 0x508; // float
}

namespace CFilterModel { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterModel = 0x508; // CUtlSymbolLarge
}

namespace CFilterMultiple { // CBaseFilter
    constexpr std::ptrdiff_t m_nFilterType = 0x508; // filter_t
    constexpr std::ptrdiff_t m_iFilterName = 0x510; // CUtlSymbolLarge[10]
    constexpr std::ptrdiff_t m_hFilter = 0x560; // CHandle<CBaseEntity>[10]
    constexpr std::ptrdiff_t m_nFilterCount = 0x588; // int32_t
}

namespace CFilterName { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterName = 0x508; // CUtlSymbolLarge
}

namespace CFilterProximity { // CBaseFilter
    constexpr std::ptrdiff_t m_flRadius = 0x508; // float
}

namespace CFire { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hEffect = 0x700; // CHandle<CBaseFire>
    constexpr std::ptrdiff_t m_hOwner = 0x704; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nFireType = 0x708; // int32_t
    constexpr std::ptrdiff_t m_flFuel = 0x70C; // float
    constexpr std::ptrdiff_t m_flDamageTime = 0x710; // GameTime_t
    constexpr std::ptrdiff_t m_lastDamage = 0x714; // GameTime_t
    constexpr std::ptrdiff_t m_flFireSize = 0x718; // float
    constexpr std::ptrdiff_t m_flLastNavUpdateTime = 0x71C; // GameTime_t
    constexpr std::ptrdiff_t m_flHeatLevel = 0x720; // float
    constexpr std::ptrdiff_t m_flHeatAbsorb = 0x724; // float
    constexpr std::ptrdiff_t m_flDamageScale = 0x728; // float
    constexpr std::ptrdiff_t m_flMaxHeat = 0x72C; // float
    constexpr std::ptrdiff_t m_flLastHeatLevel = 0x730; // float
    constexpr std::ptrdiff_t m_flAttackTime = 0x734; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x738; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x739; // bool
    constexpr std::ptrdiff_t m_bDidActivate = 0x73A; // bool
    constexpr std::ptrdiff_t m_OnIgnited = 0x740; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExtinguished = 0x768; // CEntityIOOutput
}

namespace CFireCrackerBlast { // CInferno
}

namespace CFireSmoke { // CBaseFire
    constexpr std::ptrdiff_t m_nFlameModelIndex = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_nFlameFromAboveModelIndex = 0x4C4; // int32_t
}

namespace CFiringModeFloat {
    constexpr std::ptrdiff_t m_flValues = 0x0; // float[2]
}

namespace CFiringModeInt {
    constexpr std::ptrdiff_t m_nValues = 0x0; // int32_t[2]
}

namespace CFish { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_pool = 0x890; // CHandle<CFishPool>
    constexpr std::ptrdiff_t m_id = 0x894; // uint32_t
    constexpr std::ptrdiff_t m_x = 0x898; // float
    constexpr std::ptrdiff_t m_y = 0x89C; // float
    constexpr std::ptrdiff_t m_z = 0x8A0; // float
    constexpr std::ptrdiff_t m_angle = 0x8A4; // float
    constexpr std::ptrdiff_t m_angleChange = 0x8A8; // float
    constexpr std::ptrdiff_t m_forward = 0x8AC; // Vector
    constexpr std::ptrdiff_t m_perp = 0x8B8; // Vector
    constexpr std::ptrdiff_t m_poolOrigin = 0x8C4; // Vector
    constexpr std::ptrdiff_t m_waterLevel = 0x8D0; // float
    constexpr std::ptrdiff_t m_speed = 0x8D4; // float
    constexpr std::ptrdiff_t m_desiredSpeed = 0x8D8; // float
    constexpr std::ptrdiff_t m_calmSpeed = 0x8DC; // float
    constexpr std::ptrdiff_t m_panicSpeed = 0x8E0; // float
    constexpr std::ptrdiff_t m_avoidRange = 0x8E4; // float
    constexpr std::ptrdiff_t m_turnTimer = 0x8E8; // CountdownTimer
    constexpr std::ptrdiff_t m_turnClockwise = 0x900; // bool
    constexpr std::ptrdiff_t m_goTimer = 0x908; // CountdownTimer
    constexpr std::ptrdiff_t m_moveTimer = 0x920; // CountdownTimer
    constexpr std::ptrdiff_t m_panicTimer = 0x938; // CountdownTimer
    constexpr std::ptrdiff_t m_disperseTimer = 0x950; // CountdownTimer
    constexpr std::ptrdiff_t m_proximityTimer = 0x968; // CountdownTimer
    constexpr std::ptrdiff_t m_visible = 0x980; // CUtlVector<CFish*>
}

namespace CFishPool { // CBaseEntity
    constexpr std::ptrdiff_t m_fishCount = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_maxRange = 0x4C4; // float
    constexpr std::ptrdiff_t m_swimDepth = 0x4C8; // float
    constexpr std::ptrdiff_t m_waterLevel = 0x4CC; // float
    constexpr std::ptrdiff_t m_isDormant = 0x4D0; // bool
    constexpr std::ptrdiff_t m_fishes = 0x4D8; // CUtlVector<CHandle<CFish>>
    constexpr std::ptrdiff_t m_visTimer = 0x4F0; // CountdownTimer
}

namespace CFists { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bPlayingUninterruptableAct = 0xE20; // bool
    constexpr std::ptrdiff_t m_nUninterruptableActivity = 0xE24; // PlayerAnimEvent_t
    constexpr std::ptrdiff_t m_bRestorePrevWep = 0xE28; // bool
    constexpr std::ptrdiff_t m_hWeaponBeforePrevious = 0xE2C; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hWeaponPrevious = 0xE30; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_bDelayedHardPunchIncoming = 0xE34; // bool
    constexpr std::ptrdiff_t m_bDestroyAfterTaunt = 0xE35; // bool
}

namespace CFlashbang { // CBaseCSGrenade
}

namespace CFlashbangProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_flTimeToDetonate = 0xA40; // float
    constexpr std::ptrdiff_t m_numOpponentsHit = 0xA44; // uint8_t
    constexpr std::ptrdiff_t m_numTeammatesHit = 0xA45; // uint8_t
}

namespace CFogController { // CBaseEntity
    constexpr std::ptrdiff_t m_fog = 0x4B0; // fogparams_t
    constexpr std::ptrdiff_t m_bUseAngles = 0x518; // bool
    constexpr std::ptrdiff_t m_iChangedVariables = 0x51C; // int32_t
}

namespace CFogTrigger { // CBaseTrigger
    constexpr std::ptrdiff_t m_fog = 0x8A8; // fogparams_t
}

namespace CFogVolume { // CServerOnlyModelEntity
    constexpr std::ptrdiff_t m_fogName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_postProcessName = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_colorCorrectionName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x720; // bool
    constexpr std::ptrdiff_t m_bInFogVolumesList = 0x721; // bool
}

namespace CFootstepControl { // CBaseTrigger
    constexpr std::ptrdiff_t m_source = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_destination = 0x8B0; // CUtlSymbolLarge
}

namespace CFootstepTableHandle {
}

namespace CFuncBrush { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iSolidity = 0x700; // BrushSolidities_e
    constexpr std::ptrdiff_t m_iDisabled = 0x704; // int32_t
    constexpr std::ptrdiff_t m_bSolidBsp = 0x708; // bool
    constexpr std::ptrdiff_t m_iszExcludedClass = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bInvertExclusion = 0x718; // bool
    constexpr std::ptrdiff_t m_bScriptedMovement = 0x719; // bool
}

namespace CFuncConveyor { // CBaseModelEntity
    constexpr std::ptrdiff_t m_szConveyorModels = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTransitionDurationSeconds = 0x708; // float
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x70C; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirEntitySpace = 0x718; // Vector
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x724; // float
    constexpr std::ptrdiff_t m_nTransitionStartTick = 0x728; // GameTick_t
    constexpr std::ptrdiff_t m_nTransitionDurationTicks = 0x72C; // int32_t
    constexpr std::ptrdiff_t m_flTransitionStartSpeed = 0x730; // float
    constexpr std::ptrdiff_t m_hConveyorModels = 0x738; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
}

namespace CFuncElectrifiedVolume { // CFuncBrush
    constexpr std::ptrdiff_t m_EffectName = 0x720; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectInterpenetrateName = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_EffectZapName = 0x730; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEffectSource = 0x738; // CUtlSymbolLarge
}

namespace CFuncIllusionary { // CBaseModelEntity
}

namespace CFuncInteractionLayerClip { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_iszInteractsAs = 0x708; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszInteractsWith = 0x710; // CUtlSymbolLarge
}

namespace CFuncLadder { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vecLadderDir = 0x700; // Vector
    constexpr std::ptrdiff_t m_Dismounts = 0x710; // CUtlVector<CHandle<CInfoLadderDismount>>
    constexpr std::ptrdiff_t m_vecLocalTop = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionTop = 0x734; // Vector
    constexpr std::ptrdiff_t m_vecPlayerMountPositionBottom = 0x740; // Vector
    constexpr std::ptrdiff_t m_flAutoRideSpeed = 0x74C; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x750; // bool
    constexpr std::ptrdiff_t m_bFakeLadder = 0x751; // bool
    constexpr std::ptrdiff_t m_bHasSlack = 0x752; // bool
    constexpr std::ptrdiff_t m_surfacePropName = 0x758; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnPlayerGotOnLadder = 0x760; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerGotOffLadder = 0x788; // CEntityIOOutput
}

namespace CFuncLadderAlias_func_useableladder { // CFuncLadder
}

namespace CFuncMonitor { // CFuncBrush
    constexpr std::ptrdiff_t m_targetCamera = 0x720; // CUtlString
    constexpr std::ptrdiff_t m_nResolutionEnum = 0x728; // int32_t
    constexpr std::ptrdiff_t m_bRenderShadows = 0x72C; // bool
    constexpr std::ptrdiff_t m_bUseUniqueColorTarget = 0x72D; // bool
    constexpr std::ptrdiff_t m_brushModelName = 0x730; // CUtlString
    constexpr std::ptrdiff_t m_hTargetCamera = 0x738; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bEnabled = 0x73C; // bool
    constexpr std::ptrdiff_t m_bDraw3DSkybox = 0x73D; // bool
    constexpr std::ptrdiff_t m_bStartEnabled = 0x73E; // bool
}

namespace CFuncMoveLinear { // CBaseToggle
    constexpr std::ptrdiff_t m_authoredPosition = 0x780; // MoveLinearAuthoredPos_t
    constexpr std::ptrdiff_t m_angMoveEntitySpace = 0x784; // QAngle
    constexpr std::ptrdiff_t m_vecMoveDirParentSpace = 0x790; // Vector
    constexpr std::ptrdiff_t m_soundStart = 0x7A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_soundStop = 0x7A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_currentSound = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B8; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x7BC; // float
    constexpr std::ptrdiff_t m_flMoveDistance = 0x7C0; // float
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x7D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x7F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCreateMovableNavMesh = 0x820; // bool
    constexpr std::ptrdiff_t m_bCreateNavObstacle = 0x821; // bool
}

namespace CFuncMoveLinearAlias_momentary_door { // CFuncMoveLinear
}

namespace CFuncNavBlocker { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
    constexpr std::ptrdiff_t m_nBlockedTeamNumber = 0x704; // int32_t
}

namespace CFuncNavObstruction { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x708; // bool
}

namespace CFuncPlat { // CBasePlatTrain
    constexpr std::ptrdiff_t m_sNoise = 0x7A8; // CUtlSymbolLarge
}

namespace CFuncPlatRot { // CFuncPlat
    constexpr std::ptrdiff_t m_end = 0x7B0; // QAngle
    constexpr std::ptrdiff_t m_start = 0x7BC; // QAngle
}

namespace CFuncPropRespawnZone { // CBaseEntity
}

namespace CFuncRotating { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vecMoveAng = 0x700; // QAngle
    constexpr std::ptrdiff_t m_flFanFriction = 0x70C; // float
    constexpr std::ptrdiff_t m_flAttenuation = 0x710; // float
    constexpr std::ptrdiff_t m_flVolume = 0x714; // float
    constexpr std::ptrdiff_t m_flTargetSpeed = 0x718; // float
    constexpr std::ptrdiff_t m_flMaxSpeed = 0x71C; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x720; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x724; // float
    constexpr std::ptrdiff_t m_NoiseRunning = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bReversed = 0x730; // bool
    constexpr std::ptrdiff_t m_angStart = 0x73C; // QAngle
    constexpr std::ptrdiff_t m_bStopAtStartPos = 0x748; // bool
    constexpr std::ptrdiff_t m_vecClientOrigin = 0x74C; // Vector
    constexpr std::ptrdiff_t m_vecClientAngles = 0x758; // QAngle
}

namespace CFuncShatterglass { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hGlassMaterialDamaged = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hGlassMaterialUndamaged = 0x708; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFace = 0x710; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeCaps = 0x718; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hConcreteMaterialEdgeFins = 0x720; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_matPanelTransform = 0x728; // matrix3x4_t
    constexpr std::ptrdiff_t m_matPanelTransformWsTemp = 0x758; // matrix3x4_t
    constexpr std::ptrdiff_t m_vecShatterGlassShards = 0x788; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_PanelSize = 0x7A0; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelNormalWs = 0x7A8; // Vector
    constexpr std::ptrdiff_t m_nNumShardsEverCreated = 0x7B4; // int32_t
    constexpr std::ptrdiff_t m_flLastShatterSoundEmitTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_flLastCleanupTime = 0x7BC; // GameTime_t
    constexpr std::ptrdiff_t m_flInitAtTime = 0x7C0; // GameTime_t
    constexpr std::ptrdiff_t m_flGlassThickness = 0x7C4; // float
    constexpr std::ptrdiff_t m_flSpawnInvulnerability = 0x7C8; // float
    constexpr std::ptrdiff_t m_bBreakSilent = 0x7CC; // bool
    constexpr std::ptrdiff_t m_bBreakShardless = 0x7CD; // bool
    constexpr std::ptrdiff_t m_bBroken = 0x7CE; // bool
    constexpr std::ptrdiff_t m_bHasRateLimitedShards = 0x7CF; // bool
    constexpr std::ptrdiff_t m_bGlassNavIgnore = 0x7D0; // bool
    constexpr std::ptrdiff_t m_bGlassInFrame = 0x7D1; // bool
    constexpr std::ptrdiff_t m_bStartBroken = 0x7D2; // bool
    constexpr std::ptrdiff_t m_iInitialDamageType = 0x7D3; // uint8_t
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName01 = 0x7D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName02 = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName03 = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szDamagePositioningEntityName04 = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vInitialDamagePositions = 0x7F8; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_vExtraDamagePositions = 0x810; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_OnBroken = 0x828; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iSurfaceType = 0x851; // uint8_t
}

namespace CFuncTankTrain { // CFuncTrackTrain
    constexpr std::ptrdiff_t m_OnDeath = 0x850; // CEntityIOOutput
}

namespace CFuncTimescale { // CBaseEntity
    constexpr std::ptrdiff_t m_flDesiredTimescale = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAcceleration = 0x4B4; // float
    constexpr std::ptrdiff_t m_flMinBlendRate = 0x4B8; // float
    constexpr std::ptrdiff_t m_flBlendDeltaMultiplier = 0x4BC; // float
    constexpr std::ptrdiff_t m_isStarted = 0x4C0; // bool
}

namespace CFuncTrackAuto { // CFuncTrackChange
}

namespace CFuncTrackChange { // CFuncPlatRot
    constexpr std::ptrdiff_t m_trackTop = 0x7C8; // CPathTrack*
    constexpr std::ptrdiff_t m_trackBottom = 0x7D0; // CPathTrack*
    constexpr std::ptrdiff_t m_train = 0x7D8; // CFuncTrackTrain*
    constexpr std::ptrdiff_t m_trackTopName = 0x7E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trackBottomName = 0x7E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_trainName = 0x7F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_code = 0x7F8; // TRAIN_CODE
    constexpr std::ptrdiff_t m_targetState = 0x7FC; // int32_t
    constexpr std::ptrdiff_t m_use = 0x800; // int32_t
}

namespace CFuncTrackTrain { // CBaseModelEntity
    constexpr std::ptrdiff_t m_ppath = 0x700; // CHandle<CPathTrack>
    constexpr std::ptrdiff_t m_length = 0x704; // float
    constexpr std::ptrdiff_t m_vPosPrev = 0x708; // Vector
    constexpr std::ptrdiff_t m_angPrev = 0x714; // QAngle
    constexpr std::ptrdiff_t m_controlMins = 0x720; // Vector
    constexpr std::ptrdiff_t m_controlMaxs = 0x72C; // Vector
    constexpr std::ptrdiff_t m_lastBlockPos = 0x738; // Vector
    constexpr std::ptrdiff_t m_lastBlockTick = 0x744; // int32_t
    constexpr std::ptrdiff_t m_flVolume = 0x748; // float
    constexpr std::ptrdiff_t m_flBank = 0x74C; // float
    constexpr std::ptrdiff_t m_oldSpeed = 0x750; // float
    constexpr std::ptrdiff_t m_flBlockDamage = 0x754; // float
    constexpr std::ptrdiff_t m_height = 0x758; // float
    constexpr std::ptrdiff_t m_maxSpeed = 0x75C; // float
    constexpr std::ptrdiff_t m_dir = 0x760; // float
    constexpr std::ptrdiff_t m_iszSoundMove = 0x768; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovePing = 0x770; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStart = 0x778; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundStop = 0x780; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strPathTarget = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flMoveSoundMinDuration = 0x790; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxDuration = 0x794; // float
    constexpr std::ptrdiff_t m_flNextMoveSoundTime = 0x798; // GameTime_t
    constexpr std::ptrdiff_t m_flMoveSoundMinPitch = 0x79C; // float
    constexpr std::ptrdiff_t m_flMoveSoundMaxPitch = 0x7A0; // float
    constexpr std::ptrdiff_t m_eOrientationType = 0x7A4; // TrainOrientationType_t
    constexpr std::ptrdiff_t m_eVelocityType = 0x7A8; // TrainVelocityType_t
    constexpr std::ptrdiff_t m_OnStart = 0x7B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNext = 0x7E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnArrivedAtDestinationNode = 0x808; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bManualSpeedChanges = 0x830; // bool
    constexpr std::ptrdiff_t m_flDesiredSpeed = 0x834; // float
    constexpr std::ptrdiff_t m_flSpeedChangeTime = 0x838; // GameTime_t
    constexpr std::ptrdiff_t m_flAccelSpeed = 0x83C; // float
    constexpr std::ptrdiff_t m_flDecelSpeed = 0x840; // float
    constexpr std::ptrdiff_t m_bAccelToSpeed = 0x844; // bool
    constexpr std::ptrdiff_t m_flTimeScale = 0x848; // float
    constexpr std::ptrdiff_t m_flNextMPSoundTime = 0x84C; // GameTime_t
}

namespace CFuncTrain { // CBasePlatTrain
    constexpr std::ptrdiff_t m_hCurrentTarget = 0x7A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_activated = 0x7AC; // bool
    constexpr std::ptrdiff_t m_hEnemy = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flBlockDamage = 0x7B4; // float
    constexpr std::ptrdiff_t m_flNextBlockTime = 0x7B8; // GameTime_t
    constexpr std::ptrdiff_t m_iszLastTarget = 0x7C0; // CUtlSymbolLarge
}

namespace CFuncTrainControls { // CBaseModelEntity
}

namespace CFuncVPhysicsClip { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x700; // bool
}

namespace CFuncVehicleClip { // CBaseModelEntity
}

namespace CFuncWall { // CBaseModelEntity
    constexpr std::ptrdiff_t m_nState = 0x700; // int32_t
}

namespace CFuncWallToggle { // CFuncWall
}

namespace CFuncWater { // CBaseModelEntity
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x700; // CBuoyancyHelper
}

namespace CGameChoreoServices { // IChoreoServices
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_hScriptedSequence = 0xC; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_scriptState = 0x10; // IChoreoServices::ScriptState_t
    constexpr std::ptrdiff_t m_choreoState = 0x14; // IChoreoServices::ChoreoState_t
    constexpr std::ptrdiff_t m_flTimeStartedState = 0x18; // GameTime_t
}

namespace CGameEnd { // CRulePointEntity
}

namespace CGameGibManager { // CBaseEntity
    constexpr std::ptrdiff_t m_bAllowNewGibs = 0x4D0; // bool
    constexpr std::ptrdiff_t m_iCurrentMaxPieces = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_iMaxPieces = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_iLastFrame = 0x4DC; // int32_t
}

namespace CGameMoney { // CRulePointEntity
    constexpr std::ptrdiff_t m_OnMoneySpent = 0x710; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMoneySpentFail = 0x738; // CEntityIOOutput
    constexpr std::ptrdiff_t m_nMoney = 0x760; // int32_t
    constexpr std::ptrdiff_t m_strAwardText = 0x768; // CUtlString
}

namespace CGamePlayerEquip { // CRulePointEntity
}

namespace CGamePlayerZone { // CRuleBrushEntity
    constexpr std::ptrdiff_t m_OnPlayerInZone = 0x708; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerOutZone = 0x730; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayersInCount = 0x758; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_PlayersOutCount = 0x780; // CEntityOutputTemplate<int32_t>
}

namespace CGameRules {
    constexpr std::ptrdiff_t m_szQuestName = 0x8; // char[128]
    constexpr std::ptrdiff_t m_nQuestPhase = 0x88; // int32_t
}

namespace CGameRulesProxy { // CBaseEntity
}

namespace CGameSceneNode {
    constexpr std::ptrdiff_t m_nodeToWorld = 0x10; // CTransform
    constexpr std::ptrdiff_t m_pOwner = 0x30; // CEntityInstance*
    constexpr std::ptrdiff_t m_pParent = 0x38; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pChild = 0x40; // CGameSceneNode*
    constexpr std::ptrdiff_t m_pNextSibling = 0x48; // CGameSceneNode*
    constexpr std::ptrdiff_t m_hParent = 0x70; // CGameSceneNodeHandle
    constexpr std::ptrdiff_t m_vecOrigin = 0x80; // CNetworkOriginCellCoordQuantizedVector
    constexpr std::ptrdiff_t m_angRotation = 0xB8; // QAngle
    constexpr std::ptrdiff_t m_flScale = 0xC4; // float
    constexpr std::ptrdiff_t m_vecAbsOrigin = 0xC8; // Vector
    constexpr std::ptrdiff_t m_angAbsRotation = 0xD4; // QAngle
    constexpr std::ptrdiff_t m_flAbsScale = 0xE0; // float
    constexpr std::ptrdiff_t m_nParentAttachmentOrBone = 0xE4; // int16_t
    constexpr std::ptrdiff_t m_bDebugAbsOriginChanges = 0xE6; // bool
    constexpr std::ptrdiff_t m_bDormant = 0xE7; // bool
    constexpr std::ptrdiff_t m_bForceParentToBeNetworked = 0xE8; // bool
    constexpr std::ptrdiff_t m_bDirtyHierarchy = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bDirtyBoneMergeInfo = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedPositionChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedAnglesChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNetworkedScaleChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bWillBeCallingPostDataUpdate = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bNotifyBoneTransformsChanged = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bBoneMergeFlex = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nLatchAbsOrigin = 0x0; // bitfield:2
    constexpr std::ptrdiff_t m_bDirtyBoneMergeBoneToRoot = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_nHierarchicalDepth = 0xEB; // uint8_t
    constexpr std::ptrdiff_t m_nHierarchyType = 0xEC; // uint8_t
    constexpr std::ptrdiff_t m_nDoNotSetAnimTimeInInvalidatePhysicsCount = 0xED; // uint8_t
    constexpr std::ptrdiff_t m_name = 0xF0; // CUtlStringToken
    constexpr std::ptrdiff_t m_hierarchyAttachName = 0x130; // CUtlStringToken
    constexpr std::ptrdiff_t m_flZOffset = 0x134; // float
    constexpr std::ptrdiff_t m_vRenderOrigin = 0x138; // Vector
}

namespace CGameSceneNodeHandle {
    constexpr std::ptrdiff_t m_hOwner = 0x8; // CEntityHandle
    constexpr std::ptrdiff_t m_name = 0xC; // CUtlStringToken
}

namespace CGameScriptedMoveData {
    constexpr std::ptrdiff_t m_vDest = 0x0; // Vector
    constexpr std::ptrdiff_t m_vSrc = 0xC; // Vector
    constexpr std::ptrdiff_t m_angSrc = 0x18; // QAngle
    constexpr std::ptrdiff_t m_angDst = 0x24; // QAngle
    constexpr std::ptrdiff_t m_angCurrent = 0x30; // QAngle
    constexpr std::ptrdiff_t m_flAngRate = 0x3C; // float
    constexpr std::ptrdiff_t m_flDuration = 0x40; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x44; // GameTime_t
    constexpr std::ptrdiff_t m_nPrevMoveType = 0x48; // MoveType_t
    constexpr std::ptrdiff_t m_bActive = 0x49; // bool
    constexpr std::ptrdiff_t m_bTeleportOnEnd = 0x4A; // bool
    constexpr std::ptrdiff_t m_bEndOnDestinationReached = 0x4B; // bool
    constexpr std::ptrdiff_t m_bIgnoreRotation = 0x4C; // bool
    constexpr std::ptrdiff_t m_nType = 0x50; // ScriptedMoveType_t
    constexpr std::ptrdiff_t m_bSuccess = 0x54; // bool
    constexpr std::ptrdiff_t m_nForcedCrouchState = 0x58; // ForcedCrouchState_t
    constexpr std::ptrdiff_t m_bIgnoreCollisions = 0x5C; // bool
}

namespace CGameText { // CRulePointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_textParms = 0x718; // hudtextparms_t
}

namespace CGenericConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_nLinearMotionX = 0x510; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionY = 0x514; // JointMotion_t
    constexpr std::ptrdiff_t m_nLinearMotionZ = 0x518; // JointMotion_t
    constexpr std::ptrdiff_t m_flLinearFrequencyX = 0x51C; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyY = 0x520; // float
    constexpr std::ptrdiff_t m_flLinearFrequencyZ = 0x524; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioX = 0x528; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioY = 0x52C; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatioZ = 0x530; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseX = 0x534; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseY = 0x538; // float
    constexpr std::ptrdiff_t m_flMaxLinearImpulseZ = 0x53C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeX = 0x540; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeY = 0x544; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeZ = 0x548; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeX = 0x54C; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeY = 0x550; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeStartTimeZ = 0x554; // GameTime_t
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdX = 0x558; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdY = 0x55C; // float
    constexpr std::ptrdiff_t m_flBreakAfterTimeThresholdZ = 0x560; // float
    constexpr std::ptrdiff_t m_flNotifyForceX = 0x564; // float
    constexpr std::ptrdiff_t m_flNotifyForceY = 0x568; // float
    constexpr std::ptrdiff_t m_flNotifyForceZ = 0x56C; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeX = 0x570; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeY = 0x574; // float
    constexpr std::ptrdiff_t m_flNotifyForceMinTimeZ = 0x578; // float
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeX = 0x57C; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeY = 0x580; // GameTime_t
    constexpr std::ptrdiff_t m_flNotifyForceLastTimeZ = 0x584; // GameTime_t
    constexpr std::ptrdiff_t m_bAxisNotifiedX = 0x588; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedY = 0x589; // bool
    constexpr std::ptrdiff_t m_bAxisNotifiedZ = 0x58A; // bool
    constexpr std::ptrdiff_t m_nAngularMotionX = 0x58C; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionY = 0x590; // JointMotion_t
    constexpr std::ptrdiff_t m_nAngularMotionZ = 0x594; // JointMotion_t
    constexpr std::ptrdiff_t m_flAngularFrequencyX = 0x598; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyY = 0x59C; // float
    constexpr std::ptrdiff_t m_flAngularFrequencyZ = 0x5A0; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioX = 0x5A4; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioY = 0x5A8; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatioZ = 0x5AC; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseX = 0x5B0; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseY = 0x5B4; // float
    constexpr std::ptrdiff_t m_flMaxAngularImpulseZ = 0x5B8; // float
    constexpr std::ptrdiff_t m_NotifyForceReachedX = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedY = 0x5E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyForceReachedZ = 0x610; // CEntityIOOutput
}

namespace CGlowProperty {
    constexpr std::ptrdiff_t m_fGlowColor = 0x8; // Vector
    constexpr std::ptrdiff_t m_iGlowType = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iGlowTeam = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_glowColorOverride = 0x40; // Color
    constexpr std::ptrdiff_t m_bFlashing = 0x44; // bool
    constexpr std::ptrdiff_t m_flGlowTime = 0x48; // float
    constexpr std::ptrdiff_t m_flGlowStartTime = 0x4C; // float
    constexpr std::ptrdiff_t m_bEligibleForScreenHighlight = 0x50; // bool
    constexpr std::ptrdiff_t m_bGlowing = 0x51; // bool
}

namespace CGradientFog { // CBaseEntity
    constexpr std::ptrdiff_t m_hGradientFogTexture = 0x4B0; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_flFogStartDistance = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFogEndDistance = 0x4BC; // float
    constexpr std::ptrdiff_t m_bHeightFogEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_flFogStartHeight = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogEndHeight = 0x4C8; // float
    constexpr std::ptrdiff_t m_flFarZ = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFogMaxOpacity = 0x4D0; // float
    constexpr std::ptrdiff_t m_flFogFalloffExponent = 0x4D4; // float
    constexpr std::ptrdiff_t m_flFogVerticalExponent = 0x4D8; // float
    constexpr std::ptrdiff_t m_fogColor = 0x4DC; // Color
    constexpr std::ptrdiff_t m_flFogStrength = 0x4E0; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4E4; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bGradientFogNeedsTextures = 0x4EA; // bool
}

namespace CGunTarget { // CBaseToggle
    constexpr std::ptrdiff_t m_on = 0x780; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x784; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_OnDeath = 0x788; // CEntityIOOutput
}

namespace CHEGrenade { // CBaseCSGrenade
}

namespace CHEGrenadeProjectile { // CBaseCSGrenadeProjectile
}

namespace CHandleDummy { // CBaseEntity
}

namespace CHandleTest { // CBaseEntity
    constexpr std::ptrdiff_t m_Handle = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bSendHandle = 0x4B4; // bool
}

namespace CHintMessage {
    constexpr std::ptrdiff_t m_hintString = 0x8; // char*
    constexpr std::ptrdiff_t m_args = 0x10; // CUtlVector<char*>
    constexpr std::ptrdiff_t m_duration = 0x28; // float
}

namespace CHintMessageQueue {
    constexpr std::ptrdiff_t m_tmMessageEnd = 0x8; // float
    constexpr std::ptrdiff_t m_messages = 0x10; // CUtlVector<CHintMessage*>
    constexpr std::ptrdiff_t m_pPlayerController = 0x28; // CBasePlayerController*
}

namespace CHitboxComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_bvDisabledHitGroups = 0x24; // uint32_t[1]
}

namespace CHostage { // CHostageExpresserShim
    constexpr std::ptrdiff_t m_OnHostageBeginGrab = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFirstPickedUp = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDroppedNotRescued = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRescued = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_entitySpottedState = 0xA88; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0xAA0; // int32_t
    constexpr std::ptrdiff_t m_uiHostageSpawnExclusionGroupMask = 0xAA4; // uint32_t
    constexpr std::ptrdiff_t m_nHostageSpawnRandomFactor = 0xAA8; // uint32_t
    constexpr std::ptrdiff_t m_bRemove = 0xAAC; // bool
    constexpr std::ptrdiff_t m_vel = 0xAB0; // Vector
    constexpr std::ptrdiff_t m_isRescued = 0xABC; // bool
    constexpr std::ptrdiff_t m_jumpedThisFrame = 0xABD; // bool
    constexpr std::ptrdiff_t m_nHostageState = 0xAC0; // int32_t
    constexpr std::ptrdiff_t m_leader = 0xAC4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastLeader = 0xAC8; // CHandle<CCSPlayerPawnBase>
    constexpr std::ptrdiff_t m_reuseTimer = 0xAD0; // CountdownTimer
    constexpr std::ptrdiff_t m_hasBeenUsed = 0xAE8; // bool
    constexpr std::ptrdiff_t m_accel = 0xAEC; // Vector
    constexpr std::ptrdiff_t m_isRunning = 0xAF8; // bool
    constexpr std::ptrdiff_t m_isCrouching = 0xAF9; // bool
    constexpr std::ptrdiff_t m_jumpTimer = 0xB00; // CountdownTimer
    constexpr std::ptrdiff_t m_isWaitingForLeader = 0xB18; // bool
    constexpr std::ptrdiff_t m_repathTimer = 0x2B28; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitDoorTimer = 0x2B40; // CountdownTimer
    constexpr std::ptrdiff_t m_inhibitObstacleAvoidanceTimer = 0x2BD0; // CountdownTimer
    constexpr std::ptrdiff_t m_wiggleTimer = 0x2BF0; // CountdownTimer
    constexpr std::ptrdiff_t m_isAdjusted = 0x2C0C; // bool
    constexpr std::ptrdiff_t m_bHandsHaveBeenCut = 0x2C0D; // bool
    constexpr std::ptrdiff_t m_hHostageGrabber = 0x2C10; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_fLastGrabTime = 0x2C14; // GameTime_t
    constexpr std::ptrdiff_t m_vecPositionWhenStartedDroppingToGround = 0x2C18; // Vector
    constexpr std::ptrdiff_t m_vecGrabbedPos = 0x2C24; // Vector
    constexpr std::ptrdiff_t m_flRescueStartTime = 0x2C30; // GameTime_t
    constexpr std::ptrdiff_t m_flGrabSuccessTime = 0x2C34; // GameTime_t
    constexpr std::ptrdiff_t m_flDropStartTime = 0x2C38; // GameTime_t
    constexpr std::ptrdiff_t m_nApproachRewardPayouts = 0x2C3C; // int32_t
    constexpr std::ptrdiff_t m_nPickupEventCount = 0x2C40; // int32_t
    constexpr std::ptrdiff_t m_vecSpawnGroundPos = 0x2C44; // Vector
    constexpr std::ptrdiff_t m_vecHostageResetPosition = 0x2C64; // Vector
}

namespace CHostageAlias_info_hostage_spawn { // CHostage
}

namespace CHostageCarriableProp { // CBaseAnimGraph
}

namespace CHostageExpresserShim { // CBaseCombatCharacter
    constexpr std::ptrdiff_t m_pExpresser = 0x9D0; // CAI_Expresser*
}

namespace CHostageRescueZone { // CHostageRescueZoneShim
}

namespace CHostageRescueZoneShim { // CBaseTrigger
}

namespace CInButtonState {
    constexpr std::ptrdiff_t m_pButtonStates = 0x8; // uint64_t[3]
}

namespace CIncendiaryGrenade { // CMolotovGrenade
}

namespace CInferno { // CBaseModelEntity
    constexpr std::ptrdiff_t m_firePositions = 0x710; // Vector[64]
    constexpr std::ptrdiff_t m_fireParentPositions = 0xA10; // Vector[64]
    constexpr std::ptrdiff_t m_bFireIsBurning = 0xD10; // bool[64]
    constexpr std::ptrdiff_t m_BurnNormal = 0xD50; // Vector[64]
    constexpr std::ptrdiff_t m_fireCount = 0x1050; // int32_t
    constexpr std::ptrdiff_t m_nInfernoType = 0x1054; // int32_t
    constexpr std::ptrdiff_t m_nFireEffectTickBegin = 0x1058; // int32_t
    constexpr std::ptrdiff_t m_nFireLifetime = 0x105C; // float
    constexpr std::ptrdiff_t m_bInPostEffectTime = 0x1060; // bool
    constexpr std::ptrdiff_t m_nFiresExtinguishCount = 0x1064; // int32_t
    constexpr std::ptrdiff_t m_bWasCreatedInSmoke = 0x1068; // bool
    constexpr std::ptrdiff_t m_extent = 0x1270; // Extent
    constexpr std::ptrdiff_t m_damageTimer = 0x1288; // CountdownTimer
    constexpr std::ptrdiff_t m_damageRampTimer = 0x12A0; // CountdownTimer
    constexpr std::ptrdiff_t m_splashVelocity = 0x12B8; // Vector
    constexpr std::ptrdiff_t m_InitialSplashVelocity = 0x12C4; // Vector
    constexpr std::ptrdiff_t m_startPos = 0x12D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalSpawnLocation = 0x12DC; // Vector
    constexpr std::ptrdiff_t m_activeTimer = 0x12E8; // IntervalTimer
    constexpr std::ptrdiff_t m_fireSpawnOffset = 0x12F8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFlames = 0x12FC; // int32_t
    constexpr std::ptrdiff_t m_BookkeepingTimer = 0x1300; // CountdownTimer
    constexpr std::ptrdiff_t m_NextSpreadTimer = 0x1318; // CountdownTimer
    constexpr std::ptrdiff_t m_nSourceItemDefIndex = 0x1330; // uint16_t
}

namespace CInfoData { // CServerOnlyEntity
}

namespace CInfoDeathmatchSpawn { // SpawnPoint
}

namespace CInfoDynamicShadowHint { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flRange = 0x4B4; // float
    constexpr std::ptrdiff_t m_nImportance = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLightChoice = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_hLight = 0x4C0; // CHandle<CBaseEntity>
}

namespace CInfoDynamicShadowHintBox { // CInfoDynamicShadowHint
    constexpr std::ptrdiff_t m_vBoxMins = 0x4C8; // Vector
    constexpr std::ptrdiff_t m_vBoxMaxs = 0x4D4; // Vector
}

namespace CInfoEnemyTerroristSpawn { // SpawnPointCoopEnemy
}

namespace CInfoGameEventProxy { // CPointEntity
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flRange = 0x4B8; // float
}

namespace CInfoInstructorHintBombTargetA { // CPointEntity
}

namespace CInfoInstructorHintBombTargetB { // CPointEntity
}

namespace CInfoInstructorHintHostageRescueZone { // CPointEntity
}

namespace CInfoInstructorHintTarget { // CPointEntity
}

namespace CInfoLadderDismount { // CBaseEntity
}

namespace CInfoLandmark { // CPointEntity
}

namespace CInfoOffscreenPanoramaTexture { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nResolutionX = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nResolutionY = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_szLayoutFileName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_RenderAttrName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_TargetEntities = 0x4D0; // CNetworkUtlVectorBase<CHandle<CBaseModelEntity>>
    constexpr std::ptrdiff_t m_nTargetChangeCount = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x4F0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_szTargetsName = 0x508; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_AdditionalTargetEntities = 0x510; // CUtlVector<CHandle<CBaseModelEntity>>
}

namespace CInfoParticleTarget { // CPointEntity
}

namespace CInfoPlayerCounterterrorist { // SpawnPoint
}

namespace CInfoPlayerStart { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
}

namespace CInfoPlayerTerrorist { // SpawnPoint
}

namespace CInfoSpawnGroupLandmark { // CPointEntity
}

namespace CInfoSpawnGroupLoadUnload { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadStarted = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupLoadFinished = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadStarted = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawnGroupUnloadFinished = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSpawnGroupName = 0x550; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpawnGroupFilterName = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLandmarkName = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sFixedSpawnGroupName = 0x568; // CUtlString
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x570; // float
    constexpr std::ptrdiff_t m_bStreamingStarted = 0x574; // bool
    constexpr std::ptrdiff_t m_bUnloadingStarted = 0x575; // bool
}

namespace CInfoTarget { // CPointEntity
}

namespace CInfoTargetServerOnly { // CServerOnlyPointEntity
}

namespace CInfoTeleportDestination { // CPointEntity
}

namespace CInfoVisibilityBox { // CBaseEntity
    constexpr std::ptrdiff_t m_nMode = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_vBoxSize = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
}

namespace CInfoWorldLayer { // CBaseEntity
    constexpr std::ptrdiff_t m_pOutputOnEntitiesSpawned = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_worldName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_layerName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bWorldLayerVisible = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bEntitiesSpawned = 0x4E9; // bool
    constexpr std::ptrdiff_t m_bCreateAsChildSpawnGroup = 0x4EA; // bool
    constexpr std::ptrdiff_t m_hLayerSpawnGroup = 0x4EC; // uint32_t
}

namespace CInstancedSceneEntity { // CSceneEntity
    constexpr std::ptrdiff_t m_hOwner = 0xA08; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bHadOwner = 0xA0C; // bool
    constexpr std::ptrdiff_t m_flPostSpeakDelay = 0xA10; // float
    constexpr std::ptrdiff_t m_flPreDelay = 0xA14; // float
    constexpr std::ptrdiff_t m_bIsBackground = 0xA18; // bool
}

namespace CInstructorEventEntity { // CPointEntity
    constexpr std::ptrdiff_t m_iszName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszHintTargetEntity = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetPlayer = 0x4C0; // CHandle<CBasePlayerPawn>
}

namespace CIronSightController {
    constexpr std::ptrdiff_t m_bIronSightAvailable = 0x8; // bool
    constexpr std::ptrdiff_t m_flIronSightAmount = 0xC; // float
    constexpr std::ptrdiff_t m_flIronSightAmountGained = 0x10; // float
    constexpr std::ptrdiff_t m_flIronSightAmountBiased = 0x14; // float
}

namespace CItem { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_OnPlayerTouch = 0x898; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActivateWhenAtRest = 0x8C0; // bool
    constexpr std::ptrdiff_t m_OnCacheInteraction = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGlovePulled = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0x940; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0x94C; // QAngle
    constexpr std::ptrdiff_t m_bPhysStartAsleep = 0x958; // bool
}

namespace CItemAssaultSuit { // CItem
}

namespace CItemDefuser { // CItem
    constexpr std::ptrdiff_t m_entitySpottedState = 0x968; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x980; // int32_t
}

namespace CItemDefuserAlias_item_defuser { // CItemDefuser
}

namespace CItemDogtags { // CItem
    constexpr std::ptrdiff_t m_OwningPlayer = 0x968; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_KillingPlayer = 0x96C; // CHandle<CCSPlayerPawn>
}

namespace CItemGeneric { // CItem
    constexpr std::ptrdiff_t m_bHasTriggerRadius = 0x970; // bool
    constexpr std::ptrdiff_t m_bHasPickupRadius = 0x971; // bool
    constexpr std::ptrdiff_t m_flPickupRadiusSqr = 0x974; // float
    constexpr std::ptrdiff_t m_flTriggerRadiusSqr = 0x978; // float
    constexpr std::ptrdiff_t m_flLastPickupCheck = 0x97C; // GameTime_t
    constexpr std::ptrdiff_t m_bPlayerCounterListenerAdded = 0x980; // bool
    constexpr std::ptrdiff_t m_bPlayerInTriggerRadius = 0x981; // bool
    constexpr std::ptrdiff_t m_hSpawnParticleEffect = 0x988; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pAmbientSoundEffect = 0x990; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bAutoStartAmbientSound = 0x998; // bool
    constexpr std::ptrdiff_t m_pSpawnScriptFunction = 0x9A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupParticleEffect = 0x9A8; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pPickupSoundEffect = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupScriptFunction = 0x9B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTimeoutParticleEffect = 0x9C0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_pTimeoutSoundEffect = 0x9C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pTimeoutScriptFunction = 0x9D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pPickupFilterName = 0x9D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hPickupFilter = 0x9E0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnPickup = 0x9E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimeout = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerStartTouch = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerTouch = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTriggerEndTouch = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pAllowPickupScriptFunction = 0xAB0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPickupRadius = 0xAB8; // float
    constexpr std::ptrdiff_t m_flTriggerRadius = 0xABC; // float
    constexpr std::ptrdiff_t m_pTriggerSoundEffect = 0xAC0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bGlowWhenInTrigger = 0xAC8; // bool
    constexpr std::ptrdiff_t m_glowColor = 0xAC9; // Color
    constexpr std::ptrdiff_t m_bUseable = 0xACD; // bool
    constexpr std::ptrdiff_t m_hTriggerHelper = 0xAD0; // CHandle<CItemGenericTriggerHelper>
}

namespace CItemGenericTriggerHelper { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hParentItem = 0x700; // CHandle<CItemGeneric>
}

namespace CItemHeavyAssaultSuit { // CItemAssaultSuit
}

namespace CItemKevlar { // CItem
}

namespace CItemSoda { // CBaseAnimGraph
}

namespace CItem_Healthshot { // CWeaponBaseItem
}

namespace CKeepUpright { // CPointEntity
    constexpr std::ptrdiff_t m_worldGoalAxis = 0x4B8; // Vector
    constexpr std::ptrdiff_t m_localTestAxis = 0x4C4; // Vector
    constexpr std::ptrdiff_t m_nameAttach = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_attachedObject = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_angularLimit = 0x4E4; // float
    constexpr std::ptrdiff_t m_bActive = 0x4E8; // bool
    constexpr std::ptrdiff_t m_bDampAllRotation = 0x4E9; // bool
}

namespace CKnife { // CCSWeaponBase
    constexpr std::ptrdiff_t m_bFirstAttack = 0xE20; // bool
}

namespace CLightComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x48; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Color = 0x85; // Color
    constexpr std::ptrdiff_t m_SecondaryColor = 0x89; // Color
    constexpr std::ptrdiff_t m_flBrightness = 0x90; // float
    constexpr std::ptrdiff_t m_flBrightnessScale = 0x94; // float
    constexpr std::ptrdiff_t m_flBrightnessMult = 0x98; // float
    constexpr std::ptrdiff_t m_flRange = 0x9C; // float
    constexpr std::ptrdiff_t m_flFalloff = 0xA0; // float
    constexpr std::ptrdiff_t m_flAttenuation0 = 0xA4; // float
    constexpr std::ptrdiff_t m_flAttenuation1 = 0xA8; // float
    constexpr std::ptrdiff_t m_flAttenuation2 = 0xAC; // float
    constexpr std::ptrdiff_t m_flTheta = 0xB0; // float
    constexpr std::ptrdiff_t m_flPhi = 0xB4; // float
    constexpr std::ptrdiff_t m_hLightCookie = 0xB8; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_nCascades = 0xC0; // int32_t
    constexpr std::ptrdiff_t m_nCastShadows = 0xC4; // int32_t
    constexpr std::ptrdiff_t m_nShadowWidth = 0xC8; // int32_t
    constexpr std::ptrdiff_t m_nShadowHeight = 0xCC; // int32_t
    constexpr std::ptrdiff_t m_bRenderDiffuse = 0xD0; // bool
    constexpr std::ptrdiff_t m_nRenderSpecular = 0xD4; // int32_t
    constexpr std::ptrdiff_t m_bRenderTransmissive = 0xD8; // bool
    constexpr std::ptrdiff_t m_flOrthoLightWidth = 0xDC; // float
    constexpr std::ptrdiff_t m_flOrthoLightHeight = 0xE0; // float
    constexpr std::ptrdiff_t m_nStyle = 0xE4; // int32_t
    constexpr std::ptrdiff_t m_Pattern = 0xE8; // CUtlString
    constexpr std::ptrdiff_t m_nCascadeRenderStaticObjects = 0xF0; // int32_t
    constexpr std::ptrdiff_t m_flShadowCascadeCrossFade = 0xF4; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistanceFade = 0xF8; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance0 = 0xFC; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance1 = 0x100; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance2 = 0x104; // float
    constexpr std::ptrdiff_t m_flShadowCascadeDistance3 = 0x108; // float
    constexpr std::ptrdiff_t m_nShadowCascadeResolution0 = 0x10C; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution1 = 0x110; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution2 = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nShadowCascadeResolution3 = 0x118; // int32_t
    constexpr std::ptrdiff_t m_bUsesBakedShadowing = 0x11C; // bool
    constexpr std::ptrdiff_t m_nShadowPriority = 0x120; // int32_t
    constexpr std::ptrdiff_t m_nBakedShadowIndex = 0x124; // int32_t
    constexpr std::ptrdiff_t m_bRenderToCubemaps = 0x128; // bool
    constexpr std::ptrdiff_t m_nDirectLight = 0x12C; // int32_t
    constexpr std::ptrdiff_t m_nIndirectLight = 0x130; // int32_t
    constexpr std::ptrdiff_t m_flFadeMinDist = 0x134; // float
    constexpr std::ptrdiff_t m_flFadeMaxDist = 0x138; // float
    constexpr std::ptrdiff_t m_flShadowFadeMinDist = 0x13C; // float
    constexpr std::ptrdiff_t m_flShadowFadeMaxDist = 0x140; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x144; // bool
    constexpr std::ptrdiff_t m_bFlicker = 0x145; // bool
    constexpr std::ptrdiff_t m_bPrecomputedFieldsValid = 0x146; // bool
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMins = 0x148; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedBoundsMaxs = 0x154; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBOrigin = 0x160; // Vector
    constexpr std::ptrdiff_t m_vPrecomputedOBBAngles = 0x16C; // QAngle
    constexpr std::ptrdiff_t m_vPrecomputedOBBExtent = 0x178; // Vector
    constexpr std::ptrdiff_t m_flPrecomputedMaxRange = 0x184; // float
    constexpr std::ptrdiff_t m_nFogLightingMode = 0x188; // int32_t
    constexpr std::ptrdiff_t m_flFogContributionStength = 0x18C; // float
    constexpr std::ptrdiff_t m_flNearClipPlane = 0x190; // float
    constexpr std::ptrdiff_t m_SkyColor = 0x194; // Color
    constexpr std::ptrdiff_t m_flSkyIntensity = 0x198; // float
    constexpr std::ptrdiff_t m_SkyAmbientBounce = 0x19C; // Color
    constexpr std::ptrdiff_t m_bUseSecondaryColor = 0x1A0; // bool
    constexpr std::ptrdiff_t m_bMixedShadows = 0x1A1; // bool
    constexpr std::ptrdiff_t m_flLightStyleStartTime = 0x1A4; // GameTime_t
    constexpr std::ptrdiff_t m_flCapsuleLength = 0x1A8; // float
    constexpr std::ptrdiff_t m_flMinRoughness = 0x1AC; // float
    constexpr std::ptrdiff_t m_bPvsModifyEntity = 0x1C0; // bool
}

namespace CLightDirectionalEntity { // CLightEntity
}

namespace CLightEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_CLightComponent = 0x700; // CLightComponent*
}

namespace CLightEnvironmentEntity { // CLightDirectionalEntity
}

namespace CLightGlow { // CBaseModelEntity
    constexpr std::ptrdiff_t m_nHorizontalSize = 0x700; // uint32_t
    constexpr std::ptrdiff_t m_nVerticalSize = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_nMinDist = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_nMaxDist = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_nOuterMaxDist = 0x710; // uint32_t
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x714; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x718; // float
}

namespace CLightOrthoEntity { // CLightEntity
}

namespace CLightSpotEntity { // CLightEntity
}

namespace CLogicAchievement { // CLogicalEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszAchievementEventID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnFired = 0x4C0; // CEntityIOOutput
}

namespace CLogicActiveAutosave { // CLogicAutosave
    constexpr std::ptrdiff_t m_TriggerHitPoints = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_flTimeToTrigger = 0x4C4; // float
    constexpr std::ptrdiff_t m_flStartTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4CC; // float
}

namespace CLogicAuto { // CBaseEntity
    constexpr std::ptrdiff_t m_OnMapSpawn = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDemoMapSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNewGame = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLoadGame = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMapTransition = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBackgroundMap = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewMap = 0x5A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMultiNewRound = 0x5C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVREnabled = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnVRNotEnabled = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_globalstate = 0x640; // CUtlSymbolLarge
}

namespace CLogicAutosave { // CLogicalEntity
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4B0; // bool
    constexpr std::ptrdiff_t m_minHitPoints = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_minHitPointsToCommit = 0x4B8; // int32_t
}

namespace CLogicBranch { // CLogicalEntity
    constexpr std::ptrdiff_t m_bInValue = 0x4B0; // bool
    constexpr std::ptrdiff_t m_Listeners = 0x4B8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_OnTrue = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFalse = 0x4F8; // CEntityIOOutput
}

namespace CLogicBranchList { // CLogicalEntity
    constexpr std::ptrdiff_t m_nLogicBranchNames = 0x4B0; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_LogicBranchList = 0x530; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_eLastState = 0x548; // CLogicBranchList::LogicBranchListenerLastState_t
    constexpr std::ptrdiff_t m_OnAllTrue = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAllFalse = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMixed = 0x5A0; // CEntityIOOutput
}

namespace CLogicCase { // CLogicalEntity
    constexpr std::ptrdiff_t m_nCase = 0x4B0; // CUtlSymbolLarge[32]
    constexpr std::ptrdiff_t m_nShuffleCases = 0x5B0; // int32_t
    constexpr std::ptrdiff_t m_nLastShuffleCase = 0x5B4; // int32_t
    constexpr std::ptrdiff_t m_uchShuffleCaseMap = 0x5B8; // uint8_t[32]
    constexpr std::ptrdiff_t m_OnCase = 0x5D8; // CEntityIOOutput[32]
    constexpr std::ptrdiff_t m_OnDefault = 0xAD8; // CEntityOutputTemplate<CVariantBase<CVariantDefaultAllocator>>
}

namespace CLogicCollisionPair { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_disabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_succeeded = 0x4C1; // bool
}

namespace CLogicCompare { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInValue = 0x4B0; // float
    constexpr std::ptrdiff_t m_flCompareValue = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnLessThan = 0x4B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnEqualTo = 0x4E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnNotEqualTo = 0x508; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x530; // CEntityOutputTemplate<float>
}

namespace CLogicDistanceAutosave { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszTargetEntity = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceToPlayer = 0x4B8; // float
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bCheckCough = 0x4BD; // bool
    constexpr std::ptrdiff_t m_bThinkDangerous = 0x4BE; // bool
    constexpr std::ptrdiff_t m_flDangerousTime = 0x4C0; // float
}

namespace CLogicDistanceCheck { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszEntityA = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityB = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flZone1Distance = 0x4C0; // float
    constexpr std::ptrdiff_t m_flZone2Distance = 0x4C4; // float
    constexpr std::ptrdiff_t m_InZone1 = 0x4C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone2 = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_InZone3 = 0x518; // CEntityIOOutput
}

namespace CLogicEventListener { // CLogicalEntity
    constexpr std::ptrdiff_t m_strEventName = 0x4C0; // CUtlString
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4C8; // bool
    constexpr std::ptrdiff_t m_nTeam = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_OnEventFired = 0x4D0; // CEntityIOOutput
}

namespace CLogicGameEvent { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszEventName = 0x4B0; // CUtlSymbolLarge
}

namespace CLogicGameEventListener { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnEventFired = 0x4C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszGameEventName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszGameEventItem = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bEnabled = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4F9; // bool
}

namespace CLogicLineToEntity { // CLogicalEntity
    constexpr std::ptrdiff_t m_Line = 0x4B0; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_SourceName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_StartEntity = 0x4E0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_EndEntity = 0x4E4; // CHandle<CBaseEntity>
}

namespace CLogicMeasureMovement { // CLogicalEntity
    constexpr std::ptrdiff_t m_strMeasureTarget = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMeasureReference = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strTargetReference = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hMeasureReference = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTargetReference = 0x4D4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flScale = 0x4D8; // float
    constexpr std::ptrdiff_t m_nMeasureType = 0x4DC; // int32_t
}

namespace CLogicNPCCounter { // CBaseEntity
    constexpr std::ptrdiff_t m_OnMinCountAll = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCountAll = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactorAll = 0x500; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDistAll = 0x528; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_1 = 0x550; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_1 = 0x578; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_1 = 0x5A0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_1 = 0x5C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_2 = 0x5F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_2 = 0x618; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_2 = 0x640; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_2 = 0x668; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinCount_3 = 0x690; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMaxCount_3 = 0x6B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFactor_3 = 0x6E0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnMinPlayerDist_3 = 0x708; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_hSource = 0x730; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x738; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flDistanceMax = 0x740; // float
    constexpr std::ptrdiff_t m_bDisabled = 0x744; // bool
    constexpr std::ptrdiff_t m_nMinCountAll = 0x748; // int32_t
    constexpr std::ptrdiff_t m_nMaxCountAll = 0x74C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactorAll = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactorAll = 0x754; // int32_t
    constexpr std::ptrdiff_t m_iszNPCClassname_1 = 0x760; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_1 = 0x768; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_1 = 0x76C; // bool
    constexpr std::ptrdiff_t m_nMinCount_1 = 0x770; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_1 = 0x774; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_1 = 0x778; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_1 = 0x77C; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_1 = 0x784; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_2 = 0x788; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_2 = 0x790; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_2 = 0x794; // bool
    constexpr std::ptrdiff_t m_nMinCount_2 = 0x798; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_2 = 0x79C; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_2 = 0x7A0; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_2 = 0x7A4; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_2 = 0x7AC; // float
    constexpr std::ptrdiff_t m_iszNPCClassname_3 = 0x7B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNPCState_3 = 0x7B8; // int32_t
    constexpr std::ptrdiff_t m_bInvertState_3 = 0x7BC; // bool
    constexpr std::ptrdiff_t m_nMinCount_3 = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_nMaxCount_3 = 0x7C4; // int32_t
    constexpr std::ptrdiff_t m_nMinFactor_3 = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_nMaxFactor_3 = 0x7CC; // int32_t
    constexpr std::ptrdiff_t m_flDefaultDist_3 = 0x7D4; // float
}

namespace CLogicNPCCounterAABB { // CLogicNPCCounter
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x7F0; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x7FC; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x808; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x814; // Vector
}

namespace CLogicNPCCounterOBB { // CLogicNPCCounterAABB
}

namespace CLogicNavigation { // CLogicalEntity
    constexpr std::ptrdiff_t m_isOn = 0x4B8; // bool
    constexpr std::ptrdiff_t m_navProperty = 0x4BC; // navproperties_t
}

namespace CLogicPlayerProxy { // CLogicalEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_PlayerHasAmmo = 0x4B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerHasNoAmmo = 0x4E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_PlayerDied = 0x508; // CEntityIOOutput
    constexpr std::ptrdiff_t m_RequestedPlayerHealth = 0x530; // CEntityOutputTemplate<int32_t>
}

namespace CLogicProximity { // CPointEntity
}

namespace CLogicRelay { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTrigger = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnSpawn = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bDisabled = 0x500; // bool
    constexpr std::ptrdiff_t m_bWaitForRefire = 0x501; // bool
    constexpr std::ptrdiff_t m_bTriggerOnce = 0x502; // bool
    constexpr std::ptrdiff_t m_bFastRetrigger = 0x503; // bool
    constexpr std::ptrdiff_t m_bPassthoughCaller = 0x504; // bool
}

namespace CLogicScript { // CPointEntity
}

namespace CLogicalEntity { // CServerOnlyEntity
}

namespace CMapInfo { // CPointEntity
    constexpr std::ptrdiff_t m_iBuyingStatus = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flBombRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_iPetPopulation = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_bUseNormalSpawnsForDM = 0x4BC; // bool
    constexpr std::ptrdiff_t m_bDisableAutoGeneratedDMSpawns = 0x4BD; // bool
    constexpr std::ptrdiff_t m_flBotMaxVisionDistance = 0x4C0; // float
    constexpr std::ptrdiff_t m_iHostageCount = 0x4C4; // int32_t
    constexpr std::ptrdiff_t m_bFadePlayerVisibilityFarZ = 0x4C8; // bool
}

namespace CMapVetoPickController { // CBaseEntity
    constexpr std::ptrdiff_t m_bPlayedIntroVcd = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bNeedToPlayFiveSecondsRemaining = 0x4B1; // bool
    constexpr std::ptrdiff_t m_dblPreMatchDraftSequenceTime = 0x4D0; // double
    constexpr std::ptrdiff_t m_bPreMatchDraftStateChanged = 0x4D8; // bool
    constexpr std::ptrdiff_t m_nDraftType = 0x4DC; // int32_t
    constexpr std::ptrdiff_t m_nTeamWinningCoinToss = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nTeamWithFirstChoice = 0x4E4; // int32_t[64]
    constexpr std::ptrdiff_t m_nVoteMapIdsList = 0x5E4; // int32_t[7]
    constexpr std::ptrdiff_t m_nAccountIDs = 0x600; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId0 = 0x700; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId1 = 0x800; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId2 = 0x900; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId3 = 0xA00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId4 = 0xB00; // int32_t[64]
    constexpr std::ptrdiff_t m_nMapId5 = 0xC00; // int32_t[64]
    constexpr std::ptrdiff_t m_nStartingSide0 = 0xD00; // int32_t[64]
    constexpr std::ptrdiff_t m_nCurrentPhase = 0xE00; // int32_t
    constexpr std::ptrdiff_t m_nPhaseStartTick = 0xE04; // int32_t
    constexpr std::ptrdiff_t m_nPhaseDurationTicks = 0xE08; // int32_t
    constexpr std::ptrdiff_t m_OnMapVetoed = 0xE10; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnMapPicked = 0xE38; // CEntityOutputTemplate<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_OnSidesPicked = 0xE60; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnNewPhaseStarted = 0xE88; // CEntityOutputTemplate<int32_t>
    constexpr std::ptrdiff_t m_OnLevelTransition = 0xEB0; // CEntityOutputTemplate<int32_t>
}

namespace CMarkupVolume { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x700; // bool
}

namespace CMarkupVolumeTagged { // CMarkupVolume
    constexpr std::ptrdiff_t m_bIsGroup = 0x738; // bool
    constexpr std::ptrdiff_t m_bGroupByPrefab = 0x739; // bool
    constexpr std::ptrdiff_t m_bGroupByVolume = 0x73A; // bool
    constexpr std::ptrdiff_t m_bGroupOtherGroups = 0x73B; // bool
    constexpr std::ptrdiff_t m_bIsInGroup = 0x73C; // bool
}

namespace CMarkupVolumeTagged_Nav { // CMarkupVolumeTagged
}

namespace CMarkupVolumeTagged_NavGame { // CMarkupVolumeWithRef
    constexpr std::ptrdiff_t m_bFloodFillAttribute = 0x758; // bool
}

namespace CMarkupVolumeWithRef { // CMarkupVolumeTagged
    constexpr std::ptrdiff_t m_bUseRef = 0x740; // bool
    constexpr std::ptrdiff_t m_vRefPos = 0x744; // Vector
    constexpr std::ptrdiff_t m_flRefDot = 0x750; // float
}

namespace CMathColorBlend { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_OutColor1 = 0x4B8; // Color
    constexpr std::ptrdiff_t m_OutColor2 = 0x4BC; // Color
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<Color>
}

namespace CMathCounter { // CLogicalEntity
    constexpr std::ptrdiff_t m_flMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_bHitMin = 0x4B8; // bool
    constexpr std::ptrdiff_t m_bHitMax = 0x4B9; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x4BA; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C0; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnGetValue = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnHitMin = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHitMax = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMin = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnChangedFromMax = 0x588; // CEntityIOOutput
}

namespace CMathRemap { // CLogicalEntity
    constexpr std::ptrdiff_t m_flInMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flInMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flOut1 = 0x4B8; // float
    constexpr std::ptrdiff_t m_flOut2 = 0x4BC; // float
    constexpr std::ptrdiff_t m_flOldInValue = 0x4C0; // float
    constexpr std::ptrdiff_t m_bEnabled = 0x4C4; // bool
    constexpr std::ptrdiff_t m_OutValue = 0x4C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnRoseAboveMin = 0x4F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnRoseAboveMax = 0x518; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMin = 0x540; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFellBelowMax = 0x568; // CEntityIOOutput
}

namespace CMelee { // CCSWeaponBase
    constexpr std::ptrdiff_t m_flThrowAt = 0xE20; // GameTime_t
    constexpr std::ptrdiff_t m_hThrower = 0xE24; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bDidThrowDamage = 0xE28; // bool
}

namespace CMessage { // CPointEntity
    constexpr std::ptrdiff_t m_iszMessage = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_MessageVolume = 0x4B8; // float
    constexpr std::ptrdiff_t m_MessageAttenuation = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_Radius = 0x4C0; // float
    constexpr std::ptrdiff_t m_sNoise = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnShowMessage = 0x4D0; // CEntityIOOutput
}

namespace CMessageEntity { // CPointEntity
    constexpr std::ptrdiff_t m_radius = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_messageText = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_drawText = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bDeveloperOnly = 0x4C1; // bool
    constexpr std::ptrdiff_t m_bEnabled = 0x4C2; // bool
}

namespace CModelPointEntity { // CBaseModelEntity
}

namespace CModelState {
    constexpr std::ptrdiff_t m_hModel = 0xA0; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_ModelName = 0xA8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bClientClothCreationSuppressed = 0xE8; // bool
    constexpr std::ptrdiff_t m_MeshGroupMask = 0x180; // uint64_t
    constexpr std::ptrdiff_t m_nIdealMotionType = 0x222; // int8_t
    constexpr std::ptrdiff_t m_nForceLOD = 0x223; // int8_t
    constexpr std::ptrdiff_t m_nClothUpdateFlags = 0x224; // int8_t
}

namespace CMolotovGrenade { // CBaseCSGrenade
}

namespace CMolotovProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_bIsIncGrenade = 0xA40; // bool
    constexpr std::ptrdiff_t m_bDetonated = 0xA4C; // bool
    constexpr std::ptrdiff_t m_stillTimer = 0xA50; // IntervalTimer
    constexpr std::ptrdiff_t m_bHasBouncedOffPlayer = 0xB30; // bool
}

namespace CMomentaryRotButton { // CRotButton
    constexpr std::ptrdiff_t m_Position = 0x8C8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnUnpressed = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyOpen = 0x918; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnFullyClosed = 0x940; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedPosition = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_lastUsed = 0x990; // int32_t
    constexpr std::ptrdiff_t m_start = 0x994; // QAngle
    constexpr std::ptrdiff_t m_end = 0x9A0; // QAngle
    constexpr std::ptrdiff_t m_IdealYaw = 0x9AC; // float
    constexpr std::ptrdiff_t m_sNoise = 0x9B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUpdateTarget = 0x9B8; // bool
    constexpr std::ptrdiff_t m_direction = 0x9BC; // int32_t
    constexpr std::ptrdiff_t m_returnSpeed = 0x9C0; // float
    constexpr std::ptrdiff_t m_flStartPosition = 0x9C4; // float
}

namespace CMotorController {
    constexpr std::ptrdiff_t m_speed = 0x8; // float
    constexpr std::ptrdiff_t m_maxTorque = 0xC; // float
    constexpr std::ptrdiff_t m_axis = 0x10; // Vector
    constexpr std::ptrdiff_t m_inertiaFactor = 0x1C; // float
}

namespace CMultiLightProxy { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszLightNameFilter = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLightClassFilter = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flLightRadiusFilter = 0x4C0; // float
    constexpr std::ptrdiff_t m_flBrightnessDelta = 0x4C4; // float
    constexpr std::ptrdiff_t m_bPerformScreenFade = 0x4C8; // bool
    constexpr std::ptrdiff_t m_flTargetBrightnessMultiplier = 0x4CC; // float
    constexpr std::ptrdiff_t m_flCurrentBrightnessMultiplier = 0x4D0; // float
    constexpr std::ptrdiff_t m_vecLights = 0x4D8; // CUtlVector<CHandle<CLightEntity>>
}

namespace CMultiSource { // CLogicalEntity
    constexpr std::ptrdiff_t m_rgEntities = 0x4B0; // CHandle<CBaseEntity>[32]
    constexpr std::ptrdiff_t m_rgTriggered = 0x530; // int32_t[32]
    constexpr std::ptrdiff_t m_OnTrigger = 0x5B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iTotal = 0x5D8; // int32_t
    constexpr std::ptrdiff_t m_globalstate = 0x5E0; // CUtlSymbolLarge
}

namespace CMultiplayRules { // CGameRules
}

namespace CMultiplayer_Expresser { // CAI_ExpresserWithFollowup
    constexpr std::ptrdiff_t m_bAllowMultipleScenes = 0x70; // bool
}

namespace CNavHullPresetVData {
    constexpr std::ptrdiff_t m_vecNavHulls = 0x0; // CUtlVector<CUtlString>
}

namespace CNavHullVData {
    constexpr std::ptrdiff_t m_bAgentEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_agentRadius = 0x4; // float
    constexpr std::ptrdiff_t m_agentHeight = 0x8; // float
    constexpr std::ptrdiff_t m_agentShortHeightEnabled = 0xC; // bool
    constexpr std::ptrdiff_t m_agentShortHeight = 0x10; // float
    constexpr std::ptrdiff_t m_agentMaxClimb = 0x14; // float
    constexpr std::ptrdiff_t m_agentMaxSlope = 0x18; // int32_t
    constexpr std::ptrdiff_t m_agentMaxJumpDownDist = 0x1C; // float
    constexpr std::ptrdiff_t m_agentMaxJumpHorizDistBase = 0x20; // float
    constexpr std::ptrdiff_t m_agentMaxJumpUpDist = 0x24; // float
    constexpr std::ptrdiff_t m_agentBorderErosion = 0x28; // int32_t
}

namespace CNavLinkAnimgraphVar {
    constexpr std::ptrdiff_t m_strAnimgraphVar = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_unAlignmentDegrees = 0x8; // uint32_t
}

namespace CNavLinkAreaEntity { // CPointEntity
    constexpr std::ptrdiff_t m_flWidth = 0x4B0; // float
    constexpr std::ptrdiff_t m_vLocatorOffset = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_qLocatorAnglesOffset = 0x4C0; // QAngle
    constexpr std::ptrdiff_t m_strMovementForward = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strMovementReverse = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nNavLinkIdForward = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_nNavLinkIdReverse = 0x4E4; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4E8; // bool
    constexpr std::ptrdiff_t m_strFilterName = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4F8; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_OnNavLinkStart = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNavLinkFinish = 0x528; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bIsTerminus = 0x550; // bool
}

namespace CNavLinkMovementVData {
    constexpr std::ptrdiff_t m_bIsInterpolated = 0x0; // bool
    constexpr std::ptrdiff_t m_unRecommendedDistance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vecAnimgraphVars = 0x8; // CUtlVector<CNavLinkAnimgraphVar>
}

namespace CNavSpaceInfo { // CPointEntity
    constexpr std::ptrdiff_t m_bCreateFlightSpace = 0x4B0; // bool
}

namespace CNavVolume {
}

namespace CNavVolumeAll { // CNavVolumeVector
}

namespace CNavVolumeBreadthFirstSearch { // CNavVolumeCalculatedVector
    constexpr std::ptrdiff_t m_vStartPos = 0xA0; // Vector
    constexpr std::ptrdiff_t m_flSearchDist = 0xAC; // float
}

namespace CNavVolumeCalculatedVector { // CNavVolume
}

namespace CNavVolumeMarkupVolume { // CNavVolume
}

namespace CNavVolumeSphere { // CNavVolume
    constexpr std::ptrdiff_t m_vCenter = 0x70; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x7C; // float
}

namespace CNavVolumeSphericalShell { // CNavVolumeSphere
    constexpr std::ptrdiff_t m_flRadiusInner = 0x80; // float
}

namespace CNavVolumeVector { // CNavVolume
    constexpr std::ptrdiff_t m_bHasBeenPreFiltered = 0x78; // bool
}

namespace CNavWalkable { // CPointEntity
}

namespace CNetworkOriginCellCoordQuantizedVector {
    constexpr std::ptrdiff_t m_cellX = 0x10; // uint16_t
    constexpr std::ptrdiff_t m_cellY = 0x12; // uint16_t
    constexpr std::ptrdiff_t m_cellZ = 0x14; // uint16_t
    constexpr std::ptrdiff_t m_nOutsideWorld = 0x16; // uint16_t
    constexpr std::ptrdiff_t m_vecX = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x20; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x28; // CNetworkedQuantizedFloat
}

namespace CNetworkOriginQuantizedVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkTransmitComponent {
    constexpr std::ptrdiff_t m_nTransmitStateOwnedCounter = 0x16C; // uint8_t
}

namespace CNetworkVelocityVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkViewOffsetVector {
    constexpr std::ptrdiff_t m_vecX = 0x10; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecY = 0x18; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_vecZ = 0x20; // CNetworkedQuantizedFloat
}

namespace CNetworkedSequenceOperation {
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flPrevCycle = 0xC; // float
    constexpr std::ptrdiff_t m_flCycle = 0x10; // float
    constexpr std::ptrdiff_t m_flWeight = 0x14; // CNetworkedQuantizedFloat
    constexpr std::ptrdiff_t m_bSequenceChangeNetworked = 0x1C; // bool
    constexpr std::ptrdiff_t m_bDiscontinuity = 0x1D; // bool
    constexpr std::ptrdiff_t m_flPrevCycleFromDiscontinuity = 0x20; // float
    constexpr std::ptrdiff_t m_flPrevCycleForAnimEventDetection = 0x24; // float
}

namespace CNullEntity { // CBaseEntity
}

namespace COmniLight { // CBarnLight
    constexpr std::ptrdiff_t m_flInnerAngle = 0x928; // float
    constexpr std::ptrdiff_t m_flOuterAngle = 0x92C; // float
    constexpr std::ptrdiff_t m_bShowLight = 0x930; // bool
}

namespace COrnamentProp { // CDynamicProp
    constexpr std::ptrdiff_t m_initialOwner = 0xB08; // CUtlSymbolLarge
}

namespace CParticleSystem { // CBaseModelEntity
    constexpr std::ptrdiff_t m_szSnapshotFileName = 0x700; // char[512]
    constexpr std::ptrdiff_t m_bActive = 0x900; // bool
    constexpr std::ptrdiff_t m_bFrozen = 0x901; // bool
    constexpr std::ptrdiff_t m_flFreezeTransitionDuration = 0x904; // float
    constexpr std::ptrdiff_t m_nStopType = 0x908; // int32_t
    constexpr std::ptrdiff_t m_bAnimateDuringGameplayPause = 0x90C; // bool
    constexpr std::ptrdiff_t m_iEffectIndex = 0x910; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_flStartTime = 0x918; // GameTime_t
    constexpr std::ptrdiff_t m_flPreSimTime = 0x91C; // float
    constexpr std::ptrdiff_t m_vServerControlPoints = 0x920; // Vector[4]
    constexpr std::ptrdiff_t m_iServerControlPointAssignments = 0x950; // uint8_t[4]
    constexpr std::ptrdiff_t m_hControlPointEnts = 0x954; // CHandle<CBaseEntity>[64]
    constexpr std::ptrdiff_t m_bNoSave = 0xA54; // bool
    constexpr std::ptrdiff_t m_bNoFreeze = 0xA55; // bool
    constexpr std::ptrdiff_t m_bNoRamp = 0xA56; // bool
    constexpr std::ptrdiff_t m_bStartActive = 0xA57; // bool
    constexpr std::ptrdiff_t m_iszEffectName = 0xA58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszControlPointNames = 0xA60; // CUtlSymbolLarge[64]
    constexpr std::ptrdiff_t m_nDataCP = 0xC60; // int32_t
    constexpr std::ptrdiff_t m_vecDataCPValue = 0xC64; // Vector
    constexpr std::ptrdiff_t m_nTintCP = 0xC70; // int32_t
    constexpr std::ptrdiff_t m_clrTint = 0xC74; // Color
}

namespace CPathCorner { // CPointEntity
    constexpr std::ptrdiff_t m_flWait = 0x4B0; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B4; // float
    constexpr std::ptrdiff_t m_OnPass = 0x4B8; // CEntityIOOutput
}

namespace CPathCornerCrash { // CPathCorner
}

namespace CPathKeyFrame { // CLogicalEntity
    constexpr std::ptrdiff_t m_Origin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_Angles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_qAngle = 0x4D0; // Quaternion
    constexpr std::ptrdiff_t m_iNextKey = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flNextTime = 0x4E8; // float
    constexpr std::ptrdiff_t m_pNextKey = 0x4F0; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_pPrevKey = 0x4F8; // CPathKeyFrame*
    constexpr std::ptrdiff_t m_flSpeed = 0x500; // float
}

namespace CPathParticleRope { // CBaseEntity
    constexpr std::ptrdiff_t m_bStartActive = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMaxSimulationTime = 0x4B4; // float
    constexpr std::ptrdiff_t m_iszEffectName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_PathNodes_Name = 0x4C0; // CUtlVector<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_flParticleSpacing = 0x4D8; // float
    constexpr std::ptrdiff_t m_flSlack = 0x4DC; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_ColorTint = 0x4E4; // Color
    constexpr std::ptrdiff_t m_nEffectState = 0x4E8; // int32_t
    constexpr std::ptrdiff_t m_iEffectIndex = 0x4F0; // CStrongHandle<InfoForResourceTypeIParticleSystemDefinition>
    constexpr std::ptrdiff_t m_PathNodes_Position = 0x4F8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentIn = 0x510; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_TangentOut = 0x528; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_Color = 0x540; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_PathNodes_PinEnabled = 0x558; // CNetworkUtlVectorBase<bool>
    constexpr std::ptrdiff_t m_PathNodes_RadiusScale = 0x570; // CNetworkUtlVectorBase<float>
}

namespace CPathParticleRopeAlias_path_particle_rope_clientside { // CPathParticleRope
}

namespace CPathTrack { // CPointEntity
    constexpr std::ptrdiff_t m_pnext = 0x4B0; // CPathTrack*
    constexpr std::ptrdiff_t m_pprevious = 0x4B8; // CPathTrack*
    constexpr std::ptrdiff_t m_paltpath = 0x4C0; // CPathTrack*
    constexpr std::ptrdiff_t m_flRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_length = 0x4CC; // float
    constexpr std::ptrdiff_t m_altName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nIterVal = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_eOrientationType = 0x4DC; // TrackOrientationType_t
    constexpr std::ptrdiff_t m_OnPass = 0x4E0; // CEntityIOOutput
}

namespace CPhysBallSocket { // CPhysConstraint
    constexpr std::ptrdiff_t m_flFriction = 0x508; // float
    constexpr std::ptrdiff_t m_bEnableSwingLimit = 0x50C; // bool
    constexpr std::ptrdiff_t m_flSwingLimit = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableTwistLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinTwistAngle = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxTwistAngle = 0x51C; // float
}

namespace CPhysBox { // CBreakable
    constexpr std::ptrdiff_t m_damageType = 0x7C0; // int32_t
    constexpr std::ptrdiff_t m_massScale = 0x7C4; // float
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0x7C8; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0x7CC; // float
    constexpr std::ptrdiff_t m_angPreferredCarryAngles = 0x7D0; // QAngle
    constexpr std::ptrdiff_t m_bNotSolidToWorld = 0x7DC; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0x7DD; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0x7E0; // int32_t
    constexpr std::ptrdiff_t m_flTouchOutputPerEntityDelay = 0x7E4; // float
    constexpr std::ptrdiff_t m_OnDamaged = 0x7E8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0x810; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMotionEnabled = 0x838; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0x860; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartTouch = 0x888; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hCarryingPlayer = 0x8B0; // CHandle<CBasePlayerPawn>
}

namespace CPhysConstraint { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach1 = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttach2 = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_breakSound = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceLimit = 0x4D0; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x4D4; // float
    constexpr std::ptrdiff_t m_teleportTick = 0x4D8; // uint32_t
    constexpr std::ptrdiff_t m_minTeleportDistance = 0x4DC; // float
    constexpr std::ptrdiff_t m_OnBreak = 0x4E0; // CEntityIOOutput
}

namespace CPhysExplosion { // CPointEntity
    constexpr std::ptrdiff_t m_bExplodeOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flDamage = 0x4B8; // float
    constexpr std::ptrdiff_t m_radius = 0x4BC; // float
    constexpr std::ptrdiff_t m_targetEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4C8; // float
    constexpr std::ptrdiff_t m_flPushScale = 0x4CC; // float
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x4D0; // bool
    constexpr std::ptrdiff_t m_OnPushedPlayer = 0x4D8; // CEntityIOOutput
}

namespace CPhysFixed { // CPhysConstraint
    constexpr std::ptrdiff_t m_flLinearFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flLinearDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngularFrequency = 0x510; // float
    constexpr std::ptrdiff_t m_flAngularDampingRatio = 0x514; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x518; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x519; // bool
}

namespace CPhysForce { // CPointEntity
    constexpr std::ptrdiff_t m_nameAttach = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_force = 0x4C0; // float
    constexpr std::ptrdiff_t m_forceTime = 0x4C4; // float
    constexpr std::ptrdiff_t m_attachedObject = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_wasRestored = 0x4CC; // bool
    constexpr std::ptrdiff_t m_integrator = 0x4D0; // CConstantForceController
}

namespace CPhysHinge { // CPhysConstraint
    constexpr std::ptrdiff_t m_soundInfo = 0x510; // ConstraintSoundInfo
    constexpr std::ptrdiff_t m_NotifyMinLimitReached = 0x598; // CEntityIOOutput
    constexpr std::ptrdiff_t m_NotifyMaxLimitReached = 0x5C0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAtMinLimit = 0x5E8; // bool
    constexpr std::ptrdiff_t m_bAtMaxLimit = 0x5E9; // bool
    constexpr std::ptrdiff_t m_hinge = 0x5EC; // constraint_hingeparams_t
    constexpr std::ptrdiff_t m_hingeFriction = 0x62C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x630; // float
    constexpr std::ptrdiff_t m_bIsAxisLocal = 0x634; // bool
    constexpr std::ptrdiff_t m_flMinRotation = 0x638; // float
    constexpr std::ptrdiff_t m_flMaxRotation = 0x63C; // float
    constexpr std::ptrdiff_t m_flInitialRotation = 0x640; // float
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x644; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x648; // float
    constexpr std::ptrdiff_t m_flAngleSpeed = 0x64C; // float
    constexpr std::ptrdiff_t m_flAngleSpeedThreshold = 0x650; // float
    constexpr std::ptrdiff_t m_OnStartMoving = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStopMoving = 0x680; // CEntityIOOutput
}

namespace CPhysHingeAlias_phys_hinge_local { // CPhysHinge
}

namespace CPhysImpact { // CPointEntity
    constexpr std::ptrdiff_t m_damage = 0x4B0; // float
    constexpr std::ptrdiff_t m_distance = 0x4B4; // float
    constexpr std::ptrdiff_t m_directionEntityName = 0x4B8; // CUtlSymbolLarge
}

namespace CPhysLength { // CPhysConstraint
    constexpr std::ptrdiff_t m_offset = 0x508; // Vector[2]
    constexpr std::ptrdiff_t m_vecAttach = 0x520; // Vector
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_minLength = 0x530; // float
    constexpr std::ptrdiff_t m_totalLength = 0x534; // float
    constexpr std::ptrdiff_t m_bEnableCollision = 0x538; // bool
}

namespace CPhysMagnet { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_OnMagnetAttach = 0x890; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnMagnetDetach = 0x8B8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0x8E0; // float
    constexpr std::ptrdiff_t m_forceLimit = 0x8E4; // float
    constexpr std::ptrdiff_t m_torqueLimit = 0x8E8; // float
    constexpr std::ptrdiff_t m_MagnettedEntities = 0x8F0; // CUtlVector<magnetted_objects_t>
    constexpr std::ptrdiff_t m_bActive = 0x908; // bool
    constexpr std::ptrdiff_t m_bHasHitSomething = 0x909; // bool
    constexpr std::ptrdiff_t m_flTotalMass = 0x90C; // float
    constexpr std::ptrdiff_t m_flRadius = 0x910; // float
    constexpr std::ptrdiff_t m_flNextSuckTime = 0x914; // GameTime_t
    constexpr std::ptrdiff_t m_iMaxObjectsAttached = 0x918; // int32_t
}

namespace CPhysMotor { // CLogicalEntity
    constexpr std::ptrdiff_t m_nameAttach = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hAttachedObject = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_spinUp = 0x4BC; // float
    constexpr std::ptrdiff_t m_additionalAcceleration = 0x4C0; // float
    constexpr std::ptrdiff_t m_angularAcceleration = 0x4C4; // float
    constexpr std::ptrdiff_t m_lastTime = 0x4C8; // GameTime_t
    constexpr std::ptrdiff_t m_motor = 0x4E0; // CMotorController
}

namespace CPhysPulley { // CPhysConstraint
    constexpr std::ptrdiff_t m_position2 = 0x508; // Vector
    constexpr std::ptrdiff_t m_offset = 0x514; // Vector[2]
    constexpr std::ptrdiff_t m_addLength = 0x52C; // float
    constexpr std::ptrdiff_t m_gearRatio = 0x530; // float
}

namespace CPhysSlideConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_axisEnd = 0x510; // Vector
    constexpr std::ptrdiff_t m_slideFriction = 0x51C; // float
    constexpr std::ptrdiff_t m_systemLoadScale = 0x520; // float
    constexpr std::ptrdiff_t m_initialOffset = 0x524; // float
    constexpr std::ptrdiff_t m_bEnableLinearConstraint = 0x528; // bool
    constexpr std::ptrdiff_t m_bEnableAngularConstraint = 0x529; // bool
    constexpr std::ptrdiff_t m_flMotorFrequency = 0x52C; // float
    constexpr std::ptrdiff_t m_flMotorDampingRatio = 0x530; // float
    constexpr std::ptrdiff_t m_bUseEntityPivot = 0x534; // bool
    constexpr std::ptrdiff_t m_soundInfo = 0x538; // ConstraintSoundInfo
}

namespace CPhysThruster { // CPhysForce
    constexpr std::ptrdiff_t m_localOrigin = 0x510; // Vector
}

namespace CPhysTorque { // CPhysForce
    constexpr std::ptrdiff_t m_axis = 0x510; // Vector
}

namespace CPhysWheelConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_flSuspensionFrequency = 0x508; // float
    constexpr std::ptrdiff_t m_flSuspensionDampingRatio = 0x50C; // float
    constexpr std::ptrdiff_t m_flSuspensionHeightOffset = 0x510; // float
    constexpr std::ptrdiff_t m_bEnableSuspensionLimit = 0x514; // bool
    constexpr std::ptrdiff_t m_flMinSuspensionOffset = 0x518; // float
    constexpr std::ptrdiff_t m_flMaxSuspensionOffset = 0x51C; // float
    constexpr std::ptrdiff_t m_bEnableSteeringLimit = 0x520; // bool
    constexpr std::ptrdiff_t m_flMinSteeringAngle = 0x524; // float
    constexpr std::ptrdiff_t m_flMaxSteeringAngle = 0x528; // float
    constexpr std::ptrdiff_t m_flSteeringAxisFriction = 0x52C; // float
    constexpr std::ptrdiff_t m_flSpinAxisFriction = 0x530; // float
}

namespace CPhysicalButton { // CBaseButton
}

namespace CPhysicsEntitySolver { // CLogicalEntity
    constexpr std::ptrdiff_t m_hMovingEntity = 0x4B8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsBlocker = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_separationDuration = 0x4C0; // float
    constexpr std::ptrdiff_t m_cancelTime = 0x4C4; // GameTime_t
}

namespace CPhysicsProp { // CBreakableProp
    constexpr std::ptrdiff_t m_MotionEnabled = 0xA10; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwakened = 0xA38; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAwake = 0xA60; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnAsleep = 0xA88; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerUse = 0xAB0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0xAD8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnOutOfWorld = 0xB00; // CEntityIOOutput
    constexpr std::ptrdiff_t m_massScale = 0xB28; // float
    constexpr std::ptrdiff_t m_inertiaScale = 0xB2C; // float
    constexpr std::ptrdiff_t m_buoyancyScale = 0xB30; // float
    constexpr std::ptrdiff_t m_damageType = 0xB34; // int32_t
    constexpr std::ptrdiff_t m_damageToEnableMotion = 0xB38; // int32_t
    constexpr std::ptrdiff_t m_flForceToEnableMotion = 0xB3C; // float
    constexpr std::ptrdiff_t m_bThrownByPlayer = 0xB40; // bool
    constexpr std::ptrdiff_t m_bDroppedByPlayer = 0xB41; // bool
    constexpr std::ptrdiff_t m_bTouchedByPlayer = 0xB42; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0xB43; // bool
    constexpr std::ptrdiff_t m_iExploitableByPlayer = 0xB44; // int32_t
    constexpr std::ptrdiff_t m_bHasBeenAwakened = 0xB48; // bool
    constexpr std::ptrdiff_t m_bIsOverrideProp = 0xB49; // bool
    constexpr std::ptrdiff_t m_fNextCheckDisableMotionContactsTime = 0xB4C; // GameTime_t
    constexpr std::ptrdiff_t m_iInitialGlowState = 0xB50; // int32_t
    constexpr std::ptrdiff_t m_nGlowRange = 0xB54; // int32_t
    constexpr std::ptrdiff_t m_nGlowRangeMin = 0xB58; // int32_t
    constexpr std::ptrdiff_t m_glowColor = 0xB5C; // Color
    constexpr std::ptrdiff_t m_bForceNavIgnore = 0xB60; // bool
    constexpr std::ptrdiff_t m_bNoNavmeshBlocker = 0xB61; // bool
    constexpr std::ptrdiff_t m_bForceNpcExclude = 0xB62; // bool
    constexpr std::ptrdiff_t m_bShouldAutoConvertBackFromDebris = 0xB63; // bool
    constexpr std::ptrdiff_t m_bMuteImpactEffects = 0xB64; // bool
    constexpr std::ptrdiff_t m_bAcceptDamageFromHeldObjects = 0xB6C; // bool
    constexpr std::ptrdiff_t m_bEnableUseOutput = 0xB6D; // bool
    constexpr std::ptrdiff_t m_bAwake = 0xB6E; // bool
    constexpr std::ptrdiff_t m_nCollisionGroupOverride = 0xB70; // int32_t
}

namespace CPhysicsPropMultiplayer { // CPhysicsProp
}

namespace CPhysicsPropOverride { // CPhysicsProp
}

namespace CPhysicsPropRespawnable { // CPhysicsProp
    constexpr std::ptrdiff_t m_vOriginalSpawnOrigin = 0xB78; // Vector
    constexpr std::ptrdiff_t m_vOriginalSpawnAngles = 0xB84; // QAngle
    constexpr std::ptrdiff_t m_vOriginalMins = 0xB90; // Vector
    constexpr std::ptrdiff_t m_vOriginalMaxs = 0xB9C; // Vector
    constexpr std::ptrdiff_t m_flRespawnDuration = 0xBA8; // float
}

namespace CPhysicsShake {
    constexpr std::ptrdiff_t m_force = 0x8; // Vector
}

namespace CPhysicsSpring { // CBaseEntity
    constexpr std::ptrdiff_t m_flFrequency = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x4BC; // float
    constexpr std::ptrdiff_t m_flRestLength = 0x4C0; // float
    constexpr std::ptrdiff_t m_nameAttachStart = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nameAttachEnd = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_start = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_end = 0x4E4; // Vector
    constexpr std::ptrdiff_t m_teleportTick = 0x4F0; // uint32_t
}

namespace CPhysicsWire { // CBaseEntity
    constexpr std::ptrdiff_t m_nDensity = 0x4B0; // int32_t
}

namespace CPlantedC4 { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_bBombTicking = 0x890; // bool
    constexpr std::ptrdiff_t m_flC4Blow = 0x894; // GameTime_t
    constexpr std::ptrdiff_t m_nBombSite = 0x898; // int32_t
    constexpr std::ptrdiff_t m_nSourceSoundscapeHash = 0x89C; // int32_t
    constexpr std::ptrdiff_t m_OnBombDefused = 0x8A0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombBeginDefuse = 0x8C8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnBombDefuseAborted = 0x8F0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bCannotBeDefused = 0x918; // bool
    constexpr std::ptrdiff_t m_entitySpottedState = 0x920; // EntitySpottedState_t
    constexpr std::ptrdiff_t m_nSpotRules = 0x938; // int32_t
    constexpr std::ptrdiff_t m_bTrainingPlacedByPlayer = 0x93C; // bool
    constexpr std::ptrdiff_t m_bHasExploded = 0x93D; // bool
    constexpr std::ptrdiff_t m_flTimerLength = 0x940; // float
    constexpr std::ptrdiff_t m_bBeingDefused = 0x944; // bool
    constexpr std::ptrdiff_t m_fLastDefuseTime = 0x94C; // GameTime_t
    constexpr std::ptrdiff_t m_flDefuseLength = 0x954; // float
    constexpr std::ptrdiff_t m_flDefuseCountDown = 0x958; // GameTime_t
    constexpr std::ptrdiff_t m_bBombDefused = 0x95C; // bool
    constexpr std::ptrdiff_t m_hBombDefuser = 0x960; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hControlPanel = 0x964; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iProgressBarTime = 0x968; // int32_t
    constexpr std::ptrdiff_t m_bVoiceAlertFired = 0x96C; // bool
    constexpr std::ptrdiff_t m_bVoiceAlertPlayed = 0x96D; // bool[4]
    constexpr std::ptrdiff_t m_flNextBotBeepTime = 0x974; // GameTime_t
    constexpr std::ptrdiff_t m_bPlantedAfterPickup = 0x97C; // bool
    constexpr std::ptrdiff_t m_angCatchUpToPlayerEye = 0x980; // QAngle
    constexpr std::ptrdiff_t m_flLastSpinDetectionTime = 0x98C; // GameTime_t
}

namespace CPlatTrigger { // CBaseModelEntity
    constexpr std::ptrdiff_t m_pPlatform = 0x700; // CHandle<CFuncPlat>
}

namespace CPlayerControllerComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPawnComponent {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
}

namespace CPlayerPing { // CBaseEntity
    constexpr std::ptrdiff_t m_hPlayer = 0x4B8; // CHandle<CCSPlayerPawn>
    constexpr std::ptrdiff_t m_hPingedEntity = 0x4BC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iType = 0x4C0; // int32_t
    constexpr std::ptrdiff_t m_bUrgent = 0x4C4; // bool
    constexpr std::ptrdiff_t m_szPlaceName = 0x4C5; // char[18]
}

namespace CPlayerSprayDecal { // CModelPointEntity
    constexpr std::ptrdiff_t m_nUniqueID = 0x700; // int32_t
    constexpr std::ptrdiff_t m_unAccountID = 0x704; // uint32_t
    constexpr std::ptrdiff_t m_unTraceID = 0x708; // uint32_t
    constexpr std::ptrdiff_t m_rtGcTime = 0x70C; // uint32_t
    constexpr std::ptrdiff_t m_vecEndPos = 0x710; // Vector
    constexpr std::ptrdiff_t m_vecStart = 0x71C; // Vector
    constexpr std::ptrdiff_t m_vecLeft = 0x728; // Vector
    constexpr std::ptrdiff_t m_vecNormal = 0x734; // Vector
    constexpr std::ptrdiff_t m_nPlayer = 0x740; // int32_t
    constexpr std::ptrdiff_t m_nEntity = 0x744; // int32_t
    constexpr std::ptrdiff_t m_nHitbox = 0x748; // int32_t
    constexpr std::ptrdiff_t m_flCreationTime = 0x74C; // float
    constexpr std::ptrdiff_t m_nTintID = 0x750; // int32_t
    constexpr std::ptrdiff_t m_nVersion = 0x754; // uint8_t
    constexpr std::ptrdiff_t m_ubSignature = 0x755; // uint8_t[128]
}

namespace CPlayerVisibility { // CBaseEntity
    constexpr std::ptrdiff_t m_flVisibilityStrength = 0x4B0; // float
    constexpr std::ptrdiff_t m_flFogDistanceMultiplier = 0x4B4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensityMultiplier = 0x4B8; // float
    constexpr std::ptrdiff_t m_flFadeTime = 0x4BC; // float
    constexpr std::ptrdiff_t m_bStartDisabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_bIsEnabled = 0x4C1; // bool
}

namespace CPlayer_AutoaimServices { // CPlayerPawnComponent
}

namespace CPlayer_CameraServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_vecCsViewPunchAngle = 0x40; // QAngle
    constexpr std::ptrdiff_t m_nCsViewPunchAngleTick = 0x4C; // GameTick_t
    constexpr std::ptrdiff_t m_flCsViewPunchAngleTickRatio = 0x50; // float
    constexpr std::ptrdiff_t m_PlayerFog = 0x58; // fogplayerparams_t
    constexpr std::ptrdiff_t m_hColorCorrectionCtrl = 0x98; // CHandle<CColorCorrection>
    constexpr std::ptrdiff_t m_hViewEntity = 0x9C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTonemapController = 0xA0; // CHandle<CTonemapController2>
    constexpr std::ptrdiff_t m_audio = 0xA8; // audioparams_t
    constexpr std::ptrdiff_t m_PostProcessingVolumes = 0x120; // CNetworkUtlVectorBase<CHandle<CPostProcessingVolume>>
    constexpr std::ptrdiff_t m_flOldPlayerZ = 0x138; // float
    constexpr std::ptrdiff_t m_flOldPlayerViewOffsetZ = 0x13C; // float
    constexpr std::ptrdiff_t m_hTriggerSoundscapeList = 0x158; // CUtlVector<CHandle<CEnvSoundscapeTriggerable>>
}

namespace CPlayer_FlashlightServices { // CPlayerPawnComponent
}

namespace CPlayer_ItemServices { // CPlayerPawnComponent
}

namespace CPlayer_MovementServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_nImpulse = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nButtons = 0x48; // CInButtonState
    constexpr std::ptrdiff_t m_nQueuedButtonDownMask = 0x68; // uint64_t
    constexpr std::ptrdiff_t m_nQueuedButtonChangeMask = 0x70; // uint64_t
    constexpr std::ptrdiff_t m_nButtonDoublePressed = 0x78; // uint64_t
    constexpr std::ptrdiff_t m_pButtonPressedCmdNumber = 0x80; // uint32_t[64]
    constexpr std::ptrdiff_t m_nLastCommandNumberProcessed = 0x180; // uint32_t
    constexpr std::ptrdiff_t m_nToggleButtonDownMask = 0x188; // uint64_t
    constexpr std::ptrdiff_t m_flMaxspeed = 0x190; // float
    constexpr std::ptrdiff_t m_arrForceSubtickMoveWhen = 0x194; // float[4]
    constexpr std::ptrdiff_t m_flForwardMove = 0x1A4; // float
    constexpr std::ptrdiff_t m_flLeftMove = 0x1A8; // float
    constexpr std::ptrdiff_t m_flUpMove = 0x1AC; // float
    constexpr std::ptrdiff_t m_vecLastMovementImpulses = 0x1B0; // Vector
    constexpr std::ptrdiff_t m_vecOldViewAngles = 0x1BC; // QAngle
}

namespace CPlayer_MovementServices_Humanoid { // CPlayer_MovementServices
    constexpr std::ptrdiff_t m_flStepSoundTime = 0x1D0; // float
    constexpr std::ptrdiff_t m_flFallVelocity = 0x1D4; // float
    constexpr std::ptrdiff_t m_bInCrouch = 0x1D8; // bool
    constexpr std::ptrdiff_t m_nCrouchState = 0x1DC; // uint32_t
    constexpr std::ptrdiff_t m_flCrouchTransitionStartTime = 0x1E0; // GameTime_t
    constexpr std::ptrdiff_t m_bDucked = 0x1E4; // bool
    constexpr std::ptrdiff_t m_bDucking = 0x1E5; // bool
    constexpr std::ptrdiff_t m_bInDuckJump = 0x1E6; // bool
    constexpr std::ptrdiff_t m_groundNormal = 0x1E8; // Vector
    constexpr std::ptrdiff_t m_flSurfaceFriction = 0x1F4; // float
    constexpr std::ptrdiff_t m_surfaceProps = 0x1F8; // CUtlStringToken
    constexpr std::ptrdiff_t m_nStepside = 0x208; // int32_t
    constexpr std::ptrdiff_t m_iTargetVolume = 0x20C; // int32_t
    constexpr std::ptrdiff_t m_vecSmoothedVelocity = 0x210; // Vector
}

namespace CPlayer_ObserverServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_iObserverMode = 0x40; // uint8_t
    constexpr std::ptrdiff_t m_hObserverTarget = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iObserverLastMode = 0x48; // ObserverMode_t
    constexpr std::ptrdiff_t m_bForcedObserverMode = 0x4C; // bool
}

namespace CPlayer_UseServices { // CPlayerPawnComponent
}

namespace CPlayer_ViewModelServices { // CPlayerPawnComponent
}

namespace CPlayer_WaterServices { // CPlayerPawnComponent
}

namespace CPlayer_WeaponServices { // CPlayerPawnComponent
    constexpr std::ptrdiff_t m_bAllowSwitchToNoWeapon = 0x40; // bool
    constexpr std::ptrdiff_t m_hMyWeapons = 0x48; // CNetworkUtlVectorBase<CHandle<CBasePlayerWeapon>>
    constexpr std::ptrdiff_t m_hActiveWeapon = 0x60; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_hLastWeapon = 0x64; // CHandle<CBasePlayerWeapon>
    constexpr std::ptrdiff_t m_iAmmo = 0x68; // uint16_t[32]
    constexpr std::ptrdiff_t m_bPreventWeaponPickup = 0xA8; // bool
}

namespace CPointAngleSensor { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_nLookAtName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hLookAtEntity = 0x4C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDuration = 0x4C8; // float
    constexpr std::ptrdiff_t m_flDotTolerance = 0x4CC; // float
    constexpr std::ptrdiff_t m_flFacingTime = 0x4D0; // GameTime_t
    constexpr std::ptrdiff_t m_bFired = 0x4D4; // bool
    constexpr std::ptrdiff_t m_OnFacingLookat = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnNotFacingLookat = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_TargetDir = 0x528; // CEntityOutputTemplate<Vector>
    constexpr std::ptrdiff_t m_FacingPercentage = 0x550; // CEntityOutputTemplate<float>
}

namespace CPointAngularVelocitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flThreshold = 0x4B4; // float
    constexpr std::ptrdiff_t m_nLastCompareResult = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_nLastFireResult = 0x4BC; // int32_t
    constexpr std::ptrdiff_t m_flFireTime = 0x4C0; // GameTime_t
    constexpr std::ptrdiff_t m_flFireInterval = 0x4C4; // float
    constexpr std::ptrdiff_t m_flLastAngVelocity = 0x4C8; // float
    constexpr std::ptrdiff_t m_lastOrientation = 0x4CC; // QAngle
    constexpr std::ptrdiff_t m_vecAxis = 0x4D8; // Vector
    constexpr std::ptrdiff_t m_bUseHelper = 0x4E4; // bool
    constexpr std::ptrdiff_t m_AngularVelocity = 0x4E8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnLessThan = 0x510; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLessThanOrEqualTo = 0x538; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThan = 0x560; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnGreaterThanOrEqualTo = 0x588; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEqualTo = 0x5B0; // CEntityIOOutput
}

namespace CPointBroadcastClientCommand { // CPointEntity
}

namespace CPointCamera { // CBaseEntity
    constexpr std::ptrdiff_t m_FOV = 0x4B0; // float
    constexpr std::ptrdiff_t m_Resolution = 0x4B4; // float
    constexpr std::ptrdiff_t m_bFogEnable = 0x4B8; // bool
    constexpr std::ptrdiff_t m_FogColor = 0x4B9; // Color
    constexpr std::ptrdiff_t m_flFogStart = 0x4C0; // float
    constexpr std::ptrdiff_t m_flFogEnd = 0x4C4; // float
    constexpr std::ptrdiff_t m_flFogMaxDensity = 0x4C8; // float
    constexpr std::ptrdiff_t m_bActive = 0x4CC; // bool
    constexpr std::ptrdiff_t m_bUseScreenAspectRatio = 0x4CD; // bool
    constexpr std::ptrdiff_t m_flAspectRatio = 0x4D0; // float
    constexpr std::ptrdiff_t m_bNoSky = 0x4D4; // bool
    constexpr std::ptrdiff_t m_fBrightness = 0x4D8; // float
    constexpr std::ptrdiff_t m_flZFar = 0x4DC; // float
    constexpr std::ptrdiff_t m_flZNear = 0x4E0; // float
    constexpr std::ptrdiff_t m_bCanHLTVUse = 0x4E4; // bool
    constexpr std::ptrdiff_t m_bDofEnabled = 0x4E5; // bool
    constexpr std::ptrdiff_t m_flDofNearBlurry = 0x4E8; // float
    constexpr std::ptrdiff_t m_flDofNearCrisp = 0x4EC; // float
    constexpr std::ptrdiff_t m_flDofFarCrisp = 0x4F0; // float
    constexpr std::ptrdiff_t m_flDofFarBlurry = 0x4F4; // float
    constexpr std::ptrdiff_t m_flDofTiltToGround = 0x4F8; // float
    constexpr std::ptrdiff_t m_TargetFOV = 0x4FC; // float
    constexpr std::ptrdiff_t m_DegreesPerSecond = 0x500; // float
    constexpr std::ptrdiff_t m_bIsOn = 0x504; // bool
    constexpr std::ptrdiff_t m_pNext = 0x508; // CPointCamera*
}

namespace CPointCameraVFOV { // CPointCamera
    constexpr std::ptrdiff_t m_flVerticalFOV = 0x510; // float
}

namespace CPointClientCommand { // CPointEntity
}

namespace CPointClientUIDialog { // CBaseClientUIEntity
    constexpr std::ptrdiff_t m_hActivator = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bStartEnabled = 0x8B4; // bool
}

namespace CPointClientUIWorldPanel { // CBaseClientUIEntity
    constexpr std::ptrdiff_t m_bIgnoreInput = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bLit = 0x8B1; // bool
    constexpr std::ptrdiff_t m_bFollowPlayerAcrossTeleport = 0x8B2; // bool
    constexpr std::ptrdiff_t m_flWidth = 0x8B4; // float
    constexpr std::ptrdiff_t m_flHeight = 0x8B8; // float
    constexpr std::ptrdiff_t m_flDPI = 0x8BC; // float
    constexpr std::ptrdiff_t m_flInteractDistance = 0x8C0; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x8C4; // float
    constexpr std::ptrdiff_t m_unOwnerContext = 0x8C8; // uint32_t
    constexpr std::ptrdiff_t m_unHorizontalAlign = 0x8CC; // uint32_t
    constexpr std::ptrdiff_t m_unVerticalAlign = 0x8D0; // uint32_t
    constexpr std::ptrdiff_t m_unOrientation = 0x8D4; // uint32_t
    constexpr std::ptrdiff_t m_bAllowInteractionFromAllSceneWorlds = 0x8D8; // bool
    constexpr std::ptrdiff_t m_vecCSSClasses = 0x8E0; // CNetworkUtlVectorBase<CUtlSymbolLarge>
    constexpr std::ptrdiff_t m_bOpaque = 0x8F8; // bool
    constexpr std::ptrdiff_t m_bNoDepth = 0x8F9; // bool
    constexpr std::ptrdiff_t m_bRenderBackface = 0x8FA; // bool
    constexpr std::ptrdiff_t m_bUseOffScreenIndicator = 0x8FB; // bool
    constexpr std::ptrdiff_t m_bExcludeFromSaveGames = 0x8FC; // bool
    constexpr std::ptrdiff_t m_bGrabbable = 0x8FD; // bool
    constexpr std::ptrdiff_t m_bOnlyRenderToTexture = 0x8FE; // bool
    constexpr std::ptrdiff_t m_bDisableMipGen = 0x8FF; // bool
    constexpr std::ptrdiff_t m_nExplicitImageLayout = 0x900; // int32_t
}

namespace CPointClientUIWorldTextPanel { // CPointClientUIWorldPanel
    constexpr std::ptrdiff_t m_messageText = 0x908; // char[512]
}

namespace CPointCommentaryNode { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_iszPreCommands = 0x890; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostCommands = 0x898; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszCommentaryFile = 0x8A0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszViewTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewTargetAngles = 0x8B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszViewPosition = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hViewPosition = 0x8C0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hViewPositionMover = 0x8C4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bPreventMovement = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bUnderCrosshair = 0x8C9; // bool
    constexpr std::ptrdiff_t m_bUnstoppable = 0x8CA; // bool
    constexpr std::ptrdiff_t m_flFinishedTime = 0x8CC; // GameTime_t
    constexpr std::ptrdiff_t m_vecFinishOrigin = 0x8D0; // Vector
    constexpr std::ptrdiff_t m_vecOriginalAngles = 0x8DC; // QAngle
    constexpr std::ptrdiff_t m_vecFinishAngles = 0x8E8; // QAngle
    constexpr std::ptrdiff_t m_bPreventChangesWhileMoving = 0x8F4; // bool
    constexpr std::ptrdiff_t m_bDisabled = 0x8F5; // bool
    constexpr std::ptrdiff_t m_vecTeleportOrigin = 0x8F8; // Vector
    constexpr std::ptrdiff_t m_flAbortedPlaybackAt = 0x904; // GameTime_t
    constexpr std::ptrdiff_t m_pOnCommentaryStarted = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_pOnCommentaryStopped = 0x930; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bActive = 0x958; // bool
    constexpr std::ptrdiff_t m_flStartTime = 0x95C; // GameTime_t
    constexpr std::ptrdiff_t m_flStartTimeInCommentary = 0x960; // float
    constexpr std::ptrdiff_t m_iszTitle = 0x968; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSpeakers = 0x970; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iNodeNumber = 0x978; // int32_t
    constexpr std::ptrdiff_t m_iNodeNumberMax = 0x97C; // int32_t
    constexpr std::ptrdiff_t m_bListenedTo = 0x980; // bool
}

namespace CPointEntity { // CBaseEntity
}

namespace CPointEntityFinder { // CBaseEntity
    constexpr std::ptrdiff_t m_hEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iFilterName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4C0; // CHandle<CBaseFilter>
    constexpr std::ptrdiff_t m_iRefName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hReference = 0x4D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_FindMethod = 0x4D4; // EntFinderMethod_t
    constexpr std::ptrdiff_t m_OnFoundEntity = 0x4D8; // CEntityIOOutput
}

namespace CPointGamestatsCounter { // CPointEntity
    constexpr std::ptrdiff_t m_strStatisticName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bDisabled = 0x4B8; // bool
}

namespace CPointGiveAmmo { // CPointEntity
    constexpr std::ptrdiff_t m_pActivator = 0x4B0; // CHandle<CBaseEntity>
}

namespace CPointHurt { // CPointEntity
    constexpr std::ptrdiff_t m_nDamage = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bitsDamageType = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flDelay = 0x4BC; // float
    constexpr std::ptrdiff_t m_strTarget = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pActivator = 0x4C8; // CHandle<CBaseEntity>
}

namespace CPointPrefab { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_targetMapName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_forceWorldGroupID = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_associatedRelayTargetName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fixupNames = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bLoadDynamic = 0x4C9; // bool
    constexpr std::ptrdiff_t m_associatedRelayEntity = 0x4CC; // CHandle<CPointPrefab>
}

namespace CPointProximitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_Distance = 0x4B8; // CEntityOutputTemplate<float>
}

namespace CPointPulse { // CBaseEntity
    constexpr std::ptrdiff_t m_sNameFixupStaticPrefix = 0x5C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupParent = 0x5D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_sNameFixupLocal = 0x5D8; // CUtlSymbolLarge
}

namespace CPointPush { // CPointEntity
    constexpr std::ptrdiff_t m_bEnabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_flMagnitude = 0x4B4; // float
    constexpr std::ptrdiff_t m_flRadius = 0x4B8; // float
    constexpr std::ptrdiff_t m_flInnerRadius = 0x4BC; // float
    constexpr std::ptrdiff_t m_flConeOfInfluence = 0x4C0; // float
    constexpr std::ptrdiff_t m_iszFilterName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x4D0; // CHandle<CBaseFilter>
}

namespace CPointScript { // CBaseEntity
}

namespace CPointServerCommand { // CPointEntity
}

namespace CPointTeleport { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_vSaveOrigin = 0x4B0; // Vector
    constexpr std::ptrdiff_t m_vSaveAngles = 0x4BC; // QAngle
    constexpr std::ptrdiff_t m_bTeleportParentedEntities = 0x4C8; // bool
    constexpr std::ptrdiff_t m_bTeleportUseCurrentAngle = 0x4C9; // bool
}

namespace CPointTemplate { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszWorldName = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSource2EntityLumpName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntityFilterName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flTimeoutInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_bAsynchronouslySpawnEntities = 0x4CC; // bool
    constexpr std::ptrdiff_t m_pOutputOnSpawned = 0x4D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_clientOnlyEntityBehavior = 0x4F8; // PointTemplateClientOnlyEntityBehavior_t
    constexpr std::ptrdiff_t m_ownerSpawnGroupType = 0x4FC; // PointTemplateOwnerSpawnGroupType_t
    constexpr std::ptrdiff_t m_createdSpawnGroupHandles = 0x500; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_SpawnedEntityHandles = 0x518; // CUtlVector<CEntityHandle>
    constexpr std::ptrdiff_t m_ScriptSpawnCallback = 0x530; // HSCRIPT
    constexpr std::ptrdiff_t m_ScriptCallbackScope = 0x538; // HSCRIPT
}

namespace CPointValueRemapper { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bUpdateOnClient = 0x4B1; // bool
    constexpr std::ptrdiff_t m_nInputType = 0x4B4; // ValueRemapperInputType_t
    constexpr std::ptrdiff_t m_iszRemapLineStartName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszRemapLineEndName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hRemapLineStart = 0x4C8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hRemapLineEnd = 0x4CC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flMaximumChangePerSecond = 0x4D0; // float
    constexpr std::ptrdiff_t m_flDisengageDistance = 0x4D4; // float
    constexpr std::ptrdiff_t m_flEngageDistance = 0x4D8; // float
    constexpr std::ptrdiff_t m_bRequiresUseKey = 0x4DC; // bool
    constexpr std::ptrdiff_t m_nOutputType = 0x4E0; // ValueRemapperOutputType_t
    constexpr std::ptrdiff_t m_iszOutputEntityName = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity2Name = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity3Name = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOutputEntity4Name = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hOutputEntities = 0x508; // CNetworkUtlVectorBase<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nHapticsType = 0x520; // ValueRemapperHapticsType_t
    constexpr std::ptrdiff_t m_nMomentumType = 0x524; // ValueRemapperMomentumType_t
    constexpr std::ptrdiff_t m_flMomentumModifier = 0x528; // float
    constexpr std::ptrdiff_t m_flSnapValue = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentMomentum = 0x530; // float
    constexpr std::ptrdiff_t m_nRatchetType = 0x534; // ValueRemapperRatchetType_t
    constexpr std::ptrdiff_t m_flRatchetOffset = 0x538; // float
    constexpr std::ptrdiff_t m_flInputOffset = 0x53C; // float
    constexpr std::ptrdiff_t m_bEngaged = 0x540; // bool
    constexpr std::ptrdiff_t m_bFirstUpdate = 0x541; // bool
    constexpr std::ptrdiff_t m_flPreviousValue = 0x544; // float
    constexpr std::ptrdiff_t m_flPreviousUpdateTickTime = 0x548; // GameTime_t
    constexpr std::ptrdiff_t m_vecPreviousTestPoint = 0x54C; // Vector
    constexpr std::ptrdiff_t m_hUsingPlayer = 0x558; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flCustomOutputValue = 0x55C; // float
    constexpr std::ptrdiff_t m_iszSoundEngage = 0x560; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundDisengage = 0x568; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueZero = 0x570; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundReachedValueOne = 0x578; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSoundMovingLoop = 0x580; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Position = 0x590; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_PositionDelta = 0x5B8; // CEntityOutputTemplate<float>
    constexpr std::ptrdiff_t m_OnReachedValueZero = 0x5E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueOne = 0x608; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnReachedValueCustom = 0x630; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEngage = 0x658; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnDisengage = 0x680; // CEntityIOOutput
}

namespace CPointVelocitySensor { // CPointEntity
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecAxis = 0x4B4; // Vector
    constexpr std::ptrdiff_t m_bEnabled = 0x4C0; // bool
    constexpr std::ptrdiff_t m_fPrevVelocity = 0x4C4; // float
    constexpr std::ptrdiff_t m_flAvgInterval = 0x4C8; // float
    constexpr std::ptrdiff_t m_Velocity = 0x4D0; // CEntityOutputTemplate<float>
}

namespace CPointWorldText { // CModelPointEntity
    constexpr std::ptrdiff_t m_messageText = 0x700; // char[512]
    constexpr std::ptrdiff_t m_FontName = 0x900; // char[64]
    constexpr std::ptrdiff_t m_bEnabled = 0x940; // bool
    constexpr std::ptrdiff_t m_bFullbright = 0x941; // bool
    constexpr std::ptrdiff_t m_flWorldUnitsPerPx = 0x944; // float
    constexpr std::ptrdiff_t m_flFontSize = 0x948; // float
    constexpr std::ptrdiff_t m_flDepthOffset = 0x94C; // float
    constexpr std::ptrdiff_t m_Color = 0x950; // Color
    constexpr std::ptrdiff_t m_nJustifyHorizontal = 0x954; // PointWorldTextJustifyHorizontal_t
    constexpr std::ptrdiff_t m_nJustifyVertical = 0x958; // PointWorldTextJustifyVertical_t
    constexpr std::ptrdiff_t m_nReorientMode = 0x95C; // PointWorldTextReorientMode_t
}

namespace CPostProcessingVolume { // CBaseTrigger
    constexpr std::ptrdiff_t m_hPostSettings = 0x8B8; // CStrongHandle<InfoForResourceTypeCPostProcessingResource>
    constexpr std::ptrdiff_t m_flFadeDuration = 0x8C0; // float
    constexpr std::ptrdiff_t m_flMinLogExposure = 0x8C4; // float
    constexpr std::ptrdiff_t m_flMaxLogExposure = 0x8C8; // float
    constexpr std::ptrdiff_t m_flMinExposure = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMaxExposure = 0x8D0; // float
    constexpr std::ptrdiff_t m_flExposureCompensation = 0x8D4; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedUp = 0x8D8; // float
    constexpr std::ptrdiff_t m_flExposureFadeSpeedDown = 0x8DC; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x8E0; // float
    constexpr std::ptrdiff_t m_bMaster = 0x8E4; // bool
    constexpr std::ptrdiff_t m_bExposureControl = 0x8E5; // bool
    constexpr std::ptrdiff_t m_flRate = 0x8E8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x8EC; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x8F0; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x8F4; // float
}

namespace CPrecipitation { // CBaseTrigger
}

namespace CPrecipitationBlocker { // CBaseModelEntity
}

namespace CPrecipitationVData { // CEntitySubclassVDataBase
    constexpr std::ptrdiff_t m_szParticlePrecipitationEffect = 0x28; // CResourceNameTyped<CWeakHandle<InfoForResourceTypeIParticleSystemDefinition>>
    constexpr std::ptrdiff_t m_flInnerDistance = 0x108; // float
    constexpr std::ptrdiff_t m_nAttachType = 0x10C; // ParticleAttachment_t
    constexpr std::ptrdiff_t m_bBatchSameVolumeType = 0x110; // bool
    constexpr std::ptrdiff_t m_nRTEnvCP = 0x114; // int32_t
    constexpr std::ptrdiff_t m_nRTEnvCPComponent = 0x118; // int32_t
    constexpr std::ptrdiff_t m_szModifier = 0x120; // CUtlString
}

namespace CPredictedViewModel { // CBaseViewModel
}

namespace CProjectedDecal { // CPointEntity
    constexpr std::ptrdiff_t m_nTexture = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_flDistance = 0x4B4; // float
}

namespace CPropDoorRotating { // CBasePropDoor
    constexpr std::ptrdiff_t m_vecAxis = 0xD98; // Vector
    constexpr std::ptrdiff_t m_flDistance = 0xDA4; // float
    constexpr std::ptrdiff_t m_eSpawnPosition = 0xDA8; // PropDoorRotatingSpawnPos_t
    constexpr std::ptrdiff_t m_eOpenDirection = 0xDAC; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_eCurrentOpenDirection = 0xDB0; // PropDoorRotatingOpenDirection_e
    constexpr std::ptrdiff_t m_flAjarAngle = 0xDB4; // float
    constexpr std::ptrdiff_t m_angRotationAjarDeprecated = 0xDB8; // QAngle
    constexpr std::ptrdiff_t m_angRotationClosed = 0xDC4; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenForward = 0xDD0; // QAngle
    constexpr std::ptrdiff_t m_angRotationOpenBack = 0xDDC; // QAngle
    constexpr std::ptrdiff_t m_angGoal = 0xDE8; // QAngle
    constexpr std::ptrdiff_t m_vecForwardBoundsMin = 0xDF4; // Vector
    constexpr std::ptrdiff_t m_vecForwardBoundsMax = 0xE00; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMin = 0xE0C; // Vector
    constexpr std::ptrdiff_t m_vecBackBoundsMax = 0xE18; // Vector
    constexpr std::ptrdiff_t m_bAjarDoorShouldntAlwaysOpen = 0xE24; // bool
    constexpr std::ptrdiff_t m_hEntityBlocker = 0xE28; // CHandle<CEntityBlocker>
}

namespace CPropDoorRotatingBreakable { // CPropDoorRotating
    constexpr std::ptrdiff_t m_bBreakable = 0xE30; // bool
    constexpr std::ptrdiff_t m_isAbleToCloseAreaPortals = 0xE31; // bool
    constexpr std::ptrdiff_t m_currentDamageState = 0xE34; // int32_t
    constexpr std::ptrdiff_t m_damageStates = 0xE38; // CUtlVector<CUtlSymbolLarge>
}

namespace CPulseCell_Inflow_GameEvent { // CPulseCell_Inflow_BaseEntrypoint
    constexpr std::ptrdiff_t m_EventName = 0x70; // CBufferString
}

namespace CPulseCell_Outflow_PlayVCD { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_vcdFilename = 0x48; // CUtlString
    constexpr std::ptrdiff_t m_OnFinished = 0x50; // CPulse_OutflowConnection
    constexpr std::ptrdiff_t m_Triggers = 0x60; // CUtlVector<CPulse_OutflowConnection>
}

namespace CPulseCell_SoundEventStart { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Type = 0x48; // SoundEventStartType_t
}

namespace CPulseCell_Step_EntFire { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_Input = 0x48; // CUtlString
}

namespace CPulseCell_Step_SetAnimGraphParam { // CPulseCell_BaseFlow
    constexpr std::ptrdiff_t m_ParamName = 0x48; // CUtlString
}

namespace CPulseCell_Value_FindEntByName { // CPulseCell_BaseValue
    constexpr std::ptrdiff_t m_EntityType = 0x48; // CUtlString
}

namespace CPulseGraphInstance_ServerPointEntity { // CBasePulseGraphInstance
}

namespace CPulseServerFuncs {
}

namespace CPulseServerFuncs_Sounds {
}

namespace CPushable { // CBreakable
}

namespace CRR_Response {
    constexpr std::ptrdiff_t m_Type = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_szResponseName = 0x1; // char[192]
    constexpr std::ptrdiff_t m_szMatchingRule = 0xC1; // char[128]
    constexpr std::ptrdiff_t m_Params = 0x148; // ResponseParams
    constexpr std::ptrdiff_t m_fMatchScore = 0x168; // float
    constexpr std::ptrdiff_t m_szSpeakerContext = 0x170; // char*
    constexpr std::ptrdiff_t m_szWorldContext = 0x178; // char*
    constexpr std::ptrdiff_t m_Followup = 0x180; // ResponseFollowup
    constexpr std::ptrdiff_t m_pchCriteriaNames = 0x1B8; // CUtlVector<CUtlSymbol>
    constexpr std::ptrdiff_t m_pchCriteriaValues = 0x1D0; // CUtlVector<char*>
}

namespace CRagdollConstraint { // CPhysConstraint
    constexpr std::ptrdiff_t m_xmin = 0x508; // float
    constexpr std::ptrdiff_t m_xmax = 0x50C; // float
    constexpr std::ptrdiff_t m_ymin = 0x510; // float
    constexpr std::ptrdiff_t m_ymax = 0x514; // float
    constexpr std::ptrdiff_t m_zmin = 0x518; // float
    constexpr std::ptrdiff_t m_zmax = 0x51C; // float
    constexpr std::ptrdiff_t m_xfriction = 0x520; // float
    constexpr std::ptrdiff_t m_yfriction = 0x524; // float
    constexpr std::ptrdiff_t m_zfriction = 0x528; // float
}

namespace CRagdollMagnet { // CPointEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_radius = 0x4B4; // float
    constexpr std::ptrdiff_t m_force = 0x4B8; // float
    constexpr std::ptrdiff_t m_axis = 0x4BC; // Vector
}

namespace CRagdollManager { // CBaseEntity
    constexpr std::ptrdiff_t m_iCurrentMaxRagdollCount = 0x4B0; // int8_t
    constexpr std::ptrdiff_t m_iMaxRagdollCount = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_bSaveImportant = 0x4B8; // bool
}

namespace CRagdollProp { // CBaseAnimGraph
    constexpr std::ptrdiff_t m_ragdoll = 0x898; // ragdoll_t
    constexpr std::ptrdiff_t m_bStartDisabled = 0x8D0; // bool
    constexpr std::ptrdiff_t m_ragPos = 0x8D8; // CNetworkUtlVectorBase<Vector>
    constexpr std::ptrdiff_t m_ragAngles = 0x8F0; // CNetworkUtlVectorBase<QAngle>
    constexpr std::ptrdiff_t m_hRagdollSource = 0x908; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_lastUpdateTickCount = 0x90C; // uint32_t
    constexpr std::ptrdiff_t m_allAsleep = 0x910; // bool
    constexpr std::ptrdiff_t m_bFirstCollisionAfterLaunch = 0x911; // bool
    constexpr std::ptrdiff_t m_hDamageEntity = 0x914; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hKiller = 0x918; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hPhysicsAttacker = 0x91C; // CHandle<CBasePlayerPawn>
    constexpr std::ptrdiff_t m_flLastPhysicsInfluenceTime = 0x920; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeOutStartTime = 0x924; // GameTime_t
    constexpr std::ptrdiff_t m_flFadeTime = 0x928; // float
    constexpr std::ptrdiff_t m_vecLastOrigin = 0x92C; // Vector
    constexpr std::ptrdiff_t m_flAwakeTime = 0x938; // GameTime_t
    constexpr std::ptrdiff_t m_flLastOriginChangeTime = 0x93C; // GameTime_t
    constexpr std::ptrdiff_t m_nBloodColor = 0x940; // int32_t
    constexpr std::ptrdiff_t m_strOriginClassName = 0x948; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_strSourceClassName = 0x950; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bHasBeenPhysgunned = 0x958; // bool
    constexpr std::ptrdiff_t m_bShouldTeleportPhysics = 0x959; // bool
    constexpr std::ptrdiff_t m_flBlendWeight = 0x95C; // float
    constexpr std::ptrdiff_t m_flDefaultFadeScale = 0x960; // float
    constexpr std::ptrdiff_t m_ragdollMins = 0x968; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_ragdollMaxs = 0x980; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_bShouldDeleteActivationRecord = 0x998; // bool
    constexpr std::ptrdiff_t m_bValidatePoweredRagdollPose = 0x9F8; // bool
}

namespace CRagdollPropAlias_physics_prop_ragdoll { // CRagdollProp
}

namespace CRagdollPropAttached { // CRagdollProp
    constexpr std::ptrdiff_t m_boneIndexAttached = 0xA38; // uint32_t
    constexpr std::ptrdiff_t m_ragdollAttachedObjectIndex = 0xA3C; // uint32_t
    constexpr std::ptrdiff_t m_attachmentPointBoneSpace = 0xA40; // Vector
    constexpr std::ptrdiff_t m_attachmentPointRagdollSpace = 0xA4C; // Vector
    constexpr std::ptrdiff_t m_bShouldDetach = 0xA58; // bool
    constexpr std::ptrdiff_t m_bShouldDeleteAttachedActivationRecord = 0xA68; // bool
}

namespace CRandSimTimer { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_minInterval = 0x8; // float
    constexpr std::ptrdiff_t m_maxInterval = 0xC; // float
}

namespace CRandStopwatch { // CStopwatchBase
    constexpr std::ptrdiff_t m_minInterval = 0xC; // float
    constexpr std::ptrdiff_t m_maxInterval = 0x10; // float
}

namespace CRangeFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[2]
}

namespace CRangeInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[2]
}

namespace CRectLight { // CBarnLight
    constexpr std::ptrdiff_t m_bShowLight = 0x928; // bool
}

namespace CRemapFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CRenderComponent { // CEntityComponent
    constexpr std::ptrdiff_t __m_pChainEntity = 0x10; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_bIsRenderingWithViewModels = 0x50; // bool
    constexpr std::ptrdiff_t m_nSplitscreenFlags = 0x54; // uint32_t
    constexpr std::ptrdiff_t m_bEnableRendering = 0x60; // bool
    constexpr std::ptrdiff_t m_bInterpolationReadyToDraw = 0xB0; // bool
}

namespace CResponseCriteriaSet {
    constexpr std::ptrdiff_t m_nNumPrefixedContexts = 0x28; // int32_t
    constexpr std::ptrdiff_t m_bOverrideOnAppend = 0x2C; // bool
}

namespace CResponseQueue {
    constexpr std::ptrdiff_t m_ExpresserTargets = 0x50; // CUtlVector<CAI_Expresser*>
}

namespace CResponseQueue_CDeferredResponse {
    constexpr std::ptrdiff_t m_contexts = 0x10; // CResponseCriteriaSet
    constexpr std::ptrdiff_t m_fDispatchTime = 0x40; // float
    constexpr std::ptrdiff_t m_hIssuer = 0x44; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_response = 0x50; // CRR_Response
    constexpr std::ptrdiff_t m_bResponseValid = 0x238; // bool
}

namespace CRetakeGameRules {
    constexpr std::ptrdiff_t m_nMatchSeed = 0xF8; // int32_t
    constexpr std::ptrdiff_t m_bBlockersPresent = 0xFC; // bool
    constexpr std::ptrdiff_t m_bRoundInProgress = 0xFD; // bool
    constexpr std::ptrdiff_t m_iFirstSecondHalfRound = 0x100; // int32_t
    constexpr std::ptrdiff_t m_iBombSite = 0x104; // int32_t
}

namespace CRevertSaved { // CModelPointEntity
    constexpr std::ptrdiff_t m_loadTime = 0x700; // float
    constexpr std::ptrdiff_t m_Duration = 0x704; // float
    constexpr std::ptrdiff_t m_HoldTime = 0x708; // float
}

namespace CRopeKeyframe { // CBaseModelEntity
    constexpr std::ptrdiff_t m_RopeFlags = 0x708; // uint16_t
    constexpr std::ptrdiff_t m_iNextLinkName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_Slack = 0x718; // int16_t
    constexpr std::ptrdiff_t m_Width = 0x71C; // float
    constexpr std::ptrdiff_t m_TextureScale = 0x720; // float
    constexpr std::ptrdiff_t m_nSegments = 0x724; // uint8_t
    constexpr std::ptrdiff_t m_bConstrainBetweenEndpoints = 0x725; // bool
    constexpr std::ptrdiff_t m_strRopeMaterialModel = 0x728; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iRopeMaterialModelIndex = 0x730; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_Subdiv = 0x738; // uint8_t
    constexpr std::ptrdiff_t m_nChangeCount = 0x739; // uint8_t
    constexpr std::ptrdiff_t m_RopeLength = 0x73A; // int16_t
    constexpr std::ptrdiff_t m_fLockedPoints = 0x73C; // uint8_t
    constexpr std::ptrdiff_t m_bCreatedFromMapFile = 0x73D; // bool
    constexpr std::ptrdiff_t m_flScrollSpeed = 0x740; // float
    constexpr std::ptrdiff_t m_bStartPointValid = 0x744; // bool
    constexpr std::ptrdiff_t m_bEndPointValid = 0x745; // bool
    constexpr std::ptrdiff_t m_hStartPoint = 0x748; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hEndPoint = 0x74C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iStartAttachment = 0x750; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_iEndAttachment = 0x751; // AttachmentHandle_t
}

namespace CRopeKeyframeAlias_move_rope { // CRopeKeyframe
}

namespace CRotButton { // CBaseButton
}

namespace CRotDoor { // CBaseDoor
    constexpr std::ptrdiff_t m_bSolidBsp = 0x988; // bool
}

namespace CRuleBrushEntity { // CRuleEntity
}

namespace CRuleEntity { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iszMaster = 0x700; // CUtlSymbolLarge
}

namespace CRulePointEntity { // CRuleEntity
    constexpr std::ptrdiff_t m_Score = 0x708; // int32_t
}

namespace CSAdditionalMatchStats_t { // CSAdditionalPerRoundStats_t
    constexpr std::ptrdiff_t m_numRoundsSurvived = 0x14; // int32_t
    constexpr std::ptrdiff_t m_maxNumRoundsSurvived = 0x18; // int32_t
    constexpr std::ptrdiff_t m_numRoundsSurvivedTotal = 0x1C; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchase = 0x20; // int32_t
    constexpr std::ptrdiff_t m_iRoundsWonWithoutPurchaseTotal = 0x24; // int32_t
    constexpr std::ptrdiff_t m_numFirstKills = 0x28; // int32_t
    constexpr std::ptrdiff_t m_numClutchKills = 0x2C; // int32_t
    constexpr std::ptrdiff_t m_numPistolKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_numSniperKills = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iNumSuicides = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iNumTeamKills = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iTeamDamage = 0x40; // int32_t
}

namespace CSAdditionalPerRoundStats_t {
    constexpr std::ptrdiff_t m_numChickensKilled = 0x0; // int32_t
    constexpr std::ptrdiff_t m_killsWhileBlind = 0x4; // int32_t
    constexpr std::ptrdiff_t m_bombCarrierkills = 0x8; // int32_t
    constexpr std::ptrdiff_t m_iBurnDamageInflicted = 0xC; // int32_t
    constexpr std::ptrdiff_t m_iDinks = 0x10; // int32_t
}

namespace CSMatchStats_t { // CSPerRoundStats_t
    constexpr std::ptrdiff_t m_iEnemy5Ks = 0x68; // int32_t
    constexpr std::ptrdiff_t m_iEnemy4Ks = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_iEnemy3Ks = 0x70; // int32_t
    constexpr std::ptrdiff_t m_iEnemy2Ks = 0x74; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Count = 0x78; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Successes = 0x7C; // int32_t
    constexpr std::ptrdiff_t m_iUtility_Enemies = 0x80; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Count = 0x84; // int32_t
    constexpr std::ptrdiff_t m_iFlash_Successes = 0x88; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsRemovedTotal = 0x8C; // int32_t
    constexpr std::ptrdiff_t m_nHealthPointsDealtTotal = 0x90; // int32_t
    constexpr std::ptrdiff_t m_nShotsFiredTotal = 0x94; // int32_t
    constexpr std::ptrdiff_t m_nShotsOnTargetTotal = 0x98; // int32_t
    constexpr std::ptrdiff_t m_i1v1Count = 0x9C; // int32_t
    constexpr std::ptrdiff_t m_i1v1Wins = 0xA0; // int32_t
    constexpr std::ptrdiff_t m_i1v2Count = 0xA4; // int32_t
    constexpr std::ptrdiff_t m_i1v2Wins = 0xA8; // int32_t
    constexpr std::ptrdiff_t m_iEntryCount = 0xAC; // int32_t
    constexpr std::ptrdiff_t m_iEntryWins = 0xB0; // int32_t
}

namespace CSPerRoundStats_t {
    constexpr std::ptrdiff_t m_iKills = 0x30; // int32_t
    constexpr std::ptrdiff_t m_iDeaths = 0x34; // int32_t
    constexpr std::ptrdiff_t m_iAssists = 0x38; // int32_t
    constexpr std::ptrdiff_t m_iDamage = 0x3C; // int32_t
    constexpr std::ptrdiff_t m_iEquipmentValue = 0x40; // int32_t
    constexpr std::ptrdiff_t m_iMoneySaved = 0x44; // int32_t
    constexpr std::ptrdiff_t m_iKillReward = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iLiveTime = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iHeadShotKills = 0x50; // int32_t
    constexpr std::ptrdiff_t m_iObjective = 0x54; // int32_t
    constexpr std::ptrdiff_t m_iCashEarned = 0x58; // int32_t
    constexpr std::ptrdiff_t m_iUtilityDamage = 0x5C; // int32_t
    constexpr std::ptrdiff_t m_iEnemiesFlashed = 0x60; // int32_t
}

namespace CSceneEntity { // CPointEntity
    constexpr std::ptrdiff_t m_iszSceneFile = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszResumeSceneFile = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget1 = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget2 = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget3 = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget4 = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget5 = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget6 = 0x4F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget7 = 0x4F8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTarget8 = 0x500; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTarget1 = 0x508; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget2 = 0x50C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget3 = 0x510; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget4 = 0x514; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget5 = 0x518; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget6 = 0x51C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget7 = 0x520; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget8 = 0x524; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bIsPlayingBack = 0x528; // bool
    constexpr std::ptrdiff_t m_bPaused = 0x529; // bool
    constexpr std::ptrdiff_t m_bMultiplayer = 0x52A; // bool
    constexpr std::ptrdiff_t m_bAutogenerated = 0x52B; // bool
    constexpr std::ptrdiff_t m_flForceClientTime = 0x52C; // float
    constexpr std::ptrdiff_t m_flCurrentTime = 0x530; // float
    constexpr std::ptrdiff_t m_flFrameTime = 0x534; // float
    constexpr std::ptrdiff_t m_bCancelAtNextInterrupt = 0x538; // bool
    constexpr std::ptrdiff_t m_fPitch = 0x53C; // float
    constexpr std::ptrdiff_t m_bAutomated = 0x540; // bool
    constexpr std::ptrdiff_t m_nAutomatedAction = 0x544; // int32_t
    constexpr std::ptrdiff_t m_flAutomationDelay = 0x548; // float
    constexpr std::ptrdiff_t m_flAutomationTime = 0x54C; // float
    constexpr std::ptrdiff_t m_hWaitingForThisResumeScene = 0x550; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bWaitingForResumeScene = 0x554; // bool
    constexpr std::ptrdiff_t m_bPausedViaInput = 0x555; // bool
    constexpr std::ptrdiff_t m_bPauseAtNextInterrupt = 0x556; // bool
    constexpr std::ptrdiff_t m_bWaitingForActor = 0x557; // bool
    constexpr std::ptrdiff_t m_bWaitingForInterrupt = 0x558; // bool
    constexpr std::ptrdiff_t m_bInterruptedActorsScenes = 0x559; // bool
    constexpr std::ptrdiff_t m_bBreakOnNonIdle = 0x55A; // bool
    constexpr std::ptrdiff_t m_hActorList = 0x560; // CNetworkUtlVectorBase<CHandle<CBaseFlex>>
    constexpr std::ptrdiff_t m_hRemoveActorList = 0x578; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_nSceneFlushCounter = 0x5A0; // int32_t
    constexpr std::ptrdiff_t m_nSceneStringIndex = 0x5A4; // uint16_t
    constexpr std::ptrdiff_t m_OnStart = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCompletion = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCanceled = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPaused = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnResumed = 0x648; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTrigger = 0x670; // CEntityIOOutput[16]
    constexpr std::ptrdiff_t m_hInterruptScene = 0x980; // CHandle<CSceneEntity>
    constexpr std::ptrdiff_t m_nInterruptCount = 0x984; // int32_t
    constexpr std::ptrdiff_t m_bSceneMissing = 0x988; // bool
    constexpr std::ptrdiff_t m_bInterrupted = 0x989; // bool
    constexpr std::ptrdiff_t m_bCompletedEarly = 0x98A; // bool
    constexpr std::ptrdiff_t m_bInterruptSceneFinished = 0x98B; // bool
    constexpr std::ptrdiff_t m_bRestoring = 0x98C; // bool
    constexpr std::ptrdiff_t m_hNotifySceneCompletion = 0x990; // CUtlVector<CHandle<CSceneEntity>>
    constexpr std::ptrdiff_t m_hListManagers = 0x9A8; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszSoundName = 0x9E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hActor = 0x9F0; // CHandle<CBaseFlex>
    constexpr std::ptrdiff_t m_hActivator = 0x9F4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_BusyActor = 0x9F8; // int32_t
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x9FC; // SceneOnPlayerDeath_t
}

namespace CSceneEntityAlias_logic_choreographed_scene { // CSceneEntity
}

namespace CSceneEventInfo {
    constexpr std::ptrdiff_t m_iLayer = 0x0; // int32_t
    constexpr std::ptrdiff_t m_iPriority = 0x4; // int32_t
    constexpr std::ptrdiff_t m_hSequence = 0x8; // HSequence
    constexpr std::ptrdiff_t m_flWeight = 0xC; // float
    constexpr std::ptrdiff_t m_bIsMoving = 0x10; // bool
    constexpr std::ptrdiff_t m_bHasArrived = 0x11; // bool
    constexpr std::ptrdiff_t m_flInitialYaw = 0x14; // float
    constexpr std::ptrdiff_t m_flTargetYaw = 0x18; // float
    constexpr std::ptrdiff_t m_flFacingYaw = 0x1C; // float
    constexpr std::ptrdiff_t m_nType = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flNext = 0x24; // GameTime_t
    constexpr std::ptrdiff_t m_bIsGesture = 0x28; // bool
    constexpr std::ptrdiff_t m_bShouldRemove = 0x29; // bool
    constexpr std::ptrdiff_t m_hTarget = 0x54; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nSceneEventId = 0x58; // uint32_t
    constexpr std::ptrdiff_t m_bClientSide = 0x5C; // bool
    constexpr std::ptrdiff_t m_bStarted = 0x5D; // bool
}

namespace CSceneListManager { // CLogicalEntity
    constexpr std::ptrdiff_t m_hListManagers = 0x4B0; // CUtlVector<CHandle<CSceneListManager>>
    constexpr std::ptrdiff_t m_iszScenes = 0x4C8; // CUtlSymbolLarge[16]
    constexpr std::ptrdiff_t m_hScenes = 0x548; // CHandle<CBaseEntity>[16]
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CScriptItem { // CItem
    constexpr std::ptrdiff_t m_OnPlayerPickup = 0x968; // CEntityIOOutput
    constexpr std::ptrdiff_t m_MoveTypeOverride = 0x990; // MoveType_t
}

namespace CScriptNavBlocker { // CFuncNavBlocker
    constexpr std::ptrdiff_t m_vExtent = 0x710; // Vector
}

namespace CScriptTriggerHurt { // CTriggerHurt
    constexpr std::ptrdiff_t m_vExtent = 0x948; // Vector
}

namespace CScriptTriggerMultiple { // CTriggerMultiple
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerOnce { // CTriggerOnce
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptTriggerPush { // CTriggerPush
    constexpr std::ptrdiff_t m_vExtent = 0x8D0; // Vector
}

namespace CScriptUniformRandomStream {
    constexpr std::ptrdiff_t m_hScriptScope = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nInitialSeed = 0x9C; // int32_t
}

namespace CScriptedSequence { // CBaseEntity
    constexpr std::ptrdiff_t m_iszEntry = 0x4B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPreIdle = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPlay = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszPostIdle = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszModifierToAddOnPlay = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszNextScript = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszEntity = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSyncGroup = 0x4E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nMoveTo = 0x4F0; // ScriptedMoveTo_t
    constexpr std::ptrdiff_t m_bIsPlayingPreIdle = 0x4F4; // bool
    constexpr std::ptrdiff_t m_bIsPlayingEntry = 0x4F5; // bool
    constexpr std::ptrdiff_t m_bIsPlayingAction = 0x4F6; // bool
    constexpr std::ptrdiff_t m_bIsPlayingPostIdle = 0x4F7; // bool
    constexpr std::ptrdiff_t m_bLoopPreIdleSequence = 0x4F8; // bool
    constexpr std::ptrdiff_t m_bLoopActionSequence = 0x4F9; // bool
    constexpr std::ptrdiff_t m_bLoopPostIdleSequence = 0x4FA; // bool
    constexpr std::ptrdiff_t m_bSynchPostIdles = 0x4FB; // bool
    constexpr std::ptrdiff_t m_bIgnoreGravity = 0x4FC; // bool
    constexpr std::ptrdiff_t m_bDisableNPCCollisions = 0x4FD; // bool
    constexpr std::ptrdiff_t m_bKeepAnimgraphLockedPost = 0x4FE; // bool
    constexpr std::ptrdiff_t m_bDontAddModifiers = 0x4FF; // bool
    constexpr std::ptrdiff_t m_flRadius = 0x500; // float
    constexpr std::ptrdiff_t m_flRepeat = 0x504; // float
    constexpr std::ptrdiff_t m_flPlayAnimFadeInTime = 0x508; // float
    constexpr std::ptrdiff_t m_flMoveInterpTime = 0x50C; // float
    constexpr std::ptrdiff_t m_flAngRate = 0x510; // float
    constexpr std::ptrdiff_t m_iDelay = 0x514; // int32_t
    constexpr std::ptrdiff_t m_startTime = 0x518; // GameTime_t
    constexpr std::ptrdiff_t m_bWaitForBeginSequence = 0x51C; // bool
    constexpr std::ptrdiff_t m_saved_effects = 0x520; // int32_t
    constexpr std::ptrdiff_t m_savedFlags = 0x524; // int32_t
    constexpr std::ptrdiff_t m_savedCollisionGroup = 0x528; // int32_t
    constexpr std::ptrdiff_t m_interruptable = 0x52C; // bool
    constexpr std::ptrdiff_t m_sequenceStarted = 0x52D; // bool
    constexpr std::ptrdiff_t m_bPrevAnimatedEveryTick = 0x52E; // bool
    constexpr std::ptrdiff_t m_bForcedAnimatedEveryTick = 0x52F; // bool
    constexpr std::ptrdiff_t m_bPositionRelativeToOtherEntity = 0x530; // bool
    constexpr std::ptrdiff_t m_hTargetEnt = 0x534; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hNextCine = 0x538; // CHandle<CScriptedSequence>
    constexpr std::ptrdiff_t m_bThinking = 0x53C; // bool
    constexpr std::ptrdiff_t m_bInitiatedSelfDelete = 0x53D; // bool
    constexpr std::ptrdiff_t m_bIsTeleportingDueToMoveTo = 0x53E; // bool
    constexpr std::ptrdiff_t m_bAllowCustomInterruptConditions = 0x53F; // bool
    constexpr std::ptrdiff_t m_hLastFoundEntity = 0x540; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hForcedTarget = 0x544; // CHandle<CBaseAnimGraph>
    constexpr std::ptrdiff_t m_bDontCancelOtherSequences = 0x548; // bool
    constexpr std::ptrdiff_t m_bForceSynch = 0x549; // bool
    constexpr std::ptrdiff_t m_bTargetWasAsleep = 0x54A; // bool
    constexpr std::ptrdiff_t m_bPreventUpdateYawOnFinish = 0x54B; // bool
    constexpr std::ptrdiff_t m_bEnsureOnNavmeshOnFinish = 0x54C; // bool
    constexpr std::ptrdiff_t m_onDeathBehavior = 0x550; // ScriptedOnDeath_t
    constexpr std::ptrdiff_t m_ConflictResponse = 0x554; // ScriptedConflictResponse_t
    constexpr std::ptrdiff_t m_OnBeginSequence = 0x558; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnActionStartOrLoop = 0x580; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndSequence = 0x5A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnPostIdleEndSequence = 0x5D0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelSequence = 0x5F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnCancelFailedSequence = 0x620; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnScriptEvent = 0x648; // CEntityIOOutput[8]
    constexpr std::ptrdiff_t m_matOtherToMain = 0x790; // CTransform
    constexpr std::ptrdiff_t m_hInteractionMainEntity = 0x7B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iPlayerDeathBehavior = 0x7B4; // int32_t
}

namespace CSensorGrenade { // CBaseCSGrenade
}

namespace CSensorGrenadeProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_fExpireTime = 0xA40; // GameTime_t
    constexpr std::ptrdiff_t m_fNextDetectPlayerSound = 0xA44; // GameTime_t
    constexpr std::ptrdiff_t m_hDisplayGrenade = 0xA48; // CHandle<CBaseEntity>
}

namespace CServerOnlyEntity { // CBaseEntity
}

namespace CServerOnlyModelEntity { // CBaseModelEntity
}

namespace CServerOnlyPointEntity { // CServerOnlyEntity
}

namespace CServerRagdollTrigger { // CBaseTrigger
}

namespace CShatterGlassShard {
    constexpr std::ptrdiff_t m_hShardHandle = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x10; // CUtlVector<Vector2D>
    constexpr std::ptrdiff_t m_vLocalPanelSpaceOrigin = 0x28; // Vector2D
    constexpr std::ptrdiff_t m_hModel = 0x30; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_hPhysicsEntity = 0x38; // CHandle<CShatterGlassShardPhysics>
    constexpr std::ptrdiff_t m_hParentPanel = 0x3C; // CHandle<CFuncShatterglass>
    constexpr std::ptrdiff_t m_hParentShard = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_ShatterStressType = 0x44; // ShatterGlassStressType
    constexpr std::ptrdiff_t m_vecStressVelocity = 0x48; // Vector
    constexpr std::ptrdiff_t m_bCreatedModel = 0x54; // bool
    constexpr std::ptrdiff_t m_flLongestEdge = 0x58; // float
    constexpr std::ptrdiff_t m_flShortestEdge = 0x5C; // float
    constexpr std::ptrdiff_t m_flLongestAcross = 0x60; // float
    constexpr std::ptrdiff_t m_flShortestAcross = 0x64; // float
    constexpr std::ptrdiff_t m_flSumOfAllEdges = 0x68; // float
    constexpr std::ptrdiff_t m_flArea = 0x6C; // float
    constexpr std::ptrdiff_t m_nOnFrameEdge = 0x70; // OnFrame
    constexpr std::ptrdiff_t m_nParentPanelsNthShard = 0x74; // int32_t
    constexpr std::ptrdiff_t m_nSubShardGeneration = 0x78; // int32_t
    constexpr std::ptrdiff_t m_vecAverageVertPosition = 0x7C; // Vector2D
    constexpr std::ptrdiff_t m_bAverageVertPositionIsValid = 0x84; // bool
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionA = 0x88; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelSpaceStressPositionB = 0x90; // Vector2D
    constexpr std::ptrdiff_t m_bStressPositionAIsValid = 0x98; // bool
    constexpr std::ptrdiff_t m_bStressPositionBIsValid = 0x99; // bool
    constexpr std::ptrdiff_t m_bFlaggedForRemoval = 0x9A; // bool
    constexpr std::ptrdiff_t m_flPhysicsEntitySpawnedAtTime = 0x9C; // GameTime_t
    constexpr std::ptrdiff_t m_bShatterRateLimited = 0xA0; // bool
    constexpr std::ptrdiff_t m_hEntityHittingMe = 0xA4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_vecNeighbors = 0xA8; // CUtlVector<uint32_t>
}

namespace CShatterGlassShardPhysics { // CPhysicsProp
    constexpr std::ptrdiff_t m_bDebris = 0xB78; // bool
    constexpr std::ptrdiff_t m_hParentShard = 0xB7C; // uint32_t
    constexpr std::ptrdiff_t m_ShardDesc = 0xB80; // shard_model_desc_t
}

namespace CShower { // CModelPointEntity
}

namespace CSimTimer { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_interval = 0x8; // float
}

namespace CSimpleMarkupVolumeTagged { // CMarkupVolumeTagged
}

namespace CSimpleSimTimer {
    constexpr std::ptrdiff_t m_next = 0x0; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x4; // WorldGroupId_t
}

namespace CSimpleStopwatch { // CStopwatchBase
}

namespace CSingleplayRules { // CGameRules
    constexpr std::ptrdiff_t m_bSinglePlayerGameEnding = 0x90; // bool
}

namespace CSkeletonAnimationController { // ISkeletonAnimationController
    constexpr std::ptrdiff_t m_pSkeletonInstance = 0x8; // CSkeletonInstance*
}

namespace CSkeletonInstance { // CGameSceneNode
    constexpr std::ptrdiff_t m_modelState = 0x160; // CModelState
    constexpr std::ptrdiff_t m_bIsAnimationEnabled = 0x390; // bool
    constexpr std::ptrdiff_t m_bUseParentRenderBounds = 0x391; // bool
    constexpr std::ptrdiff_t m_bDisableSolidCollisionsForHierarchy = 0x392; // bool
    constexpr std::ptrdiff_t m_bDirtyMotionType = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_bIsGeneratingLatchedParentSpaceState = 0x0; // bitfield:1
    constexpr std::ptrdiff_t m_materialGroup = 0x394; // CUtlStringToken
    constexpr std::ptrdiff_t m_nHitboxSet = 0x398; // uint8_t
}

namespace CSkillDamage {
    constexpr std::ptrdiff_t m_flDamage = 0x0; // CSkillFloat
    constexpr std::ptrdiff_t m_flPhysicsForceDamage = 0x10; // float
}

namespace CSkillFloat {
    constexpr std::ptrdiff_t m_pValue = 0x0; // float[4]
}

namespace CSkillInt {
    constexpr std::ptrdiff_t m_pValue = 0x0; // int32_t[4]
}

namespace CSkyCamera { // CBaseEntity
    constexpr std::ptrdiff_t m_skyboxData = 0x4B0; // sky3dparams_t
    constexpr std::ptrdiff_t m_skyboxSlotToken = 0x540; // CUtlStringToken
    constexpr std::ptrdiff_t m_bUseAngles = 0x544; // bool
    constexpr std::ptrdiff_t m_pNext = 0x548; // CSkyCamera*
}

namespace CSkyboxReference { // CBaseEntity
    constexpr std::ptrdiff_t m_worldGroupId = 0x4B0; // WorldGroupId_t
    constexpr std::ptrdiff_t m_hSkyCamera = 0x4B4; // CHandle<CSkyCamera>
}

namespace CSmokeGrenade { // CBaseCSGrenade
}

namespace CSmokeGrenadeProjectile { // CBaseCSGrenadeProjectile
    constexpr std::ptrdiff_t m_nSmokeEffectTickBegin = 0xA58; // int32_t
    constexpr std::ptrdiff_t m_bDidSmokeEffect = 0xA5C; // bool
    constexpr std::ptrdiff_t m_nRandomSeed = 0xA60; // int32_t
    constexpr std::ptrdiff_t m_vSmokeColor = 0xA64; // Vector
    constexpr std::ptrdiff_t m_vSmokeDetonationPos = 0xA70; // Vector
    constexpr std::ptrdiff_t m_VoxelFrameData = 0xA80; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_flLastBounce = 0xA98; // GameTime_t
    constexpr std::ptrdiff_t m_fllastSimulationTime = 0xA9C; // GameTime_t
}

namespace CSmoothFunc {
    constexpr std::ptrdiff_t m_flSmoothAmplitude = 0x8; // float
    constexpr std::ptrdiff_t m_flSmoothBias = 0xC; // float
    constexpr std::ptrdiff_t m_flSmoothDuration = 0x10; // float
    constexpr std::ptrdiff_t m_flSmoothRemainingTime = 0x14; // float
    constexpr std::ptrdiff_t m_nSmoothDir = 0x18; // int32_t
}

namespace CSound {
    constexpr std::ptrdiff_t m_hOwner = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hTarget = 0x4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iVolume = 0x8; // int32_t
    constexpr std::ptrdiff_t m_flOcclusionScale = 0xC; // float
    constexpr std::ptrdiff_t m_iType = 0x10; // int32_t
    constexpr std::ptrdiff_t m_iNextAudible = 0x14; // int32_t
    constexpr std::ptrdiff_t m_flExpireTime = 0x18; // GameTime_t
    constexpr std::ptrdiff_t m_iNext = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_bNoExpirationTime = 0x1E; // bool
    constexpr std::ptrdiff_t m_ownerChannelIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_vecOrigin = 0x24; // Vector
    constexpr std::ptrdiff_t m_bHasOwner = 0x30; // bool
}

namespace CSoundAreaEntityBase { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_iszSoundAreaType = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vPos = 0x4C0; // Vector
}

namespace CSoundAreaEntityOrientedBox { // CSoundAreaEntityBase
    constexpr std::ptrdiff_t m_vMin = 0x4D0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0x4DC; // Vector
}

namespace CSoundAreaEntitySphere { // CSoundAreaEntityBase
    constexpr std::ptrdiff_t m_flRadius = 0x4D0; // float
}

namespace CSoundEnt { // CPointEntity
    constexpr std::ptrdiff_t m_iFreeSound = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iActiveSound = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_cLastActiveSounds = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_SoundPool = 0x4BC; // CSound[128]
}

namespace CSoundEnvelope {
    constexpr std::ptrdiff_t m_current = 0x0; // float
    constexpr std::ptrdiff_t m_target = 0x4; // float
    constexpr std::ptrdiff_t m_rate = 0x8; // float
    constexpr std::ptrdiff_t m_forceupdate = 0xC; // bool
}

namespace CSoundEventAABBEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_bStartOnSpawn = 0x4B0; // bool
    constexpr std::ptrdiff_t m_bToLocalPlayer = 0x4B1; // bool
    constexpr std::ptrdiff_t m_bStopOnNew = 0x4B2; // bool
    constexpr std::ptrdiff_t m_bSaveRestore = 0x4B3; // bool
    constexpr std::ptrdiff_t m_bSavedIsPlaying = 0x4B4; // bool
    constexpr std::ptrdiff_t m_flSavedElapsedTime = 0x4B8; // float
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszAttachmentName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_onGUIDChanged = 0x4D0; // CEntityOutputTemplate<uint64_t>
    constexpr std::ptrdiff_t m_onSoundFinished = 0x4F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszSoundName = 0x540; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hSource = 0x550; // CEntityHandle
}

namespace CSoundEventEntityAlias_snd_event_point { // CSoundEventEntity
}

namespace CSoundEventOBBEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_vMins = 0x558; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x564; // Vector
}

namespace CSoundEventParameter { // CBaseEntity
    constexpr std::ptrdiff_t m_iszParamName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flFloatValue = 0x4C0; // float
}

namespace CSoundEventPathCornerEntity { // CSoundEventEntity
    constexpr std::ptrdiff_t m_iszPathCorner = 0x558; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iCountMax = 0x560; // int32_t
    constexpr std::ptrdiff_t m_flDistanceMax = 0x564; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x568; // float
    constexpr std::ptrdiff_t m_flDotProductMax = 0x56C; // float
    constexpr std::ptrdiff_t bPlaying = 0x570; // bool
}

namespace CSoundOpvarSetAABBEntity { // CSoundOpvarSetPointEntity
    constexpr std::ptrdiff_t m_vDistanceInnerMins = 0x648; // Vector
    constexpr std::ptrdiff_t m_vDistanceInnerMaxs = 0x654; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMins = 0x660; // Vector
    constexpr std::ptrdiff_t m_vDistanceOuterMaxs = 0x66C; // Vector
    constexpr std::ptrdiff_t m_nAABBDirection = 0x678; // int32_t
    constexpr std::ptrdiff_t m_vInnerMins = 0x67C; // Vector
    constexpr std::ptrdiff_t m_vInnerMaxs = 0x688; // Vector
    constexpr std::ptrdiff_t m_vOuterMins = 0x694; // Vector
    constexpr std::ptrdiff_t m_vOuterMaxs = 0x6A0; // Vector
}

namespace CSoundOpvarSetEntity { // CBaseEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x4B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nOpvarType = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nOpvarIndex = 0x4D4; // int32_t
    constexpr std::ptrdiff_t m_flOpvarValue = 0x4D8; // float
    constexpr std::ptrdiff_t m_OpvarValueString = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bSetOnSpawn = 0x4E8; // bool
}

namespace CSoundOpvarSetOBBEntity { // CSoundOpvarSetAABBEntity
}

namespace CSoundOpvarSetOBBWindEntity { // CSoundOpvarSetPointBase
    constexpr std::ptrdiff_t m_vMins = 0x548; // Vector
    constexpr std::ptrdiff_t m_vMaxs = 0x554; // Vector
    constexpr std::ptrdiff_t m_vDistanceMins = 0x560; // Vector
    constexpr std::ptrdiff_t m_vDistanceMaxs = 0x56C; // Vector
    constexpr std::ptrdiff_t m_flWindMin = 0x578; // float
    constexpr std::ptrdiff_t m_flWindMax = 0x57C; // float
    constexpr std::ptrdiff_t m_flWindMapMin = 0x580; // float
    constexpr std::ptrdiff_t m_flWindMapMax = 0x584; // float
}

namespace CSoundOpvarSetPathCornerEntity { // CSoundOpvarSetPointEntity
    constexpr std::ptrdiff_t m_flDistMinSqr = 0x660; // float
    constexpr std::ptrdiff_t m_flDistMaxSqr = 0x664; // float
    constexpr std::ptrdiff_t m_iszPathCornerEntityName = 0x668; // CUtlSymbolLarge
}

namespace CSoundOpvarSetPointBase { // CBaseEntity
    constexpr std::ptrdiff_t m_bDisabled = 0x4B0; // bool
    constexpr std::ptrdiff_t m_hSource = 0x4B4; // CEntityHandle
    constexpr std::ptrdiff_t m_iszSourceEntityName = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_vLastPosition = 0x518; // Vector
    constexpr std::ptrdiff_t m_iszStackName = 0x528; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOperatorName = 0x530; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszOpvarName = 0x538; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iOpvarIndex = 0x540; // int32_t
    constexpr std::ptrdiff_t m_bUseAutoCompare = 0x544; // bool
}

namespace CSoundOpvarSetPointEntity { // CSoundOpvarSetPointBase
    constexpr std::ptrdiff_t m_OnEnter = 0x548; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnExit = 0x570; // CEntityIOOutput
    constexpr std::ptrdiff_t m_bAutoDisable = 0x598; // bool
    constexpr std::ptrdiff_t m_flDistanceMin = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDistanceMax = 0x5E0; // float
    constexpr std::ptrdiff_t m_flDistanceMapMin = 0x5E4; // float
    constexpr std::ptrdiff_t m_flDistanceMapMax = 0x5E8; // float
    constexpr std::ptrdiff_t m_flOcclusionRadius = 0x5EC; // float
    constexpr std::ptrdiff_t m_flOcclusionMin = 0x5F0; // float
    constexpr std::ptrdiff_t m_flOcclusionMax = 0x5F4; // float
    constexpr std::ptrdiff_t m_flValSetOnDisable = 0x5F8; // float
    constexpr std::ptrdiff_t m_bSetValueOnDisable = 0x5FC; // bool
    constexpr std::ptrdiff_t m_nSimulationMode = 0x600; // int32_t
    constexpr std::ptrdiff_t m_nVisibilitySamples = 0x604; // int32_t
    constexpr std::ptrdiff_t m_vDynamicProxyPoint = 0x608; // Vector
    constexpr std::ptrdiff_t m_flDynamicMaximumOcclusion = 0x614; // float
    constexpr std::ptrdiff_t m_hDynamicEntity = 0x618; // CEntityHandle
    constexpr std::ptrdiff_t m_iszDynamicEntityName = 0x620; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flPathingDistanceNormFactor = 0x628; // float
    constexpr std::ptrdiff_t m_vPathingSourcePos = 0x62C; // Vector
    constexpr std::ptrdiff_t m_vPathingListenerPos = 0x638; // Vector
    constexpr std::ptrdiff_t m_nPathingSourceIndex = 0x644; // int32_t
}

namespace CSoundPatch {
    constexpr std::ptrdiff_t m_pitch = 0x8; // CSoundEnvelope
    constexpr std::ptrdiff_t m_volume = 0x18; // CSoundEnvelope
    constexpr std::ptrdiff_t m_shutdownTime = 0x30; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x34; // float
    constexpr std::ptrdiff_t m_iszSoundScriptName = 0x38; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hEnt = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundEntityIndex = 0x44; // CEntityIndex
    constexpr std::ptrdiff_t m_soundOrigin = 0x48; // Vector
    constexpr std::ptrdiff_t m_isPlaying = 0x54; // int32_t
    constexpr std::ptrdiff_t m_Filter = 0x58; // CCopyRecipientFilter
    constexpr std::ptrdiff_t m_flCloseCaptionDuration = 0x80; // float
    constexpr std::ptrdiff_t m_bUpdatedSoundOrigin = 0x84; // bool
    constexpr std::ptrdiff_t m_iszClassName = 0x88; // CUtlSymbolLarge
}

namespace CSoundStackSave { // CLogicalEntity
    constexpr std::ptrdiff_t m_iszStackName = 0x4B0; // CUtlSymbolLarge
}

namespace CSplineConstraint { // CPhysConstraint
}

namespace CSpotlightEnd { // CBaseModelEntity
    constexpr std::ptrdiff_t m_flLightScale = 0x700; // float
    constexpr std::ptrdiff_t m_Radius = 0x704; // float
    constexpr std::ptrdiff_t m_vSpotlightDir = 0x708; // Vector
    constexpr std::ptrdiff_t m_vSpotlightOrg = 0x714; // Vector
}

namespace CSprite { // CBaseModelEntity
    constexpr std::ptrdiff_t m_hSpriteMaterial = 0x700; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_hAttachedToEntity = 0x708; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_nAttachment = 0x70C; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flSpriteFramerate = 0x710; // float
    constexpr std::ptrdiff_t m_flFrame = 0x714; // float
    constexpr std::ptrdiff_t m_flDieTime = 0x718; // GameTime_t
    constexpr std::ptrdiff_t m_nBrightness = 0x728; // uint32_t
    constexpr std::ptrdiff_t m_flBrightnessDuration = 0x72C; // float
    constexpr std::ptrdiff_t m_flSpriteScale = 0x730; // float
    constexpr std::ptrdiff_t m_flScaleDuration = 0x734; // float
    constexpr std::ptrdiff_t m_bWorldSpaceScale = 0x738; // bool
    constexpr std::ptrdiff_t m_flGlowProxySize = 0x73C; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x740; // float
    constexpr std::ptrdiff_t m_flLastTime = 0x744; // GameTime_t
    constexpr std::ptrdiff_t m_flMaxFrame = 0x748; // float
    constexpr std::ptrdiff_t m_flStartScale = 0x74C; // float
    constexpr std::ptrdiff_t m_flDestScale = 0x750; // float
    constexpr std::ptrdiff_t m_flScaleTimeStart = 0x754; // GameTime_t
    constexpr std::ptrdiff_t m_nStartBrightness = 0x758; // int32_t
    constexpr std::ptrdiff_t m_nDestBrightness = 0x75C; // int32_t
    constexpr std::ptrdiff_t m_flBrightnessTimeStart = 0x760; // GameTime_t
    constexpr std::ptrdiff_t m_nSpriteWidth = 0x764; // int32_t
    constexpr std::ptrdiff_t m_nSpriteHeight = 0x768; // int32_t
}

namespace CSpriteAlias_env_glow { // CSprite
}

namespace CSpriteOriented { // CSprite
}

namespace CStopwatch { // CStopwatchBase
    constexpr std::ptrdiff_t m_interval = 0xC; // float
}

namespace CStopwatchBase { // CSimpleSimTimer
    constexpr std::ptrdiff_t m_fIsRunning = 0x8; // bool
}

namespace CSun { // CBaseModelEntity
    constexpr std::ptrdiff_t m_vDirection = 0x700; // Vector
    constexpr std::ptrdiff_t m_clrOverlay = 0x70C; // Color
    constexpr std::ptrdiff_t m_iszEffectName = 0x710; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszSSEffectName = 0x718; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bOn = 0x720; // bool
    constexpr std::ptrdiff_t m_bmaxColor = 0x721; // bool
    constexpr std::ptrdiff_t m_flSize = 0x724; // float
    constexpr std::ptrdiff_t m_flRotation = 0x728; // float
    constexpr std::ptrdiff_t m_flHazeScale = 0x72C; // float
    constexpr std::ptrdiff_t m_flAlphaHaze = 0x730; // float
    constexpr std::ptrdiff_t m_flAlphaHdr = 0x734; // float
    constexpr std::ptrdiff_t m_flAlphaScale = 0x738; // float
    constexpr std::ptrdiff_t m_flHDRColorScale = 0x73C; // float
    constexpr std::ptrdiff_t m_flFarZScale = 0x740; // float
}

namespace CTablet { // CCSWeaponBase
}

namespace CTakeDamageInfo {
    constexpr std::ptrdiff_t m_vecDamageForce = 0x8; // Vector
    constexpr std::ptrdiff_t m_vecDamagePosition = 0x14; // Vector
    constexpr std::ptrdiff_t m_vecReportedPosition = 0x20; // Vector
    constexpr std::ptrdiff_t m_vecDamageDirection = 0x2C; // Vector
    constexpr std::ptrdiff_t m_hInflictor = 0x38; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAttacker = 0x3C; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_hAbility = 0x40; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flDamage = 0x44; // float
    constexpr std::ptrdiff_t m_bitsDamageType = 0x48; // int32_t
    constexpr std::ptrdiff_t m_iDamageCustom = 0x4C; // int32_t
    constexpr std::ptrdiff_t m_iAmmoType = 0x50; // AmmoIndex_t
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x60; // float
    constexpr std::ptrdiff_t m_bShouldBleed = 0x64; // bool
    constexpr std::ptrdiff_t m_bShouldSpark = 0x65; // bool
    constexpr std::ptrdiff_t m_nDamageFlags = 0x70; // TakeDamageFlags_t
    constexpr std::ptrdiff_t m_nNumObjectsPenetrated = 0x74; // int32_t
    constexpr std::ptrdiff_t m_hScriptInstance = 0x78; // HSCRIPT
    constexpr std::ptrdiff_t m_bInTakeDamageFlow = 0x94; // bool
}

namespace CTakeDamageResult {
    constexpr std::ptrdiff_t m_nHealthLost = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nDamageTaken = 0x4; // int32_t
}

namespace CTakeDamageSummaryScopeGuard {
    constexpr std::ptrdiff_t m_vecSummaries = 0x8; // CUtlVector<SummaryTakeDamageInfo_t*>
}

namespace CTankTargetChange { // CPointEntity
    constexpr std::ptrdiff_t m_newTarget = 0x4B0; // CVariantBase<CVariantDefaultAllocator>
    constexpr std::ptrdiff_t m_newTargetName = 0x4C0; // CUtlSymbolLarge
}

namespace CTankTrainAI { // CPointEntity
    constexpr std::ptrdiff_t m_hTrain = 0x4B0; // CHandle<CFuncTrackTrain>
    constexpr std::ptrdiff_t m_hTargetEntity = 0x4B4; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_soundPlaying = 0x4B8; // int32_t
    constexpr std::ptrdiff_t m_startSoundName = 0x4D0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_engineSoundName = 0x4D8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_movementSoundName = 0x4E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_targetEntityName = 0x4E8; // CUtlSymbolLarge
}

namespace CTeam { // CBaseEntity
    constexpr std::ptrdiff_t m_aPlayerControllers = 0x4B0; // CNetworkUtlVectorBase<CHandle<CBasePlayerController>>
    constexpr std::ptrdiff_t m_aPlayers = 0x4C8; // CNetworkUtlVectorBase<CHandle<CBasePlayerPawn>>
    constexpr std::ptrdiff_t m_iScore = 0x4E0; // int32_t
    constexpr std::ptrdiff_t m_szTeamname = 0x4E4; // char[129]
}

namespace CTeamplayRules { // CMultiplayRules
}

namespace CTestEffect { // CBaseEntity
    constexpr std::ptrdiff_t m_iLoop = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iBeam = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_pBeam = 0x4B8; // CBeam*[24]
    constexpr std::ptrdiff_t m_flBeamTime = 0x578; // GameTime_t[24]
    constexpr std::ptrdiff_t m_flStartTime = 0x5D8; // GameTime_t
}

namespace CTextureBasedAnimatable { // CBaseModelEntity
    constexpr std::ptrdiff_t m_bLoop = 0x700; // bool
    constexpr std::ptrdiff_t m_flFPS = 0x704; // float
    constexpr std::ptrdiff_t m_hPositionKeys = 0x708; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_hRotationKeys = 0x710; // CStrongHandle<InfoForResourceTypeCTextureBase>
    constexpr std::ptrdiff_t m_vAnimationBoundsMin = 0x718; // Vector
    constexpr std::ptrdiff_t m_vAnimationBoundsMax = 0x724; // Vector
    constexpr std::ptrdiff_t m_flStartTime = 0x730; // float
    constexpr std::ptrdiff_t m_flStartFrame = 0x734; // float
}

namespace CTimeline { // IntervalTimer
    constexpr std::ptrdiff_t m_flValues = 0x10; // float[64]
    constexpr std::ptrdiff_t m_nValueCounts = 0x110; // int32_t[64]
    constexpr std::ptrdiff_t m_nBucketCount = 0x210; // int32_t
    constexpr std::ptrdiff_t m_flInterval = 0x214; // float
    constexpr std::ptrdiff_t m_flFinalValue = 0x218; // float
    constexpr std::ptrdiff_t m_nCompressionType = 0x21C; // TimelineCompression_t
    constexpr std::ptrdiff_t m_bStopped = 0x220; // bool
}

namespace CTimerEntity { // CLogicalEntity
    constexpr std::ptrdiff_t m_OnTimer = 0x4B0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerHigh = 0x4D8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnTimerLow = 0x500; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iDisabled = 0x528; // int32_t
    constexpr std::ptrdiff_t m_flInitialDelay = 0x52C; // float
    constexpr std::ptrdiff_t m_flRefireTime = 0x530; // float
    constexpr std::ptrdiff_t m_bUpDownState = 0x534; // bool
    constexpr std::ptrdiff_t m_iUseRandomTime = 0x538; // int32_t
    constexpr std::ptrdiff_t m_bPauseAfterFiring = 0x53C; // bool
    constexpr std::ptrdiff_t m_flLowerRandomBound = 0x540; // float
    constexpr std::ptrdiff_t m_flUpperRandomBound = 0x544; // float
    constexpr std::ptrdiff_t m_flRemainingTime = 0x548; // float
    constexpr std::ptrdiff_t m_bPaused = 0x54C; // bool
}

namespace CTonemapController2 { // CBaseEntity
    constexpr std::ptrdiff_t m_flAutoExposureMin = 0x4B0; // float
    constexpr std::ptrdiff_t m_flAutoExposureMax = 0x4B4; // float
    constexpr std::ptrdiff_t m_flTonemapPercentTarget = 0x4B8; // float
    constexpr std::ptrdiff_t m_flTonemapPercentBrightPixels = 0x4BC; // float
    constexpr std::ptrdiff_t m_flTonemapMinAvgLum = 0x4C0; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedUp = 0x4C4; // float
    constexpr std::ptrdiff_t m_flExposureAdaptationSpeedDown = 0x4C8; // float
    constexpr std::ptrdiff_t m_flTonemapEVSmoothingRange = 0x4CC; // float
}

namespace CTonemapController2Alias_env_tonemap_controller2 { // CTonemapController2
}

namespace CTonemapTrigger { // CBaseTrigger
    constexpr std::ptrdiff_t m_tonemapControllerName = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hTonemapController = 0x8B0; // CEntityHandle
}

namespace CTouchExpansionComponent { // CEntityComponent
}

namespace CTriggerActiveWeaponDetect { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnTouchedActiveWeapon = 0x8A8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iszWeaponClassName = 0x8D0; // CUtlSymbolLarge
}

namespace CTriggerBombReset { // CBaseTrigger
}

namespace CTriggerBrush { // CBaseModelEntity
    constexpr std::ptrdiff_t m_OnStartTouch = 0x700; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndTouch = 0x728; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnUse = 0x750; // CEntityIOOutput
    constexpr std::ptrdiff_t m_iInputFilter = 0x778; // int32_t
    constexpr std::ptrdiff_t m_iDontMessageParent = 0x77C; // int32_t
}

namespace CTriggerBuoyancy { // CBaseTrigger
    constexpr std::ptrdiff_t m_BuoyancyHelper = 0x8A8; // CBuoyancyHelper
    constexpr std::ptrdiff_t m_flFluidDensity = 0x8C8; // float
}

namespace CTriggerCallback { // CBaseTrigger
}

namespace CTriggerDetectBulletFire { // CBaseTrigger
    constexpr std::ptrdiff_t m_bPlayerFireOnly = 0x8A8; // bool
    constexpr std::ptrdiff_t m_OnDetectedBulletFire = 0x8B0; // CEntityIOOutput
}

namespace CTriggerDetectExplosion { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnDetectedExplosion = 0x8E0; // CEntityIOOutput
}

namespace CTriggerFan { // CBaseTrigger
    constexpr std::ptrdiff_t m_vFanOrigin = 0x8A8; // Vector
    constexpr std::ptrdiff_t m_vFanEnd = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_vNoise = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flPlayerForce = 0x8D0; // float
    constexpr std::ptrdiff_t m_flRampTime = 0x8D4; // float
    constexpr std::ptrdiff_t m_bFalloff = 0x8D8; // bool
    constexpr std::ptrdiff_t m_bPushPlayer = 0x8D9; // bool
    constexpr std::ptrdiff_t m_bRampDown = 0x8DA; // bool
    constexpr std::ptrdiff_t m_bAddNoise = 0x8DB; // bool
    constexpr std::ptrdiff_t m_RampTimer = 0x8E0; // CountdownTimer
}

namespace CTriggerGameEvent { // CBaseTrigger
    constexpr std::ptrdiff_t m_strStartTouchEventName = 0x8A8; // CUtlString
    constexpr std::ptrdiff_t m_strEndTouchEventName = 0x8B0; // CUtlString
    constexpr std::ptrdiff_t m_strTriggerID = 0x8B8; // CUtlString
}

namespace CTriggerGravity { // CBaseTrigger
}

namespace CTriggerHostageReset { // CBaseTrigger
}

namespace CTriggerHurt { // CBaseTrigger
    constexpr std::ptrdiff_t m_flOriginalDamage = 0x8A8; // float
    constexpr std::ptrdiff_t m_flDamage = 0x8AC; // float
    constexpr std::ptrdiff_t m_flDamageCap = 0x8B0; // float
    constexpr std::ptrdiff_t m_flLastDmgTime = 0x8B4; // GameTime_t
    constexpr std::ptrdiff_t m_flForgivenessDelay = 0x8B8; // float
    constexpr std::ptrdiff_t m_bitsDamageInflict = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_damageModel = 0x8C0; // int32_t
    constexpr std::ptrdiff_t m_bNoDmgForce = 0x8C4; // bool
    constexpr std::ptrdiff_t m_vDamageForce = 0x8C8; // Vector
    constexpr std::ptrdiff_t m_thinkAlways = 0x8D4; // bool
    constexpr std::ptrdiff_t m_hurtThinkPeriod = 0x8D8; // float
    constexpr std::ptrdiff_t m_OnHurt = 0x8E0; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnHurtPlayer = 0x908; // CEntityIOOutput
    constexpr std::ptrdiff_t m_hurtEntities = 0x930; // CUtlVector<CHandle<CBaseEntity>>
}

namespace CTriggerHurtGhost { // CTriggerHurt
}

namespace CTriggerImpact { // CTriggerMultiple
    constexpr std::ptrdiff_t m_flMagnitude = 0x8D0; // float
    constexpr std::ptrdiff_t m_flNoise = 0x8D4; // float
    constexpr std::ptrdiff_t m_flViewkick = 0x8D8; // float
    constexpr std::ptrdiff_t m_pOutputForce = 0x8E0; // CEntityOutputTemplate<Vector>
}

namespace CTriggerLerpObject { // CBaseTrigger
    constexpr std::ptrdiff_t m_iszLerpTarget = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTarget = 0x8B0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszLerpTargetAttachment = 0x8B8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hLerpTargetAttachment = 0x8C0; // AttachmentHandle_t
    constexpr std::ptrdiff_t m_flLerpDuration = 0x8C4; // float
    constexpr std::ptrdiff_t m_bLerpRestoreMoveType = 0x8C8; // bool
    constexpr std::ptrdiff_t m_bSingleLerpObject = 0x8C9; // bool
    constexpr std::ptrdiff_t m_vecLerpingObjects = 0x8D0; // CUtlVector<lerpdata_t>
    constexpr std::ptrdiff_t m_iszLerpEffect = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszLerpSound = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_OnLerpStarted = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnLerpFinished = 0x920; // CEntityIOOutput
}

namespace CTriggerLook { // CTriggerOnce
    constexpr std::ptrdiff_t m_hLookTarget = 0x8D0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_flFieldOfView = 0x8D4; // float
    constexpr std::ptrdiff_t m_flLookTime = 0x8D8; // float
    constexpr std::ptrdiff_t m_flLookTimeTotal = 0x8DC; // float
    constexpr std::ptrdiff_t m_flLookTimeLast = 0x8E0; // GameTime_t
    constexpr std::ptrdiff_t m_flTimeoutDuration = 0x8E4; // float
    constexpr std::ptrdiff_t m_bTimeoutFired = 0x8E8; // bool
    constexpr std::ptrdiff_t m_bIsLooking = 0x8E9; // bool
    constexpr std::ptrdiff_t m_b2DFOV = 0x8EA; // bool
    constexpr std::ptrdiff_t m_bUseVelocity = 0x8EB; // bool
    constexpr std::ptrdiff_t m_hActivator = 0x8EC; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_bTestOcclusion = 0x8F0; // bool
    constexpr std::ptrdiff_t m_OnTimeout = 0x8F8; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnStartLook = 0x920; // CEntityIOOutput
    constexpr std::ptrdiff_t m_OnEndLook = 0x948; // CEntityIOOutput
}

namespace CTriggerMultiple { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnTrigger = 0x8A8; // CEntityIOOutput
}

namespace CTriggerOnce { // CTriggerMultiple
}

namespace CTriggerPhysics { // CBaseTrigger
    constexpr std::ptrdiff_t m_gravityScale = 0x8B8; // float
    constexpr std::ptrdiff_t m_linearLimit = 0x8BC; // float
    constexpr std::ptrdiff_t m_linearDamping = 0x8C0; // float
    constexpr std::ptrdiff_t m_angularLimit = 0x8C4; // float
    constexpr std::ptrdiff_t m_angularDamping = 0x8C8; // float
    constexpr std::ptrdiff_t m_linearForce = 0x8CC; // float
    constexpr std::ptrdiff_t m_flFrequency = 0x8D0; // float
    constexpr std::ptrdiff_t m_flDampingRatio = 0x8D4; // float
    constexpr std::ptrdiff_t m_vecLinearForcePointAt = 0x8D8; // Vector
    constexpr std::ptrdiff_t m_bCollapseToForcePoint = 0x8E4; // bool
    constexpr std::ptrdiff_t m_vecLinearForcePointAtWorld = 0x8E8; // Vector
    constexpr std::ptrdiff_t m_vecLinearForceDirection = 0x8F4; // Vector
    constexpr std::ptrdiff_t m_bConvertToDebrisWhenPossible = 0x900; // bool
}

namespace CTriggerProximity { // CBaseTrigger
    constexpr std::ptrdiff_t m_hMeasureTarget = 0x8A8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_iszMeasureTarget = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fRadius = 0x8B8; // float
    constexpr std::ptrdiff_t m_nTouchers = 0x8BC; // int32_t
    constexpr std::ptrdiff_t m_NearestEntityDistance = 0x8C0; // CEntityOutputTemplate<float>
}

namespace CTriggerPush { // CBaseTrigger
    constexpr std::ptrdiff_t m_angPushEntitySpace = 0x8A8; // QAngle
    constexpr std::ptrdiff_t m_vecPushDirEntitySpace = 0x8B4; // Vector
    constexpr std::ptrdiff_t m_bTriggerOnStartTouch = 0x8C0; // bool
    constexpr std::ptrdiff_t m_flAlternateTicksFix = 0x8C4; // float
    constexpr std::ptrdiff_t m_flPushSpeed = 0x8C8; // float
}

namespace CTriggerRemove { // CBaseTrigger
    constexpr std::ptrdiff_t m_OnRemove = 0x8A8; // CEntityIOOutput
}

namespace CTriggerSave { // CBaseTrigger
    constexpr std::ptrdiff_t m_bForceNewLevelUnit = 0x8A8; // bool
    constexpr std::ptrdiff_t m_fDangerousTimer = 0x8AC; // float
    constexpr std::ptrdiff_t m_minHitPoints = 0x8B0; // int32_t
}

namespace CTriggerSndSosOpvar { // CBaseTrigger
    constexpr std::ptrdiff_t m_hTouchingPlayers = 0x8A8; // CUtlVector<CHandle<CBaseEntity>>
    constexpr std::ptrdiff_t m_flPosition = 0x8C0; // Vector
    constexpr std::ptrdiff_t m_flCenterSize = 0x8CC; // float
    constexpr std::ptrdiff_t m_flMinVal = 0x8D0; // float
    constexpr std::ptrdiff_t m_flMaxVal = 0x8D4; // float
    constexpr std::ptrdiff_t m_flWait = 0x8D8; // float
    constexpr std::ptrdiff_t m_opvarName = 0x8E0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_stackName = 0x8E8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_operatorName = 0x8F0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bVolIs2D = 0x8F8; // bool
    constexpr std::ptrdiff_t m_opvarNameChar = 0x8F9; // char[256]
    constexpr std::ptrdiff_t m_stackNameChar = 0x9F9; // char[256]
    constexpr std::ptrdiff_t m_operatorNameChar = 0xAF9; // char[256]
    constexpr std::ptrdiff_t m_VecNormPos = 0xBFC; // Vector
    constexpr std::ptrdiff_t m_flNormCenterSize = 0xC08; // float
}

namespace CTriggerSoundscape { // CBaseTrigger
    constexpr std::ptrdiff_t m_hSoundscape = 0x8A8; // CHandle<CEnvSoundscapeTriggerable>
    constexpr std::ptrdiff_t m_SoundscapeName = 0x8B0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_spectators = 0x8B8; // CUtlVector<CHandle<CBasePlayerPawn>>
}

namespace CTriggerTeleport { // CBaseTrigger
    constexpr std::ptrdiff_t m_iLandmark = 0x8A8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_bUseLandmarkAngles = 0x8B0; // bool
    constexpr std::ptrdiff_t m_bMirrorPlayer = 0x8B1; // bool
}

namespace CTriggerToggleSave { // CBaseTrigger
    constexpr std::ptrdiff_t m_bDisabled = 0x8A8; // bool
}

namespace CTriggerTripWire { // CBaseTrigger
}

namespace CTriggerVolume { // CBaseModelEntity
    constexpr std::ptrdiff_t m_iFilterName = 0x700; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_hFilter = 0x708; // CHandle<CBaseFilter>
}

namespace CTripWireFire { // CBaseCSGrenade
}

namespace CTripWireFireProjectile { // CBaseGrenade
}

namespace CVoteController { // CBaseEntity
    constexpr std::ptrdiff_t m_iActiveIssueIndex = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_iOnlyTeamToVote = 0x4B4; // int32_t
    constexpr std::ptrdiff_t m_nVoteOptionCount = 0x4B8; // int32_t[5]
    constexpr std::ptrdiff_t m_nPotentialVotes = 0x4CC; // int32_t
    constexpr std::ptrdiff_t m_bIsYesNoVote = 0x4D0; // bool
    constexpr std::ptrdiff_t m_acceptingVotesTimer = 0x4D8; // CountdownTimer
    constexpr std::ptrdiff_t m_executeCommandTimer = 0x4F0; // CountdownTimer
    constexpr std::ptrdiff_t m_resetVoteTimer = 0x508; // CountdownTimer
    constexpr std::ptrdiff_t m_nVotesCast = 0x520; // int32_t[64]
    constexpr std::ptrdiff_t m_playerHoldingVote = 0x620; // CPlayerSlot
    constexpr std::ptrdiff_t m_playerOverrideForVote = 0x624; // CPlayerSlot
    constexpr std::ptrdiff_t m_nHighestCountIndex = 0x628; // int32_t
    constexpr std::ptrdiff_t m_potentialIssues = 0x630; // CUtlVector<CBaseIssue*>
    constexpr std::ptrdiff_t m_VoteOptions = 0x648; // CUtlVector<char*>
}

namespace CWaterBullet { // CBaseAnimGraph
}

namespace CWeaponAWP { // CCSWeaponBaseGun
}

namespace CWeaponAug { // CCSWeaponBaseGun
}

namespace CWeaponBaseItem { // CCSWeaponBase
    constexpr std::ptrdiff_t m_SequenceCompleteTimer = 0xE20; // CountdownTimer
    constexpr std::ptrdiff_t m_bRedraw = 0xE38; // bool
}

namespace CWeaponBizon { // CCSWeaponBaseGun
}

namespace CWeaponCZ75a { // CCSWeaponBaseGun
}

namespace CWeaponElite { // CCSWeaponBaseGun
}

namespace CWeaponFamas { // CCSWeaponBaseGun
}

namespace CWeaponFiveSeven { // CCSWeaponBaseGun
}

namespace CWeaponG3SG1 { // CCSWeaponBaseGun
}

namespace CWeaponGalilAR { // CCSWeaponBaseGun
}

namespace CWeaponGlock { // CCSWeaponBaseGun
}

namespace CWeaponHKP2000 { // CCSWeaponBaseGun
}

namespace CWeaponM249 { // CCSWeaponBaseGun
}

namespace CWeaponM4A1 { // CCSWeaponBaseGun
}

namespace CWeaponM4A1Silencer { // CCSWeaponBaseGun
}

namespace CWeaponMAC10 { // CCSWeaponBaseGun
}

namespace CWeaponMP5SD { // CCSWeaponBaseGun
}

namespace CWeaponMP7 { // CCSWeaponBaseGun
}

namespace CWeaponMP9 { // CCSWeaponBaseGun
}

namespace CWeaponMag7 { // CCSWeaponBaseGun
}

namespace CWeaponNOVA { // CCSWeaponBase
}

namespace CWeaponNegev { // CCSWeaponBaseGun
}

namespace CWeaponP250 { // CCSWeaponBaseGun
}

namespace CWeaponP90 { // CCSWeaponBaseGun
}

namespace CWeaponRevolver { // CCSWeaponBaseGun
}

namespace CWeaponSCAR20 { // CCSWeaponBaseGun
}

namespace CWeaponSG556 { // CCSWeaponBaseGun
}

namespace CWeaponSSG08 { // CCSWeaponBaseGun
}

namespace CWeaponSawedoff { // CCSWeaponBase
}

namespace CWeaponShield { // CCSWeaponBaseGun
    constexpr std::ptrdiff_t m_flBulletDamageAbsorbed = 0xE40; // float
    constexpr std::ptrdiff_t m_flLastBulletHitSoundTime = 0xE44; // GameTime_t
    constexpr std::ptrdiff_t m_flDisplayHealth = 0xE48; // float
}

namespace CWeaponTaser { // CCSWeaponBaseGun
    constexpr std::ptrdiff_t m_fFireTime = 0xE40; // GameTime_t
}

namespace CWeaponTec9 { // CCSWeaponBaseGun
}

namespace CWeaponUMP45 { // CCSWeaponBaseGun
}

namespace CWeaponUSPSilencer { // CCSWeaponBaseGun
}

namespace CWeaponXM1014 { // CCSWeaponBase
}

namespace CWeaponZoneRepulsor { // CCSWeaponBaseGun
}

namespace CWorld { // CBaseModelEntity
}

namespace CommandToolCommand_t {
    constexpr std::ptrdiff_t m_bEnabled = 0x0; // bool
    constexpr std::ptrdiff_t m_bOpened = 0x1; // bool
    constexpr std::ptrdiff_t m_InternalId = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_ShortName = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_ExecMode = 0x10; // CommandExecMode_t
    constexpr std::ptrdiff_t m_SpawnGroup = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_PeriodicExecDelay = 0x20; // float
    constexpr std::ptrdiff_t m_SpecType = 0x24; // CommandEntitySpecType_t
    constexpr std::ptrdiff_t m_EntitySpec = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_Commands = 0x30; // CUtlString
    constexpr std::ptrdiff_t m_SetDebugBits = 0x38; // DebugOverlayBits_t
    constexpr std::ptrdiff_t m_ClearDebugBits = 0x40; // DebugOverlayBits_t
}

namespace ConceptHistory_t {
    constexpr std::ptrdiff_t timeSpoken = 0x0; // float
    constexpr std::ptrdiff_t m_response = 0x8; // CRR_Response
}

namespace ConstraintSoundInfo {
    constexpr std::ptrdiff_t m_vSampler = 0x8; // VelocitySampler
    constexpr std::ptrdiff_t m_soundProfile = 0x20; // SimpleConstraintSoundProfile
    constexpr std::ptrdiff_t m_forwardAxis = 0x40; // Vector
    constexpr std::ptrdiff_t m_iszTravelSoundFwd = 0x50; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszTravelSoundBack = 0x58; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszReversalSounds = 0x68; // CUtlSymbolLarge[3]
    constexpr std::ptrdiff_t m_bPlayTravelSound = 0x80; // bool
    constexpr std::ptrdiff_t m_bPlayReversalSound = 0x81; // bool
}

namespace CountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
    constexpr std::ptrdiff_t m_nWorldGroupId = 0x14; // WorldGroupId_t
}

namespace EngineCountdownTimer {
    constexpr std::ptrdiff_t m_duration = 0x8; // float
    constexpr std::ptrdiff_t m_timestamp = 0xC; // float
    constexpr std::ptrdiff_t m_timescale = 0x10; // float
}

namespace EntityRenderAttribute_t {
    constexpr std::ptrdiff_t m_ID = 0x30; // CUtlStringToken
    constexpr std::ptrdiff_t m_Values = 0x34; // Vector4D
}

namespace EntitySpottedState_t {
    constexpr std::ptrdiff_t m_bSpotted = 0x8; // bool
    constexpr std::ptrdiff_t m_bSpottedByMask = 0xC; // uint32_t[2]
}

namespace Extent {
    constexpr std::ptrdiff_t lo = 0x0; // Vector
    constexpr std::ptrdiff_t hi = 0xC; // Vector
}

namespace FilterDamageType { // CBaseFilter
    constexpr std::ptrdiff_t m_iDamageType = 0x508; // int32_t
}

namespace FilterHealth { // CBaseFilter
    constexpr std::ptrdiff_t m_bAdrenalineActive = 0x508; // bool
    constexpr std::ptrdiff_t m_iHealthMin = 0x50C; // int32_t
    constexpr std::ptrdiff_t m_iHealthMax = 0x510; // int32_t
}

namespace FilterTeam { // CBaseFilter
    constexpr std::ptrdiff_t m_iFilterTeam = 0x508; // int32_t
}

namespace GameAmmoTypeInfo_t { // AmmoTypeInfo_t
    constexpr std::ptrdiff_t m_nBuySize = 0x38; // int32_t
    constexpr std::ptrdiff_t m_nCost = 0x3C; // int32_t
}

namespace GameTick_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace GameTime_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // float
}

namespace HullFlags_t {
    constexpr std::ptrdiff_t m_bHull_Human = 0x0; // bool
    constexpr std::ptrdiff_t m_bHull_SmallCentered = 0x1; // bool
    constexpr std::ptrdiff_t m_bHull_WideHuman = 0x2; // bool
    constexpr std::ptrdiff_t m_bHull_Tiny = 0x3; // bool
    constexpr std::ptrdiff_t m_bHull_Medium = 0x4; // bool
    constexpr std::ptrdiff_t m_bHull_TinyCentered = 0x5; // bool
    constexpr std::ptrdiff_t m_bHull_Large = 0x6; // bool
    constexpr std::ptrdiff_t m_bHull_LargeCentered = 0x7; // bool
    constexpr std::ptrdiff_t m_bHull_MediumTall = 0x8; // bool
    constexpr std::ptrdiff_t m_bHull_Small = 0x9; // bool
}

namespace IChoreoServices {
}

namespace IEconItemInterface {
}

namespace IHasAttributes {
}

namespace IRagdoll {
}

namespace ISkeletonAnimationController {
}

namespace IVehicle {
}

namespace IntervalTimer {
    constexpr std::ptrdiff_t m_timestamp = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_nWorldGroupId = 0xC; // WorldGroupId_t
}

namespace ModelConfigHandle_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // uint32_t
}

namespace ParticleIndex_t {
    constexpr std::ptrdiff_t m_Value = 0x0; // int32_t
}

namespace PhysicsRagdollPose_t {
    constexpr std::ptrdiff_t __m_pChainEntity = 0x8; // CNetworkVarChainer
    constexpr std::ptrdiff_t m_Transforms = 0x30; // CNetworkUtlVectorBase<CTransform>
    constexpr std::ptrdiff_t m_hOwner = 0x48; // CHandle<CBaseEntity>
}

namespace QuestProgress {
}

namespace RagdollCreationParams_t {
    constexpr std::ptrdiff_t m_vForce = 0x0; // Vector
    constexpr std::ptrdiff_t m_nForceBone = 0xC; // int32_t
}

namespace RelationshipOverride_t { // Relationship_t
    constexpr std::ptrdiff_t entity = 0x8; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t classType = 0xC; // Class_T
}

namespace Relationship_t {
    constexpr std::ptrdiff_t disposition = 0x0; // Disposition_t
    constexpr std::ptrdiff_t priority = 0x4; // int32_t
}

namespace ResponseContext_t {
    constexpr std::ptrdiff_t m_iszName = 0x0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_iszValue = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_fExpirationTime = 0x10; // GameTime_t
}

namespace ResponseFollowup {
    constexpr std::ptrdiff_t followup_concept = 0x0; // char*
    constexpr std::ptrdiff_t followup_contexts = 0x8; // char*
    constexpr std::ptrdiff_t followup_delay = 0x10; // float
    constexpr std::ptrdiff_t followup_target = 0x14; // char*
    constexpr std::ptrdiff_t followup_entityiotarget = 0x1C; // char*
    constexpr std::ptrdiff_t followup_entityioinput = 0x24; // char*
    constexpr std::ptrdiff_t followup_entityiodelay = 0x2C; // float
    constexpr std::ptrdiff_t bFired = 0x30; // bool
}

namespace ResponseParams {
    constexpr std::ptrdiff_t odds = 0x10; // int16_t
    constexpr std::ptrdiff_t flags = 0x12; // int16_t
    constexpr std::ptrdiff_t m_pFollowup = 0x18; // ResponseFollowup*
}

namespace SellbackPurchaseEntry_t {
    constexpr std::ptrdiff_t m_unDefIdx = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCost = 0x34; // int32_t
    constexpr std::ptrdiff_t m_nPrevArmor = 0x38; // int32_t
    constexpr std::ptrdiff_t m_bPrevHelmet = 0x3C; // bool
    constexpr std::ptrdiff_t m_hItem = 0x40; // CEntityHandle
}

namespace ServerAuthoritativeWeaponSlot_t {
    constexpr std::ptrdiff_t unClass = 0x28; // uint16_t
    constexpr std::ptrdiff_t unSlot = 0x2A; // uint16_t
    constexpr std::ptrdiff_t unItemDefIdx = 0x2C; // uint16_t
}

namespace SimpleConstraintSoundProfile {
    constexpr std::ptrdiff_t eKeypoints = 0x8; // SimpleConstraintSoundProfile::SimpleConstraintsSoundProfileKeypoints_t
    constexpr std::ptrdiff_t m_keyPoints = 0xC; // float[2]
    constexpr std::ptrdiff_t m_reversalSoundThresholds = 0x14; // float[3]
}

namespace SpawnPoint { // CServerOnlyPointEntity
    constexpr std::ptrdiff_t m_iPriority = 0x4B0; // int32_t
    constexpr std::ptrdiff_t m_bEnabled = 0x4B4; // bool
    constexpr std::ptrdiff_t m_nType = 0x4B8; // int32_t
}

namespace SpawnPointCoopEnemy { // SpawnPoint
    constexpr std::ptrdiff_t m_szWeaponsToGive = 0x4C0; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_szPlayerModelToUse = 0x4C8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_nArmorToSpawnWith = 0x4D0; // int32_t
    constexpr std::ptrdiff_t m_nDefaultBehavior = 0x4D4; // SpawnPointCoopEnemy::BotDefaultBehavior_t
    constexpr std::ptrdiff_t m_nBotDifficulty = 0x4D8; // int32_t
    constexpr std::ptrdiff_t m_bIsAgressive = 0x4DC; // bool
    constexpr std::ptrdiff_t m_bStartAsleep = 0x4DD; // bool
    constexpr std::ptrdiff_t m_flHideRadius = 0x4E0; // float
    constexpr std::ptrdiff_t m_szBehaviorTreeFile = 0x4F0; // CUtlSymbolLarge
}

namespace SummaryTakeDamageInfo_t {
    constexpr std::ptrdiff_t nSummarisedCount = 0x0; // int32_t
    constexpr std::ptrdiff_t info = 0x8; // CTakeDamageInfo
    constexpr std::ptrdiff_t result = 0xA0; // CTakeDamageResult
    constexpr std::ptrdiff_t hTarget = 0xA8; // CHandle<CBaseEntity>
}

namespace VPhysicsCollisionAttribute_t {
    constexpr std::ptrdiff_t m_nInteractsAs = 0x8; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsWith = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nInteractsExclude = 0x18; // uint64_t
    constexpr std::ptrdiff_t m_nEntityId = 0x20; // uint32_t
    constexpr std::ptrdiff_t m_nOwnerId = 0x24; // uint32_t
    constexpr std::ptrdiff_t m_nHierarchyId = 0x28; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionGroup = 0x2A; // uint8_t
    constexpr std::ptrdiff_t m_nCollisionFunctionMask = 0x2B; // uint8_t
}

namespace VelocitySampler {
    constexpr std::ptrdiff_t m_prevSample = 0x0; // Vector
    constexpr std::ptrdiff_t m_fPrevSampleTime = 0xC; // GameTime_t
    constexpr std::ptrdiff_t m_fIdealSampleRate = 0x10; // float
}

namespace ViewAngleServerChange_t {
    constexpr std::ptrdiff_t nType = 0x30; // FixAngleSet_t
    constexpr std::ptrdiff_t qAngle = 0x34; // QAngle
    constexpr std::ptrdiff_t nIndex = 0x40; // uint32_t
}

namespace WeaponPurchaseCount_t {
    constexpr std::ptrdiff_t m_nItemDefIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t m_nCount = 0x32; // uint16_t
}

namespace WeaponPurchaseTracker_t {
    constexpr std::ptrdiff_t m_weaponPurchases = 0x8; // CUtlVectorEmbeddedNetworkVar<WeaponPurchaseCount_t>
}

namespace audioparams_t {
    constexpr std::ptrdiff_t localSound = 0x8; // Vector[8]
    constexpr std::ptrdiff_t soundscapeIndex = 0x68; // int32_t
    constexpr std::ptrdiff_t localBits = 0x6C; // uint8_t
    constexpr std::ptrdiff_t soundscapeEntityListIndex = 0x70; // int32_t
    constexpr std::ptrdiff_t soundEventHash = 0x74; // uint32_t
}

namespace dynpitchvol_base_t {
    constexpr std::ptrdiff_t preset = 0x0; // int32_t
    constexpr std::ptrdiff_t pitchrun = 0x4; // int32_t
    constexpr std::ptrdiff_t pitchstart = 0x8; // int32_t
    constexpr std::ptrdiff_t spinup = 0xC; // int32_t
    constexpr std::ptrdiff_t spindown = 0x10; // int32_t
    constexpr std::ptrdiff_t volrun = 0x14; // int32_t
    constexpr std::ptrdiff_t volstart = 0x18; // int32_t
    constexpr std::ptrdiff_t fadein = 0x1C; // int32_t
    constexpr std::ptrdiff_t fadeout = 0x20; // int32_t
    constexpr std::ptrdiff_t lfotype = 0x24; // int32_t
    constexpr std::ptrdiff_t lforate = 0x28; // int32_t
    constexpr std::ptrdiff_t lfomodpitch = 0x2C; // int32_t
    constexpr std::ptrdiff_t lfomodvol = 0x30; // int32_t
    constexpr std::ptrdiff_t cspinup = 0x34; // int32_t
    constexpr std::ptrdiff_t cspincount = 0x38; // int32_t
    constexpr std::ptrdiff_t pitch = 0x3C; // int32_t
    constexpr std::ptrdiff_t spinupsav = 0x40; // int32_t
    constexpr std::ptrdiff_t spindownsav = 0x44; // int32_t
    constexpr std::ptrdiff_t pitchfrac = 0x48; // int32_t
    constexpr std::ptrdiff_t vol = 0x4C; // int32_t
    constexpr std::ptrdiff_t fadeinsav = 0x50; // int32_t
    constexpr std::ptrdiff_t fadeoutsav = 0x54; // int32_t
    constexpr std::ptrdiff_t volfrac = 0x58; // int32_t
    constexpr std::ptrdiff_t lfofrac = 0x5C; // int32_t
    constexpr std::ptrdiff_t lfomult = 0x60; // int32_t
}

namespace dynpitchvol_t { // dynpitchvol_base_t
}

namespace fogparams_t {
    constexpr std::ptrdiff_t dirPrimary = 0x8; // Vector
    constexpr std::ptrdiff_t colorPrimary = 0x14; // Color
    constexpr std::ptrdiff_t colorSecondary = 0x18; // Color
    constexpr std::ptrdiff_t colorPrimaryLerpTo = 0x1C; // Color
    constexpr std::ptrdiff_t colorSecondaryLerpTo = 0x20; // Color
    constexpr std::ptrdiff_t start = 0x24; // float
    constexpr std::ptrdiff_t end = 0x28; // float
    constexpr std::ptrdiff_t farz = 0x2C; // float
    constexpr std::ptrdiff_t maxdensity = 0x30; // float
    constexpr std::ptrdiff_t exponent = 0x34; // float
    constexpr std::ptrdiff_t HDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t skyboxFogFactor = 0x3C; // float
    constexpr std::ptrdiff_t skyboxFogFactorLerpTo = 0x40; // float
    constexpr std::ptrdiff_t startLerpTo = 0x44; // float
    constexpr std::ptrdiff_t endLerpTo = 0x48; // float
    constexpr std::ptrdiff_t maxdensityLerpTo = 0x4C; // float
    constexpr std::ptrdiff_t lerptime = 0x50; // GameTime_t
    constexpr std::ptrdiff_t duration = 0x54; // float
    constexpr std::ptrdiff_t blendtobackground = 0x58; // float
    constexpr std::ptrdiff_t scattering = 0x5C; // float
    constexpr std::ptrdiff_t locallightscale = 0x60; // float
    constexpr std::ptrdiff_t enable = 0x64; // bool
    constexpr std::ptrdiff_t blend = 0x65; // bool
    constexpr std::ptrdiff_t m_bNoReflectionFog = 0x66; // bool
    constexpr std::ptrdiff_t m_bPadding = 0x67; // bool
}

namespace fogplayerparams_t {
    constexpr std::ptrdiff_t m_hCtrl = 0x8; // CHandle<CFogController>
    constexpr std::ptrdiff_t m_flTransitionTime = 0xC; // float
    constexpr std::ptrdiff_t m_OldColor = 0x10; // Color
    constexpr std::ptrdiff_t m_flOldStart = 0x14; // float
    constexpr std::ptrdiff_t m_flOldEnd = 0x18; // float
    constexpr std::ptrdiff_t m_flOldMaxDensity = 0x1C; // float
    constexpr std::ptrdiff_t m_flOldHDRColorScale = 0x20; // float
    constexpr std::ptrdiff_t m_flOldFarZ = 0x24; // float
    constexpr std::ptrdiff_t m_NewColor = 0x28; // Color
    constexpr std::ptrdiff_t m_flNewStart = 0x2C; // float
    constexpr std::ptrdiff_t m_flNewEnd = 0x30; // float
    constexpr std::ptrdiff_t m_flNewMaxDensity = 0x34; // float
    constexpr std::ptrdiff_t m_flNewHDRColorScale = 0x38; // float
    constexpr std::ptrdiff_t m_flNewFarZ = 0x3C; // float
}

namespace hudtextparms_t {
    constexpr std::ptrdiff_t color1 = 0x0; // Color
    constexpr std::ptrdiff_t color2 = 0x4; // Color
    constexpr std::ptrdiff_t effect = 0x8; // uint8_t
    constexpr std::ptrdiff_t channel = 0x9; // uint8_t
    constexpr std::ptrdiff_t x = 0xC; // float
    constexpr std::ptrdiff_t y = 0x10; // float
}

namespace lerpdata_t {
    constexpr std::ptrdiff_t m_hEnt = 0x0; // CHandle<CBaseEntity>
    constexpr std::ptrdiff_t m_MoveType = 0x4; // MoveType_t
    constexpr std::ptrdiff_t m_flStartTime = 0x8; // GameTime_t
    constexpr std::ptrdiff_t m_vecStartOrigin = 0xC; // Vector
    constexpr std::ptrdiff_t m_qStartRot = 0x20; // Quaternion
    constexpr std::ptrdiff_t m_nFXIndex = 0x30; // ParticleIndex_t
}

namespace locksound_t {
    constexpr std::ptrdiff_t sLockedSound = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t sUnlockedSound = 0x10; // CUtlSymbolLarge
    constexpr std::ptrdiff_t flwaitSound = 0x18; // GameTime_t
}

namespace magnetted_objects_t {
    constexpr std::ptrdiff_t hEntity = 0x8; // CHandle<CBaseEntity>
}

namespace ragdoll_t {
    constexpr std::ptrdiff_t list = 0x0; // CUtlVector<ragdollelement_t>
    constexpr std::ptrdiff_t boneIndex = 0x18; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t allowStretch = 0x30; // bool
    constexpr std::ptrdiff_t unused = 0x31; // bool
}

namespace ragdollelement_t {
    constexpr std::ptrdiff_t originParentSpace = 0x0; // Vector
    constexpr std::ptrdiff_t parentIndex = 0x20; // int32_t
    constexpr std::ptrdiff_t m_flRadius = 0x24; // float
}

namespace shard_model_desc_t {
    constexpr std::ptrdiff_t m_nModelID = 0x8; // int32_t
    constexpr std::ptrdiff_t m_hMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_solid = 0x18; // ShardSolid_t
    constexpr std::ptrdiff_t m_ShatterPanelMode = 0x19; // ShatterPanelMode
    constexpr std::ptrdiff_t m_vecPanelSize = 0x1C; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionA = 0x24; // Vector2D
    constexpr std::ptrdiff_t m_vecStressPositionB = 0x2C; // Vector2D
    constexpr std::ptrdiff_t m_vecPanelVertices = 0x38; // CNetworkUtlVectorBase<Vector2D>
    constexpr std::ptrdiff_t m_flGlassHalfThickness = 0x50; // float
    constexpr std::ptrdiff_t m_bHasParent = 0x54; // bool
    constexpr std::ptrdiff_t m_bParentFrozen = 0x55; // bool
    constexpr std::ptrdiff_t m_SurfacePropStringToken = 0x58; // CUtlStringToken
}

namespace sky3dparams_t {
    constexpr std::ptrdiff_t scale = 0x8; // int16_t
    constexpr std::ptrdiff_t origin = 0xC; // Vector
    constexpr std::ptrdiff_t bClip3DSkyBoxNearToWorldFar = 0x18; // bool
    constexpr std::ptrdiff_t flClip3DSkyBoxNearToWorldFarOffset = 0x1C; // float
    constexpr std::ptrdiff_t fog = 0x20; // fogparams_t
    constexpr std::ptrdiff_t m_nWorldGroupID = 0x88; // WorldGroupId_t
}

namespace thinkfunc_t {
    constexpr std::ptrdiff_t m_hFn = 0x8; // HSCRIPT
    constexpr std::ptrdiff_t m_nContext = 0x10; // CUtlStringToken
    constexpr std::ptrdiff_t m_nNextThinkTick = 0x14; // GameTick_t
    constexpr std::ptrdiff_t m_nLastThinkTick = 0x18; // GameTick_t
}
```

`HPCS2/offset/soundsystem.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace CDSPMixgroupModifier {
    constexpr std::ptrdiff_t m_mixgroup = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flModifier = 0x8; // float
    constexpr std::ptrdiff_t m_flModifierMin = 0xC; // float
    constexpr std::ptrdiff_t m_flSourceModifier = 0x10; // float
    constexpr std::ptrdiff_t m_flSourceModifierMin = 0x14; // float
    constexpr std::ptrdiff_t m_flListenerReverbModifierWhenSourceReverbIsActive = 0x18; // float
}

namespace CDSPPresetMixgroupModifierTable {
    constexpr std::ptrdiff_t m_table = 0x0; // CUtlVector<CDspPresetModifierList>
}

namespace CDspPresetModifierList {
    constexpr std::ptrdiff_t m_dspName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_modifiers = 0x8; // CUtlVector<CDSPMixgroupModifier>
}

namespace CSosGroupActionLimitSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_nStopType = 0x1C; // SosActionStopType_t
    constexpr std::ptrdiff_t m_nSortType = 0x20; // SosActionSortType_t
}

namespace CSosGroupActionSchema {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_actionType = 0x10; // ActionType_t
    constexpr std::ptrdiff_t m_actionInstanceType = 0x14; // ActionType_t
}

namespace CSosGroupActionSetSoundeventParameterSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_nMaxCount = 0x18; // int32_t
    constexpr std::ptrdiff_t m_flMinValue = 0x1C; // float
    constexpr std::ptrdiff_t m_flMaxValue = 0x20; // float
    constexpr std::ptrdiff_t m_opvarName = 0x28; // CUtlString
    constexpr std::ptrdiff_t m_nSortType = 0x30; // SosActionSortType_t
}

namespace CSosGroupActionTimeLimitSchema { // CSosGroupActionSchema
    constexpr std::ptrdiff_t m_flMaxDuration = 0x18; // float
}

namespace CSosGroupBranchPattern {
    constexpr std::ptrdiff_t m_bMatchEventName = 0x8; // bool
    constexpr std::ptrdiff_t m_bMatchEventSubString = 0x9; // bool
    constexpr std::ptrdiff_t m_bMatchEntIndex = 0xA; // bool
    constexpr std::ptrdiff_t m_bMatchOpvar = 0xB; // bool
}

namespace CSosGroupMatchPattern { // CSosGroupBranchPattern
    constexpr std::ptrdiff_t m_matchSoundEventName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_matchSoundEventSubString = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_flEntIndex = 0x20; // float
    constexpr std::ptrdiff_t m_flOpvar = 0x24; // float
}

namespace CSosSoundEventGroupListSchema {
    constexpr std::ptrdiff_t m_groupList = 0x0; // CUtlVector<CSosSoundEventGroupSchema>
}

namespace CSosSoundEventGroupSchema {
    constexpr std::ptrdiff_t m_name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nType = 0x8; // SosGroupType_t
    constexpr std::ptrdiff_t m_bIsBlocking = 0xC; // bool
    constexpr std::ptrdiff_t m_nBlockMaxCount = 0x10; // int32_t
    constexpr std::ptrdiff_t m_bInvertMatch = 0x14; // bool
    constexpr std::ptrdiff_t m_matchPattern = 0x18; // CSosGroupMatchPattern
    constexpr std::ptrdiff_t m_branchPattern = 0x40; // CSosGroupBranchPattern
    constexpr std::ptrdiff_t m_vActions = 0xB0; // CSosGroupActionSchema*[4]
}

namespace CSoundEventMetaData {
    constexpr std::ptrdiff_t m_soundEventVMix = 0x0; // CStrongHandle<InfoForResourceTypeCVMixListResource>
}

namespace SelectedEditItemInfo_t {
    constexpr std::ptrdiff_t m_EditItems = 0x0; // CUtlVector<SosEditItemInfo_t>
}

namespace SosEditItemInfo_t {
    constexpr std::ptrdiff_t itemType = 0x0; // SosEditItemType_t
    constexpr std::ptrdiff_t itemName = 0x8; // CUtlString
    constexpr std::ptrdiff_t itemTypeName = 0x10; // CUtlString
    constexpr std::ptrdiff_t itemKVString = 0x20; // CUtlString
    constexpr std::ptrdiff_t itemPos = 0x28; // Vector2D
}

namespace VMixAutoFilterDesc_t {
    constexpr std::ptrdiff_t m_flEnvelopeAmount = 0x0; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
    constexpr std::ptrdiff_t m_filter = 0xC; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flLFOAmount = 0x1C; // float
    constexpr std::ptrdiff_t m_flLFORate = 0x20; // float
    constexpr std::ptrdiff_t m_flPhase = 0x24; // float
    constexpr std::ptrdiff_t m_nLFOShape = 0x28; // VMixLFOShape_t
}

namespace VMixBoxverbDesc_t {
    constexpr std::ptrdiff_t m_flSizeMax = 0x0; // float
    constexpr std::ptrdiff_t m_flSizeMin = 0x4; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x8; // float
    constexpr std::ptrdiff_t m_flDiffusion = 0xC; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x10; // float
    constexpr std::ptrdiff_t m_flModRate = 0x14; // float
    constexpr std::ptrdiff_t m_bParallel = 0x18; // bool
    constexpr std::ptrdiff_t m_filterType = 0x1C; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_flWidth = 0x2C; // float
    constexpr std::ptrdiff_t m_flHeight = 0x30; // float
    constexpr std::ptrdiff_t m_flDepth = 0x34; // float
    constexpr std::ptrdiff_t m_flFeedbackScale = 0x38; // float
    constexpr std::ptrdiff_t m_flFeedbackWidth = 0x3C; // float
    constexpr std::ptrdiff_t m_flFeedbackHeight = 0x40; // float
    constexpr std::ptrdiff_t m_flFeedbackDepth = 0x44; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x48; // float
    constexpr std::ptrdiff_t m_flTaps = 0x4C; // float
}

namespace VMixConvolutionDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_flPreDelayMS = 0x4; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLow = 0xC; // float
    constexpr std::ptrdiff_t m_fldbMid = 0x10; // float
    constexpr std::ptrdiff_t m_fldbHigh = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
}

namespace VMixDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bEnableFilter = 0x10; // bool
    constexpr std::ptrdiff_t m_flDelay = 0x14; // float
    constexpr std::ptrdiff_t m_flDirectGain = 0x18; // float
    constexpr std::ptrdiff_t m_flDelayGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flWidth = 0x24; // float
}

namespace VMixDiffusorDesc_t {
    constexpr std::ptrdiff_t m_flSize = 0x0; // float
    constexpr std::ptrdiff_t m_flComplexity = 0x4; // float
    constexpr std::ptrdiff_t m_flFeedback = 0x8; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0xC; // float
}

namespace VMixDynamics3BandDesc_t {
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x0; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flDepth = 0xC; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x10; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0x14; // float
    constexpr std::ptrdiff_t m_flLowCutoffFreq = 0x18; // float
    constexpr std::ptrdiff_t m_flHighCutoffFreq = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
    constexpr std::ptrdiff_t m_bandDesc = 0x24; // VMixDynamicsBand_t[3]
}

namespace VMixDynamicsBand_t {
    constexpr std::ptrdiff_t m_fldbGainInput = 0x0; // float
    constexpr std::ptrdiff_t m_fldbGainOutput = 0x4; // float
    constexpr std::ptrdiff_t m_fldbThresholdBelow = 0x8; // float
    constexpr std::ptrdiff_t m_fldbThresholdAbove = 0xC; // float
    constexpr std::ptrdiff_t m_flRatioBelow = 0x10; // float
    constexpr std::ptrdiff_t m_flRatioAbove = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_bEnable = 0x20; // bool
    constexpr std::ptrdiff_t m_bSolo = 0x21; // bool
}

namespace VMixDynamicsCompressorDesc_t {
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flCompressionRatio = 0xC; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x10; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x14; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x1C; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x20; // bool
}

namespace VMixDynamicsDesc_t {
    constexpr std::ptrdiff_t m_fldbGain = 0x0; // float
    constexpr std::ptrdiff_t m_fldbNoiseGateThreshold = 0x4; // float
    constexpr std::ptrdiff_t m_fldbCompressionThreshold = 0x8; // float
    constexpr std::ptrdiff_t m_fldbLimiterThreshold = 0xC; // float
    constexpr std::ptrdiff_t m_fldbKneeWidth = 0x10; // float
    constexpr std::ptrdiff_t m_flRatio = 0x14; // float
    constexpr std::ptrdiff_t m_flLimiterRatio = 0x18; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x20; // float
    constexpr std::ptrdiff_t m_flRMSTimeMS = 0x24; // float
    constexpr std::ptrdiff_t m_flWetMix = 0x28; // float
    constexpr std::ptrdiff_t m_bPeakMode = 0x2C; // bool
}

namespace VMixEQ8Desc_t {
    constexpr std::ptrdiff_t m_stages = 0x0; // VMixFilterDesc_t[8]
}

namespace VMixEffectChainDesc_t {
    constexpr std::ptrdiff_t m_flCrossfadeTime = 0x0; // float
}

namespace VMixEnvelopeDesc_t {
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x0; // float
    constexpr std::ptrdiff_t m_flHoldTimeMS = 0x4; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x8; // float
}

namespace VMixFilterDesc_t {
    constexpr std::ptrdiff_t m_nFilterType = 0x0; // VMixFilterType_t
    constexpr std::ptrdiff_t m_nFilterSlope = 0x2; // VMixFilterSlope_t
    constexpr std::ptrdiff_t m_bEnabled = 0x3; // bool
    constexpr std::ptrdiff_t m_fldbGain = 0x4; // float
    constexpr std::ptrdiff_t m_flCutoffFreq = 0x8; // float
    constexpr std::ptrdiff_t m_flQ = 0xC; // float
}

namespace VMixFreeverbDesc_t {
    constexpr std::ptrdiff_t m_flRoomSize = 0x0; // float
    constexpr std::ptrdiff_t m_flDamp = 0x4; // float
    constexpr std::ptrdiff_t m_flWidth = 0x8; // float
    constexpr std::ptrdiff_t m_flLateReflections = 0xC; // float
}

namespace VMixModDelayDesc_t {
    constexpr std::ptrdiff_t m_feedbackFilter = 0x0; // VMixFilterDesc_t
    constexpr std::ptrdiff_t m_bPhaseInvert = 0x10; // bool
    constexpr std::ptrdiff_t m_flGlideTime = 0x14; // float
    constexpr std::ptrdiff_t m_flDelay = 0x18; // float
    constexpr std::ptrdiff_t m_flOutputGain = 0x1C; // float
    constexpr std::ptrdiff_t m_flFeedbackGain = 0x20; // float
    constexpr std::ptrdiff_t m_flModRate = 0x24; // float
    constexpr std::ptrdiff_t m_flModDepth = 0x28; // float
    constexpr std::ptrdiff_t m_bApplyAntialiasing = 0x2C; // bool
}

namespace VMixOscDesc_t {
    constexpr std::ptrdiff_t oscType = 0x0; // VMixLFOShape_t
    constexpr std::ptrdiff_t m_freq = 0x4; // float
    constexpr std::ptrdiff_t m_flPhase = 0x8; // float
}

namespace VMixPannerDesc_t {
    constexpr std::ptrdiff_t m_type = 0x0; // VMixPannerType_t
    constexpr std::ptrdiff_t m_flStrength = 0x4; // float
}

namespace VMixPitchShiftDesc_t {
    constexpr std::ptrdiff_t m_nGrainSampleCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flPitchShift = 0x4; // float
    constexpr std::ptrdiff_t m_nQuality = 0x8; // int32_t
    constexpr std::ptrdiff_t m_nProcType = 0xC; // int32_t
}

namespace VMixPlateverbDesc_t {
    constexpr std::ptrdiff_t m_flPrefilter = 0x0; // float
    constexpr std::ptrdiff_t m_flInputDiffusion1 = 0x4; // float
    constexpr std::ptrdiff_t m_flInputDiffusion2 = 0x8; // float
    constexpr std::ptrdiff_t m_flDecay = 0xC; // float
    constexpr std::ptrdiff_t m_flDamp = 0x10; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion1 = 0x14; // float
    constexpr std::ptrdiff_t m_flFeedbackDiffusion2 = 0x18; // float
}

namespace VMixShaperDesc_t {
    constexpr std::ptrdiff_t m_nShape = 0x0; // int32_t
    constexpr std::ptrdiff_t m_fldbDrive = 0x4; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0x8; // float
    constexpr std::ptrdiff_t m_flWetMix = 0xC; // float
    constexpr std::ptrdiff_t m_nOversampleFactor = 0x10; // int32_t
}

namespace VMixSubgraphSwitchDesc_t {
    constexpr std::ptrdiff_t m_interpolationMode = 0x0; // VMixSubgraphSwitchInterpolationType_t
    constexpr std::ptrdiff_t m_bOnlyTailsOnFadeOut = 0x4; // bool
    constexpr std::ptrdiff_t m_flInterpolationTime = 0x8; // float
}

namespace VMixUtilityDesc_t {
    constexpr std::ptrdiff_t m_nOp = 0x0; // VMixChannelOperation_t
    constexpr std::ptrdiff_t m_flInputPan = 0x4; // float
    constexpr std::ptrdiff_t m_flOutputBalance = 0x8; // float
    constexpr std::ptrdiff_t m_fldbOutputGain = 0xC; // float
    constexpr std::ptrdiff_t m_bBassMono = 0x10; // bool
    constexpr std::ptrdiff_t m_flBassFreq = 0x14; // float
}

namespace VMixVocoderDesc_t {
    constexpr std::ptrdiff_t m_nBandCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_flBandwidth = 0x4; // float
    constexpr std::ptrdiff_t m_fldBModGain = 0x8; // float
    constexpr std::ptrdiff_t m_flFreqRangeStart = 0xC; // float
    constexpr std::ptrdiff_t m_flFreqRangeEnd = 0x10; // float
    constexpr std::ptrdiff_t m_fldBUnvoicedGain = 0x14; // float
    constexpr std::ptrdiff_t m_flAttackTimeMS = 0x18; // float
    constexpr std::ptrdiff_t m_flReleaseTimeMS = 0x1C; // float
    constexpr std::ptrdiff_t m_nDebugBand = 0x20; // int32_t
    constexpr std::ptrdiff_t m_bPeakMode = 0x24; // bool
}
```

`HPCS2/offset/vphysics2.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:50 +0000
 */

#pragma once

#include <cstddef>

namespace CFeIndexedJiggleBone {
    constexpr std::ptrdiff_t m_nNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nJiggleParent = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x8; // CFeJiggleBone
}

namespace CFeJiggleBone {
    constexpr std::ptrdiff_t m_nFlags = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
    constexpr std::ptrdiff_t m_flTipMass = 0x8; // float
    constexpr std::ptrdiff_t m_flYawStiffness = 0xC; // float
    constexpr std::ptrdiff_t m_flYawDamping = 0x10; // float
    constexpr std::ptrdiff_t m_flPitchStiffness = 0x14; // float
    constexpr std::ptrdiff_t m_flPitchDamping = 0x18; // float
    constexpr std::ptrdiff_t m_flAlongStiffness = 0x1C; // float
    constexpr std::ptrdiff_t m_flAlongDamping = 0x20; // float
    constexpr std::ptrdiff_t m_flAngleLimit = 0x24; // float
    constexpr std::ptrdiff_t m_flMinYaw = 0x28; // float
    constexpr std::ptrdiff_t m_flMaxYaw = 0x2C; // float
    constexpr std::ptrdiff_t m_flYawFriction = 0x30; // float
    constexpr std::ptrdiff_t m_flYawBounce = 0x34; // float
    constexpr std::ptrdiff_t m_flMinPitch = 0x38; // float
    constexpr std::ptrdiff_t m_flMaxPitch = 0x3C; // float
    constexpr std::ptrdiff_t m_flPitchFriction = 0x40; // float
    constexpr std::ptrdiff_t m_flPitchBounce = 0x44; // float
    constexpr std::ptrdiff_t m_flBaseMass = 0x48; // float
    constexpr std::ptrdiff_t m_flBaseStiffness = 0x4C; // float
    constexpr std::ptrdiff_t m_flBaseDamping = 0x50; // float
    constexpr std::ptrdiff_t m_flBaseMinLeft = 0x54; // float
    constexpr std::ptrdiff_t m_flBaseMaxLeft = 0x58; // float
    constexpr std::ptrdiff_t m_flBaseLeftFriction = 0x5C; // float
    constexpr std::ptrdiff_t m_flBaseMinUp = 0x60; // float
    constexpr std::ptrdiff_t m_flBaseMaxUp = 0x64; // float
    constexpr std::ptrdiff_t m_flBaseUpFriction = 0x68; // float
    constexpr std::ptrdiff_t m_flBaseMinForward = 0x6C; // float
    constexpr std::ptrdiff_t m_flBaseMaxForward = 0x70; // float
    constexpr std::ptrdiff_t m_flBaseForwardFriction = 0x74; // float
    constexpr std::ptrdiff_t m_flRadius0 = 0x78; // float
    constexpr std::ptrdiff_t m_flRadius1 = 0x7C; // float
    constexpr std::ptrdiff_t m_vPoint0 = 0x80; // Vector
    constexpr std::ptrdiff_t m_vPoint1 = 0x8C; // Vector
    constexpr std::ptrdiff_t m_nCollisionMask = 0x98; // uint16_t
}

namespace CFeMorphLayer {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
}

namespace CFeNamedJiggleBone {
    constexpr std::ptrdiff_t m_strParentBone = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_transform = 0x10; // CTransform
    constexpr std::ptrdiff_t m_nJiggleParent = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_jiggleBone = 0x34; // CFeJiggleBone
}

namespace CFeVertexMapBuildArray {
    constexpr std::ptrdiff_t m_Array = 0x0; // CUtlVector<FeVertexMapBuild_t*>
}

namespace CRegionSVM {
    constexpr std::ptrdiff_t m_Planes = 0x0; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<uint32_t>
}

namespace CastSphereSATParams_t {
    constexpr std::ptrdiff_t m_vRayStart = 0x0; // Vector
    constexpr std::ptrdiff_t m_vRayDelta = 0xC; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_flMaxFraction = 0x1C; // float
    constexpr std::ptrdiff_t m_flScale = 0x20; // float
    constexpr std::ptrdiff_t m_pHull = 0x28; // RnHull_t*
}

namespace CovMatrix3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // Vector
    constexpr std::ptrdiff_t m_flXY = 0xC; // float
    constexpr std::ptrdiff_t m_flXZ = 0x10; // float
    constexpr std::ptrdiff_t m_flYZ = 0x14; // float
}

namespace Dop26_t {
    constexpr std::ptrdiff_t m_flSupport = 0x0; // float[26]
}

namespace FeAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x8; // float
}

namespace FeAxialEdgeBend_t {
    constexpr std::ptrdiff_t te = 0x0; // float
    constexpr std::ptrdiff_t tv = 0x4; // float
    constexpr std::ptrdiff_t flDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight = 0xC; // float[4]
    constexpr std::ptrdiff_t nNode = 0x1C; // uint16_t[6]
}

namespace FeBandBendLimit_t {
    constexpr std::ptrdiff_t flDistMin = 0x0; // float
    constexpr std::ptrdiff_t flDistMax = 0x4; // float
    constexpr std::ptrdiff_t nNode = 0x8; // uint16_t[6]
}

namespace FeBoxRigid_t {
    constexpr std::ptrdiff_t tmFrame2 = 0x0; // CTransform
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t vSize = 0x24; // Vector
    constexpr std::ptrdiff_t nVertexMapIndex = 0x30; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x32; // uint16_t
}

namespace FeBuildBoxRigid_t { // FeBoxRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x40; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x44; // uint32_t
}

namespace FeBuildSphereRigid_t { // FeSphereRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x20; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x24; // uint32_t
}

namespace FeBuildTaperedCapsuleRigid_t { // FeTaperedCapsuleRigid_t
    constexpr std::ptrdiff_t m_nPriority = 0x30; // int32_t
    constexpr std::ptrdiff_t m_nVertexMapHash = 0x34; // uint32_t
}

namespace FeCollisionPlane_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_Plane = 0x4; // RnPlane_t
    constexpr std::ptrdiff_t flStrength = 0x14; // float
}

namespace FeCtrlOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nCtrlParent = 0xC; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0xE; // uint16_t
}

namespace FeCtrlOsOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
}

namespace FeCtrlSoftOffset_t {
    constexpr std::ptrdiff_t nCtrlParent = 0x0; // uint16_t
    constexpr std::ptrdiff_t nCtrlChild = 0x2; // uint16_t
    constexpr std::ptrdiff_t vOffset = 0x4; // Vector
    constexpr std::ptrdiff_t flAlpha = 0x10; // float
}

namespace FeEdgeDesc_t {
    constexpr std::ptrdiff_t nEdge = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nSide = 0x4; // uint16_t[2][2]
    constexpr std::ptrdiff_t nVirtElem = 0xC; // uint16_t[2]
}

namespace FeEffectDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nType = 0xC; // int32_t
    constexpr std::ptrdiff_t m_Params = 0x10; // KeyValues3
}

namespace FeFitInfluence_t {
    constexpr std::ptrdiff_t nVertexNode = 0x0; // uint32_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
    constexpr std::ptrdiff_t nMatrixNode = 0x8; // uint32_t
}

namespace FeFitMatrix_t {
    constexpr std::ptrdiff_t bone = 0x0; // CTransform
    constexpr std::ptrdiff_t vCenter = 0x20; // Vector
    constexpr std::ptrdiff_t nEnd = 0x2C; // uint16_t
    constexpr std::ptrdiff_t nNode = 0x2E; // uint16_t
    constexpr std::ptrdiff_t nBeginDynamic = 0x30; // uint16_t
}

namespace FeFitWeight_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float
    constexpr std::ptrdiff_t nNode = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
}

namespace FeFollowNode_t {
    constexpr std::ptrdiff_t nParentNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nChildNode = 0x2; // uint16_t
    constexpr std::ptrdiff_t flWeight = 0x4; // float
}

namespace FeKelagerBend2_t {
    constexpr std::ptrdiff_t flWeight = 0x0; // float[3]
    constexpr std::ptrdiff_t flHeight0 = 0xC; // float
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t[3]
    constexpr std::ptrdiff_t nReserved = 0x16; // uint16_t
}

namespace FeMorphLayerDepr_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Nodes = 0x10; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_InitPos = 0x28; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Gravity = 0x40; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalStrength = 0x58; // CUtlVector<float>
    constexpr std::ptrdiff_t m_GoalDamping = 0x70; // CUtlVector<float>
    constexpr std::ptrdiff_t m_nFlags = 0x88; // uint32_t
}

namespace FeNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x2; // uint16_t[3]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0xA; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0xC; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0xE; // uint16_t
    constexpr std::ptrdiff_t qAdjust = 0x10; // QuaternionStorage
}

namespace FeNodeIntegrator_t {
    constexpr std::ptrdiff_t flPointDamping = 0x0; // float
    constexpr std::ptrdiff_t flAnimationForceAttraction = 0x4; // float
    constexpr std::ptrdiff_t flAnimationVertexAttraction = 0x8; // float
    constexpr std::ptrdiff_t flGravity = 0xC; // float
}

namespace FeNodeReverseOffset_t {
    constexpr std::ptrdiff_t vOffset = 0x0; // Vector
    constexpr std::ptrdiff_t nBoneCtrl = 0xC; // uint16_t
    constexpr std::ptrdiff_t nTargetNode = 0xE; // uint16_t
}

namespace FeNodeWindBase_t {
    constexpr std::ptrdiff_t nNodeX0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeX1 = 0x2; // uint16_t
    constexpr std::ptrdiff_t nNodeY0 = 0x4; // uint16_t
    constexpr std::ptrdiff_t nNodeY1 = 0x6; // uint16_t
}

namespace FeProxyVertexMap_t {
    constexpr std::ptrdiff_t m_Name = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_flWeight = 0x8; // float
}

namespace FeQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t flSlack = 0x8; // float
    constexpr std::ptrdiff_t vShape = 0xC; // Vector4D[4]
}

namespace FeRigidColliderIndices_t {
    constexpr std::ptrdiff_t m_nTaperedCapsuleRigidIndex = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nSphereRigidIndex = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nBoxRigidIndex = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nCollisionPlaneIndex = 0x6; // uint16_t
}

namespace FeRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flMaxDist = 0x4; // float
    constexpr std::ptrdiff_t flMinDist = 0x8; // float
    constexpr std::ptrdiff_t flWeight0 = 0xC; // float
    constexpr std::ptrdiff_t flRelaxationFactor = 0x10; // float
}

namespace FeSimdAnimStrayRadius_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flMaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t flRelaxationFactor = 0x20; // fltx4
}

namespace FeSimdNodeBase_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX0 = 0x8; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeX1 = 0x10; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY0 = 0x18; // uint16_t[4]
    constexpr std::ptrdiff_t nNodeY1 = 0x20; // uint16_t[4]
    constexpr std::ptrdiff_t nDummy = 0x28; // uint16_t[4]
    constexpr std::ptrdiff_t qAdjust = 0x30; // FourQuaternions
}

namespace FeSimdQuad_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][4]
    constexpr std::ptrdiff_t f4Slack = 0x20; // fltx4
    constexpr std::ptrdiff_t vShape = 0x30; // FourVectors[4]
    constexpr std::ptrdiff_t f4Weights = 0xF0; // fltx4[4]
}

namespace FeSimdRodConstraint_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t f4MaxDist = 0x10; // fltx4
    constexpr std::ptrdiff_t f4MinDist = 0x20; // fltx4
    constexpr std::ptrdiff_t f4Weight0 = 0x30; // fltx4
    constexpr std::ptrdiff_t f4RelaxationFactor = 0x40; // fltx4
}

namespace FeSimdSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[4][2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x10; // fltx4
    constexpr std::ptrdiff_t flSpringConstant = 0x20; // fltx4
    constexpr std::ptrdiff_t flSpringDamping = 0x30; // fltx4
    constexpr std::ptrdiff_t flNodeWeight0 = 0x40; // fltx4
}

namespace FeSimdTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint32_t[4][3]
    constexpr std::ptrdiff_t w1 = 0x30; // fltx4
    constexpr std::ptrdiff_t w2 = 0x40; // fltx4
    constexpr std::ptrdiff_t v1x = 0x50; // fltx4
    constexpr std::ptrdiff_t v2 = 0x60; // FourVectors2D
}

namespace FeSoftParent_t {
    constexpr std::ptrdiff_t nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t flAlpha = 0x4; // float
}

namespace FeSourceEdge_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
}

namespace FeSphereRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4
    constexpr std::ptrdiff_t nNode = 0x10; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x12; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x14; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x16; // uint16_t
}

namespace FeSpringIntegrator_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t flSpringRestLength = 0x4; // float
    constexpr std::ptrdiff_t flSpringConstant = 0x8; // float
    constexpr std::ptrdiff_t flSpringDamping = 0xC; // float
    constexpr std::ptrdiff_t flNodeWeight0 = 0x10; // float
}

namespace FeStiffHingeBuild_t {
    constexpr std::ptrdiff_t flMaxAngle = 0x0; // float
    constexpr std::ptrdiff_t flStrength = 0x4; // float
    constexpr std::ptrdiff_t flMotionBias = 0x8; // float[3]
    constexpr std::ptrdiff_t nNode = 0x14; // uint16_t[3]
}

namespace FeTaperedCapsuleRigid_t {
    constexpr std::ptrdiff_t vSphere = 0x0; // fltx4[2]
    constexpr std::ptrdiff_t nNode = 0x20; // uint16_t
    constexpr std::ptrdiff_t nCollisionMask = 0x22; // uint16_t
    constexpr std::ptrdiff_t nVertexMapIndex = 0x24; // uint16_t
    constexpr std::ptrdiff_t nFlags = 0x26; // uint16_t
}

namespace FeTaperedCapsuleStretch_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t nCollisionMask = 0x4; // uint16_t
    constexpr std::ptrdiff_t nDummy = 0x6; // uint16_t
    constexpr std::ptrdiff_t flRadius = 0x8; // float[2]
}

namespace FeTreeChildren_t {
    constexpr std::ptrdiff_t nChild = 0x0; // uint16_t[2]
}

namespace FeTri_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t[3]
    constexpr std::ptrdiff_t w1 = 0x8; // float
    constexpr std::ptrdiff_t w2 = 0xC; // float
    constexpr std::ptrdiff_t v1x = 0x10; // float
    constexpr std::ptrdiff_t v2 = 0x14; // Vector2D
}

namespace FeTwistConstraint_t {
    constexpr std::ptrdiff_t nNodeOrient = 0x0; // uint16_t
    constexpr std::ptrdiff_t nNodeEnd = 0x2; // uint16_t
    constexpr std::ptrdiff_t flTwistRelax = 0x4; // float
    constexpr std::ptrdiff_t flSwingRelax = 0x8; // float
}

namespace FeVertexMapBuild_t {
    constexpr std::ptrdiff_t m_VertexMapName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_Color = 0xC; // Color
    constexpr std::ptrdiff_t m_flVolumetricSolveStrength = 0x10; // float
    constexpr std::ptrdiff_t m_nScaleSourceNode = 0x14; // int32_t
    constexpr std::ptrdiff_t m_Weights = 0x18; // CUtlVector<float>
}

namespace FeVertexMapDesc_t {
    constexpr std::ptrdiff_t sName = 0x0; // CUtlString
    constexpr std::ptrdiff_t nNameHash = 0x8; // uint32_t
    constexpr std::ptrdiff_t nColor = 0xC; // uint32_t
    constexpr std::ptrdiff_t nFlags = 0x10; // uint32_t
    constexpr std::ptrdiff_t nVertexBase = 0x14; // uint16_t
    constexpr std::ptrdiff_t nVertexCount = 0x16; // uint16_t
    constexpr std::ptrdiff_t nMapOffset = 0x18; // uint32_t
    constexpr std::ptrdiff_t nNodeListOffset = 0x1C; // uint32_t
    constexpr std::ptrdiff_t vCenterOfMass = 0x20; // Vector
    constexpr std::ptrdiff_t flVolumetricSolveStrength = 0x2C; // float
    constexpr std::ptrdiff_t nScaleSourceNode = 0x30; // int16_t
    constexpr std::ptrdiff_t nNodeListCount = 0x32; // uint16_t
}

namespace FeWeightedNode_t {
    constexpr std::ptrdiff_t nNode = 0x0; // uint16_t
    constexpr std::ptrdiff_t nWeight = 0x2; // uint16_t
}

namespace FeWorldCollisionParams_t {
    constexpr std::ptrdiff_t flWorldFriction = 0x0; // float
    constexpr std::ptrdiff_t flGroundFriction = 0x4; // float
    constexpr std::ptrdiff_t nListBegin = 0x8; // uint16_t
    constexpr std::ptrdiff_t nListEnd = 0xA; // uint16_t
}

namespace FourCovMatrices3 {
    constexpr std::ptrdiff_t m_vDiag = 0x0; // FourVectors
    constexpr std::ptrdiff_t m_flXY = 0x30; // fltx4
    constexpr std::ptrdiff_t m_flXZ = 0x40; // fltx4
    constexpr std::ptrdiff_t m_flYZ = 0x50; // fltx4
}

namespace FourVectors2D {
    constexpr std::ptrdiff_t x = 0x0; // fltx4
    constexpr std::ptrdiff_t y = 0x10; // fltx4
}

namespace IPhysicsPlayerController {
}

namespace OldFeEdge_t {
    constexpr std::ptrdiff_t m_flK = 0x0; // float[3]
    constexpr std::ptrdiff_t invA = 0xC; // float
    constexpr std::ptrdiff_t t = 0x10; // float
    constexpr std::ptrdiff_t flThetaRelaxed = 0x14; // float
    constexpr std::ptrdiff_t flThetaFactor = 0x18; // float
    constexpr std::ptrdiff_t c01 = 0x1C; // float
    constexpr std::ptrdiff_t c02 = 0x20; // float
    constexpr std::ptrdiff_t c03 = 0x24; // float
    constexpr std::ptrdiff_t c04 = 0x28; // float
    constexpr std::ptrdiff_t flAxialModelDist = 0x2C; // float
    constexpr std::ptrdiff_t flAxialModelWeights = 0x30; // float[4]
    constexpr std::ptrdiff_t m_nNode = 0x40; // uint16_t[4]
}

namespace PhysFeModelDesc_t {
    constexpr std::ptrdiff_t m_CtrlHash = 0x0; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_CtrlName = 0x18; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_nStaticNodeFlags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_nDynamicNodeFlags = 0x34; // uint32_t
    constexpr std::ptrdiff_t m_flLocalForce = 0x38; // float
    constexpr std::ptrdiff_t m_flLocalRotation = 0x3C; // float
    constexpr std::ptrdiff_t m_nNodeCount = 0x40; // uint16_t
    constexpr std::ptrdiff_t m_nStaticNodes = 0x42; // uint16_t
    constexpr std::ptrdiff_t m_nRotLockStaticNodes = 0x44; // uint16_t
    constexpr std::ptrdiff_t m_nFirstPositionDrivenNode = 0x46; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount1 = 0x48; // uint16_t
    constexpr std::ptrdiff_t m_nSimdTriCount2 = 0x4A; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount1 = 0x4C; // uint16_t
    constexpr std::ptrdiff_t m_nSimdQuadCount2 = 0x4E; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount1 = 0x50; // uint16_t
    constexpr std::ptrdiff_t m_nQuadCount2 = 0x52; // uint16_t
    constexpr std::ptrdiff_t m_nTreeDepth = 0x54; // uint16_t
    constexpr std::ptrdiff_t m_nNodeBaseJiggleboneDependsCount = 0x56; // uint16_t
    constexpr std::ptrdiff_t m_nRopeCount = 0x58; // uint16_t
    constexpr std::ptrdiff_t m_Ropes = 0x60; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_NodeBases = 0x78; // CUtlVector<FeNodeBase_t>
    constexpr std::ptrdiff_t m_SimdNodeBases = 0x90; // CUtlVector<FeSimdNodeBase_t>
    constexpr std::ptrdiff_t m_Quads = 0xA8; // CUtlVector<FeQuad_t>
    constexpr std::ptrdiff_t m_SimdQuads = 0xC0; // CUtlVector<FeSimdQuad_t>
    constexpr std::ptrdiff_t m_SimdTris = 0xD8; // CUtlVector<FeSimdTri_t>
    constexpr std::ptrdiff_t m_SimdRods = 0xF0; // CUtlVector<FeSimdRodConstraint_t>
    constexpr std::ptrdiff_t m_InitPose = 0x108; // CUtlVector<CTransform>
    constexpr std::ptrdiff_t m_Rods = 0x120; // CUtlVector<FeRodConstraint_t>
    constexpr std::ptrdiff_t m_Twists = 0x138; // CUtlVector<FeTwistConstraint_t>
    constexpr std::ptrdiff_t m_AxialEdges = 0x150; // CUtlVector<FeAxialEdgeBend_t>
    constexpr std::ptrdiff_t m_NodeInvMasses = 0x168; // CUtlVector<float>
    constexpr std::ptrdiff_t m_CtrlOffsets = 0x180; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_CtrlOsOffsets = 0x198; // CUtlVector<FeCtrlOsOffset_t>
    constexpr std::ptrdiff_t m_FollowNodes = 0x1B0; // CUtlVector<FeFollowNode_t>
    constexpr std::ptrdiff_t m_CollisionPlanes = 0x1C8; // CUtlVector<FeCollisionPlane_t>
    constexpr std::ptrdiff_t m_NodeIntegrator = 0x1E0; // CUtlVector<FeNodeIntegrator_t>
    constexpr std::ptrdiff_t m_SpringIntegrator = 0x1F8; // CUtlVector<FeSpringIntegrator_t>
    constexpr std::ptrdiff_t m_SimdSpringIntegrator = 0x210; // CUtlVector<FeSimdSpringIntegrator_t>
    constexpr std::ptrdiff_t m_WorldCollisionParams = 0x228; // CUtlVector<FeWorldCollisionParams_t>
    constexpr std::ptrdiff_t m_LegacyStretchForce = 0x240; // CUtlVector<float>
    constexpr std::ptrdiff_t m_NodeCollisionRadii = 0x258; // CUtlVector<float>
    constexpr std::ptrdiff_t m_DynNodeFriction = 0x270; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalRotation = 0x288; // CUtlVector<float>
    constexpr std::ptrdiff_t m_LocalForce = 0x2A0; // CUtlVector<float>
    constexpr std::ptrdiff_t m_TaperedCapsuleStretches = 0x2B8; // CUtlVector<FeTaperedCapsuleStretch_t>
    constexpr std::ptrdiff_t m_TaperedCapsuleRigids = 0x2D0; // CUtlVector<FeTaperedCapsuleRigid_t>
    constexpr std::ptrdiff_t m_SphereRigids = 0x2E8; // CUtlVector<FeSphereRigid_t>
    constexpr std::ptrdiff_t m_WorldCollisionNodes = 0x300; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeParents = 0x318; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeCollisionMasks = 0x330; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_TreeChildren = 0x348; // CUtlVector<FeTreeChildren_t>
    constexpr std::ptrdiff_t m_FreeNodes = 0x360; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_FitMatrices = 0x378; // CUtlVector<FeFitMatrix_t>
    constexpr std::ptrdiff_t m_FitWeights = 0x390; // CUtlVector<FeFitWeight_t>
    constexpr std::ptrdiff_t m_ReverseOffsets = 0x3A8; // CUtlVector<FeNodeReverseOffset_t>
    constexpr std::ptrdiff_t m_AnimStrayRadii = 0x3C0; // CUtlVector<FeAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_SimdAnimStrayRadii = 0x3D8; // CUtlVector<FeSimdAnimStrayRadius_t>
    constexpr std::ptrdiff_t m_KelagerBends = 0x3F0; // CUtlVector<FeKelagerBend2_t>
    constexpr std::ptrdiff_t m_CtrlSoftOffsets = 0x408; // CUtlVector<FeCtrlSoftOffset_t>
    constexpr std::ptrdiff_t m_JiggleBones = 0x420; // CUtlVector<CFeIndexedJiggleBone>
    constexpr std::ptrdiff_t m_SourceElems = 0x438; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_GoalDampedSpringIntegrators = 0x450; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_Tris = 0x468; // CUtlVector<FeTri_t>
    constexpr std::ptrdiff_t m_nTriCount1 = 0x480; // uint16_t
    constexpr std::ptrdiff_t m_nTriCount2 = 0x482; // uint16_t
    constexpr std::ptrdiff_t m_nReservedUint8 = 0x484; // uint8_t
    constexpr std::ptrdiff_t m_nExtraPressureIterations = 0x485; // uint8_t
    constexpr std::ptrdiff_t m_nExtraGoalIterations = 0x486; // uint8_t
    constexpr std::ptrdiff_t m_nExtraIterations = 0x487; // uint8_t
    constexpr std::ptrdiff_t m_BoxRigids = 0x488; // CUtlVector<FeBoxRigid_t>
    constexpr std::ptrdiff_t m_DynNodeVertexSet = 0x4A0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexSetNames = 0x4B8; // CUtlVector<uint32_t>
    constexpr std::ptrdiff_t m_RigidColliderPriorities = 0x4D0; // CUtlVector<FeRigidColliderIndices_t>
    constexpr std::ptrdiff_t m_MorphLayers = 0x4E8; // CUtlVector<FeMorphLayerDepr_t>
    constexpr std::ptrdiff_t m_MorphSetData = 0x500; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_VertexMaps = 0x518; // CUtlVector<FeVertexMapDesc_t>
    constexpr std::ptrdiff_t m_VertexMapValues = 0x530; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_Effects = 0x548; // CUtlVector<FeEffectDesc_t>
    constexpr std::ptrdiff_t m_LockToParent = 0x560; // CUtlVector<FeCtrlOffset_t>
    constexpr std::ptrdiff_t m_LockToGoal = 0x578; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_DynNodeWindBases = 0x590; // CUtlVector<FeNodeWindBase_t>
    constexpr std::ptrdiff_t m_flInternalPressure = 0x5A8; // float
    constexpr std::ptrdiff_t m_flDefaultTimeDilation = 0x5AC; // float
    constexpr std::ptrdiff_t m_flWindage = 0x5B0; // float
    constexpr std::ptrdiff_t m_flWindDrag = 0x5B4; // float
    constexpr std::ptrdiff_t m_flDefaultSurfaceStretch = 0x5B8; // float
    constexpr std::ptrdiff_t m_flDefaultThreadStretch = 0x5BC; // float
    constexpr std::ptrdiff_t m_flDefaultGravityScale = 0x5C0; // float
    constexpr std::ptrdiff_t m_flDefaultVelAirDrag = 0x5C4; // float
    constexpr std::ptrdiff_t m_flDefaultExpAirDrag = 0x5C8; // float
    constexpr std::ptrdiff_t m_flDefaultVelQuadAirDrag = 0x5CC; // float
    constexpr std::ptrdiff_t m_flDefaultExpQuadAirDrag = 0x5D0; // float
    constexpr std::ptrdiff_t m_flRodVelocitySmoothRate = 0x5D4; // float
    constexpr std::ptrdiff_t m_flQuadVelocitySmoothRate = 0x5D8; // float
    constexpr std::ptrdiff_t m_flAddWorldCollisionRadius = 0x5DC; // float
    constexpr std::ptrdiff_t m_flDefaultVolumetricSolveAmount = 0x5E0; // float
    constexpr std::ptrdiff_t m_nRodVelocitySmoothIterations = 0x5E4; // uint16_t
    constexpr std::ptrdiff_t m_nQuadVelocitySmoothIterations = 0x5E6; // uint16_t
}

namespace RnBlendVertex_t {
    constexpr std::ptrdiff_t m_nWeight0 = 0x0; // uint16_t
    constexpr std::ptrdiff_t m_nIndex0 = 0x2; // uint16_t
    constexpr std::ptrdiff_t m_nWeight1 = 0x4; // uint16_t
    constexpr std::ptrdiff_t m_nIndex1 = 0x6; // uint16_t
    constexpr std::ptrdiff_t m_nWeight2 = 0x8; // uint16_t
    constexpr std::ptrdiff_t m_nIndex2 = 0xA; // uint16_t
    constexpr std::ptrdiff_t m_nFlags = 0xC; // uint16_t
    constexpr std::ptrdiff_t m_nTargetIndex = 0xE; // uint16_t
}

namespace RnBodyDesc_t {
    constexpr std::ptrdiff_t m_sDebugName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_vPosition = 0x8; // Vector
    constexpr std::ptrdiff_t m_qOrientation = 0x14; // QuaternionStorage
    constexpr std::ptrdiff_t m_vLinearVelocity = 0x24; // Vector
    constexpr std::ptrdiff_t m_vAngularVelocity = 0x30; // Vector
    constexpr std::ptrdiff_t m_vLocalMassCenter = 0x3C; // Vector
    constexpr std::ptrdiff_t m_LocalInertiaInv = 0x48; // Vector[3]
    constexpr std::ptrdiff_t m_flMassInv = 0x6C; // float
    constexpr std::ptrdiff_t m_flGameMass = 0x70; // float
    constexpr std::ptrdiff_t m_flInertiaScaleInv = 0x74; // float
    constexpr std::ptrdiff_t m_flLinearDamping = 0x78; // float
    constexpr std::ptrdiff_t m_flAngularDamping = 0x7C; // float
    constexpr std::ptrdiff_t m_flLinearDrag = 0x80; // float
    constexpr std::ptrdiff_t m_flAngularDrag = 0x84; // float
    constexpr std::ptrdiff_t m_flLinearBuoyancyDrag = 0x88; // float
    constexpr std::ptrdiff_t m_flAngularBuoyancyDrag = 0x8C; // float
    constexpr std::ptrdiff_t m_vLastAwakeForceAccum = 0x90; // Vector
    constexpr std::ptrdiff_t m_vLastAwakeTorqueAccum = 0x9C; // Vector
    constexpr std::ptrdiff_t m_flBuoyancyFactor = 0xA8; // float
    constexpr std::ptrdiff_t m_flGravityScale = 0xAC; // float
    constexpr std::ptrdiff_t m_flTimeScale = 0xB0; // float
    constexpr std::ptrdiff_t m_nBodyType = 0xB4; // int32_t
    constexpr std::ptrdiff_t m_nGameIndex = 0xB8; // uint32_t
    constexpr std::ptrdiff_t m_nGameFlags = 0xBC; // uint32_t
    constexpr std::ptrdiff_t m_nMinVelocityIterations = 0xC0; // int8_t
    constexpr std::ptrdiff_t m_nMinPositionIterations = 0xC1; // int8_t
    constexpr std::ptrdiff_t m_nMassPriority = 0xC2; // int8_t
    constexpr std::ptrdiff_t m_bEnabled = 0xC3; // bool
    constexpr std::ptrdiff_t m_bSleeping = 0xC4; // bool
    constexpr std::ptrdiff_t m_bIsContinuousEnabled = 0xC5; // bool
    constexpr std::ptrdiff_t m_bDragEnabled = 0xC6; // bool
    constexpr std::ptrdiff_t m_bBuoyancyDragEnabled = 0xC7; // bool
    constexpr std::ptrdiff_t m_bGravityDisabled = 0xC8; // bool
    constexpr std::ptrdiff_t m_bSpeculativeEnabled = 0xC9; // bool
    constexpr std::ptrdiff_t m_bHasShadowController = 0xCA; // bool
}

namespace RnCapsuleDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Capsule = 0x10; // RnCapsule_t
}

namespace RnCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
}

namespace RnFace_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnHalfEdge_t {
    constexpr std::ptrdiff_t m_nNext = 0x0; // uint8_t
    constexpr std::ptrdiff_t m_nTwin = 0x1; // uint8_t
    constexpr std::ptrdiff_t m_nOrigin = 0x2; // uint8_t
    constexpr std::ptrdiff_t m_nFace = 0x3; // uint8_t
}

namespace RnHullDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Hull = 0x10; // RnHull_t
}

namespace RnHull_t {
    constexpr std::ptrdiff_t m_vCentroid = 0x0; // Vector
    constexpr std::ptrdiff_t m_flMaxAngularRadius = 0xC; // float
    constexpr std::ptrdiff_t m_Bounds = 0x10; // AABB_t
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x28; // Vector
    constexpr std::ptrdiff_t m_MassProperties = 0x34; // matrix3x4_t
    constexpr std::ptrdiff_t m_flVolume = 0x64; // float
    constexpr std::ptrdiff_t m_Vertices = 0x68; // CUtlVector<RnVertex_t>
    constexpr std::ptrdiff_t m_VertexPositions = 0x80; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_Edges = 0x98; // CUtlVector<RnHalfEdge_t>
    constexpr std::ptrdiff_t m_Faces = 0xB0; // CUtlVector<RnFace_t>
    constexpr std::ptrdiff_t m_FacePlanes = 0xC8; // CUtlVector<RnPlane_t>
    constexpr std::ptrdiff_t m_nFlags = 0xE0; // uint32_t
    constexpr std::ptrdiff_t m_pRegionSVM = 0xE8; // CRegionSVM*
}

namespace RnMeshDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Mesh = 0x10; // RnMesh_t
}

namespace RnMesh_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_vMax = 0xC; // Vector
    constexpr std::ptrdiff_t m_Nodes = 0x18; // CUtlVector<RnNode_t>
    constexpr std::ptrdiff_t m_Vertices = 0x30; // CUtlVectorSIMDPaddedVector
    constexpr std::ptrdiff_t m_Triangles = 0x48; // CUtlVector<RnTriangle_t>
    constexpr std::ptrdiff_t m_Wings = 0x60; // CUtlVector<RnWing_t>
    constexpr std::ptrdiff_t m_Materials = 0x78; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_vOrthographicAreas = 0x90; // Vector
    constexpr std::ptrdiff_t m_nFlags = 0x9C; // uint32_t
    constexpr std::ptrdiff_t m_nDebugFlags = 0xA0; // uint32_t
}

namespace RnNode_t {
    constexpr std::ptrdiff_t m_vMin = 0x0; // Vector
    constexpr std::ptrdiff_t m_nChildren = 0xC; // uint32_t
    constexpr std::ptrdiff_t m_vMax = 0x10; // Vector
    constexpr std::ptrdiff_t m_nTriangleOffset = 0x1C; // uint32_t
}

namespace RnPlane_t {
    constexpr std::ptrdiff_t m_vNormal = 0x0; // Vector
    constexpr std::ptrdiff_t m_flOffset = 0xC; // float
}

namespace RnShapeDesc_t {
    constexpr std::ptrdiff_t m_nCollisionAttributeIndex = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nSurfacePropertyIndex = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_UserFriendlyName = 0x8; // CUtlString
}

namespace RnSoftbodyCapsule_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector[2]
    constexpr std::ptrdiff_t m_flRadius = 0x18; // float
    constexpr std::ptrdiff_t m_nParticle = 0x1C; // uint16_t[2]
}

namespace RnSoftbodyParticle_t {
    constexpr std::ptrdiff_t m_flMassInv = 0x0; // float
}

namespace RnSoftbodySpring_t {
    constexpr std::ptrdiff_t m_nParticle = 0x0; // uint16_t[2]
    constexpr std::ptrdiff_t m_flLength = 0x4; // float
}

namespace RnSphereDesc_t { // RnShapeDesc_t
    constexpr std::ptrdiff_t m_Sphere = 0x10; // RnSphere_t
}

namespace RnSphere_t {
    constexpr std::ptrdiff_t m_vCenter = 0x0; // Vector
    constexpr std::ptrdiff_t m_flRadius = 0xC; // float
}

namespace RnTriangle_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace RnVertex_t {
    constexpr std::ptrdiff_t m_nEdge = 0x0; // uint8_t
}

namespace RnWing_t {
    constexpr std::ptrdiff_t m_nIndex = 0x0; // int32_t[3]
}

namespace VertexPositionColor_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
}

namespace VertexPositionNormal_t {
    constexpr std::ptrdiff_t m_vPosition = 0x0; // Vector
    constexpr std::ptrdiff_t m_vNormal = 0xC; // Vector
}

namespace constraint_axislimit_t {
    constexpr std::ptrdiff_t flMinRotation = 0x0; // float
    constexpr std::ptrdiff_t flMaxRotation = 0x4; // float
    constexpr std::ptrdiff_t flMotorTargetAngSpeed = 0x8; // float
    constexpr std::ptrdiff_t flMotorMaxTorque = 0xC; // float
}

namespace constraint_breakableparams_t {
    constexpr std::ptrdiff_t strength = 0x0; // float
    constexpr std::ptrdiff_t forceLimit = 0x4; // float
    constexpr std::ptrdiff_t torqueLimit = 0x8; // float
    constexpr std::ptrdiff_t bodyMassScale = 0xC; // float[2]
    constexpr std::ptrdiff_t isActive = 0x14; // bool
}

namespace constraint_hingeparams_t {
    constexpr std::ptrdiff_t worldPosition = 0x0; // Vector
    constexpr std::ptrdiff_t worldAxisDirection = 0xC; // Vector
    constexpr std::ptrdiff_t hingeAxis = 0x18; // constraint_axislimit_t
    constexpr std::ptrdiff_t constraint = 0x28; // constraint_breakableparams_t
}

namespace vphysics_save_cphysicsbody_t { // RnBodyDesc_t
    constexpr std::ptrdiff_t m_nOldPointer = 0xD0; // uint64_t
}
```

`HPCS2/offset/worldrenderer.dll.hpp`:

```hpp
/*
 * Created using https://github.com/a2x/cs2-dumper
 * Wed, 22 Nov 2023 19:35:51 +0000
 */

#pragma once

#include <cstddef>

namespace AggregateLODSetup_t {
    constexpr std::ptrdiff_t m_vLODOrigin = 0x0; // Vector
    constexpr std::ptrdiff_t m_fMaxObjectScale = 0xC; // float
    constexpr std::ptrdiff_t m_fSwitchDistances = 0x10; // CUtlVectorFixedGrowable<float>
}

namespace AggregateMeshInfo_t {
    constexpr std::ptrdiff_t m_nVisClusterMemberOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nVisClusterMemberCount = 0x4; // uint8_t
    constexpr std::ptrdiff_t m_bHasTransform = 0x5; // bool
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x6; // int16_t
    constexpr std::ptrdiff_t m_nLODSetupIndex = 0x8; // int16_t
    constexpr std::ptrdiff_t m_nLODGroupMask = 0xA; // uint8_t
    constexpr std::ptrdiff_t m_vTintColor = 0xB; // Color
    constexpr std::ptrdiff_t m_objectFlags = 0x10; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x14; // int32_t
}

namespace AggregateSceneObject_t {
    constexpr std::ptrdiff_t m_allFlags = 0x0; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_anyFlags = 0x4; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x8; // int16_t
    constexpr std::ptrdiff_t m_aggregateMeshes = 0x10; // CUtlVector<AggregateMeshInfo_t>
    constexpr std::ptrdiff_t m_lodSetups = 0x28; // CUtlVector<AggregateLODSetup_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x40; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_fragmentTransforms = 0x58; // CUtlVector<matrix3x4_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x70; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace BakedLightingInfo_t {
    constexpr std::ptrdiff_t m_nLightmapVersionNumber = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLightmapGameVersionNumber = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_bHasLightmaps = 0x10; // bool
    constexpr std::ptrdiff_t m_lightMaps = 0x18; // CUtlVector<CStrongHandle<InfoForResourceTypeCTextureBase>>
}

namespace BaseSceneObjectOverride_t {
    constexpr std::ptrdiff_t m_nSceneObjectIndex = 0x0; // uint32_t
}

namespace CEntityComponent {
}

namespace CEntityIdentity {
    constexpr std::ptrdiff_t m_nameStringableIndex = 0x14; // int32_t
    constexpr std::ptrdiff_t m_name = 0x18; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_designerName = 0x20; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_flags = 0x30; // uint32_t
    constexpr std::ptrdiff_t m_worldGroupId = 0x38; // WorldGroupId_t
    constexpr std::ptrdiff_t m_fDataObjectTypes = 0x3C; // uint32_t
    constexpr std::ptrdiff_t m_PathIndex = 0x40; // ChangeAccessorFieldPathIndex_t
    constexpr std::ptrdiff_t m_pPrev = 0x58; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNext = 0x60; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pPrevByClass = 0x68; // CEntityIdentity*
    constexpr std::ptrdiff_t m_pNextByClass = 0x70; // CEntityIdentity*
}

namespace CEntityInstance {
    constexpr std::ptrdiff_t m_iszPrivateVScripts = 0x8; // CUtlSymbolLarge
    constexpr std::ptrdiff_t m_pEntity = 0x10; // CEntityIdentity*
    constexpr std::ptrdiff_t m_CScriptComponent = 0x28; // CScriptComponent*
}

namespace CScriptComponent { // CEntityComponent
    constexpr std::ptrdiff_t m_scriptClassName = 0x30; // CUtlSymbolLarge
}

namespace CVoxelVisibility {
    constexpr std::ptrdiff_t m_nBaseClusterCount = 0x40; // uint32_t
    constexpr std::ptrdiff_t m_nPVSBytesPerCluster = 0x44; // uint32_t
    constexpr std::ptrdiff_t m_vMinBounds = 0x48; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x54; // Vector
    constexpr std::ptrdiff_t m_flGridSize = 0x60; // float
    constexpr std::ptrdiff_t m_nSkyVisibilityCluster = 0x64; // uint32_t
    constexpr std::ptrdiff_t m_nSunVisibilityCluster = 0x68; // uint32_t
    constexpr std::ptrdiff_t m_NodeBlock = 0x6C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_RegionBlock = 0x74; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClusterListBlock = 0x7C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_EnclosedClustersBlock = 0x84; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_MasksBlock = 0x8C; // VoxelVisBlockOffset_t
    constexpr std::ptrdiff_t m_nVisBlocks = 0x94; // VoxelVisBlockOffset_t
}

namespace ClutterSceneObject_t {
    constexpr std::ptrdiff_t m_Bounds = 0x0; // AABB_t
    constexpr std::ptrdiff_t m_flags = 0x18; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_nLayer = 0x1C; // int16_t
    constexpr std::ptrdiff_t m_instancePositions = 0x20; // CUtlVector<Vector>
    constexpr std::ptrdiff_t m_instanceScales = 0x50; // CUtlVector<float>
    constexpr std::ptrdiff_t m_instanceTintSrgb = 0x68; // CUtlVector<Color>
    constexpr std::ptrdiff_t m_tiles = 0x80; // CUtlVector<ClutterTile_t>
    constexpr std::ptrdiff_t m_renderableModel = 0x98; // CStrongHandle<InfoForResourceTypeCModel>
}

namespace ClutterTile_t {
    constexpr std::ptrdiff_t m_nFirstInstance = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nLastInstance = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_BoundsWs = 0x8; // AABB_t
}

namespace EntityIOConnectionData_t {
    constexpr std::ptrdiff_t m_outputName = 0x0; // CUtlString
    constexpr std::ptrdiff_t m_targetType = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_targetName = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_inputName = 0x18; // CUtlString
    constexpr std::ptrdiff_t m_overrideParam = 0x20; // CUtlString
    constexpr std::ptrdiff_t m_flDelay = 0x28; // float
    constexpr std::ptrdiff_t m_nTimesToFire = 0x2C; // int32_t
}

namespace EntityKeyValueData_t {
    constexpr std::ptrdiff_t m_connections = 0x8; // CUtlVector<EntityIOConnectionData_t>
    constexpr std::ptrdiff_t m_keyValuesData = 0x20; // CUtlBinaryBlock
}

namespace ExtraVertexStreamOverride_t { // BaseSceneObjectOverride_t
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_nAdditionalMeshDrawPrimitiveFlags = 0xC; // MeshDrawPrimitiveFlags_t
    constexpr std::ptrdiff_t m_extraBufferBinding = 0x10; // CRenderBufferBinding
}

namespace InfoForResourceTypeVMapResourceData_t {
}

namespace InfoOverlayData_t {
    constexpr std::ptrdiff_t m_transform = 0x0; // matrix3x4_t
    constexpr std::ptrdiff_t m_flWidth = 0x30; // float
    constexpr std::ptrdiff_t m_flHeight = 0x34; // float
    constexpr std::ptrdiff_t m_flDepth = 0x38; // float
    constexpr std::ptrdiff_t m_vUVStart = 0x3C; // Vector2D
    constexpr std::ptrdiff_t m_vUVEnd = 0x44; // Vector2D
    constexpr std::ptrdiff_t m_pMaterial = 0x50; // CStrongHandle<InfoForResourceTypeIMaterial2>
    constexpr std::ptrdiff_t m_nRenderOrder = 0x58; // int32_t
    constexpr std::ptrdiff_t m_vTintColor = 0x5C; // Vector4D
    constexpr std::ptrdiff_t m_nSequenceOverride = 0x6C; // int32_t
}

namespace MaterialOverride_t { // BaseSceneObjectOverride_t
    constexpr std::ptrdiff_t m_nSubSceneObject = 0x4; // uint32_t
    constexpr std::ptrdiff_t m_nDrawCallIndex = 0x8; // uint32_t
    constexpr std::ptrdiff_t m_pMaterial = 0x10; // CStrongHandle<InfoForResourceTypeIMaterial2>
}

namespace NodeData_t {
    constexpr std::ptrdiff_t m_nParent = 0x0; // int32_t
    constexpr std::ptrdiff_t m_vOrigin = 0x4; // Vector
    constexpr std::ptrdiff_t m_vMinBounds = 0x10; // Vector
    constexpr std::ptrdiff_t m_vMaxBounds = 0x1C; // Vector
    constexpr std::ptrdiff_t m_flMinimumDistance = 0x28; // float
    constexpr std::ptrdiff_t m_ChildNodeIndices = 0x30; // CUtlVector<int32_t>
    constexpr std::ptrdiff_t m_worldNodePrefix = 0x48; // CUtlString
}

namespace PermEntityLumpData_t {
    constexpr std::ptrdiff_t m_name = 0x8; // CUtlString
    constexpr std::ptrdiff_t m_hammerUniqueId = 0x10; // CUtlString
    constexpr std::ptrdiff_t m_childLumps = 0x18; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
    constexpr std::ptrdiff_t m_entityKeyValues = 0x30; // CUtlLeanVector<EntityKeyValueData_t>
}

namespace SceneObject_t {
    constexpr std::ptrdiff_t m_nObjectID = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_vTransform = 0x4; // Vector4D[3]
    constexpr std::ptrdiff_t m_flFadeStartDistance = 0x34; // float
    constexpr std::ptrdiff_t m_flFadeEndDistance = 0x38; // float
    constexpr std::ptrdiff_t m_vTintColor = 0x3C; // Vector4D
    constexpr std::ptrdiff_t m_skin = 0x50; // CUtlString
    constexpr std::ptrdiff_t m_nObjectTypeFlags = 0x58; // ObjectTypeFlags_t
    constexpr std::ptrdiff_t m_vLightingOrigin = 0x5C; // Vector
    constexpr std::ptrdiff_t m_nOverlayRenderOrder = 0x68; // int16_t
    constexpr std::ptrdiff_t m_nLODOverride = 0x6A; // int16_t
    constexpr std::ptrdiff_t m_nCubeMapPrecomputedHandshake = 0x6C; // int32_t
    constexpr std::ptrdiff_t m_nLightProbeVolumePrecomputedHandshake = 0x70; // int32_t
    constexpr std::ptrdiff_t m_renderableModel = 0x78; // CStrongHandle<InfoForResourceTypeCModel>
    constexpr std::ptrdiff_t m_renderable = 0x80; // CStrongHandle<InfoForResourceTypeCRenderMesh>
}

namespace VMapResourceData_t {
}

namespace VoxelVisBlockOffset_t {
    constexpr std::ptrdiff_t m_nOffset = 0x0; // uint32_t
    constexpr std::ptrdiff_t m_nElementCount = 0x4; // uint32_t
}

namespace WorldBuilderParams_t {
    constexpr std::ptrdiff_t m_flMinDrawVolumeSize = 0x0; // float
    constexpr std::ptrdiff_t m_bBuildBakedLighting = 0x4; // bool
    constexpr std::ptrdiff_t m_vLightmapUvScale = 0x8; // Vector2D
    constexpr std::ptrdiff_t m_nCompileTimestamp = 0x10; // uint64_t
    constexpr std::ptrdiff_t m_nCompileFingerprint = 0x18; // uint64_t
}

namespace WorldNodeOnDiskBufferData_t {
    constexpr std::ptrdiff_t m_nElementCount = 0x0; // int32_t
    constexpr std::ptrdiff_t m_nElementSizeInBytes = 0x4; // int32_t
    constexpr std::ptrdiff_t m_inputLayoutFields = 0x8; // CUtlVector<RenderInputLayoutField_t>
    constexpr std::ptrdiff_t m_pData = 0x20; // CUtlVector<uint8_t>
}

namespace WorldNode_t {
    constexpr std::ptrdiff_t m_sceneObjects = 0x0; // CUtlVector<SceneObject_t>
    constexpr std::ptrdiff_t m_infoOverlays = 0x18; // CUtlVector<InfoOverlayData_t>
    constexpr std::ptrdiff_t m_visClusterMembership = 0x30; // CUtlVector<uint16_t>
    constexpr std::ptrdiff_t m_aggregateSceneObjects = 0x48; // CUtlVector<AggregateSceneObject_t>
    constexpr std::ptrdiff_t m_clutterSceneObjects = 0x60; // CUtlVector<ClutterSceneObject_t>
    constexpr std::ptrdiff_t m_extraVertexStreamOverrides = 0x78; // CUtlVector<ExtraVertexStreamOverride_t>
    constexpr std::ptrdiff_t m_materialOverrides = 0x90; // CUtlVector<MaterialOverride_t>
    constexpr std::ptrdiff_t m_extraVertexStreams = 0xA8; // CUtlVector<WorldNodeOnDiskBufferData_t>
    constexpr std::ptrdiff_t m_layerNames = 0xC0; // CUtlVector<CUtlString>
    constexpr std::ptrdiff_t m_sceneObjectLayerIndices = 0xD8; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_overlayLayerIndices = 0xF0; // CUtlVector<uint8_t>
    constexpr std::ptrdiff_t m_grassFileName = 0x108; // CUtlString
    constexpr std::ptrdiff_t m_nodeLightingInfo = 0x110; // BakedLightingInfo_t
}

namespace World_t {
    constexpr std::ptrdiff_t m_builderParams = 0x0; // WorldBuilderParams_t
    constexpr std::ptrdiff_t m_worldNodes = 0x20; // CUtlVector<NodeData_t>
    constexpr std::ptrdiff_t m_worldLightingInfo = 0x38; // BakedLightingInfo_t
    constexpr std::ptrdiff_t m_entityLumps = 0x68; // CUtlVector<CStrongHandleCopyable<InfoForResourceTypeCEntityLump>>
}
```

`HPCS2/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by HPCS2.rc

// 下一個新增物件的預設值
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`HPCS2/resource1.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by HPCS21.rc

// 下一個新增物件的預設值
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`HPCS2/resource2.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 產生的 Include 檔案。
// 由 HPCS2.rc 使用
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`HPCS2/x64/Release/HPCS2.Build.CppClean.log`:

```log
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\vc142.pdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\source.obj
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\memory.obj
g:\halfpeoplestudioc++ porject\hpcs2\x64\release\hpcs2.exe
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.ipdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.iobj
g:\halfpeoplestudioc++ porject\hpcs2\x64\release\hpcs2.pdb
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.command.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.read.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\cl.write.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.command.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.read.1.tlog
g:\halfpeoplestudioc++ porject\hpcs2\hpcs2\x64\release\hpcs2.tlog\link.write.1.tlog

```

`HPCS2/x64/Release/HPCS2.exe.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>G:\HalfPeopleStudioC++ Porject\HPCS2\x64\Release\HPCS2.exe</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`HPCS2/x64/Release/HPCS2.log`:

```log
  正在產生程式碼
  2 of 1334 functions ( 0.1%) were compiled, the rest were copied from previous compilation.
    0 functions were new in current compilation
    2 functions had inline decision re-evaluated but remain unchanged
  已完成程式碼產生
  HPCS2.vcxproj -> G:\HalfPeopleStudioC++ Porject\HPCS2\x64\Release\HPCS2.exe

```

`HPCS2/x64/Release/HPCS2.tlog/CL.command.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /permissive- /Zc:wchar_t /Zc:forScope /Zc:inline /std:c++20 /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC142.PDB" /external:W3 /Gd /TP /FC G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /permissive- /Zc:wchar_t /Zc:forScope /Zc:inline /std:c++20 /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC142.PDB" /external:W3 /Gd /TP /FC G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP

```

`HPCS2/x64/Release/HPCS2.tlog/CL.read.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VECTOR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XMEMORY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDINT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\FLOAT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISA_AVAILABILITY.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTDDEF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDDEF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTR1COMMON
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NEW
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CRTDBG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MALLOC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XUTILITY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTRING
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UTILITY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCEPTS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMPARE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\BIT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TUPLE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XPOLYMORPHIC_ALLOCATOR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TLHELP32.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STRING
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTRING
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSFWD
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CCTYPE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OSTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCNUM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CMATH
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ITERATOR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STREAMBUF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SHARE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CERRNO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDEXCEPT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XERRC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ATOMIC
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC_WAIT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTHREADS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTIMEC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\TIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCALE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MEMORY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPEINFO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XFACET
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\LOCALE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PSAPI.H
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\HANDLE_HIJACK.HPP
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1028\CLUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\OFFSET\OFFSETS.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDDEF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTR1COMMON
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\OFFSET\CLIENT.DLL.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\IME_CMODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMUTIL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OLECTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\OCIDL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MALLOC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDINT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTDDEF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMDEFSP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\TLHELP32.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OSTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCNUM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CMATH
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CRTDBG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XUTILITY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTRING
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UTILITY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCEPTS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMPARE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\BIT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISA_AVAILABILITY.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\FLOAT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ITERATOR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IOSFWD
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STREAMBUF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SHARE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CERRNO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDEXCEPT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTRING
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XMEMORY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NEW
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TUPLE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XPOLYMORPHIC_ALLOCATOR.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XERRC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ATOMIC
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XATOMIC_WAIT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTHREADS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTIMEC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\TIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCALE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MEMORY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPEINFO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XFACET
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCINFO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CCTYPE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\LOCALE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\THREAD
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CHRONO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\RATIO
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\__MSVC_TZDB.HPP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ALGORITHM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\FORWARD_LIST
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\OPTIONAL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSMF_CONTROL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SSTREAM
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STRING
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VECTOR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XLOCTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\PROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STARTUP.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STARTUP.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STOP_TOKEN
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NUMBERS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MAP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTREE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XNODE_HANDLE.H
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.HPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UM\PSAPI.H
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\API\INI.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UNORDERED_MAP
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XHASH
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIST
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XBIT_OPS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\FSTREAM

```

`HPCS2/x64/Release/HPCS2.tlog/CL.write.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP|G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\MEMORY.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\SOURCE.CPP
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\VC142.PDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ

```

`HPCS2/x64/Release/HPCS2.tlog/HPCS2.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v142:VCToolArchitecture=Native32Bit:VCToolsVersion=14.29.30133:VCServicingVersionMFC=14.29.30136:VCServicingVersionATL=14.29.30136:VCServicingVersionCrtHeaders=14.29.30136:TargetPlatformVersion=10.0.19041.0:
Release|x64|G:\HalfPeopleStudioC++ Porject\HPCS2\|

```

`HPCS2/x64/Release/HPCS2.tlog/link.command.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ|G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
/OUT:"G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\X64\RELEASE\HPCS2.EXE" /INCREMENTAL:NO /NOLOGO KERNEL32.LIB USER32.LIB GDI32.LIB WINSPOOL.LIB COMDLG32.LIB ADVAPI32.LIB SHELL32.LIB OLE32.LIB OLEAUT32.LIB UUID.LIB ODBC32.LIB ODBCCP32.LIB /MANIFEST /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" /manifest:embed /DEBUG /PDB:"G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\X64\RELEASE\HPCS2.PDB" /SUBSYSTEM:CONSOLE /OPT:REF /OPT:ICF /LTCG:incremental /LTCGOUT:"X64\RELEASE\HPCS2.IOBJ" /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\X64\RELEASE\HPCS2.LIB" /MACHINE:X64 X64\RELEASE\MEMORY.OBJ
X64\RELEASE\SOURCE.OBJ

```

`HPCS2/x64/Release/HPCS2.tlog/link.read.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ|G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\KERNEL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\USER32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\GDI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\WINSPOOL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\COMDLG32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\ADVAPI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\SHELL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\OLE32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\OLEAUT32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\UUID.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\ODBC32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UM\X64\ODBCCP32.LIB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\C2.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\X64\MSVCPRT.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\X64\MSVCRT.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\X64\OLDNAMES.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\X64\COMSUPPW.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\X64\VCRUNTIME.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\UCRT\X64\UCRT.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1028\LINKUI.DLL
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\HPCS2.IPDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\HPCS2.IOBJ
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\CVTRES.EXE
C:\WINDOWS\SYSTEM32\TZRES.DLL

```

`HPCS2/x64/Release/HPCS2.tlog/link.write.1.tlog`:

```tlog
^G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\MEMORY.OBJ|G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\SOURCE.OBJ
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\X64\RELEASE\HPCS2.EXE
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\HPCS2.IPDB
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\HPCS2\X64\RELEASE\HPCS2.IOBJ
G:\HALFPEOPLESTUDIOC++ PORJECT\HPCS2\X64\RELEASE\HPCS2.PDB

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Half People

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
## NewUpdata By `banovers` [GitHub/banovers/csgo2-cheat](https://github.com/banovers/csgo2-cheat)

# HPCS2 - (HalfPeople CSGO 2 Hack Test)

Download : [Releases](https://github.com/Half-People/HPCS2/releases)

- The purpose of this project is only to learn cheating and anti-cheating. How you use this project has nothing to do with the author.
- 100% not VAC (this hack only read)
- maby you like this video you can give me like or add my dc : )
- The purpose of this project is only to learn cheating and anti-cheating. 
- How you use this project has nothing to do with the author.

video : 
[YouTube](https://www.youtube.com/watch?v=pVb7yktltYQ&t=106s)
Discord : 
[Discord](https://discord.gg/SsqWQSqrkK)

![image](https://github.com/Half-People/CS2H/assets/56476339/1072eac6-8723-4f55-9a38-b679fac7077a)

```

`x64/Release/Configuration.ini`:

```ini
[function]
brecoilcontrol=0
aimbot=1
drawesp=1
[aimbot]
aimbothot=0
fov=10.000000
smoothing=1
aimteam=0
[esp]
show_extra=1
textsize=15
showbonedistance=1000
flag_render_distance=10
render_distance=-1
boomsize=100
```