Project Path: arc_AsenOsen_frida-stealth__18gascp

Source Tree:

```txt
arc_AsenOsen_frida-stealth__18gascp
├── README.md
├── frida-core
│   └── patch.patch
└── frida-gum
    └── patch.patch

```

`README.md`:

```md
# Stealth patch for Frida!

**FIRST OF ALL! Tired of Frida getting detected all the time?**  
Try [my revolutionary(duh) approach](https://github.com/AsenOsen/android-framework-jar-patching) based on injecting code into system Android libraries.  

The patch set was inspired by this repo - https://github.com/JsHookApp/Frida-Patchs. This patch hides most of frida traces in system:

- default port number changed
- unix socket names (named pipes) does not contain "frida" no more
- all thread names does not contain "frida" no more
- frida-gum main loop renamed
- GLib main loop renamed
- SELinux context names

# How to apply patch?

Get latest Frida version with all submodules:

```
git clone --recurse-submodules https://github.com/frida/frida.git
```

Apply patches:

```
cd frida/frida-core && git apply --reject --whitespace=fix ../../frida-core/patch.patch
cd frida/frida-gum && git apply --reject --whitespace=fix ../../frida-gum/patch.patch
```

# How to build Frida with patch? (Android Arm64 example)

1. Download Android NDK. Easiest way to do it - via Android Studio SDK Manager: pick the NDK version 25.2.9519653.
2. In root frida folder: 
	- Build: `ANDROID_NDK_ROOT="$ANDROID_HOME/ndk/25.2.9519653" make core-android-arm64` 
	- Run the script to hide frida symbols in compiled binaries: 
		- Install requirements: `pip install lief` 
		- Run `python src/anti-anti-frida.py PATH` for following `PATH` list (you may pass unneeded components):
			- Agent library: `build/tmp-android-arm64/frida-core/lib/agent/frida-agent.so`
			- Gadget library: `build/tmp-android-arm64/frida-core/lib/gadget/frida-gadget.so`
			- Frida Inject: `build/frida-android-arm64/bin/frida-inject`
			- Frida Portal: `build/frida-android-arm64/bin/frida-portal`
			- Frida Server: `build/frida-android-arm64/bin/frida-server`
	- Copy needed binaries to Android Device and enjoy the patch!

# Advices how to achive even more stealthy mode

1. Use ZygiskFrida(https://github.com/lico-n/ZygiskFrida) to avoid process being ptraced. Important notice: use this module for Kitsune Magisk (https://github.com/HuskyDG/magisk-files). Do not use ZygiskFrida with usual Magisk - module will not work.
2. When using ZygiskFrida, use patched `frida-gadget.so`!
3. Use frida scripts from this repo - https://github.com/apkunpacker/AntiFrida_Bypass - to hide any other possible traces of frida/magisk in memory.
4. Consider some uncommon techniques like [patching system libraries](https://github.com/AsenOsen/android-framework-jar-patching).

```

`frida-core/patch.patch`:

```patch
diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 00000000..9a874b57
Binary files /dev/null and b/.DS_Store differ
diff --git a/lib/agent/agent-glue.c b/lib/agent/agent-glue.c
index a8affbab..c8cc99d1 100644
--- a/lib/agent/agent-glue.c
+++ b/lib/agent/agent-glue.c
@@ -23,7 +23,7 @@ _frida_agent_environment_init (void)
     return;
   been_here = TRUE;
 #endif
-
+  
   gum_init_embedded ();
   gio_init ();
 
diff --git a/lib/agent/agent.vala b/lib/agent/agent.vala
index 44e37594..c92aa560 100644
--- a/lib/agent/agent.vala
+++ b/lib/agent/agent.vala
@@ -15,7 +15,7 @@ namespace Frida.Agent {
 		public static Runner shared_instance = null;
 		public static Mutex shared_mutex;
 		private static string? cached_agent_path = null;
-		private static Gum.MemoryRange cached_agent_range;
+		private static Gum.MemoryRange cached_agent_range; 
 
 		public string agent_parameters {
 			get;
@@ -335,7 +335,7 @@ namespace Frida.Agent {
 		}
 
 		private void keep_running_eternalized () {
-			agent_gthread = new Thread<bool> ("frida-eternal-agent", () => {
+			agent_gthread = new Thread<bool> ("banana-eternal-agent", () => {
 				var ignore_scope = new ThreadIgnoreScope (FRIDA_THREAD);
 
 				agent_tid = Gum.Process.get_current_thread_id ();
@@ -531,7 +531,7 @@ namespace Frida.Agent {
 					assert_not_reached ();
 				}
 			} else {
-				agent_gthread = new Thread<bool> ("frida-eternal-agent", () => {
+				agent_gthread = new Thread<bool> ("banana-eternal-agent", () => {
 					var ignore_scope = new ThreadIgnoreScope (FRIDA_THREAD);
 					run_after_transition ();
 					ignore_scope = null;
@@ -639,7 +639,7 @@ namespace Frida.Agent {
 					assert_not_reached ();
 				}
 			} else {
-				agent_gthread = new Thread<bool> ("frida-eternal-agent", () => {
+				agent_gthread = new Thread<bool> ("banana-eternal-agent", () => {
 					var ignore_scope = new ThreadIgnoreScope (FRIDA_THREAD);
 					run_after_transition ();
 					ignore_scope = null;
@@ -1399,7 +1399,7 @@ namespace Frida.Agent {
 
 				emulated_bridge_state = new BridgeState (parameters.str);
 
-				emulated_worker = new Thread<void> ("frida-agent-emulated", run_emulated_agent);
+				emulated_worker = new Thread<void> ("banana-agent-emulated", run_emulated_agent);
 
 				var connection = yield new DBusConnection (stream, ServerGuid.HOST_SESSION_SERVICE,
 					AUTHENTICATION_SERVER | AUTHENTICATION_ALLOW_ANONYMOUS, null, cancellable);
diff --git a/lib/base/p2p.vala b/lib/base/p2p.vala
index fcf93371..27584d10 100644
--- a/lib/base/p2p.vala
+++ b/lib/base/p2p.vala
@@ -1100,7 +1100,7 @@ namespace Frida {
 		string? result_cert_pem = null;
 		string? result_key_pem = null;
 
-		new Thread<bool> ("frida-generate-certificate", () => {
+		new Thread<bool> ("banana-generate-certificate", () => {
 			uint8[] local_cert_der;
 			string local_cert_pem;
 			string local_key_pem;
diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index 3695ba8c..02602abf 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -17,7 +17,7 @@ namespace Frida {
 			var request = new Json.Builder ();
 			request
 				.begin_array ()
-				.add_string_value ("frida:rpc")
+				.add_string_value ((string) GLib.Base64.decode("ZnJpZGE6cnBj="))
 				.add_string_value (request_id)
 				.add_string_value ("call")
 				.add_string_value (method)
@@ -70,7 +70,7 @@ namespace Frida {
 		}
 
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			if (json.index_of ((string) GLib.Base64.decode("ImZyaWRhOnJwYyI=")) == -1)
 				return false;
 
 			var parser = new Json.Parser ();
@@ -99,7 +99,7 @@ namespace Frida {
 				return false;
 
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null || type != (string) GLib.Base64.decode("ZnJpZGE6cnBj="))
 				return false;
 
 			var request_id_value = rpc_message.get_element (1);
diff --git a/lib/base/session.vala b/lib/base/session.vala
index eab36c49..bf61407f 100644
--- a/lib/base/session.vala
+++ b/lib/base/session.vala
@@ -292,7 +292,7 @@ namespace Frida {
 			var offer = PeerSessionDescription.parse (offer_sdp);
 
 			var agent = new Nice.Agent.full (dbus_context, Nice.Compatibility.RFC5245, ICE_TRICKLE);
-			agent.set_software ("Frida");
+			agent.set_software ("Banana");
 			agent.controlling_mode = false;
 			agent.ice_tcp = false;
 
@@ -2033,7 +2033,7 @@ namespace Frida {
 #endif
 
 	namespace ServerGuid {
-		public const string HOST_SESSION_SERVICE = "6769746875622e636f6d2f6672696461";
+		public const string HOST_SESSION_SERVICE = "851fa8de1f0a068701f5699c3e074ae6";
 	}
 
 	namespace ObjectPath {
diff --git a/lib/base/socket.vala b/lib/base/socket.vala
index 54fd477b..4e66ae7c 100644
--- a/lib/base/socket.vala
+++ b/lib/base/socket.vala
@@ -1,13 +1,13 @@
 namespace Frida {
-	public const uint16 DEFAULT_CONTROL_PORT = 27042;
-	public const uint16 DEFAULT_CLUSTER_PORT = 27052;
+	public const uint16 DEFAULT_CONTROL_PORT = 27043;
+	public const uint16 DEFAULT_CLUSTER_PORT = 27053;
 
 	public SocketConnectable parse_control_address (string? address, uint16 port = 0) throws Error {
-		return parse_socket_address (address, port, "127.0.0.1", DEFAULT_CONTROL_PORT);
+		return parse_socket_address (address, port, "0.0.0.0", DEFAULT_CONTROL_PORT);
 	}
 
 	public SocketConnectable parse_cluster_address (string? address, uint16 port = 0) throws Error {
-		return parse_socket_address (address, port, "127.0.0.1", DEFAULT_CLUSTER_PORT);
+		return parse_socket_address (address, port, "0.0.0.0", DEFAULT_CLUSTER_PORT);
 	}
 
 	public SocketConnectable parse_socket_address (string? address, uint16 port, string default_address,
@@ -104,7 +104,7 @@ namespace Frida {
 		var msg = new Soup.Message ("GET", uri);
 		Soup.websocket_client_prepare_handshake (msg, origin, null, null);
 		msg.request_headers.replace ("Host", canonical_host);
-		msg.request_headers.replace ("User-Agent", "Frida/" + _version_string ());
+		msg.request_headers.replace ("User-Agent", "Banana/" + _version_string ());
 		msg.request_headers.foreach ((name, val) => {
 			request.append (name + ": " + val + "\r\n");
 		});
@@ -374,7 +374,7 @@ namespace Frida {
 		}
 
 		private void on_asset_request (Soup.Server server, Soup.ServerMessage msg, string path, HashTable<string, string>? query) {
-			msg.get_response_headers ().replace ("Server", "Frida/" + _version_string ());
+			msg.get_response_headers ().replace ("Server", "Banana/" + _version_string ());
 
 			unowned string method = msg.get_method ();
 			if (method != "GET" && method != "HEAD") {
@@ -591,7 +591,7 @@ namespace Frida {
 <center><h1>301 Moved Permanently</h1></center>
 <hr><center>%s</center>
 </body>
-</html>""".printf ("Frida/" + _version_string ());
+</html>""".printf ("Banana/" + _version_string ());
 
 			if (msg.get_method () == "HEAD") {
 				var headers = msg.get_response_headers ();
diff --git a/lib/gadget/gadget-glue.c b/lib/gadget/gadget-glue.c
index 256b8d99..079945e8 100644
--- a/lib/gadget/gadget-glue.c
+++ b/lib/gadget/gadget-glue.c
@@ -106,7 +106,7 @@ frida_gadget_environment_init (void)
 
   worker_context = g_main_context_ref (g_main_context_default ());
   worker_loop = g_main_loop_new (worker_context, FALSE);
-  worker_thread = g_thread_new ("frida-gadget", run_worker_loop, NULL);
+  worker_thread = g_thread_new ("banana-gadget", run_worker_loop, NULL);
 }
 
 void
diff --git a/lib/gadget/gadget.vala b/lib/gadget/gadget.vala
index 1227833c..112091dd 100644
--- a/lib/gadget/gadget.vala
+++ b/lib/gadget/gadget.vala
@@ -650,7 +650,7 @@ namespace Frida.Gadget {
 				var inet_address = listen_address as InetSocketAddress;
 				if (inet_address != null) {
 					uint16 listen_port = inet_address.get_port ();
-					Environment.set_thread_name ("frida-gadget-tcp-%u".printf (listen_port));
+					Environment.set_thread_name ("banana-gadget-tcp-%u".printf (listen_port));
 					if (request != null) {
 						request.set_value (listen_port);
 					} else {
@@ -661,7 +661,7 @@ namespace Frida.Gadget {
 				} else {
 #if !WINDOWS
 					var unix_address = (UnixSocketAddress) listen_address;
-					Environment.set_thread_name ("frida-gadget-unix");
+					Environment.set_thread_name ("banana-gadget-unix");
 					if (request != null) {
 						request.set_value (0);
 					} else {
@@ -1778,8 +1778,8 @@ namespace Frida.Gadget {
 				}
 
 				uint pid = get_process_id ();
-				string identifier = "re.frida.Gadget";
-				string name = "Gadget";
+				string identifier = "re.banana.Gadget";
+				string name = "Banana";
 				var no_parameters = make_parameters_dict ();
 				this_app = HostApplicationInfo (identifier, name, pid, no_parameters);
 				this_process = HostProcessInfo (pid, name, no_parameters);
diff --git a/lib/pipe/pipe.vala b/lib/pipe/pipe.vala
index 58d064d8..2c0e0783 100644
--- a/lib/pipe/pipe.vala
+++ b/lib/pipe/pipe.vala
@@ -167,7 +167,7 @@ namespace Frida {
 
 					Posix.chmod (path, Posix.S_IRUSR | Posix.S_IWUSR | Posix.S_IRGRP | Posix.S_IWGRP | Posix.S_IROTH | Posix.S_IWOTH);
 #if ANDROID
-					SELinux.setfilecon (path, "u:object_r:frida_file:s0");
+					SELinux.setfilecon (path, "u:object_r:banana_file:s0");
 #endif
 
 					establish_server.begin (socket, server_address, promise, cancellable);
diff --git a/lib/selinux/patch.c b/lib/selinux/patch.c
index db631ffd..d4fb16ae 100644
--- a/lib/selinux/patch.c
+++ b/lib/selinux/patch.c
@@ -39,9 +39,9 @@ static gboolean frida_set_file_contents (const gchar * filename, const gchar * c
 static const FridaSELinuxRule frida_selinux_rules[] =
 {
   { { "domain", NULL }, "domain", "process", { "execmem", NULL } },
-  { { "domain", NULL }, "frida_file", "dir", { "search", NULL } },
-  { { "domain", NULL }, "frida_file", "file", { "open", "read", "getattr", "execute", "?map", NULL } },
-  { { "domain", NULL }, "frida_memfd", "file", { "open", "read", "write", "getattr", "execute", "?map", NULL } },
+  { { "domain", NULL }, "banana_file", "dir", { "search", NULL } },
+  { { "domain", NULL }, "banana_file", "file", { "open", "read", "getattr", "execute", "?map", NULL } },
+  { { "domain", NULL }, "banana_memfd", "file", { "open", "read", "write", "getattr", "execute", "?map", NULL } },
   { { "domain", NULL }, "shell_data_file", "dir", { "search", NULL } },
   { { "domain", NULL }, "zygote_exec", "file", { "execute", NULL } },
   { { "domain", NULL }, "$self", "process", { "sigchld", NULL } },
@@ -82,14 +82,14 @@ frida_selinux_patch_policy (void)
   res = policydb_load_isids (&db, &sidtab);
   g_assert (res == 0);
 
-  if (frida_ensure_type (&db, "frida_file", 2, "file_type", "mlstrustedobject", &error) == NULL)
+  if (frida_ensure_type (&db, "banana_file", 2, "file_type", "mlstrustedobject", &error) == NULL)
   {
     g_printerr ("Unable to add SELinux type: %s\n", error->message);
     g_clear_error (&error);
     goto beach;
   }
 
-  if (frida_ensure_type (&db, "frida_memfd", 2, "file_type", "mlstrustedobject", &error) == NULL)
+  if (frida_ensure_type (&db, "banana_memfd", 2, "file_type", "mlstrustedobject", &error) == NULL)
   {
     g_printerr ("Unable to add SELinux type: %s\n", error->message);
     g_clear_error (&error);
diff --git a/meson.build b/meson.build
index b96edc83..2716dc31 100644
--- a/meson.build
+++ b/meson.build
@@ -385,7 +385,7 @@ configure_file(
 
 add_project_arguments(
   '-include', 'config.h',
-  '-DG_LOG_DOMAIN="Frida"',
+  '-DG_LOG_DOMAIN="Banana"',
   '-DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_56',
   '-DG_DISABLE_DEPRECATED',
   language: c_languages)
diff --git a/server/server.vala b/server/server.vala
index 525c145e..83efc98b 100644
--- a/server/server.vala
+++ b/server/server.vala
@@ -1,7 +1,7 @@
 namespace Frida.Server {
 	private static Application application;
 
-	private const string DEFAULT_DIRECTORY = "re.frida.server";
+	private static string? DEFAULT_DIRECTORY = null;
 	private static bool output_version = false;
 	private static string? listen_address = null;
 	private static string? certpath = null;
@@ -50,6 +50,7 @@ namespace Frida.Server {
 	};
 
 	private static int main (string[] args) {
+		DEFAULT_DIRECTORY = GLib.Uuid.string_random();
 		Environment.init ();
 
 #if DARWIN
@@ -177,7 +178,7 @@ namespace Frida.Server {
 		Environment.configure ();
 
 #if DARWIN
-		var worker = new Thread<int> ("frida-server-main-loop", () => {
+		var worker = new Thread<int> ("banana-server-main-loop", () => {
 			var exit_code = run_application (endpoint_params, options, on_ready);
 
 			_stop_run_loop ();
diff --git a/src/agent-container.vala b/src/agent-container.vala
index a8db6b29..8ea740fa 100644
--- a/src/agent-container.vala
+++ b/src/agent-container.vala
@@ -25,7 +25,7 @@ namespace Frida {
 			assert (container.module != null);
 
 			void * main_func_symbol;
-			var main_func_found = container.module.symbol ("frida_agent_main", out main_func_symbol);
+			var main_func_found = container.module.symbol ("banana_main", out main_func_symbol);
 			assert (main_func_found);
 			container.main_impl = (AgentMainFunc) main_func_symbol;
 
@@ -100,7 +100,7 @@ namespace Frida {
 		}
 
 		private void start_worker_thread () {
-			thread = new Thread<bool> ("frida-agent-container", run);
+			thread = new Thread<bool> ("banana-container", run);
 		}
 
 		private void stop_worker_thread () {
diff --git a/src/anti-anti-frida.py b/src/anti-anti-frida.py
new file mode 100644
index 00000000..47e321f6
--- /dev/null
+++ b/src/anti-anti-frida.py
@@ -0,0 +1,41 @@
+import lief
+import sys
+import random
+import os
+
+def replacer(input_file):
+    print(f"[*] Patch frida-agent: {input_file}")
+    random_name = "".join(random.sample("ABCDEFGHIJKLMNO", 5))
+    print(f"[*] Patch `frida` to `{random_name}``")
+
+    binary = lief.parse(input_file)
+
+    if not binary:
+        exit()
+
+    for symbol in binary.symbols:
+        if symbol.name == "frida_agent_main":
+            print(symbol.name)
+            symbol.name = "banana_main"
+        
+        if "frida" in symbol.name:
+            symbol.name = symbol.name.replace("frida", random_name)
+            print(symbol.name)
+
+        if "FRIDA" in symbol.name:
+            print(symbol.name)
+            symbol.name = symbol.name.replace("FRIDA", random_name)
+
+    binary.write(input_file)
+    
+    # gum-js-loop thread
+    random_name = "".join(random.sample("abcdefghijklmn", 11))
+    print(f"[*] Patch `gum-js-loop` to `{random_name}`")
+    os.system(f"gsed -i s/gum-js-loop/{random_name}/g {input_file}")
+    
+    # gmain thread
+    random_name = "".join(random.sample("abcdefghijklmn", 5))
+    print(f"[*] Patch `gmain` to `{random_name}`")
+    os.system(f"gsed -i s/gmain/{random_name}/g {input_file}")
+
+replacer(sys.argv[1])
\ No newline at end of file
diff --git a/src/droidy/droidy-client.vala b/src/droidy/droidy-client.vala
index 0ed2edeb..5ab4c006 100644
--- a/src/droidy/droidy-client.vala
+++ b/src/droidy/droidy-client.vala
@@ -1013,7 +1013,7 @@ namespace Frida.Droidy {
 						case "OPEN":
 						case "CLSE":
 						case "WRTE":
-							throw new Error.PROTOCOL ("Unexpected command");
+							break;
 
 						default:
 							var length = parse_length (command_or_length);
diff --git a/src/droidy/injector.vala b/src/droidy/injector.vala
index f2acafb0..1463a529 100644
--- a/src/droidy/injector.vala
+++ b/src/droidy/injector.vala
@@ -81,7 +81,7 @@ namespace Frida.Droidy.Injector {
 			string so_path_app = "/data/data/" + package + "/gadget.so";
 			string config_path_shared = "/data/local/tmp/frida-gadget-" + instance_id + ".config";
 			string config_path_app = "/data/data/" + package + "/gadget.config";
-			string unix_socket_path = "frida:" + package;
+			string unix_socket_path = "banana:" + package;
 
 			bool waiting = false;
 			uint target_pid = 0;
diff --git a/src/embed-agent.sh b/src/embed-agent.sh
index 6a3bf9ed..2ee8ee0c 100755
--- a/src/embed-agent.sh
+++ b/src/embed-agent.sh
@@ -12,6 +12,7 @@ lipo=$9
 agent_dbghelp_prefix=${10}
 agent_symsrv_prefix=${11}
 
+custom_script="$output_dir/../../../../frida-core/src/anti-anti-frida.py"
 priv_dir="$output_dir/frida-agent@emb"
 
 mkdir -p "$priv_dir"
@@ -91,6 +92,11 @@ case $host_os in
     collect_unix_agent "$agent_emulated_modern" arm64
     collect_unix_agent "$agent_emulated_legacy" arm
 
+
+    if [ -f "$custom_script" ]; then
+      python3 "$custom_script" "$embedded_agent"
+    fi
+
     exec "$resource_compiler" --toolchain=gnu -c "$resource_config" -o "$output_dir/frida-data-agent" "${embedded_assets[@]}"
     ;;
 esac
diff --git a/src/frida-glue.c b/src/frida-glue.c
index ee8f0737..76ed813e 100644
--- a/src/frida-glue.c
+++ b/src/frida-glue.c
@@ -44,7 +44,7 @@ frida_init_with_runtime (FridaRuntime rt)
     {
       main_context = g_main_context_ref (g_main_context_default ());
       main_loop = g_main_loop_new (main_context, FALSE);
-      main_thread = g_thread_new ("frida-main-loop", run_main_loop, NULL);
+      main_thread = g_thread_new ("banana-main-loop", run_main_loop, NULL);
     }
 
     g_once_init_leave (&frida_initialized, TRUE);
diff --git a/src/frida.vala b/src/frida.vala
index 2f07a886..fee02670 100644
--- a/src/frida.vala
+++ b/src/frida.vala
@@ -2312,7 +2312,7 @@ namespace Frida {
 			dbus_context = yield get_dbus_context ();
 
 			var agent = new Nice.Agent.full (dbus_context, Nice.Compatibility.RFC5245, ICE_TRICKLE);
-			agent.set_software ("Frida");
+			agent.set_software ("Banana");
 			agent.controlling_mode = true;
 			agent.ice_tcp = false;
 
diff --git a/src/linux/frida-helper-backend.vala b/src/linux/frida-helper-backend.vala
index a4be8c42..114ee634 100644
--- a/src/linux/frida-helper-backend.vala
+++ b/src/linux/frida-helper-backend.vala
@@ -1213,7 +1213,7 @@ namespace Frida {
 		}
 
 		private static string make_fallback_address () {
-			return "/frida-" + Uuid.string_random ();
+			return "/banana-" + Uuid.string_random ();
 		}
 
 		private Future<RemoteAgent> establish_connection (LoaderLaunch launch, InjectSpec spec, BootstrapResult bres,
diff --git a/src/linux/frida-helper-process.vala b/src/linux/frida-helper-process.vala
index 7e5cf0cc..8e57b46c 100644
--- a/src/linux/frida-helper-process.vala
+++ b/src/linux/frida-helper-process.vala
@@ -315,7 +315,7 @@ namespace Frida {
 			TimeoutSource? timeout_source = null;
 
 			try {
-				string socket_path = "/frida-" + Uuid.string_random ();
+				string socket_path = "/banana-" + Uuid.string_random ();
 				string socket_address = "unix:abstract=" + socket_path;
 
 				service = new SocketService ();
@@ -622,11 +622,11 @@ namespace Frida {
 #if HAVE_EMBEDDED_ASSETS
 			var blob32 = Frida.Data.Helper.get_frida_helper_32_blob ();
 			if (blob32.data.length > 0)
-				helper32 = make_temporary_helper ("frida-helper-32", blob32.data);
+				helper32 = make_temporary_helper ("banana-helper-32", blob32.data);
 
 			var blob64 = Frida.Data.Helper.get_frida_helper_64_blob ();
 			if (blob64.data.length > 0)
-				helper64 = make_temporary_helper ("frida-helper-64", blob64.data);
+				helper64 = make_temporary_helper ("banana-helper-64", blob64.data);
 #else
 			var tpl = PathTemplate (Config.FRIDA_HELPER_PATH);
 			string path = tpl.expand ((sizeof (void *) == 8) ? "32" : "64");
diff --git a/src/linux/linjector.vala b/src/linux/linjector.vala
index 0dfa33d8..d65d498f 100644
--- a/src/linux/linjector.vala
+++ b/src/linux/linjector.vala
@@ -101,6 +101,7 @@ namespace Frida {
 		public async uint inject_library_fd (uint pid, UnixInputStream library_so, string entrypoint, string data,
 				AgentFeatures features, Cancellable? cancellable) throws Error, IOError {
 			uint id = next_injectee_id++;
+			print(entrypoint);
 			yield helper.inject_library (pid, library_so, entrypoint, data, features, id, cancellable);
 
 			pid_by_id[id] = pid;
@@ -255,7 +256,7 @@ namespace Frida {
 					throw new Error.NOT_SUPPORTED ("Kernel too old for memfd support");
 				FileDescriptor fd = MemoryFileDescriptor.from_bytes (name, blob);
 #if ANDROID
-				SELinux.fsetfilecon (fd.handle, "u:object_r:frida_memfd:s0");
+				SELinux.fsetfilecon (fd.handle, "u:object_r:banana_memfd:s0");
 #endif
 				_memfd = new UnixInputStream (fd.steal (), true);
 			}
@@ -266,14 +267,14 @@ namespace Frida {
 	private static void adjust_directory_permissions (string path) {
 		FileUtils.chmod (path, 0755);
 #if ANDROID
-		SELinux.setfilecon (path, "u:object_r:frida_file:s0");
+		SELinux.setfilecon (path, "u:object_r:banana_file:s0");
 #endif
 	}
 
 	private static void adjust_file_permissions (string path) {
 		FileUtils.chmod (path, path.has_suffix (".so") ? 0755 : 0644);
 #if ANDROID
-		SELinux.setfilecon (path, "u:object_r:frida_file:s0");
+		SELinux.setfilecon (path, "u:object_r:banana_file:s0");
 #endif
 	}
 }
diff --git a/src/linux/linux-host-session.vala b/src/linux/linux-host-session.vala
index 50470ac8..2447664f 100644
--- a/src/linux/linux-host-session.vala
+++ b/src/linux/linux-host-session.vala
@@ -128,12 +128,13 @@ namespace Frida {
 			var blob64 = Frida.Data.Agent.get_frida_agent_64_so_blob ();
 			var emulated_arm = Frida.Data.Agent.get_frida_agent_arm_so_blob ();
 			var emulated_arm64 = Frida.Data.Agent.get_frida_agent_arm64_so_blob ();
-			agent = new AgentDescriptor (PathTemplate ("frida-agent-<arch>.so"),
+			var random_prefix = GLib.Uuid.string_random();
+			agent = new AgentDescriptor (PathTemplate (random_prefix + "-<arch>.so"),
 				new Bytes.static (blob32.data),
 				new Bytes.static (blob64.data),
 				new AgentResource[] {
-					new AgentResource ("frida-agent-arm.so", new Bytes.static (emulated_arm.data), tempdir),
-					new AgentResource ("frida-agent-arm64.so", new Bytes.static (emulated_arm64.data), tempdir),
+					new AgentResource (random_prefix + "-arm.so", new Bytes.static (emulated_arm.data), tempdir),
+					new AgentResource (random_prefix + "-arm64.so", new Bytes.static (emulated_arm64.data), tempdir),
 				},
 				AgentMode.INSTANCED,
 				tempdir);
@@ -237,6 +238,7 @@ namespace Frida {
 			var app = yield system_server_agent.get_frontmost_application (opts, cancellable);
 			if (app.pid == 0)
 				return app;
+				
 
 			if (opts.scope != MINIMAL) {
 				var process_opts = new ProcessQueryOptions ();
@@ -426,10 +428,11 @@ namespace Frida {
 		protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
 				Cancellable? cancellable, out Object? transport) throws Error, IOError {
 			uint id;
-			string entrypoint = "frida_agent_main";
+			string entrypoint = "banana_main"; 
 			string parameters = make_agent_parameters (pid, "", options);
 			AgentFeatures features = CONTROL_CHANNEL;
 			var linjector = (Linjector) injector;
+
 #if HAVE_EMBEDDED_ASSETS
 			id = yield linjector.inject_library_resource (pid, agent, entrypoint, parameters, features, cancellable);
 #else
diff --git a/src/qnx/qnx-host-session.vala b/src/qnx/qnx-host-session.vala
index 69f2995f..e3bfc64b 100644
--- a/src/qnx/qnx-host-session.vala
+++ b/src/qnx/qnx-host-session.vala
@@ -182,7 +182,7 @@ namespace Frida {
 
 			var stream_request = Pipe.open (t.local_address, cancellable);
 
-			var id = yield qinjector.inject_library_resource (pid, agent_desc, "frida_agent_main",
+			var id = yield qinjector.inject_library_resource (pid, agent_desc, "banana_agent_main",
 				make_agent_parameters (pid, t.remote_address, options), cancellable);
 			injectee_by_pid[pid] = id;
 
diff --git a/src/windows/windows-host-session.vala b/src/windows/windows-host-session.vala
index 67f1f3ef..b5eba406 100644
--- a/src/windows/windows-host-session.vala
+++ b/src/windows/windows-host-session.vala
@@ -274,7 +274,7 @@ namespace Frida {
 			var stream_request = Pipe.open (t.local_address, cancellable);
 
 			var winjector = injector as Winjector;
-			var id = yield winjector.inject_library_resource (pid, agent, "frida_agent_main",
+			var id = yield winjector.inject_library_resource (pid, agent, ""main",
 				make_agent_parameters (pid, t.remote_address, options), cancellable);
 			injectee_by_pid[pid] = id;
 
diff --git a/tests/test-agent.vala b/tests/test-agent.vala
index 62fb8260..6e5eba51 100644
--- a/tests/test-agent.vala
+++ b/tests/test-agent.vala
@@ -449,7 +449,7 @@ Interceptor.attach(Module.getExportByName('libsystem_kernel.dylib', 'open'), ()
 			assert_nonnull (module);
 
 			void * main_func_symbol;
-			var main_func_found = module.symbol ("frida_agent_main", out main_func_symbol);
+			var main_func_found = module.symbol ("main", out main_func_symbol);
 			assert_true (main_func_found);
 			main_impl = (AgentMainFunc) main_func_symbol;
 
diff --git a/tests/test-injector.vala b/tests/test-injector.vala
index f4a321c4..448bddf3 100644
--- a/tests/test-injector.vala
+++ b/tests/test-injector.vala
@@ -258,7 +258,7 @@ namespace Frida.InjectorTest {
 				var path = Frida.Test.Labrats.path_to_library (name, arch);
 				assert_true (FileUtils.test (path, FileTest.EXISTS));
 
-				yield injector.inject_library_file (process.id, path, "frida_agent_main", data);
+				yield injector.inject_library_file (process.id, path, "main", data);
 			} catch (GLib.Error e) {
 				printerr ("\nFAIL: %s\n\n", e.message);
 				assert_not_reached ();

```

`frida-gum/patch.patch`:

```patch
diff --git a/.cirrus.yml b/.cirrus.yml
index 4fddac53..75de1e90 100644
--- a/.cirrus.yml
+++ b/.cirrus.yml
@@ -1,7 +1,7 @@
 task:
   name: freebsd-x86_64
   freebsd_instance:
-    image_family: freebsd-13-2
+    image_family: freebsd-13-1
   install_script: |
     pkg install -y \
       git \
diff --git a/bindings/gumjs/gumquickprocess.c b/bindings/gumjs/gumquickprocess.c
index ed2c9968..5db95104 100644
--- a/bindings/gumjs/gumquickprocess.c
+++ b/bindings/gumjs/gumquickprocess.c
@@ -1,7 +1,6 @@
 /*
  * Copyright (C) 2020-2022 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2020-2023 Francesco Tamagni <mrmacete@protonmail.ch>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -292,13 +291,6 @@ gum_emit_thread (const GumThreadDetails * details,
       GUM_QUICK_CORE_ATOM (core, id),
       JS_NewInt64 (ctx, details->id),
       JS_PROP_C_W_E);
-  if (details->name != NULL)
-  {
-    JS_DefinePropertyValue (ctx, thread,
-        GUM_QUICK_CORE_ATOM (core, name),
-        JS_NewString (ctx, details->name),
-        JS_PROP_C_W_E);
-  }
   JS_DefinePropertyValue (ctx, thread,
       GUM_QUICK_CORE_ATOM (core, state),
       _gum_quick_thread_state_new (ctx, details->state),
diff --git a/bindings/gumjs/gumscriptscheduler.c b/bindings/gumjs/gumscriptscheduler.c
index b86a6c57..2459c874 100644
--- a/bindings/gumjs/gumscriptscheduler.c
+++ b/bindings/gumjs/gumscriptscheduler.c
@@ -114,7 +114,7 @@ gum_script_scheduler_start (GumScriptScheduler * self)
   {
     self->js_loop = g_main_loop_new (self->js_context, TRUE);
 
-    self->js_thread = g_thread_new ("gum-js-loop",
+    self->js_thread = g_thread_new ("banana-gjs-loop",
         (GThreadFunc) gum_script_scheduler_run_js_loop, self);
   }
 }
diff --git a/bindings/gumjs/gumv8process.cpp b/bindings/gumjs/gumv8process.cpp
index 56942790..19eaf571 100644
--- a/bindings/gumjs/gumv8process.cpp
+++ b/bindings/gumjs/gumv8process.cpp
@@ -1,7 +1,6 @@
 /*
  * Copyright (C) 2010-2022 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2020-2023 Francesco Tamagni <mrmacete@protonmail.ch>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -252,8 +251,6 @@ gum_emit_thread (const GumThreadDetails * details,
 
   auto thread = Object::New (isolate);
   _gum_v8_object_set (thread, "id", Number::New (isolate, details->id), core);
-  if (details->name != NULL)
-    _gum_v8_object_set_utf8 (thread, "name", details->name, core);
   _gum_v8_object_set (thread, "state", _gum_v8_string_new_ascii (isolate,
       _gum_v8_thread_state_to_string (details->state)), core);
   auto cpu_context =
diff --git a/gum/backend-darwin/gumprocess-darwin.c b/gum/backend-darwin/gumprocess-darwin.c
index 0e7d39ca..a620827e 100644
--- a/gum/backend-darwin/gumprocess-darwin.c
+++ b/gum/backend-darwin/gumprocess-darwin.c
@@ -4,7 +4,6 @@
  * Copyright (C) 2022-2023 Francesco Tamagni <mrmacete@protonmail.ch>
  * Copyright (C) 2022 Håvard Sørbø <havard@hsorbo.no>
  * Copyright (C) 2023 Alex Soler <asoler@nowsecure.com>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -1499,7 +1498,6 @@ gum_darwin_enumerate_threads (mach_port_t task,
       thread_basic_info_data_t info;
       mach_msg_type_number_t info_count = THREAD_BASIC_INFO_COUNT;
       GumDarwinUnifiedThreadState state;
-      gchar thread_name[64];
 
       kr = thread_info (thread, THREAD_BASIC_INFO, (thread_info_t) &info,
           &info_count);
@@ -1521,21 +1519,7 @@ gum_darwin_enumerate_threads (mach_port_t task,
 #endif
 
       details.id = (GumThreadId) thread;
-
-      details.name = NULL;
-      if (task == self)
-      {
-        pthread_t th = pthread_from_mach_thread_np (thread);
-        if (th != NULL)
-        {
-          pthread_getname_np (th, thread_name, sizeof (thread_name));
-          if (thread_name[0] != '\0')
-            details.name = thread_name;
-        }
-      }
-
       details.state = gum_thread_state_from_darwin (info.run_state);
-
       gum_darwin_parse_unified_thread_state (&state, &details.cpu_context);
 
       if (!func (&details, user_data))
diff --git a/gum/backend-freebsd/gumprocess-freebsd.c b/gum/backend-freebsd/gumprocess-freebsd.c
index 4740d7b4..e8bfebd6 100644
--- a/gum/backend-freebsd/gumprocess-freebsd.c
+++ b/gum/backend-freebsd/gumprocess-freebsd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
+ * Copyright (C) 2022-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2023 Francesco Tamagni <mrmacete@protonmail.ch>
  *
  * Licence: wxWindows Library Licence, Version 3.1
@@ -408,7 +408,6 @@ _gum_process_enumerate_threads (GumFoundThreadFunc func,
     GumThreadDetails details;
 
     details.id = p->ki_tid;
-    details.name = (p->ki_tdname[0] != '\0') ? p->ki_tdname : NULL;
     details.state = gum_thread_state_from_proc (p);
     if (!gum_process_modify_thread (details.id, gum_store_cpu_context,
           &details.cpu_context, GUM_MODIFY_THREAD_FLAGS_ABORT_SAFELY))
diff --git a/gum/backend-linux/gumprocess-linux.c b/gum/backend-linux/gumprocess-linux.c
index f9e2d6a1..26183feb 100644
--- a/gum/backend-linux/gumprocess-linux.c
+++ b/gum/backend-linux/gumprocess-linux.c
@@ -2,7 +2,6 @@
  * Copyright (C) 2010-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2023 Håvard Sørbø <havard@hsorbo.no>
  * Copyright (C) 2023 Francesco Tamagni <mrmacete@protonmail.ch>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -258,7 +257,6 @@ static void gum_proc_maps_iter_init_for_path (GumProcMapsIter * iter,
 static void gum_acquire_dumpability (void);
 static void gum_release_dumpability (void);
 
-static gchar * gum_thread_read_name (GumThreadId thread_id);
 static gboolean gum_thread_read_state (GumThreadId tid, GumThreadState * state);
 static GumThreadState gum_thread_state_from_proc_status_character (gchar c);
 static GumPageProtection gum_page_protection_from_proc_perms_string (
@@ -723,6 +721,7 @@ gboolean
 gum_process_has_thread (GumThreadId thread_id)
 {
   gchar path[16 + 20 + 1];
+
   sprintf (path, "/proc/self/task/%" G_GSIZE_MODIFIER "u", thread_id);
 
   return g_file_test (path, G_FILE_TEST_EXISTS);
@@ -1022,13 +1021,8 @@ _gum_process_enumerate_threads (GumFoundThreadFunc func,
   while (carry_on && (name = g_dir_read_name (dir)) != NULL)
   {
     GumThreadDetails details;
-    gchar * thread_name;
 
     details.id = atoi (name);
-
-    thread_name = gum_thread_read_name (details.id);
-    details.name = thread_name;
-
     if (gum_thread_read_state (details.id, &details.state))
     {
       if (gum_process_modify_thread (details.id, gum_store_cpu_context,
@@ -1037,8 +1031,6 @@ _gum_process_enumerate_threads (GumFoundThreadFunc func,
         carry_on = func (&details, user_data);
       }
     }
-
-    g_free (thread_name);
   }
 
   g_dir_close (dir);
@@ -2679,26 +2671,6 @@ gum_unparse_regs (const GumCpuContext * ctx,
 #endif
 }
 
-static gchar *
-gum_thread_read_name (GumThreadId thread_id)
-{
-  gchar * name = NULL;
-  gchar * path;
-  gchar * comm = NULL;
-
-  path = g_strdup_printf ("/proc/self/task/%" G_GSIZE_FORMAT "/comm",
-      thread_id);
-  if (!g_file_get_contents (path, &comm, NULL, NULL))
-    goto beach;
-  name = g_strchomp (g_steal_pointer (&comm));
-
-beach:
-  g_free (comm);
-  g_free (path);
-
-  return name;
-}
-
 static gboolean
 gum_thread_read_state (GumThreadId tid,
                        GumThreadState * state)
diff --git a/gum/backend-posix/gummemory-posix.c b/gum/backend-posix/gummemory-posix.c
index 848b430a..6be5b5a8 100644
--- a/gum/backend-posix/gummemory-posix.c
+++ b/gum/backend-posix/gummemory-posix.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2008-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
+ * Copyright (C) 2008-2022 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -34,14 +34,12 @@ struct _GumEnumerateFreeRangesContext
   GumAddress prev_end;
 };
 
-static gpointer gum_memory_allocate_internal (gpointer address, gsize size,
-    gsize alignment, GumPageProtection prot, gint extra_flags);
 static gboolean gum_try_alloc_in_range_if_near_enough (
     const GumRangeDetails * details, gpointer user_data);
 static gboolean gum_try_suggest_allocation_base (const GumMemoryRange * range,
     const GumAllocNearContext * ctx, gpointer * allocation_base);
 static gpointer gum_allocate_page_aligned (gpointer address, gsize size,
-    gint prot, gint extra_flags);
+    gint prot);
 static void gum_enumerate_free_ranges (GumFoundRangeFunc func,
     gpointer user_data);
 static gboolean gum_emit_free_range (const GumRangeDetails * details,
@@ -123,16 +121,6 @@ gum_memory_allocate (gpointer address,
                      gsize size,
                      gsize alignment,
                      GumPageProtection prot)
-{
-  return gum_memory_allocate_internal (address, size, alignment, prot, 0);
-}
-
-static gpointer
-gum_memory_allocate_internal (gpointer address,
-                              gsize size,
-                              gsize alignment,
-                              GumPageProtection prot,
-                              gint extra_flags)
 {
   gsize page_size, allocation_size;
   guint8 * base, * aligned_base;
@@ -144,7 +132,7 @@ gum_memory_allocate_internal (gpointer address,
   allocation_size = GUM_ALIGN_SIZE (allocation_size, page_size);
 
   base = gum_allocate_page_aligned (address, allocation_size,
-      _gum_page_protection_to_posix (prot), extra_flags);
+      _gum_page_protection_to_posix (prot));
   if (base == NULL)
     return NULL;
 
@@ -209,16 +197,6 @@ gum_try_alloc_in_range_if_near_enough (const GumRangeDetails * details,
   if (!gum_try_suggest_allocation_base (details->range, ctx, &suggested_base))
     goto keep_looking;
 
-#ifdef HAVE_FREEBSD
-  received_base = gum_memory_allocate_internal (suggested_base, ctx->size,
-      ctx->alignment, ctx->prot, MAP_FIXED | MAP_EXCL);
-  if (received_base != NULL)
-  {
-    ctx->result = received_base;
-    return FALSE;
-  }
-#endif
-
   received_base = gum_memory_allocate (suggested_base, ctx->size,
       ctx->alignment, ctx->prot);
   if (received_base == NULL)
@@ -267,29 +245,29 @@ gum_try_suggest_allocation_base (const GumMemoryRange * range,
 static gpointer
 gum_allocate_page_aligned (gpointer address,
                            gsize size,
-                           gint prot,
-                           gint extra_flags)
+                           gint prot)
 {
   gpointer result;
-  const gint base_flags = MAP_PRIVATE | MAP_ANONYMOUS | extra_flags;
-  gint region_flags = 0;
+  int extra_flags = 0;
 
 #if defined (HAVE_FREEBSD) && GLIB_SIZEOF_VOID_P == 8
   if (address != NULL &&
       GPOINTER_TO_SIZE (address) + size < G_MAXUINT32)
   {
-    region_flags |= MAP_32BIT;
+    extra_flags |= MAP_32BIT;
   }
 #endif
 
-  result = mmap (address, size, prot, base_flags | region_flags, -1, 0);
+  result = mmap (address, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | extra_flags,
+      -1, 0);
 
 #if defined (HAVE_FREEBSD) && GLIB_SIZEOF_VOID_P == 8
-  if (result == MAP_FAILED && (region_flags & MAP_32BIT) != 0)
+  if (result == MAP_FAILED && (extra_flags & MAP_32BIT) != 0)
   {
-    result = mmap (NULL, size, prot, base_flags | region_flags, -1, 0);
+    result = mmap (NULL, size, prot, MAP_PRIVATE | MAP_ANONYMOUS |
+        extra_flags, -1, 0);
     if (result == MAP_FAILED)
-      result = mmap (address, size, prot, base_flags, -1, 0);
+      result = mmap (address, size, prot, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
   }
 #endif
 
diff --git a/gum/backend-qnx/gumprocess-qnx.c b/gum/backend-qnx/gumprocess-qnx.c
index 742cf595..1c863a68 100644
--- a/gum/backend-qnx/gumprocess-qnx.c
+++ b/gum/backend-qnx/gumprocess-qnx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
+ * Copyright (C) 2015-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2023 Francesco Tamagni <mrmacete@protonmail.ch>
  *
  * Licence: wxWindows Library Licence, Version 3.1
@@ -238,20 +238,8 @@ _gum_process_enumerate_threads (GumFoundThreadFunc func,
       (devctl (fd, DCMD_PROC_TIDSTATUS, &thread, sizeof (thread), NULL) == 0))
   {
     GumThreadDetails details;
-    gchar thread_name[_NTO_THREAD_NAME_MAX];
 
     details.id = thread.tid;
-
-    if (pthread_getname_np (thread.tid, thread_name,
-          sizeof (thread_name)) == 0 && thread_name[0] != '\0')
-    {
-      details.name = thread_name;
-    }
-    else
-    {
-      details.name = NULL;
-    }
-
     details.state = gum_thread_state_from_system_thread_state (thread.state);
 
     if (thread.state != STATE_DEAD &&
diff --git a/gum/backend-windows/gumprocess-windows.c b/gum/backend-windows/gumprocess-windows.c
index 5a99772e..72cc3566 100644
--- a/gum/backend-windows/gumprocess-windows.c
+++ b/gum/backend-windows/gumprocess-windows.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2009-2024 Ole André Vadla Ravnås <oleavr@nowsecure.com>
+ * Copyright (C) 2009-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2023 Francesco Tamagni <mrmacete@protonmail.ch>
  *
  * Licence: wxWindows Library Licence, Version 3.1
@@ -21,8 +21,6 @@
 # pragma GCC diagnostic ignored "-Warray-bounds"
 #endif
 
-typedef HRESULT (WINAPI * GumGetThreadDescriptionFunc) (
-    HANDLE thread, WCHAR ** description);
 typedef void (WINAPI * GumGetCurrentThreadStackLimitsFunc) (
     PULONG_PTR low_limit, PULONG_PTR high_limit);
 typedef struct _GumEnumerateSymbolsContext GumEnumerateSymbolsContext;
@@ -208,10 +206,6 @@ gum_windows_get_thread_details (DWORD thread_id,
                                 GumThreadDetails * details)
 {
   gboolean success = FALSE;
-  static gsize initialized = FALSE;
-  static GumGetThreadDescriptionFunc get_thread_description;
-  static DWORD desired_access;
-  HANDLE thread = NULL;
 #ifdef _MSC_VER
   __declspec (align (64))
 #endif
@@ -221,43 +215,8 @@ gum_windows_get_thread_details (DWORD thread_id,
 #endif
         = { 0, };
 
-  memset (details, 0, sizeof (GumThreadDetails));
-
-  if (g_once_init_enter (&initialized))
-  {
-    get_thread_description = (GumGetThreadDescriptionFunc) GetProcAddress (
-        GetModuleHandle (_T ("kernel32.dll")),
-        "GetThreadDescription");
-
-    desired_access = THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME;
-    if (get_thread_description != NULL)
-      desired_access |= THREAD_QUERY_LIMITED_INFORMATION;
-
-    g_once_init_leave (&initialized, TRUE);
-  }
-
-  thread = OpenThread (desired_access, FALSE, thread_id);
-  if (thread == NULL)
-    goto beach;
-
   details->id = thread_id;
 
-  if (get_thread_description != NULL)
-  {
-    WCHAR * name_utf16;
-
-    if (!SUCCEEDED (get_thread_description (thread, &name_utf16)))
-      goto beach;
-
-    if (name_utf16[0] != L'\0')
-    {
-      details->name = g_utf16_to_utf8 ((const gunichar2 *) name_utf16, -1, NULL,
-          NULL, NULL);
-    }
-
-    LocalFree (name_utf16);
-  }
-
   if (thread_id == GetCurrentThreadId ())
   {
     details->state = GUM_THREAD_RUNNING;
@@ -269,34 +228,36 @@ gum_windows_get_thread_details (DWORD thread_id,
   }
   else
   {
-    DWORD previous_suspend_count;
+    HANDLE thread;
 
-    previous_suspend_count = SuspendThread (thread);
-    if (previous_suspend_count == (DWORD) -1)
-      goto beach;
+    thread = OpenThread (THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, FALSE,
+        thread_id);
+    if (thread != NULL)
+    {
+      DWORD previous_suspend_count;
 
-    if (previous_suspend_count == 0)
-      details->state = GUM_THREAD_RUNNING;
-    else
-      details->state = GUM_THREAD_STOPPED;
+      previous_suspend_count = SuspendThread (thread);
+      if (previous_suspend_count != (DWORD) -1)
+      {
+        if (previous_suspend_count == 0)
+          details->state = GUM_THREAD_RUNNING;
+        else
+          details->state = GUM_THREAD_STOPPED;
+
+        context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
+        if (GetThreadContext (thread, &context))
+        {
+          gum_windows_parse_context (&context, &details->cpu_context);
+          success = TRUE;
+        }
+
+        ResumeThread (thread);
+      }
 
-    context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
-    if (GetThreadContext (thread, &context))
-    {
-      gum_windows_parse_context (&context, &details->cpu_context);
-      success = TRUE;
+      CloseHandle (thread);
     }
-
-    ResumeThread (thread);
   }
 
-beach:
-  if (thread != NULL)
-    CloseHandle (thread);
-
-  if (!success)
-    g_free ((gpointer) details->name);
-
   return success;
 }
 
diff --git a/gum/gumprocess.h b/gum/gumprocess.h
index 0b6bb9c2..8476d361 100644
--- a/gum/gumprocess.h
+++ b/gum/gumprocess.h
@@ -1,7 +1,6 @@
 /*
  * Copyright (C) 2008-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2020-2024 Francesco Tamagni <mrmacete@protonmail.ch>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -60,7 +59,6 @@ typedef enum {
 struct _GumThreadDetails
 {
   GumThreadId id;
-  const gchar * name;
   GumThreadState state;
   GumCpuContext cpu_context;
 };
diff --git a/meson.build b/meson.build
index 0ad28b24..10206c23 100644
--- a/meson.build
+++ b/meson.build
@@ -607,7 +607,7 @@ configure_file(
 
 add_project_arguments(
   (cc.get_argument_syntax() == 'msvc') ? '/FI' : '-include', meson.current_build_dir() / 'config.h',
-  '-DG_LOG_DOMAIN="Frida"',
+  '-DG_LOG_DOMAIN="Banana"',
   '-DGLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_56',
   '-DG_DISABLE_DEPRECATED',
   language: languages)
diff --git a/tests/core/process.c b/tests/core/process.c
index 8fa67d81..f8c6d36b 100644
--- a/tests/core/process.c
+++ b/tests/core/process.c
@@ -2,7 +2,6 @@
  * Copyright (C) 2008-2023 Ole André Vadla Ravnås <oleavr@nowsecure.com>
  * Copyright (C) 2008 Christian Berentsen <jc.berentsen@gmail.com>
  * Copyright (C) 2015 Asger Hautop Drewsen <asgerdrewsen@gmail.com>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -35,7 +34,6 @@
 TESTLIST_BEGIN (process)
   TESTENTRY (process_threads)
   TESTENTRY (process_threads_exclude_cloaked)
-  TESTENTRY (process_threads_should_include_name)
   TESTENTRY (process_modules)
   TESTENTRY (process_ranges)
   TESTENTRY (process_ranges_exclude_cloaked)
@@ -108,7 +106,6 @@ struct _TestThreadSyncData
 {
   GMutex mutex;
   GCond cond;
-  const gchar * name;
   volatile gboolean started;
   volatile GumThreadId thread_id;
   volatile gboolean * volatile done;
@@ -147,15 +144,13 @@ static gboolean process_potential_export_search_result (
     const GumExportDetails * details, gpointer user_data);
 #endif
 
-static GThread * create_sleeping_dummy_thread_sync (const gchar * name,
-    volatile gboolean * done, GumThreadId * thread_id);
+static GThread * create_sleeping_dummy_thread_sync (volatile gboolean * done,
+    GumThreadId * thread_id);
 static gpointer sleeping_dummy (gpointer data);
 static gboolean thread_found_cb (const GumThreadDetails * details,
     gpointer user_data);
 static gboolean thread_check_cb (const GumThreadDetails * details,
     gpointer user_data);
-static gboolean thread_collect_if_matching_id (const GumThreadDetails * details,
-    gpointer user_data);
 static gboolean module_found_cb (const GumModuleDetails * details,
     gpointer user_data);
 static gboolean import_found_cb (const GumImportDetails * details,
@@ -190,10 +185,8 @@ TESTCASE (process_threads)
   if (!check_thread_enumeration_testable ())
     return;
 
-  thread_a = create_sleeping_dummy_thread_sync ("process-test-sleeping-dummy-a",
-      &done, NULL);
-  thread_b = create_sleeping_dummy_thread_sync ("process-test-sleeping-dummy-b",
-      &done, NULL);
+  thread_a = create_sleeping_dummy_thread_sync (&done, NULL);
+  thread_b = create_sleeping_dummy_thread_sync (&done, NULL);
 
   ctx.number_of_calls = 0;
   ctx.value_to_return = TRUE;
@@ -219,8 +212,7 @@ TESTCASE (process_threads_exclude_cloaked)
   if (!check_thread_enumeration_testable ())
     return;
 
-  thread = create_sleeping_dummy_thread_sync ("process-test-sleeping-dummy",
-      &done, &ctx.needle);
+  thread = create_sleeping_dummy_thread_sync (&done, &ctx.needle);
 
   ctx.found = FALSE;
   gum_process_enumerate_threads (thread_check_cb, &ctx);
@@ -238,26 +230,6 @@ TESTCASE (process_threads_exclude_cloaked)
   g_thread_join (thread);
 }
 
-TESTCASE (process_threads_should_include_name)
-{
-  volatile gboolean done = FALSE;
-  GThread * thread;
-  GumThreadDetails d = { 0, };
-
-  if (!check_thread_enumeration_testable ())
-    return;
-
-  thread = create_sleeping_dummy_thread_sync ("named", &done, &d.id);
-  gum_process_enumerate_threads (thread_collect_if_matching_id, &d);
-
-  g_assert_cmpstr (d.name, ==, "named");
-
-  done = TRUE;
-  g_thread_join (thread);
-
-  g_free ((gpointer) d.name);
-}
-
 static gboolean
 check_thread_enumeration_testable (void)
 {
@@ -1103,8 +1075,7 @@ process_potential_export_search_result (const GumExportDetails * details,
 #endif
 
 static GThread *
-create_sleeping_dummy_thread_sync (const gchar * name,
-                                   volatile gboolean * done,
+create_sleeping_dummy_thread_sync (volatile gboolean * done,
                                    GumThreadId * thread_id)
 {
   TestThreadSyncData sync_data;
@@ -1114,12 +1085,12 @@ create_sleeping_dummy_thread_sync (const gchar * name,
   g_cond_init (&sync_data.cond);
   sync_data.started = FALSE;
   sync_data.thread_id = 0;
-  sync_data.name = name;
   sync_data.done = done;
 
   g_mutex_lock (&sync_data.mutex);
 
-  thread = g_thread_new (name, sleeping_dummy, &sync_data);
+  thread = g_thread_new ("process-test-sleeping-dummy", sleeping_dummy,
+      &sync_data);
 
   while (!sync_data.started)
     g_cond_wait (&sync_data.cond, &sync_data.mutex);
@@ -1141,15 +1112,6 @@ sleeping_dummy (gpointer data)
   TestThreadSyncData * sync_data = data;
   volatile gboolean * done = sync_data->done;
 
-  /*
-   * On Linux g_thread_new() may not actually set the thread name, which is due
-   * to GLib potentially having been prebuilt against an old libc. Therefore we
-   * set the name manually using pthreads.
-   */
-#ifdef HAVE_LINUX
-  pthread_setname_np (pthread_self (), sync_data->name);
-#endif
-
   g_mutex_lock (&sync_data->mutex);
   sync_data->started = TRUE;
   sync_data->thread_id = gum_process_get_current_thread_id ();
@@ -1185,22 +1147,6 @@ thread_check_cb (const GumThreadDetails * details,
   return !ctx->found;
 }
 
-static gboolean
-thread_collect_if_matching_id (const GumThreadDetails * details,
-                               gpointer user_data)
-{
-  GumThreadDetails * ctx = user_data;
-
-  if (details->id != ctx->id)
-    return TRUE;
-
-  ctx->name = g_strdup (details->name);
-  ctx->state = details->state;
-  ctx->cpu_context = details->cpu_context;
-
-  return FALSE;
-}
-
 static gboolean
 module_found_cb (const GumModuleDetails * details,
                  gpointer user_data)
diff --git a/tests/gumjs/script.c b/tests/gumjs/script.c
index a1bcbdd6..99f2ed26 100644
--- a/tests/gumjs/script.c
+++ b/tests/gumjs/script.c
@@ -4,7 +4,6 @@
  * Copyright (C) 2020-2021 Francesco Tamagni <mrmacete@protonmail.ch>
  * Copyright (C) 2020 Marcus Mengs <mame8282@googlemail.com>
  * Copyright (C) 2021 Abdelrahman Eid <hot3eed@gmail.com>
- * Copyright (C) 2023 Grant Douglas <me@hexplo.it>
  *
  * Licence: wxWindows Library Licence, Version 3.1
  */
@@ -196,7 +195,6 @@ TESTLIST_BEGIN (script)
     TESTENTRY (process_current_thread_id_is_available)
     TESTENTRY (process_threads_can_be_enumerated)
     TESTENTRY (process_threads_can_be_enumerated_legacy_style)
-    TESTENTRY (process_threads_have_names)
     TESTENTRY (process_modules_can_be_enumerated)
     TESTENTRY (process_modules_can_be_enumerated_legacy_style)
     TESTENTRY (process_module_can_be_looked_up_from_address)
@@ -498,7 +496,6 @@ TESTLIST_END ()
 
 typedef int (* TargetFunctionInt) (int arg);
 typedef struct _GumInvokeTargetContext GumInvokeTargetContext;
-typedef struct _GumNamedSleeperContext GumNamedSleeperContext;
 typedef struct _GumCrashExceptorContext GumCrashExceptorContext;
 typedef struct _TestTrigger TestTrigger;
 
@@ -510,12 +507,6 @@ struct _GumInvokeTargetContext
   volatile gint finished;
 };
 
-struct _GumNamedSleeperContext
-{
-  GAsyncQueue * controller_messages;
-  GAsyncQueue * sleeper_messages;
-};
-
 struct _GumCrashExceptorContext
 {
   gboolean called;
@@ -568,7 +559,6 @@ static gpointer run_stalked_through_target_function (gpointer data);
 #endif
 
 static gpointer sleeping_dummy (gpointer data);
-static gpointer named_sleeper (gpointer data);
 
 static gpointer invoke_target_function_int_worker (gpointer data);
 static gpointer invoke_target_function_trigger (gpointer data);
@@ -5005,7 +4995,7 @@ TESTCASE (process_threads_can_be_enumerated_legacy_style)
     return;
 #endif
 
-#if defined (HAVE_MIPS)
+#if defined (HAVE_ANDROID) || defined (HAVE_MIPS)
   if (!g_test_slow ())
   {
     g_print ("<skipping, run in slow mode> ");
@@ -5050,64 +5040,6 @@ sleeping_dummy (gpointer data)
   return NULL;
 }
 
-TESTCASE (process_threads_have_names)
-{
-  GumNamedSleeperContext ctx;
-  GThread * thread;
-
-#ifdef HAVE_LINUX
-  if (!check_exception_handling_testable ())
-    return;
-#endif
-
-#ifdef HAVE_MIPS
-  if (!g_test_slow ())
-  {
-    g_print ("<skipping, run in slow mode> ");
-    return;
-  }
-#endif
-
-  ctx.controller_messages = g_async_queue_new ();
-  ctx.sleeper_messages = g_async_queue_new ();
-
-  thread = g_thread_new ("named-sleeper", named_sleeper, &ctx);
-  g_assert_cmpstr (g_async_queue_pop (ctx.controller_messages), ==, "ready");
-
-  COMPILE_AND_LOAD_SCRIPT (
-      "send(Process.enumerateThreads().some(t => t.name === 'named-sleeper'));"
-  );
-  EXPECT_SEND_MESSAGE_WITH ("true");
-  EXPECT_NO_MESSAGES ();
-
-  g_async_queue_push (ctx.sleeper_messages, "done");
-  g_thread_join (thread);
-
-  g_async_queue_unref (ctx.sleeper_messages);
-  g_async_queue_unref (ctx.controller_messages);
-}
-
-static gpointer
-named_sleeper (gpointer data)
-{
-  GumNamedSleeperContext * ctx = data;
-
-  /*
-   * On Linux g_thread_new() may not actually set the thread name, which is due
-   * to GLib potentially having been prebuilt against an old libc. Therefore we
-   * set the name manually using pthreads.
-   */
-#ifdef HAVE_LINUX
-  pthread_setname_np (pthread_self (), "named-sleeper");
-#endif
-
-  g_async_queue_push (ctx->controller_messages, "ready");
-
-  g_assert_cmpstr (g_async_queue_pop (ctx->sleeper_messages), ==, "done");
-
-  return NULL;
-}
-
 TESTCASE (process_modules_can_be_enumerated)
 {
   COMPILE_AND_LOAD_SCRIPT (
diff --git a/tests/run-corellium.sh b/tests/run-corellium.sh
deleted file mode 100755
index c10df3a9..00000000
--- a/tests/run-corellium.sh
+++ /dev/null
@@ -1,75 +0,0 @@
-#!/bin/bash
-
-host_os=$1
-host_arch=arm64
-
-case $host_os in
-  ios)
-    device="ios-12.5.7-arm64"
-    ;;
-  android)
-    device="android-8.1.0-arm64"
-    ;;
-  *)
-    echo "Usage: $0 ios|android" > /dev/stderr
-    exit 1
-esac
-
-if [ -z "$GH_TOKEN" ]; then
-  echo "Missing GH_TOKEN environment variable" > /dev/stderr
-  exit 1
-fi
-
-build_os=$(echo $(uname -s | tr '[A-Z]' '[a-z]' | sed 's,^darwin$,macos,'))
-build_arch=$(uname -m)
-
-gum_tests=$(dirname "$0")
-
-runner_tarball=$(mktemp -t gum-tests.XXXXXX)
-runner_script=$(mktemp -t gum-tests.XXXXXX)
-
-function dispose {
-  rm -f "$runner_tarball"
-  rm -f "$runner_script"
-}
-trap dispose EXIT
-
-set -ex
-
-cd "$gum_tests/../../build"
-. frida-env-$build_os-$build_arch.rc
-
-cd tmp-$host_os-$host_arch/frida-gum
-ninja
-
-cd tests
-tar czf "$runner_tarball" gum-tests data/
-
-case $host_os in
-  ios)
-    cat << EOF > "$runner_script"
-cd /usr/local
-rm -rf opt/frida
-mkdir -p opt/frida
-cd opt/frida
-tar xf \$ASSET_PATH
-./gum-tests
-EOF
-    ;;
-  android)
-    cat << EOF > "$runner_script"
-cd /data/local/tmp
-tar xf \$ASSET_PATH
-./gum-tests
-EOF
-    ;;
-esac
-
-curl \
-    https://corellium.frida.re/devices/$device \
-    --form "asset=@$runner_tarball" \
-    --form "script=<$runner_script" \
-    --form-string $'marker=\n*** Finished with exit code: ' \
-    --form-string "token=$GH_TOKEN" \
-    -N \
-    -v

```